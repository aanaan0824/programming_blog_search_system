{"blogid": "126309634", "writerAge": "码龄1年", "writerBlogNum": "171", "writerCollect": "3701", "writerComment": "4184", "writerFan": "13559", "writerGrade": "7级", "writerIntegral": "14422", "writerName": "未见花闻", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126309634.jpg", "writerRankTotal": "693", "writerRankWeekly": "144", "writerThumb": "5513", "writerVisitNum": "199965", "blog_read_count": "707", "blog_time": "于 2022-08-14 08:00:00 发布", "blog_title": "HashMap与HashSet的底层实现原理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><font color=\"#87CEFA\" size=\"4\">⭐️<strong>前面的话</strong>⭐️</font></p>\n<p>本篇文章将介绍Java中HashMap的底层实现原理，有关HashMap为数组开辟内存的时期，默认的容量，默认负载因子，树化的条件，HashMap的扩容机制，put方法的过程以及HashMap中的哈希函数。</p>\n<p><strong>小贴士：博主推荐-&gt;</strong><a href=\"https://www.nowcoder.com/link/pc_csdncpt_wjhw_java2\">学习面试刷题必用工具</a></p>\n<blockquote>\n<p>📒博客主页：<a href=\"https://weijianhuawen.blog.csdn.net/\">未见花闻的博客主页</a><br/> 🎉欢迎关注🔎点赞👍收藏⭐️留言📝<br/> 📌本文由<strong>未见花闻</strong>原创，<strong>CSDN</strong>首发！<br/> 📆首发时间：🌴2022年8月14日🌴<br/> ✉️坚持和努力一定能换来诗与远方！<br/> 💭推荐书籍：📚《数据结构》，📚《算法导论》<br/> 💬参考在线编程网站：🌐<a href=\"https://www.nowcoder.com/link/pc_csdncpt_wjhw_java2\">牛客网</a>🌐<a href=\"https://leetcode-cn.com/\">力扣</a><br/> <a href=\"https://gitee.com/weijianhuawen\">博主的码云gitee，平常博主写的程序代码都在里面。</a><br/> <a href=\"https://github.com/weijianhuawen\">博主的github，平常博主写的程序代码都在里面。</a><br/> 🍭<font color=\"orange\">作者水平很有限，如果发现错误，一定要及时告知作者哦！感谢感谢！</font></p>\n</blockquote>\n<hr/>\n<p></p>\n<div class=\"toc\">\n<h3>📌导航小助手📌</h3>\n<ul><li><a href=\"#1HashMapHashMap_41\">1.HashMap以及HashMap的基本原理</a></li><li><ul><li><a href=\"#11HashMap_43\">1.1什么是HashMap？</a></li><li><a href=\"#12HashMap_52\">1.2HashMap的属性</a></li><li><a href=\"#13HashMap_94\">1.3HashMap的构造方法</a></li><li><a href=\"#14HashMap_144\">1.4HashMap开辟数组的时机</a></li><li><a href=\"#15HashMapput_159\">1.5HashMap中的put</a></li><li><a href=\"#16HashMap_172\">1.6HashMap中的哈希函数</a></li><li><a href=\"#17HashMap_197\">1.7HashMap的扩容机制</a></li></ul>\n</li><li><a href=\"#2HashSet_215\">2.HashSet的基本实现原理</a></li><li><a href=\"#3HashMap_219\">3.有关HashMap其他的面试题</a></li><li><ul><li><a href=\"#31HashMapHashMap_221\">3.1HashMap是否是线程安全的？有没有线程安全的\"HashMap\"？</a></li><li><a href=\"#32HashMap_228\">3.2HashMap有什么特点？</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<p><strong>注意事项：博主安利一款刷题面试的神器，如果有小伙伴还没有注册牛客，可以点击下方链接进行注册，注册完就能立即刷题了。不仅是刷题，上面还有很多有关就业的面经，面试题库，以及名企的模拟面试，我非常推荐它，博主自己用的也很多，也刷了不少题了！下图可以作证：</strong><br/> <img alt=\"1\" src=\"..\\..\\static\\image\\0baa362a4d0c4554a1db143f758d8c9b.png\"/></p>\n<p>注册地址：<a href=\"https://www.nowcoder.com/link/pc_csdncpt_wjhw_java2\">牛客网</a></p>\n<p><img alt=\"1\" src=\"..\\..\\static\\image\\d0967589dfd34948805966f609129bb7.png\"/></p>\n<p>有关任何问题都可以与博主交流，你可以在评论区留言，也可以私信我，更可以加上博主的vx与博主一对一交流（文章最下方有）。</p>\n<p><img alt=\"封面区\" src=\"..\\..\\static\\image\\62139f753ccf4fd5a69b4fd995c9296f.png\"/></p>\n<hr/>\n<h1><a id=\"1HashMapHashMap_41\"></a>1.HashMap以及HashMap的基本原理</h1>\n<h2><a id=\"11HashMap_43\"></a>1.1什么是HashMap？</h2>\n<p>HashMap是Java集合框架中Map容器的一个实现类，它的底层是使用哈希表实现的，更加具体地说在jdk7中采用数组+链表实现，在jdk8中采用数组+链表+红黑树实现。</p>\n<p>Map代表具有映射关系（key-value）的集合，其所有的key是一个Set集合（key值不能重复），即key无序且不能重复，而HashMap就是Map接口下的一个实现类，HashMap是一个储存键值对（EntrySet）的集合，并且支持储存key/value为<code>null</code>的元素。</p>\n<p>下面我们基于jdk8来说一说HashMap的基本原理。</p>\n<h2><a id=\"12HashMap_52\"></a>1.2HashMap的属性</h2>\n<p>HashMap对象被构造时，初始的默认容量为<code>1&lt;&lt;4</code>，也就是<code>16</code>，并且必须是2的幂（这与哈希函数有关）。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> DEFAULT_INITIAL_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// aka 16</span>\n</code></pre>\n<p>HashMap最大的容量为<code>1&lt;&lt;30</code>，也就是<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        \n         2\n        \n        \n         30\n        \n       \n      \n      \n       2^{30}\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">30</span></span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAXIMUM_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>HashMap默认的负载因子为<code>0.75</code>。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> DEFAULT_LOAD_FACTOR <span class=\"token operator\">=</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>链表树化的最小链表大小阈值<code>8</code>，当HashMap中数组大于<code>64</code>，数组所挂链表的大小超过<code>8</code>才会将数组所挂的链表转换为红黑树。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> TREEIFY_THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MIN_TREEIFY_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">64</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>红黑树链表化的的阈值是<code>6</code>，当红黑树结点个数小于<code>6</code>时，就会转换为链表。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> UNTREEIFY_THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>HashMap底层的数组，是一个链表数组：</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">transient</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>元素个数阈值，当HashMap的size大于threshold时会执行resize操作，<code>threshold=capacity*loadFactor</code>，其中capacity表示数组的容量。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"13HashMap_94\"></a>1.3HashMap的构造方法</h2>\n<p>HashMap最常用的构造方法，一个是无参的构造方法，使用无参构造方法构造HashMap时，默认的构造容量是<code>16</code>，但是此时不会真的去申请一个大小为<code>16</code>的数组，还有一个指定容量的构造方法也是如此，并且所取容量为大于或等于指定容量的一个最接近的2次幂数，日指定容量为<code>19</code>，那实际数组容量为<code>32</code>。</p>\n<p>源码：</p>\n<pre><code class=\"prism language-java\">    <span class=\"token keyword\">public</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>initialCapacity<span class=\"token punctuation\">,</span> DEFAULT_LOAD_FACTOR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<pre><code class=\"prism language-java\">    <span class=\"token keyword\">public</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>loadFactor <span class=\"token operator\">=</span> DEFAULT_LOAD_FACTOR<span class=\"token punctuation\">;</span> <span class=\"token comment\">// all other fields defaulted</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>除此之外，还有指定容量和负载因子的构造方法，其中<code>tableSizeFor(initialCapacity)</code>方法会生成比<code>initialCapacity</code>大并最接近<code>initialCapacity</code>的一个<code>2</code>次幂。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token keyword\">public</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Illegal initial capacity: \"</span> <span class=\"token operator\">+</span>\n                                               initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">&gt;</span> MAXIMUM_CAPACITY<span class=\"token punctuation\">)</span>\n            initialCapacity <span class=\"token operator\">=</span> MAXIMUM_CAPACITY<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loadFactor <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> <span class=\"token class-name\">Float</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span>loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Illegal load factor: \"</span> <span class=\"token operator\">+</span>\n                                               loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>loadFactor <span class=\"token operator\">=</span> loadFactor<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threshold <span class=\"token operator\">=</span> <span class=\"token function\">tableSizeFor</span><span class=\"token punctuation\">(</span>initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>从源码可以看出其实在使用以上三种构造方法进行对象构造的时候，并没有为数组分配空间，只是确定负载因子，容量等属性。</p>\n<p>最后还有一个根据其他的Map对象构造HashMap的构造方法，使用这种方式构造，只要传入的参数有元素，那么数组空间肯定已经申请好了，否则也是没有去申请的。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token keyword\">public</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>loadFactor <span class=\"token operator\">=</span> DEFAULT_LOAD_FACTOR<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">putMapEntries</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>所以我们可以得到一个结论：当HashMap对象创建时，内部的数组并没有分配内存。</p>\n<h2><a id=\"14HashMap_144\"></a>1.4HashMap开辟数组的时机</h2>\n<p>真正为数组分配内存是在第一次<code>put</code>操作的时候，其中源码如下：</p>\n<pre><code class=\"prism language-java\">    <span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>意思就是通过哈希函数<code>hash</code>生成对应数组的下标值，找到对应的位置进制插入。<br/> 如果是第一次插入，就会对链表数组进行扩容，也是正式地为数组初始化：<br/> <img alt=\"1\" src=\"..\\..\\static\\image\\5d540db7ac4340afbb6a35f246d8e8ae.png\"/><br/> 我们就不继续深入看了，在resize方法中，会为数组分配内存，并且大小为2的幂，至于为什么是这个值，这与HashMap中的哈希函数有关。</p>\n<h2><a id=\"15HashMapput_159\"></a>1.5HashMap中的put</h2>\n<p>如果是首次扩容，先判断数组是否为空，若数组为空则进行第一次扩容（resize），会为HashMap对象申请一个默认容量大小<code>16</code>的数组。</p>\n<p>第一步，通过hash()方法计算索引，通过hash算法，计算键值对在数组中的索引，并通过索引找到在数组中的位置。<br/> 第二步，插入数据，分以下几种情况：</p>\n<ul><li>如果当前位置元素为空，则直接插入数据；</li><li>如果当前位置元素非空，遍历链表或红黑树，如果key已存在，则直接覆盖其value；</li><li>如果当前位置元素非空，遍历链表或红黑树，如果key不存在，则将数据链尾插（jdk7是头插）到链表；</li><li>若链表长度达到8，并且HashMap中的<code>table</code>数组大小达到<code>64</code>，则将链表转换成红黑树，并将数据插入树中，如果链表长度达到<code>8</code>但是<code>table</code>数组大小没有<code>64</code>则将数组扩容；</li></ul>\n<p>第三步，检查存储的元素个数，如果超过阈值<code>threshold</code>，则扩容。这一步其实也就是检查负载因子是否超过默认值，超过就扩容。</p>\n<h2><a id=\"16HashMap_172\"></a>1.6HashMap中的哈希函数</h2>\n<p>前面我们说到了hash方法，HashMap中的hash方法是与我们直接根据<code>key</code>生成hashCode值再取模的方式不同，在HashMap中的hash算法中，首先会<code>key</code>计算出hashCode值，然后再将hashCode值与右移<code>16</code>为的hashCode值进行按位异或操作，得到一个新的哈希值，这样做的目的其实就是为了增强哈希值的随机性，这个方法也叫做“扰动方法”。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">&gt;&gt;&gt;</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在进行put等需要找到某个<code>key</code>所对应的数组索引的时候，HashMap不是通过直接取数组长度的模来得到对应的下标，取而代之的是使用按位与<code>&amp;</code>运算来进行下标的计算，毕竟位运算的效率是大于取模<code>%</code>操作的。假设HashMap底层数组<code>table</code>的长度为<code>length</code>，不妨记<code>n=length-1</code>，<code>key</code>对应的哈希值为<code>h</code>。</p>\n<p>在jdk8源码中，使用<code>h&amp;(n-1)</code>来获取对应<code>table</code>数组的索引（下标）,这也解释了为什么HashMap当中的数组长度一定是<code>2</code>的幂。</p>\n<p>因为使用<code>2</code>的幂再减去一个<code>1</code>，得到的数<code>n</code>它的所有有效二进制位均为<code>1</code>，如<code>64</code>的二进制数为<code>1000000</code>，减去<code>1</code>得到<code>n</code>，它的值为<code>0111111</code>，数组的长度的二进制有效位是<code>7</code>位，因为数组长度是二的幂，数组下标最大下标有效位一定是<code>6</code>位，并且全为<code>1</code>，我们知道<code>0</code>与任何数按位与得到的均为<code>0</code>，而<code>1</code>与任何数运算得到的结果可能是<code>1</code>也可能是<code>0</code>，这就保证了在使用<code>&amp;</code>操作时，每一位有效位的值都有可能是<code>0</code>或<code>1</code>，进一步就保证了数组<code>table</code>的所有下标均有可能被映射到，反之如果存在含有<code>0</code>的二进制有效位，则那一位按位与的操作结果一定是<code>0</code>，这样的话，一定存在数组<code>table</code>中某些下标无法被映射，增大了哈希冲突的可能性。</p>\n<p><img alt=\"3\" src=\"..\\..\\static\\image\\0b37261c7b654c0aafe00ad174f34893.png\"/></p>\n<p>做个小总结，HashMap中计算的哈希值是通过hashCode值与右移16位hashCode值按位异或的结果，这个目的就是为了增强哈希值的随机性。HashMap确定索引的方法是将<code>n&amp;h</code>，毕竟按位与的效率大于取模，为了数组每个下标都可能被映射到，则<code>n</code>的每一位二进制有效位均得为<code>1</code>，所以数组的长度必须为<code>2</code>的幂，因为只有<code>2</code>的幂减<code>1</code>得到的有效二进制位均为<code>1</code>。</p>\n<p>其中<code>n</code>表示数组长度减去一个<code>1</code>，<code>h</code>表示通过hash方法得到的哈希值。</p>\n<h2><a id=\"17HashMap_197\"></a>1.7HashMap的扩容机制</h2>\n<p>HashMap中<code>table</code>数组初始默认大小为<code>16</code>，根据上述对hash方法的分析，数组<code>table</code>长度一定得是<code>2</code>的幂，从这里就不难猜出，HashMap极有可能是<code>2</code>倍扩容，毕竟<code>2</code>倍扩容比较合理，并且它能够保证扩容后的数组大小也是<code>2</code>的幂。</p>\n<p>在jdk8中，HashMap的扩容，确实是采用了<code>2</code>倍扩容。<br/> <img alt=\"4\" src=\"..\\..\\static\\image\\881bdf78e3de40438d71ffbffdb1db04.png\"/></p>\n<p>当HashMap对象中元素个数<code>size</code>大于<code>threshold</code>或者数组为<code>null</code>时会触发扩容<code>resize</code>。</p>\n<p>为了解决哈希冲突，jdk8采用了数组+链表+红黑树的方式实现，当数组中某链表的长度大于<code>8</code>，并且数组<code>table</code>的长度达到<code>64</code>，就会将链表转换为红黑树来提高效率，当数组中某链表长度大于<code>8</code>但是数组<code>table</code>长度没有达到<code>64</code>，此时就会进行扩容。<br/> <img alt=\"5\" src=\"..\\..\\static\\image\\1cfec8729e7f4007bdff78b26076d9f2.png\"/></p>\n<p><img alt=\"6\" src=\"..\\..\\static\\image\\18013e190107437d8a1e4a7de5fa46ab.png\"/><br/> 当红黑树结点个数小于<code>6</code>时，就会将红黑树转换回链表。</p>\n<p>在扩容的时候，会将所有的元素遍历，全部重新计算哈希值并全部重新确定在数组中的位置。</p>\n<h1><a id=\"2HashSet_215\"></a>2.HashSet的基本实现原理</h1>\n<p>HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。<br/> <img alt=\"7\" src=\"..\\..\\static\\image\\1320d7926c0d4e2d92a64cef5a880c6c.png\"/></p>\n<h1><a id=\"3HashMap_219\"></a>3.有关HashMap其他的面试题</h1>\n<h2><a id=\"31HashMapHashMap_221\"></a>3.1HashMap是否是线程安全的？有没有线程安全的\"HashMap\"？</h2>\n<p>HashMap不能保证线程安全，因为在并发的情况下进行<code>put</code>操作，可能会导致数组中链表死循环。<br/> 线程安全的“HashMap”有HashTable，它相比于HashMap，给关键的方法加上了锁，那么给方法加锁本质上就是给对象加锁，那么每种操作都需要拿对象锁，这样会造成激烈的锁竞争。<br/> 相比于HashTable，更推荐使用CurrentHashMap，在jdk7中，它是给每一个数组中的元素都加上了锁，或者说创建了一个新的数组<code>Segment</code>，这个数组用于实现加锁操作，每个 Segment 里包含一个 HashEntry 数组，Segment 中元素的结构和 HashMap 类似，是一个数组和链表结构。<br/> 在jdk8中，已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作，整个看起来就像是优化过且线程安全的 HashMap，简单说，在HashMap的基础上，就是给每个数组中的元素加锁，来保证线程安全，并且由于每个数组元素都有锁，所以相比于HashTable锁竞争的激烈程度小得多。</p>\n<h2><a id=\"32HashMap_228\"></a>3.2HashMap有什么特点？</h2>\n<ol><li>HashMap是线程不安全的，支持序列化。</li><li>HashMap可以使用null作为key或value。</li><li>HashMap查找的效率可达到O(1)。</li><li>HashMap遍历方式比较单一，主要使用EntrySet 和 KeySet进行遍历，遍历方式有增强for循环和迭代器。</li><li>HashMap是Map容器的一种实现，是无序的键值对集合。</li></ol>\n<hr/>\n<p><strong>下期预告：反射枚举lambda表达式</strong></p>\n<p>到文章最后，再来安利一下吧，博主也是经常使用，并且也经常在牛客上刷题，题库也非常丰富：<a href=\"https://www.nowcoder.com/link/pc_csdncpt_wjhw_java2\">学习，刷题，面试，内推都有</a>。也欢迎与博主交流有关刷题，技术方面，以及与博主聊聊天，交个朋友也好啊，毕竟有朋自远方来！</p>\n<center>\n<font color=\"red\">觉得文章写得不错的老铁们，点赞评论关注走一波！谢谢啦！ </font>\n</center>\n<p><img alt=\"1-99\" height=\"180\" src=\"..\\..\\static\\image\\70dbcef1173945aa9b467ea939621bba.png\" width=\"160\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-14 08:00:00", "summary": "前面的话本篇文章将介绍中的底层实现原理，有关为数组开辟内存的时期，默认的容量，默认负载因子，树化的条件，的扩容机制，方法的过程以及中的哈希函数。小贴士：博主推荐学习面试刷题必用工具博客主页：未见花闻的"}