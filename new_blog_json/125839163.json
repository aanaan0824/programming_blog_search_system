{"blogid": "125839163", "writerAge": "码龄1年", "writerBlogNum": "25", "writerCollect": "2049", "writerComment": "1518", "writerFan": "2633", "writerGrade": "6级", "writerIntegral": "4561", "writerName": "猿力猪", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125839163.jpg", "writerRankTotal": "4640", "writerRankWeekly": "15864", "writerThumb": "1555", "writerVisitNum": "113074", "blog_read_count": "4391", "blog_time": "已于 2022-07-18 22:49:26 修改", "blog_title": "【OpenCV】图像拼接 原理介绍 C++ OpenCV 案例实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%9B%AE%E5%BD%95\">目录</h1>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%8B%BC%E6%8E%A5%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%8B%BC%E6%8E%A5%E5%8E%9F%E7%90%86\">一、图像拼接相关原理 ​编辑</a></p>\n<p id=\"%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E9%87%87%E9%9B%86-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E9%87%87%E9%9B%86\">图像特征采集</a></p>\n<p id=\"%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95\">特征提取算法</a></p>\n<p id=\"%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2\">透视变换</a></p>\n<p id=\"%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5\">透视矩阵</a></p>\n<p id=\"%E5%9B%BE%E5%83%8F%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E5%83%8F%E6%8B%B7%E8%B4%9D\">图像拷贝</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">二、案例实现</a></p>\n<p id=\"Step1%EF%BC%9A%E5%AF%BC%E5%85%A5%E7%9B%AE%E6%A0%87%E5%9B%BE%E7%89%87-toc\" style=\"margin-left:40px;\"><a href=\"#Step1%EF%BC%9A%E5%AF%BC%E5%85%A5%E7%9B%AE%E6%A0%87%E5%9B%BE%E7%89%87\">Step1：导入目标图片</a></p>\n<p id=\"Step2%EF%BC%9A%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96%E5%92%8C%E5%8C%B9%E9%85%8D%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#Step2%EF%BC%9A%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96%E5%92%8C%E5%8C%B9%E9%85%8D%C2%A0\">Step2：特征点提取和匹配 </a></p>\n<p id=\"Step3%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%85%8D%E5%87%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step3%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%85%8D%E5%87%86\">Step3：图像配准</a></p>\n<p id=\"Step4%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:40px;\"><a href=\"#Step4%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%8B%B7%E8%B4%9D\">Step4：图像拷贝</a></p>\n<p id=\"Step5%EF%BC%9A%C2%A0%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88-toc\" style=\"margin-left:40px;\"><a href=\"#Step5%EF%BC%9A%C2%A0%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88\">Step5：图像融合</a></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">完整代码</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</a></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>本文以<strong>实现图像拼接</strong>为目标，把分割开的图像进行拼接还原，核心的内容包括：<span style=\"color:#be191c;\"><strong>OpenCV图像拼接相关原理</strong></span>以及<span style=\"color:#be191c;\"><strong>OpenCV图像拼接案例</strong></span><span style=\"color:#494949;\">的实现</span></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%8B%BC%E6%8E%A5%E5%8E%9F%E7%90%86\"><strong>一、图像拼接相关原理</strong> <img alt=\"\" src=\"..\\..\\static\\image\\9dfb9a0f6dee40a0b05f2a6f01ffd0e4.png\"/></h1>\n<h2 id=\"%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E9%87%87%E9%9B%86\"><strong>图像特征采集</strong></h2>\n<blockquote>\n<p>一幅图中总存在着一些独特的像素点，这些点我们可以认为就是这幅图的特征，即为特征点</p>\n</blockquote>\n<ul><li>如何确定左边的是狼，右边的是猪？ </li></ul>\n<p><img alt=\"\" height=\"179\" src=\"..\\..\\static\\image\\7aaf311b66f043bc8d3c614a81185eff.png\" width=\"701\"/></p>\n<blockquote>\n<p>获取一幅图中存在的一些独特的像素点，需要解决两个问题：</p>\n<p></p>\n<ul><li>解决尺度不变性问题，不同大小的图片获取到的特征是一样的</li><li>提取到的特征点要稳定，能被精确定位 </li></ul>\n</blockquote>\n<h2 id=\"%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95\"><strong>特征提取算法</strong></h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td><strong>名称</strong></td><td><strong>支持尺寸不变性</strong></td><td><strong>速度</strong></td></tr><tr><td>SURF</td><td>支持</td><td>快</td></tr><tr><td>SIFT</td><td>支持</td><td>比SURF慢</td></tr><tr><td>ORB</td><td>不支持</td><td>SURF算法快10倍</td></tr><tr><td>FAST</td><td>没有尺度不变性</td><td> <p>比ORB快</p> </td></tr></tbody></table>\n<h2 id=\"%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2\"><strong>透视变换</strong></h2>\n<p><img alt=\"\" height=\"337\" src=\"..\\..\\static\\image\\9eaedeeb00c34515a1b5e81b8976f257.png\" width=\"682\"/></p>\n<blockquote>\n<ul><li>透视变换是按照物体成像投影规律进行变换，即将物体重新投影到新的成像平面</li><li>透视变换常用于机器人视觉导航研究中，由于相机视场与地面存在倾斜角使得物体成像产生畸变，通常通过透视变换实现对物体图像的校正</li></ul>\n</blockquote>\n<h2 id=\"%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5\"><strong>透视矩阵</strong></h2>\n<ul><li>[u,v,w] 表示当前平面坐标的x,y,z，如果是平面，那么z=1</li><li>[x',y',z'] 表示目标平面坐标的x,y,z，如果是平面，那么z=1</li></ul>\n<p><img alt=\"\" height=\"203\" src=\"..\\..\\static\\image\\bceb7905637644798b58343d49f843ac.png\" width=\"651\"/></p>\n<p><img alt=\"\" height=\"139\" src=\"..\\..\\static\\image\\b73cc6b8dd364a1cb059a4435ef8bd0f.png\" width=\"683\"/></p>\n<blockquote>\n<p>以上公式，我们可以理解为，透视矩阵是原始平面可目标平面之间的一种转换关系</p>\n</blockquote>\n<h2 id=\"%E5%9B%BE%E5%83%8F%E6%8B%B7%E8%B4%9D\"><strong>图像拷贝</strong></h2>\n<ul><li>将一副图像拷贝到另一副图像上的过程</li></ul>\n<p><img alt=\"\" height=\"561\" src=\"..\\..\\static\\image\\96f020ba5f474d84a7e8e8185069a2e3.png\" width=\"853\"/></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">二、案例实现</h1>\n<ul><li>这是本案例所用到的素材，如下图所示： </li></ul>\n<p><img alt=\"\" height=\"449\" src=\"..\\..\\static\\image\\6619073135894b62954f076166bfa8a1.jpeg\" width=\"788\"/></p>\n<ul><li>我们将上图进行分割，用于实现拼接还原，如下图所示： </li></ul>\n<p style=\"text-align:center;\"> <img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\fc3040b2a8064f01ba21640b7db3ba1c.png\" width=\"281\"/>    <img alt=\"\" height=\"299\" src=\"..\\..\\static\\image\\330b8433b8884e7fbf5d3864750cf90a.png\" width=\"375\"/></p>\n<h2 id=\"Step1%EF%BC%9A%E5%AF%BC%E5%85%A5%E7%9B%AE%E6%A0%87%E5%9B%BE%E7%89%87\">Step1：导入目标图片</h2>\n<ul><li>设置需要处理的两张图片，进行拼接准备工作 </li></ul>\n<pre><code class=\"language-cpp\">    Mat left=imread(\"C:/Users/86177/Desktop/image/a11.png\");//左侧：图片路径\n    Mat right=imread(\"C:/Users/86177/Desktop/image/a22.png\");//右侧：图片路径\n\n    imshow(\"left\",left);\n    imshow(\"right\",right);</code></pre>\n<p><img alt=\"\" height=\"552\" src=\"..\\..\\static\\image\\3ce6282260c640b9a51ab9fb164e149f.png\" width=\"1071\"/></p>\n<p></p>\n<h2 id=\"Step2%EF%BC%9A%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96%E5%92%8C%E5%8C%B9%E9%85%8D%C2%A0\">Step2：特征点提取和匹配 </h2>\n<ul><li>用SIFT算法来实现图像拼接是很常用的方法，虽说SURF精确度和稳定性不及SIFT，但是其综合能力还是优越一些</li></ul>\n<pre><code class=\"language-cpp\">    //创建SURF对象\n    Ptr&lt;SURF&gt;surf;   //可以容纳800个特征点\n    surf = SURF::create(800);//参数 查找的海森矩阵 create 海森矩阵阀值\n\n    //暴力匹配器\n    BFMatcher matcher;\n\n    vector&lt;KeyPoint&gt;key1,key2;\n    Mat c,d;\n\n    //寻找特征点\n    surf-&gt;detectAndCompute(left,Mat(),key2,d);\n    surf-&gt;detectAndCompute(right,Mat(),key1,c);\n\n    //特征点对比，保存下来\n    vector&lt;DMatch&gt;matches;//DMatch 点和点之间的关系\n    //使用暴力匹配器匹配特征点，找到存来\n    matcher.match(d,c,matches);\n\n    //排序 从小到大\n    sort(matches.begin(),matches.end());\n\n    //保留最优的特征点对象\n    vector&lt;DMatch&gt;good_matches;//最优\n\n    //设置比例\n    int ptrPoint = std::min(50,(int)(matches.size()*0.15));\n\n    for(int i = 0;i &lt; ptrPoint;i++)\n    {\n        good_matches.push_back(matches[i]);\n    }\n\n    //最佳匹配的特征点连成线\n    Mat outimg;\n\n    drawMatches(left,key2,right,key1,good_matches,outimg,\n                Scalar::all(-1),Scalar::all(-1),\n                vector&lt;char&gt;(),DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);\n\n    imshow(\"outimg\",outimg);</code></pre>\n<p><img alt=\"\" height=\"528\" src=\"..\\..\\static\\image\\55fe44f9783c4e6693967323f2b14c7d.png\" width=\"987\"/></p>\n<h2 id=\"Step3%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%85%8D%E5%87%86\">Step3：图像配准</h2>\n<ul><li>我们就可以得到了两幅待拼接图的匹配点集，接下来我们进行图像的配准，即将两张图像转换为同一坐标下</li></ul>\n<pre><code class=\"language-cpp\">    //特征点配准\n    vector&lt;Point2f&gt;imagepoint1,imagepoint2;\n\n    for(int i = 0;i&lt;good_matches.size();i++)\n    {\n        imagepoint1.push_back(key1[good_matches[i].trainIdx].pt);\n        imagepoint2.push_back(key2[good_matches[i].queryIdx].pt);\n    }\n\n    //透视转换\n    Mat homo = findHomography(imagepoint1,imagepoint2,CV_RANSAC);\n\n    imshow(\"homo\",homo);</code></pre>\n<p><img alt=\"\" height=\"525\" src=\"..\\..\\static\\image\\c2517a14db1946cc9706f93052915257.png\" width=\"788\"/></p>\n<h2 id=\"Step4%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%8B%B7%E8%B4%9D\">Step4：图像拷贝</h2>\n<ul><li>将我们的左图拷贝到设置好的配准图（右图）上 </li></ul>\n<pre><code class=\"language-cpp\">    //创建拼接后的图，计算图的大小\n    int dst_width = imageTranForm.cols;//获取最右点为拼接图长度\n    int dst_height = left.rows;\n\n    Mat dst(dst_height,dst_width,CV_8UC3);\n    dst.setTo(0);\n\n    imageTranForm.copyTo(dst(Rect(0,0,imageTranForm.cols,imageTranForm.rows)));\n    left.copyTo(dst(Rect(0,0,left.cols,left.rows)));\n            \n    imshow(\"dst\",dst);</code></pre>\n<p><img alt=\"\" height=\"522\" src=\"..\\..\\static\\image\\583ccbdd5b9344f7a742cbf119449bd1.png\" width=\"781\"/></p>\n<h2 id=\"Step5%EF%BC%9A%C2%A0%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88\"><strong>Step5：图像融合</strong></h2>\n<ul><li>去裂缝处理，让我们的优化两图的连接处，使得拼接自然</li><li><strong>PS：</strong>上面拼接完的图片看不太出来，拼接处理中，还是建议用上</li></ul>\n<pre><code class=\"language-cpp\">//优化两图的连接处，使得拼接自然\nvoid OptimizeSeam(Mat&amp; img1, Mat&amp; trans, Mat&amp; dst)\n{\n    int start = MIN(corners.left_top.x, corners.left_bottom.x);//开始位置，即重叠区域的左边界\n\n    double processWidth = img1.cols - start;//重叠区域的宽度\n    int rows = dst.rows;\n    int cols = img1.cols; //注意，是列数*通道数\n    double alpha = 1;//img1中像素的权重\n    for (int i = 0; i &lt; rows; i++)\n    {\n        uchar* p = img1.ptr&lt;uchar&gt;(i);  //获取第i行的首地址\n        uchar* t = trans.ptr&lt;uchar&gt;(i);\n        uchar* d = dst.ptr&lt;uchar&gt;(i);\n        for (int j = start; j &lt; cols; j++)\n        {\n            //如果遇到图像trans中无像素的黑点，则完全拷贝img1中的数据\n            if (t[j * 3] == 0 &amp;&amp; t[j * 3 + 1] == 0 &amp;&amp; t[j * 3 + 2] == 0)\n            {\n                alpha = 1;\n            }\n            else\n            {\n                //img1中像素的权重，与当前处理点距重叠区域左边界的距离成正比，实验证明，这种方法确实好\n                alpha = (processWidth - (j - start)) / processWidth;\n            }\n\n            d[j * 3] = p[j * 3] * alpha + t[j * 3] * (1 - alpha);\n            d[j * 3 + 1] = p[j * 3 + 1] * alpha + t[j * 3 + 1] * (1 - alpha);\n            d[j * 3 + 2] = p[j * 3 + 2] * alpha + t[j * 3 + 2] * (1 - alpha);\n\n        }\n    }\n\n}</code></pre>\n<p><strong>其他图片拼接效果，如下图所示：</strong></p>\n<p><img alt=\"\" height=\"761\" src=\"..\\..\\static\\image\\e934373aca8b4106bab1ac7335c5637b.png\" width=\"1200\"/><img alt=\"\" height=\"756\" src=\"..\\..\\static\\image\\1a0a2d28810a4a1aa9b5a8a01bd46dbf.png\" width=\"1023\"/><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\58cb9c4204b249d7bbfb3feece36f7b0.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\c8c58c38d82f4563b6cb0b76b99ad538.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\73c408373ba34e7483d55b8b29bf150c.png\" width=\"1200\"/><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\68e29eb1e99a44d0b8a5cb562a725679.png\" width=\"1200\"/></p>\n<h2 id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><strong>完整代码</strong></h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n#include &lt;opencv2/xfeatures2d.hpp&gt;\n#include &lt;opencv2/calib3d.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;\n\nusing namespace std;\nusing namespace cv;\nusing namespace cv::xfeatures2d;\n\ntypedef struct\n{\n    //四个顶点\n    Point2f left_top;\n    Point2f left_bottom;\n    Point2f right_top;\n    Point2f right_bottom;\n}four_corners_t;\n\nfour_corners_t corners;\n\n//计算配准图的四个顶点坐标\nvoid CalcCorners(const Mat&amp; H, const Mat&amp; src)\n{\n    double v2[] = { 0, 0, 1 };//左上角\n    double v1[3];//变换后的坐标值\n    Mat V2 = Mat(3, 1, CV_64FC1, v2);  //列向量\n    Mat V1 = Mat(3, 1, CV_64FC1, v1);  //列向量\n\n    V1 = H * V2;\n    //左上角(0,0,1)\n    cout &lt;&lt; \"V2: \" &lt;&lt; V2 &lt;&lt; endl;\n    cout &lt;&lt; \"V1: \" &lt;&lt; V1 &lt;&lt; endl;\n    corners.left_top.x = v1[0] / v1[2];\n    corners.left_top.y = v1[1] / v1[2];\n\n    //左下角(0,src.rows,1)\n    v2[0] = 0;\n    v2[1] = src.rows;\n    v2[2] = 1;\n    V2 = Mat(3, 1, CV_64FC1, v2);  //列向量\n    V1 = Mat(3, 1, CV_64FC1, v1);  //列向量\n    V1 = H * V2;\n    corners.left_bottom.x = v1[0] / v1[2];\n    corners.left_bottom.y = v1[1] / v1[2];\n\n    //右上角(src.cols,0,1)\n    v2[0] = src.cols;\n    v2[1] = 0;\n    v2[2] = 1;\n    V2 = Mat(3, 1, CV_64FC1, v2);  //列向量\n    V1 = Mat(3, 1, CV_64FC1, v1);  //列向量\n    V1 = H * V2;\n    corners.right_top.x = v1[0] / v1[2];\n    corners.right_top.y = v1[1] / v1[2];\n\n    //右下角(src.cols,src.rows,1)\n    v2[0] = src.cols;\n    v2[1] = src.rows;\n    v2[2] = 1;\n    V2 = Mat(3, 1, CV_64FC1, v2);  //列向量\n    V1 = Mat(3, 1, CV_64FC1, v1);  //列向量\n    V1 = H * V2;\n    corners.right_bottom.x = v1[0] / v1[2];\n    corners.right_bottom.y = v1[1] / v1[2];\n\n}\n\n//优化两图的连接处，使得拼接自然\nvoid OptimizeSeam(Mat&amp; img1, Mat&amp; trans, Mat&amp; dst)\n{\n    int start = MIN(corners.left_top.x, corners.left_bottom.x);//开始位置，即重叠区域的左边界\n\n    double processWidth = img1.cols - start;//重叠区域的宽度\n    int rows = dst.rows;\n    int cols = img1.cols; //注意，是列数*通道数\n    double alpha = 1;//img1中像素的权重\n    for (int i = 0; i &lt; rows; i++)\n    {\n        uchar* p = img1.ptr&lt;uchar&gt;(i);  //获取第i行的首地址\n        uchar* t = trans.ptr&lt;uchar&gt;(i);\n        uchar* d = dst.ptr&lt;uchar&gt;(i);\n        for (int j = start; j &lt; cols; j++)\n        {\n            //如果遇到图像trans中无像素的黑点，则完全拷贝img1中的数据\n            if (t[j * 3] == 0 &amp;&amp; t[j * 3 + 1] == 0 &amp;&amp; t[j * 3 + 2] == 0)\n            {\n                alpha = 1;\n            }\n            else\n            {\n                //img1中像素的权重，与当前处理点距重叠区域左边界的距离成正比，实验证明，这种方法确实好\n                alpha = (processWidth - (j - start)) / processWidth;\n            }\n\n            d[j * 3] = p[j * 3] * alpha + t[j * 3] * (1 - alpha);\n            d[j * 3 + 1] = p[j * 3 + 1] * alpha + t[j * 3 + 1] * (1 - alpha);\n            d[j * 3 + 2] = p[j * 3 + 2] * alpha + t[j * 3 + 2] * (1 - alpha);\n\n        }\n    }\n\n}\n\nint main(int argc, char *argv[])\n{\n    Mat left=imread(\"C:/Users/86177/Desktop/image/test(1).png\");//左侧：图片路径\n    Mat right=imread(\"C:/Users/86177/Desktop/image/test(2).png\");//右侧：图片路径\n\n    imshow(\"left\",left);\n    imshow(\"right\",right);\n\n    //创建SURF对象\n    Ptr&lt;SURF&gt;surf;   //可以容纳800个特征点\n    surf = SURF::create(800);//参数 查找的海森矩阵 create 海森矩阵阀值\n\n    //暴力匹配器\n    BFMatcher matcher;\n\n    vector&lt;KeyPoint&gt;key1,key2;\n    Mat c,d;\n\n    //寻找特征点\n    surf-&gt;detectAndCompute(left,Mat(),key2,d);\n    surf-&gt;detectAndCompute(right,Mat(),key1,c);\n\n    //特征点对比，保存下来\n    vector&lt;DMatch&gt;matches;//DMatch 点和点之间的关系\n    //使用暴力匹配器匹配特征点，找到存来\n    matcher.match(d,c,matches);\n\n    //排序 从小到大\n    sort(matches.begin(),matches.end());\n\n    //保留最优的特征点对象\n    vector&lt;DMatch&gt;good_matches;//最优\n\n    //设置比例\n    int ptrPoint = std::min(50,(int)(matches.size()*0.15));\n\n    for(int i = 0;i &lt; ptrPoint;i++)\n    {\n        good_matches.push_back(matches[i]);\n    }\n\n    //最佳匹配的特征点连成线\n    Mat outimg;\n\n    drawMatches(left,key2,right,key1,good_matches,outimg,\n                Scalar::all(-1),Scalar::all(-1),\n                vector&lt;char&gt;(),DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);\n\n    imshow(\"outimg\",outimg);\n\n    //特征点配准\n    vector&lt;Point2f&gt;imagepoint1,imagepoint2;\n\n    for(int i = 0;i&lt;good_matches.size();i++)\n    {\n        imagepoint1.push_back(key1[good_matches[i].trainIdx].pt);\n        imagepoint2.push_back(key2[good_matches[i].queryIdx].pt);\n    }\n\n    //透视转换\n    Mat homo = findHomography(imagepoint1,imagepoint2,CV_RANSAC);\n\n    imshow(\"homo\",homo);\n\n    //四个顶点坐标的转换计算\n    CalcCorners(homo,right);\n\n    Mat imageTranForm;\n    warpPerspective(right,imageTranForm,homo,\n                    Size(MAX(corners.right_top.x,\n                             corners.right_bottom.x),\n                         left.rows));\n\n    imshow(\"imageTranForm\",imageTranForm);\n\n    //创建拼接后的图，计算图的大小\n    int dst_width = imageTranForm.cols;//获取最右点为拼接图长度\n    int dst_height = left.rows;\n\n    Mat dst(dst_height,dst_width,CV_8UC3);\n    dst.setTo(0);\n\n    imageTranForm.copyTo(dst(Rect(0,0,imageTranForm.cols,imageTranForm.rows)));\n    left.copyTo(dst(Rect(0,0,left.cols,left.rows)));\n\n    //优化拼接，主要目的去除黑边\n    OptimizeSeam(left,imageTranForm, dst);\n\n    imshow(\"dst\",dst);\n\n    waitKey(0);\n\n    return 0;\n}\n</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</h1>\n<blockquote>\n<ul><li>本文的核心内容包括：<span style=\"color:#be191c;\"><strong>OpenCV图像拼接相关原理</strong></span>以及<strong><span style=\"color:#be191c;\">OpenCV图像拼接案例</span></strong>的实现</li><li><strong>图像拼接</strong>在我们日常生活中运用其实算是非常广了，比如说我们现在经常见到的<strong>无人机航拍</strong>，以及我们手机相机的<strong>全景拍摄</strong></li><li>图像拼接是我们对图像进行其他处理的基础条件，图像拼接的好坏，将会直接影响了咱们出图的效果！所以学会<strong>拼接算法</strong>对图像进行拼接处理，很重要！</li></ul>\n</blockquote>\n<p><span style=\"color:#38d8f0;\"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！ !</strong></span></p>\n<p class=\"img-center\"><img alt=\"\" height=\"392\" src=\"https://img-blog.csdnimg.cn/2c286c2c5088497ca4b1c3470cec80b3.gif\" width=\"700\"/></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-18 22:49:26", "summary": "目录前言一、图像拼接相关原理编辑图像特征采集特征提取算法透视变换透视矩阵图像拷贝二、案例实现：导入目标图片：特征点提取和匹配：图像配准：图像拷贝：图像融合完整代码三、总结前言本文以实现图像拼接为目标，"}