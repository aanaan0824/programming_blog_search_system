{"blogid": "126743249", "writerAge": "码龄24天", "writerBlogNum": "53", "writerCollect": "0", "writerComment": "0", "writerFan": "27", "writerGrade": "3级", "writerIntegral": "530", "writerName": "web18606678257", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743249.jpg", "writerRankTotal": "39250", "writerRankWeekly": "12288", "writerThumb": "0", "writerVisitNum": "2038", "blog_read_count": "10", "blog_time": "于 2022-09-07 12:36:10 发布", "blog_title": "JVM Heap Memory", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"JVM_2\"></a>JVM堆内存和非堆内存</h1>\n<h2><a id=\"_5\"></a>堆和非堆内存</h2>\n<p>按照官方的说法：“Java 虚拟机具有一个堆(Heap)，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。</p>\n<p>JVM主要管理两种类型的内存：堆和非堆。</p>\n<p>Heap memory</p>\n<p>Code Cache</p>\n<p>Eden Space</p>\n<p>Survivor Space</p>\n<p>Tenured Gen</p>\n<p>non-heap memory</p>\n<p>Perm Gen</p>\n<p>native heap(I guess)</p>\n<ul><li>堆内存</li></ul>\n<p>Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</p>\n<p>堆的大小可以固定，也可以扩大和缩小。堆的内存不需要是连续空间。</p>\n<ul><li>非堆内存</li></ul>\n<p>Java 虚拟机管理堆之外的内存（称为非堆内存）。</p>\n<p>Java 虚拟机具有一个由所有线程共享的方法区。方法区属于非堆内存。它存储每个类结构，如运行时常数池、字段和方法数据，以及方法和构造方法的代码。它是在 Java 虚拟机启动时创建的。</p>\n<p>方法区在逻辑上属于堆，但 Java 虚拟机实现可以选择不对其进行回收或压缩。与堆类似，方法区的大小可以固定，也可以扩大和缩小。方法区的内存不需要是连续空间。</p>\n<p>除了方法区外，Java 虚拟机实现可能需要用于内部处理或优化的内存，这种内存也是非堆内存。例如，JIT 编译器需要内存来存储从 Java 虚拟机代码转换而来的本机代码，从而获得高性能。</p>\n<ul><li>几个基本概念</li></ul>\n<p>PermGen space：全称是Permanent Generation space，即永久代。就是说是永久保存的区域,用于存放Class和Meta信息，Class在被Load的时候被放入该区域，GC(Garbage Collection)应该不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。</p>\n<p>Heap space：存放Instance。</p>\n<p>Java Heap分为3个区，Young即新生代，Old即老生代和Permanent。</p>\n<p>Young保存刚实例化的对象。当该区被填满时，GC会将对象移到Old区。Permanent区则负责保存反射对象。</p>\n<ul><li> <p>堆内存分配</p>\n<ul><li>JVM初始分配的堆内存由-Xms指定，默认是物理内存的1/64；</li><li>JVM最大分配的堆内存由-Xmx指定，默认是物理内存的1/4。</li><li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；</li><li>空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。</li><li>因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。</li><li>说明：如果-Xmx 不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误，此错误来自JVM，不是Throwable的，无法用try…catch捕捉。</li></ul> </li><li> <p>非堆内存分配</p>\n<ul><li>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；</li><li>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 \n    <ul><li>还有一说：MaxPermSize缺省值和-server -client选项相关，-server选项下默认MaxPermSize为64m，-client选项下默认MaxPermSize为32m。这个我没有实验。</li></ul> </li><li>XX:MaxPermSize设置过小会导致java.lang.OutOfMemoryError: PermGen space 就是内存益出。</li><li>为什么会内存益出： \n    <ol><li>这一部分内存用于存放Class和Meta的信息，Class在被 Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同。</li><li>GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS 的话,就很可能出现PermGen space错误。</li></ol> </li><li>这种错误常见在web服务器对JSP进行pre compile的时候。</li></ul> </li></ul>\n<h2><a id=\"JVM_72\"></a>JVM内存限制(最大值)</h2>\n<ul><li> <p>首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统下为2G-3G），而64bit以上的处理器就不会有限制了。</p> </li><li> <p>为什么有的机器我将-Xmx和-XX:MaxPermSize都设置为512M之后Eclipse可以启动，而有些机器无法启动？</p>\n<ul><li>通过上面对JVM内存管理的介绍我们已经了解到JVM内存包含两种：堆内存和非堆内存，另外JVM最大内存首先取决于实际的物理内存和操作系统。所以说设置VM参数导致程序无法启动主要有以下几种原因： \n    <ol><li>参数中-Xms的值大于-Xmx，或者-XX:PermSize的值大于-XX:MaxPermSize；</li><li>-Xmx的值和-XX:MaxPermSize的总和超过了JVM内存的最大限制，比如当前操作系统最大内存限制，或者实际的物理内存等等。说到实际物理内存这里需要说明一点的是，如果你的内存是1024MB，但实际系统中用到的并不可能是1024MB，因为有一部分被硬件占用了。</li></ol> </li></ul> </li><li> <p>如果你有一个双核的CPU，也许可以尝试这个参数: -XX:+UseParallelGC 让GC可以更快的执行。（只是JDK 5里对GC新增加的参数）</p> </li><li> <p>如果你的WEB APP下都用了大量的第三方jar，其大小超过了服务器jvm默认的大小，那么就会产生内存益出问题了。解决方法： 设置MaxPermSize大小。</p>\n<ul><li>增加服务器启动的JVM参数设置：<code>-Xms128m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m</code></li><li>如tomcat，修改TOMCAT_HOME/bin/catalina.sh，在<code>echo \"Using CATALINA_BASE: $CATALINA_BASE\"</code>上面加入以下行：<code>JAVA_OPTS=\"-server -XX:PermSize=64M -XX:MaxPermSize=128m</code></li></ul> </li><li> <p>建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以减少jar 文档重复占用内存</p> </li></ul>\n<h2><a id=\"JVM_90\"></a>JVM内存设置参数</h2>\n<ul><li>内存设置参数</li></ul>\n<p>设置项</p>\n<p>说明</p>\n<p>-Xms512m</p>\n<p>表示JVM初始分配的堆内存大小为512m（JVM Heap(堆内存)最小尺寸，初始分配）</p>\n<p>-Xmx1024m</p>\n<p>JVM最大允许分配的堆内存大小为1024m，按需分配（JVM Heap(堆内存)最大允许的尺寸，按需分配）</p>\n<p>-XX:PermSize=512M</p>\n<p>JVM初始分配的非堆内存</p>\n<p>-XX:MaxPermSize=1024M</p>\n<p>JVM最大允许分配的非堆内存，按需分配</p>\n<p>-XX:NewSize/-XX:MaxNewSize</p>\n<p>定义YOUNG段的尺寸，NewSize为JVM启动时YOUNG的内存大小；</p>\n<p>MaxNewSize为最大可占用的YOUNG内存大小。</p>\n<p>-XX:SurvivorRatio</p>\n<p>设置YOUNG代中Survivor空间和Eden空间的比例</p>\n<ul><li> <p>说明：</p>\n<ol><li>如果-Xmx不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误，此错误来自JVM不是Throwable的，无法用try…catch捕捉。</li><li>PermSize和MaxPermSize指明虚拟机为java永久生成对象（Permanate generation）如，class对象、方法对象这些可反射（reflective）对象分配内存限制，这些内存不包括在Heap（堆内存）区之中。</li><li>-XX:MaxPermSize分配过小会导致：java.lang.OutOfMemoryError: PermGen space。</li><li>MaxPermSize缺省值和-server -client选项相关：-server选项下默认MaxPermSize为64m、-client选项下默认MaxPermSize为32m。</li></ol> </li><li> <p>申请一块内存的过程</p>\n<ol><li>JVM会试图为相关Java对象在Eden中初始化一块内存区域</li><li>当Eden空间足够时，内存申请结束。否则到下一步</li><li>JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）；释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区/OLD区</li><li>Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区</li><li>当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）</li><li>完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”</li></ol> </li><li> <p>resin服务器典型的响应时间优先型的jvm配置：</p> <p>-Xmx2000M -Xms2000M -Xmn500M<br/> -XX:PermSize=250M -XX:MaxPermSize=250M<br/> -Xss256K<br/> -XX:+DisableExplicitGC<br/> -XX:SurvivorRatio=1<br/> -XX:+UseConcMarkSweepGC<br/> -XX:+UseParNewGC<br/> -XX:+CMSParallelRemarkEnabled<br/> -XX:+UseCMSCompactAtFullCollection<br/> -XX:CMSFullGCsBeforeCompaction=0<br/> -XX:+CMSClassUnloadingEnabled<br/> -XX:LargePageSizeInBytes=128M<br/> -XX:+UseFastAccessorMethods<br/> -XX:+UseCMSInitiatingOccupancyOnly<br/> -XX:CMSInitiatingOccupancyFraction=60<br/> -XX:SoftRefLRUPolicyMSPerMB=0<br/> -XX:+PrintClassHistogram<br/> -XX:+PrintGCDetails<br/> -XX:+PrintGCTimeStamps<br/> -XX:+PrintHeapAtGC<br/> -Xloggc:log/gc.log</p> </li></ul>\n<h2><a id=\"_164\"></a>内存回收算法</h2>\n<p>Java中有四种不同的回收算法，对应的启动参数为:</p>\n<p>–XX:+UseSerialGC<br/> –XX:+UseParallelGC<br/> –XX:+UseParallelOldGC<br/> –XX:+UseConcMarkSweepGC</p>\n<h3><a id=\"Serial_Collector_174\"></a>Serial Collector</h3>\n<p>大部分平台或者强制 java -client 默认会使用这种。</p>\n<p>young generation算法 = serial</p>\n<p>old generation算法 = serial (mark-sweep-compact)</p>\n<p>这种方法的缺点很明显, stop-the-world, 速度慢。服务器应用不推荐使用。</p>\n<h3><a id=\"Parallel_Collector_184\"></a>Parallel Collector</h3>\n<p>在linux x64上默认是这种，其他平台要加 java -server 参数才会默认选用这种。</p>\n<p>young = parallel，多个thread同时copy</p>\n<p>old = mark-sweep-compact = 1</p>\n<p>优点：新生代回收更快。因为系统大部分时间做的gc都是新生代的，这样提高了throughput(cpu用于非gc时间)</p>\n<p>缺点：当运行在8G/16G server上old generation live object太多时候pause time过长</p>\n<h3><a id=\"Parallel_Compact_Collector_ParallelOld_196\"></a>Parallel Compact Collector (ParallelOld)</h3>\n<p>young = parallel = 2</p>\n<p>old = parallel，分成多个独立的单元，如果单元中live object少则回收，多则跳过</p>\n<p>优点：old old generation上性能较 parallel 方式有提高</p>\n<p>缺点：大部分server系统old generation内存占用会达到60%-80%, 没有那么多理想的单元live object很少方便迅速回收，同时compact方面开销比起parallel并没明显减少。</p>\n<h3><a id=\"Concurrent_MarkSweepCMS_Collector_206\"></a>Concurrent Mark-Sweep(CMS) Collector</h3>\n<p>young generation = parallel collector = 2</p>\n<p>old = cms</p>\n<p>同时不做 compact 操作。</p>\n<p>优点：pause time会降低, pause敏感但CPU有空闲的场景需要建议使用策略4.</p>\n<p>缺点：cpu占用过多，cpu密集型服务器不适合。另外碎片太多，每个object的存储都要通过链表连续跳n个地方，空间浪费问题也会增大。</p>\n<h2><a id=\"_218\"></a>内存监控方法</h2>\n<ul><li> <p>jmap -heap 查看java 堆（heap）使用情况</p> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p><code>jmap -heap pid</code></p> <p><code>using thread-</code> <code>local</code> <code>object allocation.</code></p> <p><code>Parallel GC with 4 thread(s)??</code> <code>#GC 方式</code></p> <p><code>Heap Configuration:?</code> <code>#堆内存初始化配置</code></p> <p><code>MinHeapFreeRatio=40?</code> <code>#对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</code></p> <p><code>MaxHeapFreeRatio=70?</code> <code>#对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</code></p> <p><code>MaxHeapSize=512.0MB?</code> <code>#对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</code></p> <p><code>NewSize? = 1.0MB????</code> <code>#对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</code></p> <p><code>MaxNewSize =4095MB??</code> <code>#对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</code></p> <p><code>OldSize? = 4.0MB????</code> <code>#对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</code></p> <p><code>NewRatio? = 8???????</code> <code>#对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</code></p> <p><code>SurvivorRatio = 8???</code> <code>#对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值</code></p> <p><code>PermSize= 16.0MB????</code> <code>#对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</code></p> <p><code>MaxPermSize=64.0MB??</code> <code>#对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</code></p> <p><code>Heap Usage:?????????</code> <code>#堆内存分步</code></p> <p><code>PS Young Generation</code></p> <p><code>Eden Space:????????</code> <code>#Eden区内存分布</code></p> <p><code>capacity = 20381696 (19.4375MB)????????????</code> <code>#Eden区总容量</code></p> <p><code>used???? = 20370032 (19.426376342773438MB)?</code> <code>#Eden区已使用</code></p> <p><code>free</code> <code>= 11664 (0.0111236572265625MB)????</code> <code>#Eden区剩余容量</code></p> <p><code>99.94277218147106% used????????????????????</code> <code>#Eden区使用比率</code></p> <p><code>From Space:???????</code> <code>#其中一个Survivor区的内存分布</code></p> <p><code>capacity = 8519680 (8.125MB)</code></p> <p><code>used???? = 32768 (0.03125MB)</code></p> <p><code>free</code> <code>= 8486912 (8.09375MB)</code></p> <p><code>0.38461538461538464% used</code></p> <p><code>To Space:?????????</code> <code>#另一个Survivor区的内存分布</code></p> <p><code>capacity = 9306112 (8.875MB)</code></p> <p><code>used???? = 0 (0.0MB)</code></p> <p><code>free</code> <code>= 9306112 (8.875MB)</code></p> <p><code>0.0% used</code></p> <p><code>PS Old Generation?</code> <code>#当前的Old区内存分布</code></p> <p><code>capacity = 366280704 (349.3125MB)</code></p> <p><code>used???? = 322179848 (307.25464630126953MB)</code></p> <p><code>free</code> <code>= 44100856 (42.05785369873047MB)</code></p> <p><code>87.95982001825573% used</code></p> <p><code>PS Perm Generation</code> <code>#当前的 “永生代” 内存分布</code></p> <p><code>capacity = 32243712 (30.75MB)</code></p> <p><code>used???? = 28918584 (27.57891082763672MB)</code></p> <p><code>free</code> <code>= 3325128 (3.1710891723632812MB)</code></p> <p><code>89.68751488662348% used</code></p> </li><li> <p>JVM内存监控工具</p> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p><code>&lt;%@ page import=\"java.lang.management.*\" %&gt;</code></p> <p><code>&lt;%@ page import=\"java.util.*\" %&gt;</code></p> <p><code>&lt;</code> <code>html</code> <code>&gt;</code></p> <p><code>&lt;</code> <code>head</code> <code>&gt;</code></p> <p><code>??</code> <code>&lt;</code> <code>title</code> <code>&gt;JVM Memory Monitor&lt;/</code> <code>title</code> <code>&gt;</code></p> <p><code>&lt;/</code> <code>head</code> <code>&gt;</code></p> <p><code>&lt;</code> <code>body</code> <code>&gt;</code></p> <p><code>&lt;</code> <code>table</code> <code>border</code> <code>=</code> <code>\"0\"</code> <code>width</code> <code>=</code> <code>\"100%\"</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>colspan</code> <code>=</code> <code>\"2\"</code> <code>align</code> <code>=</code> <code>\"center\"</code> <code>&gt;&lt;</code> <code>h3</code> <code>&gt;Memory MXBean&lt;/</code> <code>h3</code> <code>&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>width</code> <code>=</code> <code>\"200\"</code> <code>&gt;Heap Memory Usage&lt;/</code> <code>td</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;&lt;%=ManagementFactory.getMemoryMXBean().getHeapMemoryUsage()%&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;Non-Heap Memory Usage&lt;/</code> <code>td</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;&lt;%=ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage()%&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>colspan</code> <code>=</code> <code>\"2\"</code> <code>&gt;&amp;nbsp;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>colspan</code> <code>=</code> <code>\"2\"</code> <code>align</code> <code>=</code> <code>\"center\"</code> <code>&gt;&lt;</code> <code>h3</code> <code>&gt;Memory Pool MXBeans&lt;/</code> <code>h3</code> <code>&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>&lt;%</code></p> <p><code>????????</code> <code>Iterator iter = ManagementFactory.getMemoryPoolMXBeans().iterator();</code></p> <p><code>????????</code> <code>while (iter.hasNext()) {<!-- --></code></p> <p><code>????????????</code> <code>MemoryPoolMXBean item = (MemoryPoolMXBean) iter.next();</code></p> <p><code>%&gt;</code></p> <p><code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>colspan</code> <code>=</code> <code>\"2\"</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;</code> <code>table</code> <code>border</code> <code>=</code> <code>\"0\"</code> <code>width</code> <code>=</code> <code>\"100%\"</code> <code>style</code> <code>=</code> <code>\"border: 1px #98AAB1 solid;\"</code> <code>&gt;</code></p> <p><code>????????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>colspan</code> <code>=</code> <code>\"2\"</code> <code>align</code> <code>=</code> <code>\"center\"</code> <code>&gt;&lt;</code> <code>b</code> <code>&gt;&lt;%= item.getName() %&gt;&lt;/</code> <code>b</code> <code>&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>width</code> <code>=</code> <code>\"200\"</code> <code>&gt;Type&lt;/</code> <code>td</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;&lt;%= item.getType() %&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;Usage&lt;/</code> <code>td</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;&lt;%= item.getUsage() %&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;Peak Usage&lt;/</code> <code>td</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;&lt;%= item.getPeakUsage() %&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????????</code> <code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;Collection Usage&lt;/</code> <code>td</code> <code>&gt;&lt;</code> <code>td</code> <code>&gt;&lt;%= item.getCollectionUsage() %&gt;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>????</code> <code>&lt;/</code> <code>table</code> <code>&gt;</code></p> <p><code>&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>&lt;</code> <code>tr</code> <code>&gt;&lt;</code> <code>td</code> <code>colspan</code> <code>=</code> <code>\"2\"</code> <code>&gt;&amp;nbsp;&lt;/</code> <code>td</code> <code>&gt;&lt;/</code> <code>tr</code> <code>&gt;</code></p> <p><code>&lt;%} %&gt;</code></p> <p><code>&lt;/</code> <code>table</code> <code>&gt;</code></p> <p><code>&lt;/</code> <code>body</code> <code>&gt;</code></p> <p><code>&lt;/</code> <code>html</code> <code>&gt;</code></p> </li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:36:10", "summary": "堆内存和非堆内存堆和非堆内存按照官方的说法：虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在虚拟机启动时创建的。在中堆之外的内存称为非堆内存。主要管理两种类型的内存：堆"}