{"blogid": "125509256", "writerAge": "码龄1年", "writerBlogNum": "161", "writerCollect": "407", "writerComment": "122", "writerFan": "48", "writerGrade": "5级", "writerIntegral": "2084", "writerName": "小天狼星_布莱克", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125509256.jpg", "writerRankTotal": "9986", "writerRankWeekly": "1467", "writerThumb": "353", "writerVisitNum": "31291", "blog_read_count": "1256", "blog_time": "于 2022-06-28 20:50:56 发布", "blog_title": "C++简单排序——选择排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>今天我们来学习一种新的排序方法——选择排序。</p>\n<p>上一次我们学习了一种简单的排序——冒泡排序。<s>但有的人啊，他就是说：“冒泡排序太难记了！换一种！” </s>于是，<s>无敌天才</s> 我决定发一下我认为最好记的排序之一——选排。</p>\n<p>选择排序：选出一个作为基本位置，然后再把位置的数和后面的依次比较，交换，将基本位置的数确定好，重复，直到完成排序。</p>\n<p>文字看不懂，看看具体操作：将数列：4 9 2 8 6  从小到大排序。</p>\n<p>第一步： 4 9 2 8 6      // 基本位置是第一位：4，开始比较。4＜9，不交换。</p>\n<p>第二步： 2 9 4 8 6      // 接下来将 4 2 比较，交换。</p>\n<p>第三步： 2 9 4 8 6      // 将 2 8 比较，不交换。</p>\n<p>第四步： 2 9 4 8 6      // 将 2 6 比较，不交换。</p>\n<p>//现在完成了最小数放在最前面，用了4次比较，1次交换。</p>\n<p>第五步： 2 4 9 8 6      // 基本位置是第二位：9，开始比较。4＜9，交换。</p>\n<p>第六步： 2 4 9 8 6      // 将 4 8 比较，不交换。</p>\n<p>第七步： 2 4 9 8 6      // 将 4 8 比较，不交换。</p>\n<p>//我们已经将第2小数放到第2位，用了3次比较，1次交换。</p>\n<p>第八步： 2 4 8 9 6      // 将 9 8 比较，交换。</p>\n<p>第九步： 2 4 6 9 8     // 将 8 6 比较，交换。</p>\n<p>//我们已经将第3小数放到第3位，用了2次比较，2次交换。现在要将第4小数放到第4位。</p>\n<p>第十步： 2 4 6 8 9      // 将 9 8 比较，交换。</p>\n<p>这时，程序结束了。我们也将数列排好了。每一次的交换如下：</p>\n<p>4 9 2 8 6</p>\n<p>2 9 4 8 6</p>\n<p>2 4 9 8 6</p>\n<p>2 4 8 9 6</p>\n<p>2 4 6 9 8</p>\n<p>2 4 6 8 9</p>\n<p>排序结束。</p>\n<p>知道了基本原理，代码也就好打了（将整形的数从小到大排序）：</p>\n<pre><code>\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nint n,i,j,a[2000];\nbool t;              //定义变量\n\nint main()\n{\n\tcin &gt;&gt;n;\n\tfor (i=1;i&lt;=n;i++)\n\t\tcin &gt;&gt;a[i];       //输入\n\n\tfor (i=1;i&lt;n;i++)        //从1开始，最后一位不用比\n\t\tfor (j=i+1;j&lt;=n;j++)\n\t\t\tif (a[i]&gt;a[j])        //a[i]是基本位，a[j]是当前位\n\t\t\t\tswap(a[i],a[j]);     //交换\n\n\tfor (i=1;i&lt;=n;i++)\n\t\tcout &lt;&lt;a[i] &lt;&lt;\" \";        //输出\n\n\treturn 0;        //华丽结束\n}</code></pre>\n<p><br/> 选择排序时间复杂度为O（n²），比计数排序要慢，和冒泡排序一样，但没有数据类型和范围的局限（当然，范围不能太大），是一种很好记的不稳定排序。</p>\n<p>选择排序讲解完毕，别忘了点个赞哦。</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-28 20:50:56", "summary": "今天我们来学习一种新的排序方法选择排序。上一次我们学习了一种简单的排序冒泡排序。但有的人啊，他就是说：冒泡排序太难记了！换一种！于是，无敌天才我决定发一下我认为最好记的排序之一选排。选择排序：选出一个"}