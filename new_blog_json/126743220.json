{"blogid": "126743220", "writerAge": "码龄24天", "writerBlogNum": "52", "writerCollect": "3", "writerComment": "4", "writerFan": "219", "writerGrade": "3级", "writerIntegral": "538", "writerName": "web13262315245", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743220.jpg", "writerRankTotal": "35602", "writerRankWeekly": "5568", "writerThumb": "4", "writerVisitNum": "2982", "blog_read_count": "10", "blog_time": "于 2022-09-07 12:33:46 发布", "blog_title": "JVM GC与频繁GC", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>内容：</p>\n<p>1.JVM GC的内存管理</p>\n<p>2.频繁 GC 的原因</p>\n<h2><a id=\"JVM_GC_8\"></a>一、JVM GC的内存管理</h2>\n<h3><a id=\"1JVM_11\"></a>1.JVM内存分布图</h3>\n<p><img alt=\"\" src=\"https://img-blog.csdn.net/20160820021751634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"/></p>\n<h2><a id=\"2JVM_GC_15\"></a>2.JVM GC运行原理</h2>\n<h4><a id=\"1_18\"></a>(1)从对象角度来看</h4>\n<p>在JVM进行GC时，内存中存在新生代（年轻代）、老年代（年老代）、永久带。</p>\n<p>在我们运行程序时，会创建很多对象。</p>\n<p>1）从生命周期上看：</p>\n<p>根据经验，绝大多数对象在使用过之后就不会在使用了。也就是说这些对象的使用的生命周期比较短。当然相应的，也有一少部分对象的生命周期会比较长。</p>\n<p>2)从对象大小上看</p>\n<p>在这些对象中会有很多小对象，和一些的大对象。</p>\n<p>因此，JVM在进行GC时就要从两方面来考虑GC问题。</p>\n<p>1)针对对象大小比较小且对象的生命周期比较短，会通过频繁GC把这些对象从内存中清除出去。</p>\n<p>2)对于对象大小比较大或者对象的生命周期比较长，一般不会通过频繁GC的方式，而是将这些对象放到老年代。</p>\n<h4><a id=\"2JVMJVM_GC_38\"></a>(2)从JVM的内存空间来看JVM GC</h4>\n<p>新生代有Eden（伊甸园）、From（Survivor 1）、To（Survivor 2）区域。</p>\n<p>Eden（伊甸园）主要用于存放新创建的对象，它会在第一次GC时，将对其内部的存活的对象放入到From或者To区域。但我们仍可以使用这些对象。</p>\n<p>From与To区域都是用Survivor区域，主要用于GC时，在对象复制时，提供作用，以及承担新生代与老年代之间的缓冲带的作用。</p>\n<p>就整个新生代来说，会进行频繁的GC。</p>\n<p>而老年代，则存放经过几次（一定次数）的GC仍存在的对象或者是大对象以及生命周期比较长的对象。</p>\n<p>GC的过程：</p>\n<p>当对象创建后会进入Eden中、垃圾收集器进行垃圾回收时，会扫描Eden以及From区域。如果对象仍然存活，即在进行GC时，对象仍存活。此时，就会将该对象由Eden、From复制到To区域。如果从Eden或Form区域进行对象复制操作时，To区域已经满了，则会直接将对象放入到老年代（Old Generation）。而在对象复制后，To区域中存在的对象就是有效的对象，此时会将To区域与From区域交换，然后将无效对象清除，即将From区域（此时已经经过交换而成为To区域）与Eden清空。所以我们说Old Generation是经过几次GC后仍存在的对象，其实最小的次数有可能是0次，这是因为如果对象特别大，就会在其创建时，直接将其放入到老年代；也有可能是1次，例如：当进行第一次GC时，要将Eden中的对象放入到To区域，但是此时To区域已经满了，那么对象就会直接放入到老年代了。在GC时，JVM还会对From区域中的对象进行扫描，发现进过几次GC仍然存在的对象，也会放入老年代中。然后再进行清空操作。</p>\n<p>从新生代GC的过程，我们可以看出年轻代的垃圾回收采用的是复制的方式进行。</p>\n<p>其次，Eden中的对象复制到老年代之前会用个缓冲地带（Survivor区域），Survivor缓冲地带主要是方便对象复制而设计的。采用复制进行对象的回收的好处是，不会产生内存碎片，此处采用了空间换时间的方式来加快垃圾回收过程。（这里需要提供两倍的内存空间，Survivor1和Survivor2。）</p>\n<p>对于老年代，其中放置的是进过几次GC仍然存在的对象，或者是大对象；老年代一般占用内存空间也较大，但是可以通过参数设置。相对而言，这部分不会进行频繁的GC（正常情况下，1h或者10h进行一次GC）。</p>\n<p>1.若在服务器端发生Full GC（老年代发生GC）对性能影响相当大，可能会造成服务器不响应的现象。</p>\n<p>2.Full GC：一般老年代和永久代发生GC，都为Full GC。</p>\n<p>在老年代中，对象可以采用压缩方式存储也可以不采用压缩方式存储，主要看具体的实现。</p>\n<p>对于永久代（PermanentGeneration）来说，其中存放的是类的定义，类的字节码，常量等，其中发生GC的时机或者条件：类的所有实例对象都被GC掉了，同时类的加载器也被回收掉了。</p>\n<h2><a id=\"GC_68\"></a>二、频繁GC</h2>\n<h3><a id=\"1GC_71\"></a>1.频繁GC的原因：</h3>\n<h4><a id=\"1_73\"></a>(1)人为原因</h4>\n<p>例如在代码中调用System#GC或者Runtime#GC方法。</p>\n<h4><a id=\"2_77\"></a>(2)框架原因</h4>\n<p>在java程序调用相关框架时，框架内部调用了GC方法。</p>\n<h4><a id=\"3_81\"></a>(3)内存原因</h4>\n<p>当heap大小设置比较小时，会引起频繁的GC，所以在类似于Spark这样对内存性能要求比较高的应用程序运行时，应可能给heap分配较大的内存，这样可以减少频繁的GC现象的发生。</p>\n<h4><a id=\"4_85\"></a>(4)其他原因</h4>\n<p>当构建的对象实例化十分频繁并且释放该对象也较为频繁时，同样会产生频繁GC现象。</p>\n<p>&amp; Scala是一种面向函数式和面向对象相结合的编程语言。从面向函数式编程风格来说，创建的对象一般都是不可变的。这样就给内存的管理带来了极大的好处，避免由于对象频繁的改变而造成的GC。同时，不可变对象也可以在代码中被其他函数复用。</p>\n<p>&amp; 对用复用来说，是一把双刃剑。复用即通过缓存对对象进行使用。Cache级别的对象，若是其缓存命中很高时，此时应尽量复用这些对象。若cache命中率不高时，此时既占用内存，又会消耗IO、CPU等内存等资源。</p>\n<p>&amp; 一般来说，进行GC时，保证heap 50%的剩余空间，相对来说是比较合适的。并且需要统计缓存命中率的问题，其命中率越高越好。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:33:46", "summary": "内容：的内存管理频繁的原因一、的内存管理内存分布图运行原理从对象角度来看在进行时，内存中存在新生代年轻代、老年代年老代、永久带。在我们运行程序时，会创建很多对象。从生命周期上看：根据经验，绝大多数对象"}