{"blogid": "124635746", "writerAge": "码龄2年", "writerBlogNum": "70", "writerCollect": "3151", "writerComment": "3018", "writerFan": "12168", "writerGrade": "6级", "writerIntegral": "8019", "writerName": "程序猿追", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124635746.jpg", "writerRankTotal": "1707", "writerRankWeekly": "74", "writerThumb": "2783", "writerVisitNum": "110833", "blog_read_count": "4339", "blog_time": "已于 2022-07-12 15:19:57 修改", "blog_title": "【算法合集】八大排序算法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅🎡个人主页：<a class=\"link-info\" href=\"https://blog.csdn.net/aasd23?spm=1000.2115.3001.5343\" title=\"程序猿追\">程序猿追</a></p>\n<p>✅🎡系列专栏：<a class=\"link-info\" href=\"https://blog.csdn.net/aasd23/category_11805404.html?spm=1001.2014.3001.5482\" title=\"算法合集\">算法合集</a></p>\n<p>✅🎡目前状态：创建Java学习之路（零基础到就业实战）系列，目前更新到JAVAWEB开发</p>\n<p>✅🎡作者简介：大家好，我是程序猿追，全栈领域新星创作者，算法爱好者，常在作者周榜排名前30，某不知名的 ACMer</p>\n<p>✅🎡推荐一款刷题面试找工作三不误的网站——<a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf\" title=\"牛客网\">牛客网</a></p>\n<p>✅🎡个人名言：不积跬步无以至千里，趁年轻，使劲拼，给未来的自己一个交代！</p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D\">开篇介绍</a></p>\n<p id=\"%E9%A6%96%E5%85%88%E5%95%A5%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A6%96%E5%85%88%E5%95%A5%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F\">首先啥是排序？</a></p>\n<p id=\"%E2%80%8B%E4%B8%80%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B%E4%B8%80%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">​一、插入排序</a></p>\n<p id=\"1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">1、直接插入排序</a></p>\n<p id=\"2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">2、希尔排序</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">二、选择排序</a></p>\n<p id=\"1%E3%80%81%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">1、简单选择排序</a></p>\n<p id=\"2%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F\">2、堆排序</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F\">三、交换排序</a></p>\n<p id=\"1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">1、冒泡排序</a></p>\n<p id=\"2%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">2、快速排序</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">四、归并排序</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\">五、基数排序</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93%C2%A0\">总结 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D\">开篇介绍</h1>\n<h2 id=\"%E9%A6%96%E5%85%88%E5%95%A5%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F\">首先啥是排序？</h2>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">排序</span>是计算机内经常进行的一种操作，其<span style=\"color:#be191c;\">目的是将一组“无序”的记录序列调整为“有序”的记录序列</span>。分内部排序和外部排序，<span style=\"color:#956fe7;\">若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序</span>。内部排序的过程是一个逐步扩大记录的有序序列长度的过程。</p>\n<p>上面的话可以理解为排序可以分为外部排序（内存与外存的相结合使用）和内部排序（使用了内存）。</p>\n<p><img alt=\"\" height=\"200\" src=\"https://img-blog.csdnimg.cn/154003c7c63940f58259c08592c616e9.gif\" width=\"200\"/></p>\n</blockquote>\n<p><span style=\"background-color:#fe2c24;\">内部排序分为：</span><span style=\"color:#38d8f0;\">插入排序（</span><span style=\"color:#fe2c24;\">直接插入排序和希尔排序</span><span style=\"color:#38d8f0;\">）、选择排序（</span><span style=\"color:#fe2c24;\">简单选择排序和堆排序</span><span style=\"color:#38d8f0;\">）、交换排序（</span><span style=\"color:#fe2c24;\">冒泡排序和快速排序</span><span style=\"color:#38d8f0;\">）、</span><span style=\"color:#fe2c24;\">归并排序、基数排序</span>，如下图所示。那么下面我们来看看吧。</p>\n<p></p>\n<p><img alt=\"\" height=\"900\" src=\"..\\..\\static\\image\\c10031f78abc4b1694f858f02e244153.png\" width=\"1200\"/></p>\n<p></p>\n<h1 id=\"%E2%80%8B%E4%B8%80%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">​一、插入排序</h1>\n<h2 id=\"1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">1、直接插入排序</h2>\n<blockquote>\n<p><strong>插入排序我们可以理解为</strong>，<u>满足某一条件后，将当前的值插入到当前符合调节的位置上。通俗的来讲直接插入排序很像抓扑克，在我们抓扑克时候按顺序依次比较，符合条件后，再将扑克插入当位置上</u>。<s>（17张牌你能秒我？）走错过场了</s>。我们先来看看动图。</p>\n</blockquote>\n<p><img alt=\"\" height=\"739\" src=\"https://img-blog.csdnimg.cn/a786c5b6e55a4422b68efb0f2b49b114.gif\" width=\"1034\"/></p>\n<p></p>\n<p><strong>是不是很像抓扑克？我们来看看插入排序的代码</strong></p>\n<pre><code class=\"language-cpp\">void InsertSort(int *a,int n)\n{\n    for(int i = 1; i &lt; n; i ++)\n    {\n        int j = i - 1, k = a[i];\n        while(j &gt;= 0 &amp;&amp; a[j] &gt; k)\n        {\n            a[j + 1] = a[j];\n            j --;\n        }\n        a[j + 1] = k;\n    }\n}</code></pre>\n<p><strong>定义一个数组（int a[] = {7,12,6,34,9,11,26,17,40,3};），跑一下数据。</strong></p>\n<p><img alt=\"\" height=\"547\" src=\"..\\..\\static\\image\\787b54a716424f128bb5c626cbe2c954.png\" width=\"1097\"/></p>\n<p></p>\n<h2 id=\"2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">2、希尔排序</h2>\n<blockquote>\n<p><strong>希尔排序就是</strong><u>将数组的长度对半分设置为步长，选择步长一一相对的元素，将小的放前面，做完一轮后，缩小步长（一般 缩小的直接除二），继续重复上面的的操作</u>，我们来看看下面的的图。</p>\n</blockquote>\n<p></p>\n<p><img alt=\"\" height=\"887\" src=\"..\\..\\static\\image\\23eb81046e39465581209e98d4d520e1.png\" width=\"1200\"/></p>\n<p></p>\n<p><strong>直接看代码咯（同样是和上面的数据）</strong></p>\n<pre><code class=\"language-cpp\">void ShellSort(int a[],int n) {\n\tint temp,j,i;\n\tint mid = ceil(n /2);\n\tfor (mid; mid &gt;= 1; mid = ceil(mid / 2)) {\n\t\tfor (i = mid;i &lt; n;i++) {\n\t\t\tif (a[i] &lt; a[i - mid]) {\n\t\t\t\ttemp = a[i];\n\t\t\t\tfor (j = i - mid;j &gt;=0 &amp;&amp; a[j] &gt; temp;j=j-mid) {\n\t\t\t\t\ta[j + mid] = a[j];\n\t\t\t\t}\n\t\t\t\ta[j + mid] = temp;\n\t\t\t}\n\t\t}\n\t}\n}</code></pre>\n<p><img alt=\"\" height=\"640\" src=\"..\\..\\static\\image\\d9ffcaa4e8ce44858af1afed15dbcf6b.png\" width=\"1200\"/></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">二、选择排序</h1>\n<h2 id=\"1%E3%80%81%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">1、简单选择排序</h2>\n<blockquote>\n<p><strong>简单选择排序</strong>就是<u>我们扫描一个数组（下标 0 ~ n - 1），来找到当前最小值，找到之后，将最小值放入到最左边（下标为0），然后在扫描数组（1 ~ n - 1），找到最小值，放到最左边（下标为1）依次执行</u>，来看看效果图。</p>\n</blockquote>\n<p><img alt=\"\" height=\"738\" src=\"https://img-blog.csdnimg.cn/fce7d686069d43b1b3a11de49fe8970e.gif\" width=\"1034\"/></p>\n<blockquote>\n<p><strong> 是不是感觉如此的 so easy ？哈哈哈，我们来看看代码。</strong></p>\n<p><img alt=\"\" height=\"115\" src=\"https://img-blog.csdnimg.cn/38b125bcc1414ebf86043f23a8f63ae4.gif\" width=\"115\"/></p>\n</blockquote>\n<pre><code class=\"language-cpp\">void SelectSort(int a[] ,int n)\n{\n\n\tfor(int i = 0; i &lt; n; i ++)\n    {\n\t\tint Index = i;\n\t\tfor(int j = i + 1; j &lt; n; j ++)\n        {\n\t\t\tif(a[j] &lt; a[Index])\n\t\t\t{\n\t\t\t\tIndex = j;\n\t\t\t}\n\t\t}\n\t\tswap(a[i] ,a[Index]);\n\t}\n}\n</code></pre>\n<p> <img alt=\"\" height=\"509\" src=\"..\\..\\static\\image\\4488ea48fc984941b11bbb30eca0e434.png\" width=\"1080\"/></p>\n<h2 id=\"2%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F\">2、堆排序</h2>\n<blockquote>\n<p><strong>堆排序：</strong>堆它是一颗完全二叉树，我们要记得<span style=\"background-color:#faa572;\">啥是小根堆？啥是大根堆？</span>（ <span style=\"background-color:#ed7976;\">孩子节点都大于等于父节点是小根堆，或者 孩子节点都小于等于父节点是大根堆</span>）</p>\n<p>因为是完全二叉树，则 i &gt;= n / 2， i 表示叶子节点</p>\n<p><u>先从 n / 2 的位置开始调整，大根堆，根节点位置都大于孩子节点，跟小则互调。</u></p>\n<p><u>之后调整 n / 2 - 1节点，递推。如果互调后被调节点仍有孩子节点，则递归上述步骤</u></p>\n<p><u>之后根节点与最后序列元素对调，并断开与父节点关系。一直递归下去</u>，我们可以看下面的图加以理解。</p>\n</blockquote>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/20181126103327180.gif\"/></p>\n<p></p>\n<p><strong>看完图之后我们来看看代码。</strong></p>\n<pre><code class=\"language-cpp\">\nvoid AdjustHeap(int a[], int r, int l){\n        int left = 2 * r + 1;\n        int right = 2 * r + 2;\n        int Max = r;\n        if( left &lt; l &amp;&amp; a[left] &gt; a[Max])\n                Max = left;\n        if( right &lt; l &amp;&amp; a[right] &gt; a[Max])\n                Max = right;\n        if(Max != r){\n                swap( a[Max], a[r]);\n                AdjustHeap(a, Max, l);\n        }\n}\n\nvoid HeapSort(int* a, int len){\n        for(int i = len/2 -1; i &gt;= 0; --i)\n                AdjustHeap(a, i, len);\n\n        for(int i = len - 1; i &gt;= 0; i--){\n                swap(a[0], a[i]);\n                AdjustHeap(a, 0 , i);\n        }\n}</code></pre>\n<p> <img alt=\"\" height=\"568\" src=\"..\\..\\static\\image\\69d144f2b4384b3da882a9499031b2d9.png\" width=\"1200\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F\">三、交换排序</h1>\n<h2 id=\"1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">1、冒泡排序</h2>\n<blockquote>\n<p><strong>冒泡排序</strong><u>作为我们学 c 语言的第一个算法相信大家都不会陌生吧？它是选择两个相邻的数据进行比较 ，将小的数移到左边，然后再选择下一对两两相对的数进行比较，依次执行</u>，看看效果图。</p>\n</blockquote>\n<p><img alt=\"\" height=\"738\" src=\"https://img-blog.csdnimg.cn/ff5a1751cfda4ea68938aa9db5fa58d3.gif\" width=\"1034\"/>​</p>\n<p><strong>我们直接来看看代码</strong></p>\n<div>\n<pre><code class=\"language-cpp\">void BubbleSort(int a[],int len)\n                                \n{\n\tfor (int i = 0; i &lt; len - 1; i ++)\t\n\t{\n\t\tfor (int j = 0; j &lt; len - i - 1; j ++)\t \n\t\t{\n\t\t\tif(a[j + 1] &lt; a[j])\t\n\t\t\t{\n\t\t\t\tint temp = a[j];\n\t\t\t\ta[j] = a[j+1];\n\t\t\t\ta[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\t\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"512\" src=\"..\\..\\static\\image\\6a0b528abcc4433cafb63a082203e212.png\" width=\"999\"/>​</p>\n<p></p>\n<h2 id=\"2%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">2、快速排序</h2>\n<blockquote>\n<p><strong>快速排序的理解：</strong><u>每次选择数组的第一个元素作为记号，<span style=\"color:#fe2c24;\">大于这个记号的都放在它的右边，凡是小于这个记号的都放在它的左边</span>，我们有两个变量 i 和 j ，设第一个元素作为记号 ，i 指向序列的最左边（下标为 0），<span style=\"color:#fe2c24;\">j 指向序列的最右边（下标为n - 1），j 从右往左走（j --），i 从左往右走(i ++)</span>，<span style=\"color:#a2e043;\">直到 j 找到小于记号就停止，i 找到大于记号就停止，交换 i 和 j 指向的两个数，j 继续往左走，i 继续往右走,如果 i 和 j 相遇(i == j)，则 i 或 j 上的元素与记号交换</span>，则这一轮排序结束，然后继续执行以上操作。</u></p>\n</blockquote>\n<p><img alt=\"\" height=\"738\" src=\"https://img-blog.csdnimg.cn/987542be646c465ea366978fbc64f762.gif\" width=\"1034\"/>​</p>\n<blockquote>\n<p><span style=\"background-color:#a2e043;\"> 加油呀~都看到这里了，再坚持坚持~</span></p>\n<p><img alt=\"\" height=\"76\" src=\"https://img-blog.csdnimg.cn/146a9fb094e049e2ac72d0f7542d0f86.gif\" width=\"76\"/></p>\n</blockquote>\n<p><strong>话不多说，直接看代码</strong></p>\n<div>\n<pre><code class=\"language-cpp\">void QuickSort(int a[], int l, int r){\n\n    if(l &gt;= r) return;\n\n    int x = a[l], i = l - 1, j = r + 1;\n    while(i &lt; j){\n        do i ++; while(a[i] &lt; x);\n        do j --; while(a[j] &gt; x);\n        if(i &lt; j) swap(a[i], a[j]);\n    }\n\n    QuickSort(a, l, j);\n    QuickSort(a, j + 1, r);\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"523\" src=\"..\\..\\static\\image\\86491c3a2d0d40f4ad1c55dd5cfb371d.png\" width=\"1182\"/>​</p>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">四、归并排序</h1>\n<blockquote>\n<p><strong>归并排序</strong><u>是将序列分成两个小大致的两个子序列，再分别对两个序列调用归并排序，最终将排序好的序列合并成要求的排序好的序列</u>。</p>\n</blockquote>\n<p><img alt=\"\" height=\"738\" src=\"https://img-blog.csdnimg.cn/d23e3ad05ccd425e80e58ef478f83c51.gif\" width=\"1034\"/>​</p>\n<p></p>\n<p><strong>我们来看看代码</strong></p>\n<div>\n<pre><code class=\"language-cpp\">void MergeSort(int a[], int l, int r){\n    if(l &gt;= r) return ;\n    int mid = (l + r) &gt;&gt; 1;\n    MergeSort(a, l, mid);\n    MergeSort(a, mid + 1, r);\n    int k = 0, i = l, j = mid + 1;\n    while(i &lt;= mid &amp;&amp; j &lt;= r){\n        if(a[i] &lt;= a[j]) t[k++] = a[i++];\n        else t[k++] = a[j++];\n    }\n    while(i &lt;= mid){\n        t[k++] = a[i++];\n    }\n    while(j &lt;= r){\n        t[k++] = a[j++];\n    }\n    for(int i = l, j = 0; j &lt;= k - 1; ){\n        a[i++] = t[j++];\n    }\n}</code></pre>\n</div>\n<p></p>\n<p><img alt=\"\" height=\"627\" src=\"..\\..\\static\\image\\f4ac2f37f7e44248b2e005d08be01682.png\" width=\"1037\"/>​</p>\n<p></p>\n<h1 id=\"%E4%BA%94%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\">五、基数排序</h1>\n<blockquote>\n<p><strong>基数排序</strong><u>是一种非比较型整数排序算法，<span style=\"color:#fe2c24;\">原理是将众多数字按位分隔后进行排序。将所有待比较的数字（正整数）统一为同一长度（即最长的那一个位数），位数不够的数字前面补0（如最大为数是3，那么 8 就是 008）；按照从个位，十位，百位······从低到高的顺序进行排序（可以理解为切尾巴）</span>；完成从低位到高位的排序后，待排序数字也就完成了排序</u>，我们来看看效果图。</p>\n</blockquote>\n<p><img alt=\"\" height=\"738\" src=\"https://img-blog.csdnimg.cn/6ed16d7c02c4412ba4aafa624b86fffc.gif\" width=\"1200\"/>​</p>\n<blockquote>\n<p><span style=\"background-color:#38d8f0;\"> 快结束了，再坚持坚持，加油加油~</span></p>\n<p><img alt=\"\" height=\"120\" src=\"https://img-blog.csdnimg.cn/61ee7f5376204d37899b2a795bf444ed.gif\" width=\"120\"/></p>\n</blockquote>\n<p><strong>代码如下</strong></p>\n<div>\n<pre><code class=\"language-cpp\">int MaxDigit(int a[], int n)\n{\n    int t = 1;\n    int p = 10;\n    for(int i = 0; i &lt; n; ++i)\n    {\n        while(a[i] &gt;= p)\n        {\n            p *= 10;\n            ++ t;\n        }\n    }\n    return t;\n}\nvoid indexSort(int a[], int n)\n{\n    int d = MaxDigit(a, n);\n    int t[n];\n    int count1[10];\n    int i, j, k;\n    int index = 1;\n    for(i = 1; i &lt;= d; i++)\n    {\n        for(j = 0; j &lt; 10; j++)\n            count1[j] = 0;\n        for(j = 0; j &lt; n; j++)\n        {\n            k = (a[j] / index) % 10;\n            count1[k]++;\n        }\n        for(j = 1; j &lt; 10; j++)\n            count1[j] = count1[j - 1] + count1[j];\n        for(j = n - 1; j &gt;= 0; j--)\n        {\n            k = (a[j] / index) % 10;\n            t[count1[k] - 1] = a[j];\n            count1[k]--;\n        }\n        for(j = 0; j &lt; n; j++)\n            a[j] = t[j];\n        index = index * 10;\n    }\n}</code></pre>\n</div>\n<p></p>\n<p><img alt=\"\" height=\"688\" src=\"..\\..\\static\\image\\9832a591174f45fe831cd2f9a9acb8f3.png\" width=\"1136\"/>​</p>\n<h1 id=\"%E6%80%BB%E7%BB%93%C2%A0\">总结 </h1>\n<blockquote>\n<p><strong>这里作出总结</strong>，在上面这些排序中，我们可以看到即使是不一样的排序它们都有<span style=\"color:#a2e043;\">各自的优势</span>，<span style=\"color:#fe2c24;\">有各自的时间复杂度与空间复杂度</span>。那么下面我们来看看。</p>\n</blockquote>\n<p><img alt=\"\" height=\"398\" src=\"..\\..\\static\\image\\03b4fce2bdd34b8d89c1bbe84bbb83c8.png\" width=\"1200\"/></p>\n<p></p>\n<div>\n<div>\n<blockquote>\n<p style=\"text-align:left;\"><span style=\"color:#333333;\">算法对程序员来说及其重要，语言和开发平台不断变化，但是万变不离其宗的是那些算法和理论，依稀记得我那个玩的很好的一个学长（在大二就拿到了 offer），他告诉我想找一个好的工作，那刷题一定是必不可少的</span></p>\n<p style=\"text-align:left;\"><span style=\"color:#333333;\">现在算法刷题平台还是蛮多的，给大家介绍一个我认为与大厂关联最深的平台——<a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf\" title=\"牛客网\">牛客网</a></span></p>\n</blockquote>\n</div>\n</div>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-12 15:19:57", "summary": "个人主页：程序猿追程序猿追系列专栏：算法合集算法合集目前状态：创建学习之路零基础到就业实战系列，目前更新到开发作者简介：大家好，我是程序猿追，全栈领域新星创作者，算法爱好者，常在作者周榜排名前，某不知"}