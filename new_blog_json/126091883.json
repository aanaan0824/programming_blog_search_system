{"blogid": "126091883", "writerAge": "码龄158天", "writerBlogNum": "22", "writerCollect": "214", "writerComment": "306", "writerFan": "127", "writerGrade": "4级", "writerIntegral": "1244", "writerName": "Node_Hao", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126091883.jpg", "writerRankTotal": "15734", "writerRankWeekly": "658", "writerThumb": "308", "writerVisitNum": "9792", "blog_read_count": "1250", "blog_time": "已于 2022-08-26 15:15:58 修改", "blog_title": "[Java]快速入门栈和队列,手撕相关面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/863ec7b6d72947baaeae544d53cf682e.gif\"/></p>\n<p></p>\n<blockquote>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\cb2be72a3c2b4b59b1128abf613b8abe.png\" width=\"16\"/>专栏简介 :<span style=\"color:#fe2c24;\">java语法及数据结构</span></p>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\1254c5b119a44cf0ae350489fb7736ad.png\" width=\"16\"/>题目来源:<span style=\"color:#38d8f0;\">leetcode,牛客,剑指offer</span></p>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\4366a93aaa3142b5a0f16c7a2200339b.png\" width=\"16\"/>创作目标:<span style=\"color:#a2e043;\">从java语法角度实现底层相关数据结构,达到手撕各类题目的水平</span>.</p>\n<p><img alt=\"\" height=\"15\" src=\"..\\..\\static\\image\\52a3437a932f4621b25533c330f7c6cb.png\" width=\"15\"/><span style=\"color:#956fe7;\">希望在提升自己的同时,帮助他人,与大家一起共同进步,互相成长.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"..\\..\\static\\image\\14aa2f0648ae44a299b8f9832af57d2c.png\" width=\"15\"/><span style=\"color:#fe2c24;\">学历代表过去,能力代表现在,学习能力代表未来!</span></p>\n</blockquote>\n<hr/>\n<blockquote>\n<h1 id=\"%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B\"><a id=\"_7\"></a></h1>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0\">一.栈的定义与实现</a></p>\n<p id=\"1)%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%3A-toc\" style=\"margin-left:40px;\"><a href=\"#1%29%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%3A\">1)栈的定义:</a></p>\n<p id=\"%C2%A02)%E6%A0%88%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02%29%E6%A0%88%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%3A\"> 2)栈常见操作方法:</a></p>\n<p id=\"%C2%A03)%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03%29%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%3A\"> 3)栈的实现:</a></p>\n<p id=\"%E4%BA%8C.%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">二.栈相关题目</a></p>\n<p id=\"1)%E9%80%86%E6%B3%A2%E5%85%B0%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1%29%E9%80%86%E6%B3%A2%E5%85%B0%E6%95%B0\">1)逆波兰数</a></p>\n<p id=\"2)%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%85%A5%E6%A0%88%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2%29%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%85%A5%E6%A0%88%E6%96%B9%E5%BC%8F\">2)不可能的入栈方式</a></p>\n<p id=\"3)%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-toc\" style=\"margin-left:40px;\"><a href=\"#3%29%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7\">3)有效括号</a></p>\n<p id=\"4)%E6%9C%80%E5%B0%8F%E6%A0%88-toc\" style=\"margin-left:40px;\"><a href=\"#4%29%E6%9C%80%E5%B0%8F%E6%A0%88\">4)最小栈</a></p>\n<p id=\"%E4%B8%89.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0\">三.队列的实现</a></p>\n<p id=\"1)%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-toc\" style=\"margin-left:40px;\"><a href=\"#1%29%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97\">1)单链表实现队列</a></p>\n<p id=\"2)%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc\" style=\"margin-left:40px;\"><a href=\"#2%29%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\">2)循环队列</a></p>\n<p id=\"%E5%9B%9B.%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B.%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">四.队列相关题目</a></p>\n<p id=\"1)%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1%29%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0\">1)用栈实现队列 </a></p>\n<p id=\"2)%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-toc\" style=\"margin-left:40px;\"><a href=\"#2%29%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88\">2)用队列实现栈</a></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n</blockquote>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<blockquote>\n<p>        Hello!大家好!我是Node_Hao,今天给大家带来的是<span style=\"color:#fe2c24;\">栈和队列的底层实现及其构造方法</span>,旨在<span style=\"color:#38d8f0;\">熟练掌握栈和队列的使用以后,可以手撕各类栈相关的题目</span>.希望我的文章能对你有所帮助与启发!</p>\n</blockquote>\n<hr/>\n<h1 id=\"%E4%B8%80.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0\">一.栈的定义与实现</h1>\n<h2 id=\"1)%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%3A\">1)栈的定义:</h2>\n<blockquote>\n<p>      栈是一种数据结构特点是\"<span style=\"color:#fe2c24;\">先进后出</span>\",基于这一特点栈<span style=\"color:#38d8f0;\">不管是push()(压入元素)还是pop()(弹出栈顶元素),时间复杂度都是O(1)</span>.而java虚拟机栈只是JVM中的一块内存,用来存放局部变量..... 调用函数时我们会在java虚拟机栈中开辟一块内存叫栈帧.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"643\" src=\"..\\..\\static\\image\\412cb90433e346fbbb006c434bebd35a.png\" width=\"1200\"/></p>\n<p>  </p>\n<h2 id=\"%C2%A02)%E6%A0%88%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%3A\"> <strong>2)栈常见操作方法:</strong></h2>\n<blockquote>\n<p>1.stack.empty().判断栈是否为空,为空就返回false,否则返回true.</p>\n<p>2.stack.push().将元素压入栈底.</p>\n<p>3.stack.pop().将栈顶元素弹出栈.</p>\n<p>4.satck.peek().peek有窥视的意思,顾名思义作用就是查看栈顶元素,但不弹出.</p>\n</blockquote>\n<h2 id=\"%C2%A03)%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%3A\"> 3)栈的实现:</h2>\n<blockquote>\n<p>        栈的底层实现既可以用顺序表也可以使用双向链表,二者实现方式大同小异,而我们使用的是<span style=\"color:#fe2c24;\">顺序表</span>.基本配置只需要<span style=\"color:#38d8f0;\">一个数组来存放元素和一个usedSize记录顺序表元素的个数</span>.构造方法初始化时我们可以将栈的大小初始化为5,后续不够再扩容.扩容使用<span style=\"color:#38d8f0;\">Arrays.copyof()</span>方法.</p>\n</blockquote>\n<p></p>\n<pre><code class=\"language-java\">class My_stack{\n    int[] elem;\n    int usedSize;\n\n    public My_stack(int[] elem, int usedSize) {\n        this.elem = new int[5];\n        this.usedSize = usedSize;\n    }\n    public void push(int val){\n        if (usedSize==elem.length){//如果满了就扩容\n            Arrays.copyOf(elem,elem.length*2);\n        }\n        elem[usedSize] = val;\n        usedSize++;\n    }\n    public int pop(){\n        if (isEmpty()){\n            throw new RuntimeException(\"栈为空\");\n        }\n        return elem[usedSize--];\n    }\n    public int peek(){\n        if (isEmpty()){\n            throw new RuntimeException(\"栈为空\");\n        }\n        return elem[usedSize-1];\n    }\n    public boolean isEmpty(){\n        return usedSize==0;\n    }\n}</code></pre>\n<p></p>\n<h1 id=\"%E4%BA%8C.%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">二.栈相关题目</h1>\n<h2 id=\"1)%E9%80%86%E6%B3%A2%E5%85%B0%E6%95%B0\">1)逆波兰数</h2>\n<p><img alt=\"\" height=\"696\" src=\"..\\..\\static\\image\\676b1bc719e440be9ca6d468c8398044.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        <span style=\"color:#fe2c24;\">逆波兰数</span>也叫<span style=\"color:#38d8f0;\">后缀表达式</span>,早年计算机并没有用括号来规定四则运算的计算顺序,那么如果计算9+(3-1)x3+10/2总不能直接输9+3-1x3+10/2吧,于是睿智的科学家通过栈解决了这个难题,<span style=\"color:#38d8f0;\">栈中存放的只能是数字,所以只要遇到数字就压栈,遇到运算符号就从栈顶弹出两个数字,最顶部的在操作符右边,下一个在操作符左边,运算完后将结果压栈,继续重复上述操作.</span></p>\n</blockquote>\n<blockquote>\n<p>        在此题的基础上我们拓展<span style=\"color:#fe2c24;\">中缀表达式转后缀表达式</span>,首先按<span style=\"color:#38d8f0;\">四则运算的优先级给表达式加上相应的括号((9+((3-1)x3))+(10/2))然后将每个括号中对应的操作符移到该括号之外</span>:</p>\n<p>(((9((31)-3)x)+)10 2)/)+去掉括号后得:931-3x+102/+.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"791\" src=\"..\\..\\static\\image\\3622142a7ed34154bdc769470151fef8.png\" width=\"1200\"/></p>\n<pre><code class=\"language-java\">class Solution {\n    public int evalRPN(String[] tokens) {\n        Stack&lt;Integer&gt; str = new Stack&lt;&gt;();\n        for(int i = 0;i&lt;tokens.length;i++){\n            String s = tokens[i];\n            if(!isoperation(s)){\n                str.push(Integer.parseInt(s));//将数字压栈\n            }else{\n                int num2 = str.pop();\n                int num1 = str.pop();\n                switch(s){\n                    case \"+\":\n                        str.push(num1+num2);\n                        break;\n                     case \"-\":\n                        str.push(num1-num2);\n                        break;\n                     case \"*\":\n                        str.push(num1*num2);\n                        break;\n                    case \"/\":\n                        str.push(num1/num2);\n                        break;\n                }\n            }\n        }\n        return str.pop();\n    }\n    public boolean isoperation(String s){\n        if(s.equals(\"+\")||s.equals(\"-\")||s.equals(\"*\")||s.equals(\"/\")){\n            return true;\n        }\n        return false;\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"2)%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%85%A5%E6%A0%88%E6%96%B9%E5%BC%8F\">2)不可能的入栈方式</h2>\n<p><img alt=\"\" height=\"673\" src=\"..\\..\\static\\image\\5758bca9fb204bce835fcf2265e26951.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         根据栈\"先进后出\"的原理我们可以将<span style=\"color:#38d8f0;\">pushed数组,每压入一个元素就与popped数组的栈顶元素相比较</span>,<span style=\"color:#fe2c24;\">如果相同就弹出压入数组的元素</span>,<span style=\"color:#38d8f0;\">然后访问popped数组的下一个元素继续比较.</span><span style=\"color:#fe2c24;\">如果不相同</span>,pushed数组继续压栈,重复上述操作.当<span style=\"color:#fe2c24;\">pushed数组全部压入后</span>,如果此时栈为空,那么符合出栈方式,如果不为空则不符合.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"812\" src=\"..\\..\\static\\image\\70ef32df34e5404a83da8450ba8ebd07.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\n         int j = 0;\n        for(int i = 0;i&lt;pushed.length;i++){\n            stack.push(pushed[i]);\n            while(!stack.empty()&amp;&amp;i&lt;pushed.length&amp;&amp;stack.peek()==popped[j]){\n                stack.pop();\n                j++;\n            }\n        }\n        if(!stack.empty()){\n            return false;\n        }\n        return true;\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"3)%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7\">3)有效括号</h2>\n<p><img alt=\"\" height=\"633\" src=\"..\\..\\static\\image\\4e493e5c6d6943e08b2abf720246fd86.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         通过了解题目大致有四种情况<span style=\"color:#fe2c24;\">,1.左边括号多( ( ( )</span> <span style=\"color:#38d8f0;\">2.右边括号多( ( ) ) ) )</span><span style=\"color:#a2e043;\"> 3.左右括号不匹配{ ) [ }</span> <span style=\"color:#956fe7;\">4.左右括号匹配( ) { }</span> .那么根据栈的特点,我们可以<span style=\"color:#38d8f0;\">遇到左边的括号就压入栈中,遇到右边的括号便和栈顶的元素比较是否匹配,如果不匹配返回false.</span>但要注意两点:1. 如果我们在比较的过程中发现<span style=\"color:#fe2c24;\">栈为空</span>,那么就是<span style=\"color:#fe2c24;\">右边括号多,返回fasle</span>.2.如果我们比较完毕,<span style=\"color:#fe2c24;\">栈不为空</span>,说明<span style=\"color:#fe2c24;\">左边括号多,返回false</span>.如果没有以上情形我们就可以返回true.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"654\" src=\"..\\..\\static\\image\\181055c84d6849aa8b3e9519a91af14b.png\" width=\"958\"/></p>\n<p></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isValid(String s) {\n        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n        for(int i = 0;i&lt;s.length();i++){\n            char ch = s.charAt(i);\n            if(ch=='('||ch=='['||ch=='{'){\n                stack.push(ch);\n            }else{\n                if(stack.empty()){//右边括号多\n                    return false;\n                }\n                char top = stack.peek();\n                if((top=='('&amp;&amp;ch==')')||(top=='['&amp;&amp;ch==']')||(top=='{'&amp;&amp;ch=='}')){\n                    stack.pop();\n                }else{\n                    return false;//左右括号不匹配\n                }\n            }\n        }\n        if(!stack.empty()){//左面括号多\n            return false;\n        }\n    return true;\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"4)%E6%9C%80%E5%B0%8F%E6%A0%88\">4)最小栈</h2>\n<p><img alt=\"\" height=\"913\" src=\"..\\..\\static\\image\\7bdba3eccc7b4ff1a90ac6f6ea35c21d.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        要想实现在常数时间内检索到最小元素的栈,那么<span style=\"color:#fe2c24;\">一定不可能一个栈</span>,因为根据栈的特点<span style=\"color:#38d8f0;\">检索元素的时间复杂度必然是O(N),</span>所以如果我们可以把<span style=\"color:#fe2c24;\">栈的最小元素单独保存起来</span>,那么当我们需要时查找最小元素<span style=\"color:#fe2c24;\">时间复杂度必然是O(1)</span>.按照上述思路,首先我们<span style=\"color:#38d8f0;\">创建两个栈</span>,第一个栈中<span style=\"color:#38d8f0;\">存放元素</span>,第二个栈中<span style=\"color:#38d8f0;\">存放最小值</span>.其次压入元素时,<span style=\"color:#a2e043;\">如果是第一次压入,两个栈都压</span>.否则<span style=\"color:#a2e043;\">判断要压入的元素是否小于第二个栈栈顶的元素</span>,如果<span style=\"color:#38d8f0;\">小于就压入第二个栈,否则就不压入</span>.重复上述操作,无论任何时候我们都能按<span style=\"color:#fe2c24;\">O(1)的时间复杂度取出第二个栈栈顶的元素</span>,也就是最小的元素.</p>\n</blockquote>\n<p><img alt=\"\" height=\"717\" src=\"..\\..\\static\\image\\b9e0d44603b9411f9b65eb7c764daf67.png\" width=\"1173\"/></p>\n<p></p>\n<pre><code class=\"language-java\">class MinStack {\n    public Stack&lt;Integer&gt; stack1;\n    public Stack&lt;Integer&gt; stack2;\n    public MinStack() {\n        stack1 = new Stack&lt;Integer&gt;();\n        stack2 = new Stack&lt;Integer&gt;();\n    }\n\n    public void push(int val) {\n        stack1.push(val);\n        if (stack2.empty()){\n            stack2.push(val);\n        }else {\n            if(val&lt;=stack2.peek()){\n                stack2.push(val);\n            }\n        }\n    }\n\n    public void pop() {\n        int popVal = stack1.pop();\n       if(!stack2.empty()){\n           int top = stack2.peek();\n           if(top==popVal){\n               stack2.pop();\n           }\n       }\n    }\n\n    public int top() {\n        return stack1.peek();\n    }\n\n    public int getMin() {\n        return stack2.peek();\n    }\n}</code></pre>\n<p></p>\n<h1 id=\"%E4%B8%89.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0\">三.队列的实现</h1>\n<blockquote>\n<p>        <span style=\"color:#fe2c24;\">队列是只允许在一端进行插入另一端进行删除的线性表</span>,与栈正好相反.简要概括为:\"<span style=\"color:#fe2c24;\">尾进头出</span>\",同样队列的实现底层既可以用顺序表也可以用链表.首先我们用单链表来实现,为了使<span style=\"color:#38d8f0;\">入队和出队的时间复杂度都为O(1)</span>,我们需要记录单链表的头结点和尾结点,<span style=\"color:#38d8f0;\">入队时尾插,出队时删除头结点即可.</span></p>\n</blockquote>\n<p><img alt=\"\" height=\"419\" src=\"..\\..\\static\\image\\8edb8019c1274cc4ae4e539b44525705.png\" width=\"448\"/></p>\n<p></p>\n<h2 id=\"1)%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97\">1)单链表实现队列</h2>\n<pre><code class=\"language-java\">class Node1{\n    public Node1 next;\n    public int val;\n\n    public Node1(int val) {\n        this.val = val;\n    }\n}\nclass My_queue{\n    public Node1 head;\n    public Node1 last;\n\n    public void offer(int val){//入队\n        Node1 node1 = new Node1(val);\n        if (head==null){\n            head = node1;\n            last = node1;\n        }else {\n            last.next = node1;\n            last = last.next;\n        }\n    }\n    public int poll(){//出队\n        if (isEmpty()){\n            throw new RuntimeException(\"队列为空\");\n        }\n        int pollVal = head.val;\n        head = head.next;\n        return pollVal;\n    }\n    public int peek(){\n        if (isEmpty()){\n            throw new RuntimeException(\"队列为空\");\n        }\n        return head.val;\n    }\n    public boolean isEmpty(){\n        return head==null;\n    }\n\n}</code></pre>\n<p></p>\n<h2 id=\"2)%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\">2)循环队列</h2>\n<blockquote>\n<p>        循环队列的底层为顺序表,为了使<span style=\"color:#38d8f0;\">出队和入队的时间复杂度都是O(1)</span>,我们必须<span style=\"color:#fe2c24;\">记录顺序表元素的首尾</span>,<span style=\"color:#a2e043;\">rear为队尾控制元素入队</span>,<span style=\"color:#a2e043;\">front为队首控制元素出队</span>. 为了使顺序表达到循环的效果,我们需要借助公式<span style=\"color:#fe2c24;\">(rear+1)%elem.length</span>,<span style=\"color:#956fe7;\">front</span>也同样借助这个公式.基于顺序表的特点,删除元素时只需后移front,增加元素只需在rear下标增加元素,之后后移rear即可.</p>\n</blockquote>\n<p><img alt=\"\" height=\"761\" src=\"..\\..\\static\\image\\67a12a715137432183929498e7b0b592.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-java\">class MyCircularQueue {\n public int elem[];\n    public int front;\n    public int rear;\n\n    public MyCircularQueue(int k) {\n        this.elem = new int[k+1];\n    }\n\n    public boolean enQueue(int value) {//入队\n        if (isFull()){\n            return false;\n        }\n        this.elem[rear] = value;\n        rear = (rear +1)%elem.length;\n        return true;\n    }\n\n    public boolean deQueue() {//出队\n        if (isEmpty()){\n            return false;\n        }\n        front = (front +1)%elem.length;\n        return true;\n    }\n\n    public int Front() {//获取队头元素\n        if (isEmpty()){\n            return -1;\n        }\n        return elem[front];\n    }\n\n    public int Rear() {//获取队位元素\n        if (isEmpty()){\n            return -1;\n        }\n       if (rear==0){\n           return elem[elem.length-1];\n       }else {\n           return elem[rear-1];\n       }\n    }\n\n    public boolean isEmpty() {\n        return front==rear;\n    }\n\n    public boolean isFull() {\n        //rear的下一个如果为front\n        if ((rear+1)%elem.length==front){\n            return true;\n        }\n        return false;\n    }\n}</code></pre>\n<p></p>\n<h1 id=\"%E5%9B%9B.%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">四.队列相关题目</h1>\n<h2 id=\"1)%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0\">1)用栈实现队列 </h2>\n<p><img alt=\"\" height=\"775\" src=\"..\\..\\static\\image\\932570751c384aea959cb061586fcd41.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        一个栈必定无法实现队列,那么我们可以考虑<span style=\"color:#fe2c24;\">用两个栈</span>,<span style=\"color:#38d8f0;\">入队时把要入队元素压入stack1中</span>,<span style=\"color:#a2e043;\">出队时先把所有stack1中元素压入stack2中,然后弹出stack2的栈顶元素即可</span>. </p>\n</blockquote>\n<pre><code class=\"language-java\">class MyQueue {\n public Stack&lt;Integer&gt; stack1;\n    public Stack&lt;Integer&gt; stack2;\n\n    public MyQueue() {\n        stack1 = new Stack&lt;&gt;();\n        stack2 = new Stack&lt;&gt;();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if(empty()){\n            return -1;\n        }\n        if(stack2.empty()) {\n            int size = stack1.size();\n            for (int i = 0; i &lt; size; i++) {\n                stack2.push(stack1.pop());\n            }\n        }\n         return stack2.pop();\n    }\n    public int peek() {\n        if(empty()){\n            return -1;\n        }\n        if(stack2.empty()) {\n            int size = stack1.size();\n            for (int i = 0; i &lt; size; i++) {\n                stack2.push(stack1.pop());\n            }\n        }\n         return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.empty()&amp;&amp;stack2.empty();\n    }\n}\n</code></pre>\n<p></p>\n<p></p>\n<h2 id=\"2)%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88\">2)用队列实现栈</h2>\n<p><img alt=\"\" height=\"859\" src=\"..\\..\\static\\image\\58f3ebfcc3704125add454139f11ea0f.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        同样一个队列也无法实现栈,可以考虑使用<span style=\"color:#fe2c24;\">两个队列</span>,<span style=\"color:#38d8f0;\">入队时哪个队列为空入哪个 ,如果都为空就入que1</span>.但是与栈不同的是队列的出队顺序,我们不能把que1中的元素全部放入que2再出que2中的元素,而是移size-1个到que2,出que1.<span style=\"color:#956fe7;\">假设入队都在que1中,那么出队时只需将que1中的size-1个元素移到que2中,然后弹出que1中的元素即可</span>.</p>\n</blockquote>\n<pre><code class=\"language-java\">class MyStack {\n\n     public Queue&lt;Integer&gt; que1;\n    public Queue&lt;Integer&gt; que2;\n\n    public MyStack() {\n        que1 = new LinkedList&lt;&gt;();\n        que2 = new LinkedList&lt;&gt;();\n    }\n    public void push(int x) {\n        if (!que1.isEmpty()){\n            que1.offer(x);\n        }else if (!que2.isEmpty()){\n            que2.offer(x);\n        }else {\n            que1.offer(x);\n        }\n    }\n\n    public int pop() {\n        if (empty()){\n            return -1;\n        }\n        if (!que1.isEmpty()){\n            int size = que1.size();\n            for (int i = 0; i &lt;size-1 ; i++) {\n                que2.offer(que1.poll());\n            }\n            return que1.poll();\n        }\n        if (!que2.isEmpty()){\n            int size = que2.size();\n            for (int i = 0; i &lt;size-1 ; i++) {\n                que1.offer(que2.poll());\n            }\n            return que2.poll();\n        }\n        return -1;\n    }\n\n    public int top() {\n        if (empty()){\n            return -1;\n        }\n        if (!que1.isEmpty()){\n            int size = que1.size();\n            int val = -1;\n            for (int i = 0; i &lt;size ; i++) {\n                val = que1.poll();\n                que2.offer(val);\n            }\n            return val;\n        }\n        if (!que2.isEmpty()){\n            int size = que2.size();\n            int val = -1;\n            for (int i = 0; i &lt;size ; i++) {\n                val = que2.poll();\n                que1.offer(val);\n            }\n            return val;\n        }\n        return -1;\n    }\n\n    public boolean empty() {\n        return que1.isEmpty()&amp;&amp;que2.isEmpty();\n    }\n}\n</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\884c4bc8cefe49808a5a58525be8f62e.jpeg\"/></p>\n<p></p>\n<hr/>\n<h1 id=\"%E6%80%BB%E7%BB%93\"><a id=\"_45\"></a>总结</h1>\n<blockquote>\n<p>        以上就是<span style=\"color:#fe2c24;\">快速入门栈和队列</span>的全部内容了,在了解栈和队列的各种实现并手撕相关习题,相信我们已经熟练掌握了栈和队列,<span style=\"color:#38d8f0;\">如果我的文章对你有亿点点帮助和启发,麻烦不要忘记三连哦!</span></p>\n</blockquote>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-26 15:15:58", "summary": "专栏简介语法及数据结构题目来源牛客剑指创作目标从语法角度实现底层相关数据结构达到手撕各类题目的水平希望在提升自己的同时帮助他人与大家一起共同进步互相成长学历代表过去能力代表现在学习能力代表未来目录前言"}