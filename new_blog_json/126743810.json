{"blogid": "126743810", "writerAge": "码龄15年", "writerBlogNum": "100", "writerCollect": "251", "writerComment": "61", "writerFan": "2132", "writerGrade": "5级", "writerIntegral": "1659", "writerName": "roykingw", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743810.jpg", "writerRankTotal": "11821", "writerRankWeekly": "3441", "writerThumb": "47", "writerVisitNum": "98074", "blog_read_count": "15", "blog_time": "于 2022-09-07 13:29:02 发布", "blog_title": "Kafka3.x核心速查手册二、客户端使用篇-3、消息序列化机制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>​ 在之前的简单示例中，Producer指定了两个属性KEY_SERIALIZER_CLASS_CONFIG和VALUE_SERIALIZER_CLASS_CONFIG，对于这两个属性，在ProducerConfig中都有配套的说明属性。</p>\n<pre><code class=\"prism language-java\">\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> KEY_SERIALIZER_CLASS_CONFIG <span class=\"token operator\">=</span> <span class=\"token string\">\"key.serializer\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> KEY_SERIALIZER_CLASS_DOC <span class=\"token operator\">=</span> <span class=\"token string\">\"Serializer class for key that implements the &lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt; interface.\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> VALUE_SERIALIZER_CLASS_CONFIG <span class=\"token operator\">=</span> <span class=\"token string\">\"value.serializer\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> VALUE_SERIALIZER_CLASS_DOC <span class=\"token operator\">=</span> <span class=\"token string\">\"Serializer class for value that implements the &lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt; interface.\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>​ 这些这些属性，在下面都会加载默认配置。</p>\n<p>​ 从描述中可以看到，这两个属性是对消息的key和value进行格式化的配置。</p>\n<p><strong>对于生产者，key和value的作用分别如下</strong>：</p>\n<ul><li>key是用来进行分区的可选项。Kafka通过key来判断消息要分发到哪个Partition。</li></ul>\n<p>​ 如果没有填写key，那么Kafka会使Round-robin轮询的方式，自动选择Partition。</p>\n<p>​ 如果填写了key，那么会通过声明的Serializer序列化接口，将key转换成一个byte[]数组，然后对key进行hash，选择Partition。这样可以保证key相同的消息会分配到相同的Partition中。</p>\n<ul><li>Value是业务上比较关心的消息。Kafka同样需要将Value对象通过Serializer序列化接口，将Key转换成byte[]数组，这样才能比较好的在网络上传输Value信息，以及将Value信息落盘到操作系统的文件当中。</li></ul>\n<p>生产者要对消息进行序列化，那么消费者拉取消息时，自然需要进行反序列化。所以，在Consumer中，也有反序列化的两个配置</p>\n<pre><code class=\"prism language-java\"> \t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> KEY_DESERIALIZER_CLASS_CONFIG <span class=\"token operator\">=</span> <span class=\"token string\">\"key.deserializer\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> KEY_DESERIALIZER_CLASS_DOC <span class=\"token operator\">=</span> <span class=\"token string\">\"Deserializer class for key that implements the &lt;code&gt;org.apache.kafka.common.serialization.Deserializer&lt;/code&gt; interface.\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> VALUE_DESERIALIZER_CLASS_CONFIG <span class=\"token operator\">=</span> <span class=\"token string\">\"value.deserializer\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> VALUE_DESERIALIZER_CLASS_DOC <span class=\"token operator\">=</span> <span class=\"token string\">\"Deserializer class for value that implements the &lt;code&gt;org.apache.kafka.common.serialization.Deserializer&lt;/code&gt; interface.\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>​ 在Kafka中，对于常用的一些基础数据类型，都已经提供了对应的实现类。但是，如果需要使用一些自定义的消息格式，比如自己定制的POJO，就需要定制具体的实现类了。</p>\n<p>​ 在自己进行序列化机制时，需要考虑的是如何用二进制来描述业务数据。例如对于一个通常的POJO类型，可以将他的属性拆分成两种类型：<strong>一种类型是定长的基础类型</strong>，比如Integer,Long,Double等。这些基础类型转化成二进制数组都是定长的。这类属性可以直接转成序列化数组，在反序列化时，只要按照定长去读取二进制数据就可以反序列化了。<strong>另一种是不定长的浮动类型</strong>，比如String，或者基于String的JSON类型等。这种浮动类型的基础数据转化成二进制数组，长度都是不一定的。对于这类数据，通常的处理方式都是先往二进制数组中写入一个定长的数据的长度数据(Integer或者Long类型)，然后再继续写入数据本身。这样，反序列化时，就可以先读取一个定长的长度，再按照这个长度去读取对应长度的二进制数据，这样就能读取到数据的完整二进制内容。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5734bbc97f8a4e3981a8a20ad2308bb5.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 13:29:02", "summary": "在之前的简单示例中，指定了两个属性和，对于这两个属性，在中都有配套的说明属性。这些这些属性，在下面都会加载默认配置。从描述中可以看到，这两个属性是对消息的和进行格式化的配置。对于生产者，和的作用分别如"}