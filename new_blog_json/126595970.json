{"blogid": "126595970", "writerAge": "码龄1年", "writerBlogNum": "114", "writerCollect": "1169", "writerComment": "486", "writerFan": "5307", "writerGrade": "5级", "writerIntegral": "2052", "writerName": "十八岁讨厌Java", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126595970.jpg", "writerRankTotal": "8674", "writerRankWeekly": "210", "writerThumb": "452", "writerVisitNum": "38128", "blog_read_count": "458", "blog_time": "于 2022-09-01 09:16:56 发布", "blog_title": "RabbitMQ消息丢失的场景，如何保证消息不丢失？（详细讲解，一文看懂）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5\">一.RabbitMQ消息丢失的三种情况</a></p>\n<p id=\"%E4%BA%8C.RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">二.RabbitMQ消息丢失解决方案</a></p>\n<p id=\"1.%E9%92%88%E5%AF%B9%E7%94%9F%E4%BA%A7%E8%80%85-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E9%92%88%E5%AF%B9%E7%94%9F%E4%BA%A7%E8%80%85\">1.针对生产者</a></p>\n<p id=\"%E6%96%B9%E6%A1%881%20%EF%BC%9A%E5%BC%80%E5%90%AFRabbitMQ%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%A1%881%20%EF%BC%9A%E5%BC%80%E5%90%AFRabbitMQ%E4%BA%8B%E5%8A%A1\">方案1 ：开启RabbitMQ事务</a></p>\n<p id=\"%E6%96%B9%E6%A1%882%EF%BC%9A%20%E4%BD%BF%E7%94%A8confirm%E6%9C%BA%E5%88%B6%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%A1%882%EF%BC%9A%20%E4%BD%BF%E7%94%A8confirm%E6%9C%BA%E5%88%B6%C2%A0\">方案2： 使用confirm机制 </a></p>\n<p id=\"2.%E9%92%88%E5%AF%B9RabbitMQ-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E9%92%88%E5%AF%B9RabbitMQ\">2.针对RabbitMQ</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96\">（1）消息持久化</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F\">（2）设置集群镜像模式</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6\">（3）消息补偿机制</a></p>\n<p id=\"3.%E9%92%88%E5%AF%B9%E6%B6%88%E8%B4%B9%E8%80%85-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E9%92%88%E5%AF%B9%E6%B6%88%E8%B4%B9%E8%80%85\">3.针对消费者</a></p>\n<p id=\"%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AACK%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AACK%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6\">方案一：ACK确认机制</a></p>\n<p id=\"%E4%B8%89.%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E6%80%BB%E7%BB%93\">三.总结</a></p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80.RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5\">一.RabbitMQ消息丢失的三种情况</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/3dcb145be10ac2fb27c62d29a49736ef.webp?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>第一种：生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p>\n<p>第二种：RabbitMQ 弄丢了数据。MQ还没有持久化自己挂了<br/> 第三种：消费端弄丢了数据。刚消费到，还没处理，结果进程挂了，比如重启了。</p>\n<p></p>\n<h1 id=\"%E4%BA%8C.RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">二.RabbitMQ消息丢失解决方案</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/6c5d52f42ffcce328e6cd6d338599249.webp?x-oss-process=image/format,png\"/></p>\n<h2 id=\"1.%E9%92%88%E5%AF%B9%E7%94%9F%E4%BA%A7%E8%80%85\">1.针对生产者</h2>\n<h3 id=\"%E6%96%B9%E6%A1%881%20%EF%BC%9A%E5%BC%80%E5%90%AFRabbitMQ%E4%BA%8B%E5%8A%A1\">方案1 ：开启RabbitMQ事务</h3>\n<p>可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</p>\n<blockquote>\n<p>// 开启事务<br/> channel.txSelect<br/> try {<!-- --><br/>       // 这里发送消息<br/> } catch (Exception e) {<!-- --><br/>       channel.txRollback</p>\n<p>// 这里再次重发这条消息</p>\n<p>}</p>\n<p>// 提交事务<br/> channel.txCommit</p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\">缺点：</span><br/> RabbitMQ 事务机制是同步的，你提交一个事务之后会阻塞在那儿，采用这种方式基本上吞吐量会下来，因为太耗性能。</p>\n<h3 id=\"%E6%96%B9%E6%A1%882%EF%BC%9A%20%E4%BD%BF%E7%94%A8confirm%E6%9C%BA%E5%88%B6%C2%A0\">方案2： 使用confirm机制 </h3>\n<p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的</p>\n<p>在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。</p>\n<blockquote>\n<p>    //开启confirm<br/>     channel.confirm();<br/>     //发送成功回调<br/>     public void ack(String messageId){<!-- --><br/>       <br/>     }</p>\n<p>    // 发送失败回调<br/>     public void nack(String messageId){<!-- --><br/>         //重发该消息<br/>     }</p>\n</blockquote>\n<p></p>\n<h2 id=\"2.%E9%92%88%E5%AF%B9RabbitMQ\">2.针对RabbitMQ</h2>\n<p><strong>说三点：</strong></p>\n<p>（1）要保证rabbitMQ不丢失消息，那么就需要开启rabbitMQ的持久化机制，即把消息持久化到硬盘上，这样即使rabbitMQ挂掉在重启后仍然可以从硬盘读取消息；</p>\n<p>（2）如果rabbitMQ单点故障怎么办，这种情况倒不会造成消息丢失，这里就要提到rabbitMQ的3种安装模式，单机模式、普通集群模式、镜像集群模式，这里要保证rabbitMQ的高可用就要配合HAPROXY做镜像集群模式</p>\n<p>（3）如果硬盘坏掉怎么保证消息不丢失</p>\n<h3 id=\"%EF%BC%881%EF%BC%89%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96\">（1）消息持久化</h3>\n<p>RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。</p>\n<p>所以就要对消息进行持久化处理。如何持久化，下面具体说明下：</p>\n<p>要想做到消息持久化，必须满足以下三个条件，缺一不可。</p>\n<p>1） Exchange 设置持久化</p>\n<p>2）Queue 设置持久化</p>\n<p>3）Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F\">（2）设置集群镜像模式</h3>\n<p>我们先来介绍下RabbitMQ三种部署模式：</p>\n<p>1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br/> 2）普通模式：消息只会存在与当前节点中，并不会同步到其他节点，当前节点宕机，有影响的业务会瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br/> 3）镜像模式：消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。属于RabbitMQ的HA方案</p>\n<p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。下面自己画了一张图介绍普通集群丢失消息情况：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/fa717df47ef30ac841fb380fa42106c9.webp?x-oss-process=image/format,png\"/></p>\n<p>如果想解决上面途中问题，保证消息不丢失，需要采用HA 镜像模式队列。</p>\n<p>下面介绍下三种HA策略模式：</p>\n<p>1）同步至所有的<br/> 2）同步最多N个机器<br/> 3）只同步至符合指定名称的nodes</p>\n<p>命令处理HA策略模版：rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</p>\n<p>1）为每个以“rock.wechat”开头的队列设置所有节点的镜像，并且设置为自动同步模式<br/> rabbitmqctl set_policy ha-all \"^rock.wechat\" '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}'<br/> rabbitmqctl set_policy -p rock ha-all \"^rock.wechat\" '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}'</p>\n<p>2）为每个以“rock.wechat.”开头的队列设置两个节点的镜像，并且设置为自动同步模式<br/> rabbitmqctl set_policy -p rock ha-exacly \"^rock.wechat\" \\<br/> '{\"ha-mode\":\"exactly\",\"ha-params\":2,\"ha-sync-mode\":\"automatic\"}'</p>\n<p>3）为每个以“node.”开头的队列分配指定的节点做镜像<br/> rabbitmqctl set_policy ha-nodes \"^nodes\\.\" \\<br/> '{\"ha-mode\":\"nodes\",\"ha-params\":[\"rabbit@nodeA\", \"rabbit@nodeB\"]}'</p>\n<p>但是：HA 镜像队列有一个很大的缺点就是：   系统的吞吐量会有所下降</p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6\">（3）消息补偿机制</h3>\n<p>为什么还要消息补偿机制呢？难道消息还会丢失，没错，系统是在一个复杂的环境，不要想的太简单了，虽然以上的三种方案，基本可以保证消息的高可用不丢失的问题，</p>\n<p>但是作为有追求的程序员来讲，要绝对保证我的系统的稳定性，有一种危机意识。</p>\n<p>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</p>\n<p>1）生产端首先将业务数据以及消息数据入库，需要在同一个事务中，消息数据入库失败，则整体回滚。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"322\" src=\"..\\..\\static\\image\\170e82dcf4e14765a1fc4513e5d1c495.png\" width=\"273\"/></p>\n<p></p>\n<p>2）根据消息表中消息状态，失败则进行消息补偿措施，重新发送消息处理。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/cc3b4708cea9583f36141ee1f6b95307.webp?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"3.%E9%92%88%E5%AF%B9%E6%B6%88%E8%B4%B9%E8%80%85\">3.针对消费者</h2>\n<h3 id=\"%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AACK%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6\">方案一：ACK确认机制</h3>\n<p>多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？</p>\n<p>使用rabbitmq提供的ack机制，服务端首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。才把消息从内存删除。</p>\n<p>这样就解决了，即使一个消费者出了问题，但不会同步消息给服务端，会有其他的消费端去消费，保证了消息不丢的case。 </p>\n<p></p>\n<h1 id=\"%E4%B8%89.%E6%80%BB%E7%BB%93\">三.总结</h1>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\20210920012129540.png\"/></p>\n<p>如果需要保证消息在整条链路中不丢失，那就需要生产端、mq自身与消费端共同去保障。</p>\n<p>生产端：对生产的消息进行状态标记，开启confirm机制，依据mq的响应来更新消息状态，使用定时任务重新投递超时的消息，多次投递失败进行报警。</p>\n<p>mq自身：开启持久化，并在落盘后再进行ack。如果是镜像部署模式，需要在同步到多个副本之后再进行ack。</p>\n<p>消费端：开启手动ack模式，在业务处理完成后再进行ack，并且需要保证幂等。</p>\n<p>通过以上的处理，理论上不存在消息丢失的情况，但是系统的吞吐量以及性能有所下降。</p>\n<p>在实际开发中，需要考虑消息丢失的影响程度，来做出对可靠性以及性能之间的权衡。</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-01 09:16:56", "summary": "目录一消息丢失的三种情况二消息丢失解决方案针对生产者方案：开启事务方案：使用机制针对消息持久化设置集群镜像模式消息补偿机制针对消费者方案一：确认机制三总结一消息丢失的三种情况第一种：生产者弄丢了数据。"}