{"blogid": "125041202", "writerAge": "码龄3年", "writerBlogNum": "15", "writerCollect": "16", "writerComment": "9", "writerFan": "7", "writerGrade": "2级", "writerIntegral": "189", "writerName": "秕谷.", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125041202.jpg", "writerRankTotal": "66083", "writerRankWeekly": "247485", "writerThumb": "16", "writerVisitNum": "26872", "blog_read_count": "2319", "blog_time": "已于 2022-05-30 15:39:32 修改", "blog_title": "浅谈stringBuilder.ToString()方法底层原理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>ToString方法浅谈</h3>\n<ul><li><a href=\"#_1\">一、什么是单向链表？</a></li><li><a href=\"#ToStringCJava_14\">二、ToString（）底层区别（C#/Java）</a></li><li><ul><li><a href=\"#C_15\">C#</a></li><li><a href=\"#Java_28\">Java</a></li><li><a href=\"#_34\">两者区别</a></li></ul>\n</li><li><a href=\"#ToString_43\">二、ToString底层代码解析</a></li><li><ul><li><a href=\"#C_44\">C#底层代码</a></li><li><a href=\"#Java_126\">Java底层代码</a></li></ul>\n</li><li><a href=\"#_179\">小结</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>一、什么是单向链表？</h1>\n<p>首先我们要知道，三个StringBuilder的关系是单向链表，那么什么是单向链表呢？</p>\n<p>链表是一种特殊的<code>数据结构</code>，能够<code>动态</code>的存储一种结构类型数据。<br/> 该结构由节点组成。每个节点包含两个部分数据：</p>\n<ul><li>第一部分（尾节点）：节点本身的数据</li><li>第二部分（头节点）：指向下一个节点的<code>指针</code>（整个stringBuilder对象的地址</li></ul>\n<p><code>单向链表</code>就是C# 的 StringBuilder<code>扩容机制</code>。它的容量和上一个stringBuilder长度有关，每次扩容不固定：<code>max(当前追加字符的剩余长度,min(当前StringBuilder长度,8000))</code></p>\n<hr/>\n<h1><a id=\"ToStringCJava_14\"></a>二、ToString（）底层区别（C#/Java）</h1>\n<h2><a id=\"C_15\"></a>C#</h2>\n<p>下面我画了一下单向链表的调用关系，如图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7490598e5f234600af6860178167f86e.png\"/><br/> 从图中可以看出来，引用关系总结了以下几步：</p>\n<ol><li>声明的builder绑定的是而stringBuilderC的堆地址0x0003，节点头存放着地址，就叫做单向链表。</li><li>而<code>stringBuilderC</code>头节点存放了<code>stringBuilderB</code>堆地址0x0002，</li><li>stringBuilderB<code>存放</code>的是stringBuilderA的<code>堆地址</code>0x0001。</li><li>到这里就发现stringBuilderA的头节点就没有存放下一个节点的指针，这也就说明了char[ ]到头了，A就是一堆扩容数组中的领头。<br/> 在ToString()时，也会根据这个顺序，<code>倒序遍历</code>出各自的元素，组成在一起。</li></ol>\n<p>以上是 C# 中stringBuilder扩容机制（单向链表），在ToString()时，会根据这个单向链表顺序，<code>开辟</code>新空间<code>倒序遍历</code>出各自的元素，组成在一起。</p>\n<h2><a id=\"Java_28\"></a>Java</h2>\n<p>扩容机制如图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\afa60c1508b1468e830941731ebfde44.png\"/></p>\n<p>Java的stringBuilder扩容机（char[ ]数组），从图中就可以看出来和C#的区别。但是，Java在ToString()时<code>开辟新空间</code>（也就是String对象），人家本身就存储在<code>char[ ]</code>数组中。转换的时候将之前的数组<code>内容复制</code>过去，不需要倒序遍历。所以最后ToString（）输出 Java的StringBuilder优势是非常明显的。</p>\n<h2><a id=\"_34\"></a>两者区别</h2>\n<p>针对于更多的区别，可以通过一下链接点进去看看，比较全面一些：</p>\n<p>链接: <a href=\"https://blog.csdn.net/weixin_46484674/article/details/124951029\">String、StringBuilder实现原理、toString方法（ JAVA / C# ）</a></p>\n<hr/>\n<br/>\n<h1><a id=\"ToString_43\"></a>二、ToString底层代码解析</h1>\n<h2><a id=\"C_44\"></a>C#底层代码</h2>\n<p><strong>假设</strong><br/> 设定条件：<code>初始值char[16]</code><br/> 现有三个stringBuilder：char[16]stringBuilderA、char[ ]stringBuilderB、char[ ]stringBuilderC</p>\n<p>首次 .Append（“<code>16</code>个字符”）；（也就是stringBuilderA）<br/> 二次 .Append(“<code>16</code>个字符”)；（扩容出来的stringBuilderB，元素存放在里面）<br/> 三次 .Append（“<code>2</code>个字符”）；（扩容出来的stringBuilderC，Append的2个元素存放在里面）</p>\n<p>以这种情况为<code>前提</code>，咱走近底层实现代码研究研究（vs2022版可以看见更多的底层实现代码，它给我们开放了一些）：</p>\n<pre><code class=\"prism language-cs\"><span class=\"token operator\">&gt;</span> 核心步骤一，长度相关：\n <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> Length\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">__DynamicallyInvokable</span></span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">get</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token comment\">/******** 新建stringBuilder时，会有两个参数（offset+数组长度）*********/</span>\n      <span class=\"token keyword\">return</span> m_ChunkOffset <span class=\"token operator\">+</span> m_ChunkLength<span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token operator\">&gt;</span> 核心步骤一，<span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>倒序遍历：\n<span class=\"token comment\">// 已标注：不安全的方法（C#默认不让使用指针，想要用指针，需要标注一下，谨防安全隐患）</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">override</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>\n<span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">{<!-- --></span>\n   \t<span class=\"token keyword\">return</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n   \n   <span class=\"token comment\">// 新开辟一个新的数组空间，长度是64的：FastAllocateString（16+16+32=64）</span>\n   <span class=\"token class-name\"><span class=\"token keyword\">string</span></span> text <span class=\"token operator\">=</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">.</span><span class=\"token function\">FastAllocateString</span><span class=\"token punctuation\">(</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token class-name\">StringBuilder</span> stringBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\">// fixed 使用指针的关键字</span>\n   <span class=\"token keyword\">fixed</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> ptr <span class=\"token operator\">=</span> text<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 新开辟空间的数组，堆地址赋给指针变量ptr</span>\n   <span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token comment\">// 整个 do-while 倒序遍历单向链表 </span>\n   <span class=\"token comment\">// 顺序：stringBuilderC → stringBuilderB → stringBuilderC</span>\n   <span class=\"token comment\">//顺序是和挂钩的，变量builder引用地址是stringBuilderC的0x0003。以此类推</span>\n     <span class=\"token keyword\">do</span>\n     <span class=\"token punctuation\">{<!-- --></span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span>m_ChunkLength <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">{<!-- --></span>\n         <span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> chunkChars <span class=\"token operator\">=</span> stringBuilder<span class=\"token punctuation\">.</span>m_ChunkChars<span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> chunkOffset <span class=\"token operator\">=</span> stringBuilder<span class=\"token punctuation\">.</span>m_ChunkOffset<span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> chunkLength <span class=\"token operator\">=</span> stringBuilder<span class=\"token punctuation\">.</span>m_ChunkLength<span class=\"token punctuation\">;</span>\n\t\t \n\t\t <span class=\"token comment\">// 长度超出了int最大值或者大于新开辟空间的长度</span>\n\t\t <span class=\"token comment\">//例如数组长度刚刚好是int最大值，这个后Append两个字符</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">uint</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>chunkLength <span class=\"token operator\">+</span> chunkOffset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&gt;</span> text<span class=\"token punctuation\">.</span>Length \n\t\t \t\t     <span class=\"token operator\">||</span>\n\t\t          <span class=\"token punctuation\">(</span><span class=\"token keyword\">uint</span><span class=\"token punctuation\">)</span>chunkLength <span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">uint</span><span class=\"token punctuation\">)</span>chunkChars<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">ArgumentOutOfRangeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"chunkLength\"</span><span class=\"token punctuation\">,</span> Environment<span class=\"token punctuation\">.</span><span class=\"token function\">GetResourceString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ArgumentOutOfRange_Index\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n\n         <span class=\"token comment\">// 当前stringBuilder它的char[]的指针，堆地址赋给指针变量smem</span>\n         <span class=\"token comment\">//例如首次循环的第三个char[] stringBuilderC</span>\n         <span class=\"token keyword\">fixed</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> smem <span class=\"token operator\">=</span> chunkChars<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{<!-- --></span>\n          <span class=\"token comment\">// CLR公共语言运行时 原生提供（copy），将当前char[]元素克隆到新开辟的空间去</span>\n\t\t  <span class=\"token comment\">// ptr + chunkOffset:ptr指的是开头，第三个char[]是放在后面位置的，所以要添加偏移量offset</span>\n\t\t  <span class=\"token comment\">// smem:当前char[]数组指针（引用地址）</span>\n\t\t <span class=\"token comment\">// chunkLength： 当前char[]数组被使用的长度（被占用）</span>\n            <span class=\"token keyword\">string</span><span class=\"token punctuation\">.</span><span class=\"token function\">wstrcpy</span><span class=\"token punctuation\">(</span>ptr <span class=\"token operator\">+</span> chunkOffset<span class=\"token punctuation\">,</span> smem<span class=\"token punctuation\">,</span> chunkLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\t    <span class=\"token comment\">// stringBuilder = 上一个stringBuilder（也就是第二个stringBuilder）</span>\n        stringBuilder <span class=\"token operator\">=</span> stringBuilder<span class=\"token punctuation\">.</span>m_ChunkPrevious<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>stringBuilder <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 最后都添加到最初新开辟的空间数组里去：test</span>\n  <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>画了一个上面的实现图，希望有所帮助：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c2c29746ddb94a8aa72114c50433a3db.png\"/></p>\n<h2><a id=\"Java_126\"></a>Java底层代码</h2>\n<p>下面是我用的jkd1.8，java中自带的我们可以看到的底层代码。对它进行拆分分析。</p>\n<pre><code class=\"prism language-cs\">\n<span class=\"token operator\">&gt;</span> 步骤一，方法：\n<span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">&gt;</span> 步骤二，条件筛选：\n<span class=\"token keyword\">public</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> offset<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> count<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">//以下代码判断偏移量或者count（你要复制的元素数量）组合，会不会超出数组的索引</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">StringIndexOutOfBoundsException</span><span class=\"token punctuation\">(</span>offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">StringIndexOutOfBoundsException</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">&lt;=</span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">value</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>  <span class=\"token punctuation\">}</span> \n     <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">&gt;</span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">StringIndexOutOfBoundsException</span><span class=\"token punctuation\">(</span>offset <span class=\"token operator\">+</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//如果没有查出索引边界，则进入核心代码：copy相关</span>\n\t<span class=\"token comment\">//offset（偏移量）：从那里开始</span>\n\t<span class=\"token comment\">//count（数量）：你要复制多少个 </span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">value</span> <span class=\"token operator\">=</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOfRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> offset<span class=\"token operator\">+</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token operator\">&gt;</span> 步骤三，核心代码：\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> <span class=\"token function\">copyOfRange</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> original<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> from<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> to<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//新长度=offset+count-offset   也就是count（我也不知道为什么要这么写，为啥子这么绕0.0）</span>\n    <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> newLength <span class=\"token operator\">=</span> to <span class=\"token operator\">-</span> from<span class=\"token punctuation\">;</span>\n    \n \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newLength <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span>from <span class=\"token operator\">+</span> <span class=\"token string\">\" &gt; \"</span> <span class=\"token operator\">+</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token comment\">//new了一个新数组，把刚才的count赋值给这个新数组</span>\n \t<span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> copy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\"><span class=\"token keyword\">char</span></span><span class=\"token punctuation\">[</span>newLength<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n \t\n \t<span class=\"token comment\">//arraycopy(原来的数组, 偏移量, 新数组, 0, 两个选最小(原来数组长度-偏移量, 新数组长度))</span>\n  \tSystem<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>original<span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>original<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> from<span class=\"token punctuation\">,</span> newLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \t\n  \t<span class=\"token comment\">//返回新数组</span>\n\t<span class=\"token keyword\">return</span> copy<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>从代码中可以看出来，java在ToString() 时，也是会开辟一个新空间（也就是创建新数组），但是java的不需要进行倒序遍历。<br/> 因为本身就是存储在char[ ]内的，所以最后ToString()是直接将原来的数组copy给新创建的数组中，然后进行返回的。</p>\n<h1><a id=\"_179\"></a>小结</h1>\n<p><code>C#</code> 的StringBuilder是<code>单向链表</code>，扩容的时候挺好，充分利用空间，保证了<code>存储空间</code>的<code>最大利用</code>。但是最后ToString（）需要循环<code>倒序遍历</code>，最终把结果组装成一个字符串返回。<br/> <br/><br/> <code>JAVA</code> 的StringBuilder 是 <code>char[ ]</code> 类型的，扩容的时候，会生成一个新的数组并且<code>克隆</code>旧数组中的元素到自己里面。之前的旧数组没人引用就会等待垃圾回收。</p>\n<p>所以，类似数组扩容再copy的逻辑没有链表的方式高效。</p>\n<p>最后输出结果的时候因为本身存储在char[ ]中，所以随后输出 Java的StringBuilder优势是非常明显的。</p>\n<br/>\n<br/>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-05-30 15:39:32", "summary": "方法浅谈一、什么是单向链表？二、底层区别两者区别二、底层代码解析底层代码底层代码小结一、什么是单向链表？首先我们要知道，三个的关系是单向链表，那么什么是单向链表呢？链表是一种特殊的数据结构，能够动态的"}