{"blogid": "126556693", "writerAge": "码龄2年", "writerBlogNum": "113", "writerCollect": "82", "writerComment": "8", "writerFan": "904", "writerGrade": "4级", "writerIntegral": "1200", "writerName": "uManBoy", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126556693.jpg", "writerRankTotal": "16471", "writerRankWeekly": "2574", "writerThumb": "18", "writerVisitNum": "36346", "blog_read_count": "1049", "blog_time": "于 2022-08-27 12:35:12 发布", "blog_title": "在c++项目中你必须真正使用的15个c++特性", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>本文转载自：https://cppdepend.com/blog/?p=319</p>\n</blockquote>\n<p>During the last few years, we talk about the “C++ Renaissance”. We have to admit that Microsoft was a major part of this movement, I remember this <a href=\"http://channel9.msdn.com/Shows/Going+Deep/Craig-Symonds-and-Mohsen-Agsen-C-Renaissance\">video</a> where Craig Symonds and Mohsen Agsen talked about it.</p>\n<p>In 2011 Microsoft announced in many articles the comeback of C++, and Microsoft C++ experts like Herb Sutter did many conferences to explain why C++ was back and mostly recommended the use of Modern C++. At the same time, the standard C++11 was approved and we began to talk about C++ as a new language.</p>\n<p>By 2011, C++ had been in use for more than 30 years. It was not easy to convince developers that the new C++ actually simplified many frustrating facets of C++ usage and that there was a new modern way to improve the C++ Code.</p>\n<p>For the C++ developers who do not yet switch to C++11, they can use clang-tidy to get suggestions on where they can modernize the codebase or try the <a href=\"https://www.cppdepend.com/Modernize\">CppDepend modernization feature</a>. And here are the 15 features mostly used in the C++ open source libraries.</p>\n<p>Let’s take as example <a href=\"https://github.com/facebook/folly\">Folly</a> released six years ago by Facebook, Folly is a large collection of reusable C++ library components that internally at Facebook are used extensively. And here’s the motivations from their website behind its utility:</p>\n<blockquote>\n<p>Folly (acronymed loosely after Facebook Open Source Library) is a library of C++11 components designed with practicality and efficiency in mind. It complements (as opposed to competing against) offerings such as Boost and of course <code>std</code>. In fact, we embark on defining our own component only when something we need is either not available, or does not meet the needed performance profile.</p>\n</blockquote>\n<p>Let’s explore from its source code 15 C++11 features:</p>\n<h3><a id=\"1_auto_16\"></a><strong>1- auto</strong></h3>\n<p>C++11 introduces type inference capability using the auto keyword, which means that the compiler infers the type of a variable at the point of declaration. Folly uses auto for almost all its variable declarations, here’s an example from its source code</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c1.png\"><img alt=\"c1\" src=\"..\\..\\static\\image\\c7f645beaf332c6042966bd027c189a9.png\"/></a></p>\n<p>Using the auto keyword permits to spend less time having to write out things the compiler already knows.</p>\n<h3><a id=\"2_nullptr_24\"></a><strong>2- nullptr</strong></h3>\n<p>The constant 0 has had the double role of constant integer and null pointer constant.C++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant:nulptr</p>\n<p>In the Folly source code, all null pointers are represented by the new keyword nullptr, there ‘s no place where the constant 0 is used.</p>\n<h3><a id=\"3_shared_ptr_30\"></a><strong>3- shared_ptr</strong></h3>\n<p>The smart pointer is not a new concept, many libraries implemented it many years ago, the popular one is <a href=\"http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/shared_ptr.htm\">boost::shared_ptr</a>, what’s new is its standardization, and no need anymore to use an external library to work with smart pointers.</p>\n<p>Folly uses extensively the standardized shared pointer, only a few raw pointers remain in its source code.</p>\n<h3><a id=\"4_Stronglytyped_enums_36\"></a><strong>4- Strongly-typed enums</strong></h3>\n<p>“Traditional” enums in C++ export their enumerators in the surrounding scope, which can lead to name collisions, if two different enums in the same have scope define enumerators with the same name,</p>\n<p>C++11 introduces the enum class keywords. They no longer export their enumerators in the surrounding scope. Moreover, we can also now inherit from an enum.</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c2.png\"><img alt=\"c2\" src=\"..\\..\\static\\image\\d8d178cc22621317209713e785adb127.png\"/></a></p>\n<h3><a id=\"5_static_assert_46\"></a><strong>5- static assert</strong></h3>\n<p>C++11 introduces a new way to test assertions at compile-time, using the new keyword static_assert, this feature is very useful to add conditions to the template parameters, as shown in this template class from Folly source code:</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c3.png\"><img alt=\"c3\" src=\"..\\..\\static\\image\\345f19a659a61200f66ee16b1f00206f.png\"/></a></p>\n<h3><a id=\"6_Variadic_template_52\"></a>6- Variadic template</h3>\n<p>The variadic template is a template, which can take an arbitrary number of template arguments of any type. Both the classes &amp; functions can be variadic. Folly defines many variadic templates, here are two variadic template functions from the Folly source code:</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c4.png\"><img alt=\"c4\" src=\"..\\..\\static\\image\\d7fc551fa293c8c5703b2b611d2cfc33.png\"/></a></p>\n<h3><a id=\"7_Rangebased_for_loops_58\"></a><strong>7- Range-based for loops</strong></h3>\n<p>C++11 augmented the for statement to support the “foreach” paradigm of iterating over collections. it makes the code more simple and cleaner. Folly uses extensively this feature, here’s an example for Folly</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c6.png\"><img alt=\"c6\" src=\"..\\..\\static\\image\\f008789cc543fa55abfbf2dea98d93b3.png\"/></a></p>\n<h3><a id=\"8Initializer_lists_64\"></a><strong>8-Initializer lists</strong></h3>\n<p>In C++03 Initializer lists concern only arrays, in C++11 are not just for arrays anymore. The mechanism for accepting a <strong>{}</strong>-list is a function (often a constructor) accepting an argument of type <strong>std::initializer_list</strong>. Here’s an example of function accepting std::initializer_list as an argument</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c7.png\"><img alt=\"c7\" src=\"..\\..\\static\\image\\4f0f215cd08815fbf41eff5c74aaf260.png\"/></a></p>\n<p>And here’s how it’s invoked</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c8.png\"><img alt=\"c8\" src=\"..\\..\\static\\image\\ba28af23aa1febce701beff9b35dda31.png\"/></a></p>\n<h3><a id=\"9_noexcept_74\"></a><strong>9- noexcept</strong></h3>\n<p>If a function cannot throw an exception or if the program isn’t written to handle exceptions thrown by a function, that function can be declared <strong>noexcept.</strong></p>\n<p>Here’s an example from Folly source code</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c9.png\">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W9lkY7jf-1661574884080)(http://www.javadepend.com/Blog/wp-content/uploads/c9.png)]</a></p>\n<h3><a id=\"10_move_82\"></a><strong>10- move</strong></h3>\n<p>C++11 has introduced the concept of rvalue references (specified with &amp;&amp;) to differentiate a reference to an lvalue or an rvalue. An lvalue is an object that has a name, while an rvalue is an object that does not have a name (a temporary object). The move semantics allow modifying rvalues.</p>\n<p>For that C++11 introduces two new special member functions: the <em>move constructor</em> and the <em>move assignment operator</em>.</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c12.png\"><img alt=\"c12\" src=\"..\\..\\static\\image\\358121e2ac0ac9687491377721d980d0.png\"/></a></p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c10.png\"><img alt=\"c10\" src=\"..\\..\\static\\image\\67ab1d7a223fa3431a12bd7c54dd0ce2.png\"/></a></p>\n<p>Here’s a <a href=\"http://www.stroustrup.com/move.pdf\">good document</a> that explains better the benefits of move semantics.</p>\n<h3><a id=\"11lambda_94\"></a><strong>11-lambda</strong></h3>\n<p>C++11 provides the ability to create anonymous functions, called lambda functions, you can refer <a href=\"http://www.stroustrup.com/C++11FAQ.html#lambda\">here</a> for more details about this new feature.</p>\n<p>Folly uses it in many functions, here’s an example from its source code:</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c14.png\"><img alt=\"c14\" src=\"..\\..\\static\\image\\237c0e506603ff301feff82cdd14472c.png\"/></a></p>\n<h3><a id=\"12_Explicitly_defaulted_and_deleted_special_member_functions_102\"></a><strong>12- Explicitly defaulted and deleted special member functions</strong></h3>\n<p>In C++03, the compiler provides, for classes that do not provide them for themselves, a default constructor, a copy constructor, a copy assignment operator (<code>operator=</code>), and a destructor. The programmer can override these defaults by defining custom versions.</p>\n<p>However, there is very little control over the creation of these defaults. Making a class inherently non-copyable, for example, requires declaring a private copy constructor and copy assignment operator and not defining them.</p>\n<p>In C++11, certain features can be explicitly disabled. For example, the following type is non-copyable, which makes the code more simple and clean.</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c15.png\"><img alt=\"c15\" src=\"..\\..\\static\\image\\47fee17d0863ade103750024479db5fe.png\"/></a></p>\n<h3><a id=\"13_override_identifier_112\"></a><strong>13- override identifier</strong></h3>\n<p>In C++03, it is possible to accidentally create a new virtual function, when one intended to override a base class function.</p>\n<p>The <code>override</code> special identifier means that the compiler will check the base class(es) to see if there is a virtual function with this exact signature. And if there is not, the compiler will indicate an error.</p>\n<p>Folly uses extensively this new feature:</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c18.png\"><img alt=\"c18\" src=\"..\\..\\static\\image\\fa8f44c140eb596b9b91dffabd1ad952.png\"/></a></p>\n<h3><a id=\"14_stdthread_124\"></a><strong>14- std::thread</strong></h3>\n<p>A thread class (<code>std::thread</code>) is provided which takes a function object — and an optional series of arguments to pass to it — to run in the new thread.</p>\n<p>In C++11 working with threads is more simplified, here’s from Folly source code the new standard way to defines a new thread:</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c20.png\"><img alt=\"c20\" src=\"..\\..\\static\\image\\b5178c1c06c6f8b1506d8d8e4063d973.png\"/></a></p>\n<h3><a id=\"15_Unordered_containers_132\"></a><strong>15- Unordered containers</strong></h3>\n<p>An unordered container is a kind of hash table. C++11 offers four standard ones:</p>\n<ul><li>unordered_map</li><li>unordered_set</li><li>unordered_multimap</li><li>unordered_multiset</li></ul>\n<p>Folly uses in many places these new containers</p>\n<p><a href=\"http://www.javadepend.com/Blog/wp-content/uploads/c21.png\"><img alt=\"c21\" src=\"..\\..\\static\\image\\b2063c4d5cf4a7ccf6212fb6265b854c.png\"/></a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-27 12:35:12", "summary": "本文转载自："}