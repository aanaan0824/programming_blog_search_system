{"blogid": "123517926", "writerAge": "码龄3年", "writerBlogNum": "55", "writerCollect": "68", "writerComment": "60", "writerFan": "21", "writerGrade": "3级", "writerIntegral": "748", "writerName": "野生绿箭侠", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123517926.jpg", "writerRankTotal": "30992", "writerRankWeekly": "89648", "writerThumb": "42", "writerVisitNum": "145219", "blog_read_count": "1627", "blog_time": "已于 2022-05-08 14:45:26 修改", "blog_title": "线程池的 execute() 方法是如何执行的？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<section id=\"nice\">\n<h1><span class=\"prefix\"></span><span class=\"content\">线程池的 execute() 方法是如何执行的？</span><span class=\"suffix\"></span></h1>\n<h2> <span class=\"prefix\"></span><span class=\"content\">执行流程</span><span class=\"suffix\"></span> </h2>\n<p>一般情况下，我们使用线程池经常会用到它的 <code>execute()</code> 方法去提交任务，那么你知道它的执行流程吗？我们首先来看下源码实现：</p>\n<pre class=\"custom\"><code class=\"hljs\">public void execute(Runnable <span class=\"hljs-built_in\">command</span>) {<!-- --><br/>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">command</span> == null)<br/>            throw new NullPointerException();<br/>        <br/>         and so reject the task.<br/>        <br/>        int c = ctl.get();<br/>         // 这里判断的是当前工作的线程数小于核心线程数<br/>        <span class=\"hljs-keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) {<!-- --><br/>           // 如果小于则创建新的线程执行此任务<br/>            <span class=\"hljs-keyword\">if</span> (addWorker(<span class=\"hljs-built_in\">command</span>, <span class=\"hljs-literal\">true</span>))<br/>                <span class=\"hljs-built_in\">return</span>;<br/>            c = ctl.get();<br/>        }<br/>        // 判断线程池是否处于运行状态，如果是则把任务添加到队列<br/>        <span class=\"hljs-keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(<span class=\"hljs-built_in\">command</span>)) {<!-- --><br/>            int recheck = ctl.get();<br/>            // 再次检线程池是否处于运行状态，防止在第一次校验通过后线程池关闭<br/>            // 如果是非运行状态，则将刚加入队列的任务移除<br/>            <span class=\"hljs-keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(<span class=\"hljs-built_in\">command</span>))<br/>                reject(<span class=\"hljs-built_in\">command</span>);<br/>                // 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）<br/>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (workerCountOf(recheck) == 0)<br/>                addWorker(null, <span class=\"hljs-literal\">false</span>);<br/>        }<br/>         // 核心线程都在工作且队列已满，尝试新启动一个线程执行失败<br/>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!addWorker(<span class=\"hljs-built_in\">command</span>, <span class=\"hljs-literal\">false</span>))<br/>            reject(<span class=\"hljs-built_in\">command</span>);<br/>    }<br/></code></pre>\n<p>根据以上源码我们可以得出，<code>execute()</code> 方法的执行流程是：第一步先判断当前线程数是否大于核心线程数，如果结果为 false，则新建线程并执行任务；如果结果为 true，第二步则判断任务队列是否已满，如果结果为 false，则把任务添加到任务队列中等待线程执行，第三步则判断当前线程数量是否超过最大线程数，如果结果为 false，则新建线程执行此任务，否则将执行线程池的拒绝策略。</p>\n<h2> <span class=\"prefix\"></span><span class=\"content\">线程池拒绝策略</span><span class=\"suffix\"></span> </h2>\n<p>当任务过多且线程池的任务队列已满时，此时就会执行线程池的拒绝策略，线程池的拒绝策略默认有以下 4 种：</p>\n<ul><li>\n<section>\n<code>AbortPolicy</code>：中止策略，线程池会抛出 \n    <code>RejectedExecutionException</code>异常并中止执行此任务；\n   </section></li><li>\n<section>\n<code>CallerRunsPolicy</code>：把任务交给添加此任务的（main）线程来执行；\n   </section></li><li>\n<section>\n<code>DiscardPolicy</code>：忽略此任务，忽略最新的一个任务；\n   </section></li><li>\n<section>\n<code>DiscardOldestPolicy</code>：忽略旧的任务，最先加入队列的任务。\n   </section></li></ul>\n<p>线程池默认的拒绝策略为 <code>AbortPolicy</code> 中止策略。</p>\n<h2> <span class=\"prefix\"></span><span class=\"content\">自定义拒绝策略</span><span class=\"suffix\"></span> </h2>\n<p>通过 <code>new RejectedExecutionHandler</code>，并重写 <code>rejectedExecution()</code> 方法来实现自定义拒绝策略。</p>\n<p><strong>微信搜索：R先生专栏，点关注，不迷路！</strong></p> \n - END -\n</section>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-08 14:45:26", "summary": "线程池的方法是如何执行的？执行流程一般情况下，我们使用线程池经常会用到它的方法去提交任务，那么你知道它的执行流程吗？我们首先来看下源码实现：这里判断的是当前工作的线程数小于核心线程数如果小于则创建新的"}