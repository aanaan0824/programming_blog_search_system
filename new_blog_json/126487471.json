{"blogid": "126487471", "writerAge": "码龄2年", "writerBlogNum": "60", "writerCollect": "1843", "writerComment": "2527", "writerFan": "2234", "writerGrade": "6级", "writerIntegral": "6541", "writerName": "头发没有代码多", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126487471.jpg", "writerRankTotal": "2533", "writerRankWeekly": "93", "writerThumb": "2279", "writerVisitNum": "45412", "blog_read_count": "137", "blog_time": "于 2022-08-26 08:00:00 发布", "blog_title": "C++——内联函数|auto关键字", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p> </p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\">内联函数</a></p>\n<p id=\"%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">内联函数介绍</a></p>\n<p id=\"%E5%86%85%E8%81%94%E7%89%B9%E6%80%A7%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%86%85%E8%81%94%E7%89%B9%E6%80%A7%C2%A0\">内联特性 </a></p>\n<p id=\"%C2%A0auto%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B11)%E5%92%8C%E8%8C%83%E5%9B%B4for-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0auto%E5%85%B3%E9%94%AE%E5%AD%97%28C%2B%2B11%29%E5%92%8C%E8%8C%83%E5%9B%B4for\"> auto关键字(C++11)和范围for</a></p>\n<p id=\"auto%E7%9A%84%E5%85%B6%E5%AE%83%E7%94%A8%E6%B3%95%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#auto%E7%9A%84%E5%85%B6%E5%AE%83%E7%94%A8%E6%B3%95%C2%A0\">auto的其它用法 </a></p>\n<p id=\"auto%20%2C%E8%8C%83%E5%9B%B4for%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AF%BC%E7%9A%84%E6%83%85%E6%99%AF-toc\" style=\"margin-left:40px;\"><a href=\"#auto%20%2C%E8%8C%83%E5%9B%B4for%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AF%BC%E7%9A%84%E6%83%85%E6%99%AF\">auto ,范围for不能推导的情景</a></p>\n<p id=\"%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr(C%2B%2B11)%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr%28C%2B%2B11%29%C2%A0\">指针空值nullptr(C++11) </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\">内联函数</h1>\n<h2 id=\"%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">内联函数介绍</h2>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/weixin_49449676/article/details/125832634\" title=\"点击跳转_C语言宏知识讲解\">点击跳转_C语言宏知识讲解</a></p>\n<p>C语言中，宏有一些缺点如：可读性差，没类型安全检查，不方便调试 ，C++中为了解决这个问题，提出了内联函数</p>\n<p><span style=\"color:#0d0016;\"><strong> 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。</strong></span></p>\n<p><span style=\"color:#0d0016;\">先观察下列函数的反汇编，这个call指令就说明创建了函数的栈帧，也就是当前情况下函数没有被展开，如果函数被展开了就不会创建栈帧</span></p>\n<p><img alt=\"\" height=\"359\" src=\"..\\..\\static\\image\\b1ebb1013c954c66af1b036053d318fa.png\" width=\"777\"/></p>\n<p><img alt=\"\" height=\"258\" src=\"..\\..\\static\\image\\db9e47b39cbe44b4b23332571e20ec1e.png\" width=\"1132\"/></p>\n<p> 当我们加上inline，再观察</p>\n<p><img alt=\"\" height=\"457\" src=\"..\\..\\static\\image\\df7c06f4be78458193cd4f9ba96ba07c.png\" width=\"977\"/></p>\n<p> <img alt=\"\" height=\"252\" src=\"..\\..\\static\\image\\27b2ca6872ae471b974b3838851a1b81.png\" width=\"714\"/></p>\n<p>此时反汇编里仍然有这个call指令，说明加了inline之后还是会创建栈帧。</p>\n<p> <img alt=\"\" height=\"555\" src=\"..\\..\\static\\image\\3cf7c9a2fa0948898be1a83a73b3d159.png\" width=\"800\"/></p>\n<p>选择程序数据库</p>\n<p><img alt=\"\" height=\"555\" src=\"..\\..\\static\\image\\4e7507a20a8a48f68fa28046a1037d5a.png\" width=\"800\"/></p>\n<p>选择只适用于inline</p>\n<p>此时再进行调试，观察反汇编，我们发现此时fun（10,20）语句后没有call指令，说明此时函数被展开了，也就是没有创建栈帧</p>\n<p><img alt=\"\" height=\"449\" src=\"..\\..\\static\\image\\e4372c4efd0b4ff79ae9e657b359b974.png\" width=\"954\"/></p>\n<p> 内联函数有宏的有点，也改善了宏的缺点，C++中推荐使用内联函数</p>\n<p>《effectiveC++》中有一个条款说明：</p>\n<p>尽量使用const，enum，inline去替代宏</p>\n</blockquote>\n<h2 id=\"%E5%86%85%E8%81%94%E7%89%B9%E6%80%A7%C2%A0\">内联特性 </h2>\n<blockquote>\n<p>inline对编译器而言只是一个建议，听不听取这个建议由编译器决定 </p>\n<p>特性1：inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建议：<strong><span style=\"color:#fe2c24;\">将函数规模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不是递归、频繁调用的函数采用inline修饰，否则编译器会忽略inline特性。</span></strong>下图为《C++prime》第五版关于inline的建议<br/><img alt=\"\" height=\"256\" src=\"..\\..\\static\\image\\19d74fc2c58f45cab19d0d17090e32b5.png\" width=\"1200\"/></p>\n<p>特性2<strong><span style=\"color:#0d0016;\">： inline是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。</span></strong></p>\n<p>特性3：<span style=\"color:#fe2c24;\"><strong>inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到</strong></span></p>\n<p><img alt=\"\" height=\"346\" src=\"..\\..\\static\\image\\5698ad7c4e7141d880bb286adc8d972a.png\" width=\"559\"/></p>\n<p> <img alt=\"\" height=\"351\" src=\"..\\..\\static\\image\\cb86b5e69c62498684bd23dce141f868.png\" width=\"555\"/></p>\n<p><img alt=\"\" height=\"271\" src=\"..\\..\\static\\image\\8dcb426446f3490eb75e0094aec2fcba.png\" width=\"533\"/></p>\n<p>将声明和定义分离，之后运行，发生链接错误</p>\n<p></p>\n<p><img alt=\"\" height=\"172\" src=\"..\\..\\static\\image\\06d0182126b24ff1af1f12ff4796a501.png\" width=\"1200\"/> 这是因为，对inline void fun而言，编译器认为这是内联函数，但在展开的时候没办法展开，就要创建栈帧，创建栈帧就要调用call指令，执行call就需要一个地址，但是找不到这个地址，因为在生成符号表的时候认为它是内联函数，它没有符号表，所以在链接阶段会报错</p>\n<p></p>\n<p><img alt=\"\" height=\"633\" src=\"..\\..\\static\\image\\c447b486b7234f96bb01bfb580e823b1.png\" width=\"1200\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%C2%A0auto%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B11)%E5%92%8C%E8%8C%83%E5%9B%B4for\"> auto关键字(C++11)和范围for</h1>\n<blockquote>\n<p> auto用来自动推导类型</p>\n<p><img alt=\"\" height=\"364\" src=\"..\\..\\static\\image\\bca363e41ac64131ae1ca0a2fe548e97.png\" width=\"930\"/></p>\n<p> 自动推导函数的返回类型<img alt=\"\" height=\"427\" src=\"..\\..\\static\\image\\5b1e57c731dd4a54b4a080ab43b4813f.png\" width=\"1036\"/></p>\n<p> 也可以这样来打印数组，这个叫范围for，自动推导类型，然后自动依次取arr里面的数据，赋值给e</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tint arr[] = { 1,2,3,4,5,6,7,8,9,10 };\n\tfor (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\tfor (auto e : arr)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"354\" src=\"..\\..\\static\\image\\b9ac4a226000491e98e76a9b20fff91d.png\" width=\"979\"/></p>\n<p> 当类型比较长的时候，auto可以自动推导</p>\n</blockquote>\n<h2 id=\"auto%E7%9A%84%E5%85%B6%E5%AE%83%E7%94%A8%E6%B3%95%C2%A0\">auto的其它用法 </h2>\n<blockquote>\n<p> <img alt=\"\" height=\"214\" src=\"..\\..\\static\\image\\25518085df1c41eebf828332b737ab2b.png\" width=\"951\"/></p>\n<p> 此时会报错，这样写有提醒作用</p>\n<p><img alt=\"\" height=\"93\" src=\"..\\..\\static\\image\\1e9d98d435ba4fd4a9d84849e663dc63.png\" width=\"828\"/></p>\n<p> <img alt=\"\" height=\"161\" src=\"..\\..\\static\\image\\b75507a3a65a45529c8ca17774cffaf6.png\" width=\"695\"/></p>\n<p><strong> 用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;，如果不加就是创建了一个新的变量</strong></p>\n<p>修改下列数组，我们发现使用e--之后，数组并没发生变化，因为e是数组的一份拷贝，把数组的值依次赋值给e，然后对e--，但对数组本身没有产生任何影响</p>\n<p><img alt=\"\" height=\"571\" src=\"..\\..\\static\\image\\0e255148570247a095e4dae7c988d9dd.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"574\" src=\"..\\..\\static\\image\\90ec1447b10a425ca1456518550a3491.png\" width=\"1200\"/></p>\n<p>当使用引用后，可以修改arr数组 </p>\n<p>但不能将这里改为指针</p>\n<p><img alt=\"\" height=\"539\" src=\"..\\..\\static\\image\\7e4ab21ad6cb4eaf82346d4bc52f4a82.png\" width=\"1075\"/></p>\n<p> <img alt=\"\" height=\"141\" src=\"..\\..\\static\\image\\0c557076473e48f7832bc1bf78242513.png\" width=\"685\"/></p>\n<p> <img alt=\"\" height=\"748\" src=\"..\\..\\static\\image\\676de2b5bbc84b2294acbb7e3535bd9e.png\" width=\"1031\"/></p>\n<p>这种写法也是错误的 </p>\n<p><img alt=\"\" height=\"228\" src=\"..\\..\\static\\image\\a3dd622d2f114bb7b22e72f4341c1b82.png\" width=\"913\"/></p>\n<p>这样写可以</p>\n<p> <img alt=\"\" height=\"576\" src=\"..\\..\\static\\image\\ecdbc1ebebed49ea8d35f0b9b8765de4.png\" width=\"1105\"/></p>\n<p>这样写不行</p>\n<p><span style=\"color:#0d0016;\"><strong>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量</strong></span><br/>  </p>\n</blockquote>\n<h2 id=\"auto%20%2C%E8%8C%83%E5%9B%B4for%E4%B8%8D%E8%83%BD%E6%8E%A8%E5%AF%BC%E7%9A%84%E6%83%85%E6%99%AF\">auto ,范围for不能推导的情景</h2>\n<blockquote>\n<p>1.auto不能作为参数</p>\n<p><img alt=\"\" height=\"550\" src=\"..\\..\\static\\image\\8aadb1a2d9ac428992bea469c23d9b1e.png\" width=\"862\"/> 因为编译的时候要生成指令，生成指令就要建立栈帧，参数的变量在栈帧里面，此时由于不知道a，b的类型就不知道开多大的栈帧，所以会报错</p>\n<p><span style=\"color:#0d0016;\"><strong> auto不能直接用来声明数组</strong></span></p>\n<p><img alt=\"\" height=\"659\" src=\"..\\..\\static\\image\\a1567ec1a0db4727a5e002dbebd4d0b8.png\" width=\"920\"/></p>\n<p></p>\n<p>这块不能用范围for，这里只是传了一个指针过去，而不是整个数组，范围for必须确定范围</p>\n<p><span style=\"color:#0d0016;\"><strong>for循环迭代的范围必须是确定的</strong></span><br/> 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围。<br/> 注意：以下代码就有问题，因为for的范围不确定<br/>  </p>\n<p><img alt=\"\" height=\"679\" src=\"..\\..\\static\\image\\49d828475bef4f379e6734cb6c8a95a4.png\" width=\"981\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr(C%2B%2B11)%C2%A0\">指针空值nullptr(C++11) </h1>\n<blockquote>\n<p> C语言中空指针是NULL，在C++中NULL是0，形成是可以不接收实参的</p>\n<p><img alt=\"\" height=\"457\" src=\"..\\..\\static\\image\\b6ac68c069d04628a645df2c930b75f9.png\" width=\"995\"/></p>\n<p> C++11中增加了nullptr，代表空指针</p>\n<p>1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。<br/> 2. 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。<br/> 3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-26 08:00:00", "summary": "目录内联函数内联函数介绍内联特性关键字和范围的其它用法范围不能推导的情景指针空值内联函数内联函数介绍点击跳转语言宏知识讲解点击跳转语言宏知识讲解语言中，宏有一些缺点如：可读性差，没类型安全检查，不方便"}