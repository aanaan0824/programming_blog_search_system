{"blogid": "124410411", "writerAge": "码龄1年", "writerBlogNum": "2", "writerCollect": "12", "writerComment": "0", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "22", "writerName": "Finecsr", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124410411.jpg", "writerRankTotal": "205047", "writerRankWeekly": "1075632", "writerThumb": "2", "writerVisitNum": "2018", "blog_read_count": "1918", "blog_time": "于 2022-04-27 23:04:16 发布", "blog_title": "C语言的5种简单排序算法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%EF%BC%9A\">基本概要：</a></p>\n<p id=\"1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89\">1.冒泡排序（Bubble Sort）</a></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A\">基本思想：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</a></p>\n<p id=\"2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89\">2.快速排序（Quick Sort）</a></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A\">基本思想：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</a></p>\n<p id=\"3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89\">3.插入排序（Insertion Sort）</a></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A\">基本思想：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</a></p>\n<p id=\"4.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Simple%20Selection%20Sort%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Simple%20Selection%20Sort%EF%BC%89\">4.简单选择排序（Simple Selection Sort）</a></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A\">基本思想：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</a></p>\n<p id=\"5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89\">5.希尔排序（Shell Sort）</a></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A\">基本思想：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%EF%BC%9A\">基本概要：</h2>\n<p>本文主要介绍五种简单常用的排序算法：<span style=\"background-color:#f9eda6;\">冒泡排序，快速排序，插入排序，选择排序，希尔排序</span>。包括它们的基本思想和代码实现。值得一说的是：插入排序，冒泡排序，选择排序平均情况下的时间复杂度为<img alt=\"O\\left ( n^{2} \\right )\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?O%5Cleft%20%28%20n%5E%7B2%7D%20%5Cright%20%29\"/>，<strong>因此在排序数据较少的情况下较好</strong>；而希尔排序和快速排序的平均时间复杂度为<img alt=\"O\\left ( nlogn \\right )\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?O%5Cleft%20%28%20nlogn%20%5Cright%20%29\"/>，<strong>因此在排序数据较多的情况下较好，但是对于快速排序而言，数据基本有序时反而不好</strong>，接下来会详细阐述。（皆以从小到大的顺序排列）</p>\n<h2 id=\"1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89\">1.冒泡排序（Bubble Sort）</h2>\n<h3 id=\"%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A\">基本思想：</h3>\n<p>冒泡排序是一个非常好理解的排序，顾名思义——冒泡，此时将要排序的数据从上至下排列，从最上面的数（第一个数据）开始对相邻的两个数据进行比较，<span style=\"background-color:#f9eda6;\">较小的数据往上浮，较大的数据往下沉</span>，达到排序的效果。</p>\n<p>（1）对每一对相邻的元素进行比较，若第一个比第二个大，则调换这两个元素的位置，依次两两比较直到数据的最后一对，此为一轮操作。</p>\n<p>（2）重复n轮此操作（n为元素的个数），不过每轮结束后的最后一个元素不用参与下一轮的比较，因为经历一轮排序后，最后一个元素一定比前面所有的元素都要大。</p>\n<p>（3）因此每一轮需要比较的元素都在减少，一直到没有数可比较为止。<span style=\"background-color:#f9eda6;\">（不过为了减少比较次数，可以记录每轮是否有数据的交换，如果没有交换，表明当前数据已经按从小到大的顺序拍好了，可直接跳出循环）</span></p>\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</h3>\n<pre><code class=\"language-cs\">#include&lt;stdio.h&gt;\n\nint main() {\n\tint n, m, i, j, temp;\n\tint arr[100];\n\n\tscanf_s(\"%d\", &amp;n);    //scnaf_s是更为安全的输入方式；n为元素的个数；\n\tfor (i = 0; i &lt; n; i++) {\n\t\tscanf_s(\"%d\", &amp;arr[i]);    //输入数据；\n\t}\n\n\tm = n;            //因为每进行一次第一轮循环，需要排序的数据都要“--”，因此定义变量m=n；\n\tfor (i = 0; i &lt; n; i++) {\n\t\tint exchange = 0;           //记录这一轮会不会有数据的交换；\n\t\tfor (j = 0; j &lt; m-1; j++) {\n\t\t\tif (arr[j] &gt; arr[j + 1]) {\n\t\t\t\ttemp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t\texchange = 1;\n\t\t\t}\n\t\t}\n\t\tm--;\n\t\tif (!exchange)  //若没有数据的交换，则数据已经排列完毕，跳出循环；\n\t\t\tbreak;\n\t}\n\tfor (i = 0; i &lt; n; i++) {\n\t\tprintf(\"%d \", arr[i]);        //输出\n\t}\n\n\treturn 0;\n\n}</code></pre>\n<h2 id=\"2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89\">2.快速排序（Quick Sort）</h2>\n<p>快速排序是这五类中平均性能最优的排序算法，其中运用了<span style=\"background-color:#f9eda6;\">分治</span>的思想，并且调用了<span style=\"background-color:#f9eda6;\">递归函数</span>，因此也是这五类中最难的一个。</p>\n<h3>基本思想：</h3>\n<p>快速排序的重点在于找一个基准值，将数列分为两部分——大于基准值的放在右边，小于基准值的 放在左边。然后分别对这两部分重复次操作，一分为二，二分为四······直到每个元素自成一部分。</p>\n<p>1.将数据的中间元素设为基准值，初始化令 <img alt=\"i\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?i\"/> 指向最左边个元素，令 <img alt=\"j\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?j\"/> 指向最右边个元素，通过<img alt=\"i++\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?i&amp;plus;&amp;plus;\"/>从左往右找一个大于基准数的数，通过<img alt=\"j--\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?j--\"/>从右往左找一个小于基准数的数，交换两数的位置，直到<img alt=\"i=j\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?i%3Dj\"/>。</p>\n<p>2.如此不断的细分递归，达到排序的目的</p>\n<h3>代码实现：</h3>\n<pre><code class=\"language-cs\">#include&lt;stdio.h&gt;\n\nvoid Quicksort(int a[], int left, int right) {   //快排函数\n\tint temp;\n\tint mid = a[(left + right) / 2];            //找基准值\n\tint i = left;\n\tint j = right;\n//在左侧找一个大于基准值的数，在右侧找一个小于基准数的数，然后交换位置\n\twhile (i &lt;= j) {   \n\t\twhile (a[i] &lt; mid) i++;\n\t\twhile (a[j] &gt; mid) j--;\n\t\tif (i &lt;= j) {\n\t\t\ttemp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tif (i &lt; right) Quicksort(a, i, right);        //递归\n\tif (j &gt; left) Quicksort(a, left, j);           //递归\n}\n\nint main() {\n\tint n, m, i;\n\tint arr[100];\n\tscanf_s(\"%d\", &amp;n);\n\tfor (i = 0; i &lt; n; i++) {\n\t\tscanf_s(\"%d\", &amp;arr[i]);\t\t\t\t\t\t//输入\n\t}\n\n\tQuicksort(arr, 0, n - 1);                        //调用函数\n\n\tfor (i = 0; i &lt; n; i++) {\n\t\tprintf(\"%d \", arr[i]);\t\t\t\t\t\t//输出\n\t}\n\treturn 0;\n}</code></pre>\n<h2 id=\"3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89\">3.插入排序（Insertion Sort）</h2>\n<h3>基本思想：</h3>\n<p>将数据分为两组——<span style=\"background-color:#f9eda6;\">一组是有序的，一组是无序的</span>，将无序数据中的元素依次插入到有序数据中，从而将整个数据变为有序的（这里的分组是<span style=\"background-color:#f9eda6;\">潜意识</span>的，实际上并不会用两个数组来分）</p>\n<p>1.初始时，将第一个元素分为有序组（因为只有一个元素，所以认为它是排好序的），其余元素分为无序组</p>\n<p>2.因此只需从第二个元素开始，依次在有序组中找到自己的位置，插入即可，直到最后一个元素。</p>\n<p>3.但这并不意味着只需要一次循环，因为在“找自己的位置”的过程中，需要将自己与前面的元素相比较，若是自己较小，则将那个元素后移一位；若是自己较大，则将自己插入到上一次比较的位置</p>\n<h3>代码实现：</h3>\n<pre><code class=\"language-cs\">#include&lt;stdio.h&gt;\n\nint main() {\n\tint n, m, i, j, temp;\n\tint arr[100];\n\n\tscanf_s(\"%d\", &amp;n);\n\tfor (i = 0; i &lt; n; i++) {\n\t\tscanf_s(\"%d\", &amp;arr[i]);\t\t\t\t\t\t//输入 \n\t}\n    for(i=1; i&lt;n; i++)\t\t\t\t\t\t\t\t//从无序组的第一个元素开始 \n        if(arr[i] &lt; arr[i-1])   \t\t\t\t\t\t// 判断是否要向前寻找插入的位置 \n        {\n            int temp = arr[i];                       \n            for(j=i-1; j&gt;=0 &amp;&amp; arr[j]&gt;temp; j--)    //将大于自己的数依次向后挪位 \n                arr[j+1] = arr[j];                    \n            arr[j+1] = temp;                       //插入 \n        }\n\tfor (i = 0; i &lt; n; i++) {\n\t\tprintf(\"%d \", arr[i]);\t\t\t\t\t\t//输出 \n\t}\n\treturn 0;\n}</code></pre>\n<h2 id=\"4.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Simple%20Selection%20Sort%EF%BC%89\">4.简单选择排序（Simple Selection Sort）</h2>\n<h3>基本思想：</h3>\n<p>设一个数据集有n个元素，选择这n个元素中最小的一个与第一个元素交换位置，再在剩下的n-1个元素中选择最小的一个与第二个元素交换位置，直到在最后两个元素中选择最小的一个放在倒数第二的位置上，排序完成。</p>\n<pre><code class=\"language-cs\">#include&lt;stdio.h&gt;\n\nint main() {\n\tint n, m, i, j, p, temp;\n\tint arr[100];\n\n\tscanf_s(\"%d\", &amp;n);\n\tfor (i = 0; i &lt; n; i++) {\n\t\tscanf_s(\"%d\", &amp;arr[i]);\t\t\t\t\t\t//输入 \n\t}\n\n\tfor (i = 0; i &lt; n - 1; i++) {\n\t\tp = i;                            //p用于记录最小元素的下标\n\t\tfor (j = i + 1; j &lt; n; j++) {       //找到剩下元素中最小的那一个\n\t\t\tif (arr[p] &gt; arr[j])\n\t\t\t\tp = j;\n\t\t}\n\t\ttemp = arr[i];                        //temp是交换两数时的中间变量\n\t\tarr[i] = arr[p];\n\t\tarr[p] = temp;\n\t}\n\tfor (i = 0; i &lt; n; i++) {\n\t\tprintf(\"%d \", arr[i]);\t\t\t\t\t\t//输出 \n\t}\n\treturn 0;\n}</code></pre>\n<h3>代码实现：</h3>\n<h2 id=\"5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89\">5.希尔排序（Shell Sort）</h2>\n<p><span style=\"background-color:#f9eda6;\">希尔排序是插入排序的优化</span>，它先将待排序列进行预排序，然后对次序列进行一次插入排序，不一样的是经过预处理之后的插入排序时间复杂度为<img alt=\"O\\left ( n \\right )\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?O%5Cleft%20%28%20n%20%5Cright%20%29\"/></p>\n<h3>基本思想：</h3>\n<p>定义一个间隔gap，在一组数据中，将相隔为gap的元素作为一个组，对组内元素执行简单的插入排序，然后不断缩小gap重复此操作，完成数据的预处理，直到gap=1，表示对所有数进行插入排序，算法终止。</p>\n<p>1.初始化<img alt=\"gap=\\frac{n}{2}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?gap%3D%5Cfrac%7Bn%7D%7B2%7D\"/>（n为元素个数），将数据中所有距离为gap的元素分在一组（此时这组数据会被分成<img alt=\"\\frac{n}{2}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B2%7D\"/>个组，每组有两个元素，对每个组进行排序）</p>\n<p>2.接着缩小gap至<img alt=\"\\frac{n}{4}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B4%7D\"/>，将数据中所有距离为gap的元素分在一组（此时这组数据会被分成<img alt=\"\\frac{n}{4}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B4%7D\"/>个组，每组有四个元素，对每个组进行排序）</p>\n<p>3.重复直到gap=1，此时数据为一组，有n个元素，简单插入排序即可。</p>\n<p></p>\n<h3>代码实现：</h3>\n<pre><code class=\"language-cs\">#include&lt;stdio.h&gt;\n\nint main() {\n\tint n, m, i, j, temp,gap;\n\tint arr[100];\n\n\tscanf(\"%d\", &amp;n);\n\tfor (i = 0; i &lt; n; i++) {\n\t\tscanf(\"%d\", &amp;arr[i]);\t\t\t\t\t\t//输入\n\t}\n\n    for(gap=n/2; gap&gt;0; gap/=2)\n        for(i=gap; i&lt;n; i++)\n            for(j=i-gap; j&gt;=0 &amp;&amp; arr[j]&gt;arr[j+gap]; j-=gap){\n            \ttemp=arr[j];\n            \tarr[j]=arr[j+gap];\n            \tarr[j+gap]=temp;\n\t\t\t}\n\tfor (i = 0; i &lt; n; i++) {\n\t\tprintf(\"%d \", arr[i]);\t\t\t\t\t\t//输出\n\t}\n\treturn 0;\n}</code></pre>\n<p><strong>小白文一篇</strong></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-27 23:04:16", "summary": "目录基本概要：冒泡排序基本思想：代码实现：快速排序基本思想：代码实现：插入排序基本思想：代码实现：简单选择排序基本思想：代码实现：希尔排序基本思想：代码实现：基本概要：本文主要介绍五种简单常用的排序算"}