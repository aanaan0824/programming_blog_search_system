{"blogid": "125578029", "writerAge": "码龄4年", "writerBlogNum": "31", "writerCollect": "15", "writerComment": "0", "writerFan": "4", "writerGrade": "2级", "writerIntegral": "312", "writerName": "zznb", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125578029.jpg", "writerRankTotal": "64313", "writerRankWeekly": "120547", "writerThumb": "0", "writerVisitNum": "3573", "blog_read_count": "891", "blog_time": "于 2022-07-03 14:57:52 发布", "blog_title": "c++线程锁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p><strong>1.mutex</strong></p>\n</blockquote>\n<p>“锁”的本质属性是为内存中的各种变量提供“访问保护”，计算机定义为互斥量（mutex）。</p>\n<p>mutex：互斥访问的量，在多线程编程中起作用，c++11开始提供了std::mutex，对多线程的加锁操作提供了很好的支持。</p>\n<p>例：假定有一个全局变量counter，启动两个线程，每个都对该变量自增10000次，最后输出该变量的值</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;mutex&gt;\n#include &lt;chrono&gt;\n#include &lt;stdexcept&gt;\n\nint counter = 0;\nvoid increase(int time){\n\tfor(int i=0;i&lt;time;i++){\n\t//当前线程休眠1ms\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\tcounter++;\n\t}\n}\n\nint main(int argc, char** argv){\n\tstd::thread t1(increase, 10000);\n\tstd::thread t2(increase, 10000);\n\tt1.join();\n\tt2.join();\n\tstd::cout&lt;&lt;\"counter:\"&lt;&lt;counter&lt;&lt; std::endl;\n\treturn 0;\n}</code></pre>\n<p>为了显示多线程竞争，导致结果不正确的现象，在每次自增操作的时候都让当前线程休眠1ms</p>\n<p>对应的cmakelists.txt</p>\n<pre><code class=\"language-cpp\">#声明要求的cmake最低版本\ncmake_minimum_required(VESRION 3.0.0)\n#声明一个cmake工程\nproject(HelloMutex)\n#设置编译模式\nset(CMAKE_BUILD_TYPE \"Debug\")\n#语法：add_excutable(程序名 源代码文件)\nadd_excutable(${PROJECT_NAME} mutex_demo1_no_mutex.cpp)\n\nif(WIN32)\n set(PLATFROM_LIBS Ws2_32 mswsock iphlpapi ntdll)\nelse(WIN32)\n set(PLATFROM_LIBS pthread ${CMAKE_DL_LIBS})\nendif(WIN32)\n#将库文件链接到可执行程序上\ntarget_link_libraries(${PROJECT_NAME} ${PLATFROM_LIBS})</code></pre>\n<p>自增操作“counter++”不是原子操作，而是由多条汇编指令完成的，多个线程对同一个变量进行读写操作就会出现不可预期的操作。假定counter当前值为1，线程1 读取到了10，线程2也读取到了10，分别执行自增操作，线程1和线程2分别将自增的结果写回counter,不管写入的顺序如何，counter的值都会是11，但我们期望的结果是12.</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;mutex&gt;\n#include &lt;chrono&gt;\n#include &lt;stdexcept&gt;\n\nint counter = 0;\nstd::mutex mtx;\nvoid increase(int time){\n\tfor(int i=0;i&lt;time;i++){\n\tmtx.lock();\n\t//当前线程休眠1ms\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\tcounter++;\n\tmtx.unlock(); //利用锁来保护共享变量\n\t}\n}\n\nint main(int argc, char** argv){\n\tstd::thread t1(increase, 10000);\n\tstd::thread t2(increase, 10000);\n\tt1.join();\n\tt2.join();\n\tstd::cout&lt;&lt;\"counter:\"&lt;&lt;counter&lt;&lt; std::endl;\n\treturn 0;\n}</code></pre>\n<p>“利用锁来保护共享变量”，在这里共享变量就是counter(多个线程对能对期进行访问)</p>\n<p>std::mutex总结： std::mutex对象，任意时刻最多允许一个线程对其上锁；mtx.lock()，调用该函数的线程尝试加锁，如果上锁不成功，即：其他线程已经上锁且未释放，则当前线程block.如果上锁成功，则执行后面的操作，操作完成后要调用mtx.unlock()释放锁，否则会导致死锁的产生。</p>\n<p>mtx.unlock():释放锁</p>\n<p>std::mutex还有一个操作：mtx.try_lock(),与mtx.lock()不同点在于，如果上锁不成功，当前线程不阻塞。</p>\n<blockquote>\n<p><strong>2.lock_guard</strong></p>\n</blockquote>\n<p> 虽然std::mutex可以对多线程编程中的共享变量提供保护，但是直接使用std::mutex的情况不多，因为仅使用std::mutex有时候会发生死锁。考虑这样一个情况：假设线程1上锁成功，线程2上锁等待，但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2\"永久的等待下去\"。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;mutex&gt;\n#include &lt;chrono&gt;\n#include &lt;stdexcept&gt;\n\nint counter = 0;\nstd::mutex mtx;\n\nvoid increase_proxy(int time, int id){\n\tfor(int i=0;i&lt;time;i++){\n\tmtx.lock();\n\t//线程1上锁成功后，抛出异常，未释放锁\n\tif(id == 1){\n\t\tthrow std::runtime_error(\"throw exception....\");\n\t}\n\t//当前线程休眠1ms\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\tcounter++;\n\tmtx.unlock(); //利用锁来保护共享变量\n\t}\n}\n\nvoid increase(int time, int id){\n\ttry{\n\t\tincrease_proxy(time, id);\n\t}\n\tcatch(const std::exception&amp; e){\n\t\tstd::cout&lt;&lt;\"id:\" &lt;&lt; id &lt;&lt; \",\" &lt;&lt; e.what() &lt;&lt; std::endl;\n\t}\n}\n\nint main(int argc, char** argv){\n\tstd::thread t1(increase, 10000, 1);\n\tstd::thread t2(increase, 10000, 2);\n\tt1.join();\n\tt2.join();\n\tstd::cout&lt;&lt;\"counter:\"&lt;&lt;counter&lt;&lt; std::endl;\n\treturn 0;\n}</code></pre>\n<p>程序执行后，并没有退出，而是永远的“卡”在那里了，也就是发生了死锁，这个时候就需要lock_guard(),lock_guard只有构造函数和析构函数，当调用构造函数时，会自动调用传入的对象的lock()函数，而当调用析构函数时，自动调用unlock()函数</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;mutex&gt;\n#include &lt;chrono&gt;\n#include &lt;stdexcept&gt;\n\nint counter = 0;\nstd::mutex mtx;\n\nvoid increase_proxy(int time, int id){\n\tfor(int i=0;i&lt;time;i++){\n\t//std::lock_guard对象构造时，自动调用mtx_lock()进行上锁\n\t//std::lock_guard对象析构时，自动调用mtx.unlock()释放锁\n\tstd::lock_guard&lt;std::mutex&gt; lk(mtx);\n\t//线程1上锁成功后，抛出异常，未释放锁\n\tif(id == 1){\n\t\tthrow std::runtime_error(\"throw exception....\");\n\t}\n\t//当前线程休眠1ms\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\tcounter++;\n\t}\n}\n\nvoid increase(int time, int id){\n\ttry{\n\t\tincrease_proxy(time, id);\n\t}\n\tcatch(const std::exception&amp; e){\n\t\tstd::cout&lt;&lt;\"id:\" &lt;&lt; id &lt;&lt; \",\" &lt;&lt; e.what() &lt;&lt; std::endl;\n\t}\n}\n\nint main(int argc, char** argv){\n\tstd::thread t1(increase, 10000, 1);\n\tstd::thread t2(increase, 10000, 2);\n\tt1.join();\n\tt2.join();\n\tstd::cout&lt;&lt;\"counter:\"&lt;&lt;counter&lt;&lt; std::endl;\n\treturn 0;\n}</code></pre>\n<p>std::lock_guard有两个构造函数，具体</p>\n<pre><code class=\"language-cpp\">explicit lock_guard(mutex_type&amp; m);  (1)\nlock_guard(mutex_type&amp; m,std::adopt_lock_tt);  (2)\nlock_guard(const lock_guard&amp; ) = delete;    (3)\n</code></pre>\n<p>上个例子中，使用(1)构造函数，第(3)个为拷贝构造函数，定义为删除函数。</p>\n<p>第(2)个构造函数有两个参数，其中第二个参数类型为std::adopt_lock_t。这个构造函数假定：当前线程已经上锁成功，所以不再调用lock()函数，c++还提供了std::lock_guard()的加强版std::unique_lock,提供了更多的接口，使用更加灵活，但性能方面也会有些受损。</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-03 14:57:52", "summary": "锁的本质属性是为内存中的各种变量提供访问保护，计算机定义为互斥量。：互斥访问的量，在多线程编程中起作用，开始提供了，对多线程的加锁操作提供了很好的支持。例：假定有一个全局变量，启动两个线程，每个都对该"}