{"blogid": "126664178", "writerAge": "码龄5年", "writerBlogNum": "21", "writerCollect": "134", "writerComment": "8", "writerFan": "9", "writerGrade": "3级", "writerIntegral": "442", "writerName": "浮__夸", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126664178.jpg", "writerRankTotal": "35358", "writerRankWeekly": "123988", "writerThumb": "30", "writerVisitNum": "22431", "blog_read_count": "88", "blog_time": "于 2022-09-02 16:09:24 发布", "blog_title": "RT-thread 中CAN总线的应用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>准备：</h1>\n<p>        RT-thread Studio 2.2.5</p>\n<p>        CubeMX 6.6.1</p>\n<p>        rt-thread驱动包 4.0.3  </p>\n<h1>1.新建项目</h1>\n<p>        <img alt=\"\" height=\"559\" src=\"..\\..\\static\\image\\91505b314a9143e6ae81cb3e1ae0894d.png\" width=\"391\"/></p>\n<h1>2.打开CubeMX Settings ，设置CAN。</h1>\n<p>找到CAN1，并勾选激活，然后直接获取代码（无需任何操作）。然后关闭CubeMX窗口会弹出一个提示框，告诉你：</p>\n<p>原先  drivers目录下：stm32f4xx_hal_conf.h文件 重命名为：stm32f4xx_hal_conf_bak.h(即该配置文件失效了)。并在cubemx/lnc目录下重新生成了新的配置文件。</p>\n<p><span style=\"color:#fe2c24;\">注意：要在 ”cubemx/lnc/stm32f4xx_hal_conf.h“ 中取消对  ”#define HAL_UART_MODULE_ENABLED“ 的注释。因为控制台中有用到串口，这里不取消注释会报错。</span></p>\n<p> <img alt=\"\" height=\"338\" src=\"..\\..\\static\\image\\e315ec2327c64d7086becbbf642215e2.png\" width=\"410\"/></p>\n<p> <img alt=\"\" height=\"617\" src=\"..\\..\\static\\image\\002b74a6618840eeb54ffa483a09a433.png\" width=\"677\"/></p>\n<p> <img alt=\"\" height=\"153\" src=\"..\\..\\static\\image\\54a7cb9167b64082846a9687ff715e1b.png\" width=\"518\"/></p>\n<p><img alt=\"\" height=\"808\" src=\"..\\..\\static\\image\\27c91d4be3064a17b3a965cda2908865.png\" width=\"407\"/></p>\n<h1> 3.修改board.h文件</h1>\n<pre><code class=\"language-objectivec\">/*    在board.h中添加宏定义 启用CAN*/\n#define BSP_USING_CAN\n#define BSP_USING_CAN1</code></pre>\n<h1> 4.启用CAN组件,并在示例/rt-thread设备驱动示例中打开can device。</h1>\n<p><img alt=\"\" height=\"1125\" src=\"..\\..\\static\\image\\23da50bf000c451391d65db8b7babc40.png\" width=\"1131\"/></p>\n<h1> 5.在drivers目录下添加drv_can.c 和drv_can.h文件</h1>\n<blockquote>\n<p>这两个文件在下面这个目录中：</p>\n<p>X:\\RT-ThreadStudio\\repo\\Extract\\RT-Thread_Source_Code\\RT-Thread\\4.0.3\\bsp\\stm32\\libraries\\HAL_Drivers</p>\n</blockquote>\n<h1> 6.添加官方示例</h1>\n<pre><code class=\"language-objectivec\">/*\n * 程序清单：这是一个 CAN 设备使用例程\n * 例程导出了 can_sample 命令到控制终端\n * 命令调用格式：can_sample can1\n * 命令解释：命令第二个参数是要使用的 CAN 设备名称，为空则使用默认的 CAN 设备\n * 程序功能：通过 CAN 设备发送一帧，并创建一个线程接收数据然后打印输出。\n*/\n\n#include &lt;rtthread.h&gt;\n#include \"rtdevice.h\"\n\n#define CAN_DEV_NAME       \"can1\"      /* CAN 设备名称 */\n\nstatic struct rt_semaphore rx_sem;     /* 用于接收消息的信号量 */\nstatic rt_device_t can_dev;            /* CAN 设备句柄 */\n\n/* 接收数据回调函数 */\nstatic rt_err_t can_rx_call(rt_device_t dev, rt_size_t size)\n{\n    /* CAN 接收到数据后产生中断，调用此回调函数，然后发送接收信号量 */\n    rt_sem_release(&amp;rx_sem);\n\n    return RT_EOK;\n}\n\nstatic void can_rx_thread(void *parameter)\n{\n    int i;\n    rt_err_t res;\n    struct rt_can_msg rxmsg = {0};\n\n    /* 设置接收回调函数 */\n    rt_device_set_rx_indicate(can_dev, can_rx_call);\n\n#ifdef RT_CAN_USING_HDR\n    struct rt_can_filter_item items[5] =\n    {\n        RT_CAN_FILTER_ITEM_INIT(0x100, 0, 0, 0, 0x700, RT_NULL, RT_NULL), /* std,match ID:0x100~0x1ff，hdr 为 - 1，设置默认过滤表 */\n        RT_CAN_FILTER_ITEM_INIT(0x300, 0, 0, 0, 0x700, RT_NULL, RT_NULL), /* std,match ID:0x300~0x3ff，hdr 为 - 1 */\n        RT_CAN_FILTER_ITEM_INIT(0x211, 0, 0, 0, 0x7ff, RT_NULL, RT_NULL), /* std,match ID:0x211，hdr 为 - 1 */\n        RT_CAN_FILTER_STD_INIT(0x486, RT_NULL, RT_NULL),                  /* std,match ID:0x486，hdr 为 - 1 */\n        {0x555, 0, 0, 0, 0x7ff, 7,}                                       /* std,match ID:0x555，hdr 为 7，指定设置 7 号过滤表 */\n    };\n    struct rt_can_filter_config cfg = {5, 1, items}; /* 一共有 5 个过滤表 */\n    /* 设置硬件过滤表 */\n    res = rt_device_control(can_dev, RT_CAN_CMD_SET_FILTER, &amp;cfg);\n    RT_ASSERT(res == RT_EOK);\n#endif\n\n    while (1)\n    {\n        /* hdr 值为 - 1，表示直接从 uselist 链表读取数据 */\n        rxmsg.hdr = -1;\n        /* 阻塞等待接收信号量 */\n        rt_sem_take(&amp;rx_sem, RT_WAITING_FOREVER);\n        /* 从 CAN 读取一帧数据 */\n        rt_device_read(can_dev, 0, &amp;rxmsg, sizeof(rxmsg));\n        /* 打印数据 ID 及内容 */\n        rt_kprintf(\"ID:%x\", rxmsg.id);\n        for (i = 0; i &lt; 8; i++)\n        {\n            rt_kprintf(\"%2x\", rxmsg.data[i]);\n        }\n\n        rt_kprintf(\"\\n\");\n    }\n}\n\nint can_sample(int argc, char *argv[])\n{\n    struct rt_can_msg msg = {0};\n    rt_err_t res;\n    rt_size_t  size;\n    rt_thread_t thread;\n    char can_name[RT_NAME_MAX];\n\n    if (argc == 2)\n    {\n        rt_strncpy(can_name, argv[1], RT_NAME_MAX);\n    }\n    else\n    {\n        rt_strncpy(can_name, CAN_DEV_NAME, RT_NAME_MAX);\n    }\n    /* 查找 CAN 设备 */\n    can_dev = rt_device_find(can_name);\n    if (!can_dev)\n    {\n        rt_kprintf(\"find %s failed!\\n\", can_name);\n        return RT_ERROR;\n    }\n\n    /* 初始化 CAN 接收信号量 */\n    rt_sem_init(&amp;rx_sem, \"rx_sem\", 0, RT_IPC_FLAG_FIFO);\n\n    /* 以中断接收及发送方式打开 CAN 设备 */\n    res = rt_device_open(can_dev, RT_DEVICE_FLAG_INT_TX | RT_DEVICE_FLAG_INT_RX);\n    RT_ASSERT(res == RT_EOK);\n    /* 创建数据接收线程 */\n    thread = rt_thread_create(\"can_rx\", can_rx_thread, RT_NULL, 1024, 25, 10);\n    if (thread != RT_NULL)\n    {\n        rt_thread_startup(thread);\n    }\n    else\n    {\n        rt_kprintf(\"create can_rx thread failed!\\n\");\n    }\n\n    msg.id = 0x78;              /* ID 为 0x78 */\n    msg.ide = RT_CAN_STDID;     /* 标准格式 */\n    msg.rtr = RT_CAN_DTR;       /* 数据帧 */\n    msg.len = 8;                /* 数据长度为 8 */\n    /* 待发送的 8 字节数据 */\n    msg.data[0] = 0x00;\n    msg.data[1] = 0x11;\n    msg.data[2] = 0x22;\n    msg.data[3] = 0x33;\n    msg.data[4] = 0x44;\n    msg.data[5] = 0x55;\n    msg.data[6] = 0x66;\n    msg.data[7] = 0x77;\n    /* 发送一帧 CAN 数据 */\n    size = rt_device_write(can_dev, 0, &amp;msg, sizeof(msg));\n    if (size == 0)\n    {\n        rt_kprintf(\"can dev write data failed!\\n\");\n    }\n\n    return res;\n}\n/* 导出到 msh 命令列表中 */\nMSH_CMD_EXPORT(can_sample, can device sample);\n</code></pre>\n<h1>7.注意把application中的main.c与cubemx中的main.c合并，并注释掉一个，不然会冲突。</h1>\n<h1>8.在控制台中输入can_sample命令就可以用CAN接收工具收到数据了。波特率默认1MHz</h1>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-02 16:09:24", "summary": "准备：驱动包新建项目打开，设置。找到，并勾选激活，然后直接获取代码无需任何操作。然后关闭窗口会弹出一个提示框，告诉你：原先目录下：文件重命名为：即该配置文件失效了。并在目录下重新生成了新的配置文件。注"}