{"blogid": "126626162", "writerAge": "码龄9年", "writerBlogNum": "225", "writerCollect": "33", "writerComment": "2", "writerFan": "44", "writerGrade": "5级", "writerIntegral": "2216", "writerName": "Ares-Wang", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126626162.jpg", "writerRankTotal": "10418", "writerRankWeekly": "3523", "writerThumb": "73", "writerVisitNum": "13709", "blog_read_count": "272", "blog_time": "已于 2022-09-01 10:41:41 修改", "blog_title": ".NET 回调、接口回调、 委托", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>回调浅析（委托、接口回调）<br/> 说到C#回调，通常情况下，指的是某个委托或者接口回调。现将从网上各位前辈那里学得的一些经验加以整理，形成一个稍全面一些的文章，希望对大家有所帮助！<br/> 一、 委托<br/> 先看一段代码：<br/> // 定义委托<br/> delegate void WorkDone();</p>\n<p>class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Do();</p>\n<pre><code>\tConsole.ReadLine();\n}\n\npublic static void Do()\n{\n\t// 首先给callback委托赋值\n\tWorkDone callback = new WorkDone(WorkDoneHandler);\n\t //WorkDone callback = WorkDoneHandler;   等价\n\t// 将callback作为参数\n\tWorking(callback);\n}\n\npublic static void Working(WorkDone callBack)\n{\n\t// 当工作完成的时候执行这个委托\n\tcallBack();\n}\n\npublic static void WorkDoneHandler()\n{\n\tConsole.WriteLine(DateTime.Now);\n}\n</code></pre>\n<p>}</p>\n<p>上面的代码中，将方法WorkDoneHandler()作为参数，传递给了另一个方法Working(WorkDone callBack)，这样做的好处在于，可以动态的指定执行哪个方法。比如在Do()方法中，我们指定的callback 是WorkDoneHandler 当然也可以是其它匹配的方法。而Working()方法根本不需要知道自己最后执行的是哪个Handler。<br/> 二、 接口回调<br/> 通常情况下，我们创建一个对象，并马上直接去使用它的方法。然而，在有些情况下，希望能在某个场景出现后或条件满足时才调用此对象的方法。回调就可以解决这个“延迟调用对象方法”的问题。这个被调用方法的对象称为回调对象。<br/> 实现回调的原理简介如下:<br/> 首先创建一个回调对象，然后再创建一个控制器对象，将回调对象需要被调用的方法告诉控制器对象。控制器对象负责检查某个场景是否出现或某个条件是否满足。当此场景出现或此条件满足时，自动调用回调对象的方法。</p>\n<p>以下为C#实现回调的一个小例子：<br/> using System;<br/> using System.Collections.Generic;<br/> using System.Text;<br/> namespace ConsoleApplication1<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //创建一个控制器对象，将提供给它的回调对象传入<br/> Controller obj = new Controller(new CallBack());<br/> //启动<br/> obj.Star();<br/> }<br/> }<br/> public interface IBack<br/> {<!-- --><br/> void run();<br/> }<br/> public class CallBack : IBack<br/> {<!-- --><br/> public void run()<br/> {<!-- --><br/> //为了简洁这里只是显示下时间<br/> System.Console.WriteLine(DateTime.Now);<br/> }<br/> }<br/> public class Controller<br/> {<!-- --><br/> public IBack CallBackObj = null; //这里引用回调对象<br/> public Controller(IBack obj)<br/> {<!-- --><br/> this.CallBackObj = obj;<br/> }<br/> public void Star()<br/> {<!-- --><br/> Console.WriteLine(“敲键盘任意键就显示当前的时间，直到按ESC退出…”);<br/> while (Console.ReadKey(true).Key != ConsoleKey.Escape)<br/> {<!-- --><br/> CallBackObj.run();<br/> }<br/> }<br/> }<br/> }<br/> 可以看到，当示例程序运行时，何时调用CallBack对象的run()方法是由用户决定的，用户每敲一个键，控制器对象就调用一次CallBack的run()方法。这个示例中实现回凋的关键在于IBack接口的引入。</p>\n<pre><code> 如果不用IBack接口，而直接使用 CallBack对象，一样可以实现同样的效果，如下： \n   public class Controller \n { \n     public CallBack CallBackObj = null;   //回调对象方法的引用 \n     public Controller(CallBack obj) \n     { \n         this.CallBackObj = obj; \n     } \n     public void Star() \n     { \n         Console.WriteLine(\"敲键盘任意键就显示当前的时间，直到按ESC退出....\"); \n         while (Console.ReadKey(true).Key != ConsoleKey.Escape) \n         { \n             CallBackObj.run(); \n         } \n     } \n } \n</code></pre>\n<p>但仔细思考，这样做的结果就使Controller类与CallBack对象绑定在一起，万一如果需要调用其他类型的对象，则必须修改Controller类的代码。<br/> 如果Controller类接收的是一个抽象的接口变量Iback，则任何实现了该接口的对象都可以被Controller类对象所回调，Controller类的代码就再不用被修改，保证了代码对环境的适应性，无疑是一个很好的解决方案。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-01 10:41:41", "summary": "回调浅析委托、接口回调说到回调，通常情况下，指的是某个委托或者接口回调。现将从网上各位前辈那里学得的一些经验加以整理，形成一个稍全面一些的文章，希望对大家有所帮助！一、委托先看一段代码：定义委托首先给"}