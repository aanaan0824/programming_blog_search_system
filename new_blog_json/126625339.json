{"blogid": "126625339", "writerAge": "码龄3年", "writerBlogNum": "54", "writerCollect": "190", "writerComment": "182", "writerFan": "89", "writerGrade": "4级", "writerIntegral": "958", "writerName": "叶子yes", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126625339.jpg", "writerRankTotal": "19487", "writerRankWeekly": "279", "writerThumb": "177", "writerVisitNum": "6873", "blog_read_count": "365", "blog_time": "已于 2022-09-01 10:34:35 修改", "blog_title": "猿创征文 | H5 API之web存储、拖拽事件以及跨文档通信", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81web%E5%AD%98%E5%82%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81web%E5%AD%98%E5%82%A8\">一、web存储</a></p>\n<p id=\"1%E3%80%81cookie-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81cookie\">1、cookie</a></p>\n<p id=\"cookie%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#cookie%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\">cookie的特点</a></p>\n<p id=\"set(key%2C%20value%2C%20attributes)%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#set%28key%2C%20value%2C%20attributes%29%E6%96%B9%E6%B3%95\">set(key, value, attributes)方法</a></p>\n<p id=\"get(key)%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#get%28key%29%E6%96%B9%E6%B3%95\">get(key)方法</a></p>\n<p id=\"remove(key%2C%20attributes)%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#remove%28key%2C%20attributes%29%E6%96%B9%E6%B3%95\">remove(key, attributes)方法</a></p>\n<p id=\"2%E3%80%81%E4%BC%9A%E8%AF%9D%E5%AD%98%E5%82%A8sessionStorage-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E4%BC%9A%E8%AF%9D%E5%AD%98%E5%82%A8sessionStorage\">2、会话存储sessionStorage</a></p>\n<p id=\"sessionStorage%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#sessionStorage%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\">sessionStorage的特点</a></p>\n<p id=\"setItem(key%2C%20value)%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#setItem%28key%2C%20value%29%E6%96%B9%E6%B3%95\">setItem(key, value)方法</a></p>\n<p id=\"getItem(key)%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#getItem%28key%29%E6%96%B9%E6%B3%95\">getItem(key)方法</a></p>\n<p id=\"removeItem(key)%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#removeItem%28key%29%E6%96%B9%E6%B3%95\">removeItem(key)方法</a></p>\n<p id=\"clear()%E6%96%B9%E6%B3%95%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#clear%28%29%E6%96%B9%E6%B3%95%C2%A0\">clear()方法 </a></p>\n<p id=\"%C2%A03%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8localStorage-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8localStorage\"> 3、本地存储localStorage</a></p>\n<p id=\"localStorage%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#localStorage%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\">localStorage的特点</a></p>\n<p id=\"localStorage%E4%B8%8EsessionStorage%E5%8C%BA%E5%88%AB%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#localStorage%E4%B8%8EsessionStorage%E5%8C%BA%E5%88%AB%EF%BC%9A\">localStorage与sessionStorage区别</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6\">二、拖拽事件</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%C2%A0\">三、跨文档通信 </a></p>\n<p id=\"1%E3%80%81%E4%BD%BF%E7%94%A8location%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E4%BD%BF%E7%94%A8location%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1\">1、使用location对象实现跨文档通信</a></p>\n<p id=\"2%E3%80%81%E4%BD%BF%E7%94%A8H5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E4%BD%BF%E7%94%A8H5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%C2%A0\">2、使用H5提供的方法实现跨文档通信 </a></p>\n<p id=\"%E9%80%9A%E8%BF%87window.open()%E6%96%B9%E6%B3%95%E6%89%93%E5%BC%80B%E9%A1%B5%E9%9D%A2-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%80%9A%E8%BF%87window.open%28%29%E6%96%B9%E6%B3%95%E6%89%93%E5%BC%80B%E9%A1%B5%E9%9D%A2\">通过window.open()方法打开B页面</a></p>\n<p id=\"%E9%80%9A%E8%BF%87%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%80%9A%E8%BF%87%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6\">通过内联框架</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81web%E5%AD%98%E5%82%A8\">一、web存储</h1>\n<p>web存储分为cookie和WebStorage，WebStorage又分为sessionStorage和localStorage。</p>\n<h2 id=\"1%E3%80%81cookie\">1、cookie</h2>\n<p>cookie存储在浏览器中，每次浏览器向服务器发送请求都需要携带cookie。</p>\n<h3 id=\"cookie%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\"><strong>cookie的特点：</strong></h3>\n<blockquote>\n<p>1、cookie产生于服务器端，保存在客户端</p>\n<p>2、同一服务器的cookie是共享的，不同服务器的cookie不共享</p>\n<p>3、数据传输大小限制4kb</p>\n</blockquote>\n<p>我们需要操作cookie，首先要先引入js-cookie库，js-cookie库我们可以到<a class=\"link-info\" href=\"https://www.bootcdn.cn/\" title=\"BootCDN\">BootCDN</a>上找。</p>\n<p><img alt=\"\" height=\"394\" src=\"..\\..\\static\\image\\654d12d6ba8649698e60c80e301dd36d.png\" width=\"1200\"/></p>\n<p>我们可以打印cookie看一下cookie是什么： </p>\n<p><img alt=\"\" height=\"421\" src=\"..\\..\\static\\image\\b3ff176e15da436bb3fdc76589398e5c.png\" width=\"1011\"/>  </p>\n<p>可以看出Cookies 是一个对象，里面有很多方法，但我们只需要重点关注其原型上的三个方法：get()、remove()、set()</p>\n<p><img alt=\"\" height=\"343\" src=\"..\\..\\static\\image\\7d91d98b8eab464a83f00eb893f6b482.png\" width=\"1000\"/></p>\n<p></p>\n<h3 id=\"set(key%2C%20value%2C%20attributes)%E6%96%B9%E6%B3%95\"><strong>set(key, value, attributes)方法</strong></h3>\n<p>用来设置cookie，它有三个参数：</p>\n<p>key：键名</p>\n<p>value：键值</p>\n<p>attributes：设置cookie的属性</p>\n<blockquote>\n<p><strong>cookie的属性有：</strong></p>\n<p>expires：设置cookie过期时间</p>\n<p>path：表示cookie可见路径</p>\n<p>domain：用来指定cookie所在的域名</p>\n<p>secure：表示cookie传输是否需要安全协议（HTTPS），取值为true和false，不需要我们指定值，如果通信是HTTPS协议，该开关自动打开</p>\n<p>max-age：用来指定cookie有效期，优先级高于expires</p>\n<p>HttpOnly：用来设置cookie不能被JavaScript读取</p>\n</blockquote>\n<h3 id=\"get(key)%E6%96%B9%E6%B3%95\"><strong>get(key)方法</strong></h3>\n<p>用来获取cookie</p>\n<h3 id=\"remove(key%2C%20attributes)%E6%96%B9%E6%B3%95\"><strong>remove(key, attributes)方法</strong></h3>\n<p>用来移除cookie</p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n    //设置cookie\n    //expires: 7 表示7天过期\n    Cookies.set('name', 'yezi', {expires: 7})\n    Cookies.set('age', 18, {expires: 7})\n    Cookies.set('gender', 'female', {expires: 7})\n\n    //获取cookie\n    console.log(Cookies.get('name')); //yezi\n\n    //移除cookie\n    Cookies.remove('gender')\n&lt;/script&gt;</code></pre>\n<p>在浏览器中打开F12，在存储中可以查看cookie </p>\n<p><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\3291ce51d3a24c4eaea0d683e8b6ae45.png\" width=\"1000\"/></p>\n<h2 id=\"2%E3%80%81%E4%BC%9A%E8%AF%9D%E5%AD%98%E5%82%A8sessionStorage\">2、会话存储sessionStorage</h2>\n<h3 id=\"sessionStorage%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\">sessionStorage的特点：</h3>\n<blockquote>\n<p>1、会话存储sessionStorage针对于浏览器选项卡存储，只要选项卡关闭或者是浏览器关闭，会话就会失效</p>\n<p>2、传输数据可以达到5MB，甚至更大</p>\n</blockquote>\n<p>打印一下sessionStorage：</p>\n<pre><code class=\"language-javascript\">console.log(sessionStorage);</code></pre>\n<p><img alt=\"\" height=\"347\" src=\"..\\..\\static\\image\\cc1cfd83c1ed42c388e5914bd2206ea4.png\" width=\"783\"/></p>\n<h3 id=\"setItem(key%2C%20value)%E6%96%B9%E6%B3%95\">setItem(key, value)方法</h3>\n<p>设置会话存储</p>\n<h3 id=\"getItem(key)%E6%96%B9%E6%B3%95\">getItem(key)方法</h3>\n<p>获取会话存储</p>\n<h3 id=\"removeItem(key)%E6%96%B9%E6%B3%95\">removeItem(key)方法</h3>\n<p>清除key对应的会话存储</p>\n<h3 id=\"clear()%E6%96%B9%E6%B3%95%C2%A0\">clear()方法 </h3>\n<p>清除所有的会话存储</p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n    //设置会话存储\n    sessionStorage.setItem('name', 'yezi')\n    sessionStorage.setItem('age', 18)\n    sessionStorage.setItem('gender', 'female')\n\n    //获取会话存储\n    console.log(sessionStorage.getItem('age')); //18\n\n    //删除name对应的会话存储\n    sessionStorage.removeItem('name')\n\n    //删除所有的会话存储\n    // sessionStorage.clear()\n&lt;/script&gt;</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"278\" src=\"..\\..\\static\\image\\5a4a3b9ef40d4a878a0c41db25d326f6.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A03%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8localStorage\"> 3、本地存储localStorage</h2>\n<h3 id=\"localStorage%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\">localStorage的特点：</h3>\n<blockquote>\n<p>1、将数据存到本地磁盘中，即使选项卡关闭或者浏览器关闭数据依旧存在，除非手动删除 否则数据一直存在本地磁盘中</p>\n<p>2、传输数据可以达到5MB甚至更大</p>\n</blockquote>\n<p>打印一下localStorage：</p>\n<pre><code class=\"language-javascript\">console.log(localStorage);</code></pre>\n<p><img alt=\"\" height=\"355\" src=\"..\\..\\static\\image\\1a8391039c7044cc97ecf64325f965e9.png\" width=\"766\"/></p>\n<p> localStorage拥有和sessionStorage一样的方法：</p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n    //设置本地存储\n    localStorage.setItem('name', 'yezi')\n    localStorage.setItem('age', 18)\n    localStorage.setItem('gender', 'female')\n\n    //获取本地存储\n    console.log(localStorage.getItem('age'));\n\n    //删除name对应的本地存储\n    localStorage.removeItem('name')\n\n    //删除所有的本地存储\n    // localStorage.clear()\n&lt;/script&gt;</code></pre>\n<p><br/><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\d636ee2502c047cd800bfe1cfaa01e36.png\" width=\"1200\"/></p>\n<h3 id=\"localStorage%E4%B8%8EsessionStorage%E5%8C%BA%E5%88%AB%EF%BC%9A\">localStorage与sessionStorage区别：</h3>\n<blockquote>\n<p>1、不同浏览器无法共享localStorage和sessionStorage</p>\n<p>2、相同浏览器且同一域名和端口号下的不同页面可以共享localStorage</p>\n<p>3、相同浏览器的不同页面不能共享sessionStorage</p>\n</blockquote>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6\">二、拖拽事件</h1>\n<p>在H5中实现了拖拽技术，允许用户在网页内部拖拽以及浏览器与其他应用程序之间的拖拽，通过拖拽可以传递数据。</p>\n<blockquote>\n<p><strong>拖放元素</strong>：设置当前元素可拖放 draggable='true'<br/><strong>放置元素</strong>：默认是不可以放置的，我们需要取消默认行为 event.preventDefault() </p>\n<p></p>\n<p><strong>拖动事件</strong>：dragstart(开始拖放)、drag(正在拖放)、dragend(拖放结束)<br/><strong>放置事件</strong>：dragenter(进入放置元素)、dragover(在放置元素内移动)、drop(放置到放置元素中)</p>\n<p><br/><strong>拖拽事件流</strong>：<br/> 当拖动一个元素放置到目标元素上的时候将会按照如下顺序依次触发<br/><span style=\"color:#4da8ee;\"><strong>dragstart -&gt; drag -&gt; dragenter -&gt; dragover -&gt; drop -&gt; dragend</strong></span><br/><br/> 在拖拽事件中，我们可以通过DataTransfer来实现数据交互，通过event.dataTransfer来获取DataTransfer实例</p>\n<p>方法：</p>\n<p><strong>传输数据</strong>：event.dataTransfer.setData(key, value)  <span style=\"color:#4da8ee;\">dragstart中使用</span></p>\n<p><strong>获取数据</strong>：event.dataTransfer.getData(key)            <span style=\"color:#4da8ee;\">drop中使用</span></p>\n<p><strong>清除数据</strong>：event.dataTransfer.clearData(key)         <span style=\"color:#4da8ee;\">如果不传参，则删除所有</span></p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n\t&lt;meta charset=\"UTF-8\"&gt;\n\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\t&lt;title&gt;Document&lt;/title&gt;\n\t&lt;style&gt;\n\t\t.parent {\n\t\t\theight: 200px;\n\t\t\tborder: 2px solid black;\n\t\t}\n\n\t\t.child {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: pink;\n\t\t\tcolor: white;\n\t\t\tfloat: left;\n\t\t\tmargin: 10px 0 0 10px;\n\t\t\ttext-align: center;\n\t\t\tline-height: 100px;\n\t\t}\n\n\t\tbody {\n\t\t\theight: 400px;\n\t\t}\n\t&lt;/style&gt;\n\t&lt;script&gt;\n\t\twindow.onload = function () {\n\t\t\t// 获取parent和child\n\t\t\tvar parent = document.querySelector('.parent');\n\t\t\tvar childs = document.querySelectorAll('.child');\n\t\t\t// 将类数组对象childs转成数组\n\t\t\tchilds = Array.from(childs);\n\n\t\t\t//给每一个拖动元素绑定拖拽事件\n\t\t\tchilds.forEach(function (item) {\n\t\t\t\t// 开始拖动\n\t\t\t\titem.ondragstart = function (event) {\n\t\t\t\t\tconsole.log('ondragstart开始拖动了');\n\t\t\t\t\t// console.log(event);\n\t\t\t\t\t// 将拖动元素的id传出去\n\t\t\t\t\t// dataTransfer.setData 传输数据\n\t\t\t\t\tevent.dataTransfer.setData('id', item.id);\n\t\t\t\t}\n\t\t\t\t// 正在拖动\n\t\t\t\titem.ondrag = function () {\n\t\t\t\t\tconsole.log('ondrap正在拖动');\n\t\t\t\t}\n\t\t\t\t// 拖动结束\n\t\t\t\titem.ondragend = function () {\n\t\t\t\t\tconsole.log('ondragend拖动结束');\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// 给放置元素绑定放置事件\n\t\t\t// 进入到放置元素\n\t\t\tparent.ondragenter = function () {\n\t\t\t\tconsole.log('ondragenter进入到放置元素');\n\t\t\t}\n\t\t\t// 在放置元素内移动\n\t\t\tparent.ondragover = function () {\n\t\t\t\tconsole.log('ondragover正在放置元素内移动');\n\t\t\t\t// 将放置元素设置为可放置\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t\t// 将拖动元素放置到放置元素\n\t\t\tparent.ondrop = function (event) {\n\t\t\t\tconsole.log('ondrop放置');\n\t\t\t\t//获取拖动元素传输的数据getData(key)\n\t\t\t\t// console.log(event.dataTransfer.getData('id');\n\t\t\t\tvar id = event.dataTransfer.getData('id');\n\t\t\t\tthis.appendChild(document.querySelector('#' + id))\n\t\t\t\t// 阻止事件冒泡,否则拖拽的时候会冒泡到body,就无法将拖拽元素放到放置元素parent里面\n\t\t\t\tevent.stopPropagation()\n\t\t\t}\n\n\t\t\t// 将拖动元素放置到body\n\t\t\tdocument.body.ondragover = function () {\n\t\t\t\tconsole.log('ondragover正在放置元素内移动');\n\t\t\t\t// 将放置元素设置为可放置\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t\t// 将拖动元素放置到放置元素\n\t\t\tdocument.body.ondrop = function (event) {\n\t\t\t\tconsole.log('ondrop放置');\n\t\t\t\t//获取拖动元素传输得数据getData(key)\n\t\t\t\t// console.log(event.dataTransfer.getData('id'));\n\t\t\t\tvar id = event.dataTransfer.getData('id');\n\t\t\t\tthis.appendChild(document.querySelector('#' + id))\n\t\t\t}\n\t\t}\n\t&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\t&lt;!-- 放置元素:parent  放置事件:dragenter dragover drop--&gt;\n\t&lt;!-- 拖动元素:child   拖动事件：dragstart drag dragend--&gt;\n\t&lt;div class=\"parent\"&gt;&lt;/div&gt;\n\t&lt;!-- draggable设置当前元素是否可拖拽,可以不写值，默认为true --&gt;\n\t&lt;div class=\"child\" id=\"one\" draggable=\"true\"&gt;one&lt;/div&gt;\n\t&lt;div class=\"child\" id=\"two\" draggable=\"true\"&gt;two&lt;/div&gt;\n\t&lt;div class=\"child\" id=\"three\" draggable=\"true\"&gt;three&lt;/div&gt;\n\t&lt;div class=\"child\" id=\"four\" draggable=\"true\"&gt;four&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/32ff5d760acd4cf19813c57dde85ab75.gif\"/></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%C2%A0\">三、跨文档通信 </h1>\n<h2 id=\"1%E3%80%81%E4%BD%BF%E7%94%A8location%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1\">1、使用location对象实现跨文档通信</h2>\n<p>location对象是BOM对象，提供了与当前窗口中加载的文档有关的信息。而location.search 返回URL的查询字符串。</p>\n<p>因此我们可以在A页面地址栏拼接参数，然后在B页面通过location.search获取到A页面传递过来的数据，但是我们通过location.search得到查询字符串后，要怎么转成对象呢？</p>\n<p>第一种方法：可以通过qs序列化工具，使用Qs.parse() 可以将查询字符串转换成js对象</p>\n<p>第二种方法：</p>\n<pre><code class=\"language-javascript\">// slice(1)去掉？ split('&amp;')转成数组\nvar str = location.search.slice(1).split('&amp;').map(function(item){\n  return item.split('=')\n}) //此时str变成了一个二维数组[[name,yezi],[age,18]]\nvar obj = {}\nstr.forEach(function(item){\n  // console.log(item);\n  obj[item[0]] = item[1]\n})\nconsole.log(obj);</code></pre>\n<p>例子展示：</p>\n<p>A页面.html</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- 传递数据name=yezi 和 age=18 --&gt;\n  &lt;a href=\"./B页面.html?name=yezi&amp;age=18\"&gt;跳转到B页面&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>B页面.html</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;!-- 引入qs --&gt;\n  &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/qs/6.11.0/qs.min.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // console.log(location);\n    // console.log(location.search); //?name=yezi&amp;age=18\n    \n    //第一种方法，使用qs工具\n    //Qs.parse() 把查询字符串转换成js对象\n    //console.log(Qs.parse(str));\n\n    // 第二种方法\n    // slice(1)去掉？ split('&amp;')转成数组\n    var str = location.search.slice(1).split('&amp;').map(function(item){\n      return item.split('=')\n    }) //此时str变成了一个二维数组[[name,yezi],[age,18]]\n    var obj = {}\n    str.forEach(function(item){\n      // console.log(item);\n      obj[item[0]] = item[1]\n    })\n    console.log(obj);\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  我是B页面\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/a988cb470f714d7e879af93c513ab538.gif\"/></p>\n<h2 id=\"2%E3%80%81%E4%BD%BF%E7%94%A8H5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1%C2%A0\">2、使用H5提供的方法实现跨文档通信 </h2>\n<p>H5提供了网页文档之间互相接收与发送消息的功能。当在A页面中通过window.open方法打开B页面，或者在A页面中通过iframe嵌套B页面，我们想让A中的数据传递到B中就可以使用跨文档消息传输。</p>\n<h3 id=\"%E9%80%9A%E8%BF%87window.open()%E6%96%B9%E6%B3%95%E6%89%93%E5%BC%80B%E9%A1%B5%E9%9D%A2\"><strong>通过window.open()方法打开B页面</strong></h3>\n<p>A页面.html</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;script&gt;\n    window.onload = function(){\n      var btn1 = document.querySelector('button')\n      var btn2 = document.getElementsByTagName('button')[1]\n      var win\n      btn1.onclick = function(){\n        //打开B页面\n        win = window.open('./B页面.html')\n      }\n      btn2.onclick = function(){\n        //发送消息给B页面\n        // win.postMessage('hello','http://127.0.0.1:5500')\n        // * 表示往任何服务器发送\n        win.postMessage('hello','*')\n      }\n    }\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;button&gt;打开B1页面&lt;/button&gt;\n  &lt;button&gt;发送数据&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>B页面.html</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n\t&lt;meta charset=\"UTF-8\"&gt;\n\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\t&lt;title&gt;Document&lt;/title&gt;\n\t&lt;style&gt;\n\t\tbody{\n\t\t\theight: 400px;\n\t\t\tbackground-color: pink;\n\t\t}\n\t&lt;/style&gt;\n\t&lt;script&gt;\n\t\twindow.onmessage=function(e){\n      // 接收到的数据\n\t\t\tconsole.log(e.data);\n      // 数据的来源\n\t\t\tconsole.log(e.origin);\n\t\t}\n\t&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t我是B页面\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>注意：要使用本地服务器打开</p>\n<p><img alt=\"\" height=\"248\" src=\"..\\..\\static\\image\\6a650100b6a84fd682b683ae7c0a5255.png\" width=\"507\"/></p>\n<p>先打开B页面，再回到A页面点击发送数据，此时B页面就能收到A传输过来的数据了。 </p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/43ae38399de2428780aa3f1b2205dc5d.gif\"/></p>\n<h3 id=\"%E9%80%9A%E8%BF%87%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6\">通过内联框架</h3>\n<p>A页面.html</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;script&gt;\n    window.onload = function(){\n      var btn1=document.getElementsByTagName('button')[0];\n\t\t\tvar btn2=document.getElementsByTagName('button')[1];\n      var win\n      btn1.onclick = function(){\n        //获取内联B窗口\n        win = document.querySelector('iframe').contentWindow\n      }\n      btn2.onclick = function(){\n        // win.postMessage('hello','http://127.0.0.1:5500')\n        // * 往任何服务器发送\n        win.postMessage('hello','*')\n      }\n    }\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;button&gt;获取内联B窗口&lt;/button&gt;\n  &lt;button&gt;发送数据&lt;/button&gt;\n  &lt;iframe src=\"./B页面.html\" frameborder=\"0\"&gt;&lt;/iframe&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p> B页面.html和前面的一样。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/b78ed23af0d24bddabb391976f0eaaf8.gif\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-09-01 10:34:35", "summary": "目录一、存储、的特点方法方法方法、会话存储的特点方法方法方法方法、本地存储的特点与区别二、拖拽事件三、跨文档通信、使用对象实现跨文档通信、使用提供的方法实现跨文档通信通过方法打开页面通过内联框架一、存"}