{"blogid": "126113071", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "4573", "writerComment": "4379", "writerFan": "6331", "writerGrade": "7级", "writerIntegral": "13374", "writerName": "@每天都要敲代码", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126113071.jpg", "writerRankTotal": "799", "writerRankWeekly": "90", "writerThumb": "4854", "writerVisitNum": "80937", "blog_read_count": "237", "blog_time": "已于 2022-08-08 14:33:00 修改", "blog_title": "深入理解Java IO流（第二篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p> ✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href=\"https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421\" title=\"@每天都要敲代码的个人主页\">@每天都要敲代码的个人主页</a></p>\n<p> 🔥系列专栏：<a href=\"https://blog.csdn.net/m0_61933976/category_11820121.html?spm=1001.2014.3001.5482\" title=\"JavaSE从入门到精通\">JavaSE从入门到精通</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%F0%9F%A5%85%E7%BC%93%E5%86%B2%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E7%BC%93%E5%86%B2%E6%B5%81\">🥅缓冲流</a></p>\n<p id=\"1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81BufferedReader-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81BufferedReader\">1.字符输入流BufferedReader</a></p>\n<p id=\"2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81BufferedWriter-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81BufferedWriter\">2.字符输出流BufferedWriter</a></p>\n<p id=\"%F0%9F%A5%85%E8%BD%AC%E6%8D%A2%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E8%BD%AC%E6%8D%A2%E6%B5%81\">🥅转换流</a></p>\n<p id=\"1.OutputStreamWriter-toc\" style=\"margin-left:80px;\"><a href=\"#1.OutputStreamWriter\">1.OutputStreamWriter</a></p>\n<p id=\"2.InputStreamReader-toc\" style=\"margin-left:80px;\"><a href=\"#2.InputStreamReader\">2.InputStreamReader</a></p>\n<p id=\"%F0%9F%A5%85%E6%95%B0%E6%8D%AE%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E6%95%B0%E6%8D%AE%E6%B5%81\">🥅数据流</a></p>\n<p id=\"1.DataOutputStream-toc\" style=\"margin-left:80px;\"><a href=\"#1.DataOutputStream\">1.DataOutputStream</a></p>\n<p id=\"2.DataInputStream-toc\" style=\"margin-left:80px;\"><a href=\"#2.DataInputStream\">2.DataInputStream</a></p>\n<p id=\"%F0%9F%A5%85%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81\">🥅标准输出流</a></p>\n<p id=\"1.PrintStream-toc\" style=\"margin-left:80px;\"><a href=\"#1.PrintStream\">1.PrintStream</a></p>\n<p id=\"2.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB\">2.日志工具类</a></p>\n<p id=\"%F0%9F%A5%85File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3\">🥅File类的理解</a></p>\n<p id=\"1.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%951-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%951\">1.常用方法1</a></p>\n<p id=\"2.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952\">2.常用方法2</a></p>\n<p id=\"3.listFiles%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#3.listFiles%E6%96%B9%E6%B3%95\">3.listFiles方法</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%F0%9F%A5%85%E7%BC%93%E5%86%B2%E6%B5%81\">🥅缓冲流</h1>\n<blockquote>\n<p>（1）带有缓冲区的字符输入流；使用这个流的时候<span style=\"color:#fe2c24;\">不需要自定义char数组</span>，或者说不需要自定义byte数组；自带缓冲！</p>\n<p>（2）读取数据时，<span style=\"color:#fe2c24;\">可以一次性读取一行</span></p>\n<p>（3）这里只讲解字符缓冲流： <strong>java.io.BufferedReader 和 java.io.BufferedWriter</strong>；字节缓冲流使用方法是一样的</p>\n<p>（4）<strong>BufferedReader和BufferedWriter都是包装流！</strong></p>\n</blockquote>\n<h3 id=\"1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81BufferedReader\"><strong>1.字符输入流</strong><strong>BufferedReader</strong></h3>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\n\npublic class BufferedReaderTest01 {\n    public static void main(String[] args) throws Exception {\n        FileReader reader = new FileReader(\"file\");\n        // 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。\n        // 外部负责包装的这个流，叫做：包装流或者叫做：处理流。\n        // FileReader就是一个节点流。BufferedReader就是包装流/处理流。\n        BufferedReader br = new BufferedReader(reader); // 只能传字符流\n\n        // 优点：一次能读一行；但不带换行符！\n        String s = null;\n        while((s = br.readLine()) != null){ // br.readLine()返回的是一个字符串\n            System.out.println(s);\n        }\n\n        // 关闭流,只需要关闭最外层流就行，里面的节点流会自动关闭。\n        br.close();\n\n    }\n}\n</code></pre>\n<h3 id=\"2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81BufferedWriter\"><strong>2.字符输出流</strong><strong>BufferedWriter</strong></h3>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.*;\n\npublic class BufferedWriterTest01 {\n    public static void main(String[] args) throws IOException {\n        // 创建带有缓冲区的字符输出流\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\"file\"));\n\n        // 开始写\n        writer.write(\"hello world!\");\n        writer.write(\"\\n\");\n        writer.write(\"hello kitty!\");\n\n        // 刷新\n        writer.flush();\n        // 关闭最外层\n        writer.close();\n    }\n}\n</code></pre>\n<p></p>\n<h1></h1>\n<h1 id=\"%F0%9F%A5%85%E8%BD%AC%E6%8D%A2%E6%B5%81\">🥅转换流</h1>\n<h3 id=\"1.OutputStreamWriter\">1.OutputStreamWriter</h3>\n<blockquote>\n<p>BufferedWriter：带有缓冲的字符输出流。</p>\n<p>OutputStreamWriter：转换流</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.*;\n\npublic class BufferedWriterTest01 {\n    public static void main(String[] args) throws IOException {\n        // 创建带有缓冲区的字符输出流\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\"file\"));\n\n        // 如果想要使用字节输出流，还是需要OutputStreamWriter进行流的转换\n        // 如果使用的是字节流\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"file\"));\n        BufferedWriter writer1 = new BufferedWriter(osw);\n        \n        // 合并在一起\n        BufferedWriter writer1 = new BufferedWriter(new OutputStreamWriter\n        (new FileOutputStream(\"file\")));\n\n        // 开始写\n        writer.write(\"hello world!\");\n        writer.write(\"\\n\");\n        writer.write(\"hello kitty!\");\n\n        // 刷新\n        writer.flush();\n        // 关闭最外层\n        writer.close();\n    }\n}\n</code></pre>\n<h3></h3>\n<h3 id=\"2.InputStreamReader\">2.InputStreamReader</h3>\n<blockquote>\n<p>BufferedReader(reader)，里面只能传字符流；那如果是字节流怎么办呢？</p> 需要使用转换流：InputStreamReader，把将字节流转换成字符流\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.*;\n\npublic class BufferedReaderTest02 {\n    public static void main(String[] args) {\n\n        FileInputStream fis = null;\n        try {\n            // 字节流\n            fis = new FileInputStream(\"file\");\n            // 通过转换流转换（InputStreamReader将字节流转换成字符流）\n            // fis是节点流。reader是包装流。\n            InputStreamReader reader = new InputStreamReader(fis);\n            // 把转换成字符流的字节流，传过来\n            // reader是节点流。br是包装流。\n            BufferedReader br = new BufferedReader(reader);\n\n            // 上面进行合并\n            BufferedReader br1 = new BufferedReader(new InputStreamReader(new FileInputStream(\"file\")));\n\n            // 进行打印\n            String s = null;\n            while((s = br1.readLine()) != null){\n                System.out.println(s);\n            }\n\n            // 关闭\n            br.close(); // 关闭最外层\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<h1></h1>\n<h1 id=\"%F0%9F%A5%85%E6%95%B0%E6%8D%AE%E6%B5%81\">🥅数据流</h1>\n<h3 id=\"1.DataOutputStream\"><strong>1.DataOutputStream</strong></h3>\n<blockquote>\n<p>（1）java.io.DataOutputStream：数据专属的流；也是一个包装流！<br/> （2）这个流可以<span style=\"color:#fe2c24;\">将数据连同数据的类型一并写入文件</span>。<br/> （3）注意：这个文件不是普通文本文档。（这个文件使用记事本打不开）</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\n\npublic class DataOutputStreamTest01 {\n    public static void main(String[] args) throws Exception{\n        // 创建数据专属的字节输出流（写）\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"file\")); //生成的这个文件，记事本打不开\n        // 写数据\n        byte b = 100;\n        short s = 200;\n        int i = 300;\n        long l = 400L;\n        float f = 3.0F;\n        double d = 3.14;\n        boolean sex = false;\n        char c = 'a';\n        // 写；把数据以及数据的类型一并写入到文件当中\n       dos.writeByte(b);\n       dos.writeShort(s);\n       dos.writeInt(i);\n       dos.writeLong(l);\n       dos.writeFloat(f);\n       dos.writeDouble(d);\n       dos.writeBoolean(sex);\n       dos.writeChar(c);\n\n        // 刷新\n        dos.flush();\n        \n        // 关闭最外层\n        dos.close();\n    }\n}\n</code></pre>\n<h3></h3>\n<h3 id=\"2.DataInputStream\"><strong>2.DataInputStream</strong></h3>\n<blockquote>\n<p>（1）DataInputStream：数据字节输入流。<br/> （2）DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序；读的顺序需要和写的顺序一致。才可以正常取出数据<strong>。</strong></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\n\npublic class DataInputStreamTest01 {\n    public static void main(String[] args) throws Exception {\n        // 创建数据专属的字节输入流（读）\n        DataInputStream dis = new DataInputStream(new FileInputStream(\"file\"));\n        // 开始读\n        byte b = dis.readByte();\n        short s = dis.readShort();\n        int i = dis.readInt();\n        long l = dis.readLong();\n        float f = dis.readFloat();\n        double d = dis.readDouble();\n        boolean sex = dis.readBoolean();\n        char c = dis.readChar();\n        // 打印\n\n        System.out.println(b);\n        System.out.println(s);\n        System.out.println(i);\n        System.out.println(l);\n        System.out.println(f);\n        System.out.println(d);\n        System.out.println(sex);\n        System.out.println(c);\n\n        // 关闭流\n        dis.close();\n    }\n}\n</code></pre>\n<h1 id=\"%C2%A0\"></h1>\n<h1></h1>\n<h1 id=\"%F0%9F%A5%85%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81\">🥅标准输出流</h1>\n<h3 id=\"1.PrintStream\">1.PrintStream</h3>\n<blockquote>\n<p>（1）jva.io.PrintStream：标准的字节输出流。默认输出到控制台。<br/> （2）标准输出流<strong>不需要手动close()关闭</strong>。</p>\n<p>（3）可以<span style=\"color:#fe2c24;\">通过System.setOut()方法改变输出流的方向</span></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\n\npublic class PrintStreamTest {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"hello world\");\n        // 实际上上述代码可以拆分成\n        PrintStream ps = System.out;\n        ps.println(\"hello world\");\n\n        // 可以改变标准输出流的输出方向；\n        // 例如：标准输出流不在指向控制台，指向log文件\n        PrintStream printStream = new PrintStream(new FileOutputStream(\"log\"));\n        // 修改输出方向\n        System.setOut(printStream);\n\n        // 输出\n        System.out.println(\"Hello World\"); //不会再输出到控制台，而是到log文件\n\n    }\n}\n</code></pre>\n<h3 id=\"2.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB\"><strong>2.日志工具类</strong></h3>\n<blockquote>\n<p>那么标准输出流PrintStream有什么用呢？我们不妨写一个简单的日志工具类！</p>\n</blockquote>\n<p><strong>日志框架</strong></p>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n// 日志工具\npublic class Logger {\n    // 记录日志的方法\n   public static void log(String msg) {\n       try {\n           PrintStream out = new PrintStream(new FileOutputStream(\"log.txt\",true));\n           // 改变流的方向\n           System.setOut(out);\n           // 获取系统当前时间\n           Date nowDate = new Date();\n           // 格式类型转换\n           SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n           String myNowdate = sdf.format(nowDate);\n           // 打印\n           System.out.println(myNowdate+\":\"+msg);\n\n       } catch (FileNotFoundException e) {\n           e.printStackTrace();\n       }\n\n   }\n}\n</code></pre>\n<p><strong>日志测试</strong></p>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\npublic class LoggerTest {\n    public static void main(String[] args) {\n        // 测试日志工具类\n        Logger.log(\"调用了System类的gc()方法，建议启动垃圾回收\");\n        Logger.log(\"调用了UserService的doSome()方法\");\n        Logger.log(\"用户尝试进行登录，验证失败\");\n\n        // 在log.txt打印的结果\n       /* 2022-07-22 08:47:49 667:调用了System类的gc()方法，建议启动垃圾回收\n        2022-07-22 08:47:49 703:调用了UserService的doSome()方法\n        2022-07-22 08:47:49 714:用户尝试进行登录，验证失败*/\n    }\n}\n</code></pre>\n<p></p>\n<h1></h1>\n<h1 id=\"%F0%9F%A5%85File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3\">🥅File类的理解</h1>\n<blockquote>\n<p><strong>java.io.File</strong><br/>     1、File类和四大家族没有关系，所以File类不能完成文件的读和写。<br/>     2、File对象代表什么？<br/>         文件和目录路径名的抽象表示形式。<br/>         C:\\Drivers 这是一个File对象<br/>         C:\\Drivers\\Lan\\Realtek\\Readme.txt 也是File对象。<br/>         <span style=\"color:#fe2c24;\">一个File对象有可能对应的是目录，也可能是文件</span>；File只是一个路径名的抽象表示形式；<strong>不能通过File完成文件的读和写</strong></p>\n</blockquote>\n<h3 id=\"1.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%951\"><strong>1.常用方法1</strong></h3>\n<blockquote>\n<p></p>\n<p>（1）<span style=\"color:#fe2c24;\">exists()</span>方法：判断当前文件是否存在</p>\n<p>（2）<span style=\"color:#fe2c24;\">creatNewFile()</span>方法：以文件的形式创建出来</p>\n<p>（3）<span style=\"color:#fe2c24;\">mkdir()</span>方法：以目录的形式创建出来；<span style=\"color:#fe2c24;\">创建多重目录mkdirs()</span>方法</p>\n<p>（4）<strong>获取当前文件的父路径</strong>：</p>\n<p>        方法1： 使用<span style=\"color:#fe2c24;\">getParent()</span>，返回的是一个<span style=\"color:#fe2c24;\">String</span><br/>         方法2：使用<span style=\"color:#fe2c24;\">getParentFile()</span>，返回的是一个<span style=\"color:#fe2c24;\">File</span>；和上面效果是一样的</p>\n<p>（5）<span style=\"color:#fe2c24;\">getAbsolutePath()</span>方法：获取当前文件的绝对路径</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.File;\n\npublic class FileTest01 {\n    public static void main(String[] args) throws Exception {\n        // 创建File对象\n        File f1 = new File(\"D:\\\\file\");\n        // 1、判断当前文件是否存在；exists()方法\n        System.out.println(f1.exists()); // false\n\n        // 2、如果D:\\file不存在，则以文件的形式创建出来；createNewFile()方法\n        if (!f1.exists()) {\n            f1.createNewFile();\n        }\n\n        // 3、如果D:\\file不存在，则以目录的形式创建出来；mkdir()方法\n        if (!f1.exists()) {\n            f1.mkdir();\n        }\n\n        // 4、创建多重目录；mkdirs()方法\n        File f2 = new File(\"D:/a/b/c/d\");\n        if (!f2.exists()) {\n            f2.mkdirs();\n        }\n\n        // 5、获取当前文件的父路径\n        File f3 = new File(\"D:\\\\python学习\\\\PyCharm Community Edition 2021.2.2\");\n        // 第一种：使用getParent()，返回的是一个String\n        String parentPath = f3.getParent();\n        System.out.println(parentPath); // D:\\python学习\n        // 第二种：使用getParentFile()，返回的是一个File；效果是一样的\n        File parentFile = f3.getParentFile();\n        System.out.println(parentFile); // D:\\python学习\n\n        // 6、获取当前文件的绝对路径\n        File f4 = new File(\"file\");\n        System.out.println(f4.getAbsolutePath()); // C:\\Users\\86177\\IdeaProjects\\JavaSe1\\file\n\n    }\n}\n</code></pre>\n<h3></h3>\n<h3 id=\"2.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952\"><strong>2.常用方法2</strong></h3>\n<blockquote>\n<p>（1）<span style=\"color:#fe2c24;\">getName()</span>：获取当前文件的名字</p>\n<p>（2）<span style=\"color:#fe2c24;\">isDirectory()</span>：判断是否是一个目录</p>\n<p>（3）<span style=\"color:#fe2c24;\">isFile()</span>：判断是否是一个文件</p>\n<p>（4）<span style=\"color:#fe2c24;\">lastModified()</span>：获取文件最后一次修改时间；得到的是毫秒数，返回long型</p>\n<p>（5）<span style=\"color:#fe2c24;\">length()</span>：获取文件大小，结果是字节</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class FileTest02 {\n    public static void main(String[] args) {\n        File  f1 = new File(\"C:\\\\Java学习\\\\javaSE学习\\\\2.1JavaSE进阶笔记\\\\javase\\\\Copy02.java\");\n        // 1、获取文件名，getName()方法\n        System.out.println(\"文件名:\"+f1.getName()); // 文件名:Copy02.java\n\n        // 2、判断是否是一个目录，isDirectory()方法\n        System.out.println(f1.isDirectory()); // false\n\n        // 3、判断是否是一个文件，isFile()方法\n        System.out.println(f1.isFile()); // true\n\n        // 4、获取文件最后一次修改时间，lastModified()方法\n        // 得到的是毫秒数\n        long modifytTime = f1.lastModified();\n        // 将总毫秒数转换成日期\n        Date date = new Date(modifytTime);\n        // 格式化\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n        System.out.println(sdf.format(date)); //2020-03-11 14:35:46 154\n\n        // 5、获取文件大小，length()方法\n        System.out.println(f1.length()); //1490 字节\n        \n    }\n}\n</code></pre>\n<p></p>\n<h3 id=\"3.listFiles%E6%96%B9%E6%B3%95\"><strong>3.</strong>listFiles方法</h3>\n<blockquote>\n<p>File中的<span style=\"color:#fe2c24;\">listFiles方法</span>；<strong>获取当前目录下所有的子文件</strong>；<span style=\"color:#fe2c24;\"><strong>返回的是一个File[]数组</strong></span></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.File;\n\npublic class FileTest03 {\n    public static void main(String[] args) {\n        File f = new File(\"C:\\\\Java学习\\\\javaSE学习\\\\2.1JavaSE进阶笔记\\\\javase\\\\chapter15\\\\src\");\n        // 调用listFiles()方法，返回的是一个File[]数组\n        File[] files = f.listFiles();\n        // 用增强for循环打印\n        for(File file :files){\n            System.out.println(file.getAbsolutePath()); // 获取所有子目录的绝对路径\n            System.out.println(file.getName()); //获取所有子目录的文件名\n        }\n\n    }\n}\n</code></pre>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\"></h1>\n<h1>结束语</h1>\n<blockquote>\n<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！</p>\n<p> 💬刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站\">点击跳转刷题网站</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"511\" src=\"..\\..\\static\\image\\184068dc41e94efbb14e555f972eaa17.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-08 14:33:00", "summary": "作者简介：大家好我是每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！个人主页：每天都要敲代码的个人主页每天都要敲代码的个人主页系列专栏：从入门到精通从入门到精通推荐一款模拟面试、刷题神器"}