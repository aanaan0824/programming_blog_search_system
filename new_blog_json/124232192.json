{"blogid": "124232192", "writerAge": "码龄1年", "writerBlogNum": "57", "writerCollect": "101", "writerComment": "3", "writerFan": "8", "writerGrade": "3级", "writerIntegral": "597", "writerName": "lans_g", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124232192.jpg", "writerRankTotal": "29485", "writerRankWeekly": "18882", "writerThumb": "21", "writerVisitNum": "28800", "blog_read_count": "7770", "blog_time": "于 2022-04-17 16:55:13 发布", "blog_title": "MVCC详解，深入浅出简单易懂", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"MVCC_1\"></a>一、什么是MVCC？</h3>\n<p>mvcc，也就是多版本并发控制，是为了在读取数据时不加锁来提高读取效率和并发性的一种手段。</p>\n<p>数据库并发有以下几种场景：</p>\n<ul><li>读-读：不存在任何问题。</li><li>读-写：有线程安全问题，可能出现脏读、幻读、不可重复读。</li><li>写-写：有线程安全问题，可能存在更新丢失等。</li></ul>\n<p>mvcc解决的就是读写时的线程安全问题，线程不用去争抢<strong>读写锁</strong>。</p>\n<p>mvcc所提到的读是<strong>快照读</strong>，也就是普通的<strong>select语句</strong>。快照读在读写时不用加锁，不过可能会读到历史数据。</p>\n<p>还有一种读取数据的方式是<strong>当前读</strong>，是一种<strong>悲观锁</strong>的操作。它会对当前读取的数据进行加锁，所以<strong>读到的数据都是最新的</strong>。主要包括以下几种操作：</p>\n<ul><li>select lock in share mode（共享锁）</li><li>select for update（排他锁）</li><li>update（排他锁）</li><li>insert（排他锁）</li><li>delete（排他锁）</li></ul>\n<h3><a id=\"MVCC_25\"></a>二、MVCC的实现</h3>\n<p>1.回顾事务的特性</p>\n<ul><li><strong>原子性：通过undolog实现。</strong></li><li><strong>持久性：通过redolog实现。</strong></li><li><strong>隔离性：通过加锁（当前读）&amp;MVCC（快照读）实现。</strong></li><li>一致性：通过undolog、redolog、隔离性共同实现。</li></ul>\n<p>2.回顾事务的隔离级别</p>\n<ul><li>读未提交：允许读取<strong>尚未提交</strong>的数据变更。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li><li>读已提交：允许读取<strong>已经提交</strong>的数据。可能会导致<strong>幻读和不可重复读</strong>。</li><li>可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。可能会导致<strong>幻读</strong>。</li><li>可串行化：最高隔离级别。</li></ul>\n<p><strong>在读已提交和可重复读隔离级别下的快照读，都是基于MVCC实现的！</strong></p>\n<h4><a id=\"3mvcc_45\"></a><strong>3.mvcc实现原理</strong></h4>\n<p>​ mvcc的实现，基于<strong>undolog</strong>、<strong>版本链</strong>、<strong>readview</strong>。</p>\n<p><img alt=\"image-20220417154044146\" src=\"..\\..\\static\\image\\a463e5d8f8493c4696716e44e96748af.png\"/></p>\n<p>在mysql存储的数据中，除了我们显式定义的字段，mysql会隐含的帮我们定义几个字段。</p>\n<ul><li> <p>trx_id:事务id，每进行一次事务操作，就会自增1。</p> </li><li> <p>roll_pointer:回滚指针，用于找到上一个版本的数据，结合undolog进行回滚。</p> </li></ul>\n<p><strong>什么是readview呢？</strong></p>\n<p>当我们用select读取数据时，这一时刻的数据会有很多个版本（例如上图有四个版本），但我们并不知道读取哪个版本，这时就靠readview来对我们进行读取版本的限制，<strong>通过readview我们才知道自己能够读取哪个版本</strong>。</p>\n<p>在一个readview快照中主要包括以下这些字段：</p>\n<p><img alt=\"image-20220417154721232\" src=\"..\\..\\static\\image\\09036ef6a02c422b54b365930810ceef.png\"/></p>\n<p><strong>对readview中的参数做一些解释</strong></p>\n<p>m_ids：活跃的事务就是指还没有commit的事务。</p>\n<p>max_trx_id：例如m_ids中的事务id为（1，2，3），那么下一个应该分配的事务id就是4，max_trx_id就是4。</p>\n<p>creator_trx_id：执行select读这个操作的事务的id。</p>\n<p><strong>readview如何判断版本链中的哪个版本可用呢？（重点！）</strong></p>\n<p><img alt=\"image-20220417160003011\" src=\"..\\..\\static\\image\\bc9ce42e33df050243df97fe53ff3404.png\"/></p>\n<p>从上到下分别为（1）（2）（3）（4），依次进行解释</p>\n<p><strong>trx_id表示要读取的事务id</strong></p>\n<p>（1）如果<strong>要读取的事务id等于进行读操作的事务id</strong>，说明是我读取我自己创建的记录，那么为什么不可以呢。</p>\n<p>（2）如果<strong>要读取的事务id小于最小的活跃事务id</strong>，说明要读取的事务已经提交，那么可以读取。</p>\n<p>（3）max_trx_id表示生成readview时，分配给下一个事务的id，如果<strong>要读取的事务id大于max_trx_id</strong>，说明该id已经不在该readview版本链中了，故无法访问。</p>\n<p>（4）m_ids中存储的是活跃事务的id，如果要读取的事务id不在活跃列表，那么就可以读取，反之不行。</p>\n<h4><a id=\"4mvccRCRR_95\"></a>4.mvcc如何实现RC和RR的隔离级别</h4>\n<p>（1）<strong>RC</strong>的隔离级别下，每个<strong>快照读</strong>都会<strong>生成并获取最新的readview</strong>。</p>\n<p>（2）<strong>RR</strong>的隔离级别下，只有在<strong>同一个事务</strong>的<strong>第一个快照读</strong>才会<strong>创建readview</strong>，之后的每次快照读都<strong>使用的同一个readview</strong>，所以每次的<strong>查询结果都是一样的</strong>。</p>\n<h4><a id=\"5_103\"></a>5.幻读问题</h4>\n<ul><li>快照读：通过mvcc，<strong>RR的隔离级别解决了幻读问题</strong>，因为每次使用的都是同一个readview。</li><li>当前读：通过next-key锁（行锁+gap锁），<strong>RR隔离级别并不能解决幻读问题</strong>。</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-04-17 16:55:13", "summary": "一、什么是？，也就是多版本并发控制，是为了在读取数据时不加锁来提高读取效率和并发性的一种手段。数据库并发有以下几种场景：读读：不存在任何问题。读写：有线程安全问题，可能出现脏读、幻读、不可重复读。写写"}