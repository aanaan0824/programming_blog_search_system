{"blogid": "125286196", "writerAge": "码龄117天", "writerBlogNum": "4", "writerCollect": "103", "writerComment": "5", "writerFan": "21", "writerGrade": "1级", "writerIntegral": "62", "writerName": "前端小尘", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125286196.jpg", "writerRankTotal": "129973", "writerRankWeekly": "1069027", "writerThumb": "15", "writerVisitNum": "6854", "blog_read_count": "4777", "blog_time": "已于 2022-06-14 21:24:37 修改", "blog_title": "前端最新2022面试题(JS)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>这里写自定义目录标题</h3>\n<ul><li><a href=\"#JavaScript_2\">JavaScript</a></li><li><ul><li><a href=\"#1__3\">1、解释一下什么是闭包 ?</a></li><li><a href=\"#2__15\">2、解释一下原型和原型链 ?</a></li><li><ul><li><a href=\"#_16\">原型</a></li><li><a href=\"#_18\">原型链</a></li></ul>\n</li><li><a href=\"#3_ES6___24\">3、说一下 ES6 中你熟悉的一些内容 ?</a></li><li><a href=\"#4__42\">4、数组排序的方式 ?</a></li><li><a href=\"#5EventLoop__90\">5、什么是事件轮询(EventLoop) ?</a></li><li><a href=\"#6API____98\">6、数组的一些API, 哪些能够改变原数组, 那些不能 ?</a></li><li><a href=\"#7for__forEach___128\">7、for 循环与 forEach 的区别 ?</a></li><li><a href=\"#8__133\">8、深浅拷贝 ?</a></li><li><a href=\"#9url___189\">9、url 的组成 ?</a></li><li><a href=\"#10__199\">10、常见的跨域方式 ?</a></li><li><a href=\"#11Promise___218\">11、Promise 的使用场景 ?</a></li><li><a href=\"#12let_const_var___224\">12、let, const, var 的区别 ?</a></li><li><a href=\"#13_this___this___231\">13、对 this 的理解, 三种改变 this 的方式 ?</a></li><li><a href=\"#14cookie_localStoragesessionStorage___260\">14、cookie, localStorage,sessionStorage 的区别 ?</a></li><li><a href=\"#15_url____307\">15、输入 url 到打开页面 都做了什么事情 ?</a></li><li><a href=\"#16_ajax___315\">16、原生 ajax 的流程 ?</a></li><li><a href=\"#17__337\">17、如何实现继承 ?</a></li><li><a href=\"#18null__undefined___384\">18、null 和 undefined 的区别 ?</a></li><li><a href=\"#19__397\">19、函数的节流和防抖 ?</a></li><li><a href=\"#20_Promise__431\">20、什么是 Promise ?</a></li><li><a href=\"#21__448\">21、普通函数与箭头函数的区别 ?</a></li><li><a href=\"#22___458\">22、设计模式有哪些, 分别说一说 ?</a></li><li><a href=\"#23Promsie__asyncawait___477\">23、Promsie 和 async/await 的区别和使用 ?</a></li><li><a href=\"#24__485\">24、谈一谈垃圾回收机制 ?</a></li><li><a href=\"#25__491\">25、数组去重 ?</a></li><li><a href=\"#26__544\">26、判断对象为空 ?</a></li><li><a href=\"#27__576\">27、如何用一次循环找到数组中两个最大的值 ?</a></li><li><a href=\"#28new___591\">28、new 一个对象的过程 ?</a></li><li><a href=\"#29_new__596\">29、箭头函数为什么不能用 new ?</a></li><li><a href=\"#30__600\">30、如何实现数组的复制 ?</a></li><li><a href=\"#31http___631\">31、http 的理解 ?</a></li><li><a href=\"#32http__https___637\">32、http 和 https 的区别 ?</a></li><li><a href=\"#33git___644\">33、git 的常用指令有哪些 ?</a></li><li><a href=\"#34_git___681\">34、平时是使用 git 指令还是图形化工具 ?</a></li><li><a href=\"#35Promsieall____693\">35、Promsie.all() 使用过吗, 它是怎么使用的 ?</a></li><li><a href=\"#36__702\">36、什么是三次握手和四次挥手 ?</a></li><li><a href=\"#37for_in__for_of___715\">37、for in 和 for of 循环的区别 ?</a></li><li><a href=\"#38asyncawait___723\">38、async/await 怎么抛出错误异常 ?</a></li><li><a href=\"#39___727\">39、 函数式编程和命令式编程的区别 ?</a></li><li><a href=\"#40http___739\">40、http 常见的响应状态码 ?</a></li><li><a href=\"#41___783\">41、 什么是事件流以及事件流的传播机制 ?</a></li><li><a href=\"#42__commonJS_AMD_CMD_ES6_Module_795\">42、模块化语法 ? commonJS AMD CMD ES6 Module</a></li><li><a href=\"#43___805\">43、 什么是懒加载和预加载 ?</a></li><li><a href=\"#44token____cookie___818\">44、token 一般存放在哪里 ? 为什么不存放在 cookie 内 ?</a></li><li><a href=\"#45_less__sass___822\">45、 less 和 sass 的区别 ?</a></li><li><a href=\"#44__828\">44、浏览器的同源策略机制 ?</a></li><li><a href=\"#45_______860\">45、 浏览器的缓存有哪些 ? 什么时候使用强制缓存 ? 什么时候使用协商缓存 ?</a></li><li><a href=\"#46__forEach__map___870\">46、 数组方法 forEach 和 map 的区别 ?</a></li><li><a href=\"#47_____876\">47、 什么是函数作用域 ? 什么是作用域链 ?</a></li><li><a href=\"#48_ES6__Set__Map___888\">48、 ES6 中 Set 和 Map 的原理 ?</a></li><li><a href=\"#49_01__02__03___894\">49、 0.1 + 0.2 为什么不等于 0.3, 在项目中遇到要怎么处理 ?</a></li><li><a href=\"#50___957\">50、 什么是模块化思想 ?</a></li><li><a href=\"#51_js__982\">51、 说说怎么用js 写无缝轮播图</a></li><li><a href=\"#52_JS___986\">52、 JS 如何实现多线程 ?</a></li><li><a href=\"#53___1004\">53、 闭包的使用场景 ?</a></li><li><a href=\"#54___1201\">54、 常见的兼容问题有哪些 ?</a></li><li><a href=\"#55__JS___1434\">55、 在 JS 中如何阻止事件冒泡 ?</a></li><li><a href=\"#56_var_A__1_5_6_var_B__2_6_7A___B_1449\">56、两个数组 var A = [1, 5, 6]; var B = [2, 6, 7]，实现一个方法，找出仅存在于A 或者 仅 存在于B中的所有数字。</a></li><li><a href=\"#57___class_____1467\">57、 你了解构造函数吗 ? class 是什么 ? 两者有什么区别 ?</a></li><li><a href=\"#58aa0__a1true___1478\">58、是否存在a的值（a==0 &amp;&amp; a==1）为true 的情况 ?</a></li><li><a href=\"#59for_var_i__0_i__5_i__setTimeoutfunction__consolelogi__1000__01234_1494\">59、for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i); }, 1000); } 要求：输出0，1，2，3，4</a></li><li><a href=\"#60_add_____add123__6__add1234__10_1536\">60、实现一个 add 方法 使计算结果能够满足如下预期： - add(1)(2)(3)() = 6 - add(1,2,3)(4)() = 10</a></li><li><a href=\"#61_HTTP_____1573\">61、常见的 HTTP 请求有哪些 ? 他们的区别是什么 ?</a></li><li><a href=\"#62_JS_____1589\">62、 JS 的数据类型有哪些 ? 如何判断数据类型 ?他们的优缺点是什么？</a></li><li><a href=\"#63_symbol___1604\">63、 symbol 你是怎么理解的 ?</a></li><li><a href=\"#64_1695\">64、数组常用方法有那些</a></li><li><a href=\"#65JavaScriptcookie_1737\">65、JavaScript如何存储cookie</a></li><li><a href=\"#66_1751\">66、柯理化函数</a></li><li><a href=\"#67_1810\">67、对象遍历方法</a></li><li><a href=\"#68_1846\">68、数组扁平化</a></li><li><a href=\"#69typeof__1886\">69、typeof 原理</a></li><li><a href=\"#70_1909\">70、介绍类型转化</a></li><li><a href=\"#71_1977\">71、执行上下文</a></li><li><a href=\"#72_2011\">72、闭包的问题和优化</a></li><li><a href=\"#73Node_2068\">73、浏览器和Node事件循环的区别</a></li><li><a href=\"#74_2119\">74、移动端点击延迟</a></li><li><a href=\"#75cookie_2177\">75、cookie属性</a></li><li><a href=\"#76_2192\">76、反柯里化</a></li><li><a href=\"#77_2271\">77、千分位</a></li><li><a href=\"#78loadready_2335\">78、load和ready区别</a></li><li><a href=\"#79_2396\">79、自定义事件</a></li><li><a href=\"#80setTimeoutsetInterval_2592\">80、setTimeout实现setInterval</a></li><li><a href=\"#81_2638\">81、避免回调地狱</a></li><li><a href=\"#82calleecaller_2704\">82、callee和caller的作用</a></li><li><a href=\"#83_2781\">83、统计字符串中字母个数或统计最多的字母数</a></li><li><a href=\"#84_2835\">84、面对对象和面向过程的区别</a></li><li><a href=\"#85eval_2898\">85、eval</a></li><li><a href=\"#86proxy_2926\">86、proxy</a></li><li><ul><li><a href=\"#Proxyhandler_2987\">二、Proxy所能代理的范围--handler</a></li><li><a href=\"#Proxy_3038\">三、Proxy场景</a></li></ul>\n</li><li><a href=\"#87_3371\">87、事件代理</a></li><li><a href=\"#88_3401\">88、不卡顿</a></li><li><a href=\"#89JavaScriptinstanceof_3440\">89、JavaScript中的instanceof</a></li><li><a href=\"#90forEachawait_3488\">90、forEach中的await</a></li><li><a href=\"#91srchref_3678\">91、src和href</a></li><li><a href=\"#92JavaScript_3700\">92、JavaScript中事件绑定的方法</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"JavaScript_2\"></a>JavaScript</h1>\n<h2><a id=\"1__3\"></a>1、解释一下什么是闭包 ?</h2>\n<ul><li>闭包：就是能够读取外层函数内部变量的函数。</li><li>闭包需要满足三个条件： \n  <ul><li>访问所在作用域；</li><li>函数嵌套；</li><li>在所在作用域外被调用 。</li></ul> </li><li>优点： 可以重复使用变量，并且不会造成变量污染 。</li><li>缺点： 会引起内存泄漏</li><li>使用闭包的注意点： \n  <ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象<br/> （object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ul> </li></ul>\n<h2><a id=\"2__15\"></a>2、解释一下原型和原型链 ?</h2>\n<h3><a id=\"_16\"></a>原型</h3>\n<pre><code>原型就是一个为对象实例定义了一些公共属性和公共方法的对象模板。\n</code></pre>\n<h3><a id=\"_18\"></a>原型链</h3>\n<pre><code>对象之间的继承关系通过构造函数的prototype指向父类对象，直到指向Object对象为止形成的指向链条。\n\n通俗讲： 原型链是原型对象创建过程的历史记录。 \n\n注：在javascript中，所有的对象都拥有一个__proto__属性指向该对象的原型（prototype) 。\n</code></pre>\n<h2><a id=\"3_ES6___24\"></a>3、说一下 ES6 中你熟悉的一些内容 ?</h2>\n<ul><li> <p>class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念</p> </li><li> <p>async、await使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成</p> </li><li> <p>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大</p> </li><li> <p>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</p> </li><li> <p>Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</p> </li><li> <p>Set是类似于数组的数据集合，无序，插入删除速度快，元素不重复，查找速度快。</p> </li><li> <p>Map是一个类似对象的数据结构，和对象不同的在于它的key可以是任意类型，但是对象只能使用string和symbol类型，Map的存储关联性更强</p> </li><li> <p>生成器函数可以进行阻断函数执行的过程，通过传参可以传入新的值进入函数继续执行，可以用于将异步变为阻塞式同步</p> </li></ul>\n<h2><a id=\"4__42\"></a>4、数组排序的方式 ?</h2>\n<ul><li>冒泡排序：</li></ul>\n<pre><code class=\"prism language-bash\">    for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length-1<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">j</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>arr.length-i-1<span class=\"token punctuation\">;</span>j++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                if<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span>arr<span class=\"token punctuation\">[</span>j+1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                    var <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j+1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    arr<span class=\"token punctuation\">[</span>j+1<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>temp<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        if<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j-1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> i++<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>选择排序：</li></ul>\n<pre><code class=\"prism language-bash\"> for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            var <span class=\"token assign-left variable\">min</span><span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n            for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">j</span><span class=\"token operator\">=</span>i+1<span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>j++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                if<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">min</span><span class=\"token operator\">=</span>j<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            if<span class=\"token punctuation\">(</span>min<span class=\"token operator\">!=</span><span class=\"token operator\">=</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                var <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>temp<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        if<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i+1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>i++<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>快速排序：</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> quickSort<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr.length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">return</span> arr<span class=\"token punctuation\">;</span>\n    var centerIndex <span class=\"token operator\">=</span> ~~<span class=\"token punctuation\">(</span>arr.length / <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    var left <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    var right <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>var i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr.length<span class=\"token punctuation\">;</span> i++<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span><span class=\"token operator\">=</span> centerIndex<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>centerIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> left.push<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> right.push<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token builtin class-name\">return</span> quickSort<span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span>.concat<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>centerIndex<span class=\"token punctuation\">]</span>, quickSort<span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"5EventLoop__90\"></a>5、什么是事件轮询(EventLoop) ?</h2>\n<p>一个用来等待和发送消息和事件的程序结构。</p>\n<ul><li>1、所有任务都在主线程上执行，形成一个执行栈。</li><li>2、主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里。</li><li>3、执行栈所有同步任务执行完毕。</li><li>4、执行微任务队列，之后再执行宏任务队列。</li><li>5、轮询第4步。</li></ul>\n<h2><a id=\"6API____98\"></a>6、数组的一些API, 哪些能够改变原数组, 那些不能 ?</h2>\n<ul><li>改变原数组的方法：</li></ul>\n<pre><code class=\"prism language-bash\">shift<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nunshift<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npush<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nreverse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nsplice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<ul><li>不改变原数组的方法：</li></ul>\n<pre><code class=\"prism language-bash\">concat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nevery<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nfilter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nforEach<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nindexOf<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\njoin<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nlastIndexOf<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmap<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nsome<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nevery<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nslice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nreduce<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nreduceRight<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \nflat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nflatMap<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nfind<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h2><a id=\"7for__forEach___128\"></a>7、for 循环与 forEach 的区别 ?</h2>\n<ul><li>1.for循环可以使用break跳出循环，但forEach不能。</li><li>2.for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。</li><li>3.for循环过程中支持修改索引（修改 i），但forEach做不到（底层控制index自增，无法左右它）。</li></ul>\n<h2><a id=\"8__133\"></a>8、深浅拷贝 ?</h2>\n<ul><li>深拷贝：</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> cloneObject<span class=\"token punctuation\">(</span>source, target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>target <span class=\"token operator\">==</span><span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Node.prototype.isPrototypeOf<span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">))</span> <span class=\"token punctuation\">{<!-- --></span>\n          target <span class=\"token operator\">=</span> document.createElement<span class=\"token punctuation\">(</span>source.nodeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          target.style <span class=\"token operator\">=</span> source.style.cssText<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>source.constructor <span class=\"token operator\">==</span><span class=\"token operator\">=</span> Uint8Array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n          target <span class=\"token operator\">=</span> new source.constructor<span class=\"token punctuation\">(</span>Array.from<span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>source.constructor <span class=\"token operator\">==</span><span class=\"token operator\">=</span> Date <span class=\"token operator\">||</span> source.constructor <span class=\"token operator\">==</span><span class=\"token operator\">=</span> RegExp <span class=\"token operator\">||</span> source.constructor <span class=\"token operator\">==</span><span class=\"token operator\">=</span> Set <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">source</span>\n          .constructor <span class=\"token operator\">==</span><span class=\"token operator\">=</span> Map<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n          target <span class=\"token operator\">=</span> new source.constructor<span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>source.constructor <span class=\"token operator\">==</span><span class=\"token operator\">=</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n          var arg <span class=\"token operator\">=</span> source.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>.match<span class=\"token punctuation\">(</span>/<span class=\"token punctuation\">\\</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>.<span class=\"token operator\">*</span><span class=\"token operator\">?</span><span class=\"token punctuation\">)</span>\\<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token punctuation\">)</span>[<span class=\"token number\">1</span>]<span class=\"token punctuation\">;</span>\n          var content <span class=\"token operator\">=</span> source.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>.replace<span class=\"token punctuation\">(</span><span class=\"token operator\">/</span>\\n<span class=\"token operator\">|</span>\\r<span class=\"token operator\">/</span>g<span class=\"token punctuation\">,</span> \"\"<span class=\"token punctuation\">)</span>.match<span class=\"token punctuation\">(</span><span class=\"token operator\">/</span>\\{<!-- --><span class=\"token punctuation\">(</span>.<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\\}<span class=\"token operator\">/</span><span class=\"token punctuation\">)</span>[<span class=\"token number\">1</span>]<span class=\"token punctuation\">;</span>\n          target <span class=\"token operator\">=</span> new Function<span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span>\n        } else {\n          target <span class=\"token operator\">=</span> new source.constructor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        }\n      }\n      var names <span class=\"token operator\">=</span> Object.getOwnPropertyNames<span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span>.concat<span class=\"token punctuation\">(</span>Object.getOwnPropertySymbols<span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>var i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> names.length<span class=\"token punctuation\">;</span> i++<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token string\">\"constructor\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n          Object.defineProperty<span class=\"token punctuation\">(</span>target, <span class=\"token string\">\"constructor\"</span>, <span class=\"token punctuation\">{<!-- --></span>\n            value: source.constructor\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token builtin class-name\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        var desc <span class=\"token operator\">=</span> Object.getOwnPropertyDescriptor<span class=\"token punctuation\">(</span>source, names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">((</span>typeof desc.value <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token string\">\"object\"</span> <span class=\"token operator\">&amp;&amp;</span> desc.value <span class=\"token operator\">!=</span><span class=\"token operator\">=</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> typeof desc.value <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n          var o <span class=\"token operator\">=</span> cloneObject<span class=\"token punctuation\">(</span>desc.value<span class=\"token punctuation\">)</span>\n          Object.defineProperty<span class=\"token punctuation\">(</span>target, names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>, <span class=\"token punctuation\">{<!-- --></span>\n            value: o,\n            enumerable: desc.enumerable,\n            writable: desc.writable,\n            configurable: desc.configurable\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n          Object.defineProperty<span class=\"token punctuation\">(</span>target, names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>, desc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token builtin class-name\">return</span> target<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>浅拷贝：</li></ul>\n<pre><code class=\"prism language-bash\">    <span class=\"token number\">1</span>、Object.assign<span class=\"token punctuation\">(</span>目标对象，源对象<span class=\"token punctuation\">)</span>\n    <span class=\"token number\">2</span>、\n    var <span class=\"token assign-left variable\">obj1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n    for<span class=\"token punctuation\">(</span>var key <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        obj1<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token number\">3</span>、obj1<span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">..</span>.obj<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"9url___189\"></a>9、url 的组成 ?</h2>\n<pre><code class=\"prism language-bash\"> http:/https:    协议\n www.baidu.com  域名\n :8080  端口\n /sf/vsearch  路径\n ?wd<span class=\"token operator\">=</span>百度热搜   查询<span class=\"token punctuation\">(</span>可有可无<span class=\"token punctuation\">)</span>\n <span class=\"token comment\">#a=1&amp;b=2  哈希值(可有可无)                         </span>\n</code></pre>\n<h2><a id=\"10__199\"></a>10、常见的跨域方式 ?</h2>\n<ul><li>JSONP：<br/> JSONP是利用外链脚本，没有跨源限制的特点，来实现跨源请求的一种技术。</li><li>CORS：<br/> cors：跨域资源共享，是一种实现跨源请求数据的技术。这就是跨源问题的解决方案之一。也是广泛的解决方案。</li><li>正向代理<br/> 先搭建一个属于自己的代理服务器 \n  <ul><li>1、用户发送请求到自己的代理服务器</li><li>2、自己的代理服务器发送请求到服务器</li><li>3、服务器将数据返回到自己的代理服务器</li><li>4、自己的代理服务器再将数据返回给用户</li></ul> </li><li>反向代理 \n  <ul><li>1、用户发送请求到服务器（访问的其实是反向代理服务器，但用户不知道）</li><li>2、反向代理服务器发送请求到真正的服务器</li><li>3、真正的服务器将数据返回给反向代理服务器</li><li>4、反向代理服务器再将数据返回给用户</li></ul> </li><li>通过postMassage，</li></ul>\n<h2><a id=\"11Promise___218\"></a>11、Promise 的使用场景 ?</h2>\n<ul><li>场景1：获取文件信息。</li><li>场景2：配合AJAX获取信息</li><li>场景3：解决回调地狱，实现串行任务队列。</li><li>场景4: node中进行本地操作的异步过程</li></ul>\n<h2><a id=\"12let_const_var___224\"></a>12、let, const, var 的区别 ?</h2>\n<pre><code class=\"prism language-bash\">声明方式 变量提升 暂时性死区 重复声明 初始值 作用域\nvar\t     允许\t  不存在\t   允许  不需要 非块级\n<span class=\"token builtin class-name\">let</span>\t    不允许\t   存在\t  不允许\t 不需要\t块级\nconst\t不允许\t   存在\t  不允许\t  需要\t块级\n</code></pre>\n<h2><a id=\"13_this___this___231\"></a>13、对 this 的理解, 三种改变 this 的方式 ?</h2>\n<ul><li> <p>1.任何情况下直接在script中写入的this都是window。</p> </li><li> <p>2.函数中的this 非严格模式：this指向window， 严格模式时：this指向undefined。</p> </li><li> <p>3.箭头函数的this<br/> this都指向箭头函数外上下文环境的this指向</p> </li><li> <p>4.对象中this<br/> 对象属性的this 指向对象外上下文环境的this<br/> 对象方法(普通函数)中的this，指向当前对象(谁执行该方法，this就指向谁)</p> </li><li> <p>5.回调函数的this指向</p>\n<ul><li>1)、 setTimeout，setInterval回调函数不管是否是严格模式都会指向window。</li><li>2)、通过在函数内执行当前回调函数 非严格模式：this指向window， 严格模式时：this指向undefined。</li><li>3）递归函数中的this 非严格模式：this指向window， 严格模式时：this指向undefined。</li><li>\n<ol start=\"4\"><li>使用arguments<a href=\"\">0</a>执行函数时 this指向arguments。</li></ol> </li><li>5）事件中的回调函数,this指向事件侦听的对象(e.currentTarget);</li></ul> </li><li> <p>6、call，apply，bind方法执行时this的指向</p>\n<ul><li>如果call,apply,bind传参时，第一个参数传入的不是null或者undefined，传入什么this指向什么</li><li>如果第一个参数传入的是null或者undefined ,非严格模式下指向window</li></ul> </li><li> <p>7、在ES6的类中this的指向</p>\n<ul><li>构造函数中的this指向实例当前类所产生的新的实例对象</li><li>类中实例化方法中this指向谁执行该方法，this指向谁</li><li>类中静态方法中this执行该类或者该类的构造函数</li><li>类中实例化箭头方法，this仍然指向当前类实例化的实例对象</li></ul> </li><li> <p>8、ES5的原型对象中this的指向</p>\n<ul><li>在原型的方法中，this指向实例化当前构造函数的实例化对象（谁执行该方法，this指向谁）;</li><li>三种改变this指向的方式 \n    <ul><li>函数名.call（this,…）this写谁就指谁。</li><li>函数名.apply(this,[参数1，参数2，…]) this写谁就指谁。</li><li>函数名. bind (this,1,2,3) this写谁就指谁。</li></ul> </li></ul> </li></ul>\n<h2><a id=\"14cookie_localStoragesessionStorage___260\"></a>14、cookie, localStorage,sessionStorage 的区别 ?</h2>\n<p>存储方式 作用与特性 存储数量及大小</p>\n<ul><li>cookie</li></ul>\n<pre><code class=\"prism language-bash\">存储方式\n 存储用户信息，获取数据需要与服务器建立连接。\n 以路径存储，上层路径不能访问下层的路径cookie，下层的路径cookie可以访问上层的路径cookie \n 作用与特性 \n\n可存储的数据有限，且依赖于服务器，无需请求服务器的数据尽量不要存放在cookie 中，以免影响页面性能。\n\n可设置过期时间。\n\n存储数量及大小 将cookie控制在4095B以内，超出的数据会被忽略。\nIE6或更低版本 最多存20个cookie； \nIE7及以上\n版本 多可以有50个；\nFirefox多 <span class=\"token number\">50</span>个；\nchrome和Safari没有做硬性限制。\n\ncookie最大特征就是可以在页面与服务器间互相传递，当发送或者接受数据时自动传递\n\n</code></pre>\n<pre><code class=\"prism language-bash\">localStorage\n 存储客户端信息，无需请求服务器。\n\n 数据永久保存，除非用户手动清理客户端缓存。\n\n 开发者可自行封装一个方法，设置失效时间。\t5M左右，各浏览器的存储空间有差异。\n\n 任何地方都可以存都可以取\n\n 操作简单\n\n</code></pre>\n<pre><code class=\"prism language-bash\">sessionStorage\t\n\n存储客户端信息，无需请求服务器。\n\n数据保存在当前会话，刷新页面数据不会被清除，结束会话（关闭浏览器、关闭页面、跳转页面）数据失效。\t\n\n5M左右，各浏览器的存储空间有差异。\n\n同页面不同窗口中数据不会共享\n</code></pre>\n<h2><a id=\"15_url____307\"></a>15、输入 url 到打开页面 都做了什么事情 ?</h2>\n<ul><li>输入URL</li><li>访问hosts解析，如果没有解析访问DNS解析</li><li>TCP握手</li><li>HTTP请求</li><li>HTTP响应返回数据</li><li>浏览器解析并渲染页面</li></ul>\n<h2><a id=\"16_ajax___315\"></a>16、原生 ajax 的流程 ?</h2>\n<pre><code class=\"prism language-bash\">    创建xhr\n    var <span class=\"token assign-left variable\">xhr</span><span class=\"token operator\">=</span>new XMLHTTPRequest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    侦听通信状态改变的事件\n    xhr.addEventListener<span class=\"token punctuation\">(</span><span class=\"token string\">\"readystatechange\"</span>,readyStateChangeHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Method 分为 get post put delete等等\n    Async 异步同步\n    name和password是用户名和密码\n    xhr.open<span class=\"token punctuation\">(</span>Method,URL,Async,name,password<span class=\"token punctuation\">)</span>\n    发送内容给服务器\n    xhr.send<span class=\"token punctuation\">(</span>内容<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">function</span> readyStateChangeHandler<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n      当状态是4时，并且响应头成功200时，\n       if<span class=\"token punctuation\">(</span>xhr.readyState<span class=\"token operator\">==</span><span class=\"token operator\">=</span><span class=\"token number\">4</span> <span class=\"token operator\">&amp;&amp;</span> xhr.status<span class=\"token operator\">==</span><span class=\"token operator\">=</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n         打印返回的消息 \n         console.log<span class=\"token punctuation\">(</span>xhr.response<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"17__337\"></a>17、如何实现继承 ?</h2>\n<ul><li> <p>对于 JavaScript 来说，继承有两个要点：</p>\n<ul><li>\n<ol><li>复用父构造函数中的代码</li></ol> </li><li>\n<ol start=\"2\"><li>复用父原型中的代码第一种实现复用父构造函数中的代码，我们可以考虑调用父构造函数并将 this 绑定到子构造函数。</li></ol> </li></ul> </li><li> <p>第一种方法：复用父原型中的代码，我们只需改变原型链即可。将子构造函数的原型对象的 proto 属性指向父构造函数的原型对象。</p> </li><li> <p>第二种实现<br/> 使用 new 操作符来替代直接使用 proto 属性来改变原型链。</p> </li><li> <p>第三种实现<br/> 使用一个空构造函数来作为中介函数，这样就不会将构造函数中的属性混到 prototype 中</p> </li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> A<span class=\"token punctuation\">(</span>x,y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  this.x <span class=\"token operator\">=</span> x\n  this.y <span class=\"token operator\">=</span> y\n<span class=\"token punctuation\">}</span>\nA.prototype.run <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n// 寄生继承 二者一起使用\n<span class=\"token keyword\">function</span> B<span class=\"token punctuation\">(</span>x,y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  A.call<span class=\"token punctuation\">(</span>this,x,y<span class=\"token punctuation\">)</span>  // 借用继承\n<span class=\"token punctuation\">}</span>\nB.prototype <span class=\"token operator\">=</span> new A<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> // 原型继承\n// 组合继承\nFunction.prototype.extends <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>superClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">function</span> <span class=\"token function-name function\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n  F.prototype <span class=\"token operator\">=</span> superClass.prototype\n  if<span class=\"token punctuation\">(</span>superClass.prototype.constructor <span class=\"token operator\">!=</span><span class=\"token operator\">=</span> superClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    Object.defineProperty<span class=\"token punctuation\">(</span>superClass.prototype,<span class=\"token string\">'constructor'</span>,<span class=\"token punctuation\">{<!-- --></span>value:superClass<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin class-name\">let</span> proto <span class=\"token operator\">=</span> this.prototype\n  this.prototype <span class=\"token operator\">=</span> new F<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token builtin class-name\">let</span> names <span class=\"token operator\">=</span> Reflect.ownKeys<span class=\"token punctuation\">(</span>proto<span class=\"token punctuation\">)</span>\n  for<span class=\"token punctuation\">(</span>let i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> names.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token builtin class-name\">let</span> desc <span class=\"token operator\">=</span> Object.getOwnPropertyDescriptor<span class=\"token punctuation\">(</span>proto,names<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    Object.defineProperty<span class=\"token punctuation\">(</span>this.prototypr,name<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>,desc<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n  this.prototype.super <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    superClass.apply<span class=\"token punctuation\">(</span>this,arg<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n  this.prototype.supers <span class=\"token operator\">=</span> superClass.prototype\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>第四种实现<br/> es6类的继承extends。</li></ul>\n<h2><a id=\"18null__undefined___384\"></a>18、null 和 undefined 的区别 ?</h2>\n<ul><li>null是一个表示\"无\"的对象（空对象指针），转为数值时为0；</li><li>undefined是一个表示\"无\"的原始值，转为数值时为NaN。<br/> 拓展：</li><li>null表示\"没有对象\"，即该处不应该有值。典型用法是： \n  <ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul> </li><li>undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。典型用法是： \n  <ul><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul> </li></ul>\n<h2><a id=\"19__397\"></a>19、函数的节流和防抖 ?</h2>\n<ul><li>节流</li></ul>\n<pre><code class=\"prism language-bash\">节流是指当一个事件触发的时候,为防止事件的连续频繁触发,设置定时器,达到一种一段事件内只触发一次的效果,在当前事件内不会再次触发,当前事件结束以后,再次触发才有效.\n</code></pre>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> thro<span class=\"token punctuation\">(</span>cb,wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token builtin class-name\">let</span> timeOut\n  <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    if<span class=\"token punctuation\">(</span>timeOut<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">return</span>\n    timeOut <span class=\"token operator\">=</span> setTimeout<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n      cb<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      clearTimeout<span class=\"token punctuation\">(</span>timeOut<span class=\"token punctuation\">)</span>\n      timeOut <span class=\"token operator\">=</span> null\n    <span class=\"token punctuation\">}</span>,wait<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>防抖</li></ul>\n<pre><code class=\"prism language-bash\">防抖是指当一个事件触发的时候, 为防止频繁触发事件, 设置定时器,以达到一种 频繁触发期间不处理, 只有当最后一次连续触发结束以后才处理\n</code></pre>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> debounce<span class=\"token punctuation\">(</span>cb,wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token builtin class-name\">let</span> timer\n  <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    clearTimeout<span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span>\n    timer <span class=\"token operator\">=</span> setTimeout<span class=\"token punctuation\">((</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span>cb<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>,wait<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"20_Promise__431\"></a>20、什么是 Promise ?</h2>\n<pre><code class=\"prism language-bash\">  Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；\n  \n  从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。\n  \n  promise有三种状态： pending<span class=\"token punctuation\">(</span>等待态<span class=\"token punctuation\">)</span>，fulfilled<span class=\"token punctuation\">(</span>成功态<span class=\"token punctuation\">)</span>，rejected<span class=\"token punctuation\">(</span>失败态<span class=\"token punctuation\">)</span>；状态一旦改变，就不会再变。创造promise实例后，它会立即执行\n\n  promise是用来解决两个问题的：\n\n  回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象\n\n  promise可以支持多个并发的请求，获取并发请求中的数据\n\n  这个promise可以解决异步的问题，本身不能说promise是异步的\n</code></pre>\n<h2><a id=\"21__448\"></a>21、普通函数与箭头函数的区别 ?</h2>\n<p>普通函数和箭头函数的区别：</p>\n<ul><li>1.箭头函数没有prototype(原型),箭头函数没有自己的this,继承的是外层代码块的this。</li><li>2.不可以当做构造函数，也就是说不可以使用new命令，否则会报错的。</li><li>3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>4.不可以使用yield命令，因此箭头函数不能用作 Generator（生成器） 函数。</li><li>5.因为没有this,所以不能使用call、bind、apply来改变this的指向。</li></ul>\n<h2><a id=\"22___458\"></a>22、设计模式有哪些, 分别说一说 ?</h2>\n<p>共23种设计模式，介绍其中6种应用较为广泛的模式。</p>\n<ul><li> <p>发布订阅模式:<br/> 这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。</p> </li><li> <p>中介者模式 :<br/> 观察者模式通过维护一堆列表来管理对象间的多对多关系，中介者模式通过统一接口来维护一对多关系，且通信者之间不需要知道彼此之间的关系，只需要约定好API即可。</p> </li><li> <p>代理模式 :<br/> 为其他对象提供一种代理以控制对这个对象的访问。<br/> 代理模式使得代理对象控制具体对象的引用。代理几乎可以是任何对象：文件，资源，内存中的对象，或者是一些难以复制的东西。</p> </li><li> <p>单例模式 :<br/> 保证一个类只有一个实例，并提供一个访问它的全局访问点（调用一个类，任何时候返回的都是同一个实例）。</p> </li><li> <p>工厂模式 :<br/> 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一<br/> 个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型</p> </li><li> <p>装饰者模式 : 装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责（方法或属性）。与继承相比，装饰者是一种更轻便灵活的做法。</p> </li></ul>\n<h2><a id=\"23Promsie__asyncawait___477\"></a>23、Promsie 和 async/await 的区别和使用 ?</h2>\n<p>区别：</p>\n<ul><li>1）函数前面多了一个async关键字。await关键字只能用在async定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。</li><li>2）第1点暗示我们不能在 外层代码中使用await，因为不在async函数内。使用： \n  <ul><li>1.async和await是配对使用的，await存在于async的内部。否则会报错 。</li><li>2.await表示在这里等待一个promise返回，再接下来执行。</li><li>3.await后面跟着的应该是一个promise对象，（也可以不是，如果不是接下来也没什么意义了…）</li></ul> </li></ul>\n<h2><a id=\"24__485\"></a>24、谈一谈垃圾回收机制 ?</h2>\n<p>垃圾回收是动态存储管理技术，会自动地释放“垃圾‘’(不再被程序引用的对象)，按照特定的垃圾收集算法来实现资源自动回收的功能。<br/> 回收的两种机制</p>\n<ul><li>1.标记清除（make-and-sweep）</li><li>2.引用计数 垃圾回收器会按照固定的时间间隔周期性的执行。</li></ul>\n<h2><a id=\"25__491\"></a>25、数组去重 ?</h2>\n<ul><li>第一种：</li></ul>\n<pre><code class=\"prism language-bash\">for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nfor<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">j</span><span class=\"token operator\">=</span>i+1<span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nif<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> arr.splice<span class=\"token punctuation\">(</span>j,1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">else</span> j++<span class=\"token punctuation\">;</span> // 核心 \n<span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span> \n</code></pre>\n<ul><li>第二种：</li></ul>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \nxt: for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nfor<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">j</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>arr1.length<span class=\"token punctuation\">;</span>j++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nif<span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">continue</span> xt<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\narr1.push<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n</code></pre>\n<ul><li>第三种：</li></ul>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \nfor<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nif<span class=\"token punctuation\">(</span>arr1.indexOf<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> arr1.push<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span> \n</code></pre>\n<ul><li>第四种：</li></ul>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \nfor<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nif<span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>~arr1.indexOf<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">)</span> arr1.push<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span> \n</code></pre>\n<ul><li>第五种：</li></ul>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \nfor<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nif<span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>arr1.includes<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">))</span> arr1.push<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> \n</code></pre>\n<ul><li>第六种：</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token assign-left variable\">arr</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1,2</span>,3,1,2,3,1,2,3<span class=\"token punctuation\">]</span> \nnew Set<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n</code></pre>\n<h2><a id=\"26__544\"></a>26、判断对象为空 ?</h2>\n<ul><li>第一种</li></ul>\n<pre><code class=\"prism language-bash\">使用JSON.stringify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>将对象转换为json字符串； \nJSON.stringify<span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token string\">'{}'</span> \n</code></pre>\n<ul><li>第二种</li></ul>\n<pre><code class=\"prism language-bash\">使用for<span class=\"token punctuation\">..</span>.in循环遍历对象除Symbol以外的所有可枚举属性，当对象有属性存在返回false， 否则返回 \ntrue。 \nconst obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">function</span> isObjectEmpty<span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \nfor<span class=\"token punctuation\">(</span>var key <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> \n<span class=\"token builtin class-name\">return</span> <span class=\"token boolean\">false</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token builtin class-name\">return</span> <span class=\"token boolean\">true</span> \n<span class=\"token punctuation\">}</span>\nconsole.log<span class=\"token punctuation\">(</span>isObjectEmpty<span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">))</span> \n</code></pre>\n<ul><li>第三种</li></ul>\n<pre><code class=\"prism language-bash\">Object.getOwnPropertyNames<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 方法会返回该对象所有可枚举和不可枚举属性的属性名（不含Symbol \n属性）组成的数组。然后再通过判断返回的数组长度是否为零，如果为零的话就是空对象。 \nObject.getOwnPropertyNames<span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>.length <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token number\">0</span> \n</code></pre>\n<ul><li>第四种</li></ul>\n<pre><code class=\"prism language-bash\">Object.keys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 是 ES5 新增的一个对象方法，该方法返回一个数组，包含指定对象自有的可枚举属性（不 \n含继承的和Symbol属性）。用此方法只需要判断返回的数组长度是否为零，如果为零的话就是空对象。\n</code></pre>\n<h2><a id=\"27__576\"></a>27、如何用一次循环找到数组中两个最大的值 ?</h2>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1,4</span>,10,11,11,2,5,7,2,3,4<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  var <span class=\"token punctuation\">[</span>max,second<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> ? <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>,arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>,arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    if<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token assign-left variable\">second</span><span class=\"token operator\">=</span>max<span class=\"token punctuation\">;</span>\n      <span class=\"token assign-left variable\">max</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>else if<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;=</span>max <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token assign-left variable\">second</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"28new___591\"></a>28、new 一个对象的过程 ?</h2>\n<ul><li>1.开辟一个堆内存，创建一个空对象</li><li>2.执行构造函数，对这个空对象进行构造</li><li>3.给这个空对象添加__proto__属性</li></ul>\n<h2><a id=\"29_new__596\"></a>29、箭头函数为什么不能用 new ?</h2>\n<p>因为箭头函数没有prototype也没有自己的this指向并且不可以使用arguments。</p>\n<h2><a id=\"30__600\"></a>30、如何实现数组的复制 ?</h2>\n<ul><li>for循环逐一复制；</li></ul>\n<pre><code class=\"prism language-bash\">  var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    if<span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> arr<span class=\"token punctuation\">)</span> arr1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>…方式</li></ul>\n<pre><code class=\"prism language-bash\">   var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.arr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>slice方法</li></ul>\n<pre><code class=\"prism language-bash\">  var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span>arr.slice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>concat方法</li></ul>\n<pre><code class=\"prism language-bash\">  var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span>arr.concat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>map方法</li></ul>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span>arr.map<span class=\"token punctuation\">(</span>item<span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>reduce</li></ul>\n<pre><code class=\"prism language-bash\">var <span class=\"token assign-left variable\">arr1</span><span class=\"token operator\">=</span>arr.reduce<span class=\"token punctuation\">((</span>v,t<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span>v.push<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>,<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h2><a id=\"31http___631\"></a>31、http 的理解 ?</h2>\n<pre><code class=\"prism language-bash\">HTTP 协议是超文本传输协议，是客户端浏览器或其他程序“请求”与 Web 服务器响应之间的应用层通信协议。\n\n HTTPS主要是由HTTP+SSL构建的可进行加密传输、身份认证的一种安全通信通道。\n</code></pre>\n<h2><a id=\"32http__https___637\"></a>32、http 和 https 的区别 ?</h2>\n<ul><li>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul>\n<h2><a id=\"33git___644\"></a>33、git 的常用指令有哪些 ?</h2>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">git</span> branch 分支查看\n\n<span class=\"token function\">git</span> branch branch_1 增加分支\n\n<span class=\"token function\">git</span> checkout branch 分支切换\n\n<span class=\"token function\">git</span> merge branch_1 合并分支<span class=\"token punctuation\">(</span>合并前要切换当前分支至master<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">git</span> branch -d branch_1 删除分支\n\n<span class=\"token function\">git</span> remote 查看当前仓库管理的远程仓库信息\n\n<span class=\"token function\">git</span> remote show origin 查看指定的远程仓库的详细信息\n\n<span class=\"token function\">git</span> push --set-upstream origin branch_1 第一次将本地分支推到远程仓库\n\n<span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>远程主机名<span class=\"token operator\">&gt;</span> <span class=\"token operator\">&lt;</span>本地分支名<span class=\"token operator\">&gt;</span>:<span class=\"token operator\">&lt;</span>远程分支名<span class=\"token operator\">&gt;</span> 将本地分支推到远程分支\n\n<span class=\"token function\">git</span> pull <span class=\"token operator\">&lt;</span>远程主机名<span class=\"token operator\">&gt;</span> <span class=\"token operator\">&lt;</span>远程分支<span class=\"token operator\">&gt;</span>:<span class=\"token operator\">&lt;</span>本地分支<span class=\"token operator\">&gt;</span> 将远程分支拉到本地分支\n\n<span class=\"token function\">git</span> branch -d branch_0 删除本地合并后分支\n\n<span class=\"token function\">git</span> brench -D branch_0 删除本地未合并分支\n\nit push origin --delete branch_0 删除远程分支\n\n<span class=\"token function\">git</span> restore <span class=\"token punctuation\">[</span>filename<span class=\"token punctuation\">]</span> 进行清除工作区的改变\n\n<span class=\"token function\">git</span> tag 查看标签\n\n<span class=\"token function\">git</span> tag v1.0.0 打标签\n\n<span class=\"token function\">git</span> push origin v1.0.0 将tag同步到远程服务器\n</code></pre>\n<h2><a id=\"34_git___681\"></a>34、平时是使用 git 指令还是图形化工具 ?</h2>\n<p>repository：git库相关操作，基本意思就是字面意思。</p>\n<ul><li>1）资源管理器中浏览该Git库工作空间文件，省去查找路径不断点击鼠标的操作。</li><li>2）启动Git bash工具（命令行工具）。</li><li>3）查看当前分支文件状态，不包括未提交的信息。</li><li>4）查看某个分支的文件（弹出框中可选择需要查看的版本、分支或标签），跟上一条差不多，用的比较少，可能是没有这方面的额需求。</li><li>5）可视化当前分支历史、可视化所有分支历史：弹出分支操作历史，也就是gitk工具，放到<br/> gitk工具中介绍。</li><li>edit：用于操作commit时操作信息输入，只能操作文字输入部分，你没有看错。常用的快捷键大家都知道，何必要单独做成基本没啥用的。本来以为对变更的文件进行批量操作、本来以为可以对未版本跟踪的文件批量删除、本来、、、，都说了是本来。</li><li>Branch：新建分支（需要选择其实版本，可以根据版本号、其他分支或标签来选择）、检出分支（觉得切换分支更合适）、重命名分支、删除分支、当前分支Reset操作（会丢弃所有未提交的变更，包括工作区和索引区，当然了，有弹出框提示危险操作）。</li></ul>\n<h2><a id=\"35Promsieall____693\"></a>35、Promsie.all() 使用过吗, 它是怎么使用的 ?</h2>\n<pre><code class=\"prism language-bash\">   promise.all<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>用于一个异步操作需要在几个异步操作完成后再进行时使用。\n\n   promise.all<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>接受一个promise对象组成的数组参数，返回promise对象。\n\n   当数组中所有promise都完成了，就执行当前promise对象的then方法，如果数组中有一个promise执行失败了，就执行当前promise对象的catch方法。\n</code></pre>\n<h2><a id=\"36__702\"></a>36、什么是三次握手和四次挥手 ?</h2>\n<p>三次握手是网络客户端跟网络服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的3个步骤。</p>\n<ul><li>第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；</li><li>第二次握手是服务器端表示接收到连接请求报文，并回传规定的数据包；</li><li>第三次握手是客户端接收到服务器回传的数据包后，给服务器端再次发送数据包。这样就完成了客户端跟服务器的连接和数据传送。</li></ul>\n<p>四次挥手表示当前这次连接请求已经结束，要断开这次连接。</p>\n<ul><li>第一次挥手是客户端对服务器发起断开请求，</li><li>第二次握手是服务器表示收到这次断开请求，</li><li>第三次握手是服务器表示已经断开连接</li><li>第四次握手是客户端断开连接。</li></ul>\n<h2><a id=\"37for_in__for_of___715\"></a>37、for in 和 for of 循环的区别 ?</h2>\n<pre><code class=\"prism language-bash\">   <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token keyword\">for</span> <span class=\"token keyword\">in</span><span class=\"token variable\">`</span></span> 用于遍历对象的键<span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">`</span>key<span class=\"token variable\">`</span></span><span class=\"token punctuation\">)</span>，<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token keyword\">for</span> <span class=\"token keyword\">in</span><span class=\"token variable\">`</span></span>会遍历所有自身的和原型链上的可枚举属性。如果是数组，for in会将数组的索引<span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span>当做对象的key来遍历，其他的object也是一样的。\n</code></pre>\n<pre><code class=\"prism language-bash\">   <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token keyword\">for</span> of<span class=\"token variable\">`</span></span>是<span class=\"token variable\"><span class=\"token variable\">`</span>es6<span class=\"token variable\">`</span></span>引入的语法，用于遍历 所有迭代器iterator，其中包括<span class=\"token variable\"><span class=\"token variable\">`</span>HTMLCollection<span class=\"token variable\">`</span></span>,<span class=\"token variable\"><span class=\"token variable\">`</span>NodeList<span class=\"token variable\">`</span></span>,<span class=\"token variable\"><span class=\"token variable\">`</span>Array<span class=\"token variable\">`</span></span>，<span class=\"token variable\"><span class=\"token variable\">`</span>Map<span class=\"token variable\">`</span></span>，<span class=\"token variable\"><span class=\"token variable\">`</span>Set<span class=\"token variable\">`</span></span>，<span class=\"token variable\"><span class=\"token variable\">`</span>String<span class=\"token variable\">`</span></span>，<span class=\"token variable\"><span class=\"token variable\">`</span>TypedArray<span class=\"token variable\">`</span></span>，<span class=\"token variable\"><span class=\"token variable\">`</span>arguments<span class=\"token variable\">`</span></span>等对象的值<span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">`</span>item<span class=\"token variable\">`</span></span><span class=\"token punctuation\">)</span>。\n</code></pre>\n<h2><a id=\"38asyncawait___723\"></a>38、async/await 怎么抛出错误异常 ?</h2>\n<pre><code class=\"prism language-bash\">  如果可能出错的代码比较少的时候可以使用try/catch结构来了处理，如果可能出错的代码比较多的时候，可以利用async函数返回一个promise对象的原理来处理，给async修饰的函数调用后返回的promise对象，调用catch方法来处理异常。\n</code></pre>\n<h2><a id=\"39___727\"></a>39、 函数式编程和命令式编程的区别 ?</h2>\n<ul><li>命令式编程(过程式编程) :</li></ul>\n<pre><code class=\"prism language-bash\">   专注于”如何去做”，这样不管”做什么”，都会按照你的命令去做。解决某一问题的具体算法实现。\n</code></pre>\n<ul><li>函数式编程：把运算过程尽量写成一系列嵌套的函数调用。</li></ul>\n<pre><code class=\"prism language-bash\">     函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 \n     所谓”副作用”，指的是函数内部与外部交互（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n</code></pre>\n<h2><a id=\"40http___739\"></a>40、http 常见的响应状态码 ?</h2>\n<pre><code class=\"prism language-bash\">   <span class=\"token number\">100</span>——客户必须继续发出请求\n   <span class=\"token number\">101</span>——客户要求服务器根据请求转换HTTP协议版本\n   <span class=\"token number\">200</span>——交易成功\n   <span class=\"token number\">201</span>——提示知道新文件的URL\n   <span class=\"token number\">202</span>——接受和处理、但处理未完成\n   <span class=\"token number\">203</span>——返回信息不确定或不完整\n   <span class=\"token number\">204</span>——请求收到，但返回信息为空\n   <span class=\"token number\">205</span>——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n   <span class=\"token number\">206</span>——服务器已经完成了部分用户的GET请求\n   <span class=\"token number\">300</span>——请求的资源可在多处得到\n   <span class=\"token number\">301</span>——删除请求数据\n   <span class=\"token number\">302</span>——在其他地址发现了请求数据\n   <span class=\"token number\">303</span>——建议客户访问其他URL或访问方式\n   <span class=\"token number\">304</span>——客户端已经执行了GET，但文件未变化\n   <span class=\"token number\">305</span>——请求的资源必须从服务器指定的地址得到\n   <span class=\"token number\">306</span>——前一版本HTTP中使用的代码，现行版本中不再使用\n   <span class=\"token number\">307</span>——申明请求的资源临时性删除\n   <span class=\"token number\">400</span>——错误请求，如语法错误\n   <span class=\"token number\">401</span>——请求授权失败\n   <span class=\"token number\">402</span>——保留有效ChargeTo头响应\n   <span class=\"token number\">403</span>——请求不允许\n   <span class=\"token number\">404</span>——没有发现文件、查询或URl\n   <span class=\"token number\">405</span>——用户在Request-Line字段定义的方法不允许\n   <span class=\"token number\">406</span>——根据用户发送的Accept拖，请求资源不可访问\n   <span class=\"token number\">407</span>——类似401，用户必须首先在代理服务器上得到授权\n   <span class=\"token number\">408</span>——客户端没有在用户指定的饿时间内完成请求\n   <span class=\"token number\">409</span>——对当前资源状态，请求不能完成\n   <span class=\"token number\">410</span>——服务器上不再有此资源且无进一步的参考地址\n   <span class=\"token number\">411</span>——服务器拒绝用户定义的Content-Length属性请求\n   <span class=\"token number\">412</span>——一个或多个请求头字段在当前请求中错误\n   <span class=\"token number\">413</span>——请求的资源大于服务器允许的大小\n   <span class=\"token number\">414</span>——请求的资源URL长于服务器允许的长度\n   <span class=\"token number\">415</span>——请求资源不支持请求项目格式\n   <span class=\"token number\">416</span>——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n   <span class=\"token number\">417</span>——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求\n   <span class=\"token number\">500</span>——服务器产生内部错误\n   <span class=\"token number\">501</span>——服务器不支持请求的函数\n   <span class=\"token number\">502</span>——服务器暂时不可用，有时是为了防止发生系统过载\n   <span class=\"token number\">503</span>——服务器过载或暂停维修\n   <span class=\"token number\">504</span>——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长\n   <span class=\"token number\">505</span>——服务器不支持或拒绝支请求头中指定的HTTP版本\n</code></pre>\n<h2><a id=\"41___783\"></a>41、 什么是事件流以及事件流的传播机制 ?</h2>\n<p>事件触发后，从开始找目标元素，然后执行目标元素的事件，再到离开目标元素的整个过程称之为事件流。</p>\n<p>W3C标准浏览器事件流的传播分为3个阶段：捕获阶段、目标阶段、冒泡阶段</p>\n<ul><li> <p>捕获阶段指找目标元素的过程，这个找的过程，是从最大的document对象到html，再到body，。。。直到目标元素。</p> </li><li> <p>找到目标元素后，调用执行他绑定事件时对应的处理函数，这个过程被称之为目标阶段。</p> </li><li> <p>当目标元素的事件执行结束后，再从目标元素，到他的父元素。。。body、html再到document的过程，是冒泡阶段。</p> </li></ul>\n<h2><a id=\"42__commonJS_AMD_CMD_ES6_Module_795\"></a>42、模块化语法 ? commonJS AMD CMD ES6 Module</h2>\n<ul><li> <p>commonJS是nodejs自带的一种模块化语法，将一个文件看做是一个模块，可以将文件中导出的时候，被另一个文件导入使用。导出使用：<code>module.exports</code>导出。导入使用：<code>require</code>函数导入。</p> </li><li> <p>AMD是社区开发的模块化语法，需要依赖<code>require.js</code>实现，分为定义模块，导出数据和导入模块，使用数据。AMD语法的导入是依赖前置的，也就是说，需要用到的文件需要在第一次打开页面全部加载完成，造成的后果就是首屏加载很慢，后续操作会很流畅。</p> </li><li> <p>CMD是玉伯开发的模块化语法，需要依赖<code>sea.js</code>实现，也分为模块定义导出，和模块导入使用数据。CMD语法可以依赖前置，也可以按需导入，缓解了AMD语法的依赖前置。</p> </li><li> <p>ES6的模块化语法，类似于commonJS的语法，分为数据导出和数据导入，导入导出更加灵活。</p> </li></ul>\n<h2><a id=\"43___805\"></a>43、 什么是懒加载和预加载 ?</h2>\n<ul><li> <p>懒加载：懒加载也叫延迟加载，延迟加载网络资源或符合某些条件时才加载资源。常见的就是图片延时加载。<br/> 懒加载的意义：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br/> 懒惰实现方式：</p>\n<ul><li>1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.</li><li>2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</li><li>3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。</li></ul> </li><li> <p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p> </li></ul>\n<p>两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。预加载应用如广告弹窗等。</p>\n<h2><a id=\"44token____cookie___818\"></a>44、token 一般存放在哪里 ? 为什么不存放在 cookie 内 ?</h2>\n<pre><code>token一般放在本地存储中。token的存在本身只关心请求的安全性，而不关心token本身的安全，因为token是服务器端生成的，可以理解为一种加密技术。但如果存在cookie内的话，浏览器的请求默认会自动在请求头中携带cookie，所以容易受到csrf攻击。\n</code></pre>\n<h2><a id=\"45_less__sass___822\"></a>45、 less 和 sass 的区别 ?</h2>\n<ul><li>编译环境不一样，sass是服务器端处理的，可以用Ruby、node-sass来编译；less需要引入less.js来处理输出，也可以使用工具在服务器端处理成css，也有在线编译的。</li><li>变量定义符不一样，less用的是@，而sass用$。</li><li>sass支持分支语句，less不支持</li></ul>\n<h2><a id=\"44__828\"></a>44、浏览器的同源策略机制 ?</h2>\n<pre><code>同源策略，又称SOP，全称Same Origin Policy，是浏览器最基本的安全功能。站在浏览器的较短看网页，如果网络上的接口可以不受限制、无需授权随意被人调用，那将是一个非常严重的混乱场景。浏览器为了安全有序，内部实现了同源策略。\n\n同源策略，指的是浏览器限制当前网页只能访问同源的接口资源。\n\n所谓同源，指当前页面和请求的接口，两方必须是同协议、且同域名、且同端口。只要有一个不相同，则会受到浏览器额约束，不允许请求。\n\n但当一个项目变的很大的时候，将所有内容放在一个网站或一个服务器中会让网站变的臃肿且性能低下，所以，在一些场景中，我们需要跨过同源策略，请求到不同源的接口资源，这种场景叫跨域。\n\n跨域大致有3种方案：\n</code></pre>\n<ul><li> <p>jsonp</p> <p>这种方式是利用浏览器不限制某些标签发送跨域请求，例如link、img、iframe、script。通常请求请求回来的资源要在js中进行处理，所以jsonp跨域是利用script标签进行发送，且这种请求方式只能是get请求。</p> </li><li> <p>cors</p> <p>这种方式是让接口资源方面进行授权，授权允许访问。在接口资源处添加响应头即可通过浏览器的同源策略，响应头具体的键值对如下：</p> <pre><code class=\"prism language-js\"><span class=\"token punctuation\">{<!-- --></span>Access<span class=\"token operator\">-</span>Control<span class=\"token operator\">-</span>Allow<span class=\"token operator\">-</span>Origin<span class=\"token operator\">:</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">}</span>\n</code></pre> </li><li> <p>proxy</p> <p>这种方式属于找外援的一种方式，浏览器只能限制当前正在打开的web页面发送请求，但无法限制服务器端请求接口资源。所以我们可以将请求发送到自己服务器，然后自己服务器去请求目标接口资源，最后自己服务器将接口资源返回给当前页面，类似于找外援代替自己请求目标接口资源。</p> <p>这种方式通常要对服务器进行代理配置，需要对apache服务器、nginx服务器、nodejs服务器进行配置。</p> </li></ul>\n<h2><a id=\"45_______860\"></a>45、 浏览器的缓存有哪些 ? 什么时候使用强制缓存 ? 什么时候使用协商缓存 ?</h2>\n<pre><code>当我们访问同一个页面时，请求资源、数据都是需要一定的耗时，如果可以将一些资源缓存下来，那么从第二次访问开始，就可以减少加载时间，提高用户体验，也能减轻服务器的压力。\n\n浏览器缓存分为强缓存和协商缓存，当存在缓存时，客户端第一次向服务器请求数据时，客户端会缓存到内存或者硬盘当中，当第二次获取相同的资源，强缓存和协商缓存的应对方式有所不同。\n\n强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取。缓存由服务器的响应头里 cache-control 和 expires 两个字段决定\n\n协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求\"询问\"该请求的文件缓存在ben'd与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取。协商缓存由 last-modified 和 etag两个字段决定\n</code></pre>\n<h2><a id=\"46__forEach__map___870\"></a>46、 数组方法 forEach 和 map 的区别 ?</h2>\n<pre><code>forEach和map都是循环遍历数组中的每一项。forEach() 和 map() 里面每一次执行匿名函数都支持3个参数：数组中的当前项item,当前项的索引index,原始数组input。匿名函数中的this都是指Window。只能遍历数组。\n\n他们的区别是：forEach没有返回值，但map中要有返回值，返回处理后的所有新元素组成的数组。\n</code></pre>\n<h2><a id=\"47_____876\"></a>47、 什么是函数作用域 ? 什么是作用域链 ?</h2>\n<pre><code>作用域就是在代码执行过程中，形成一个独立的空间，让空间内的变量不会邪泄露在空间外，也让独立空间内的变量函数在独立空间内运行，而不会影响到外部的环境。\n\n作用域分为全局作用域和局部作用域，也就是本来有一个巨大的空间，空间内定义的函数内部，就形成了一个独立的小空间，全局作用域是最大的作用域。\n\n但是当独立空间内的数据不能满足需求时，是可以从外部获取数据的，也就是说这样的独立空间之间是可以有层级关系的，外部的空间不可以从内部的空间获取数据，但内部的空间可以。当子级空间在父级空间中获取数据的时，父级空间没有的话，父级空间也会到他的父级空间中查找数据，这样形成的链式结构叫作用域链。\n\n当将一个变量当做值使用时，会先在当前作用域中查找这个变量的定义和数据，如果没有定义的话，就会去父级作用域中查找，如果父级作用域中有的话就使用这个值，如果父级作用域中也没有的话，就通过父级作用域查找他的父级作用域，直到找到最大的作用域-全局，如果全局也没有就报错。\n\n当将一个变量当做数据容器存储，也就是给变量赋值的时候，也要先在自己作用域中查找变量的定义，如果没有就在上一级作用域中查找，直到全局，如果全局作用域中也没有这个变量的定义，就在全局定义这个变量并赋值。\n</code></pre>\n<h2><a id=\"48_ES6__Set__Map___888\"></a>48、 ES6 中 Set 和 Map 的原理 ?</h2>\n<pre><code>Set 是无重复值的有序列表。根据 `Object.is()`方法来判断其中的值不相等，以保证无重复。 Set 会自动移除重复的值，因此你可以使用它来过滤数组中的重复值并返回结果。 Set并不是数组的子类型，所以你无法随机访问其中的值。但你可以使用`has()` 方法来判断某个值是否存在于 Set 中，或通过 `size` 属性来查看其中有多少个值。 Set 类型还拥有`forEach()`方法，用于处理每个值\n\nMap 是有序的键值对，其中的键允许是任何类型。与 Set 相似，通过调用 `Object.is()`方法来判断重复的键，这意味着能将数值 5 与字符串 \"5\" 作为两个相对独立的键。使用`set()` 方法能将任何类型的值关联到某个键上，并且该值此后能用 `get()` 方法提取出来。Map 也拥有一个 `size` 属性与一个 `forEach()` 方法，让项目访问更容易。\n</code></pre>\n<h2><a id=\"49_01__02__03___894\"></a>49、 0.1 + 0.2 为什么不等于 0.3, 在项目中遇到要怎么处理 ?</h2>\n<pre><code>计算机内部存储数据使用2进制存储，两个数字进行的数学运算，首先是将这两个数字以2进制形式，存储在计算机内部，然后在计算机内部使用两个2进制数字进行计算，最后将计算结果的2进制数字转为10进制展示出来。\n\n由于10进制的小数在转2进制的时候，规则是小数部分乘以2，判断是否得到一个整数，如果得到整数，转换完成；如果没有得到整数，则继续乘以2判断。所以，0.1和0.2在转换2进制的时候，其实是一个无限死循环，也就是一直乘以2没有得到整数的时候，但计算机内部对于无线死循环的数据，会根据一个标准保留52位。也就是说，计算机内部在存储0.1和0.2的时候，本来就不精准，两个不精准的小数在计算后，距离精准的结果是有一定误差的。\n\n项目中碰到这种情况，有3种处理方法：\n</code></pre>\n<ul><li>将小数乘以10的倍数，转为整数，然后计算，计算完成后，再缩小10的倍数，例如：</li></ul>\n<pre><code class=\"prism language-bash\">      var result <span class=\"token operator\">=</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span><span class=\"token number\">0.1</span> <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.2</span> <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">))</span></span> / <span class=\"token number\">10</span>\n      // result <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token number\">0.3</span>\n</code></pre>\n<p>​</p>\n<ul><li>使用数字的toFixed方法，强制保留小数点后多少位，例：</li></ul>\n<pre><code class=\"prism language-bash\">      var result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span> + <span class=\"token number\">0.2</span><span class=\"token punctuation\">)</span>.toFixed<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n      // result <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token number\">0.30</span>\n</code></pre>\n<p>​</p>\n<ul><li>自定义数字运算方法，当需要进行数学运算的时候，不直接进行，调用自定义的方法进行，例：（加法封装）</li></ul>\n<pre><code class=\"prism language-bash\">  <span class=\"token keyword\">function</span> add<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var num <span class=\"token operator\">=</span> args.find<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n              if<span class=\"token punctuation\">(</span>item <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n              \t throw new Error<span class=\"token punctuation\">(</span><span class=\"token string\">\"数学运算要使用数字\"</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n          var arr <span class=\"token operator\">=</span> args.map<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n              var index <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>item+<span class=\"token string\">''</span><span class=\"token punctuation\">)</span>.indexOf<span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span>\n              if<span class=\"token punctuation\">(</span>index <span class=\"token operator\">&gt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                  <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">(</span>item+<span class=\"token string\">''</span><span class=\"token punctuation\">)</span>.split<span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>.length\n              <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n          arr <span class=\"token operator\">=</span> arr.filter<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> item<span class=\"token punctuation\">)</span>\n          if<span class=\"token punctuation\">(</span>arr.length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n              var max <span class=\"token operator\">=</span> Math.max<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.arr<span class=\"token punctuation\">)</span>\n              var data <span class=\"token operator\">=</span> args.map<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> item * Math.pow<span class=\"token punctuation\">(</span><span class=\"token number\">10</span>, max<span class=\"token punctuation\">))</span>\n              var data.reduce<span class=\"token punctuation\">((</span>a, b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> a + b<span class=\"token punctuation\">)</span> / Math.pow<span class=\"token punctuation\">(</span><span class=\"token number\">10</span>, max<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>else<span class=\"token punctuation\">{<!-- --></span>\n              var data <span class=\"token operator\">=</span> args\n              <span class=\"token builtin class-name\">return</span> data.reduce<span class=\"token punctuation\">((</span>a, b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> a + b<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      // 调用使用：\n      var num1 <span class=\"token operator\">=</span> add<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span>, <span class=\"token number\">0.2</span><span class=\"token punctuation\">)</span>\n      console.log<span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token number\">0.3</span>\n      \n      var num2 <span class=\"token operator\">=</span> add<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>, <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n      console.log<span class=\"token punctuation\">(</span>num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token number\">3</span>\n      \n      var num3 <span class=\"token operator\">=</span> add<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>, <span class=\"token number\">2.1</span><span class=\"token punctuation\">)</span>\n      console.log<span class=\"token punctuation\">(</span>num3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token number\">3.1</span>\n</code></pre>\n<p>​</p>\n<h2><a id=\"50___957\"></a>50、 什么是模块化思想 ?</h2>\n<pre><code>就是JS中将不同功能的代码封装在不同的文件中, 再互相引用时不会发生命名冲突的一种思想, 大多数情况下, 一个文件就是一个模块\n\n模块化的实现，有多种方案：\n</code></pre>\n<ul><li> <p>CommonJS：</p> <p><code>CommonJS</code>是<code>nodejs</code>中使用的模块化规范<br/> 在 <code>nodejs</code> 应用中每个文件就是一个模块，拥有自己的作用域，文件中的变量、函数都是私有的，与其他文件相隔离。模块导出：<code>module.exports=数据</code>，模块导入：<code>require('模块文件路径')</code></p> </li><li> <p>ES6的模块化：</p> <p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p> <p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p> </li><li> <p>AMD （Asynchronous Module Definition）：</p> <p>特点: 提倡依赖前置，在定义模块的时候就要声明其依赖的模块：导入模块<code>require([module],callback);</code>定义模块：<code>define('模块名称', 函数)</code>。</p> </li><li> <p>CMD (Common Module Definition)：</p> <p>CMD规范是国内SeaJS的推广过程中产生的。提倡就近依赖（按需加载），在用到某个模块的时候再去require。定义模块：<code>define(function (require, exports, module) {})</code>，使用模块：<code>seajs.use() </code></p> </li></ul>\n<h2><a id=\"51_js__982\"></a>51、 说说怎么用js 写无缝轮播图</h2>\n<pre><code>将所有需要轮播的内容动态复制一份，放在原本的容器中，加定时器让整个容器中的内容滚动轮播，当内容轮播到left值为-原本的内容宽度时，快速将内容切换到left值为0的状态。\n</code></pre>\n<h2><a id=\"52_JS___986\"></a>52、 JS 如何实现多线程 ?</h2>\n<pre><code>我们都知道JS是一种单线程语言，即使是一些异步的事件也是在JS的主线程上运行的（具体是怎么运行的，可以看我另一篇博客JS代码运行机制）。像setTimeout、ajax的异步请求，或者是dom元素的一些事件，都是在JS主线程执行的，这些操作并没有在浏览器中开辟新的线程去执行，而是当这些异步操作被操作时或者是被触发时才进入事件队列，然后在JS主线程中开始运行。\n\n首先说一下浏览器的线程，浏览器中主要的线程包括，UI渲染线程，JS主线程，GUI事件触发线程，http请求线程。\n\nJS作为脚本语言，它的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。（这里这些问题我们不做研究）\n\n但是单线程的语言，有一个很致命的确定。如果说一个脚本语言在执行时，其中某一块的功能在执行时耗费了大量的时间，那么就会造成阻塞。这样的项目，用户体验是非常差的，所以这种现象在项目的开发过程中是不允许存在的。\n\n其实JS为我们提供了一个Worker的类，它的作用就是为了解决这种阻塞的现象。当我们使用这个类的时候，它就会向浏览器申请一个新的线程。这个线程就用来单独执行一个js文件。\n</code></pre>\n<pre><code class=\"prism language-bash\">    var worker <span class=\"token operator\">=</span> new Worker<span class=\"token punctuation\">(</span>js文件路径<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code>那么这个语句就会申请一个线程用来执行这个js文件。这样也就实现了js的多线程。\n</code></pre>\n<h2><a id=\"53___1004\"></a>53、 闭包的使用场景 ?</h2>\n<pre><code>一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。\n\n本来执行过程和词法作用域是封闭的，这种返回的函数就好比是一个虫洞，开了挂。\n\n闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。\n</code></pre>\n<ul><li>防抖：</li></ul>\n<pre><code class=\"prism language-bash\">    <span class=\"token keyword\">function</span> debounce<span class=\"token punctuation\">(</span>fn, interval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token builtin class-name\">let</span> timer <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> // 定时器\n        <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            // 清除上一次的定时器\n            clearTimeout<span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            // 拿到当前的函数作用域\n            <span class=\"token builtin class-name\">let</span> _this <span class=\"token operator\">=</span> this<span class=\"token punctuation\">;</span>\n            // 拿到当前函数的参数数组\n            <span class=\"token builtin class-name\">let</span> args <span class=\"token operator\">=</span> Array.prototype.slice.call<span class=\"token punctuation\">(</span>arguments, <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            // 开启倒计时定时器\n            timer <span class=\"token operator\">=</span> setTimeout<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                // 通过apply传递当前函数this，以及参数\n                fn.apply<span class=\"token punctuation\">(</span>_this, args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                // 默认300ms执行\n            <span class=\"token punctuation\">}</span>, interval <span class=\"token operator\">||</span> <span class=\"token number\">300</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>节流：</li></ul>\n<pre><code class=\"prism language-bash\">    <span class=\"token keyword\">function</span> throttle<span class=\"token punctuation\">(</span>fn, interval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token builtin class-name\">let</span> timer <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> // 定时器\n        <span class=\"token builtin class-name\">let</span> firstTime <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> // 判断是否是第一次执行\n        // 利用闭包\n        <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            // 拿到函数的参数数组\n            <span class=\"token builtin class-name\">let</span> args <span class=\"token operator\">=</span> Array.prototype.slice.call<span class=\"token punctuation\">(</span>arguments, <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            // 拿到当前的函数作用域\n            <span class=\"token builtin class-name\">let</span> _this <span class=\"token operator\">=</span> this<span class=\"token punctuation\">;</span>\n            // 如果是第一次执行的话，需要立即执行该函数\n            if<span class=\"token punctuation\">(</span>firstTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                // 通过apply，绑定当前函数的作用域以及传递参数\n                fn.apply<span class=\"token punctuation\">(</span>_this, args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                // 修改标识为null，释放内存\n                firstTime <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            // 如果当前有正在等待执行的函数则直接返回\n            if<span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">return</span><span class=\"token punctuation\">;</span>\n            // 开启一个倒计时定时器\n            timer <span class=\"token operator\">=</span> setTimeout<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                // 通过apply，绑定当前函数的作用域以及传递参数\n                fn.apply<span class=\"token punctuation\">(</span>_this, args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                // 清除之前的定时器\n                timer <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                // 默认300ms执行一次\n            <span class=\"token punctuation\">}</span>, interval <span class=\"token operator\">||</span> <span class=\"token number\">300</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>迭代器：</li></ul>\n<pre><code class=\"prism language-bash\">    var arr <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'aa'</span>,<span class=\"token string\">'bb'</span>,<span class=\"token string\">'cc'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> incre<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            //这个函数每次被执行都返回数组arr中 i下标对应的元素\n             <span class=\"token builtin class-name\">return</span> arr<span class=\"token punctuation\">[</span>i++<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token string\">'数组值已经遍历完'</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    var next <span class=\"token operator\">=</span> incre<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console.log<span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>//aa\n    console.log<span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>//bb\n    console.log<span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>//cc\n    console.log<span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>//数组值已经遍历完\n</code></pre>\n<ul><li>缓存：</li></ul>\n<pre><code class=\"prism language-bash\">    var <span class=\"token assign-left variable\">fn</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            var <span class=\"token assign-left variable\">cache</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>//缓存对象\n            var <span class=\"token assign-left variable\">calc</span><span class=\"token operator\">=</span>function<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>//计算函数\n                var <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                //求和\n                for<span class=\"token punctuation\">(</span>var <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">+=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token builtin class-name\">return</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n              \n            <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                var args <span class=\"token operator\">=</span> Array.prototype.slice.call<span class=\"token punctuation\">(</span>arguments,0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//arguments转换成数组\n                var <span class=\"token assign-left variable\">key</span><span class=\"token operator\">=</span>args.join<span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//将args用逗号连接成字符串\n                var result , tSum <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                if<span class=\"token punctuation\">(</span>tSum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>//如果缓存有   \n                    console.log<span class=\"token punctuation\">(</span><span class=\"token string\">'从缓存中取：'</span>,cache<span class=\"token punctuation\">)</span>//打印方便查看\n                    result <span class=\"token operator\">=</span> tSum<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>else<span class=\"token punctuation\">{<!-- --></span>\n                    //重新计算，并存入缓存同时赋值给result\n                    result <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>calc<span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    console.log<span class=\"token punctuation\">(</span><span class=\"token string\">'存入缓存：'</span>,cache<span class=\"token punctuation\">)</span>//打印方便查看\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token builtin class-name\">return</span> result<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fn<span class=\"token punctuation\">(</span><span class=\"token number\">1,2</span>,3,4,5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fn<span class=\"token punctuation\">(</span><span class=\"token number\">1,2</span>,3,4,5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fn<span class=\"token punctuation\">(</span><span class=\"token number\">1,2</span>,3,4,5,6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fn<span class=\"token punctuation\">(</span><span class=\"token number\">1,2</span>,3,4,5,8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fn<span class=\"token punctuation\">(</span><span class=\"token number\">1,2</span>,3,4,5,6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>getter和setter：</li></ul>\n<pre><code class=\"prism language-bash\">    <span class=\"token keyword\">function</span> <span class=\"token function-name function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            var <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">'hello'</span>\n            <span class=\"token assign-left variable\">setName</span><span class=\"token operator\">=</span>function<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                name <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token assign-left variable\">getName</span><span class=\"token operator\">=</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token builtin class-name\">return</span> name<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n              \n            //将setName，getName作为对象的属性返回\n            <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">{<!-- --></span>\n                setName:setName,\n                getName:getName\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        var fn1 <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//返回对象，属性setName和getName是两个函数\n        console.log<span class=\"token punctuation\">(</span>fn1.getName<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>//getter\n            fn1.setName<span class=\"token punctuation\">(</span><span class=\"token string\">'world'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//setter修改闭包里面的name\n        console.log<span class=\"token punctuation\">(</span>fn1.getName<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>//getter\n</code></pre>\n<ul><li>柯里化：</li></ul>\n<pre><code class=\"prism language-bash\">    <span class=\"token keyword\">function</span> curryingCheck<span class=\"token punctuation\">(</span>reg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token builtin class-name\">return</span> function<span class=\"token punctuation\">(</span>txt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token builtin class-name\">return</span> reg.test<span class=\"token punctuation\">(</span>txt<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    var hasNumber <span class=\"token operator\">=</span> curryingCheck<span class=\"token punctuation\">(</span>/<span class=\"token punctuation\">\\</span>d+/g<span class=\"token punctuation\">)</span>\n    var hasLetter <span class=\"token operator\">=</span> curryingCheck<span class=\"token punctuation\">(</span>/<span class=\"token punctuation\">[</span>a-z<span class=\"token punctuation\">]</span>+/g<span class=\"token punctuation\">)</span>\n    \n    hasNumber<span class=\"token punctuation\">(</span><span class=\"token string\">'test1'</span><span class=\"token punctuation\">)</span>      // <span class=\"token boolean\">true</span>\n    hasNumber<span class=\"token punctuation\">(</span><span class=\"token string\">'testtest'</span><span class=\"token punctuation\">)</span>   // <span class=\"token boolean\">false</span>\n    hasLetter<span class=\"token punctuation\">(</span><span class=\"token string\">'21212'</span><span class=\"token punctuation\">)</span>      // <span class=\"token boolean\">false</span>\n</code></pre>\n<ul><li>循环中绑定事件或执行异步代码：</li></ul>\n<pre><code class=\"prism language-bash\">    var p1 <span class=\"token operator\">=</span> <span class=\"token string\">\"ss\"</span><span class=\"token punctuation\">;</span>\n    var p2 <span class=\"token operator\">=</span> <span class=\"token string\">\"jj\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> testSetTime<span class=\"token punctuation\">(</span>para1,para2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            console.log<span class=\"token punctuation\">(</span>para1 + <span class=\"token string\">\"-\"</span> + para2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    var <span class=\"token builtin class-name\">test</span> <span class=\"token operator\">=</span> testSetTime<span class=\"token punctuation\">(</span>p1, p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    setTimeout<span class=\"token punctuation\">(</span>test, <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    setTimeout<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        console.log<span class=\"token punctuation\">(</span>p1 + <span class=\"token string\">\"-\"</span> + p2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>,1000<span class=\"token punctuation\">)</span>\n</code></pre>\n<ul><li>单例模式：</li></ul>\n<pre><code class=\"prism language-bash\">    var Singleton <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        var instance<span class=\"token punctuation\">;</span>\n    \n        <span class=\"token keyword\">function</span> <span class=\"token function-name function\">createInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token builtin class-name\">return</span> new Object<span class=\"token punctuation\">(</span><span class=\"token string\">\"I am the instance\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n     \n        <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">{<!-- --></span>\n            getInstance: <span class=\"token function-name function\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    instance <span class=\"token operator\">=</span> createInstance<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token builtin class-name\">return</span> instance<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>​</p>\n<h2><a id=\"54___1201\"></a>54、 常见的兼容问题有哪些 ?</h2>\n<ul><li> <p>获取标签节点：</p> <p>document.getElementsByClassName(‘类名’)在低版本<code>ie</code>中不兼容。解决方法是使用其他方式获取：</p> </li></ul>\n<pre><code class=\"prism language-bash\">      document.getElementById<span class=\"token punctuation\">(</span><span class=\"token string\">'id名'</span><span class=\"token punctuation\">)</span>\n      document.getElementsByTagName<span class=\"token punctuation\">(</span><span class=\"token string\">'标签名'</span><span class=\"token punctuation\">)</span>\n      document.getElementsByName<span class=\"token punctuation\">(</span><span class=\"token string\">'name属性值'</span><span class=\"token punctuation\">)</span>\n      document.querySelector<span class=\"token punctuation\">(</span><span class=\"token string\">'css选择器'</span><span class=\"token punctuation\">)</span>\n      document.querySelectorAll<span class=\"token punctuation\">(</span><span class=\"token string\">'css选择器'</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>​</p>\n<pre><code>* 获取卷去的高度\n</code></pre>\n<pre><code class=\"prism language-bash\">      // 当有文档声明的时候\n      document.documentElement.scrollTop\n      document.documentElement.srollLeft\n      // 没有文档声明的时候\n      document.body.scrollTop\n      document.body.scrollLeft\n</code></pre>\n<pre><code>* 解决办法使用兼容写法：\n</code></pre>\n<pre><code class=\"prism language-bash\">      // 获取\n      var t <span class=\"token operator\">=</span> document.documentElement.scrollTop <span class=\"token operator\">||</span> document.body.scrollTop\n      var l <span class=\"token operator\">=</span> document.documentElement.srollLeft <span class=\"token operator\">||</span> document.body.scrollLeft\n      // 设置\n      document.documentElement.scrollTop <span class=\"token operator\">=</span> document.body.scrollTop <span class=\"token operator\">=</span> 数值\n      document.documentElement.srollLeft <span class=\"token operator\">=</span> document.body.scrollLeft <span class=\"token operator\">=</span> 数值\n</code></pre>\n<p>​</p>\n<ul><li>获取样式</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C标准浏览器\n      window.getComputedStyle<span class=\"token punctuation\">(</span>元素<span class=\"token punctuation\">)</span>\n      // 低版本IE中\n      元素.currentStyle\n</code></pre>\n<ul><li>使用函数封装的方式兼容：</li></ul>\n<pre><code class=\"prism language-bash\">      <span class=\"token keyword\">function</span> getStyle<span class=\"token punctuation\">(</span>ele,attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          if<span class=\"token punctuation\">(</span>window.getComputedStyle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n             <span class=\"token builtin class-name\">return</span> getComputedStyle<span class=\"token punctuation\">(</span>ele<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>attr<span class=\"token punctuation\">]</span>\n          <span class=\"token punctuation\">}</span>else<span class=\"token punctuation\">{<!-- --></span>\n              <span class=\"token builtin class-name\">return</span> ele.currentStyle<span class=\"token punctuation\">[</span>attr<span class=\"token punctuation\">]</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<ul><li>事件侦听器</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      ele.addEventListener<span class=\"token punctuation\">(</span>事件类型,函数<span class=\"token punctuation\">)</span>\n      // 低版本Ie\n      ele.attachEvent<span class=\"token punctuation\">(</span><span class=\"token string\">'on事件类型'</span>,函数<span class=\"token punctuation\">)</span>\n</code></pre>\n<ul><li>使用函数封装的方式解决：</li></ul>\n<pre><code class=\"prism language-bash\">      <span class=\"token keyword\">function</span> bindEvent<span class=\"token punctuation\">(</span>ele,type,handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          if<span class=\"token punctuation\">(</span>ele.addEventListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n              ele.addEventListener<span class=\"token punctuation\">(</span>type,handler<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>else if<span class=\"token punctuation\">(</span>ele.attachEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n              ele.attachEvent<span class=\"token punctuation\">(</span><span class=\"token string\">'on'</span>+type,handler<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>else<span class=\"token punctuation\">{<!-- --></span>\n              ele<span class=\"token punctuation\">[</span><span class=\"token string\">'on'</span>+type<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> handler\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\t\n</code></pre>\n<p>​</p>\n<ul><li>事件解绑</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      ele.removeEventListener<span class=\"token punctuation\">(</span>事件类型,函数<span class=\"token punctuation\">)</span>\n      // 低版本Ie\n      ele.detachEvent<span class=\"token punctuation\">(</span><span class=\"token string\">'on事件类型'</span>,函数<span class=\"token punctuation\">)</span>\n</code></pre>\n<ul><li>使用函数封装的方式解决：</li></ul>\n<pre><code class=\"prism language-bash\">      <span class=\"token keyword\">function</span> unBind<span class=\"token punctuation\">(</span>ele,type,handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          if<span class=\"token punctuation\">(</span>ele.removeEventListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n              ele.removeEventListener<span class=\"token punctuation\">(</span>type,handler<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>else if<span class=\"token punctuation\">(</span>ele.detachEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n              ele.detachEvent<span class=\"token punctuation\">(</span><span class=\"token string\">'on'</span>+type,handler<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>else<span class=\"token punctuation\">{<!-- --></span>\n              ele<span class=\"token punctuation\">[</span><span class=\"token string\">'on'</span>+type<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<ul><li>事件对象的获取</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n      元素.addEventListener<span class=\"token punctuation\">(</span>事件类型,fn<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">function</span> fn<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          \n      <span class=\"token punctuation\">}</span>\n      // 在低版本IE中\n      元素.on事件类型 <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> window.event <span class=\"token punctuation\">}</span>\n      元素.addEventListener<span class=\"token punctuation\">(</span>事件类型,fn<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">function</span> <span class=\"token function-name function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          window.event\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>使用短路运算符解决：</li></ul>\n<pre><code class=\"prism language-bash\">      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var e <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window.event\n      <span class=\"token punctuation\">}</span>\n      元素.addEventListener<span class=\"token punctuation\">(</span>事件类型,fn<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">function</span> fn<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var e <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window.event\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<ul><li>阻止默认行为</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          e.preventDefault<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      // 在低版本IE中\n      元素.on事件类型 <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> window.event.returnValue <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>通过封装函数解决;</li></ul>\n<pre><code class=\"prism language-bash\">      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var e <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window.event\n          e.preventDefault?e.preventDefault<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>:e.returnValue<span class=\"token operator\">=</span>false\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<ul><li>阻止事件冒泡</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          e.stopPropagation<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      // 在低版本IE中\n      元素.on事件类型 <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> window.event.cancelBubble <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>通过函数封装解决：</li></ul>\n<pre><code class=\"prism language-bash\">      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var e <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window.event\n          e.stopPropagation?e.stopPropagation<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>:e.cancelBubble<span class=\"token operator\">=</span>true\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<ul><li>获取精准的目标元素</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          e.target\n      <span class=\"token punctuation\">}</span>\n      // 在低版本IE中\n      元素.on事件类型 <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> window.event.srcElement <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>通过短路运算符解决：</li></ul>\n<pre><code class=\"prism language-bash\">      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var e <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window.event\n          var target <span class=\"token operator\">=</span> e.target <span class=\"token operator\">||</span> e.srcElement<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<ul><li>获取键盘码</li></ul>\n<pre><code class=\"prism language-bash\">      // W3C浏览器\n      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          e.keyCode\n      <span class=\"token punctuation\">}</span>\n      // 在低版本火狐中\n      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n      \te.which\n      <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>通过短路运算符解决：</li></ul>\n<pre><code class=\"prism language-bash\">      元素.on事件类型 <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          var e <span class=\"token operator\">=</span> e <span class=\"token operator\">||</span> window.event\n          var keycode <span class=\"token operator\">=</span> e.keyCode <span class=\"token operator\">||</span> e.which<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\t\n</code></pre>\n<h2><a id=\"55__JS___1434\"></a>55、 在 JS 中如何阻止事件冒泡 ?</h2>\n<p>使用事件对象阻止事件冒泡，以前的w3c浏览器中，使用事件对象的方法阻止：</p>\n<pre><code class=\"prism language-bash\">    事件对象.stopPropagation<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>在ie低版本浏览器中，使用事件对象的属性阻止：</p>\n<pre><code class=\"prism language-bash\">    事件对象.cancelBubble <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n</code></pre>\n<p>现在的w3c浏览器也支持ie低版本浏览器中的写法，所以以前在阻止事件冒泡的时候，需要考虑兼容写法，现在就不需要了，直接用ie低版本浏览器中的写法即可。</p>\n<h2><a id=\"56_var_A__1_5_6_var_B__2_6_7A___B_1449\"></a>56、两个数组 var A = [1, 5, 6]; var B = [2, 6, 7]，实现一个方法，找出仅存在于A 或者 仅 存在于B中的所有数字。</h2>\n<pre><code class=\"prism language-bash\">    <span class=\"token keyword\">function</span> getDiff<span class=\"token punctuation\">(</span>arr, brr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    \t// 仅存在于arr中的内容\n        var onlyArr <span class=\"token operator\">=</span> arr.filter<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token operator\">!</span>brr.some<span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> item <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token function\">v</span><span class=\"token punctuation\">))</span>\n        // 仅存在于brr中的内容\n        var onlyBrr <span class=\"token operator\">=</span> brr.filter<span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token operator\">!</span>arr.some<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">v</span> <span class=\"token operator\">==</span><span class=\"token operator\">=</span> item<span class=\"token punctuation\">))</span>\n        // 需要哪个就返回哪个，或者一起返回\n        <span class=\"token builtin class-name\">return</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token string\">\"仅存在于arr中的内容\"</span><span class=\"token builtin class-name\">:</span> onlyArr,\n            <span class=\"token string\">\"仅存在于brr中的内容\"</span><span class=\"token builtin class-name\">:</span> onlyBrr\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<h2><a id=\"57___class_____1467\"></a>57、 你了解构造函数吗 ? class 是什么 ? 两者有什么区别 ?</h2>\n<pre><code>在es5中构造函数其实就是在定义一个类，可以实例化对象，es6中class其实是构造函数的语法糖。但还是有点区别的：\n</code></pre>\n<ul><li>在class内部和class的方法内部，默认使用严格模式</li><li>class类不存在预解析，也就是不能先调用class生成实例，再定义class类，但是构造函数可以。</li><li>class中定义的方法默认不能被枚举，也就是不能被遍历。</li><li>class必须使用new执行，但是构造函数没有new也可以执行。</li><li>class中的所有方法都没有原型，也就不能被new</li><li>class中继承可以继承静态方法，但是构造函数的继承不能。</li></ul>\n<h2><a id=\"58aa0__a1true___1478\"></a>58、是否存在a的值（a<mark>0 &amp;&amp; a</mark>1）为true 的情况 ?</h2>\n<pre><code class=\"prism language-bash\">    var value <span class=\"token operator\">=</span> -1\n    Object.defineProperty<span class=\"token punctuation\">(</span>window,<span class=\"token string\">'a'</span>,<span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function-name function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token builtin class-name\">return</span> <span class=\"token assign-left variable\">value</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    if<span class=\"token punctuation\">(</span>a<span class=\"token operator\">==</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token operator\">&amp;&amp;</span><span class=\"token assign-left variable\">a</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> // <span class=\"token boolean\">true</span>\n        console.log<span class=\"token punctuation\">(</span><span class=\"token string\">'success'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<h2><a id=\"59for_var_i__0_i__5_i__setTimeoutfunction__consolelogi__1000__01234_1494\"></a>59、for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i); }, 1000); } 要求：输出0，1，2，3，4</h2>\n<pre><code>首先这个面试题考察的是对于js中异步代码以及作用域的理解：\n\njs中常见的异步代码包括定时器和ajax。js执行代码的流程是碰到同步代码就执行，碰到异步就交给浏览器的webAPI处理，当webAPI中的异步该执行时，webAPI会将需要执行的回调函数放在任务队列中，等候执行，所以，js中所有的异步代码总会在所有同步代码执行结束后，再执行任务队列中的代码。\n\n在这个问题中，循环是同步代码，定时器是异步代码，所以整个循环都执行结束以后才会执行定时器代码。\n\nfor循环中使用var定义的变量是全局变量，定时器回调函数中输出变量的时候，根据作用域规则，先在当前作用域中变量i的定义表达式，如果没有找到，就去上一级作用域中找，此时，在局部作用域中没有找到，去上级作用域中，也就是全局找到了，全局中的i，因为循环已经执行结束了，所以i的值是5。\n\n最终，会输出5个5。\n\n其次考察的是对于类似问题的解决方式，间接性判断你是否有过类似情况的开发：\n\n这个问题的解决思路就是让回调函数中输出i的时候，不要去全局中找i，因为全局的i在循环执行结束后已经变成5了，根据这个思路，有2种解决办法：\n</code></pre>\n<ul><li>在异步代码外面嵌套一层函数作用域</li></ul>\n<pre><code class=\"prism language-bash\">       for<span class=\"token punctuation\">(</span>var i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n           <span class=\"token punctuation\">(</span>function<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n               setTimeout<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                   console.log<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">}</span>, <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n           <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>原理是自调用函数会产生作用域，循环5次就会产生5个作用域，每个作用域代码在执行的时候都有形参i传递。所以每个作用域中的i都是不同的，分别是：0 1 2 3 4。当作用域中的异步代码执行的时候，自己作用域中没有i变量的定义，然后上级作用域就是自调用函数的作用域，找到了单独的i。最终可以输出：0 1 2 3 4</p>\n<ul><li>\n<ol start=\"2\"><li>将循环代码中的var换成es6的let</li></ol> </li></ul>\n<pre><code class=\"prism language-bash\">       for<span class=\"token punctuation\">(</span>let i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n           setTimeout<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n               console.log<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n           <span class=\"token punctuation\">}</span>, <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>es6的let自带块级作用域，原理跟第一种解决思路是一样的，转成es5后，代码是一样的。</p>\n<h2><a id=\"60_add_____add123__6__add1234__10_1536\"></a>60、实现一个 add 方法 使计算结果能够满足如下预期： - add(1)(2)(3)() = 6 - add(1,2,3)(4)() = 10</h2>\n<pre><code class=\"prism language-bash\">    <span class=\"token keyword\">function</span> <span class=\"token function\">add</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        if<span class=\"token punctuation\">(</span>args.length <span class=\"token operator\">==</span><span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token builtin class-name\">return</span> -<span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> * args<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> * <span class=\"token number\">2</span> + args<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> * <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>else<span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token builtin class-name\">return</span> -args<span class=\"token punctuation\">[</span>args.length-1<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n        \n    <span class=\"token punctuation\">}</span>\n     \n    <span class=\"token keyword\">function</span> currying <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    \t<span class=\"token builtin class-name\">let</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    \t<span class=\"token builtin class-name\">return</span> <span class=\"token keyword\">function</span> _c <span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.newArgs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    \t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newArgs.length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    \t\t\targs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    \t\t\t\t<span class=\"token punctuation\">..</span>.args,\n    \t\t\t\t<span class=\"token punctuation\">..</span>.newArgs\n    \t\t\t<span class=\"token punctuation\">]</span>\n    \t\t\t<span class=\"token builtin class-name\">return</span> _c\n    \t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n    \t\t\t<span class=\"token builtin class-name\">return</span> fn.apply<span class=\"token punctuation\">(</span>this, args<span class=\"token punctuation\">)</span>\n    \t\t<span class=\"token punctuation\">}</span>\n    \t<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token builtin class-name\">let</span> addCurry <span class=\"token operator\">=</span> currying<span class=\"token punctuation\">(</span>add<span class=\"token punctuation\">)</span>\n    \n    var a <span class=\"token operator\">=</span> addCurry<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console.log<span class=\"token punctuation\">(</span>-a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token number\">10</span>\n    \n    var b <span class=\"token operator\">=</span> addCurry<span class=\"token punctuation\">(</span><span class=\"token number\">1,2</span>,3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console.log<span class=\"token punctuation\">(</span><span class=\"token number\">6</span> - b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token number\">10</span>\n</code></pre>\n<p>​</p>\n<h2><a id=\"61_HTTP_____1573\"></a>61、常见的 HTTP 请求有哪些 ? 他们的区别是什么 ?</h2>\n<p>常见的有5种，分别是GET、HEAD, POST、PUT、 DELETE</p>\n<ul><li>GET：它是最常见的方法，用于获取资源，常用于向服务器查询某些信息。打开网页一般都是用GET方法，因为要从 Web 服务器获取信息</li><li>HEAD：类似于 GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）， 数据被包含在请求体中。POST请求可能会导致新的资源的建立和／或对已有资源的修改。</li><li>PUT：从客户端向服务器传送的数据取代指定文档的内容。</li><li>DELETE：请求服务器删除指定的页面。</li></ul>\n<p>最常见的HTTP请求方法是GET 和 POST。GET一般用于获取／查询资源信息，而POST一般用于更新资源信息。GET和POST的区别：</p>\n<ul><li>GET提交的数据会放在?之后，以问号（？）分割URL 和传输数据，参数之间以＆相连</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制）， 而POST 方法提交的数据大小没有限制。</li><li>GET方式提交数据会带来安全问题，比如一个登录页面通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul>\n<h2><a id=\"62_JS_____1589\"></a>62、 JS 的数据类型有哪些 ? 如何判断数据类型 ?他们的优缺点是什么？</h2>\n<ul><li> <p>typeof 用来检测数据类型的运算符</p> <pre><code>检测的不管是数组还是正则都返回的是\"object\",所以typeof不能判断一个值是否为数组\n</code></pre> </li><li> <p>instanceof/constructor。检测某一个实例是否属于某一个类使用instanceof/constructor可以检测数组和正则</p> <pre><code>用instanceof检测的时候,只要当前的这个类在实例的原型链上(可以通过原型链__proto__找到它),检测出来的结果都是true。\n\n基本数据类型的值是不能用instanceof来检测的\n\n在类的原型继承中,instanceof检测出来的结果其实是不准确的\n</code></pre> </li><li> <p>Object.prototype.toString.call(value) -&gt;找到Object原型上的toString方法,让方法执行,并且让方法中的this变为value(value-&gt;就是我们要检测数据类型的值)。检测的类型比较多，也比较精准。</p> </li></ul>\n<h2><a id=\"63_symbol___1604\"></a>63、 symbol 你是怎么理解的 ?</h2>\n<p><code>Symbol</code> 是 <code>ES6</code> 新推出的一种基本类型，它表示独一无二的值</p>\n<p>它可以选择接受一个字符串作为参数或者不传，但是相同参数的两个<code>Symbol </code>值不相等</p>\n<pre><code class=\"prism language-bash\">    //不传参数\n    const s1 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    const s2 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console.log<span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">==</span><span class=\"token operator\">=</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token boolean\">false</span>\n    \n    // 传入参数\n    const s3 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token string\">'debug'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    const s4 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token string\">'debug'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console.log<span class=\"token punctuation\">(</span>s3 <span class=\"token operator\">==</span><span class=\"token operator\">=</span> s4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // <span class=\"token boolean\">false</span>\n</code></pre>\n<p>可以通过<code>typeof</code>判断是否为<code>Symbol</code>类型</p>\n<pre><code class=\"prism language-bash\">    console.log<span class=\"token punctuation\">(</span>typeof s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // symbol\n</code></pre>\n<p>Symbol.for()：用于将描述相同的<code>Symbol</code>变量指向同一个<code>Symbol</code>值</p>\n<pre><code class=\"prism language-bash\">    <span class=\"token builtin class-name\">let</span> a1 <span class=\"token operator\">=</span> Symbol.for<span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin class-name\">let</span> a2 <span class=\"token operator\">=</span> Symbol.for<span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    a1 <span class=\"token operator\">==</span><span class=\"token operator\">=</span> a2  // <span class=\"token boolean\">true</span>\n    typeof a1  // <span class=\"token string\">\"symbol\"</span>\n    typeof a2  // <span class=\"token string\">\"symbol\"</span>\n    \n    <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">a3</span><span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    a1 <span class=\"token operator\">==</span><span class=\"token operator\">=</span> a3      // <span class=\"token boolean\">false</span>\n</code></pre>\n<p>Symbol.keyFor()：用来检测该字符串参数作为名称的 <code>Symbol </code>值是否已被登记，返回一个已登记的 <code>Symbol</code> 类型值的<code> key</code></p>\n<pre><code class=\"prism language-bash\">    <span class=\"token builtin class-name\">let</span> a1 <span class=\"token operator\">=</span> Symbol.for<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Symbol.keyFor<span class=\"token punctuation\">(</span>a1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    // <span class=\"token string\">\"a\"</span>\n    \n    <span class=\"token builtin class-name\">let</span> a2 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Symbol.keyFor<span class=\"token punctuation\">(</span>a2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    // undefined\n</code></pre>\n<p>description：用来返回<code>Symbol</code>数据的描述：</p>\n<pre><code class=\"prism language-bash\">    // Symbol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>定义的数据\n    <span class=\"token builtin class-name\">let</span> a <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token string\">\"acc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    a.description  // <span class=\"token string\">\"acc\"</span>\n    Symbol.keyFor<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  // undefined\n    \n    // Symbol.for<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>定义的数据\n    <span class=\"token builtin class-name\">let</span> a1 <span class=\"token operator\">=</span> Symbol.for<span class=\"token punctuation\">(</span><span class=\"token string\">\"acc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    a1.description  // <span class=\"token string\">\"acc\"</span>\n    Symbol.keyFor<span class=\"token punctuation\">(</span>a1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  // <span class=\"token string\">\"acc\"</span>\n    \n    // 未指定描述的数据\n    <span class=\"token builtin class-name\">let</span> a2 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    a2.description  // undefined\n</code></pre>\n<ul><li>使用场景一：对象添加属性</li></ul>\n<pre><code class=\"prism language-bash\">    <span class=\"token builtin class-name\">let</span> n <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token string\">'N'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin class-name\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n        name: <span class=\"token string\">\"hello world\"</span>,\n        age: <span class=\"token number\">11</span>,\n        <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>: <span class=\"token number\">100</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n</code></pre>\n<ul><li>使用场景二：给对象添加私有属性</li></ul>\n<pre><code class=\"prism language-bash\">    const speak <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    class Person <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token punctuation\">[</span>speak<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            console.log<span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token builtin class-name\">let</span> person <span class=\"token operator\">=</span> new Person<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console.log<span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">[</span>speak<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span>\n</code></pre>\n<h2><a id=\"64_1695\"></a>64、数组常用方法有那些</h2>\n<p>数组的常用方法 这样的面试题 算是非常基础的面试题 面试官的目的 也不会只是单纯的让你背诵出 数组的所有方法</p>\n<p>这里的关键点 是 常用 这两个字 面试官的 目的是 通过 这个问题 看你平时在项目中 对于 数组函数的应用和理解 然后判断出 你平时在项目中对于数组的应用 然后推测出你真实的技术水平</p>\n<p>这里建议的回答方式是 通过一个 自己用的最多的数组函数方法 深入展开的说一说 在 实际项目中的应用</p>\n<p>例如谈到 数组单元删除 数组,splice() 除了要说 函数的用法之外 还要谈到 具体的项目中 删除数组单元之后 数组坍塌的影响 以及如何处理</p>\n<pre><code class=\"prism language-bash\">concat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 连接两个或更多的数组，并返回结果。\n\njoin<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。\n\npop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 删除并返回数组的最后一个元素。  \n\nshift<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 删除并返回数组的第一个元素\n\npush<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 向数组的末尾添加一个或更多元素，并返回新的长度。\n\nunshift<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 向数组的开头添加一个或更多元素，并返回新的长度。\n\nreverse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 颠倒数组中元素的顺序。\n\nslice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 从某个已有的数组返回选定的元素\n\nsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 对数组的元素进行排序\n\nsplice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 删除元素，并向数组添加新元素。\n\ntoSource<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 返回该对象的源代码。\n\ntoString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 把数组转换为字符串，并返回结果。\n\ntoLocaleString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 把数组转换为本地数组，并返回结果。\n\nvalueOf<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 返回数组对象的原始值\n</code></pre>\n<h2><a id=\"65JavaScriptcookie_1737\"></a>65、JavaScript如何存储cookie</h2>\n<p>基本语法是 document.cookie = ‘键名=键值;expires=时间对象;path=路径’ ;</p>\n<p>时效 如果不设定 默认是 seeion 会话时效<br/> 路径 如果不设定 默认是 当前文件所在文件夹</p>\n<p>设定时效 要 设定一个时间对象 时间对象的时间戳 就是 时效期<br/> 要注意计算 当前时区 和 世界标砖时间的时间差</p>\n<p>路径一般设定为根目录 也就是 ‘/’</p>\n<h2><a id=\"66_1751\"></a>66、柯理化函数</h2>\n<p>所谓的柯里化函数 指的是 把接受多个参数的函数变换成接受一个单一参数的函数 并且返回接受余下的参数而且返回结果的新函数</p>\n<pre><code class=\"prism language-bash\">// 普通的add函数\n<span class=\"token keyword\">function</span> add<span class=\"token punctuation\">(</span>x, y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token builtin class-name\">return</span> x + y\n<span class=\"token punctuation\">}</span>\n\n// Currying后\n<span class=\"token keyword\">function</span> curryingAdd<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token builtin class-name\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token builtin class-name\">return</span> x + y\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nadd<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>, <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>           // <span class=\"token number\">3</span>\ncurryingAdd<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>   // <span class=\"token number\">3</span>\n</code></pre>\n<p>优点:</p>\n<pre><code class=\"prism language-bash\"><span class=\"token number\">1</span>, 参数复用\n\n例如 一个函数 有两个参数 但是第一个参数会被反复使用 每次都需要输入 一个重复的参数\n使用柯里化函数之后 只需要 输入一个参数就可以了 \n\n<span class=\"token number\">2</span>, 提前确认\n\n提前定义好一个参数 也就 决定了整个函数程序的执行方向 避免每次都执行判断比较等\n</code></pre>\n<p>缺点:</p>\n<pre><code class=\"prism language-bash\">只能提前定义一个参数 如果想要提前定义多个参数 这样的语法是不支持\n</code></pre>\n<p>柯里化函数执行效能上的问题:</p>\n<pre><code class=\"prism language-bash\">存取arguments对象通常要比存取命名参数要慢一点\n一些老版本的浏览器在arguments.length的实现上是相当慢的\n使用 函数.apply<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 和 函数.call<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 通常比直接调用 fn<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 稍微慢点\n创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上\n</code></pre>\n<h2><a id=\"67_1810\"></a>67、对象遍历方法</h2>\n<p>JavaScript中 对象的遍历方法</p>\n<pre><code class=\"prism language-bash\">for<span class=\"token punctuation\">..</span>.in \n\n基本语法是 for<span class=\"token punctuation\">(</span> 变量 <span class=\"token keyword\">in</span> 对象 <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> 循环体程序 <span class=\"token punctuation\">}</span>\n\n这里要注意的是 \n<span class=\"token number\">1</span>, 变量中存储的键名 通过键名获取对象中存储的键值\n    因为是变量 点语法取值 不支持解析变量 要使用 对象<span class=\"token punctuation\">[</span>键名<span class=\"token punctuation\">]</span> 获取键值\n\n<span class=\"token number\">2</span>, 循环变量 定义 <span class=\"token builtin class-name\">let</span> 和 var 定义 执行效果是不同的\n</code></pre>\n<pre><code class=\"prism language-bash\">Object.keys<span class=\"token punctuation\">(</span> 对象 <span class=\"token punctuation\">)</span>\n\n返回一个数组 是 当前对象 所有键名组成的数组\n之后再循环遍历这个数组 再执行操作\n</code></pre>\n<pre><code class=\"prism language-bash\">Object.value<span class=\"token punctuation\">(</span> 对象 <span class=\"token punctuation\">)</span>\n\n返回一个数组 是 当前对象 所有键值组成的数组\n之后再循环遍历这个数组 再执行操作\n</code></pre>\n<h2><a id=\"68_1846\"></a>68、数组扁平化</h2>\n<p>数组扁平化</p>\n<p>所谓的数组扁平化就是将多维数组转化为一维数组一般数组扁平化,数组中存储的多维数据都是数组 不会是对象或者函数</p>\n<p>最常用的方法 就是 数组.toString() 将数组转化为字符串<br/> 结果是 获取数组中的每一个单元的数据 组成一个字符串 使用逗号间隔<br/> 再 以逗号为间隔 将字符串 转化为数组</p>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> fun1<span class=\"token punctuation\">(</span> arr <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token builtin class-name\">let</span> str <span class=\"token operator\">=</span> arr.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token builtin class-name\">return</span> str.split<span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>还可以使用 数组.some() 方法 判断数组中是不是还存在数组<br/> 在使用 展开运算符 赋值</p>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> fun1<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>arr.some<span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> Array.isArray<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">))</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>.concat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token builtin class-name\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>另外 ES6 语法中 新增的 flat函数也可以实现数组的扁平化<br/> 参数是固定的</p>\n<pre><code class=\"prism language-bash\">const arr <span class=\"token operator\">=</span> 原始数组.flat<span class=\"token punctuation\">(</span> Infinity <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n</code></pre>\n<h2><a id=\"69typeof__1886\"></a>69、typeof 原理</h2>\n<p>利用 typeof 是根据返回值的结果来判断数据类型</p>\n<p>具体返回值 一共是 number, string, object, boolean, function, undefined</p>\n<p>其中 数组 null 对象 的返回值 都是 object<br/> 这样的话具体的数据类型就不能区分的非常明确 在实际项目中 就不能准确的区分</p>\n<p>如果想要具体的 区分 数据类型 需要使用 Object.prototype.toString.call() 方法 返回值是</p>\n<pre><code class=\"prism language-bash\">object String \t字符串\nobject Number \t数值类型\nobject Boolean \t布尔类型\nobject Undefined \tundefined类型\nobject Null \tnull类型\nobject Function \t函数类型\nobject Array \t数组类型\n</code></pre>\n<h2><a id=\"70_1909\"></a>70、介绍类型转化</h2>\n<p>JavaScript 因为是 弱类型计算机语言 存储数据时 对变量储存的数据类型没有设定<br/> 因此一个变量中可以存储任意类型的数据<br/> 在程序的执行过程中 就会遇到需要数据类型转化的情况</p>\n<pre><code>自动转化\n  自动转化为字符串\n\t数据 直接转化为 对应的字符串\n</code></pre>\n<p>​ <br/> 自动转化为数值类型<br/> 转化为 对应的数值<br/> 1 true<br/> 0 false null “” ‘’</p>\n<pre><code>符合数字规范的字符串\n\t\t\t\t\t转化为 NaN\n          不符合数字规范的字符串\n           undefined\n\n自动转化为数值类型\n            false:\n                0  0.0000  ''   NaN   null     undefined\n            true:\n                其他情况都转化为 true\n</code></pre>\n<p>强制转化</p>\n<pre><code>强制转化为布尔类型\n\nBoolean( 变量 / 表达式 )\n                转化原则 和 自动转化原则完全相同\n                false : 0   0.000   ''    null   NaN  undefined\n                true  : 其他情况都转化为true \n\n    强制转化为字符串类型\n        String( 变量 / 表达式 );\n            转化原则 和 自动转化原则完全相同\n            不会改变 变量中存储的原始数据\n      变量.toString( 进制 ) ;\n            转化原则 和 自动转化原则完全相同\n            不会改变 变量中存储的原始数据\n            如果是 整数类型 可以 设定 转化的进制\n\n            变量 存储 null 或者 undefined不支持\n\n    强制转化为数值类型\n        Number()\n            转化原则 和 自动转化完全相同\n            不会改变 变量中存储的原始内容\n\n        parseInt()\n            从 左侧起 获取符合整数语法规范的内容部分\n            如果 左起第一个字符就不符合整数语法规范 \n            执行结果是 NaN\n\n        parseFloat()\n            从 左侧起 获取符合浮点数语法规范的内容部分\n            如果 左起第一个字符就不符合浮点数语法规范 \n            执行结果是 NaN     \n</code></pre>\n<h2><a id=\"71_1977\"></a>71、执行上下文</h2>\n<p>执行上下文：指当前执行环境中的变量、函数声明，参数（arguments），作用域链，this等信息。分为全局执行上下文、函数执行上下文，其区别在于全局执行上下文只有一个，函数执行上下文在每次调用函数时候会创建一个新的函数执行上下文。</p>\n<p>变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明。</p>\n<p>变量对象式一个抽象的概念，在不同的上下文中，表示不同的对象:</p>\n<p>全局执行上下文的变量对象<br/> 全局执行上下文中，变量对象就是全局对象。<br/> 在顶层js代码中，this指向全局对象，全局变量会作为该对象的属性来被查询。在浏览器中，window就是全局对象。<br/> 函数执行上下文的变量对象<br/> 函数上下文中，变量对象VO就是活动对象AO。<br/> 初始化时，带有arguments属性。<br/> 函数代码分成两个阶段执行<br/> 进入执行上下文时，此时变量对象包括<br/> 形参<br/> 函数声明，会替换已有变量对象<br/> 变量声明，不会替换形参和函数<br/> 函数执行</p>\n<p>执行上下文栈的作用是用来跟踪代码的，由于JS是单线程的，每次只能做一件事情，其他的事情会放在指定的上下文栈中排队等待执行。</p>\n<p>JS解释器在初始化代码的时候，首先会创建一个新的全局执行上下文到执行上下文栈顶中，然后随着每次函数的调用都会创建一个新的执行上下文放入到栈顶中，随着函数执行完毕后被执行上下文栈顶弹出，直到回到全局的执行上下文中。</p>\n<p>首先创建了全局执行上下文，当前全局执行上下文处于活跃状态。<br/> 全局代码中有2个函数 getName 和 getYear，然后调用 getName 函数，JS引擎停止执行全局执行上下文，创建了新的函数执行上下文，且把该函数上下文放入执行上下文栈顶。<br/> getName 函数里又调用了 getYear 函数，此时暂停了 getName 的执行上下文，创建了 getYear 函数的新执行上下文，且把该函数执行上下文放入执行上下文栈顶。<br/> 当 getYear 函数执行完后，其执行上下文从栈顶出栈，回到了 getName 执行上下文中继续执行。<br/> 当 getName 执行完后，其执行上下文从栈顶出栈，回到了全局执行上下文中。</p>\n<h2><a id=\"72_2011\"></a>72、闭包的问题和优化</h2>\n<p>闭包：是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。</p>\n<p>作用：</p>\n<pre><code>1、可以读取函数内部的变量2、相当于划出了一块私有作用域，避免数据污染；3、让变量始终保存在内存中\n</code></pre>\n<p>闭包有三个特性：</p>\n<pre><code>1.函数嵌套函数\n\n2.函数内部可以引用外部的参数和变量\n\n3.参数和变量不会被垃圾回收机制回收\n</code></pre>\n<p>闭包的问题</p>\n<pre><code>闭包会产生不销毁的上下文，会导致栈/堆内存消耗过大，有时候也会导致内存泄漏等，影响页面的运行性能，所以在真实项目中，要合理应用闭包！\n</code></pre>\n<p>闭包的优化</p>\n<p>原始代码</p>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> MyObject<span class=\"token punctuation\">(</span>name, message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  this.name <span class=\"token operator\">=</span> name.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  this.message <span class=\"token operator\">=</span> message.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  this.getName <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token builtin class-name\">return</span> this.name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  this.getMessage <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token builtin class-name\">return</span> this.message<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>优化代码</p>\n<pre><code class=\"prism language-bash\"><span class=\"token keyword\">function</span> MyObject<span class=\"token punctuation\">(</span>name, message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  this.name <span class=\"token operator\">=</span> name.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  this.message <span class=\"token operator\">=</span> message.toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nMyObject.prototype.getName <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token builtin class-name\">return</span> this.name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nMyObject.prototype.getMessage <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token builtin class-name\">return</span> this.message<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"73Node_2068\"></a>73、浏览器和Node事件循环的区别</h2>\n<p>一、全局环境下this的指向</p>\n<pre><code class=\"prism language-bash\"> 在node中this指向global而在浏览器中this指向window，这就是为什么underscore中一上来就定义了一 root；\n\n而且在浏览器中的window下封装了不少的API 比如 alert 、document、location、history 等等还有很多。我门就不能在node环境中xxx<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>或window.xxx<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>了。因为这些API是浏览器级别的封装，存javascript中是没有的。当然node中也提供了不少node特有的API。\n</code></pre>\n<p>二、js引擎</p>\n<pre><code class=\"prism language-bash\">在浏览器中不同的浏览器厂商提供了不同的浏览器内核，浏览器依赖这些内核解释折我们编写的js。但是考虑到不同内核的少量差异，我们需要对应兼容性好在有一些优秀的库帮助我们处理这个问题比如jquery、underscore等等。\n\n　　nodejs是基于Chromes JavaScript runtime，也就是说，实际上它是对GoogleV8引擎（应用于Google Chrome浏览器<span class=\"token punctuation\">)</span>进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。\n\n  NodeJS并不是提供简单的封装，然后提供API调用，如果是这样的话那么它就不会有现在这么火了。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。例如，在服务器环境中，处理二进制数据通常是必不可少的，但Javascript对此支持不足，因此，V8.Node增加了Buffer类，方便并且高效地 处理二进制数据。因此，Node不仅仅简单的使用了V8,还对其进行了优化，使其在各环境下更加给力。\n</code></pre>\n<p>三、DOM操作</p>\n<pre><code class=\"prism language-bash\">浏览器中的js大多数情况下是在直接或间接（一些虚拟DOM的库和框架）的操作DOM。因为浏览器中的代码主要是在表现层工作。但是node是一门服务端技术。没有一个前台页面，所以我门不会再node中操作DOM。\n</code></pre>\n<p>四、I/O读写</p>\n<pre><code class=\"prism language-bash\">与浏览器不同，我们需要像其他服务端技术一样读写文件，nodejs提供了比较方便的组件。而浏览器（确保兼容性的）想在页面中直接打开一个本地的图片就麻烦了好多（别和我说这还不简单，相对路径。。。。。。试试就知道了要么找个库要么二进制流，要么上传上去有了网络地址在显示。不然人家为什么要搞一个js库呢），而这一切node都用一个组件搞定了。\n</code></pre>\n<p>五、模块加载</p>\n<pre><code class=\"prism language-bash\">　javascript有个特点，就是原生没提供包引用的API一次性把要加载的东西全执行一遍，这里就要看各位闭包的功力了。所用东西都在一起，没有分而治之，搞的特别没有逻辑性和复用性。如果页面简单或网站当然我们可以通过一些AMD、CMD的js库（比如requireJS 和 seaJS）搞定事实上很多大型网站都是这么干的。\n\n　　在nodeJS中提供了CMD的模块加载的API，如果你用过seaJS，那么应该上手很快。\n\t\tnode还提供了npm 这种包管理工具，能更有效方便的管理我们饮用的库\n</code></pre>\n<h2><a id=\"74_2119\"></a>74、移动端点击延迟</h2>\n<p>原因 :</p>\n<pre><code class=\"prism language-bash\">为了确定用户是要做单击 还是双击 还是要做其他的操作 因此移动端 当你点击时 会有 <span class=\"token number\">300</span>毫秒延迟 为了等待判断用户的下一步操作是什么\n</code></pre>\n<p>解决方案1</p>\n<pre><code class=\"prism language-bash\">禁用缩放\n\n<span class=\"token operator\">&lt;</span>meta <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"viewport\"</span> <span class=\"token assign-left variable\">content</span><span class=\"token operator\">=</span><span class=\"token string\">\"user-scalable=no\"</span><span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span>meta <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"viewport\"</span> <span class=\"token assign-left variable\">content</span><span class=\"token operator\">=</span><span class=\"token string\">\"initial-scale=1,maximum-scale=1\"</span><span class=\"token operator\">&gt;</span>\n\n\n当HTML文档头部包含以上meta标签时 表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。\n这个方案有一个缺点，就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。但是通常情况下，我们还是希望页面能通过双指缩放来进行缩放操作，比如放大一张图片，放大一段很小的文字。\n</code></pre>\n<p>解决方案2 更改默认的视口宽度</p>\n<pre><code class=\"prism language-bash\">\n\n<span class=\"token operator\">&lt;</span>meta <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"viewport\"</span> <span class=\"token assign-left variable\">content</span><span class=\"token operator\">=</span><span class=\"token string\">\"width=device-width\"</span><span class=\"token operator\">&gt;</span>\n\n一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为设备宽度。因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。\n这个方案相比方案一的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。\n\n\n</code></pre>\n<p>解决方案3 CSS touch-action</p>\n<pre><code class=\"prism language-bash\">跟300ms点击延迟相关的，是touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。\n\n\n最后的最后 我们还可以使用一些 插件来解决这个问题 例如 FastClick 是 FT Labs 专门为解决移动端浏览器 <span class=\"token number\">300</span> 毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。\n\n安装    <span class=\"token function\">npm</span> <span class=\"token function\">install</span> fastclick -S\n\n使用    如何你是vue项目可以在main.js里面直接引入，当然这样是全局的，如果你需要某个页面用到，那就单个页面引入。\n\n//引入\n<span class=\"token function\">import</span> fastClick from <span class=\"token string\">'fastclick'</span>\n//初始化FastClick实例。在页面的DOM文档加载完成后\nfastClick.attach<span class=\"token punctuation\">(</span>document.body<span class=\"token punctuation\">)</span>\n</code></pre>\n<h2><a id=\"75cookie_2177\"></a>75、cookie属性</h2>\n<p>cookie的常见属性</p>\n<pre><code class=\"prism language-bash\">键名 \tcookie键值对的键名\n键值 \tcookie键值对的键值\nexpires\tcookie的时效 分为 session会话时效 时间时效 时间时效是服务器时间也就是世界标准时间\npath\t路径 符合路径的文件才能访问cookie\nhttponly\t设置 为 <span class=\"token boolean\">true</span> 了之后可以防止js程序访问 防止 xss攻击 增加cookie的安全性\nsecure\t设置 为 <span class=\"token boolean\">true</span> 了之后cookie只能通过https协议发送 http协议是不能发送的 这样也是为了增加cookie的安全性\n</code></pre>\n<h2><a id=\"76_2192\"></a>76、反柯里化</h2>\n<p>反柯里化的作用是，当我们调用某个方法，不用考虑这个对象在被设计时，是否拥有这个方法，只要这个方法适用于它，我们就可以对这个对象使用它</p>\n<p>例如</p>\n<pre><code class=\"prism language-bash\">Function.prototype.uncurring <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  var self <span class=\"token operator\">=</span> this<span class=\"token punctuation\">;</span>\n  <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    var obj <span class=\"token operator\">=</span> Array.prototype.shift.call<span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin class-name\">return</span> self.apply<span class=\"token punctuation\">(</span>obj, arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>我们先来看看上面这段代码有什么作用。</p>\n<p>我们要把Array.prototype.push方法转换成一个通用的push函数，只需要这样做：</p>\n<pre><code class=\"prism language-bash\">var push <span class=\"token operator\">=</span> Array.prototype.push.uncurring<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n//测试一下\n<span class=\"token punctuation\">(</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  push<span class=\"token punctuation\">(</span>arguments, <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console.log<span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> //<span class=\"token punctuation\">[</span><span class=\"token number\">1</span>, <span class=\"token number\">2</span>, <span class=\"token number\">3</span>, <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span>, <span class=\"token number\">2</span>, <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>arguments本来是没有push方法的，通常，我们都需要用Array.prototype.push.call来实现push方法，但现在，直接调用push函数，既简洁又意图明了。</p>\n<p>我们不用考虑对象是否拥有这个方法，只要它适用于这个方法，那就可以使用这个方法（类似于鸭子类型）。</p>\n<p>我们来分析一下调用Array.prototype.push.uncurring()这句代码时，发生了什么事情：</p>\n<pre><code class=\"prism language-bash\">Function.prototype.uncurring <span class=\"token operator\">=</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  var self <span class=\"token operator\">=</span> this<span class=\"token punctuation\">;</span>  //self此时是Array.prototype.push\n\n  <span class=\"token builtin class-name\">return</span> <span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    var obj <span class=\"token operator\">=</span> Array.prototype.shift.call<span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    //obj 是<span class=\"token punctuation\">{<!-- --></span>\n    //  <span class=\"token string\">\"length\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token number\">1</span>,\n    //  <span class=\"token string\">\"0\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token number\">1</span>\n    //<span class=\"token punctuation\">}</span>\n    //arguments的第一个对象被截去<span class=\"token punctuation\">(</span>也就是调用push方法的对象<span class=\"token punctuation\">)</span>,剩下<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token builtin class-name\">return</span> self.apply<span class=\"token punctuation\">(</span>obj, arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    //相当于Array.prototype.push.apply<span class=\"token punctuation\">(</span>obj, <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>//测试一下</p>\n<pre><code class=\"prism language-bash\">var push <span class=\"token operator\">=</span> Array.prototype.push.uncurring<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvar obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token string\">\"length\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token number\">1</span>,\n  <span class=\"token string\">\"0\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\npush<span class=\"token punctuation\">(</span>obj, <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole.log<span class=\"token punctuation\">(</span> obj <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> //<span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">0</span>: <span class=\"token number\">1,1</span>: <span class=\"token number\">2</span>, length: <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>看到这里你应该对柯里化和反柯里化有了一个初步的认识了，但要熟练的运用在开发中，还需要我们更深入的去了解它们内在的含义。</p>\n<h2><a id=\"77_2271\"></a>77、千分位</h2>\n<p>这里的需求 本质上是要 将 数字 转化为 带有千分位字符串 方法有很多</p>\n<p>方法1 正则表达式</p>\n<pre><code class=\"prism language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d{1,3}(?=(\\d{3})+$)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> s<span class=\"token operator\">+</span><span class=\"token string\">','</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n\n</code></pre>\n<p>方法2 字符串替换</p>\n<pre><code class=\"prism language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\d{1,3})(?=(\\d{3})+$)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">$1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> $1<span class=\"token operator\">=</span>$1<span class=\"token operator\">+</span><span class=\"token string\">','</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n</code></pre>\n<p>方法3 数字转数组 反转后 添加 , 再反转回来拼接为字符串</p>\n<pre><code class=\"prism language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\d{3})+?</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> s<span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">,$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n</code></pre>\n<p>方法4 利用while循环拼接字符串每隔3个数字加一个分隔符，首尾不加</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">var</span> result<span class=\"token operator\">=</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  len <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>len<span class=\"token operator\">&gt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  index<span class=\"token operator\">%</span><span class=\"token number\">3</span><span class=\"token operator\">===</span><span class=\"token number\">0</span><span class=\"token operator\">&amp;&amp;</span>index<span class=\"token operator\">!==</span><span class=\"token number\">0</span> <span class=\"token operator\">?</span> result<span class=\"token operator\">+=</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>str<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> result<span class=\"token operator\">+=</span>str<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  len<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n  index<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nresult<span class=\"token operator\">=</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>方法5 利用while循环在数组里push分隔符，首尾不加</p>\n<pre><code>// 利用while循环在数组里push分隔符\nvar result=\"\",\n  index = 0,\n  len = str.length,\n  i = len-1,\n  arr = str.split(\"\");\nwhile(len-index&gt;0){\n  len&gt;=index&amp;&amp;len-index!==len &amp;&amp; arr.splice(len-index,0,\",\");\n  index+=3;\n  i-=4;\n};\nconsole.log(arr.join(\"\"));\n</code></pre>\n<h2><a id=\"78loadready_2335\"></a>78、load和ready区别</h2>\n<pre><code>document.ready：\n\n是ready，表示文档结构已经加载完成 不包含图片等非文字媒体文件 只要html标签结构加载完毕就可以；\n\ndocument.load：\n\n是onload，指示页面包含图片等文件在内的所有元素都加载完成。\n</code></pre>\n<p>1、概念</p>\n<p>2、作用</p>\n<pre><code>document.ready：\n\n在DOM加载完成后就可以可以对DOM进行操作。\n\n一般情况一个页面响应加载的顺序是，域名解析-加载html-加载js和css-加载图片等其他信息。\n那么Dom Ready应该在“加载js和css”和“加载图片等其他信息”之间，就可以操作Dom了。\n\ndocument.load：\n\n在document文档加载完成后就可以可以对DOM进行操作，document文档包括了加载图片等其他信息。\n\n那么Dom Load就是在页面响应加载的顺序中的“加载图片等其他信息”之后，就可以操作Dom了。\n\n\n</code></pre>\n<p>3、加载顺序</p>\n<pre><code>document.ready：\n\n文档加载的顺序：域名解析--&gt;加载HTML--&gt;加载JavaScript和CSS--&gt;加载图片等非文字媒体文件。\n\n只要&lt;img&gt;标签加载完成，不用等该图片加载完成，就可以设置图片的属性或样式等。\n\n在原生JavaScript中没有Dom ready的直接方法。\n\ndocument.load：\n\n文档加载的顺序：域名解析--&gt;加载HTML--&gt;加载JavaScript和CSS--&gt;加载图片等非文字媒体文件。\n\nDOM load在加载图片等非文字媒体文件之后，表示在document文档加载完成后才可以对DOM进行操作，document文档包括了加载图片等非文字媒体文件。\n\n例如，需要等该图片加载完成，才可以设置图片的属性或样式等。\n\n在原生JavaScript中使用onload事件。\n</code></pre>\n<h2><a id=\"79_2396\"></a>79、自定义事件</h2>\n<p>自定义事件，就是自己定义事件类型，自己定义事件处理函数。</p>\n<p>我们平时操作dom时经常会用到onclick、onmousemove等浏览器特定行为的事件类型。</p>\n<p>封装is自定义事件基本的构思：</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">var</span> eventTarget <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token function-variable function\">addEvent</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//添加事件</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">fireEvent</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//触发事件</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">removeEvent</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//移除事件</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在js默认事件中事件类型以及对应的执行函数是一一对应的，但是自定义事件，需要一个映射表来建立两者之间的联系。</p>\n<p>如： 这样每个类型可以处理多个事件函数</p>\n<pre><code class=\"prism language-javascript\">handlers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token string-property property\">\"type1\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>\n            <span class=\"token string\">\"fun1\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"fun2\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token comment\">// \"...\"</span>\n         <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n       <span class=\"token string-property property\">\"type2\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>\n            <span class=\"token string\">\"fun1\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"fun2\"</span>\n             <span class=\"token comment\">// \"...\"</span>\n         <span class=\"token punctuation\">]</span>\n         <span class=\"token comment\">//\"...\"</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>代码实现：</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">EventTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//事件处理程序数组集合</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//自定义事件的原型对象</span>\n<span class=\"token class-name\">EventTarget</span><span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//设置原型构造函数链</span>\n    <span class=\"token literal-property property\">constructor</span><span class=\"token operator\">:</span>EventTarget<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">//注册给定类型的事件处理程序</span>\n    <span class=\"token comment\">//type-&gt;自定义事件类型，如click,handler-&gt;自定义事件回调函数</span>\n    <span class=\"token function-variable function\">addEvent</span><span class=\"token operator\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span>handler</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//判断事件处理函数中是否有该类型事件</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\">//触发事件</span>\n    <span class=\"token comment\">//event为一个js对象，属性中至少包含type属性。</span>\n    <span class=\"token function-variable function\">fireEvent</span><span class=\"token operator\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//模拟真实事件的event</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            event<span class=\"token punctuation\">.</span>target<span class=\"token operator\">=</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">//判断是否存在该事件类型</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>event<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">]</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">var</span> items<span class=\"token operator\">=</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>event<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//在同一事件类型下可能存在多个事件处理函数，依次触发</span>\n            <span class=\"token comment\">//执行触发</span>\n            items<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token function\">item</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    \n    <span class=\"token comment\">//删除事件</span>\n    <span class=\"token function-variable function\">removeEvent</span><span class=\"token operator\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span>handler</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//判断是否存在该事件类型</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">var</span> items<span class=\"token operator\">=</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//在同一事件类型下可能存在多个处理事件</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token comment\">//从该类型的事件数组中删除该事件</span>\n                    items<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>    \n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>    \n\n<span class=\"token punctuation\">}</span>\n            \n<span class=\"token comment\">//调用方法</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'执行该方法'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fun1</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'run '</span><span class=\"token operator\">+</span>obj<span class=\"token punctuation\">.</span>min<span class=\"token operator\">+</span><span class=\"token string\">'s'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> target<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">EventTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">addEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"run\"</span><span class=\"token punctuation\">,</span>fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//添加事件</span>\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">addEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"run\"</span><span class=\"token punctuation\">,</span>fun1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//添加事件</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">fireEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span><span class=\"token string\">\"run\"</span><span class=\"token punctuation\">,</span><span class=\"token literal-property property\">min</span><span class=\"token operator\">:</span><span class=\"token string\">\"30\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//执行该方法   123</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">removeEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"run\"</span><span class=\"token punctuation\">,</span>fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//移除事件</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">fireEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span><span class=\"token string\">\"run\"</span><span class=\"token punctuation\">,</span><span class=\"token literal-property property\">min</span><span class=\"token operator\">:</span><span class=\"token string\">\"20\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//123</span>\n\n\n</code></pre>\n<p>为什么要把方法添加到对象原型上？</p>\n<p>在构造函数中加属性，在原型中加方法。</p>\n<p>将属性和方法都写在构造函数里是没有问题的，但是每次进行实例化的过程中，要重复创建功能不变的方法。</p>\n<p>由于方法本质上是函数，其实也就是在堆内存中又新建了一个对象空间存放存储函数，造成了不必要的资源浪费。</p>\n<p>在本身添加会导致每次对象实例化时代码被复制，都需要申请一块内存存放该方法。</p>\n<p>写一个EventEmitter类，包括on()、off()、once()、emit()方法<br/> once()：为指定事件注册一个单次监听器，单次监听器最多只触发一次，触发后立即解除监听器。</p>\n<pre><code class=\"prism language-bash\">class EventEmitter<span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token function-name function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                this.handlers<span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            on<span class=\"token punctuation\">(</span>type,fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                if<span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>this.handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                    this.handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                this.handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span>.push<span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token builtin class-name\">return</span> this<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            off<span class=\"token punctuation\">(</span>type,fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">fns</span><span class=\"token operator\">=</span>this.handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                for<span class=\"token punctuation\">(</span>let <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>fns.length<span class=\"token punctuation\">;</span>i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                    if<span class=\"token punctuation\">(</span>fns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                        fns.splice<span class=\"token punctuation\">(</span>i,1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token builtin class-name\">break</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token builtin class-name\">return</span> this<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            emit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">type</span><span class=\"token operator\">=</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">params</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>.slice.call<span class=\"token punctuation\">(</span>args,1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">fn</span><span class=\"token operator\">=</span>this.handlers<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                fn.forEach<span class=\"token punctuation\">((</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">{<!-- --></span>\n                    item.apply<span class=\"token punctuation\">(</span>this,params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//执行函数\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">return</span> this<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            once<span class=\"token punctuation\">(</span>type,fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">wrap</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.args<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">{<!-- --></span>\n                    fn.apply<span class=\"token punctuation\">(</span>this,args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//执行事件后删除\n                    this.off<span class=\"token punctuation\">(</span>type,wrap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                this.on<span class=\"token punctuation\">(</span>type,wrap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>//再添加上去\n                <span class=\"token builtin class-name\">return</span> this<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n         <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">emitter</span><span class=\"token operator\">=</span>new EventEmitter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function-name function\">fun1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        console.log<span class=\"token punctuation\">(</span><span class=\"token string\">'fun1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function-name function\">fun2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        console.log<span class=\"token punctuation\">(</span><span class=\"token string\">'fun2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function-name function\">fun3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        console.log<span class=\"token punctuation\">(</span><span class=\"token string\">'fun3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    emitter.on<span class=\"token punctuation\">(</span><span class=\"token string\">'TEST1'</span>,fun1<span class=\"token punctuation\">)</span>.on<span class=\"token punctuation\">(</span><span class=\"token string\">'TEST2'</span>,fun2<span class=\"token punctuation\">)</span>.emit<span class=\"token punctuation\">(</span><span class=\"token string\">'TEST1'</span><span class=\"token punctuation\">)</span>.once<span class=\"token punctuation\">(</span><span class=\"token string\">'TEST2'</span>,fun3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    emitter.emit<span class=\"token punctuation\">(</span><span class=\"token string\">\"TEST2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>​</p>\n<h2><a id=\"80setTimeoutsetInterval_2592\"></a>80、setTimeout实现setInterval</h2>\n<pre><code>setTimeout() ：在指定的毫秒数后调用函数或计算表达式，只执行一次。\nsetInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。\n</code></pre>\n<p>思路是使用递归函数，不断地去执行setTimeout从而达到setInterval的效果，看代码</p>\n<pre><code>function mySetInterval(fn, millisec){\n  function interval(){\n    setTimeout(interval, millisec);\n    fn();\n  }\n  setTimeout(interval, millisec)\n}\n\n\n</code></pre>\n<p>这个mySetInterval函数有一个叫做interval的内部函数，它通过setTimeout来自动被调用，在interval中有一个闭包，调用了回调函数并通过setTimeout再次调用了interval。</p>\n<p>一个更好的实现<br/> 我们再增加一个额外的参数用来标明代码执行的次数</p>\n<pre><code>function mySetInterval(fn, millisec,count){\n  function interval(){\n    if(typeof count===‘undefined’||count--&gt;0){\n      setTimeout(interval, millisec);\n      try{\n        fn()\n      }catch(e){\n        count = 0;\n        throw e.toString();\n      }\n    }\n  }\n  setTimeout(interval, millisec)\n}\n</code></pre>\n<h2><a id=\"81_2638\"></a>81、避免回调地狱</h2>\n<p>使用 async await 配合 promise 是 解决回调地狱的终极方法</p>\n<p>async/await特点</p>\n<pre><code>1, async/await更加语义化，async 是“异步”的简写，async function 用于申明一个 function 是异步的； await，可以认为是async wait的简写， 用于等待一个异步方法执行完成；\n\n2, async/await是一个用同步思维解决异步问题的方案（等结果出来之后，代码才会继续往下执行）\n\n3, 可以通过多层 async function 的同步写法代替传统的callback嵌套\n</code></pre>\n<p>async function语法</p>\n<pre><code>1, 自动将常规函数转换成Promise，返回值也是一个Promise对象\n\n2, 只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数\n\n3, 异步函数内部可以使用await\n</code></pre>\n<p>await语法</p>\n<pre><code>1, await 放置在Promise调用之前，await 强制后面点代码等待，直到Promise对象resolve，得到resolve的值作为await表达式的运算结果\n\n2. await只能在async函数内部使用,用在普通函数里就会报错\n</code></pre>\n<p>函数形式</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ms</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//reject模拟出错，返回error</span>\n\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">asyncPrint</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ms</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{<!-- --></span>\n\n     console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'start'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n     <span class=\"token keyword\">await</span> <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span>ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//这里返回了错误</span>\n    \n     console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//所以这句代码不会被执行了</span>\n\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\n     console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//这里捕捉到错误error</span>\n\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"82calleecaller_2704\"></a>82、callee和caller的作用</h2>\n<p>caller返回一个函数的引用，这个函数调用了当前的函数;callee放回正在执行的函数本身的引用，它是arguments的一个属性</p>\n<p>caller<br/> caller返回一个函数的引用，这个函数调用了当前的函数。<br/> 使用这个属性要注意:<br/> 1 这个属性只有当函数在执行时才有用<br/> 2 如果在javascript程序中，函数是由顶层调用的，则返回null</p>\n<pre><code>functionName.caller: functionName是当前正在执行的函数。\nvar a = function() { \n    alert(a.caller); \n} \nvar b = function() { \n    a(); \n} \nb();\n</code></pre>\n<p>上面的代码中，b调用了a，那么a.caller返回的是b的引用，结果如下:</p>\n<pre><code>var b = function() { \n    a(); \n} \n</code></pre>\n<p>如果直接调用a(即a在任何函数中被调用，也就是顶层调用),返回null:</p>\n<pre><code>var a = function() { \n    alert(a.caller); \n} \nvar b = function() { \n    a(); \n} \n//b(); \na();\n输出结果:\nnull\n</code></pre>\n<p>callee<br/> callee放回正在执行的函数本身的引用，它是arguments的一个属性<br/> 使用callee时要注意:</p>\n<pre><code>1 这个属性只有在函数执行时才有效\n\n2 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length\n\n3 它可以用来递归匿名函数。\n\nvar a = function() { \n    alert(arguments.callee); \n} \nvar b = function() { \n    a(); \n} \nb();\n\n\na在b中被调用，但是它返回了a本身的引用，结果如下:\n\nvar a = function() { \n    alert(arguments.callee); \n} \n</code></pre>\n<h2><a id=\"83_2781\"></a>83、统计字符串中字母个数或统计最多的字母数</h2>\n<p>统计字母出现的次数</p>\n<pre><code>function count( str ){\n    var obj={};\n    for(var i=0;i&lt;str.length; i++){\n        if(obj[ str[i] ]==undefined){  \n            //对象初始化；如果key在对象中找不到，那么会返回undefined,反向思维\n            obj[ str[i] ]= 1;\n        } else{\n            obj[ str[i] ]++;\n        }\n    }\n\n    //取出各个字母和它的个数，作为一个新对象保存在obj对象中\n    return obj;  \n\n}\n\ncosnle.log( count( \"shhkfahkahsadhadskhdskdha\" ) );\n\n\n</code></pre>\n<p>统计字符出现次数最多的字母</p>\n<pre><code>function allProMax(obj){\n    var mm=\"\";\n    for(var m in obj){\n        if(mm==\"\"){\n            mm=new Object();\n            mm[m]=obj[m];\n        }else{\n            for(var j in mm){\n               if(mm[j]&lt;obj[m]){\n                   //清空原来的内容\n                   mm=new Object();\n                   //放入新的内容\n                   mm[m]=obj[m];\n               }\n            }\n        }\n    }\n    return mm ;\n}\n\nconsole.log( allProMax(count()) )\n</code></pre>\n<h2><a id=\"84_2835\"></a>84、面对对象和面向过程的区别</h2>\n<pre><code>一、面向对象与面向过程的区别\n面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。\n\n可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。\n\n如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。\n\n可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。\n\n上述的内容是从网上查到的，觉得这个例子非常的生动形象，我就写了下来，现在就应该理解了他俩的区别了吧，其实就是两句话，面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！\n\n二、面向对象的特点\n在了解其特点之前，咱们先谈谈对象，对象就是现实世界存在的任何事务都可以称之为对象，有着自己独特的个性\n\n1, 概念 对 具有相同特性的一类事物的抽象描述\n\n2, 组成 属性 和 方法\n\n3, 模板 构造函数\n\n4, 特点 封装 继承 多态 \n\n属性用来描述具体某个对象的特征。比如小志身高180M，体重70KG，这里身高、体重都是属性。\n面向对象的思想就是把一切都看成对象，而对象一般都由属性+方法组成！\n\n属性属于对象静态的一面，用来形容对象的一些特性，方法属于对象动态的一面，咱们举一个例子，小明会跑，会说话，跑、说话这些行为就是对象的方法！所以为动态的一面， 我们把属性和方法称为这个对象的成员！\n\n类：具有同种属性的对象称为类，是个抽象的概念。比如“人”就是一类，期中有一些人名，比如小明、小红、小玲等等这些都是对象，类就相当于一个模具，他定义了它所包含的全体对象的公共特征和功能，对象就是类的一个实例化，小明就是人的一个实例化！我们在做程序的时候，经常要将一个变量实例化，就是这个原理！我们一般在做程序的时候一般都不用类名的，比如我们在叫小明的时候，不会喊“人，你干嘛呢！”而是说的是“小明，你在干嘛呢！”\n\n面向对象有三大特性，分别是封装性、继承性和多态性，这里小编不给予太多的解释，因为在后边的博客会专门总结的！\n\n三、面向过程与面向对象的优缺点\n很多资料上全都是一群很难理解的理论知识，整的小编头都大了，后来发现了一个比较好的文章，写的真是太棒了，通俗易懂，想要不明白都难!\n\n用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。我觉得这个比喻还是比较贴切的。\n\n蛋炒饭制作的细节，我不太清楚，因为我没当过厨师，也不会做饭，但最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。\n\n蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。\n\n到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。\n\n盖浇饭的好处就是\"菜\"“饭\"分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是\"可维护性\"比较好，“饭” 和\"菜\"的耦合度比较低。蛋炒饭将\"蛋”“饭\"搅和在一起，想换\"蛋”\"饭\"中任何一种都很困难，耦合度很高，以至于\"可维护性\"比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。\n　　\n我们最后简单总结一下\n\n面向过程\n\n优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\n缺点：没有面向对象易维护、易复用、易扩展\n\n\n面向对象\n\n优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护\n缺点：性能比面向过程低\n</code></pre>\n<h2><a id=\"85eval_2898\"></a>85、eval</h2>\n<pre><code>eval()是全局对象的一个函数属性。\n\neval()的参数是一个字符串。如果字符串表示的是表达式，eval()会对表达式进行求值。如果参数表示一个或多个JavaScript语句， 那么eval()就会执行这些语句。注意不要用eval()来执行一个四则运算表达式；因为 JavaScript 会自动为四则运算求值并不需要用eval来包裹。\n\n这里的四则运算是指数学上的运算，如：3 + 4 * 4 / 6。注意这里面并没有变量，只是单纯的数学运算，这样的运算式并不需要调用eval来计算，直接在代码中计算就可以。其实即便带有变量，JavaScript也是可以直接计算的，但是如果你现在只想声明一个带有变量的表达式，但是想稍后进行运算（你有可能在声明这个带有变量的运算式之后还有可能对里面的变量进行修改），就可以使用eval。\n如果要将算数表达式构造成为一个字符串，你可以用eval()在随后对其求值。比如，假如你有一个变量 x ，你可以通过一个字符串表达式来对涉及x的表达式延迟求值，将 “3 * x + 2”，存储为变量，然后在你的脚本后面的一个地方调用eval()。\n\n如果eval()的参数不是字符串，eval()将会将参数原封不动的返回。在下面的例子中，字符串构造器被指定，eval()返回了字符串对象而不是对字符串求值。\n\n // 返回了包含\"2 + 2\"的字符串对象\neval(new String(\"2 + 2\"));\n\n// returns 4\neval(\"2 + 2\");          \n\n\neval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用eval()运行的字符串代码被恶意方（不怀好意的人）操控修改,您可能会利用最终在用户机器上运行恶意方部署的恶意代码，并导致您失去您的网页或者扩展程序的权限。更重要的是，第三方代码可以看到某一个eval()被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的Function就是不容易被攻击的。\n\neval()的运行效率也普遍的比其他的替代方案慢，因为他会调用js解析器，即便现代的JS引擎中已经对此做了优化。\n\n在常见的案例中我们都会找更安全或者更快的方案去替换他\n</code></pre>\n<h2><a id=\"86proxy_2926\"></a>86、proxy</h2>\n<p>proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p>\n<pre><code>var proxy = new Proxy(target, handler);\nnew Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为\n\nvar target = {\n   name: 'poetries'\n };\n var logHandler = {\n   get: function(target, key) {\n     console.log(`${key} 被读取`);\n     return target[key];\n   },\n   set: function(target, key, value) {\n     console.log(`${key} 被设置为 ${value}`);\n     target[key] = value;\n   }\n }\n var targetWithLog = new Proxy(target, logHandler);\n\n targetWithLog.name; // 控制台输出：name 被读取\n targetWithLog.name = 'others'; // 控制台输出：name 被设置为 others\n\n console.log(target.name); // 控制台输出: others\ntargetWithLog 读取属性的值时，实际上执行的是 logHandler.get ：在控制台输出信息，并且读取被代理对象 target 的属性。\n在 targetWithLog 设置属性值时，实际上执行的是 logHandler.set ：在控制台输出信息，并且设置被代理对象 target 的属性的值\n// 由于拦截函数总是返回35，所以访问任何属性都得到35\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\nProxy 实例也可以作为其他对象的原型对象\n\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n\nlet obj = Object.create(proxy);\nobj.time // 35\n</code></pre>\n<p>proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截</p>\n<p>Proxy的作用</p>\n<p>对于代理模式 Proxy 的作用主要体现在三个方面</p>\n<p>拦截和监视外部对对象的访问<br/> 降低函数或类的复杂度<br/> 在复杂操作前对操作进行校验或对所需资源进行管理</p>\n<h3><a id=\"Proxyhandler_2987\"></a>二、Proxy所能代理的范围–handler</h3>\n<pre><code>实际上 handler 本身就是ES6所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下\n\n// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。\nhandler.getPrototypeOf()\n\n// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。\nhandler.setPrototypeOf()\n\n\n// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。\nhandler.isExtensible()\n\n\n// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。\nhandler.preventExtensions()\n\n// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。\nhandler.getOwnPropertyDescriptor()\n\n\n// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", {}) 时。\nandler.defineProperty()\n\n\n// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。\nhandler.has()\n\n// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。\nhandler.get()\n\n\n// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。\nhandler.set()\n\n// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。\nhandler.deleteProperty()\n\n// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。\nhandler.ownKeys()\n\n// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。\nhandler.apply()\n\n\n// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。\nhandler.construct()\n</code></pre>\n<h3><a id=\"Proxy_3038\"></a>三、Proxy场景</h3>\n<p>3.1 实现私有变量</p>\n<pre><code>\nvar target = {\n   name: 'poetries',\n   _age: 22\n}\n\nvar logHandler = {\n  get: function(target,key){\n    if(key.startsWith('_')){\n      console.log('私有变量age不能被访问')\n      return false\n    }\n    return target[key];\n  },\n  set: function(target, key, value) {\n     if(key.startsWith('_')){\n      console.log('私有变量age不能被修改')\n      return false\n    }\n     target[key] = value;\n   }\n} \nvar targetWithLog = new Proxy(target, logHandler);\n\n// 私有变量age不能被访问\ntargetWithLog.name; \n\n// 私有变量age不能被修改\ntargetWithLog.name = 'others'; \n在下面的代码中，我们声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey\n\nvar api = {  \n    _apiKey: '123abc456def',\n    /* mock methods that use this._apiKey */\n    getUsers: function(){}, \n    getUser: function(userId){}, \n    setUser: function(userId, config){}\n};\n\n// logs '123abc456def';\nconsole.log(\"An apiKey we want to keep private\", api._apiKey);\n\n// get and mutate _apiKeys as desired\nvar apiKey = api._apiKey;  \napi._apiKey = '987654321';\n很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 set / get 拦截读写请求并返回 undefined:\n\nlet api = {  \n    _apiKey: '123abc456def',\n    getUsers: function(){ }, \n    getUser: function(userId){ }, \n    setUser: function(userId, config){ }\n};\n\nconst RESTRICTED = ['_apiKey'];\napi = new Proxy(api, {  \n    get(target, key, proxy) {\n        if(RESTRICTED.indexOf(key) &gt; -1) {\n            throw Error(`${key} is restricted. Please see api documentation for further info.`);\n        }\n        return Reflect.get(target, key, proxy);\n    },\n    set(target, key, value, proxy) {\n        if(RESTRICTED.indexOf(key) &gt; -1) {\n            throw Error(`${key} is restricted. Please see api documentation for further info.`);\n        }\n        return Reflect.get(target, key, value, proxy);\n    }\n});\n\n// 以下操作都会抛出错误\nconsole.log(api._apiKey);\napi._apiKey = '987654321';  \n第二种方法是使用 has 拦截 in 操作\n\nvar api = {  \n    _apiKey: '123abc456def',\n    getUsers: function(){ }, \n    getUser: function(userId){ }, \n    setUser: function(userId, config){ }\n};\n\nconst RESTRICTED = ['_apiKey'];\napi = new Proxy(api, {  \n    has(target, key) {\n        return (RESTRICTED.indexOf(key) &gt; -1) ?\n            false :\n            Reflect.has(target, key);\n    }\n});\n\n// these log false, and `for in` iterators will ignore _apiKey\nconsole.log(\"_apiKey\" in api);\n\nfor (var key in api) {  \n    if (api.hasOwnProperty(key) &amp;&amp; key === \"_apiKey\") {\n        console.log(\"This will never be logged because the proxy obscures _apiKey...\")\n    }\n}\n\n\n</code></pre>\n<p>3.2 抽离校验模块</p>\n<pre><code>让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 Proxy 保障数据类型的准确性\n\nlet numericDataStore = {  \n    count: 0,\n    amount: 1234,\n    total: 14\n};\n\nnumericDataStore = new Proxy(numericDataStore, {  \n    set(target, key, value, proxy) {\n        if (typeof value !== 'number') {\n            throw Error(\"Properties in numericDataStore can only be numbers\");\n        }\n        return Reflect.set(target, key, value, proxy);\n    }\n});\n\n// 抛出错误，因为 \"foo\" 不是数值\nnumericDataStore.count = \"foo\";\n\n// 赋值成功\nnumericDataStore.count = 333;\n如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用 Proxy 则可以将校验器从核心逻辑分离出来自成一体\n\nfunction createValidator(target, validator) {  \n    return new Proxy(target, {\n        _validator: validator,\n        set(target, key, value, proxy) {\n            if (target.hasOwnProperty(key)) {\n                let validator = this._validator[key];\n                if (!!validator(value)) {\n                    return Reflect.set(target, key, value, proxy);\n                } else {\n                    throw Error(`Cannot set ${key} to ${value}. Invalid.`);\n                }\n            } else {\n                throw Error(`${key} is not a valid property`)\n            }\n        }\n    });\n}\n\nconst personValidators = {  \n    name(val) {\n        return typeof val === 'string';\n    },\n    age(val) {\n        return typeof age === 'number' &amp;&amp; val &gt; 18;\n    }\n}\nclass Person {  \n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n        return createValidator(this, personValidators);\n    }\n}\n\nconst bill = new Person('Bill', 25);\n\n// 以下操作都会报错\nbill.name = 0;  \nbill.age = 'Bill';  \nbill.age = 15;  \n通过校验器和主逻辑的分离，你可以无限扩展 personValidators 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 Proxy 模拟类型检查，检查函数是否接收了类型和数量都正确的参数\n\nlet obj = {  \n    pickyMethodOne: function(obj, str, num) { /* ... */ },\n    pickyMethodTwo: function(num, obj) { /*... */ }\n};\n\nconst argTypes = {  \n    pickyMethodOne: [\"object\", \"string\", \"number\"],\n    pickyMethodTwo: [\"number\", \"object\"]\n};\n\nobj = new Proxy(obj, {  \n    get: function(target, key, proxy) {\n        var value = target[key];\n        return function(...args) {\n            var checkArgs = argChecker(key, args, argTypes[key]);\n            return Reflect.apply(value, target, args);\n        };\n    }\n});\n\nfunction argChecker(name, args, checkers) {  \n    for (var idx = 0; idx &lt; args.length; idx++) {\n        var arg = args[idx];\n        var type = checkers[idx];\n        if (!arg || typeof arg !== type) {\n            console.warn(`You are incorrectly implementing the signature of ${name}. Check param ${idx + 1}`);\n        }\n    }\n}\n\nobj.pickyMethodOne();  \n// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1\n// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2\n// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3\n\nobj.pickyMethodTwo(\"wopdopadoo\", {});  \n// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1\n\n// No warnings logged\nobj.pickyMethodOne({}, \"a little string\", 123);  \nobj.pickyMethodOne(123, {});\n</code></pre>\n<p>3.3 访问日志</p>\n<pre><code>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能\n\nlet api = {  \n    _apiKey: '123abc456def',\n    getUsers: function() { /* ... */ },\n    getUser: function(userId) { /* ... */ },\n    setUser: function(userId, config) { /* ... */ }\n};\n\nfunction logMethodAsync(timestamp, method) {  \n    setTimeout(function() {\n        console.log(`${timestamp} - Logging ${method} request asynchronously.`);\n    }, 0)\n}\n\napi = new Proxy(api, {  \n    get: function(target, key, proxy) {\n        var value = target[key];\n        return function(...arguments) {\n            logMethodAsync(new Date(), key);\n            return Reflect.apply(value, target, arguments);\n        };\n    }\n});\n\napi.getUsers();\n</code></pre>\n<p>3.4 预警和拦截</p>\n<pre><code>假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现\n\nlet dataStore = {  \n    noDelete: 1235,\n    oldMethod: function() {/*...*/ },\n    doNotChange: \"tried and true\"\n};\n\nconst NODELETE = ['noDelete'];  \nconst NOCHANGE = ['doNotChange'];\nconst DEPRECATED = ['oldMethod'];  \n\ndataStore = new Proxy(dataStore, {  \n    set(target, key, value, proxy) {\n        if (NOCHANGE.includes(key)) {\n            throw Error(`Error! ${key} is immutable.`);\n        }\n        return Reflect.set(target, key, value, proxy);\n    },\n    deleteProperty(target, key) {\n        if (NODELETE.includes(key)) {\n            throw Error(`Error! ${key} cannot be deleted.`);\n        }\n        return Reflect.deleteProperty(target, key);\n\n    },\n    get(target, key, proxy) {\n        if (DEPRECATED.includes(key)) {\n            console.warn(`Warning! ${key} is deprecated.`);\n        }\n        var val = target[key];\n    \n        return typeof val === 'function' ?\n            function(...args) {\n                Reflect.apply(target[key], target, args);\n            } :\n            val;\n    }\n\n});\n\n// these will throw errors or log warnings, respectively\ndataStore.doNotChange = \"foo\";  \ndelete dataStore.noDelete;  \ndataStore.oldMethod();\n</code></pre>\n<p>3.5 过滤操作</p>\n<pre><code>某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处\n\nlet obj = {  \n    getGiantFile: function(fileId) {/*...*/ }\n};\n\nobj = new Proxy(obj, {  \n    get(target, key, proxy) {\n        return function(...args) {\n            const id = args[0];\n            let isEnroute = checkEnroute(id);\n            let isDownloading = checkStatus(id);      \n            let cached = getCached(id);\n\n            if (isEnroute || isDownloading) {\n                return false;\n            }\n            if (cached) {\n                return cached;\n            }\n            return Reflect.apply(target[key], target, args);\n        }\n    }\n\n});\n</code></pre>\n<h2><a id=\"87_3371\"></a>87、事件代理</h2>\n<pre><code>事件代理 也就是 事件委托 \n\n不是直接给标签添加事件 是给标签的父级添加事件 通过 事件对象 判断触发事件的标签对象是谁 执行不同的函数程序的语法形式\n\n委托的优点\n\n减少内存消耗\n试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件\n\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；\n\n因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件的时候再去匹配判断目标元素；\n\n所以事件委托可以减少大量的内存消耗，节约效率。\n\n动态绑定事件\n比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；\n\n在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；\n\n如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；\n\n所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。\n</code></pre>\n<h2><a id=\"88_3401\"></a>88、不卡顿</h2>\n<p>如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条 都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来 每 16 ms 刷新一次。</p>\n<pre><code>&lt;ul&gt;控件&lt;/ul&gt;\n &lt;script&gt;\n    setTimeout(() =&gt; {\n       // 插入十万条数据\n      const total = 100000\n      // 一次插入 20 条，如果觉得性能不好就减少\n      const once = 20\n      // 渲染数据总共需要几次\n     const loopCount = total / once\n      let countOfRender = 0\n      let ul = document.querySelector(\"ul\");\n      function add() {\n      // 优化性能，插入不会造成回流\n       const fragment = document.createDocumentFragment();\n      for (let i = 0; i &lt; once; i++) {\n        const li = document.createElement(\"li\");\n        li.innerText = Math.floor(Math.random() * total);\n        fragment.appendChild(li);\n      }\n     ul.appendChild(fragment);\n     countOfRender += 1;\n     loop();\n  }\n  function loop() {\n      if (countOfRender &lt; loopCount) {\n       window.requestAnimationFrame(add);\n   }\n  }\n  loop();\n  }, 0);\n</code></pre>\n<h2><a id=\"89JavaScriptinstanceof_3440\"></a>89、JavaScript中的instanceof</h2>\n<pre><code>JavaScript中变量的类型判断常常使用typeof运算符，但使用typeof时存在一个缺陷，就是判断引用类型存储值时，无论引用的是什么类型的对象，它都返回 object。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。\n\n1.instanceof运算符用法\n\nvar strObj = new String(\"字符串\");\nconsole.log(strObj instanceof String);\t// true\n\n\n该段代码判断的是变量strObj是否为String对象的实例，strObj 是 String 对象的实例，因此是”true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法就很有用。\n\n// 判断 foo 是否是 Foo 类的实例\n function Foo(){}\n var foo = new Foo();\n\n console.log(foo instanceof Foo)\n\n\n2.instanceof在继承关系中使用\n\n// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例\nfunction Aoo(){}\nfunction Foo(){}\nFoo.prototype = new Aoo(); //JavaScript 原型继承\n\nvar foo = new Foo();\nconsole.log(foo instanceof Foo)//true\nconsole.log(foo instanceof Aoo)//true\nfoo作为构造函数Foo的实例，因为构造函数Foo原型继承了构造函数Aoo，因此返回true。该代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。\n\n3.instanceof运算符代码\nfunction instance_of(L, R) { //L 表示左表达式，R 表示右表达式\n  var O = R.prototype; // 取 R 的显示原型\n  L = L.__proto__; // 取 L 的隐式原型\n  while (true) {\n    if (L === null)\n      return false;\n    if (O === L) // 这里重点：当 O 严格等于 L 时，返回 true\n      return true;\n    L = L.__proto__;\n  }\n}\n</code></pre>\n<h2><a id=\"90forEachawait_3488\"></a>90、forEach中的await</h2>\n<p>不知道你是否写过类似的代码:</p>\n<pre><code> function test() {\n     let arr = [3, 2, 1]\n     arr.forEach(async item =&gt; {\n      const res = await fetch(item)\n      console.log(res)\n     })\n     console.log('end')\n    }\n    \n function fetch(x) {\n return new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n   resolve(x)\n  }, 500 * x)\n })\n}\n\ntest()\n</code></pre>\n<p>​</p>\n<p>我当时期望的打印顺序是</p>\n<pre><code>3\n2\n1\nend\n结果现实与我开了个玩笑，打印顺序居然是\n\nend\n1\n2\n3\n为什么？\n</code></pre>\n<p>其实原因很简单，那就是 forEach 只支持同步代码。</p>\n<p>我们可以参考下 Polyfill 版本的 forEach，简化以后类似就是这样的伪代码</p>\n<pre><code>while (index &lt; arr.length) {\n  callback(item, index)   //也就是我们传入的回调函数\n}\n</code></pre>\n<p>从上述代码中我们可以发现，forEach 只是简单的执行了下回调函数而已，并不会去处理异步的情况。并且你在 callback 中即使使用 break 也并不能结束遍历。</p>\n<p>怎么解决？</p>\n<p>一般来说解决的办法有2种,for…of和for循环。</p>\n<p>使用 Promise.all 的方式行不行，答案是： 不行</p>\n<pre><code>async function test() {\n    let arr = [3, 2, 1]\n    await Promise.all(\n     arr.map(async item =&gt; {\n      const res = await fetch(item)\n      console.log(res)\n     })\n    )\n    console.log('end')\n   }\n</code></pre>\n<p>可以看到并没有按照我们期望的输出。</p>\n<p>这样可以生效的原因是 async 函数肯定会返回一个 Promise 对象，调用 map 以后返回值就是一个存放了 Promise 的数组了，这样我们把数组传入 Promise.all 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 fetch 是顺序完成的，可以选择第二种方式。</p>\n<p>第1种方法是使用 for…of</p>\n<pre><code>   async function test() {\n     let arr = [3, 2, 1]\n     for (const item of arr) {\n      const res = await fetch(item)\n      console.log(res)\n     }\n     console.log('end')\n    }\n</code></pre>\n<p>这种方式相比 Promise.all 要简洁的多，并且也可以实现开头我想要的输出顺序。</p>\n<p>但是这时候你是否又多了一个疑问？为啥 for…of 内部就能让 await 生效呢。</p>\n<p>因为 for…of 内部处理的机制和 forEach 不同，forEach 是直接调用回调函数，for…of 是通过迭代器的方式去遍历。</p>\n<pre><code>async function test() {\n let arr = [3, 2, 1]\n const iterator = arr[Symbol.iterator]()\n let res = iterator.next()\n while (!res.done) {\n  const value = res.value\n  const res1 = await fetch(value)\n  console.log(res1)\n  res = iterator.next()\n }\n console.log('end')\n}\n</code></pre>\n<p>第2种方法是使用 for循环</p>\n<pre><code>async function test() {\n  let arr = [3, 2, 1]\n  for (var i=0;i&lt;arr.length;i++) {\n    const res = await fetch(arr[i])\n    console.log(res)\n  }\n  console.log('end')\n}\n\nfunction fetch(x) {\n return new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n   resolve(x)\n  }, 500 * x)\n })\n}\n\ntest()\n</code></pre>\n<p>第3种方法是使用 while循环</p>\n<pre><code>async function test() {\n  let arr = [3, 2, 1]\n  var i=0;\n  while(i!==arr.length){\n    const res = await fetch(arr[i])\n    console.log(res)\n    i++;\n  }\n  console.log('end')\n}\n\nfunction fetch(x) {\n return new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n   resolve(x)\n  }, 500 * x)\n })\n}\n\ntest()\n</code></pre>\n<p>要想在循环中使用async await，请使用for…of 或者 for 循环, while循环</p>\n<p>forEach支持async await<br/> forEach 在正常情况像下面这么写肯定是做不到同步的，程序不会等一个循环中的异步完成再进行下一个循环。原因很明显，在上面的模拟中，while 循环只是简单执行了 callback，所以尽管 callback 内使用了 await ，也只是影响到 callback 内部。</p>\n<pre><code>arr.myforeach(async v =&gt; {\n    await fetch(v);\n});\n</code></pre>\n<p>要支持上面这种写法，只要稍微改一下就好</p>\n<pre><code>Array.prototype.myforeach = async function (fn, context = null) {\n    let index = 0;\n    let arr = this;\n    if (typeof fn !== 'function') {\n        throw new TypeError(fn + ' is not a function');\n    }\n    while (index &lt; arr.length) {\n        if (index in arr) {\n            try {\n                await fn.call(context, arr[index], index, arr);\n            } catch (e) {\n                console.log(e);\n            }\n        }\n        index ++;\n    }\n};\n</code></pre>\n<h2><a id=\"91srchref_3678\"></a>91、src和href</h2>\n<pre><code>src和href都是用在外部资源的引入上，比如图像，CSS文件，HTML文件，以及其他的web页面等等，那么src和href的区别都有哪些呢？\n\n1、请求资源类型不同\n（1） href是Hypertext Reference的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。\n（2）在请求 src 资源时会将其指向的资源下载并应用到文档中，常用的有script，img 、iframe；\n\n2、作用结果不同\n（1）href 用于在当前文档和引用资源之间确立联系；\n\n（2）src 用于替换当前内容；\n\n3、 浏览器解析方式不同\n（1）若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。\n\n（2）当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。\n</code></pre>\n<h2><a id=\"92JavaScript_3700\"></a>92、JavaScript中事件绑定的方法</h2>\n<p>在JavaScript的学习中，我们经常会遇到JavaScript的事件机制，例如，事件绑定、事件监听、事件委托（事件代理）等。这些名词是什么意思呢，有什么作用呢？</p>\n<p>一、事件绑定<br/> 要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。</p>\n<p>在JavaScript中，有三种常用的绑定事件的方法：</p>\n<p>在DOM元素中直接绑定；<br/> 在JavaScript代码中绑定；<br/> 绑定事件监听函数。</p>\n<p>1、在DOM中直接绑定事件</p>\n<pre><code>我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看， DOM事件 。\n\n&lt;input type=\"button\" value=\"click me\" onclick=\"hello()\"&gt;\n\n\n&lt;script&gt;\nfunction hello(){\n alert(\"hello world!\");\n}\n\n\n</code></pre>\n<p>2、在JavaScript代码中绑定事件</p>\n<pre><code>在 JS 代码中（即 script 标签内）绑定事件可以使 JS 代码与HTML标签分离，文档结构清晰，便于管理和开发。\n\n&lt;input type=\"button\" value=\"click me\" id=\"btn\"&gt;\n\n&lt;script&gt;\ndocument.getElementById(\"btn\").onclick = function(){\n alert(\"hello world!\");\n}\n\n\n</code></pre>\n<p>3、使用事件监听绑定事件</p>\n<pre><code>绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。\n</code></pre>\n<p>1）事件监听</p>\n<pre><code>关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。\n\n起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。\n\nW3C规范\n\nelement.addEventListener(event, function, useCapture)\nevent : （必需）事件名，支持所有 DOM事件 。\nfunction：（必需）指定要事件触发时执行的函数。\nuseCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。\n注：IE8以下不支持。\n\n&lt;input type=\"button\" value=\"click me\" id=\"btn1\"&gt;\n\n&lt;script&gt;\ndocument.getElementById(\"btn1\").addEventListener(\"click\",hello);\nfunction hello(){\n alert(\"hello world!\");\n}\nIE标准\n\n\nelement.attachEvent(event, function)\nevent：（必需）事件类型。需加“on“，例如：onclick。\nfunction：（必需）指定要事件触发时执行的函数。\n&lt;input type=\"button\" value=\"click me\" id=\"btn2\"&gt;\n&lt;script&gt;\ndocument.getElementById(\"btn2\").attachEvent(\"onclick\",hello);\nfunction hello(){\n alert(\"hello world!\");\n}\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-06-14 21:24:37", "summary": "这里写自定义目录标题、解释一下什么是闭包、解释一下原型和原型链原型原型链、说一下中你熟悉的一些内容、数组排序的方式、什么是事件轮询、数组的一些哪些能够改变原数组那些不能、循环与的区别、深浅拷贝、的组成"}