{"blogid": "125527759", "writerAge": "码龄1年", "writerBlogNum": "25", "writerCollect": "2049", "writerComment": "1518", "writerFan": "2633", "writerGrade": "6级", "writerIntegral": "4561", "writerName": "猿力猪", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125527759.jpg", "writerRankTotal": "4640", "writerRankWeekly": "15864", "writerThumb": "1555", "writerVisitNum": "113016", "blog_read_count": "1373", "blog_time": "已于 2022-07-13 12:16:53 修改", "blog_title": "【Linux网络编程】高并发服务器 socket+epoll封装 服务器/客户端举例", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%9B%AE%E5%BD%95\">目录</h1>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\">一、高并发服务器</a></p>\n<p id=\"%F0%9F%92%BB%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%BB%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F\">💻什么是高并发？</a></p>\n<p id=\"%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%8C%87%E6%A0%87%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%8C%87%E6%A0%87%EF%BC%9F\">💻高并发的处理指标？</a></p>\n<p id=\"%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F\">💻高并发和多线程的关系和区别？</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E5%AE%A2%E6%88%B7%E7%AB%AF-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E5%AE%A2%E6%88%B7%E7%AB%AF\">二、搭建服务器/客户端</a></p>\n<p id=\"%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81\">💻服务器代码（4种类的封装）</a></p>\n<p id=\"%F0%9F%8C%88%E5%9C%B0%E5%9D%80%E7%B1%BB%EF%BC%88CHostAddress%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8C%88%E5%9C%B0%E5%9D%80%E7%B1%BB%EF%BC%88CHostAddress%EF%BC%89\">🌈地址类【CHostAddress】</a></p>\n<p id=\"%F0%9F%8C%88socket%E5%9F%BA%E7%B1%BB%EF%BC%88CBaseSocket%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8C%88socket%E5%9F%BA%E7%B1%BB%EF%BC%88CBaseSocket%EF%BC%89\">🌈socket类【CBaseSocket】</a></p>\n<p id=\"%F0%9F%8C%88TCP%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88CTcpServer%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8C%88TCP%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88CTcpServer%EF%BC%89\">🌈TCP类【CTcpServer】</a></p>\n<p id=\"%F0%9F%8C%88epoll%E7%B1%BB%20%EF%BC%88CEpollServer%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8C%88epoll%E7%B1%BB%20%EF%BC%88CEpollServer%EF%BC%89\">🌈epoll类 【CEpollServer】</a></p>\n<p id=\"%F0%9F%92%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81\">💻客户端代码</a></p>\n<p id=\"%F0%9F%92%BB%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%BB%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95\">💻案例测试</a></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>本文主要学习<span style=\"color:#be191c;\"><strong>Linux内核编程</strong></span>，结合<span style=\"color:#be191c;\"><strong>Visual Studio 2019</strong></span>进行跨平台编程，内容包括高并发服务器的介绍、服务器代码封装（socket+epoll）、服务器/客户端测试</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\">一、高并发服务器</h1>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"335\" src=\"..\\..\\static\\image\\0dedfc5dee0a4fdabd57bf3abb7c2a64.png\" width=\"377\"/></p>\n<h2 id=\"%F0%9F%92%BB%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F\">💻什么是高并发？</h2>\n<blockquote>\n<p><span style=\"color:#be191c;\"><strong>📘  高并发 </strong></span>是一种系统运行过程中遇到的一种<strong> </strong> <strong>“短时间内遇到大量操作请求”</strong>  的情况</p>\n<p>      【主要发生在web系统集中大量访问收到大量请求】</p>\n<p></p>\n<p>🌰举个例子：12306的抢票情况；天猫双十一活动【突然下单一万张票，上万人下单购物】</p>\n<p></p>\n<p>该情况发生会导致系统在这段时间内执行大量操作，例如，对资源的请求，数据库的操作等</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"290\" src=\"..\\..\\static\\image\\ba232185ba154127ab745dedb9e0c393.png\" width=\"434\"/></p>\n<h2 id=\"%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%8C%87%E6%A0%87%EF%BC%9F\">💻高并发的处理指标？</h2>\n<blockquote>\n<p><strong>高并发相关常用的一些指标有：</strong></p>\n<p><br/><strong>1️⃣响应时间（Response Time）</strong></p>\n<p>📗含义：系统对请求做出响应的时间</p>\n<p>🌰举个例子：系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间</p>\n<hr/>\n<p><strong>2️⃣吞吐量（Throughput）</strong></p>\n<p>📗含义：单位时间内处理的请求数量</p>\n<hr/>\n<p><strong>3️⃣每秒查询率QPS（Query Per Second）</strong></p>\n<p>📗含义 ：每秒响应请求数</p>\n<p>📖在互联网领域，这个指标和吞吐量区分的没有这么明显</p>\n<hr/>\n<p><strong>4️⃣并发用户数</strong></p>\n<p>📗含义：同时承载正常使用系统功能的用户数量</p>\n<p>🌰举个例子：例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数</p>\n</blockquote>\n<h2 id=\"%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F\">💻<strong>高并发和多线程的关系和区别？</strong></h2>\n<blockquote>\n<p><strong>“高并发和多线程”</strong>   总是被一起提起，给人感觉两者好像相等，实则    【<strong><span style=\"color:#be191c;\">高并发 ≠ 多线程</span><span style=\"color:#0d0016;\">】</span></strong></p>\n<hr/>\n<p><strong>1️⃣多线程</strong></p>\n<p></p>\n<ul><li>多线程是java的特性，因为现在CPU都是多核多线程的，可以同时执行几个任务，为了提高jvm的执行效率，java提供了这种多线程的机制，以增强数据处理效率</li><li>多线程对应的是CPU，高并发对应的是访问请求，可以用单线程处理所有访问请求，也可以用多线程同时处理访问请求</li><li>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程</li><li>虽然并不是真正意义上的 <strong>“同一时间点”</strong>，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行</li><li>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序</li><li>📗总结：多线程是处理高并发的一种编程方法，即并发需要用多线程实现</li></ul>\n<hr/>\n<p><strong>2️⃣高并发</strong></p>\n<p></p>\n<ul><li>高并发不是JAVA的专有的东西，是语言无关的广义的，为提供更好互联网服务而提出的概念</li><li>典型的场景：例如，12306抢火车票，天猫双十一秒杀活动等。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。</li><li>如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等</li><li>如果，要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等，而多线程只是其中解决方法之一</li></ul>\n</blockquote>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E5%AE%A2%E6%88%B7%E7%AB%AF\">二、搭建服务器/客户端</h1>\n<h2 id=\"%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81\">💻服务器代码（4种类的封装）</h2>\n<blockquote>\n<ul><li><strong>🍔地址类</strong></li><li><strong>🍟socket基类</strong></li><li><strong>🍕TCP派生类</strong></li><li><strong>🍿epoll类</strong></li></ul>\n</blockquote>\n<h3 id=\"%F0%9F%8C%88%E5%9C%B0%E5%9D%80%E7%B1%BB%EF%BC%88CHostAddress%EF%BC%89\">🌈地址类【CHostAddress】</h3>\n<p id=\"1%EF%BC%89CHostAddress.h\"><strong>📍CHostAddress.h</strong></p>\n<pre><code class=\"language-cpp\">#pragma once\n#include &lt;sys/types.h&gt;          /* See NOTES */\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;string.h&gt;\n#include &lt;arpa/inet.h&gt;\n\nclass CHostAddress\n{\npublic:\n\tCHostAddress(char* ip, unsigned short port);\n\t~CHostAddress();\n\n\tchar* getIp();\n\tvoid setIp(char* ip);\n\n\tunsigned short getPort();\n\tvoid setPort(unsigned short port);\n\n\tstruct sockaddr_in getAddr_in();\n\tstruct sockaddr* getAddr();\n\n\tint getLength();\n\nprivate:\n\tchar ip[16]; //保存ip地址\n\tint length; //保存 sockaddr_in 结构体长度\n\tunsigned short port; //端口号\n\tstruct sockaddr_in s_addr;\n\n};\n</code></pre>\n<p id=\"%C2%A0%F0%9F%93%8DCHostAddress.cpp\"><strong>📍CHostAddress.cpp</strong></p>\n<pre><code class=\"language-cpp\">#include \"CHostAddress.h\"\n\nCHostAddress::CHostAddress(char* ip, unsigned short port)\n{\n    memset(this-&gt;ip, 0, sizeof(this-&gt;ip));\n    strcpy(this-&gt;ip, ip);\n\n    this-&gt;port = port;\n\n    this-&gt;s_addr.sin_family = AF_INET; \n    this-&gt;s_addr.sin_port = htons(this-&gt;port); \n    this-&gt;s_addr.sin_addr.s_addr = inet_addr(this-&gt;ip);\n\n    this-&gt;length = sizeof(this-&gt;s_addr);\n}\n\nCHostAddress::~CHostAddress()\n{\n\n}\n\nchar* CHostAddress::getIp()\n{\n    return this-&gt;ip;\n}\n\nvoid CHostAddress::setIp(char* ip)\n{\n    strcpy(this-&gt;ip, ip);\n}\n\nunsigned short CHostAddress::getPort()\n{\n    return this-&gt;port;\n}\n\nvoid CHostAddress::setPort(unsigned short port)\n{\n    this-&gt;port = port;\n}\n\nsockaddr_in CHostAddress::getAddr_in()\n{\n    return this-&gt;s_addr;\n}\n\nsockaddr* CHostAddress::getAddr()\n{\n    // bind函数需要用到struct sockaddr *，因此return类型转换之后数据\n    return (struct sockaddr*)&amp;(this-&gt;s_addr);\n}\n\nint CHostAddress::getLength()\n{\n    return this-&gt;length;\n}</code></pre>\n<h3 id=\"%F0%9F%8C%88socket%E5%9F%BA%E7%B1%BB%EF%BC%88CBaseSocket%EF%BC%89\">🌈socket类【CBaseSocket】</h3>\n<p id=\"1%EF%BC%89CBaseSocket.h\"><strong>📍CBaseSocket.h</strong></p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &lt;sys/types.h&gt; //socket头文件        \n#include &lt;sys/socket.h&gt;//socket头文件  \n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n\nclass CBaseSocket\n{\npublic:\n\tCBaseSocket(char* ip, unsigned short port);\n\t~CBaseSocket();\n\tvoid Start();\n\tint getSocketFd();\n\tvirtual void Run() = 0;//写成纯虚函数，子类来实现\n\tvirtual void Stop() = 0;//写成纯虚函数，子类来实现\n\nprotected:\n\tint socketFd;//写到受保护区，子类可以用到\n\n};</code></pre>\n<p id=\"%F0%9F%93%8DCBaseSocket.cpp%C2%A0\">📍<strong>CBaseSocket.cpp </strong></p>\n<pre><code class=\"language-cpp\">#include \"CBaseSocket.h\"\n\nCBaseSocket::CBaseSocket(char* ip, unsigned short port)\n{\n\tthis-&gt;socketFd = 0;\n}\n\nCBaseSocket::~CBaseSocket()\n{\n}\n\nvoid CBaseSocket::Start()\n{\n\t//打通网络通道\n\tthis-&gt;socketFd = socket(AF_INET, SOCK_STREAM, 0);//IPPROTO_TCP用0替换也行\n\n\tif (this-&gt;socketFd &lt; 0)//大于0成功，小于0失败\n\t{\n\t\tperror(\"socket error\");//socket创建失败\n\t}\n\n\tthis-&gt;Run();//子类实现的run函数\n}\n\nint CBaseSocket::getSocketFd()\n{\n\treturn this-&gt;socketFd;\n}</code></pre>\n<h3 id=\"%F0%9F%8C%88TCP%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88CTcpServer%EF%BC%89\">🌈TCP类【CTcpServer】</h3>\n<p id=\"%F0%9F%93%8DCTcpServer.h%C2%A0\">📍<strong>CTcpServer.h </strong></p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include&lt;iostream&gt;\n#include \"CBaseSocket.h\"\n#include \"CHostAddress.h\"\n#include &lt;netinet/in.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;          /* See NOTES */\n#include &lt;sys/socket.h&gt;\n\nusing namespace std;\n\n#define LISTEN_MAX_NUM 10  \n\nclass CTcpServer :\n    public CBaseSocket\n{\npublic:\n    CTcpServer(char* ip, unsigned short port);\n    ~CTcpServer();\n    void Run();\n    void Stop();\n    CHostAddress* getAddress();\n    void setAddress(CHostAddress* address);\n\nprivate:\n    CHostAddress* address;//地址类\n};</code></pre>\n<p id=\"%F0%9F%93%8DCTcpServer.cpp%C2%A0\">📍<strong>CTcpServer.cpp </strong></p>\n<pre><code class=\"language-cpp\">#include \"CTcpSever.h\"\n\nCTcpServer::CTcpServer(char* ip, unsigned short port)\n    :CBaseSocket(ip, port)\n{\n    this-&gt;address = new CHostAddress(ip, port);\n}\n\nCTcpServer::~CTcpServer()\n{\n}\n\nvoid CTcpServer::Run()\n{\n    int opt_val = 1;\n    int res = 0;\n\n    //端口复用 解决出现 adress already use的问题\n    res = setsockopt(this-&gt;socketFd, SOL_SOCKET, SO_REUSEADDR, (const void*)&amp;opt_val, sizeof(opt_val));\n    if (res == -1)\n    {\n        perror(\"setsockopt error\");\n    }\n    //绑定端口号和地址 协议族\n    res = bind(this-&gt;socketFd, this-&gt;address-&gt;getAddr(), this-&gt;address-&gt;getLength());\n    if (res == -1)\n    {\n        perror(\"bind error\");\n    }\n    //监听这个地址和端口有没有客户端来连接\n    res = listen(this-&gt;socketFd, LISTEN_MAX_NUM);\n    if (res == -1)\n    {\n        perror(\"listen error\");\n    }\n    cout &lt;&lt; \"Server start success socketFd = \" &lt;&lt; this-&gt;socketFd &lt;&lt; endl;\n}\n\nvoid CTcpServer::Stop()\n{\n    if (this-&gt;socketFd != 0)\n    {\n        close(this-&gt;socketFd);\n        this-&gt;socketFd = 0;\n    }\n}\n\nCHostAddress* CTcpServer::getAddress()\n{\n    return this-&gt;address;\n}\n\nvoid CTcpServer::setAddress(CHostAddress* address)\n{\n    this-&gt;address = address;\n}</code></pre>\n<h3 id=\"%F0%9F%8C%88epoll%E7%B1%BB%20%EF%BC%88CEpollServer%EF%BC%89\">🌈epoll类 【CEpollServer】</h3>\n<p id=\"%C2%A0%F0%9F%93%8DCEpollServer.h\"><strong> </strong>📍<strong>CEpollServer.h</strong></p>\n<pre><code class=\"language-cpp\">#pragma once\n#include &lt;sys/epoll.h&gt;\n#include &lt;iostream&gt;\n#include \"CTcpSever.h\"\n\n#define EPOLL_SIZE 5\n\nusing namespace std;\n\nclass CEpollServer\n{\npublic:\n\tCEpollServer(char* ip, unsigned short port);\n\t~CEpollServer();\n\tvoid Start();\n\nprivate:\n\tint epollfd;\n\tint epollwaitefd;\n\tint acceptFd;\n\tchar buf[1024]; //存放客户端发来的消息\n\tstruct epoll_event epollEvent;\n\tstruct epoll_event epollEventArray[5];\n\tCTcpServer* tcp;//TCP类\n\n};\n</code></pre>\n<p id=\"%F0%9F%93%8D%C2%A0CEpollServer.cpp\">📍<strong> CEpollServer.cpp</strong></p>\n<pre><code class=\"language-cpp\">#include \"CEpollServer.h\"\n\nCEpollServer::CEpollServer(char* ip, unsigned short port)\n{\n\t//初始化 TcpServer类\n\tthis-&gt;tcp = new CTcpServer(ip, port);\n\tthis-&gt;tcp-&gt;Start();\n\tcout &lt;&lt; \"socketFd = \" &lt;&lt; this-&gt;tcp-&gt;getSocketFd() &lt;&lt; endl;\n\n\t//初始化数据成员\n\tthis-&gt;epollfd = 0;\n\tthis-&gt;epollwaitefd = 0;\n\tthis-&gt;acceptFd = 0;\n\tbzero(this-&gt;buf, sizeof(this, buf));\n\n\t//事件结构体初始化\n\tbzero(&amp;(this-&gt;epollEvent), sizeof(this-&gt;epollEvent));\n\t//绑定当前准备好的sockedfd（可用网络对象）\n\tthis-&gt;epollEvent.data.fd = this-&gt;tcp-&gt;getSocketFd();\n\t//绑定事件为客户端接入事件\n\tthis-&gt;epollEvent.events = EPOLLIN;\n\t//创建epoll\n\tthis-&gt;epollfd = epoll_create(EPOLL_SIZE);\n\t//将已经准备好的网络描述符添加到epoll事件队列中\n\tepoll_ctl(this-&gt;epollfd, EPOLL_CTL_ADD, this-&gt;tcp-&gt;getSocketFd(), &amp;(this-&gt;epollEvent));\n}\n\nCEpollServer::~CEpollServer()\n{\n}\n\nvoid CEpollServer::Start()\n{\n\twhile (1)\n\t{\n\t\tcout &lt;&lt; \"epoll wait client\" &lt;&lt; endl;\n\t\tthis-&gt;epollwaitefd = epoll_wait(this-&gt;epollfd, epollEventArray, EPOLL_SIZE, -1);\n\t\tif (this-&gt;epollwaitefd &lt; 0)\n\t\t{\n\t\t\tperror(\"epoll wait error\");\n\t\t}\n\t\tfor (int i = 0; i &lt; this-&gt;epollwaitefd; i++)\n\t\t{\n\t\t\t//判断是否有客户端上线\n\t\t\tif (epollEventArray[i].data.fd == this-&gt;tcp-&gt;getSocketFd())\n\t\t\t{\n\t\t\t\tcout &lt;&lt; \"网络_开始工作_等待客户端_上线\" &lt;&lt; endl;\n\t\t\t\tthis-&gt;acceptFd = accept(this-&gt;tcp-&gt;getSocketFd(), NULL, NULL);\n\t\t\t\tcout &lt;&lt; \"acceptfd = \" &lt;&lt; this-&gt;acceptFd &lt;&lt; endl;\n\n\t\t\t\t//上线的客户端描述符是acceptfd 绑定事件添加到epoll\n\t\t\t\tepollEvent.data.fd = this-&gt;acceptFd;\n\t\t\t\tepollEvent.events = EPOLLIN; //EPOLLIN表示对应的文件描述符可以读\n\t\t\t\tepoll_ctl(this-&gt;epollfd, EPOLL_CTL_ADD, this-&gt;acceptFd, &amp;epollEvent);\n\t\t\t}\n\t\t\telse if (epollEventArray[i].events &amp; EPOLLIN)\n\t\t\t{\n\t\t\t\tbzero(this-&gt;buf, sizeof(this-&gt;buf));\n\t\t\t\tint res = read(epollEventArray[i].data.fd, this-&gt;buf, sizeof(this-&gt;buf));\n\t\t\t\tif (res &gt; 0)\n\t\t\t\t{\n\t\t\t\t\tcout &lt;&lt; \"服务器_收到 fd = \" &lt;&lt; epollEventArray[i].data.fd &lt;&lt; \"  送达数据: buf = \" &lt;&lt; this-&gt;buf &lt;&lt; endl;\n\t\t\t\t}\n\t\t\t\telse if (res &lt;= 0)\n\t\t\t\t{\n\t\t\t\t\tcout &lt;&lt; \"客户端 fd = \" &lt;&lt; epollEventArray[i].data.fd &lt;&lt; \" _掉线_\" &lt;&lt; endl;\n\t\t\t\t\tclose(epollEventArray[i].data.fd);\n\n\t\t\t\t\t//从epoll中删除客户端描述符\n\t\t\t\t\tepollEvent.data.fd = epollEvent.data.fd;\n\t\t\t\t\tepollEvent.events = EPOLLIN;\n\t\t\t\t\tepoll_ctl(this-&gt;epollfd, EPOLL_CTL_DEL, epollEventArray[i].data.fd, &amp;epollEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}</code></pre>\n<h2 id=\"%F0%9F%92%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81\">💻<strong>客户端代码</strong></h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/types.h&gt;          \n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint socketfd = 0;\n\tint acceptfd = 0;\n\tint len = 0;\n\tint res = 0;\n\tchar buf[255] = { 0 };//初始化\n\n\t//初始化网络\n\tsocketfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (socketfd == -1)\n\t{\n\t\tperror(\"socket error\");\n\t}\n\telse\n\t{\n\t\tstruct sockaddr_in s_addr;\n\t\t//确定使用哪个协议族  ipv4\n\t\ts_addr.sin_family = AF_INET;\n\n\t\t//填入服务器的ip地址  也可以是  127.0.0.1 （回环地址）\n\t\ts_addr.sin_addr.s_addr = inet_addr(\"192.168.48.129\");\n\n\t\t//端口一个计算机有65535个  10000以下是操作系统自己使用的，自己定义的端口号为10000以后\n\t\ts_addr.sin_port = htons(12345);  //自定义端口号为12345\n\n\t\tlen = sizeof(s_addr);\n\n\t\t//绑定ip地址和端口号\n\t\tint res = connect(socketfd, (struct sockaddr*)&amp;s_addr, len);\n\t\tif (res == -1)\n\t\t{\n\t\t\tperror(\"connect error\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tcout &lt;&lt; \"请输入内容：\" &lt;&lt; endl;\n\t\t\t\tcin &gt;&gt; buf;\n\t\t\t\twrite(socketfd, buf, sizeof(buf));\n\t\t\t\tbzero(buf, sizeof(buf));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<h2 id=\"%F0%9F%92%BB%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95\">💻<strong>案例测试</strong></h2>\n<p id=\"main.cpp\">📍<strong>main.cpp</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include \"CEpollServer.h\"\n\nusing namespace std;\n\nint main()\n{\n\tCEpollServer* epoll = new CEpollServer(\"192.168.48.129\", 12345);\n\tepoll-&gt;Start();\n\treturn 0;\n}</code></pre>\n<p id=\"%F0%9F%93%8D%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%C2%A0\">📍<strong>测试效果 </strong></p>\n<p>通过Linux连接VS进行跨平台编程，上为本文设计的服务器，下为两个与之相连的客户端，在客户端1和客户端2中输入内容，服务器上能接收到相应的信息，即表示测试成功！如下动图所示： </p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/e5b46f537b794429b321992e509f28a9.gif\"/></p>\n<p></p>\n<p><strong>参考：</strong></p>\n<p><a href=\"https://www.csdn.net/tags/MtjaUgxsMzAzMjgtYmxvZwO0O0OO0O0O.html\" title=\"https://www.csdn.net/tags/MtjaUgxsMzAzMjgtYmxvZwO0O0OO0O0O.html\">https://www.csdn.net/tags/MtjaUgxsMzAzMjgtYmxvZwO0O0OO0O0O.html</a>  </p>\n<p><a href=\"https://blog.csdn.net/wmcy123/article/details/124054385\" title=\"【Linux】高并发服务器设计——socket封装_似末的博客-CSDN博客_linux socket 高并发\">【Linux】高并发服务器设计——socket封装_似末的博客-CSDN博客_linux socket 高并发</a></p>\n<p></p>\n<p><span style=\"color:#38d8f0;\"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！！</strong></span></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/9b848022d42d491cb0d59ea13b5f2f84.gif\"/></p>\n<p style=\"text-align:center;\"></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-13 12:16:53", "summary": "目录前言一、高并发服务器什么是高并发？高并发的处理指标？高并发和多线程的关系和区别？二、搭建服务器客户端服务器代码种类的封装地址类类类类客户端代码案例测试前言本文主要学习内核编程，结合进行跨平台编程，"}