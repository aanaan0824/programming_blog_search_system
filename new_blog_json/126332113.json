{"blogid": "126332113", "writerAge": "码龄6年", "writerBlogNum": "302", "writerCollect": "4140", "writerComment": "1148", "writerFan": "6274", "writerGrade": "6级", "writerIntegral": "6582", "writerName": "共饮一杯无", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126332113.jpg", "writerRankTotal": "2111", "writerRankWeekly": "62", "writerThumb": "1581", "writerVisitNum": "1849826", "blog_read_count": "12144", "blog_time": "于 2022-08-14 15:27:49 发布", "blog_title": "云原生中间件RocketMQ-消费者核心参数、消费模式之集群模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#PushConsumer_1\">PushConsumer核心参数详解</a></li><li><a href=\"#PushConsumer_41\">PushConsumer消费模式-集群模式</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h2><a id=\"PushConsumer_1\"></a>PushConsumer核心参数详解</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cc15b7cee97d456f9fdc380f10b256a3.png\"/></p>\n<ol><li><code>consumeFromWhere</code>：消费者从那个位置开始消费<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ba277cd4551a4592b0553efbafdad44c.png\"/></li></ol>\n<ul><li>CONSUME_FROM_LAST_OFFSET：第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费</li><li>CONSUME_FROM_FIRST_OFFSET：第一次启动从队列初始位置消费，后续再启动接着上次消费的进度开始消费</li><li>CONSUME_FROM_TIMESTAMP：第一次启动从指定时间点位置消费，后续再启动接着上次消费的进度开始消费</li></ul>\n<ol start=\"2\"><li><code>allocateMessageQueueStrategy</code>：消息分配策略(集群模式)，指定如何将消息队列分配给每个客户端。包括一致性hash、平均分配、平均轮询分配、自定义消费队列、按机房hash算法实现。默认平均轮询AllocateMessageQueueAveragely，Rebalance（轮询）算法实现策略。</li></ol>\n<p>平均分配的实现算法</p>\n<ul><li>如果消费者的个数可以除尽队列的个数，那么就完全平均分。</li><li>如果不能除尽。那么靠前的消费者多消费一个队列，靠后的消费平均数个队列。</li><li>如果消费者的个数大于队列的个数，那么靠前的消费者消费一个队列，后面的不消费。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8d42bac72587454e881f192f98729607.png\"/></li></ul>\n<ol start=\"3\"><li><code>subscription</code>：订阅关系。</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5adfe888bcc64d10b471cea611ae8e6b.png\"/></p>\n<ol start=\"4\"><li><code>offsetStore</code>: 消息进度存储。</li></ol>\n<ul><li>集群消费：从远程Broker获取。</li><li>广播消费：从本地文件获取。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fe42118ef3174e0fb0040e6d5376c646.png\"/></li></ul>\n<ol start=\"5\"><li> <p><code>consumeThreadMin/consumeThreadMax</code>：最小消费线程数，最大消费线程数，默认都是20。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8e814bb293f54f22a738411bfae1807f.png\"/></p> </li><li> <p><code>consumeTimeout</code>：消息阻塞使用线程的最长时间(以分钟为单位)，默认15。</p> </li><li> <p><code>pullThresholdSizeForQueue</code>：在队列级别限制缓存的消息大小，默认情况下每个消息队列最多缓存100MiB消息。</p> </li><li> <p><code>consumeConcurrentlyMaxSpan / pullThresholdForQueue</code>: 单队列并行消费允许的最大跨度，默认值2000， 队列级别的流量控制阈值，拉消息本地队列缓存消息最大数，默认1000。</p> </li><li> <p><code>pullInterval</code>： 消息拉取时间间隔，由于是长轮询，所以为0，但是如果应用为了流控，也可以设置大于0的值，单位毫秒，默认0。</p> </li><li> <p><code>pullBatchSize</code>： 批量拉消息，一次最多拉多少条，默认32。</p> </li><li> <p><code>consumeMessageBatchMaxSize</code>： 批量消费，一次消费多少条消息，默认1。</p> </li><li> <p><code>maxReconsumeTimes</code>：最大重试次数，并行模式下默认-1也就是16次，顺序模式下默认-1表示Integer.MAX_VALUE。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e7e562c1cb6647d38d3c0527bbe1baec.png\"/></p> </li><li> <p><code>awaitTerminationMillisWhenShutdown</code>：当关闭消费者时等待消息消耗的最大时间，0表示没有等待。默认0。</p> </li><li> <p><code>messageModel</code>：消息模型定义了将消息传递到每个客户端的方式，默认集群模式。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0e7e3b316e764c16ac6bb5f05ada0282.png\"/></p> </li></ol>\n<h2><a id=\"PushConsumer_41\"></a>PushConsumer消费模式-集群模式</h2>\n<p>GroupName用于把多个Consumer组织到一起，相同GroupName的Consumer只消费所订阅消息的一部分。<br/> 目的:达到天然的负载均衡机制。<strong>发消息队列数要和consumer数量为倍数,才能平均负载均衡。</strong><br/> 消费者采用负载均衡（集群模式）方式消费消息，一个分组(Group)下的多个消费者共同消费队列消息，每个消费者处理的消息不同。一个Consumer Group中的各个Consumer实例分摊去消费消息，即一条消息只会投递到一个Consumer Group下面的一个实例。例如某个Topic有3个队列，其中一个Consumer Group 有 3 个实例，那么每个实例只消费其中的1个队列。集群消费模式是消费者默认的消费方式。<br/> <strong>集群模式</strong>： 使用相同 Group ID 的订阅者属于同一个集群。 同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用） ， 这些订阅者在逻辑上可以认为是一个消费节点。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ff13cb5fd143432885e031530c7c223e.png\"/><br/> 消费端通过如下代码指定消费模式：</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">// 消费模式 默认是集群模式（负载均衡模式），还有是广播模式</span>\nconsumer<span class=\"token punctuation\">.</span><span class=\"token function\">setMessageModel</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MessageModel</span><span class=\"token punctuation\">.</span>CLUSTERING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>集群模式下，每个消费者消费的肯定不是同一个消息。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a30071e4159c4351b633eb871189d7cf.png\"/><br/> 集群模式下每一个queue都只能被一个消费者消费，但是每一个消费者都可以消费多个queue。</p>\n<p>集群模式适用场景&amp;注意事项：</p>\n<ul><li>消费端集群化部署， 每条消息只需要被处理一次；</li><li>由于消费进度在服务端维护， 可靠性更高。</li><li>Topic + Tag下的消息可以保证肯定会被整个集群至少消费一次 ；</li><li>不保证每一次失败重投的消息路由到同一台机器上， 因此处理消息时不应该做任何确定性假设。</li><li>集群中的每个消费者消费的消息肯定不会是同一条消息，因为实际上在集群模式下 \n  <ul><li>每一个queue都只能被一个消费者消费</li><li>但是每一个消费者都可以消费多个queue</li></ul> </li></ul>\n<blockquote>\n<p>本文内容到此结束了，<br/> 如有收获欢迎点赞👍收藏💖关注✔️，您的鼓励是我最大的动力。<br/> 如有错误❌疑问💬欢迎各位大佬指出。<br/> <strong>主页</strong>：<a href=\"https://zhanjq.blog.csdn.net/?type=blog\">共饮一杯无的博客汇总👨‍💻</a></p>\n<p><strong>保持热爱，奔赴下一场山海</strong>。🏃🏃🏃</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e811a3c0cfd94d29871196db256570b6.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-14 15:27:49", "summary": "文章目录核心参数详解消费模式集群模式核心参数详解在这里插入图片描述：消费者从那个位置开始消费在这里插入图片描述：第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费：第一次启动从队列初始"}