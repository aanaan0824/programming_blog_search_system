{"blogid": "125922910", "writerAge": "码龄1年", "writerBlogNum": "77", "writerCollect": "684", "writerComment": "1104", "writerFan": "919", "writerGrade": "5级", "writerIntegral": "3683", "writerName": "NO.-LL", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125922910.jpg", "writerRankTotal": "5192", "writerRankWeekly": "191", "writerThumb": "1241", "writerVisitNum": "44489", "blog_read_count": "464", "blog_time": "已于 2022-08-19 22:38:15 修改", "blog_title": "进阶C++__STL__容器list使用方法【简单易懂】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0\">list构造函数 </a></p>\n<p id=\"%C2%A0list%20%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0list%20%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2\">list 赋值和交换</a></p>\n<p id=\"%C2%A0list%20%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0list%20%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\">list 大小操作</a></p>\n<p id=\"list%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:40px;\"><a href=\"#list%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\">list 插入和删除</a></p>\n<p id=\"list%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#list%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\">list 数据存取</a></p>\n<p id=\"list%20%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#list%20%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F\">list 反转和排序</a></p>\n<p id=\"list%E5%8E%BB%E9%87%8D%E4%B8%8E%E7%BC%9D%E5%90%88-toc\" style=\"margin-left:40px;\"><a href=\"#list%E5%8E%BB%E9%87%8D%E4%B8%8E%E7%BC%9D%E5%90%88\">list去重与缝合</a></p>\n<p id=\"unique%20%E5%8E%BB%E9%87%8D-toc\" style=\"margin-left:80px;\"><a href=\"#unique%20%E5%8E%BB%E9%87%8D\">unique 去重</a></p>\n<p id=\"splice%20%E6%8E%A5%E5%90%88-toc\" style=\"margin-left:80px;\"><a href=\"#splice%20%E6%8E%A5%E5%90%88\">splice 接合</a></p>\n<p id=\"list%E5%88%A0%E9%99%A4%E5%AF%BC%E8%87%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#list%E5%88%A0%E9%99%A4%E5%AF%BC%E8%87%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98\">list删除导致迭代器失效问题</a></p>\n<p id=\"list%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#list%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">list代码实现</a></p>\n<p id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0list%E7%B1%BB%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0list%E7%B1%BB%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3\">模拟实现list类函数接口</a></p>\n<p id=\"0x00%20list.h-toc\" style=\"margin-left:80px;\"><a href=\"#0x00%20list.h\">list.h</a></p>\n<p id=\"0x01%20test.cpp-toc\" style=\"margin-left:80px;\"><a href=\"#0x01%20test.cpp\">test.cpp</a></p>\n<p id=\"0x02%20reverse_iterator.h-toc\" style=\"margin-left:80px;\"><a href=\"#0x02%20reverse_iterator.h\">reverse_iterator.h</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h2 id=\"list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0\">list构造函数 </h2>\n<ul><li><code>list&lt;T&gt; lst;</code> //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li></ul>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L){\n\tfor(list&lt;int&gt;::const_iterator it =L.begin();it!=L.end();it++){\n\t\tcout&lt;&lt;*it&lt;&lt;\" \";\n\t}\n\tcout&lt;&lt;endl;\n}\n\nvoid test01()\n{\n\tlist&lt;int&gt;L1;//默认构造 \n\tL1.push_back(10);\n\tL1.push_back(20);\n\tL1.push_back(30);\n\tL1.push_back(40);\n\n\tprintList(L1);\n\n\tlist&lt;int&gt;L2(L1.begin(),L1.end());//区间拷贝 \n\tprintList(L2);\n\n\tlist&lt;int&gt;L3(L2);//拷贝构造 \n\tprintList(L3);\n\n\tlist&lt;int&gt;L4(10, 1000);//构造函数将n个elem拷贝给本身\n\tprintList(L4);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p>10 20 30 40<br/> 10 20 30 40<br/> 10 20 30 40<br/> 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"%C2%A0list%20%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2\"> list 赋值和交换</h2>\n<p></p>\n<ul><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li><li><code>swap(lst);</code> //将lst与本身的元素互换。</li></ul>\n<p></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) {\n\n\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//赋值和交换\nvoid test01()\n{\n\tlist&lt;int&gt;L1;\n\tL1.push_back(10);\n\tL1.push_back(20);\n\tL1.push_back(30);\n\tL1.push_back(40);\n\tprintList(L1);\n\n\t//赋值\n\tlist&lt;int&gt;L2;\n\tL2 = L1;\n\tprintList(L2);\n\n\tlist&lt;int&gt;L3;\n\tL3.assign(L2.begin(), L2.end());\n\tprintList(L3);\n\n\tlist&lt;int&gt;L4;\n\tL4.assign(10, 100);\n\tprintList(L4);\n\n}\n\n//交换\nvoid test02()\n{\n\n\tlist&lt;int&gt;L1;\n\tL1.push_back(10);\n\tL1.push_back(20);\n\tL1.push_back(30);\n\tL1.push_back(40);\n\n\tlist&lt;int&gt;L2;\n\tL2.assign(10, 100);\n\n\tcout &lt;&lt; \"交换前： \" &lt;&lt; endl;\n\tprintList(L1);\n\tprintList(L2);\n\n\tcout &lt;&lt; endl;\n\n\tL1.swap(L2);\n\n\tcout &lt;&lt; \"交换后： \" &lt;&lt; endl;\n\tprintList(L1);\n\tprintList(L2);\n\n}\n\nint main() {\n\n\ttest01();\n\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p></p>\n<p>10 20 30 40<br/> 10 20 30 40<br/> 10 20 30 40<br/> 100 100 100 100 100 100 100 100 100 100<br/> 交换前：<br/> 10 20 30 40<br/> 100 100 100 100 100 100 100 100 100 100</p>\n<p>交换后：<br/> 100 100 100 100 100 100 100 100 100 100<br/> 10 20 30 40</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"%C2%A0list%20%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\"> list 大小操作</h2>\n<ul><li> <p><code>size();</code> //返回容器中元素的个数</p> </li><li> <p><code>empty();</code> //判断容器是否为空</p> </li><li> <p><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> </li></ul>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) {\n\n\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//大小操作\nvoid test01()\n{\n\tlist&lt;int&gt;L1;\n\tL1.push_back(10);\n\tL1.push_back(20);\n\tL1.push_back(30);\n\tL1.push_back(40);\n\n\tif (L1.empty())\n\t{\n\t\tcout &lt;&lt; \"L1为空\" &lt;&lt; endl;\n\t}\n\telse\n\t{\n\t\tcout &lt;&lt; \"L1不为空\" &lt;&lt; endl;\n\t\tcout &lt;&lt; \"L1的大小为： \" &lt;&lt; L1.size() &lt;&lt; endl;\n\t}\n\n\t//重新指定大小\n\tL1.resize(10);\n\tprintList(L1);\n\n\tL1.resize(2);\n\tprintList(L1);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>L1不为空<br/> L1的大小为： 4<br/> 10 20 30 40 0 0 0 0 0 0<br/> 10 20</p>\n</blockquote>\n<p></p>\n<h2 id=\"list%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\">list 插入和删除</h2>\n<ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul>\n<p></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) {\n\n\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//插入和删除\nvoid test01()\n{\n\tlist&lt;int&gt; L;\n\t//尾插\n\tL.push_back(10);\n\tL.push_back(20);\n\tL.push_back(30);\n\t//头插\n\tL.push_front(100);\n\tL.push_front(200);\n\tL.push_front(300);\n\n\tprintList(L);\n\n\t//尾删\n\tL.pop_back();\n\tprintList(L);\n\n\t//头删\n\tL.pop_front();\n\tprintList(L);\n\n\t//插入\n\tlist&lt;int&gt;::iterator it = L.begin();\n\tL.insert(++it, 1000);//链表不可跳跃访问 \n\tprintList(L);\n\n\t//删除\n\tit = L.begin();\n\tL.erase(++it);\n\tprintList(L);\n\n\t//移除\n\tL.push_back(10000);\n\tL.push_back(10000);\n\tL.push_back(10000);\n\tprintList(L);\n\tL.remove(10000);\n\tprintList(L);\n    \n    //清空\n\tL.clear();\n\tprintList(L);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n</code></pre>\n<blockquote>\n<p>300 200 100 10 20 30<br/> 300 200 100 10 20<br/> 200 100 10 20<br/> 200 1000 100 10 20<br/> 200 100 10 20<br/> 200 100 10 20 10000 10000 10000<br/> 200 100 10 20<br/> （清空时打印空字符串）</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"list%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\">list 数据存取</h2>\n<ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul>\n<blockquote>\n<p>    cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据<br/>     cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</p>\n<p>    list容器的迭代器是双向迭代器，不支持随机访问</p>\n<p>    it = it + 1;//错误，不可以跳跃访问，即使是+1</p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;list&gt;\n\n//数据存取\nvoid test01()\n{\n\tlist&lt;int&gt;L1;\n\tL1.push_back(10);\n\tL1.push_back(20);\n\tL1.push_back(30);\n\tL1.push_back(40);\n\n\t\n\t//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据\n\t//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据\n\tcout &lt;&lt; \"第一个元素为： \" &lt;&lt; L1.front() &lt;&lt; endl;\n\tcout &lt;&lt; \"最后一个元素为： \" &lt;&lt; L1.back() &lt;&lt; endl;\n\n\t//list容器的迭代器是双向迭代器，不支持随机访问\n\tlist&lt;int&gt;::iterator it = L1.begin();\n\t//it = it + 1;//错误，不可以跳跃访问，即使是+1\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n</code></pre>\n<blockquote>\n<p>第一个元素为： 10<br/> 最后一个元素为： 40</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"list%20%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F\">list 反转和排序</h2>\n<ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;list&gt;\nvoid printList(const list&lt;int&gt;&amp; L) {\n\n\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nbool myCompare(int val1 , int val2)\n{\n\treturn val1 &gt; val2;\n}\n\n//反转和排序\nvoid test01()\n{\n\tlist&lt;int&gt; L;\n\tL.push_back(90);\n\tL.push_back(30);\n\tL.push_back(20);\n\tL.push_back(70);\n\tprintList(L);\n\n\t//反转容器的元素\n\tL.reverse();\n\tprintList(L); \n\t//排序\n\tL.sort(); //默认的排序规则 从小到大\n\tprintList(L);\n\n\tL.sort(myCompare); //指定规则，从大到小\n\t//L.sort(greater&lt;int&gt;());也可以 \n\tprintList(L);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>90 30 20 70<br/> 70 20 30 90<br/> 20 30 70 90<br/> 90 70 30 20</p>\n</blockquote>\n<p></p>\n<h2 id=\"list%E5%8E%BB%E9%87%8D%E4%B8%8E%E7%BC%9D%E5%90%88\">list去重与缝合</h2>\n<h3 id=\"unique%20%E5%8E%BB%E9%87%8D\">unique 去重</h3>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\2045b922a79849108f0b1c225839a486.png\"/></p>\n<p>去重之前是有要求的，去重之前一定要先排序！如果不排序可能会去不干净。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n#include&lt;list&gt;\n\nvoid test11() {\n\tlist&lt;int&gt; L;\n\tL.push_back(2);\n\tL.push_back(1);\n\tL.push_back(2);\n\tL.push_back(1);\n\tfor (auto e : L) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\n\tL.sort(); // 去重前排个序\n\n\tcout &lt;&lt; \"去重后：\";\n\tL.unique();\n\tfor (auto e : L) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest11();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>2 1 2 1<br/> 去重后：1 2</p>\n</blockquote>\n<p></p>\n<h3 id=\"splice%20%E6%8E%A5%E5%90%88\">splice 接合</h3>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\ce9cdae51cc34a5782e0f963a208ffd0.png\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n#include&lt;list&gt;\n\nvoid test11() {\n\tlist&lt;int&gt; L1;\n\tL1.push_back(1);\n\tL1.push_back(2);\n\tL1.push_back(3);\n\tcout &lt;&lt; \"L1: \";\n\tfor (auto e : L1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\n\tlist&lt;int&gt; L2;\n\tL2.push_back(10);\n\tL2.push_back(20);\n\tL2.push_back(30);\n\tcout &lt;&lt; \"L2: \";\n\tfor (auto e : L2) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\n\tlist&lt;int&gt;::iterator pos = L1.begin();\n\tL1.splice(pos, L2);  // 把L2的内容，接到L1的begin()前面\n\tcout &lt;&lt; \"接合后：\";\n\tfor (auto e : L1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest11();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p> 输出：</p>\n<p>L1: 1 2 3<br/> L2: 10 20 30<br/> 接合后：10 20 30 1 2 3</p>\n</blockquote>\n<p></p>\n<p></p>\n<h3 id=\"list%E5%88%A0%E9%99%A4%E5%AF%BC%E8%87%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98\">list删除导致迭代器失效问题</h3>\n<pre><code class=\"language-cpp\">﻿template&lt;typename T&gt;\n\nvoid removeDuplicates(list&lt;T&gt;&amp; aList)\n\n{\n\n\tT curValue;\n\n\tlist&lt;T&gt;::iterator cur, p;\n\n\tcur = aList.begin();\n\n\twhile (cur != aList.end())\n\n\t{\n\n\t\tcurValue = *cur;\n\n\t\t//空白行 1\n\n\t\twhile (p != aList.end())\n\n\t\t{\n\n\t\t\tif (*p == curValue)\n\n\t\t\t{\n\n\t\t\t\t//空白行 2\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t{\n\n\t\t\t\tp++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}</code></pre>\n<blockquote>\n<p>A. p=cur+1;aList.erase(p++);</p>\n<p>B.p=++cur; p == cur ? cur = p = aList.erase(p) : p = aList.erase(p);</p>\n<p>C.p=cur+1;aList.erase(p);</p>\n<p>D.p=++cur;aList.erase(p);</p>\n<hr/>\n<p>分析：迭代p需要迭代不重复节点的下一节点，重要的是cur迭代器需要往下迭代，因此cur需要往前移动，二答案A C的cur都不会改变，空白行2是当需要找到重复值时进行节点删除，当删除时当前迭代器会失效，因此需要将迭代器p往后迭代，所以答案为 B</p>\n<p></p>\n</blockquote>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"list%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">list代码实现</h1>\n<h3 id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0list%E7%B1%BB%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3\">模拟实现list类函数接口</h3>\n<pre><code class=\"language-cpp\">namespace bite\n\n{\n\n  // List的节点类\n\n  template&lt;class T&gt;\n\n  struct ListNode\n\n  {\n\n    ListNode(const T&amp; val = T());\n\n    ListNode&lt;T&gt;* _pPre;\n\n    ListNode&lt;T&gt;* _pNext;\n\n    T _val;\n\n  };\n\n\n\n  //List的迭代器类\n\n  template&lt;class T, class Ref, class Ptr&gt;\n\n  class ListIterator\n\n  {\n\n    typedef ListNode&lt;T&gt;* PNode;\n\n    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;\n\n  public:\n\n    ListIterator(PNode pNode = nullptr)；\n\n    ListIterator(const Self&amp; l)；\n\n    T&amp; operator*()；\n\n    T* operator-&gt;()；\n\n    Self&amp; operator++()；\n\n    Self operator++(int)；\n\n    Self&amp; operator--();\n\n    Self&amp; operator--(int);\n\n    bool operator!=(const Self&amp; l)；\n\n    bool operator==(const Self&amp; l)；\n\n  private:\n\n    PNode _pNode;\n\n  };\n\n\n\n  //list类\n\n  template&lt;class T&gt;\n\n  class list\n\n  {\n\n    typedef ListNode&lt;T&gt; Node;\n\n    typedef Node* PNode;\n\n  public:\n\n    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;\n\n    typedef ListIterator&lt;T, const T&amp;, const T&amp;&gt; const_iterator;\n\n  public:\n\n    ///\n\n    // List的构造\n\n    list();\n\n    list(int n, const T&amp; value = T());\n\n    template &lt;class Iterator&gt;\n\n    list(Iterator first, Iterator last);\n\n    list(const list&lt;T&gt;&amp; l);\n\n    list&lt;T&gt;&amp; operator=(const list&lt;T&gt; l);\n\n    ~list();\n\n\n\n    ///\n\n    // List Iterator\n\n    iterator begin();\n\n    iterator end();\n\n    const_iterator begin();\n\n    const_iterator end();\n\n\n\n    ///\n\n    // List Capacity\n\n    size_t size()const;\n\n    bool empty()const;\n\n\n\n    \n\n    // List Access\n\n    T&amp; front();\n\n    const T&amp; front()const;\n\n    T&amp; back();\n\n    const T&amp; back()const;\n\n\n\n    \n\n    // List Modify\n\n    void push_back(const T&amp; val){insert(begin(), val);}\n\n    void pop_back(){erase(--end());}\n\n    void push_front(const T&amp; val){insert(begin(), val);}\n\n    void pop_front(){erase(begin());}\n\n    // 在pos位置前插入值为val的节点\n\n    iterator insert(iterator pos, const T&amp; val);\n\n    // 删除pos位置的节点，返回该节点的下一个位置\n\n    iterator erase(iterator pos);\n\n    void clear();\n\n    void swap(List&lt;T&gt;&amp; l);\n\n  private:\n\n    void CreateHead();\n\n    PNode _pHead;\n\n  };\n\n};</code></pre>\n<h3 id=\"0x00%20list.h\">list.h</h3>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS 1\n#include &lt;iostream&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n \nnamespace chaos\n{\n\t/* 定义结点 */\n\ttemplate&lt;class T&gt;\n\tstruct ListNode {\n\t\tT _data;\t\t\t\t  // 用来存放结点的数据\n\t\tListNode&lt;T&gt;* _next;       // 指向后继结点的指针\n\t\tListNode&lt;T&gt;* _prev;\t      // 指向前驱结点的指针\n \n\t\tListNode(const T&amp; data = T())   // 全缺省构造（初始化）\n\t\t\t: _data(data)\n\t\t\t, _next(nullptr)\n\t\t\t, _prev(nullptr)\n\t\t{}\n\t};\n \n\t/* 定义迭代器 */\n\ttemplate&lt;class T, class Ref, class Ptr&gt;\n\tstruct __list_iterator {\n\t\ttypedef ListNode&lt;T&gt; Node;\n\t\ttypedef __list_iterator&lt;T, Ref, Ptr&gt; self;    // 为了方便我们重命名为self\n\t\t\n\t\ttypedef Ref reference;\n\t\ttypedef Ptr pointer;\n \n\t\tNode* _node;\n \n\t\t__list_iterator(Node* x)\n\t\t\t: _node(x) \n\t\t{}\n \n\t\t/* 解引用 */\n\t\tRef operator*() {\n\t\t\treturn _node-&gt;_data;       // 返回结点的数据\n\t\t}\n\t\tPtr operator-&gt;() {\n\t\t\treturn &amp;_node-&gt;_data;     \n\t\t}\n \n\t\t/* ++it */\n\t\tself&amp; operator++() {\n\t\t\t_node = _node-&gt;_next;  // 让 _node 指向下一个结点\n\t\t\treturn *this;  // 返回加加后的值\n\t\t}\n\t\t/* it++ */\n\t\tself operator++(int) {\n\t\t\tself tmp(*this);   // 拷贝构造一个tmp存储原来的值\n\t\t\t_node = _node-&gt;_next;\n\t\t\treturn tmp;\n\t\t}\n\t\t/* != */\n\t\tbool operator!=(const self&amp; it) {\n\t\t\treturn _node != it._node;  // 它们结点的指针不一样吗？T or F\n\t\t}\n \n\t\t/* --it */\n\t\tself&amp; operator--() {\n\t\t\t_node = _node-&gt;_prev;  \n\t\t\treturn *this;\n\t\t}\n\t\t/* it-- */\n\t\tself operator--(int) {\n\t\t\tself tmp(*this); \n\t\t\t_node = _node-&gt;_prev;\n\t\t\treturn tmp;\n\t\t}\n\t};\n \n\t///* 定义const迭代器 */\n\t//template&lt;class T&gt;\n\t//struct __const_list_iterator {\n\t//\ttypedef ListNode&lt;T&gt; Node;\n\t//\tNode* _node;\n \n\t//\t__const_list_iterator(Node* x)\n\t//\t\t: _node(x)\n\t//\t{}\n\t//\t/* 解引用 */\n\t//\tconst T&amp; operator*() {\n\t//\t\treturn _node-&gt;_data;       // 返回结点的数据\n\t//\t}\n\t//\t/* ++it */\n\t//\t__const_list_iterator&lt;T&gt;&amp; operator++() {\n\t//\t\t_node = _node-&gt;_next;  // 让 _node 指向下一个结点\n\t//\t\treturn *this;  // 返回加加后的值\n\t//\t}\n\t//\t/* it++ */\n\t//\t__const_list_iterator&lt;T&gt; operator++(int) {\n\t//\t\t__const_list_iterator&lt;T&gt; tmp(*this);   // 拷贝构造一个tmp存储原来的值\n\t//\t\t_node = _node-&gt;_next;\n\t//\t\treturn tmp;\n\t//\t}\n\t//\t/* != */\n\t//\tbool operator!=(const __const_list_iterator&lt;T&gt;&amp; it) {\n\t//\t\treturn _node != it._node;  // 它们结点的指针不一样吗？T or F\n\t//\t}\n\t//\t/* --it */\n\t//\t__const_list_iterator&lt;T&gt;&amp; operator--() {\n\t//\t\t_node = _node-&gt;_prev;\n\t//\t\treturn *this;\n\t//\t}\n\t//\t/* it-- */\n\t//\t__const_list_iterator&lt;T&gt; operator--(int) {\n\t//\t\t__list_iterator&lt;T&gt; tmp(*this);\n\t//\t\t_node = _node-&gt;_prev;\n\t//\t\treturn tmp;\n\t//\t}\n\t//};\n \n\t/* 定义链表 */\n\ttemplate&lt;class T&gt;\n\tclass list {\n\t\ttypedef ListNode&lt;T&gt; Node;      // 重命名为Node\n\tpublic:\n\t\t/* 迭代器 */\n\t\ttypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;\n\t\ttypedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\t\titerator begin() { \n\t\t\treturn iterator(_pHead-&gt;_next); \n\t\t}\n\t\titerator end() { \n\t\t\treturn iterator(_pHead); \n\t\t}\n\t\tconst_iterator begin() const {\n\t\t\treturn const_iterator(_pHead-&gt;_next);  \n\t\t}\n\t\tconst_iterator end() const {\n\t\t\treturn const_iterator(_pHead);\n\t\t}\n \n\t\t/* 构造函数：初始化头结点 */\n\t\tlist() {\n\t\t\t_pHead = new Node();\n\t\t\t_pHead-&gt;_next = _pHead;\n\t\t\t_pHead-&gt;_prev = _pHead;\n\t\t}\n\t\tlist(size_t n, const T&amp; val = T()) {   // 初始化n个结点\n\t\t\t_pHead = new Node();\n\t\t\t_pHead-&gt;_next = _pHead;\n\t\t\t_pHead-&gt;_prev = _pHead;\n\t\t\tfor (size_t i = 0; i &lt; n; i++) {\n\t\t\t\tpush_back(val);\n\t\t\t}\n\t\t}\n\t\tlist(int n, const T&amp; val = T()) {   // 初始化n个结点\n\t\t\t_pHead = new Node();\n\t\t\t_pHead-&gt;_next = _pHead;\n\t\t\t_pHead-&gt;_prev = _pHead;\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tpush_back(val);\n\t\t\t}\n\t\t}\n \n\t\ttemplate&lt;class InputIterator&gt; \n\t\tlist(InputIterator first, InputIterator last) {\n\t\t\t_pHead = new Node();\n\t\t\t_pHead-&gt;_next = _pHead;\n\t\t\t_pHead-&gt;_prev = _pHead;\n \n\t\t\twhile (first != last) {\n\t\t\t\tpush_back(*first);\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t}\n\t\t/* 拷贝构造（现代写法）：L2(L1) */\n\t\tlist(const list&lt;T&gt;&amp; L) {\n\t\t\t_pHead = new Node();\n\t\t\t_pHead-&gt;_next = _pHead;\n\t\t\t_pHead-&gt;_prev = _pHead;\n \n\t\t\tlist&lt;T&gt; tmp(L.begin(), L.end());\n\t\t\tswap(_pHead, tmp._pHead);\n\t\t}\n \n\t\t/* 拷贝构造：L2(L1) */\n\t\t/*list(const list&lt;T&gt;&amp; L) {\n\t\t\t_pHead = new Node();\n\t\t\t_pHead-&gt;_next = _pHead;\n\t\t\t_pHead-&gt;_prev = _pHead;\n\t\t\tfor (auto e : L) {\n\t\t\t\tpush_back(e);\n\t\t\t}\n\t\t}*/\n \n\t\t///* 赋值：L2 = L1 */\n\t\t//list&lt;T&gt;&amp; operator=(list&lt;T&gt; L) {\n\t\t//\tif (this != &amp;L) {\n\t\t//\t\tclear();\n\t\t//\t\tfor (auto e : L) {\n\t\t//\t\t\tpush_back(e);\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\treturn *this;\n\t\t//}\n \n \n\t\t/* 赋值（现代写法）：L2 = L1 */\n\t\tlist&lt;T&gt;&amp; operator=(list&lt;T&gt; L) {\n\t\t\tswap(_pHead, L._pHead);\n\t\t\treturn *this;\n\t\t}\n \n \n\t\t/* 在pos位置前插入 */\n\t\tvoid insert(iterator pos, const T&amp; x) {\n\t\t\tNode* cur = pos._node;     // 找到pos位置的结点\n\t\t\tNode* cur_prev = cur-&gt;_prev;     // 因为要在pos位置前插入，所以要找到当前pos位置的前一个结点\n\t\t\tNode* new_node = new Node(x);  // 创建新节点\n \n\t\t\t// 缝合： cur_prev &lt;-&gt; new_node &lt;-&gt; cur\n\t\t\tcur_prev-&gt;_next = new_node;\n\t\t\tnew_node-&gt;_prev = cur_prev;\n\t\t\tnew_node-&gt;_next = cur;\n\t\t\tcur-&gt;_prev = new_node;\n\t\t}\n \n\t\t/* 尾插：push_back */\n\t\tvoid push_back(const T&amp; x) {\n\t\t\t//Node* pTail = _pHead-&gt;_prev;     // pHead的前驱就是pTail\n\t\t\t//Node* new_node = new Node(x);    // 创建新结点（会调用构造，自动创建）\n\t\t\t//\n\t\t\t//pTail-&gt;_next = new_node;\n\t\t\t//new_node-&gt;_prev = pTail;\n\t\t\t//new_node-&gt;_next = _pHead;\n\t\t\t//_pHead-&gt;_prev = new_node;\n \n\t\t\tinsert(end(), x);   // 在end(头结点)前插入，即尾插\n\t\t}\n \n\t\t/* 头插：push_front */\n\t\tvoid push_front(const T&amp; x) {\n\t\t\tinsert(begin(), x);  // 在begin（头结点的下一个结点）前插入，即头插\n\t\t}\n \n \n\t\t/* 任意位置删除 */\n\t\titerator erase(iterator pos) {\n\t\t\tassert(pos != end());   // 防止头结点被删除\n \n\t\t\tNode* cur = pos._node;   // 找到pos位置的结点\n\t\t\tNode* cur_prev = cur-&gt;_prev;   // 找到pos的前驱\n\t\t\tNode* cur_next = cur-&gt;_next;   // 找到pos的后继\n \n\t\t\t// 删除cur\n\t\t\tdelete cur;\n \n\t\t\t// 缝合：  cur_prev &lt;-&gt; cur(删) &lt;-&gt; cur_next\n\t\t\tcur_prev-&gt;_next = cur_next;\n\t\t\tcur_next-&gt;_prev = cur_prev;\n \n\t\t\treturn iterator(cur_next);\n\t\t}\n \n\t\t/* 尾删 */\n\t\tvoid pop_back() {\n\t\t\terase(--end());  // 删除最后一个元素，即尾结点\n\t\t}\n \n\t\t/* 头删 */\n\t\tvoid pop_front() {\n\t\t\terase(begin());  // 删除头结点的下一个结点（即begin位置的结点）\n\t\t}\n \n\t\t/* 清空链表所有数据 */\n\t\tvoid clear() {\n\t\t\t 利用迭代器去遍历整个链表\n\t\t\t//iterator it = begin();\n\t\t\t//while (it != end()) {\n\t\t\t//\titerator del = it++;  // 巧妙利用后置++的特性\n\t\t\t//\tdelete del._node;  // 删除当前结点，后置++生效\n\t\t\t//}\n \n\t\t\t 删完之后我们还需要将其恢复到初始状态\n\t\t\t//_pHead-&gt;_next = _pHead;\n\t\t\t//_pHead-&gt;_prev = _pHead;\n \n\t\t\titerator it = begin();\n\t\t\twhile (it != end()) {\n\t\t\t\t// iterator del = it++;\n\t\t\t\terase(it++);   // 直接反复调用erase删除结点\n\t\t\t}\n\t\t}\n \n\t\t~list() {\n\t\t\t// 清空链表有效数据\n\t\t\tclear();\n\t\t\t// 干掉头结点\n\t\t\tdelete _pHead;\n\t\t\t_pHead = nullptr;\n\t\t}\n \n\tprivate:\n\t\tNode* _pHead;\n\t};\n \n\t\tvoid print_list(const list&lt;int&gt;&amp; L) {\n\t\t\tlist&lt;int&gt;::const_iterator it = L.begin();\n\t\t\twhile (it != L.end()) {\n\t\t\t\t// *it = 100;\n\t\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tcout &lt;&lt; endl;\n\t\t}\n \n \n\t\tvoid test_list1() {\n\t\t\tlist&lt;int&gt; L;\n\t\t\tL.push_back(1);\n\t\t\tL.push_back(2);\n\t\t\tL.push_back(3);\n\t\t\tL.push_back(4);\t\n \n\t\t\tlist&lt;int&gt;::iterator it = L.begin();\n\t\t\twhile (it != L.end()) {\n\t\t\t\t*it *= 2;\n\t\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tcout &lt;&lt; endl;\n\t\t}\n \n\t\tvoid test_list2() {\n\t\t\tlist&lt;int&gt; L;\n\t\t\tL.push_back(2);\n\t\t\tL.push_back(4);\n\t\t\tL.push_back(6);\n\t\t\tL.push_back(8);\n \n\t\t\tprint_list(L);\n\t\t}\n \n \n\t\tstruct Date {\n\t\t\tint _year;\n\t\t\tint _month;\n\t\t\tint _day;\n \n\t\t\tDate(int year = 1, int month = 1, int day = 1) \n\t\t\t\t: _year(year)\n\t\t\t\t, _month(month)\n\t\t\t\t, _day(day) \n\t\t\t{}\n\t\t};\n \n\t\tvoid test_list3() {\n\t\t\tlist&lt;Date&gt; L;\n\t\t\tL.push_back(Date(2022, 5, 1));\n\t\t\tL.push_back(Date(2022, 5, 2));\n\t\t\tL.push_back(Date(2022, 5, 3));\n \n\t\t\tlist&lt;Date&gt;::iterator it = L.begin();\n\t\t\twhile (it != L.end()) {\n\t\t\t\tcout &lt;&lt; it-&gt;_year &lt;&lt; \"/\" &lt;&lt; it-&gt;_month &lt;&lt; \"/\" &lt;&lt; it-&gt;_day &lt;&lt; endl;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tcout &lt;&lt; endl;\n\t\t}\n \n\t\tvoid test_list4() {\n\t\t\tlist&lt;int&gt; L1;\n\t\t\tL1.push_back(1);\n\t\t\tL1.push_back(2);\n\t\t\tL1.push_back(3);\n \n\t\t\tlist&lt;int&gt; L2(L1);\n\t\t\tfor (auto e : L2) cout &lt;&lt; e &lt;&lt; \" \";\n\t\t}\n \n\t\tvoid test_list5() {\n\t\t\tlist&lt;int&gt; L;\n\t\t\tL.push_back(1);\n\t\t\tL.push_back(2);\n\t\t\tL.push_back(3);\n\t\t\tcout &lt;&lt; \"删除前：\";\n\t\t\tprint_list(L);\n \n\t\t\tcout &lt;&lt; \"删除后：\";\n\t\t\tL.clear();\n\t\t\tprint_list(L);\n\t\t}\n}\n \n\n-------------------------------------------------------------------\nnamespace bite\n\n{\n\n  // List的节点类\n\n  template&lt;class T&gt;\n\n  struct ListNode\n\n  {\n\n    ListNode(const T&amp; val = T()): _pPre(nullptr), _pNext(nullptr), _val(val)\n\n    {}\n\n    ListNode&lt;T&gt;* _pPre;\n\n    ListNode&lt;T&gt;* _pNext;\n\n    T _val;\n\n  };\n\n\n\n  //List的迭代器类\n\n  template&lt;class T, class Ref, class Ptr&gt;\n\n  class ListIterator\n\n  {\n\n    typedef ListNode&lt;T&gt;* PNode;\n\n    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;\n\n  public:\n\n    ListIterator(PNode pNode = nullptr):_pNode(pNode)\n\n    {}\n\n    ListIterator(const Self&amp; l): _pNode(l._pNode)\n\n    {}\n\n    T&amp; operator*()\n\n    {\n\n      return _pNode-&gt;_val;\n\n    }\n\n    T* operator-&gt;()\n\n    {\n\n      return &amp;*this;\n\n    }\n\n    Self&amp; operator++()\n\n    {\n\n      _pNode = _pNode-&gt;_pNext;\n\n      return *this;\n\n    }\n\n    Self operator++(int)\n\n    {\n\n      Self temp(*this);\n\n      _pNode = _pNode-&gt;_pNext;\n\n      return temp;\n\n    }\n\n    Self&amp; operator--()\n\n    {\n\n      _pNode = _pNode-&gt;_pPre;\n\n      return *this;\n\n    }\n\n    Self&amp; operator--(int)\n\n    {\n\n      Self temp(*this);\n\n      _pNode = _pNode-&gt;_pPre;\n\n      return temp;\n\n    }\n\n    bool operator!=(const Self&amp; l)\n\n    {\n\n      return _pNode != l._pNode;\n\n    }\n\n    bool operator==(const Self&amp; l)\n\n    {\n\n      return !(*this!=l);\n\n    }\n\n  private:\n\n    PNode _pNode;\n\n  };\n\n\n\n  //list类\n\n  template&lt;class T&gt;\n\n  class list\n\n  {\n\n    typedef ListNode&lt;T&gt; Node;\n\n    typedef Node* PNode;\n\n  public:\n\n    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;\n\n    typedef ListIterator&lt;T, const T&amp;, const T&amp;&gt; const_iterator;\n\n  public:\n\n    ///\n\n    // List的构造\n\n    list()\n\n    {\n\n      CreateHead();\n\n    }\n\n    list(int n, const T&amp; value = T())\n\n    {\n\n      CreateHead();\n\n      for (int i = 0; i &lt; n; ++i)\n\n       push_back(value);\n\n    }\n\n    template &lt;class Iterator&gt;\n\n    list(Iterator first, Iterator last)\n\n    {\n\n      CreateHead();\n\n      while (first != last)\n\n      {\n\n        push_back(*first);\n\n        ++first;\n\n      }\n\n    }\n\n    list(const list&lt;T&gt;&amp; l)\n\n    {\n\n      CreateHead();\n\n      // 用l中的元素构造临时的temp,然后与当前对象交换\n\n      list&lt;T&gt; temp(l.cbegin(), l.cend());\n\n      this-&gt;swap(temp);\n\n    }\n\n    list&lt;T&gt;&amp; operator=(const list&lt;T&gt; l)\n\n    {\n\n      this-&gt;swap(l);\n\n      return *this;\n\n    }\n\n    ~list()\n\n    {\n\n      clear();\n\n      delete _pHead;\n\n      _pHead = nullptr;\n\n    }\n\n\n\n    ///\n\n    // List Iterator\n\n    iterator begin()\n\n    {\n\n      return iterator(_pHead-&gt;_pNext);\n\n    }\n\n    iterator end()\n\n    {\n\n      return iterator(_pHead);\n\n    }\n\n    const_iterator begin()const\n\n    {\n\n      return const_iterator(_pHead-&gt;_pNext);\n\n    }\n\n    const_iterator end()const\n\n    {\n\n      return const_iterator(_pHead);\n\n    }\n\n\n\n    ///\n\n    // List Capacity\n\n    size_t size()const\n\n    {\n\n      size_t size = 0;\n\n      ListNode *p = _pHead-&gt;_pNext;\n\n      while(p != _pHead)\n\n      {\n\n        size++;\n\n        p = p-&gt;_pNext;\n\n      }\n\n      return size;       \n\n    }\n\n    bool empty()const\n\n    {\n\n      return size() == 0;\n\n    }\n\n\n\n    \n\n    // List Access\n\n    T&amp; front()\n\n    {\n\n      assert(!empty());\n\n      return _pHead-&gt;_pNext-&gt;_val;\n\n    }\n\n    const T&amp; front()const\n\n    {\n\n      assert(!empty());\n\n      return _pHead-&gt;_pNext-&gt;_val;\n\n    }\n\n    T&amp; back()\n\n    {\n\n      assert(!empty());\n\n      return _pHead-&gt;_pPre-&gt;_val;\n\n    }\n\n    const T&amp; back()const\n\n    {\n\n      assert(!empty());\n\n      return _pHead-&gt;_pPre-&gt;_val;\n\n    }\n\n\n\n    \n\n    // List Modify\n\n    void push_back(const T&amp; val)\n\n    {\n\n      insert(begin(), val);\n\n    }\n\n    void pop_back()\n\n    {\n\n      erase(--end());\n\n    }\n\n    void push_front(const T&amp; val)\n\n    {\n\n      insert(begin(), val);\n\n    }\n\n    void pop_front()\n\n    {\n\n      erase(begin());\n\n    }\n\n    // 在pos位置前插入值为val的节点\n\n    iterator insert(iterator pos, const T&amp; val)\n\n    {\n\n      PNode pNewNode = new Node(val);\n\n      PNode pCur = pos._pNode;\n\n      // 先将新节点插入\n\n      pNewNode-&gt;_pPre = pCur-&gt;_pPre;\n\n      pNewNode-&gt;_pNext = pCur;\n\n      pNewNode-&gt;_pPre-&gt;_pNext = pNewNode;\n\n      pCur-&gt;_pPre = pNewNode;\n\n      return iterator(pNewNode);\n\n    }\n\n    // 删除pos位置的节点，返回该节点的下一个位置\n\n    iterator erase(iterator pos)\n\n    {\n\n      // 找到待删除的节点\n\n      PNode pDel = pos._pNode;\n\n      PNode pRet = pDel-&gt;_pNext;\n\n      // 将该节点从链表中拆下来并删除\n\n      pDel-&gt;_pPre-&gt;_pNext = pDel-&gt;_pNext;\n\n      pDel-&gt;_pNext-&gt;_pPre = pDel-&gt;_pPre;\n\n      delete pDel;\n\n      return iterator(pRet);\n\n    }\n\n    void clear()\n\n    {\n\n      iterator p = begin();\n\n      while(p != end())\n\n      {\n\n        p = erase(p);\n\n      }\n\n    }\n\n    void swap(List&lt;T&gt;&amp; l)\n\n    {\n\n      pNode tmp = _pHead;\n\n      _pHead = l._pHead;\n\n      l._pHead = tmp;\n\n    }\n\n  private:\n\n    void CreateHead()\n\n    {\n\n      _pHead = new Node;\n\n      _pHead-&gt;_pPre = _pHead;\n\n      _pHead-&gt;_pNext = _pHead;\n\n    }\n\n    PNode _pHead;\n\n  };\n\n}</code></pre>\n<h3 id=\"0x01%20test.cpp\">test.cpp</h3>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS 1\n#include \"list.h\"\n \nint main(void)\n{\n\tchaos::test_list1();\n \n\treturn 0;\n}</code></pre>\n<h3 id=\"0x02%20reverse_iterator.h\">reverse_iterator.h</h3>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS 1\n#include \"list.h\"\n \nnamespace chaos\n{\n\t// Iterator是哪个容器的迭代器，reverse_iterator&lt;Iterator&gt;就可以\n\t// 适配出哪个容器的反向迭代器。复用的体现\n\t//template &lt;class Iterator, class Ref, class Ptr&gt;\n \n\t/* 定义反向迭代器 */\n\ttemplate &lt;class Iterator&gt;\n\tclass reverse_iterator {\n\t\ttypedef reverse_iterator&lt;Iterator, Ref, Ptr&gt; self;\n\t\ttypedef typename Iterator::Ref reference;  \n\t\ttypedef typename Iterator::Ptr pointer;\n\tpublic:\n\t\treverse_iterator(Iterator it)\n\t\t\t:_it(it)\n\t\t{}\n \n\t\tRef operator*() {\n\t\t\t//return *_it;\n\t\t\tIterator prev = _it;\n\t\t\treturn *--prev;\n\t\t}\n \n\t\tPtr operator-&gt;() {\n\t\t\treturn &amp;operator*();\n\t\t}\n \n\t\tself&amp; operator++() {\n\t\t\t--_it;\n\t\t\treturn *this;\n\t\t}\n \n\t\tself&amp; operator--() {\n\t\t\t++_it;\n\t\t\treturn *this;\n\t\t}\n \n\t\tbool operator!= (const self&amp; rit) const {\n\t\t\treturn _it != rit._it;\n\t\t}\n \n\tprivate:\n\t\tIterator _it;\n\t};\n}\n \n </code></pre>\n<p></p>\n<p style=\"text-align:center;\"></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-19 22:38:15", "summary": "目录构造函数赋值和交换大小操作插入和删除数据存取反转和排序去重与缝合去重接合删除导致迭代器失效问题代码实现模拟实现类函数接口构造函数采用采用模板类实现对象的默认构造形式：构造函数将区间中的元素拷贝给本"}