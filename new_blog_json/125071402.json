{"blogid": "125071402", "writerAge": "码龄2年", "writerBlogNum": "44", "writerCollect": "29", "writerComment": "3", "writerFan": "54", "writerGrade": "3级", "writerIntegral": "470", "writerName": "^命铭", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125071402.jpg", "writerRankTotal": "38552", "writerRankWeekly": "60818", "writerThumb": "20", "writerVisitNum": "17606", "blog_read_count": "1600", "blog_time": "于 2022-05-31 18:48:19 发布", "blog_title": "C#Thread", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<ol><li style=\"text-align:justify;\"><span style=\"color:#000000;\">线程(Thread)与进程(Process)</span></li></ol>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">线程是一个可执行路径,它可以独立于其他线程执行</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">每个线程都在操作系统的进程(Process)内执行,而操作系统进程提供了程序远行的独立环境</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">根据线程可分为:</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">单线程应用,在进程的独立环境里只跑一个线程,所以该线程拥有独占权;</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">多线程应用,当单个线程中共会跑多个线程,它们会共享当前执行环境(尤其是内存);</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">2在C#中提供的一个Thread类创建和控制线程,设置其优先级并获取其状态;</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">命名空间:System.Threading</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">程序集:System.Threading.Thread.dll</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">.NET6中为Thread提供的属性</span></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">属性名称</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">作用</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">ApartmentState</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置此线程的单元状态</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">CurrentCulture</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置当前线程的区域性</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">CurrentPrinicipal</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置线程的当前负责人</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">CurrentThread</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取当前正在运行的线程</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">CurrentUICulture</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置资源管理器使用当前区域性以便在运行时查找区域性特定的资源</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">ExecutionContext</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取ExecutionContext对象,该对象包含有关当前线程的各种上下文的信息</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">IsAlive</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取指示当前线程的执行状态的值</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">IsBackground</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置一个值,该值指示某个线程是否为后台线程</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">IsThreadPoolThread</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取指示线程是否属于托管线程池的值</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">ManagedThreadld</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取当前托管线程的唯一标识符</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Name</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置线程的名称</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Priority</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取或设置指示线程的调度优先级的值</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">ThreadState</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取一个值,该值包含当前线程的状态</span></p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">.NET 6为Thread提供的方法</span></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">方法名称</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">作用</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">AllocateDataSlot()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在所有线程上分配未命名的数据槽.为了获得更好的性能,请改用以ThreadStaicAttribute特性标记的字段</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">AllocateNameDataSlot(String)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在所有线程上分配未命名的数据槽.为了获得更好的性能,请改用以ThreadStaicAttribute特性标记的字段</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">BeginCriticalRegin()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">通知宿主执行将要进入一个代码区域,在该代码区域内线程中止或未经处理异常的影响可能会危害有应用程序域中的其他任务</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">BeginThreadAffinity()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">DisableComObjectEagerCleanup()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">对于当前线程关闭远行时可调用包装(RCW)的自动清理</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">EndCriticalRegion()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">通知主机执行将要进入一个代码区域,在该代码区域内线程中止或未经处理异常的影响限于当前任务</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">EndThreadAffinity()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">通知主机托管代码已执行完依赖于当前物理操作系统线程的标识的指令</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Finalize()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">确保垃圾回收Thread对象时释放资源并执行其他清理操作</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">FreeNamedDataSlot(String)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">为进程中所有线程消除名称与槽之间的关联.为了获得更好的性能,请改用以ThreadStaticAttribute特性标记的字段</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetApartmentState()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">返回表示单元状态的ApartmentState值</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetCompressedStack()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">返回CompressedStack对象,此对象可用于获取当前线程的堆栈.</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetCurrentProcessorld()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">获取用于指示当前线程正在哪个处理器上执行的ID</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetData(LocalDataStoreSlot)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在当前线程的当前域中从当前线程上指定的槽中检索值.为了获取更好的性能,请改用以ThreadStaticAttribute特性标记的字段</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetDomain()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">返回当前线程正在其中运行的当前域</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetDomainID()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">返回唯一的应用程序域标识符</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetHashCode()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">返回当前线程的哈希代码</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">GetNamedDataSlot(String)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">查找命名的数据槽.为了获取更好的性能,请改用ThreadStaticAttribute特性标记的字段</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Interrupt()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">中断处于WaitSleepJoin线程状态的线程</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Join()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在此实例表示的线程终止前,阻止调用线程</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">MemoryBarrier()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">按如下方式同步内存访问:执行当前线程的处理器在对指令重新排序时.不能采用先执行MemoryBarrier()调用之后的内存存取,在执行MemoryBarrier()调用之前的内存存取的方式</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">ResetAbort()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">取消当前线程所请求的Abort(Object)</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">SetApartmentState(ApartmentState)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在线程启动前设置其单元状态</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">SetCompressedStack(CompressedStack)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">将捕获的CompressedStack应用到当前线程</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">SetData</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在当前正在运行的线程上为此线程的当前域在指定槽中设置数据.为了提高性能,请改用用ThreadStaticAttribute属性标记的字段</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Sleep()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">将当前线程挂起指定的时间</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">SpinWait(int iterations)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">导致线程等待由iterations参数定义的时间量</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Start()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">使线程得以按计划执行</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">TrySetApartmentState(ApartmentState)</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在线程启动前设置单元状态</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">VolatileRead()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">读取字段值</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">VolatoleWrite()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">向字段中写入值</span></p> </td></tr><tr><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">Yield()</span></p> </td><td style=\"vertical-align:top;width:213.05pt;\"> <p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">导致调用线程执行准备好在当前处理器上运行的另一个线程.由操作系统选择要执行的线程</span></p> </td></tr></tbody></table>\n<pre><code>   static void Main(string[] args)\n        {\n            Thread t = new Thread(new ThreadStart(Thre));\n            t.Name = \"t1\";\n            t.Start();\n\n            for (int i = 0; i &lt; 100; i++)\n            {\n                Console.Write(\"i\");\n\n            }\n         \n        }\n\n        private static void Thre()\n        {\n            for (int m = 0; m &lt; 200; m++)\n            {\n                Console.Write(\"thre\");\n                \n            }\n            Console.WriteLine(\"正在运行的线程名字为:{0}\",Thread.CurrentThread.Name);\n        }\n      </code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">控制台输出的内容是:</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"171\" src=\"..\\..\\static\\image\\68bc832c8a3247d992d6015d0cc24627.jpeg\" width=\"966\"/></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">线程的阻塞:</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如果线程的执行由于某种原因导致暂停,那么就认为该线程被阻塞了.</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">例如在Sleep()或通过join()等待其他线程结束.</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">被阻塞的线程会立即将器处理器的时间片生成给其他线程,从此就不再消耗消耗处理器时间,直到满足阻塞条件为止.</p>\n<p> </p>\n<pre><code> \n   static Thread t1, t2;\n        static void Main(string[] args)\n        {\n            t1 = new Thread(Thre1);\n            t1.Name = \"Thread1\";\n            t1.Start();\n\n            t2 = new Thread(Thre1);\n            t2.Name = \"Thread2\";\n            t2.Start();\n        }\n\n        private static void Thre1()\n        {\n        \n            for (int m = 0; m &lt; 10; m++)\n            {\n                Console.Write(\"thre\");\n            }\n             \n            Console.WriteLine(\"正在运行的线程名字为:{0}\",Thread.CurrentThread.Name);\n            Thread.Sleep(9000);\n        }</code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><span style=\"color:#000000;\">在该实例中输入t1的名字后过9秒才输出t2的名字;</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可以通过ThreadState()这个属性来判断线程是否被阻塞的状态;</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">解除阻塞Unblocking</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">当遇到下列四种情况的时候,就会解除阻塞:</p>\n<ol><li style=\"text-align:justify;\">阻塞条件被满足</li><li style=\"text-align:justify;\">操作超时(如果设置超时的话)</li><li style=\"text-align:justify;\">通过Thread.Interrupt()进行打断</li><li style=\"text-align:justify;\">通过Thread.Abort()进行中止</li></ol>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-31 18:48:19", "summary": "线程与进程线程是一个可执行路径它可以独立于其他线程执行每个线程都在操作系统的进程内执行而操作系统进程提供了程序远行的独立环境根据线程可分为单线程应用在进程的独立环境里只跑一个线程所以该线程拥有独占权多"}