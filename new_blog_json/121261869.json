{"blogid": "121261869", "writerAge": "码龄1年", "writerBlogNum": "59", "writerCollect": "2928", "writerComment": "1392", "writerFan": "5873", "writerGrade": "5级", "writerIntegral": "3453", "writerName": "D大调奏鸣曲_第七序章_", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121261869.jpg", "writerRankTotal": "17599", "writerRankWeekly": "5373", "writerThumb": "1080", "writerVisitNum": "204156", "blog_read_count": "66378", "blog_time": "已于 2022-05-31 16:57:49 修改", "blog_title": "java IO流", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BA%8F\">序</a></p>\n<p id=\"%E4%B8%80%E3%80%81IO%E6%B5%81%E5%BC%80%E7%AF%87-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81IO%E6%B5%81%E5%BC%80%E7%AF%87\">一、IO流开篇</a></p>\n<p id=\"1%E3%80%81%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E6%A6%82%E5%BF%B5\">1、概念</a></p>\n<p id=\"2%E3%80%81%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB\">2、流的分类</a></p>\n<p id=\"3%E3%80%81IO%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81IO%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8\">3、IO流的作用</a></p>\n<p id=\"4%E3%80%81IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">4、IO流的使用场景</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81\">二、字节流</a></p>\n<p id=\"1%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB\">1、字节流抽象基类</a></p>\n<p id=\"2%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE\">2、字节流写数据</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4\">（1）基本步骤</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\">（2）三种方式</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98\">（3）两个问题</a></p>\n<p id=\"%C2%A0%EF%BC%884%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%884%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\">（4）异常处理</a></p>\n<p id=\"3%E3%80%81%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81\">3、字节缓冲流</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%26%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%26%E6%A6%82%E8%BF%B0\">（1）基本分类&amp;概述</a></p>\n<p id=\"%C2%A0%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">（2）构造方法</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%C2%A0\">（3）代码演示 </a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81\">三、字符流</a></p>\n<p id=\"1%E3%80%81%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E6%A6%82%E5%BF%B5\">1、概念</a></p>\n<p id=\"%C2%A02%E3%80%81%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02%E3%80%81%E5%88%86%E7%B1%BB\">2、分类</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BD%93%E7%B3%BB%E5%9B%BE-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BD%93%E7%B3%BB%E5%9B%BE\">（1）字符流体系图</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88Reader%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88Reader%EF%BC%89\">（2）字符输入流（Reader）</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88Writer%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88Writer%EF%BC%89\">（3）字符输出流（Writer）</a></p>\n<p id=\"%C2%A03%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81\"> 3、字符缓冲流</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5\">（1）概念</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0\">（2）构造方法 </a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\">（3）代码演示</a></p>\n<p id=\"%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD\">（4）字符缓冲流特有功能</a></p>\n<p id=\"%E5%9B%9B%E3%80%81IO%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81IO%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81\">四、IO特殊操作流</a></p>\n<p id=\"%C2%A01%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81\">1、标准输入输出流</a></p>\n<p id=\"2%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81\">2、打印流</a></p>\n<p id=\"3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81\">3、对象序列化流</a></p>\n<p id=\"4%E3%80%81%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81\">4、对象反序列化流</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86\">五、补充知识</a></p>\n<p id=\"1%E3%80%81%E9%9B%86%E5%90%88%EF%BC%88Properties%E9%9B%86%E5%90%88%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E9%9B%86%E5%90%88%EF%BC%88Properties%E9%9B%86%E5%90%88%EF%BC%89\">1、集合（Properties集合）</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%EF%BC%9A\">（1）概念：</a></p>\n<p id=\"%EF%BC%882%EF%BC%89Properties%E4%BD%9C%E4%B8%BAMap%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89Properties%E4%BD%9C%E4%B8%BAMap%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95\">（2）Properties作为Map集合的特有方法</a></p>\n<p id=\"%C2%A0%EF%BC%883%EF%BC%89Properties%E5%92%8CIO%E6%B5%81%E7%9B%B8%E7%BB%93%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%883%EF%BC%89Properties%E5%92%8CIO%E6%B5%81%E7%9B%B8%E7%BB%93%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95\">（3）Properties和IO流相结合的方法</a></p>\n<p id=\"%C2%A0%EF%BC%884%EF%BC%89%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%884%EF%BC%89%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\">（4）、示例代码</a></p>\n<p id=\"2%E3%80%81%E7%BC%96%E7%A0%81%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E7%BC%96%E7%A0%81%E8%A1%A8\">2、编码表</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86\">（1）什么是字符集</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86\">（2）常见的字符集</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99\">（3）编码规则</a></p>\n<p id=\"3%E3%80%81serialVersionUID%26transient-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81serialVersionUID%26transient\">3、serialVersionUID&amp;transient</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1ING-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1ING\">六、完结撒花ING</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E5%BA%8F\"><strong>序</strong></h1>\n<p style=\"text-align:center;\">做自己吧，别人都已经有人做了。</p>\n<p style=\"text-align:center;\">——王尔德</p>\n<p></p>\n<blockquote>\n<h1 id=\"%E4%B8%80%E3%80%81IO%E6%B5%81%E5%BC%80%E7%AF%87\"><strong><span style=\"color:#fe2c24;\">一、IO流开篇</span></strong></h1>\n</blockquote>\n<hr/>\n<h2 id=\"1%E3%80%81%E6%A6%82%E5%BF%B5\">1、概念</h2>\n<blockquote>\n<p>流：是一抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流。更具体一点，是内存与存储设备之间传输数据的通道。</p>\n</blockquote>\n<blockquote>\n<p>IO流：对于数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。</p>\n<p>Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\53299498dcb846719d1842467a165fa1.jpg\"/></p>\n<p></p>\n<h2 id=\"2%E3%80%81%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB\">2、流的分类</h2>\n<blockquote>\n<p>按方向分</p>\n<ul><li>输入流: 将 &lt; 存储设备 &gt; 中的内容读入到 &lt; 内存 &gt; 中.</li><li>输出流: 将 &lt; 内存 &gt; 中的内容写入到 &lt; 存储设备 &gt; 中.</li></ul>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"..\\..\\static\\image\\81c50a44a0d349d59e15eea707e08279.png\"/></p>\n<p></p>\n<blockquote>\n<p>按代为分</p>\n<ul><li>字节流: 以字节为单位, 可以读写所有数据.</li><li>字符流: 以字符为单位, 只能读写文本数据.</li></ul>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"..\\..\\static\\image\\a22149c96bff496f805c613dc9bd4835.png\"/></p>\n<p></p>\n<blockquote>\n<p>按功能分</p>\n<ul><li>节点流: 具有实际传输数据的读写功能.</li><li>过滤流: 在街电流的基础之上增强功能.</li></ul>\n</blockquote>\n<p> （详细解释：</p>\n<p>节点流：从特定的地方读写的流类，例如：磁盘或一块内存区域。<br/> 过滤流：使用节点流作为输入或输出。过滤流是使用一个已经存在的输入流或输出流连接创建的。<br/><br/> FileInputStream和FileOutputStream，节点流，用于从文件中读取或往文件中写入字节流。如果在构造FileOutputStream时，文件已经存在，则覆盖这个文件。<br/> BufferedInputStream和BufferedOutputStream，过滤流，需要使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率。<br/> DataInputStream和DataOutputStream，过滤流，需要使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。）</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\29b47d76300b454899e94038270501fd.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\f03fc17660564424a35b495766982fbf.png\"/></p>\n<h2 id=\"3%E3%80%81IO%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8\">3、IO流的作用</h2>\n<blockquote>\n<p>用来处理设备间数据传输问题</p>\n<p>常见的应用：文件复制、文件上传、文件下载</p>\n</blockquote>\n<h2 id=\"4%E3%80%81IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">4、IO流的使用场景</h2>\n<blockquote>\n<p>     如果操作的是纯文本文件，优先使用字符流</p>\n<p>     如果操作的是二进制文件，优先使用字节流</p>\n<p>  <span style=\"color:#fe2c24;\">   <strong>如果不确定，则优先使用字节流</strong></span></p>\n</blockquote>\n<p></p>\n<blockquote>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81\"><span style=\"color:#fe2c24;\"><strong>二、字节流</strong></span></h1>\n</blockquote>\n<hr/>\n<h2 id=\"1%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB\">1、字节流抽象基类</h2>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\c92be2e423a542928409039c32dab28a.png\"/></p>\n<blockquote>\n<p>InputStream:字节输入流的所有类的超类</p>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"..\\..\\static\\image\\1c012e0754bd430fa02ac1d5c8a128cc.png\"/></p>\n<p></p>\n<blockquote>\n<p>OutputStream:字节输出流的所有类的超类</p>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"..\\..\\static\\image\\a83b0682975248bba3adad88b2e430b2.png\"/></p>\n<p></p>\n<p>子类名特点：子类名称都是以其父类名作为子类名的后缀</p>\n<p></p>\n<h2 id=\"2%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE\">2、字节流写数据</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4\">（1）基本步骤</h3>\n<blockquote>\n<p>      创建FileOutputStream对象，关联到一个文件路径</p>\n<p>      调用write()方法，写出数据</p>\n<p>      调用close()方法，释放资源</p>\n<p>      打开文件，查看内容</p>\n</blockquote>\n<h3 id=\"%EF%BC%882%EF%BC%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\">（2）三种方式</h3>\n<blockquote>\n<p>      write(int b)                一次写一个字节数据</p>\n<p>      write(byte[] arr)                 一次写一个字节数组</p>\n<p>      write(byte[] arr,int index,int len)     写字节数组的一部分</p>\n</blockquote>\n<h3 id=\"%EF%BC%883%EF%BC%89%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98\">（3）两个问题</h3>\n<p>如何写换行</p>\n<blockquote>\n<p>调用write()方法，写出”\\r\\n”.getBytes()即可</p>\n</blockquote>\n<p>如何文件续写</p>\n<blockquote>\n<p>     使用FileOutputStream(String name,boolean append)构造方法</p>\n<p>     构造方法中第二个参数传递true，则在文件末尾继续写数据 </p>\n</blockquote>\n<h3 id=\"%C2%A0%EF%BC%884%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"> （4）异常处理</h3>\n<p>字节流写数据同时处理异常的重要步骤</p>\n<blockquote>\n<p>     将创建字节流对象和写出数据的代码放在try中</p>\n<p>     在catch中捕获IOException异常</p>\n<p>     在finally中进行释放资源</p>\n</blockquote>\n<p></p>\n<h2 id=\"3%E3%80%81%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81\"><span style=\"color:#b95514;\"><strong>3、字节缓冲流</strong></span></h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%26%E6%A6%82%E8%BF%B0\">（1）基本分类&amp;概述</h3>\n<blockquote>\n<p><span style=\"color:#b95514;\"><strong>BufferedOutputStream</strong></span></p>\n</blockquote>\n<p><span style=\"color:#0d0016;\">类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</span></p>\n<blockquote>\n<p><span style=\"color:#b95514;\"><strong>BufferedInputStream</strong></span></p>\n</blockquote>\n<p> 创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节</p>\n<p></p>\n<h3 id=\"%C2%A0%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"> （2）构造方法</h3>\n<blockquote>\n<p>| BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |</p>\n<p>| BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |</p>\n</blockquote>\n<p></p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%C2%A0\">（3）代码演示 </h3>\n<pre><code class=\"language-java\">public class BufferStreamDemo {\n    public static void main(String[] args) throws IOException {\n        //字节缓冲输出流：BufferedOutputStream(OutputStream out)\n \n        BufferedOutputStream bos = new BufferedOutputStream(new \t\t\t\t                                       FileOutputStream(\"myByteStream\\\\bos.txt\"));\n        //写数据\n        bos.write(\"hello\\r\\n\".getBytes());\n        bos.write(\"world\\r\\n\".getBytes());\n        //释放资源\n        bos.close();\n    \n\n        //字节缓冲输入流：BufferedInputStream(InputStream in)\n        BufferedInputStream bis = new BufferedInputStream(new                                                          FileInputStream(\"myByteStream\\\\bos.txt\"));\n\n        //一次读取一个字节数据\n//        int by;\n//        while ((by=bis.read())!=-1) {\n//            System.out.print((char)by);\n//        }\n\n        //一次读取一个字节数组数据\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=bis.read(bys))!=-1) {\n            System.out.print(new String(bys,0,len));\n        }\n\n        //释放资源\n        bis.close();\n    }\n}</code></pre>\n<p></p>\n<blockquote>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81\"><span style=\"color:#fe2c24;\"><strong>三、字符流</strong></span></h1>\n</blockquote>\n<hr/>\n<h2>1、概念</h2>\n<blockquote>\n<p>由于字节流操作中文不是特别的方便，所以Java就提供字符流</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">字符流 = 字节流 + 编码表</span></p>\n</blockquote>\n<blockquote>\n<p>（补充）：中文的字节存储方式</p>\n<p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？</p>\n<p>汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 </p>\n</blockquote>\n<p></p>\n<h2 id=\"%C2%A02%E3%80%81%E5%88%86%E7%B1%BB\"> 2、分类</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BD%93%E7%B3%BB%E5%9B%BE\">（1）字符流体系图</h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\f01b783c32164c1d9f29aad9d50ea2f3.png\"/></p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88Reader%EF%BC%89\">（2）字符输入流（Reader）</h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\e450dc64af8d42cb80a3746f24f3b06f.png\"/></p>\n<p></p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88Writer%EF%BC%89\">（3）字符输出流（Writer）</h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\ce127e5f381947c68e83b7475eb6a8a3.jpg\"/></p>\n<p></p>\n<h2 id=\"%C2%A03%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81\"> 3、字符缓冲流</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5\">（1）概念</h3>\n<blockquote>\n<p><span style=\"color:#b95514;\"><strong>BufferedWriter</strong></span></p>\n</blockquote>\n<p> 将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途。</p>\n<blockquote>\n<p><span style=\"color:#b95514;\"><strong>BufferedReader</strong></span></p>\n</blockquote>\n<p>从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途。 </p>\n<p></p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%C2%A0\">（2）构造方法 </h3>\n<blockquote>\n<p>| BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |</p>\n<p>| BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |</p>\n</blockquote>\n<h3></h3>\n<h3 id=\"%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\">（3）代码演示</h3>\n<pre><code class=\"language-java\">public class BufferedStreamDemo01 {\n    public static void main(String[] args) throws IOException {\n        //BufferedWriter(Writer out)\n        BufferedWriter bw = new BufferedWriter(new                                                            FileWriter(\"myCharStream\\\\bw.txt\"));\n        bw.write(\"hello\\r\\n\");\n        bw.write(\"world\\r\\n\");\n        bw.close();\n\n        //BufferedReader(Reader in)\n        BufferedReader br = new BufferedReader(new                                                           FileReader(\"myCharStream\\\\bw.txt\"));\n\n        //一次读取一个字符数据\n//        int ch;\n//        while ((ch=br.read())!=-1) {\n//            System.out.print((char)ch);\n//        }\n\n        //一次读取一个字符数组数据\n        char[] chs = new char[1024];\n        int len;\n        while ((len=br.read(chs))!=-1) {\n            System.out.print(new String(chs,0,len));\n        }\n\n        br.close();\n    }\n}</code></pre>\n<p></p>\n<h3 id=\"%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD\">（4）字符缓冲流特有功能</h3>\n<blockquote>\n<p>void newLine()写一行行分隔符，行分隔符字符串由系统属性定义</p>\n</blockquote>\n<blockquote>\n<p>String readLine()读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null</p>\n</blockquote>\n<p></p>\n<blockquote>\n<h1 id=\"%E5%9B%9B%E3%80%81IO%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81\"><span style=\"color:#fe2c24;\"><strong>四、IO特殊操作流</strong></span></h1>\n</blockquote>\n<hr/>\n<h2 id=\"%C2%A01%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81\"> 1、标准输入输出流</h2>\n<blockquote>\n<p>public static final InputStream in：标准输入流。</p>\n</blockquote>\n<p>通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源。</p>\n<p><strong>使用步骤：</strong></p>\n<p>1.我们可以自己实现键盘录入输入。<br/>         BufferedReader(InputStreamReader(System.in));<br/>         调用readtLine()方法接收数据。</p>\n<p>2.但是上面的方式太麻烦了，所以我们直接使用键盘输入的类<br/>         Scanner sc = new Scanner(System.in);</p>\n<blockquote>\n<p>public static final PrintStream out：标准输出流。</p>\n</blockquote>\n<p> 通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标。</p>\n<p><strong>使用步骤：</strong><br/>           输出语句本质就是一个标准输出流<br/>           创建标准输出流对象：PrintStream ps = System.out;<br/>           调用print()方法可以输出不带换行效果的数据<br/>           调用println()方法可以输出带换行效果的数据</p>\n<p></p>\n<h2 id=\"2%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81\">2、打印流</h2>\n<blockquote>\n<p>字节打印流：PrintStream</p>\n</blockquote>\n<p><strong>- PrintStream(String fileName)</strong>：使用指定的文件名创建新的打印流。</p>\n<p>- 使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出。</p>\n<p>- 可以改变输出语句的目的地。</p>\n<blockquote>\n<p>字符打印流：PrintWriter</p>\n</blockquote>\n<p><strong>PrintWriter(String   fileName)</strong>：使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新。</p>\n<p>PrintWriter(Writer   out, boolean autoFlush)：</p>\n<p>创建一个新的PrintWriter    out：字符输出流。   </p>\n<p>autoFlush： 一个布尔值，如果为真，则println ， printf ，或format方法将刷新输出缓冲区。 </p>\n<p></p>\n<h2 id=\"3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81\">3、对象序列化流</h2>\n<p><strong>对象序列化流（ ObjectOutputStream）：</strong></p>\n<p>将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 。</p>\n<p><strong>构造方法：</strong></p>\n<p>ObjectOutputStream(OutputStream out)<br/> 创建一个写入指定的OutputStream的ObjectOutputStream。</p>\n<p><strong>序列化对象的方法：</strong></p>\n<p>void writeObject(Object obj)<br/> 将指定的对象写入ObjectOutputStream。</p>\n<p></p>\n<h2 id=\"4%E3%80%81%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81\">4、对象反序列化流</h2>\n<p><strong>对象反序列化流（ObjectInputStream）：</strong></p>\n<p>反序列化先前使用ObjectOutputStream编写的原始数据和对象。</p>\n<p><strong>构造方法：</strong></p>\n<p>ObjectInputStream(InputStream in)</p>\n<p>创建从指定的InputStream读取的ObjectInputStream</p>\n<p><strong>反序列化对象的方法：</strong></p>\n<p>Object readObject()</p>\n<p>从ObjectInputStream读取一个对象</p>\n<p></p>\n<blockquote>\n<h1 id=\"%E4%BA%94%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86\">五、补充知识</h1>\n</blockquote>\n<hr/>\n<h2 id=\"1%E3%80%81%E9%9B%86%E5%90%88%EF%BC%88Properties%E9%9B%86%E5%90%88%EF%BC%89\">1、集合（Properties集合）</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%EF%BC%9A\">（1）概念：</h3>\n<blockquote>\n<p>- 是一个Map体系的集合类<br/> - Properties可以保存到流中或从流中加载<br/> - 属性列表中的每个键及其对应的值都是一个字符串</p>\n</blockquote>\n<h3 id=\"%EF%BC%882%EF%BC%89Properties%E4%BD%9C%E4%B8%BAMap%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95\">（2）Properties作为Map集合的特有方法</h3>\n<blockquote>\n<p>1、Object   setProperty(String key, String value)<br/> 设置集合的键和值，都是String类型，底层调用   Hashtable方法 put<br/> 2、String   getProperty(String key)<br/> 使用此属性列表中指定的键搜索属性<br/> 3、Set&lt;String&gt;   stringPropertyNames()<br/> 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</p>\n</blockquote>\n<h3 id=\"%C2%A0%EF%BC%883%EF%BC%89Properties%E5%92%8CIO%E6%B5%81%E7%9B%B8%E7%BB%93%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95\"> （3）Properties和IO流相结合的方法</h3>\n<blockquote>\n<p>1、void   load(InputStream inStream)<br/>     从输入字节流读取属性列表（键和元素对）<br/> 2、void   load(Reader reader)<br/>     从输入字符流读取属性列表（键和元素对）<br/> 3、void   store(OutputStream out, String comments)<br/>     将此属性列表（键和元素对）写入此   Properties表中，以适合于使用   load(InputStream)方法的格式写入输出字节流<br/> 4、void   store(Writer writer, String comments)<br/>     将此属性列表（键和元素对）写入此   Properties表中，以适合使用   load(Reader)方法的格式写入输出字符流</p>\n</blockquote>\n<h3 id=\"%C2%A0%EF%BC%884%EF%BC%89%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"> （4）、示例代码</h3>\n<pre><code class=\"language-java\">public class PropertiesDemo03 {\n    public static void main(String[] args) throws IOException {\n        //把集合中的数据保存到文件\n//        myStore();\n\n        //把文件中的数据加载到集合\n        myLoad();\n\n    }\n\n    private static void myLoad() throws IOException {\n        Properties prop = new Properties();\n\n        //void load(Reader reader)：\n        FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\");\n        prop.load(fr);\n        fr.close();\n\n        System.out.println(prop);\n    }\n\n    private static void myStore() throws IOException {\n        Properties prop = new Properties();\n\n        prop.setProperty(\"itheima001\",\"林青霞\");\n        prop.setProperty(\"itheima002\",\"张曼玉\");\n        prop.setProperty(\"itheima003\",\"王祖贤\");\n\n        //void store(Writer writer, String comments)：\n        FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\");\n        prop.store(fw,null);\n        fw.close();\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"2%E3%80%81%E7%BC%96%E7%A0%81%E8%A1%A8\">2、编码表</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86\">（1）什么是字符集</h3>\n<p>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>\n<p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86\">（2）常见的字符集</h3>\n<p>ASCII字符集</p>\n<p>ASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 。</p>\n<p>基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p>\n<p>GBXXX字符集</p>\n<p>GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</p>\n<p>Unicode字符集</p>\n<p>UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码。</p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99\">（3）编码规则</h3>\n<blockquote>\n<p> 128个US-ASCII字符，只需一个字节编码<br/>   拉丁文等字符，需要二个字节编码<br/>   大部分常用字（含中文），使用三个字节编码<br/>   其他极少使用的Unicode辅助字符，使用四字节编码</p>\n</blockquote>\n<h2></h2>\n<h2 id=\"3%E3%80%81serialVersionUID%26transient\">3、serialVersionUID&amp;transient</h2>\n<blockquote>\n<p><strong><span style=\"color:#fe2c24;\">serialVersionUID</span></strong></p>\n</blockquote>\n<p><strong>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？</strong></p>\n<p>会出问题，会抛出InvalidClassException异常。</p>\n<p><strong>如果出问题了，如何解决呢？</strong></p>\n<p>- 重新序列化</p>\n<p>- 给对象所属的类加一个serialVersionUID <br/>     private static final long serialVersionUID = 42L;</p>\n<p></p>\n<blockquote>\n<p><strong><span style=\"color:#fe2c24;\">transient</span></strong></p>\n</blockquote>\n<p><strong>如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？</strong></p>\n<p>给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程</p>\n<p></p>\n<p><strong>示例代码：</strong></p>\n<p><strong>学生类：</strong></p>\n<pre><code class=\"language-java\">public class Student implements Serializable {\n    private static final long serialVersionUID = 42L;\n    private String name;\n//    private int age;\n    private transient int age;\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n//    @Override\n//    public String toString() {\n//        return \"Student{\" +\n//                \"name='\" + name + '\\'' +\n//                \", age=\" + age +\n//                '}';\n//    }\n}</code></pre>\n<p><strong>测试类：</strong></p>\n<pre><code class=\"language-java\">public class ObjectStreamDemo {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n//        write();\n        read();\n    }\n\n    //反序列化\n    private static void read() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\"));\n        Object obj = ois.readObject();\n        Student s = (Student) obj;\n        System.out.println(s.getName() + \",\" + s.getAge());\n        ois.close();\n    }\n\n    //序列化\n    private static void write() throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\"));\n        Student s = new Student(\"林青霞\", 30);\n        oos.writeObject(s);\n        oos.close();\n    }\n}</code></pre>\n<p></p>\n<blockquote>\n<h1 id=\"%E5%85%AD%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1ING\"><span style=\"color:#fe2c24;\"><strong>六、完结撒花ING</strong></span></h1>\n</blockquote>\n<hr/>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/1c59b56feafc4248a9e6d0b16883658d.gif\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-05-31 16:57:49", "summary": "目录序一、流开篇、概念、流的分类、流的作用、流的使用场景二、字节流、字节流抽象基类、字节流写数据基本步骤三种方式两个问题异常处理、字节缓冲流基本分类概述构造方法代码演示三、字符流、概念、分类字符流体系"}