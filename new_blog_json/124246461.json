{"blogid": "124246461", "writerAge": "码龄1年", "writerBlogNum": "126", "writerCollect": "5826", "writerComment": "7325", "writerFan": "16749", "writerGrade": "7级", "writerIntegral": "15009", "writerName": "鹿九丸", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124246461.jpg", "writerRankTotal": "662", "writerRankWeekly": "1186", "writerThumb": "5702", "writerVisitNum": "235477", "blog_read_count": "1228", "blog_time": "已于 2022-04-18 15:39:29 修改", "blog_title": "《数据结构修炼手册》----二叉树的顺序结构及实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>二叉树的顺序结构及实现</h3>\n<ul><li><a href=\"#1__1\">1. 二叉树的顺序结构</a></li><li><a href=\"#2__7\">2. 堆的概念及结构</a></li><li><a href=\"#3_30\">3.线性堆的模拟实现</a></li><li><ul><li><a href=\"#31__31\">3.1 堆的基本结构定义</a></li><li><a href=\"#32__43\">3.2 堆的初始化</a></li><li><a href=\"#33__54\">3.3 堆的销毁</a></li><li><a href=\"#34__65\">3.4 堆数据的插入</a></li><li><a href=\"#35__120\">3.5 堆的删除</a></li><li><a href=\"#36__178\">3.6 线性堆判断是否为空</a></li><li><a href=\"#37__188\">3.7 求线性堆元素的数目</a></li><li><a href=\"#38__198\">3.8 返回线性堆头的元素</a></li><li><a href=\"#39__209\">3.9 打印线性堆的元素</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"1__1\"></a>1. 二叉树的顺序结构</h1>\n<p>普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。<strong>现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。</strong></p>\n<p><img alt=\"image-20220403105214178\" src=\"..\\..\\static\\image\\235ff939a773a300526e5522c7b75228.png\"/></p>\n<h1><a id=\"2__7\"></a>2. 堆的概念及结构</h1>\n<blockquote>\n<p>如果有一个关键码的集合K = { k<sub>0</sub>，k<sub>1</sub> ,k<sub>2</sub>…，k<sub>n-1</sub> }，把它的所有元素按完全二叉树的顺序存储方式存储<br/> 在一个一维数组中，并满足：K<sub>i</sub>&lt;= K<sub>2*i+1</sub>且 K<sub>i</sub>&lt;=K<sub>2*i+2</sub> ( K<sub>i</sub>&gt;=<br/> K<sub>2*i+1</sub>且K<sub>i</sub>&lt;=K<sub>2*i+2</sub>) i = 0，1，<br/> 2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>\n</blockquote>\n<p>简单描述：</p>\n<p><strong>大堆(大根堆)：树中父亲都大于（等于）孩子。</strong></p>\n<p><strong>小堆（小根堆）：树中父亲都小于（等于）孩子。</strong></p>\n<p>堆的性质：</p>\n<ul><li> <p><strong>堆中某个节点的值总是不大于或不小于其父节点的值；</strong></p> </li><li> <p><strong>堆总是一棵完全二叉树。</strong></p> <p><img alt=\"image-20220403122953339\" src=\"..\\..\\static\\image\\5542ae8cec34e447ec0fb0922aa0c6c4.png\"/></p> </li></ul>\n<p>应用场景：堆排序、topk。</p>\n<h1><a id=\"3_30\"></a>3.线性堆的模拟实现</h1>\n<h2><a id=\"31__31\"></a>3.1 堆的基本结构定义</h2>\n<pre><code class=\"prism language-C\">typedef int HPDataType;//堆中存放的数据，假设是整型\ntypedef struct Heap\n{\n\tHPDataType* a;//指针指向堆中存储的数据\n\tsize_t size;//堆中当前元素的数目\n\tsize_t capacity;//堆中所能存储数据的容量\n}HP;\n</code></pre>\n<h2><a id=\"32__43\"></a>3.2 堆的初始化</h2>\n<pre><code class=\"prism language-C\">void HeapInit(HP* php)\n{\n\tassert(php);\n\tphp-&gt;capacity = php-&gt;size = 0;\n\tphp-&gt;a = NULL;\n}\n</code></pre>\n<h2><a id=\"33__54\"></a>3.3 堆的销毁</h2>\n<pre><code class=\"prism language-C\">void HeapDestory(HP* php)\n{\n\tassert(php);\n\tfree(php-&gt;a);\n\tphp-&gt;a = NULL;\n}\n</code></pre>\n<h2><a id=\"34__65\"></a>3.4 堆数据的插入</h2>\n<p>思路：</p>\n<p><mark>时间复杂度：log(N)</mark></p>\n<p><img alt=\"image-20220403155004910\" src=\"..\\..\\static\\image\\5d56b36f656f5fc2717ec5b8754f68d7.png\"/></p>\n<pre><code class=\"prism language-C\">void Swap(HPDataType* pa, HPDataType* pb)//交换函数：交换数组中的两个元素\n{\n\tHPDataType tmp = *pa;\n\t*pa = *pb;\n\t*pb = tmp;\n}\nvoid AdjustUp(HPDataType* a, size_t child )//堆的向上调整\n{\n\tsize_t parant = (child - 1) / 2;\n\twhile (child &gt; 0)\n\t{\n\t\tif (a[child] &lt; a[parant])//此处如果是&lt;就是小堆，如果是&gt;就是大堆\n\t\t{\n\t\t\tSwap(&amp;a[child], &amp;a[parant]);\n\t\t\tchild = parant;\n\t\t\tparant = (child - 1) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nvoid HeapPush(HP* php, HPDataType x)\n{\n\tassert(php);\n    //判断是否需要扩充并进行扩充\n\tif (php-&gt;size == php-&gt;capacity)\n\t{\n\t\tsize_t newCapacity = php-&gt;capacity == 0 ? 2 : 2 * php-&gt;capacity;\n\t\tHPDataType*tmp = (HPDataType*)realloc(php-&gt;a, sizeof(HPDataType)*newCapacity);\n\t\tif (tmp == NULL)\n\t\t{\n\t\t\tprintf(\"realloc failed\\n\");\n\t\t\texit(-1);\n\t\t}\n\t\tphp-&gt;a = tmp;\n\t\tphp-&gt;capacity = newCapacity;\n\t}\n\tphp-&gt;a[php-&gt;size] = x;\n\tphp-&gt;size++;\n\t//向上调整，控制保持是堆\n\tAdjustUp(php-&gt;a, php-&gt;size - 1);\n}\n</code></pre>\n<h2><a id=\"35__120\"></a>3.5 堆的删除</h2>\n<p>思路：</p>\n<ol><li> <p><strong>第一个数与最后一个位置的数进行交换</strong></p> </li><li> <p><strong>删除最后一个数据</strong></p> </li><li> <p><strong>向下调整</strong></p> <p>下面是向下调整的图示：</p> <p><mark>时间复杂度：O(log<sub>2</sub>N)</mark></p> <p><img alt=\"image-20220408163509379\" src=\"..\\..\\static\\image\\2ce298ff975de8e9a85a081ac0f5e4d0.png\"/></p> </li></ol>\n<pre><code class=\"prism language-C\">void Swap(HPDataType* pa, HPDataType* pb)//交换函数：交换数组中的两个元素\n{\n\tHPDataType tmp = *pa;\n\t*pa = *pb;\n\t*pb = tmp;\n}\n\nvoid AdjustDown(HPDataType* a, size_t size,size_t root)\n{\n\tsize_t parant = root;\n\tsize_t child = 2*parant+1;\n\t\n\twhile (child&lt;size)\n\t{\n\t\tif (child+1&lt;size &amp;&amp;a[child + 1] &lt; a[child])//此时后面的这个如果是&lt;就是小堆，如果是&gt;就是大堆\n\t\t\t++child;\n\t\tif (a[child] &lt; a[parant])//如果是&lt;就是小堆，如果是&gt;就是大堆\n\t\t{\n\t\t\tSwap(&amp;a[child], &amp;a[parant]);\n\t\t\tparant = child;\n\t\t\tchild = 2 * parant + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nvoid HeapPop(HP* php)\n{\n\tassert(php);\n\tSwap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);\n\tphp-&gt;size--;\n\tAdjustDown(php-&gt;a, php-&gt;size, 0);\n}\n</code></pre>\n<blockquote>\n<p><strong>问：堆的删除为什么不直接从后向前进行覆盖，把第一个元素覆盖掉？</strong></p>\n<p><strong>答：首先时间复杂度是O(N)，其次堆原来的结构可能会被打乱，同时也可能丧失堆原来的性质变得不再是堆，除非堆原来的数组元素是从小到大或者从大到小是有序的情况下才一定能够保持堆的性质，但即使这种情况下堆的结构仍然会被打乱，即它们的父子关系被破坏掉。</strong></p>\n</blockquote>\n<h2><a id=\"36__178\"></a>3.6 线性堆判断是否为空</h2>\n<pre><code class=\"prism language-C\">bool HeapEmpty(HP* php)\n{\n\tassert(php);\n\treturn php-&gt;size == 0;\n}\n</code></pre>\n<h2><a id=\"37__188\"></a>3.7 求线性堆元素的数目</h2>\n<pre><code class=\"prism language-C\">size_t HeapSize(HP* php)\n{\n\tassert(php);\n\treturn php-&gt;size;\n}\n</code></pre>\n<h2><a id=\"38__198\"></a>3.8 返回线性堆头的元素</h2>\n<pre><code class=\"prism language-C\">HPDataType HeapTop(HP* php)\n{\n\tassert(php);\n\tassert(php-&gt;size &gt; 0);\n\treturn php-&gt;a[0];\n}\n</code></pre>\n<h2><a id=\"39__209\"></a>3.9 打印线性堆的元素</h2>\n<pre><code class=\"prism language-C\">void HeapPrint(HP* php)\n{\n\tassert(php);\n\tfor (size_t i = 0; i &lt; php-&gt;size; i++)\n\t{\n\t\tprintf(\"%d \", php-&gt;a[i]);\n\t}\n\tprintf(\"\\n\");\n}\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2022-04-18 15:39:29", "summary": "二叉树的顺序结构及实现二叉树的顺序结构堆的概念及结构线性堆的模拟实现堆的基本结构定义堆的初始化堆的销毁堆数据的插入堆的删除线性堆判断是否为空求线性堆元素的数目返回线性堆头的元素打印线性堆的元素二叉树的"}