{"blogid": "126542758", "writerAge": "码龄1年", "writerBlogNum": "27", "writerCollect": "48", "writerComment": "122", "writerFan": "1416", "writerGrade": "3级", "writerIntegral": "667", "writerName": "亲爱的小杰", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126542758.jpg", "writerRankTotal": "25057", "writerRankWeekly": "12227", "writerThumb": "187", "writerVisitNum": "7828", "blog_read_count": "440", "blog_time": "于 2022-09-01 18:25:28 发布", "blog_title": "Java之多线程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>@[TOC]多线程</p>\n<h2><a id=\"_1\"></a>什么是线程</h2>\n<p>线程就是一个“执行流”，每一个线程都能按照自己的代码执行顺序执行代码，能够实现多个线程<strong>同时</strong>执行多分代码，实现并发编程。</p>\n<h2><a id=\"_3\"></a>为什么使用线程</h2>\n<p>（1）并发编程的需要。单核CUP的发展已经到了瓶颈，我们想要提高CPU的算力已经非常困难，所以我们就需要多核CPU。而并发编程能更好的利用多核CPU<br/> （2）有一些任务场景要等待IO，为了让等待IO的时间能够做其他工作，就需要并发编程<br/> （3）虽然说，进程也能实现并发编程，创建和删除进程的过程比较消耗资源，反而线程比较轻量，更好实现并发编程。</p>\n<h2><a id=\"_7\"></a>线程的应用场景</h2>\n<p>（1）CPU密集的场景下，能够更充分利用多核资源<br/> （2）IO密集的场景下，可以充分利用IO的等待时间，干点别的事情</p>\n<h2><a id=\"_10\"></a>进程和线程的区别</h2>\n<p>（1）进程包含线程，即线程是进程的一部分<br/> （2）一个进程崩溃了，一般不会影响其他进程。而同一个进程中的一个线程崩溃了，一般会影响到其他线程，进而是该进程崩溃了。<br/> （3）一个进程有自己的虚拟地址空间和文件描述符表，而同一个进程的多个线程则是共用相同的虚拟地址空间和文件描述符表。<br/> （4）进程是操作系统资源分配的基本单位，而线程是操作系统调度的基本单位。</p>\n<h2><a id=\"Java_15\"></a>如何使用Java代码创建线程</h2>\n<p>【方法一】创建一个类，继承Thread类，实现run()方法<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9cf1403577534baa85c74f3a3a6ab5b1.png\"/><br/> 【方法二】创建一个类，实现Runnable接口，重写run()方法，来创建线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f0e6615585304b5684eb01d9bf955f60.png\"/></p>\n<p>【方法三】使用匿名内部类，创建Thread对象，重写run()方法，来创建线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6ddc4c487b4e46009ac2ceb94dd581e7.png\"/></p>\n<p>【方法四】使用匿名内部类，创建Runnable对象，重写run()方法，来创建线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\901bc72c628545bc87e4d394e4d1e129.png\"/></p>\n<p>【方法五】使用lambda表达式，来创建线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c7ceb567f8d0458fa2288724159dd2a6.png\"/></p>\n<p>【方法六】创建Callable对象，实现call方法，在通过FutureTask对象辅助，来创建线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\780b866dcda343688d6d4d51394f26ef.png\"/><br/> 【方法七】通过创建线程池，来实现多线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fb2c47bf179b4cdb9edeee8553a95bf5.png\"/></p>\n<h2><a id=\"Thread__34\"></a>Thread 类及常见方法</h2>\n<p><em><strong>Thread常见的构造方法</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\de031d9326db4755b6c2ce3515d79d61.png\"/></p>\n<p><em><strong>Thread常见的方法</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8821e0a3f50243a680ae29e6f597cb4f.png\"/><br/> <em><strong>ID 是线程的唯一标识，不同线程不会重复<br/> 名称是各种调试工具用到<br/> 状态表示线程当前所处的一个情况，下面我们会进一步说明<br/> 优先级高的线程理论上来说更容易被调度到<br/> 关于后台线程，需要记住一点：JVM会在一个进程的所有非后台线程结束后，才会结束运行。<br/> 是否存活，即简单的理解，为 run 方法是否运行结束了<br/> 线程的中断问题，下面我们进一步说明</strong></em></p>\n<p>注意：线程可以分为前台线程和后台线程两种。前台线程：前台线程会阻止进程的结束，直到所有的线程都执行完后，进程才结束。例如：<strong>我们创建的线程和main线程都是前台线程</strong>。<br/> 后台线程：后台线程不会阻止进程结束，进程结束不管其他线程是否都完成自己的代码。<strong>我们可以通过Thread对象.setDaemon()来将线程设置为后台线程，注意：将线程设置为后台线程这一步要在启动线程之前，否则会报错。Thread对象.setDaemon(true) 表示设置为后台线程</strong></p>\n<h2><a id=\"_51\"></a>如何启动线程</h2>\n<p>很多人会认为创建好一个Thread对象后，一个线程就启动了。这是一个很大的误区。创建好一个Thread对象只是将一个线程给创建好，并不是将一个线程启动了。我们想要启动一个线程 还要调用***start()***方法将线程启动。</p>\n<h2><a id=\"_53\"></a>中断线程</h2>\n<p><em><strong>【方法一】自己设置一个标识位来中断线程</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bc5a8fd640474389871407d90513cbbf.png\"/></p>\n<p><em><strong>【方法二】使用Thread对象自己带的标识位 来中断线程</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\111e89281fb24add934559cf8ede64ac.png\"/><br/> Thread.currentThread.isInterrupted()方法是判断该线程是否中断，true表示中断，false表示没有中断<br/> Thread对象.interrupt（）方法是将该线程中断。<br/> Thread对象.interrupt（）的行为：<br/> <em><strong>（1）中断线程的时候，线程处在阻塞状态，那么将会抛出InterruptedException异常，所以，我们要进行异常处理。<br/> （2）中断线程的时候，线程不处在阻塞状态，那么就会将线程里面的标识位的值设置位true;</strong></em></p>\n<h2><a id=\"join_65\"></a>等待一个线程–join()</h2>\n<p>我们说线程的调度是随机的，我们无法规定哪个线程先执行，但是，我们有办法哪个线程先执行完，哪个线程后执行完。使用join()方法就行。<br/> <em><strong>join()方法的行为：在哪一个线程里调用 Thread对象,join(),则该线程就要等待调用join()方法的线程先执行完，该线程才能执行完。</strong></em><br/> 例题：<em><strong>有三个线程A,B,C，我想让线程A在线程B之前完成，线程B在线程A之前完成。</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\19a7dd168b8f419f88642dd8dc38eb23.png\"/></p>\n<h2><a id=\"_71\"></a>获取当前线程的引用</h2>\n<p>我们通过<strong>Thread.currentThread()来获取当前线程的引用</strong><br/> Thread.currentThread()与类的this的用法是一样的。<br/> 在不同的线程中使用Thread.currentThread()，<strong>Thread.currentThread()就表示该线程的引用</strong></p>\n<h2><a id=\"_75\"></a>休眠当前线程</h2>\n<p>我们想要休眠某个线程，就在该线程里调用Thread.sleep(休眠时间（单位ms）)<br/> Thread.sleep(休眠时间（单位ms）)行为：<em><strong>将线程从就绪状态转变为阻塞状态，到达我们设置的时间后，线程的状态从阻塞状态变为就绪状态</strong></em></p>\n<h2><a id=\"_78\"></a>线程的状态</h2>\n<p>线程的状态有六种：<br/> （1）NEW：还没有安排工作<br/> （2）RUNNABLE：可工作的，分为正在工作和即将工作<br/> (3)TERMINATED:工作完成了<br/> （4）TIMED_WAITING：阻塞状态，使用了sleep()方法<br/> (5)WAITING:阻塞状态，使用了wait()方法<br/> (6)BLOCKED:阻塞状态，使用了锁<br/> <em><strong>线程状态的关系转化图（简单版本）</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2e2c25664b2843369e237590ad2c15f8.png\"/></p>\n<h2><a id=\"_89\"></a>线程安全</h2>\n<p>线程安全的概念：如果在多线程的环境下运行程序，其结果与我们预期的结果一致，则我们说该程序是线程安全的。</p>\n<p><strong>程序产生线程不安全的原因</strong><br/> （1）操作系统对线程的随机调度（抢占式执行）（最根本的问题，我们无法避免）<br/> （2）多个线程修改同一个变量<br/> （3）有些修改操作不是原子的。<br/> （4）内存的可见性，引起的线程安全<br/> （5）指令的重排序问题，引起的线程安全</p>\n<h2><a id=\"_98\"></a>解决线程安全的方法</h2>\n<p><strong>【解决多个线程修改同一个变量 和 有些操作不是原子的 所引起的线程安全问题】</strong><br/> 多个线程修改同一个变量 和 有些操作不是原子的 所引起的线程安全问题，我们可以通过<strong>加锁</strong>的方式进行解决<br/> 加锁使用到的关键字：synchronized<br/> 锁（synchronized）的使用：<br/> <em><strong>加锁的关键是要选好加锁的对象，任何对象都可以成为锁对象</strong></em><br/> 锁（synchronized）可以修饰方法：<br/> 【修饰实例方法】锁对象是该类的实例</p>\n<p>public synchronized void sleep(){<!-- --><br/> 代码<br/> }</p>\n<p>【修饰静态方法】锁对象是该类的类对象<br/> public static synchronized void sleep(){<!-- --><br/> 代码<br/> }<br/> 锁（synchronized）可以修饰代码块<br/> synchronized(锁对象) {<!-- --></p>\n<p>代码</p>\n<p>}<br/> <strong>注意：每一个类的类对象只有一个。我们加锁的时候，比较关注锁对象，多线程要发生竞争，只有多个线程竞争同一把锁的时候才能发生竞争，也就是说多个线程竞争相同的锁对象的时候才发生竞争。多个线程针对不同的锁，则不会发生竞争</strong></p>\n<p><strong>【解决 内存可见性和指令重排序引起的线程不安全问题】</strong></p>\n<p>方法很简单，就是在变量前面加一个 <strong>volatile 关键字</strong> 即可</p>\n<h2><a id=\"waitnotify_127\"></a>wait()方法和notify()方法</h2>\n<p>操作系统对线程的调度的随机的，所以，就导致了我们无法预料哪个线程先执行，哪个线程后执行。但是，我们也有一些协调多线程顺序的办法。我们之前有说过 <em><strong>join()方法可以控制哪个线程先结束哪个线程后结束。sleep()方法可以让线程进入阻塞状态一定的时间，间接地是多线程执行顺序往自己预期的方向执行。<em><strong>当时join()和sleep（）方法有时候不会达到我们想要的效果，于是就有</strong></em>wait()和notify()方法或者wait()和notifyAll()方法</strong></em> 来控制多线程的顺序。</p>\n<p><em><strong>wait()方法和sleep()方的区别：</strong></em><br/> （1）wait()方法是Object类里面的方法，而sleep()方法是Thread类里面的静态方法<br/> （2）sleep方法的效果：sleep()方法使线程进入阻塞状态，到达我们设置的阻塞时间，线程就从阻塞状态转变为就绪状态<br/> 而wait()方法有两种效果：【第一种】wait（）方法没有参数的时候，让线程进入阻塞状态，想要唤醒该线程就必须适应notify()方法或者notifyAll（）方法。【第二种】wait(等待时间)方法有参数的时候，参数表示线程阻塞的时间，效果跟sleep()方法是一样的。如果想要提前唤醒该线程，就必须适应notify()方法或者notifyAll()方法。<br/> （3）wait()方法要在有锁的情况下使用，而sleep()方法在任何地方都能使用</p>\n<p><em><strong>注意：wait（）方法和notify()方法 或者wait()方法和notifyAll()方法是搭配使用的，并且他们都是Object类里面的方法，并且他们使用的时候，锁对象必须保持一致，简单的说就是锁要相同。</strong></em></p>\n<p><em><strong>wait()方法和notify()方法的使用</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4fd91ccf9f1341f2abbe603d4838a63b.png\"/><br/> <em><strong>运行结果截图</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bed1f1830b07456786ec74577d9a0aa4.png\"/></p>\n<h2><a id=\"_143\"></a>多线程案例</h2>\n<h2><a id=\"_144\"></a>单例模式</h2>\n<p><em><strong>单例模式能够保证某个类在程序中只有唯一一个实例，而不会出现创建多个实例的情况</strong></em><br/> 单例模式的实现方式有两种：<em><strong>饿汉模式和懒汉模式</strong></em><br/> 饿汉模式：程序在运行的时候，类加载的时候创建实例<br/> 懒汉模式：程序启动的时候，先不着急创建实例，等到使用的时候在创建实例<br/> <em><strong>单例模式Java代码实现（线程安全）</strong></em><br/> <em><strong>【饿汉模式】</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c355ada6dea348b293d9fd203eb62b8b.png\"/><br/> <em><strong>【懒汉模式】</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2067df18df55469cb65665a27a56ad71.png\"/></p>\n<h2><a id=\"_154\"></a>阻塞队列</h2>\n<p><strong>【阻塞队列是什么】</strong><br/> 阻塞队列是一个数据结构，满足“先进先出”的原则，与我们之前学的队列有所不同的是阻塞队列的满足线程安全的。<br/> <strong>【生产者消费者模型】</strong><br/> <em><strong>阻塞队列</strong></em>经典的应用场景是<em><strong>生产者消费者模型</strong></em><br/> <strong>生产者消费者模型</strong>：生产者和消费者之间的信息通信并不是直接通信，而是以阻塞队列为容器，通过阻塞队列来实现生产者和消费者之间的信息通。例如：生产者想要给消费者发生信息，则生产者就会将信息发给阻塞队列，而消费者则可以通过获取阻塞队列里的信息 进而获取生产者发送过来的信息。<br/> <em><strong>生产者消费者模型最明显的两条优点：</strong></em><br/> （1）阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力<br/> （2）阻塞队列也能使生产者和消费者之间解耦.<br/> <strong>【Java中实现的阻塞队列】</strong><br/> BlockingQueue 是一个接口.<br/> BlockingQueue的实现类有很多，这里介绍几个：<br/> （1）LinkedBlockingQueue类，普通的队列，满足“先进先出”，底层是有链表实现<br/> （2）ArrayBlockingQueue类，普通的队列，满足“先进先出”，底层是有数字实现<br/> （3）PriorityBlockingQueue类，优先级队列<br/> <strong>注意:<br/> 没有线程安全的队列里面的方法 在阻塞队列里面都有。在阻塞队列里面调用没有线程安全的队列里面的方法是不能保证线程安全的。只有调用put()方法和take()方法才会线程安全. put()方法是进队列，take()方法是出队列</strong><br/> <strong>【使用Java代码简单地使用阻塞队列】</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e8b258a8a88f4528a301071377885236.png\"/></p>\n<h2><a id=\"_174\"></a>定时器</h2>\n<p>定时器是软件开发中非常重要的组件。 类似于一个 “闹钟”. 达到一个设定的时间之后, 就执行某个指定好的代码.<br/> <em><strong>定时器是多线程引用的重要例子</strong></em><br/> <em><strong>【Java中实现的定时器】</strong></em><br/> Timer类 实现类定时器。Timer 类的核心方法为 schedule .<br/> schedule 包含两个参数. 第一个参数指定即将要执行的任务代码, 第二个参数指定多长时间之后执行 (单位为毫秒). 可以多次提交任务，根据时间的先后顺序来执行代码。<br/> <strong>【Timer类的使用】</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\56c2c39f0c8c40889224ffdcecdfb030.png\"/></p>\n<p><strong>【模拟实现定时器】</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1556e0850a4c4dfda1ffe43dcf856455.png\"/></p>\n<h2><a id=\"_185\"></a>常见的锁策略</h2>\n<p><em><strong>【悲观锁和乐观锁】</strong></em><br/> 悲观锁：<strong>发生冲突的概率大。总是假设最坏的情况，每一次拿出的数据都会觉得会被修改，所以每一次在拿数据的时候都要上锁。</strong><br/> 乐观锁：<strong>发生冲突的概率小。总是假设最好的情况，只有在数据更新的时候，才会正式对数据是否产生并发冲突进行检查，如果发生并发冲突，则让返回用户错误的信息，让用户决定如何去做。</strong><br/> 注意：<em><strong>乐观锁</strong></em>往往以<em><strong>纯用户态执行</strong></em>，而<em><strong>悲观锁</strong></em>往往要进入<em><strong>操作系统内核</strong></em>，对当前线程进行挂起（阻塞）等待</p>\n<p><em><strong>【读写锁和普通锁】</strong></em><br/> 普通锁：多个线程想要获取同一把锁，他们会发生竞争<br/> 读写锁是对锁进行了细化，将锁分为<em><strong>读锁和写锁</strong></em>。<br/> 读锁：读取数据的部分使用读锁<br/> 写锁：修改或者更新数据的部分使用写锁<br/> <em><strong>使用读写锁，多线程竞争情况：</strong></em><br/> （1）多个线程读数据，并不会引发线程安全问题，读锁不加锁，并发读取<br/> （2）有的线程读数据，有的线程写数据，会引发线程安全问题，读锁和写锁发挥作用<br/> （2）多个线程写数据，会引发线程安全问题，写锁发挥作用。<br/> <em><strong>读写锁就是把读操作和写操作区分对待. Java 标准库提供了 ReentrantReadWriteLock 类, 实现了读写锁.<br/> ReentrantReadWriteLock.ReadLock 类表示一个读锁. 这个对象提供了 lock / unlock 方法进行加锁解锁.<br/> ReentrantReadWriteLock.WriteLock 类表示一个写锁. 这个对象也提供了 lock / unlock 方法进行加锁解锁</strong></em><br/> 注意：<br/> 读加锁和读加锁之间,不互斥.<br/> 写加锁和写加锁之间,互斥.<br/> 读加锁和写加锁之间,互斥.</p>\n<p><em><strong>【重量级锁和轻量级锁】</strong></em><br/> 锁的核心特性 “原子性”, 这样的机制追根溯源是 CPU 这样的硬件设备提供的.<br/> CPU 提供了 “原子操作指令”.<br/> 操作系统基于 CPU 的原子指令, 实现了 mutex 互斥锁.<br/> JVM 基于操作系统提供的互斥锁, 实现了 synchronized 和 ReentrantLock 等关键字和类<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8a6623254caf4cd1a5f0e540ffca6e2c.png\"/></p>\n<p>重量级锁：<strong>锁的开销比较大，做的工作比较多。重量级锁主要依赖操作系统里提供的锁，使用这种锁线程比较容易发生阻塞等待</strong><br/> 轻量级锁：<strong>锁开销比较小，做的工作不是很多。轻量级锁尽量避开使用操作系统里面提供的锁，而是尽量在用户态来完成功能。尽量避免用户态和内核态的切换，尽量避免挂起（阻塞）等待</strong>。<br/> <em><strong>【自旋锁和挂起等待锁】</strong></em><br/> <strong>自旋锁：是轻量级锁的具体表现，是一个轻量级锁。</strong><br/> 自旋锁，一旦获取失败，并不会挂起等待，会迅速再次尝试能不能获取到锁<br/> <em><strong>自旋锁的优点：</strong></em><br/> （1）没有放弃CPU，不涉及线程的阻塞和调度，能第一时间获取到锁<br/> <em><strong>自旋锁的缺点：</strong></em><br/> （1）线程一直获取不到锁，对CPU的消耗会比较大</p>\n<p><strong>挂起等待锁：是重量级锁的具体表现，是一个重量级锁。</strong><br/> 重量级锁，一旦获取失败，线程会挂起等待，直到获取到锁为止<br/> <em><strong>重量级锁的优点：</strong></em><br/> （1）如果锁被其他线程占用，不会占用CPU<br/> <em><strong>重量级锁的缺点：</strong></em><br/> （1）锁释放的时候，不能第一时间获取到锁</p>\n<p><em><strong>【公平锁和非公平锁】</strong></em><br/> 任何判断是否公平？<br/> 遵循“先来后到”原则<br/> 公平锁：遵循“先来后到”原则，例如：B线程比C线程先到，A线程释放锁后，B线程获取到锁，然后再是C线程获取到锁。<br/> 非公平锁：不遵循“先来后到”原则。</p>\n<p><em><strong>【可重入锁和不可重入锁】</strong></em><br/> 可重入锁：允许线程可以多次获取同一把锁，并且不发生死锁的情况<br/> 不可重入锁：不允许线程可以多次获取同一把锁，如果某线程多次获取同一把锁，则会发生死锁的情况。</p>\n<h2><a id=\"CAS_241\"></a>CAS</h2>\n<p><em><strong>【什么是CAS】</strong></em><br/> CAS:字面意思是“比较并交换”。 <strong>相当于通过一个原子的操作, 同时完成 “读取内存, 比较是否相等, 修改内存” 这三个步骤. 本质上需要 CPU 指令的支撑</strong><br/> CAS是操作系统/硬件，给JVM提供的另一种更为轻量的<em><strong>原子操作机制</strong></em><br/> <em><strong>【CAS是怎么实现的】</strong></em><br/> 一个CAS涉及以下内容：<br/> 我们设内存中源数据为A，旧的预期数据为C，要修改的新数据为B<br/> （1）比较A与C值是否相同<br/> （2）A与C的值不同，将A的值赋给C，再重新比较<br/> （3）A与C的值相同，将B的值赋给A，内存中的数据就改成B了<br/> （4）返回操作是否成功<br/> <em><strong>CAS的伪代码（上面步骤的简单描述）：</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c38cc01828ab4390984b0db852ecdbc2.png\"/></p>\n<p><em><strong>【CAS的应用】</strong></em><br/> CAS有两个比较经典的应用：<br/> （1）CAS实现自旋锁<br/> （2）CAS实现原子类<br/> <em><strong>【CAS的ABA问题】</strong></em><br/> <em><strong>ABA问题</strong></em>：假设存在两个线程t1和t2，他们共享一个资源A，线程t1想通过CAS将资源A的值改了，过程：<br/> （1）读取资源A的值到，oldNum里面<br/> （2）比较oldNum里的值和内存里A的值<br/> 再这过程中线程t2将资源A里的值改成了B，然后有改成了A，这样就有问题了？线程t1是修改了资源A的值但是并不是之前的值，，而是由线程B修改后等到的值。这就是CAS的ABA问题。<br/> <em><strong>【ABA问题的解决方案】</strong></em><br/> 解决ABA问题的方案：给修改的值，引入版本号，通过比较版本号是否相同，相同则修改，不相同则不修改。</p>\n<h2><a id=\"Synchronized__267\"></a>Synchronized 原理</h2>\n<p><em><strong>【Synchronized锁的基本特点】</strong></em><br/> （1）Synchronized既是悲观锁，也是乐观锁<br/> （2）Synchronized既是重量级锁，也是轻量级锁<br/> （3）Synchronized不是读写锁<br/> （4）Synchronized是不公平锁<br/> （5）Synchronized是可重入锁<br/> （6）Synchronized轻量级锁部分是由自旋锁实现，重量级锁部分是挂起等待锁实现的。<br/> <em><strong>【Synchronized锁的加锁过程】</strong></em><br/> （1）无锁（不加锁）<br/> （2）偏向锁<br/> （3）轻量级锁<br/> （4）重量级锁<br/> Synchronized锁在加锁的时候，一般会经历以上阶段，但是，不一定4个阶段都会经历，这要根据具体的情况来定。<br/> <em><strong>介绍一下偏向锁的概念</strong></em>：偏向锁不是真正的加锁，一个线程在获取锁后并不是马上的进行加锁，偏向锁更像一个标记表示这个锁是我的，等到由其他线程来竞争锁的时候在加锁。<br/> <em><strong>【Synchronized锁的其他优化操作】</strong></em><br/> 【优化一：锁消除】<br/> 在某些程序中，有使用synchronized，但是程序并不处于多线程的情况下，是处在单线程，加不加锁结果都是一样的，反而涉及到加锁和解锁操作，都比较消耗资源，所以编译器就会自动消除锁。<br/> 【优化二：锁粗化】<br/> 一段逻辑中如果出现多次加锁解锁,编译器+ JVM会自动进行锁的粗化<br/> 实际开发过程中,使用细粒度锁,是期望释放锁的时候其他线程能使用锁.<br/> 但是实际上可能并没有其他线程来抢占这个锁.这种情况JVM就会自动把锁粗化,避免频繁申请释放锁.</p>\n<h2><a id=\"JUCjavautilconcurrent__289\"></a>JUC(java.util.concurrent) 的常见类（重要）</h2>\n<p><em><strong>【Callable 接口创建线程】</strong></em><br/> Callable是一个接口，与Runnable接口在作用是相同的，都是编写线程执行的任务，<em><strong>不同的是Callable接口重写的方法是由返回值的，Runnable则没有。</strong></em><br/> <em><strong>Callable接口创建线程的过程：</strong></em><br/> （1）创建匿名的Callable对象，重写call()方法<br/> （2）使用辅助类FutureTask类，将Callable对象当作构造方法的参数，创建FutureTask对象，FutureTask对象是对Callable对象重写call（）方法的返回值进行控制<br/> （3）创建Thread对象，将FutureTask对象当作构造方法的参数，然后启动线程。<br/> <em><strong>代码例子</strong></em>：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\075eb36886384203a3049a28d4eae0ff.png\"/><br/> <em><strong>理解 Callable</strong></em><br/> Callable 和 Runnable 相对, 都是描述一个 “任务”. Callable 描述的是带有返回值的任务, Runnable 描述的是不带返回值的任务.<br/> Callable 通常需要搭配 FutureTask 来使用. FutureTask 用来保存 Callable 的返回结果. 因为Callable 往往是在另一个线程中执行的, 啥时候执行完并不确定. FutureTask 就可以负责这个等待结果出来的工作.<br/> <em><strong>理解 FutureTask</strong></em><br/> 想象去吃麻辣烫. 当餐点好后, 后厨就开始做了. 同时前台会给你一张 “小票” . 这个小票就是FutureTask. 后面我们可以随时凭这张小票去查看自己的这份麻辣烫做出来了没<br/> <em><strong>【ReentrantLock类的使用（可重入锁）】</strong></em><br/> ReentrantLock类实现了可重入锁，与Synchronized锁定位类似，都是用来实现互斥效果，保证线程安全。<br/> <em><strong>&lt;ReentrantLock类与Synchronized关键字的区别&gt;</strong></em><br/> （1）synchronized是关键字，以代码块为单位进行解锁，<br/> ReentrantLock则是一个类，提供lock方法加锁，unlock解锁<br/> （2）ReentrantLock默认是非公平锁，但是 在构造实例的时候，可以指定参数，将锁变为公平锁。<br/> synchronized是非公平锁，ReentrantLock提供了公平锁和非公平锁两种实现，可以通过构造方法进行切换。<br/> （3）ReentrantLock还提供了一个特殊的加锁操作，tryLock()<br/> 默认的lock加锁失败，就阻塞<br/> 而tryLock()加锁失败，则不阻塞，直接往下执行，并且返回false<br/> 除了立即失败外，tryLock（）还能设定一定的等待时间<br/> （4）ReentrantLock提供了更强大的等待/唤醒机制<br/> synchronized搭配的是Object的wait和notify，唤醒的时候，随机唤醒一个线程<br/> ReentrantLock搭配的是Condition类来实现等待唤醒，可以做到随机唤醒一个线程，也可以指定某个线程唤醒<br/> <em><strong>&lt;ReentrantLock类的用法&gt;</strong></em><br/> lock(): 加锁, 如果获取不到锁就死等.<br/> trylock(超时时间): 加锁, 如果获取不到锁, 等待一定的时间之后就放弃加锁.<br/> unlock(): 解锁<br/> <em><strong>在加锁与解锁之间写代码</strong></em><br/> <em><strong>&lt;代码例子&gt;</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f5582587c1f9494c9cce85b0bddf0dea.png\"/><br/> <em><strong>&lt;如何选择使用哪个锁?&gt;</strong></em><br/> (1)锁竞争不激烈的时候, 使用 synchronized, 效率更高, 自动释放更方便.<br/> (2)锁竞争激烈的时候, 使用 ReentrantLock, 搭配 trylock 更灵活控制加锁的行为, 而不是死等.<br/> (3)如果需要使用公平锁, 使用 ReentrantLock.<br/> <em><strong>【原子类】</strong></em><br/> 原子类是一个线程安全的类。<br/> 原子类内部用的是 CAS 实现，所以性能要比加锁实现 i++ 高很多<br/> <strong>原子类满足了简单的递增或者递减的需求场景</strong><br/> 原子类有以下几个：<br/> AtomicBoolean<br/> AtomicInteger<br/> AtomicIntegerArray<br/> AtomicLong<br/> AtomicReference<br/> AtomicStampedReference</p>\n<p><em><strong>以 AtomicInteger 举例，常见方法有</strong></em><br/> addAndGet(int delta); i += delta;<br/> decrementAndGet(); --i;<br/> getAndDecrement(); i–;<br/> incrementAndGet(); ++i;<br/> getAndIncrement(); i++;<br/> <em><strong>【线程池】</strong></em><br/> <em><strong>&lt;为什么要有线程池&gt;</strong></em><br/> 虽然创建销毁线程比创建销毁进程更轻量, 但是在频繁创建销毁线程的时候还是会比较低效.<br/> 线程池就是为了解决这个问题. 如果某个线程不再使用了, 并不是真正把线程释放, 而是放到一个 “池子” 中, 下次如果需要用到线程就直接从池子中取, 不必通过系统来创建了.<br/> <em><strong>&lt;线程池的使用&gt;</strong></em><br/> &lt;方式一&gt;<em><strong>通过ExecutorService类 和 Executors类 创建线程池</strong></em><br/> <em><strong>ExecutorService 表示一个线程池实例.<br/> Executors 是一个工厂类, 能够创建出几种不同风格的线程池.<br/> ExecutorService 的 submit 方法能够向线程池中提交若干个任务</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0229c3df8d5c46db9921cfce567380b9.png\"/><br/> <em><strong>&lt;代码例子&gt;</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3ddb84eab65d421eb7427d006dbebe84.png\"/><br/> &lt;方法二&gt;<em><strong>使用ThreadPoolExecutor类创建实例，进而创建线程池（核心）</strong></em><br/> ThreadPoolExecutor类的构造方法：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1e819d95687d4153820c2841d5a8d46d.png\"/><br/> <em><strong>ThreadPoolExecutor类的构造方法的构造方法的解释：</strong></em><br/> 把创建一个线程池想象成开个公司. 每个员工相当于一个线程.<br/> <em><strong>corePoolSize: 正式员工的数量. (正式员工, 一旦录用, 永不辞退)<br/> maximumPoolSize: 正式员工 + 临时工的数目. (临时工: 一段时间不干活, 就被辞退).<br/> keepAliveTime: 临时工允许的空闲时间.<br/> unit: keepaliveTime 的时间单位, 是秒, 分钟, 还是其他值.<br/> workQueue: 传递任务的阻塞队列<br/> threadFactory: 创建线程的工厂, 参与具体的创建线程工作.<br/> RejectedExecutionHandler: 拒绝策略, 如果任务量超出公司的负荷了接下来怎么处理.<br/> AbortPolicy(): 超过负荷, 直接抛出异常.<br/> CallerRunsPolicy(): 调用者负责处理<br/> DiscardOldestPolicy(): 丢弃队列中最老的任务.<br/> DiscardPolicy(): 丢弃新来的任务.</strong></em><br/> <em><strong>&lt;通过ThreadPoolExecutor类创建线程池&gt;</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e15a2f1b5dae4ab2b38d9ce5a39e03d2.png\"/><br/> <em><strong>【信号量 Semaphore】</strong></em><br/> <em><strong>信号量，用来表示“有效资源的个数”，本质上是一个计数器<br/> 获取的资源超过了我们设定的资源数量，程序会阻塞</strong></em><br/> <em><strong>&lt;理解信号量&gt;</strong></em><br/> 可以把信号量想象成是停车场的展示牌: 当前有车位 100 个. 表示有 100 个可用资源. 当有车开进去的时候, 就相当于申请一个可用资源, 可用车位就 -1 (这个称为信号量的 P 操作)当有车开出来的时候, 就相当于释放一个可用资源, 可用车位就 +1 (这个称为信号量的 V 操作)如果计数器的值已经为 0 了, 还尝试申请资源, 就会阻塞等待, 直到有其他线程释放资源</p>\n<p>Java中，<em><strong>Semaphore类实现了信号量</strong></em><br/> Semaphore类的构造方法：<br/> 1.使用给定数量的许可和非空中公平设置创建信号量<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\aeba87043eca4ceba66093b7246a0c96.png\"/><br/> 2.使用给定的许可数量和给定的公平性设置创建信号量。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\396424b2549241c39f8ccc2fa229934c.png\"/><br/> <em><strong>Semaphore类主要的方法：</strong></em><br/> acquire 方法表示申请资源(P操作), release 方法表示释放资源(V操作)</p>\n<p><em><strong>&lt;Semaphore类使用实例&gt;</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7c99e0138c394e59851e8d8c69482641.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a7dd4bb2a06c47b59913454c32c07091.png\"/></p>\n<p><em><strong>【CountDownLatch】</strong></em><br/> <strong>CountDownLatch类是倒计时锁存器的实现。</strong><br/> 倒计时锁存器是一种同步辅助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。<br/> CountDownLatch类可以实现同时等待N个线程结束。<br/> <em><strong>CountDownLatch类的构造方法：</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5604c58b1edd4e46b894b356d5491eb9.png\"/><br/> 构造方法的参数count表示给倒计时锁存器设置一个初始值，可以等待count个线程结束<br/> <em><strong>CountDownLatch类的方法：</strong></em><br/> （1）await()方法：导致当前线程等待，直到锁存器已倒计时到零，除非线程被中断<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b1afbd88f4ca4c5ea11a810e42be3adb.png\"/><br/> （2）await(long timeout, TimeUnit unit)方法：导致当前线程等待，直到锁存器已倒计时为零，除非线程中断或指定的等待时间已过。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6f57038d630f4d378508c829765bf292.png\"/><br/> （3）countDown()方法：递减锁存器的计数，如果计数达到零，则释放所有等待线程<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f93c99d70e2a4292ab1a7a8d16975024.png\"/><br/> （4）getCount()方法:返回当前计数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ec5808daebe947d7a85a69cce9a5f117.png\"/><br/> <em><strong>&lt;CountDownLatch类使用例子&gt;</strong></em><br/> 构造 CountDownLatch 实例, 初始化 10 表示有 10 个任务需要完成.<br/> 每个任务执行完毕, 都调用 latch.countDown() . 在 CountDownLatch 内部的计数器同时自减.<br/> 主线程中使用 latch.await(); 阻塞等待所有任务执行完毕. 相当于计数器为 0 了<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4b83a4e48e3742daa179a9ce31d6aa64.png\"/></p>\n<h2><a id=\"_417\"></a>线程安全的集合类</h2>\n<p>我们之前学的基本数据结构基本都是线程不安全的类<br/> <em><strong>&lt;线程不安全的集合类&gt;</strong></em><br/> ArrayList,LinkedList,PriorityQueue,TreeSet,HashSet,TreeMap,HashMap…<br/> <em><strong>【多线程环境使用 ArrayList】</strong></em><br/> &lt;方法一&gt;自己使用同步机制 (synchronized 或者 ReentrantLock)<br/> &lt;方法二&gt;使用Collections.synchronizedList(new ArrayList&lt;&gt;())返回一个线程安全的List对象;<br/> &lt;方法三&gt;使用 CopyOnWriteArrayList类<br/> <em><strong>CopyOnWrite容器即写时复制的容器。</strong></em><br/> <em><strong>【多线程环境使用队列】</strong></em><br/> （1) ArrayBlockingQueue<br/> 基于数组实现的阻塞队列<br/> （2) LinkedBlockingQueue<br/> 基于链表实现的阻塞队列<br/> （3) PriorityBlockingQueue<br/> 基于堆实现的带优先级的阻塞队列<br/> （4) TransferQueue<br/> 最多只包含一个元素的阻塞队列<br/> <em><strong>【多线程环境使用哈希表】</strong></em><br/> HashMap本身是线程不安全的。<br/> 在多线程环境下使用哈希表可以使用:<br/> Hashtable<br/> ConcurrentHashMap（建议使用）<br/> <em><strong>Hashtable类和ConcurrentHashMap类加锁的方式是不一样的</strong></em><br/> Hashtable类只是简单的将关键的方法加锁，就相当于对Hashtable对象加锁，每一次的读或者写都要发生竞争。<br/> <em><strong>ConcurrentHashMap类则是Hashtable类的改进版本</strong></em>：<br/> （1）读操作没有加锁(但是使用了 volatile 保证从内存读取结果), 只对写操作进行加锁. 加锁的方式仍然<br/> 是是用 synchronized, 但是不是锁整个对象, 而是 “锁桶” (用每个链表的头结点作为锁对象), 大大降低了锁冲突的概率.<br/> (2)充分利用 CAS 特性. 比如 size 属性通过 CAS 来更新. 避免出现重量级锁的情况<br/> (3)优化了扩容方式: 化整为零.就是说 在扩容的时候，并不是一次性全部扩容好，每一次扩容一些</p>\n<h2><a id=\"_447\"></a>死锁</h2>\n<p><em><strong>【什么是死锁】</strong></em><br/> 死锁：多个线程同时阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。<br/> <em><strong>【出现死锁的情况】</strong></em><br/> （1）一个线程多次获取同一把锁<br/> （2）两个线程两把锁<br/> （3）N个线程M把锁<br/> <em><strong>【死锁的四个必要条件】</strong></em><br/> （1）<em><strong>互斥使用</strong></em>，即当资源被一个线程使用(占有)时，别的线程不能使用<br/> （2）<em><strong>不可抢占</strong></em>，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。<br/> (3)<em><strong>请求和保持</strong></em>，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。<br/> (4)<em><strong>循环等待(最重要)</strong></em>，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样<br/> 就形成了一个等待环路<br/> <em><strong>【如何避免死锁】</strong></em><br/> 产生死锁的必要条件前三个，互斥使用、不可抢占、请求和保持，都是锁的基本特点，我们无法改变，而<em><strong>循环等待</strong></em>是通过我们写出的代码决定的，所以，我们可以从循环等待这一方面入手。<br/> <em><strong>&lt;破坏循环等待&gt;</strong></em><br/> 最常用的一种死锁阻止技术就是锁排序. 假设有 N 个线程尝试获取 M 把锁, 就可以针对 M 把锁进行编号(1, 2, 3…M).<br/> N 个线程尝试获取锁的时候, 都按照固定的按编号由小到大顺序来获取锁. 这样就可以避免环路等待.</p>\n<p><em><strong>我们在编写多线程代码的时候，要加锁的部分，我们要注意死锁情况</strong></em></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-01 18:25:28", "summary": "多线程什么是线程线程就是一个执行流，每一个线程都能按照自己的代码执行顺序执行代码，能够实现多个线程同时执行多分代码，实现并发编程。为什么使用线程并发编程的需要。单核的发展已经到了瓶颈，我们想要提高的算"}