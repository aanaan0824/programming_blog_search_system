{"blogid": "126743179", "writerAge": "码龄24天", "writerBlogNum": "53", "writerCollect": "0", "writerComment": "0", "writerFan": "24", "writerGrade": "3级", "writerIntegral": "530", "writerName": "web13282751078", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743179.jpg", "writerRankTotal": "38679", "writerRankWeekly": "12344", "writerThumb": "0", "writerVisitNum": "2192", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:27:53 发布", "blog_title": "jvm - 逃逸分析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>堆是分配对象的唯一选择吗？</p>\n<p><strong>不是。</strong></p>\n<p>随着<code>Java</code>的发展和<strong>逃逸分析技术</strong>的逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>会使原有的绝对堆上分配发生一些微妙的<strong>变化</strong>。</p>\n<p>逃逸分析</p>\n<p><strong>如果一个对象并没有逃逸出方法的话，那么就可能被优化为栈上分配。</strong></p>\n<ul><li>如果有个对象在方法中被定义，且只在方法内部使用，则认为它没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法引用，则认为发生了逃逸。</li></ul>\n<p><strong>如何将一个会逃逸的对象变成非逃逸对象？</strong></p>\n<pre><code>//逃逸\npublic StringBuilder test() {\n    StringBuilder sb = new StringBuild();\n    return sb;\n}\n\n//非逃逸\npublic String test() {\n    StringBuilder sb = new StringBuild();\n    return sb.toString();\n}\n</code></pre>\n<h5><a id=\"__30\"></a>⑩① 使用逃逸分析进行优化</h5>\n<h6><a id=\"1__32\"></a>1) 栈上分配</h6>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n\n        /* 执行一千万次 */\n        for (int i = 0; i &lt; 10000000; i++) {\n            CreateObj();\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(\"耗时：\" + (end - start) + \"ms\");\n    }\n\n\n    public static void CreateObj() {\n        /* 未发生逃逸 */\n        User user = new User();\n    }\n}\nclass User { }\n</code></pre>\n<p><strong>首先我们关闭逃逸分析。</strong></p>\n<p><img alt=\"image-20220221040217165\" src=\"..\\..\\static\\image\\5040a03b1b5bd6ff2de7e558affb8eb2.png\"/></p>\n<p>得到运行耗时：<code>46ms</code>。</p>\n<p><strong>开启逃逸分析。</strong></p>\n<p>得到运行耗时：<code>2ms</code>。</p>\n<p><strong>修改代码：</strong></p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n\n        User user = null;\n        \n        /* 执行一千万次 */\n        for (int i = 0; i &lt; 10000000; i++) {\n            user = CreateObj();\n\n        }\n        /* Obj 可能被其他线程继续使用 */\n        userObj(user);\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(\"耗时：\" + (end - start) + \"ms\");\n    }\n\n\n    public static User CreateObj() {\n        /* 发生逃逸 */\n        User user = new User();\n        return user;\n    }\n\n    public static void userObj(User user) { }\n\n}\nclass User {\n    public int age = 5;\n}\n</code></pre>\n<p>使代码发生逃逸，且开启逃逸分析。</p>\n<p><strong>得到运行时间：<code>43ms</code>。</strong></p>\n<h6><a id=\"2__107\"></a>2) 同步省略</h6>\n<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>\n<h6><a id=\"3__111\"></a>3) 分离对象或标量替换</h6>\n<p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在<code>CPU</code>寄存器中。</p>\n<p><strong>标量</strong>指一个无法再分解成更小得数据的数据，<strong>例如基本数据类型就是标量。</strong></p>\n<p><strong>聚合量</strong>指的是那些<strong>还可以分解为 标量 或 聚合量 的数据。</strong></p>\n<p>**标量替换：**在<code>JIT</code>阶段，如果经过逃逸分析，发现一个对象并没有发生逃逸，则会将这个对象拆解为多个标量的状态。</p>\n<p><strong>例如：</strong></p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        test();\n    }\n    \n    public static void test() {\n        Point point = new Point();\n    }\n}\n\nclass Point {\n    int x;\n    int y;\n}\n</code></pre>\n<p>此时，经过标量替换，栈中<code>Point</code>实例会被替换为。</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        test();\n    }\n    \n    //此处被替换\n    public static void test() {\n        int x;\n        int y;\n    }\n}\n\nclass Point {\n    int x;\n    int y;\n}\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:27:53", "summary": "堆是分配对象的唯一选择吗？不是。随着的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术会使原有的绝对堆上分配发生一些微妙的变化。逃逸分析如果一个对象并没有逃逸出方法的话，那么就可能被优化为栈上"}