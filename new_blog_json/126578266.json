{"blogid": "126578266", "writerAge": "码龄1年", "writerBlogNum": "89", "writerCollect": "1106", "writerComment": "1780", "writerFan": "4058", "writerGrade": "5级", "writerIntegral": "4238", "writerName": "小白又菜", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126578266.jpg", "writerRankTotal": "4022", "writerRankWeekly": "310", "writerThumb": "1868", "writerVisitNum": "66795", "blog_read_count": "325", "blog_time": "已于 2022-08-30 09:49:52 修改", "blog_title": "[ C++ ] STL _ Vector使用及其模拟实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"1.Vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#1.Vector%E7%9A%84%E4%BB%8B%E7%BB%8D\">1.Vector的介绍</a></p>\n<p id=\"1.1%20Vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%20Vector%E7%9A%84%E4%BB%8B%E7%BB%8D\">1.1 Vector的介绍</a></p>\n<p id=\"2.Vector%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#2.Vector%E7%9A%84%E4%BD%BF%E7%94%A8\">2.Vector的使用</a></p>\n<p id=\"2.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89\">2.1 vector的定义</a></p>\n<p id=\"2.2%20vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%20vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0\">2.2 vector 迭代器的使用 </a></p>\n<p id=\"2.3%20vector%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:40px;\"><a href=\"#2.3%20vector%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98\">2.3 vector的空间增长问题</a></p>\n<p id=\"3.%20vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9\">3. vector的增删查改</a></p>\n<p id=\"3.1%20push_back%20%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20push_back%20%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">3.1 push_back （重点）</a></p>\n<p id=\"3.2%20pop_back%20(%E9%87%8D%E7%82%B9)-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20pop_back%20%28%E9%87%8D%E7%82%B9%29\">3.2 pop_back (重点)</a></p>\n<p id=\"3.3%20insert-toc\" style=\"margin-left:40px;\"><a href=\"#3.3%20insert\">3.3 insert</a></p>\n<p id=\"3.4%20erase-toc\" style=\"margin-left:40px;\"><a href=\"#3.4%20erase\">3.4 erase</a></p>\n<p id=\"3.5%20operator%20%5B%20%5D%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#3.5%20operator%20%5B%20%5D%C2%A0\">3.5 operator [ ] </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"1.Vector%E7%9A%84%E4%BB%8B%E7%BB%8D\">1.Vector的介绍</h1>\n<h2 id=\"1.1%20Vector%E7%9A%84%E4%BB%8B%E7%BB%8D\">1.1 Vector的介绍</h2>\n<p><a class=\"link-info\" href=\"http://www.cplusplus.com/reference/vector/vector/\" title=\"vector官方文档介绍\">vector官方文档介绍</a></p>\n<blockquote>\n<p>1.vector是表示可变大小数组的序列容器。</p>\n<p></p>\n<div>\n<span style=\"color:#777777;\">2. </span>\n<span style=\"color:#777777;\">就像数组一样，</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">也采用的连续存储空间来存储元素。也就是意味着可以采用下标对</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</span>\n</div>\n<div></div>\n<div>\n<div>\n<span style=\"color:#777777;\">3. </span>\n<span style=\"color:#777777;\">本质讲，</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector</span>\n<span style=\"color:#777777;\">并不会每次都重新分配大小。</span>\n</div>\n<div></div>\n<div>\n<div>\n<span style=\"color:#777777;\">4. vector</span>\n<span style=\"color:#777777;\">分配空间策略：</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#777777;\">5. </span>\n<span style=\"color:#777777;\">因此，</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#777777;\">6. </span>\n<span style=\"color:#777777;\">与其它动态序列容器相比（</span>\n<span style=\"color:#777777;\">deque, list and forward_list</span>\n<span style=\"color:#777777;\">），</span>\n<span style=\"color:#777777;\"> vector</span>\n<span style=\"color:#777777;\">在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list</span>\n<span style=\"color:#777777;\">和</span>\n<span style=\"color:#777777;\">forward_list统一的迭代器和引用更好</span>\n</div>\n</div>\n</div>\n</blockquote>\n<p></p>\n<h1 id=\"2.Vector%E7%9A%84%E4%BD%BF%E7%94%A8\"><strong>2.Vector的使用</strong></h1>\n<p>vector在实际中非常重要且使用，因此我们需要熟悉使用常用的接口，以下将从常用的接口入手并进行模拟实现</p>\n<p>vector模拟实现的基本结构：</p>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nclass vector\n{\npublic:\n\t\ttypedef T* iterator;\n\t\ttypedef const T* const_iterator;\n\t    \n        //无参构造\n        vector()\n\t\t\t:_start(nullptr)\n\t\t\t, _finish(nullptr)\n\t\t\t, _endofstoage(nullptr)\n\t\t{}\n\n\t\t//资源管理\n\t\t~vector()\n\t\t{\n\t\t\tif (_start)\n\t\t\t{\n\t\t\t\tdelete[] _start;\n\t\t\t\t_start = _finish = _endofstoage = nullptr;\n\t\t\t}\n\t\t}\n\n\n        size_t size() const\n\t\t{\n\t\t\treturn _finish - _start;\n\t\t}\n\n\n\t\tsize_t capacity() const\n\t\t{\n\t\t\treturn _endofstoage - _start;\n\t\t}\t\nprivate:\n\t\titerator _start;\n\t\titerator _finish;\n\t\titerator _endofstoage;\n};</code></pre>\n<h2 id=\"2.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89\">2.1 vector的定义</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造函数声明<a href=\"https://cplusplus.com/reference/vector/vector/vector/\" title=\"constructor\">constructor</a></td><td>接口说明</td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\">vector()</span>\n<span style=\"color:#777777;\">（重点）</span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">无参构造</span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\">vector (const vector&amp; x); </span>\n<span style=\"color:#777777;\">（重点） </span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">拷贝构造</span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">（</span>\n<span style=\"color:#777777;\">size_type n, const value_type&amp; val = value_type()</span>\n<span style=\"color:#777777;\">）</span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">构造并初始化</span>\n<span style=\"color:#777777;\">n</span>\n<span style=\"color:#777777;\">个</span>\n<span style=\"color:#777777;\">val </span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\">vector (InputIterator first, InputIterator last); </span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">使用迭代器进行初始化构造</span>\n</div> </td></tr></tbody></table>\n<pre><code class=\"language-cpp\">//无参构造\nvector()\n\t:_start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{}\n\n//拷贝构造\nvoid swap(vector&lt;T&gt;&amp; v)\n{\n\tstd::swap(_start, v._start);\n\tstd::swap(_finish, v._finish);\n\tstd::swap(_endofstoage, v._endofstoage);\n}\n\n//vector(const vector&amp; v)\nvector(const vector&lt;T&gt;&amp; v)\n\t:_start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\n\tvector tmp(v.begin(), v.end());\n\tswap(tmp);\n}\n\n//初始化n个val \nvector(size_t n, const T&amp; val = T())\n\t:_start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\n\treserve(n);\n\tfor (size_t i = 0; i &lt; n; ++i)\n\t{\n\t\tpush_back(val);\n\t}\n}\n\n//使用迭代化区间初始化\ntemplate &lt;class InputIterator&gt;\nvector(InputIterator first, InputIterator last)\n\t:_start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\n\twhile (first != last)\n\t{\n\t\tpush_back(*first);\n\t\t++first;\n\t}\n}</code></pre>\n<h2 id=\"2.2%20vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0\">2.2 vector 迭代器的使用 </h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>iterator的使用</td><td>接口说明</td></tr><tr><td>begin+end （重点）</td><td>\n<div>\n<span style=\"color:#777777;\">获取第一个数据位置的</span>\n<span style=\"color:#777777;\">iterator/const_iterator</span>\n<span style=\"color:#777777;\">， 获取最后一个数据的下一个位置 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">的</span>\n<span style=\"color:#777777;\">iterator/const_iterator</span>\n</div> </td></tr><tr><td>rbegin+rend（反向迭代器）</td><td>\n<div>\n<span style=\"color:#777777;\">获取最后一个数据位置的</span>\n<span style=\"color:#777777;\">reverse_iterator</span>\n<span style=\"color:#777777;\">，获取第一个数据前一个位置的 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">reverse_iterator </span>\n</div> </td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-cpp\">iterator begin()\n{\n\treturn _start;\n}\niterator end()\n{\n\treturn _finish;\n}\n\nconst iterator begin() const\n{\n\treturn _start;\n}\nconst iterator end() const\n{\n\treturn _finish;\n}</code></pre>\n<h2 id=\"2.3%20vector%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98\">2.3 vector的空间增长问题</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>容量空间</td><td>接口说明</td></tr><tr><td>size</td><td>\n<div>\n<span style=\"color:#777777;\">获取数据个数</span>\n</div> </td></tr><tr><td>capacity</td><td>\n<div>\n<span style=\"color:#777777;\">获取容量大小</span>\n</div> </td></tr><tr><td>empty</td><td>\n<div>\n<span style=\"color:#777777;\">判断是否为空</span>\n</div> </td></tr><tr><td>resize（重点）</td><td>\n<div>\n<span style=\"color:#777777;\">改变</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">的</span>\n<span style=\"color:#777777;\">size</span>\n</div> </td></tr><tr><td>reserve（重点）</td><td>\n<div>\n<span style=\"color:#777777;\">改变</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">的</span>\n<span style=\"color:#777777;\">capacity </span>\n</div> </td></tr></tbody></table>\n<pre><code class=\"language-cpp\">void resize(size_t n, T val = T())\n{\n\tif (n &gt; capacity())\n\t{\n\n\t\treserve(n);\n\t}\n\tif (n &gt; size())\n\t{\n\t\twhile (_finish &lt; _start + n)\n\t\t{\n\t\t\t*_finish = val;\n\t\t\t++_finish;\n\t\t}\n\t}\n\telse\n\t{\n\t\t_finish = _start + n;\n\t}\n}\n</code></pre>\n<pre><code class=\"language-cpp\">void reserve(size_t n)\n{\n\tsize_t sz = size();\n\tif (n &gt; capacity())\n\t{\n\t\tT* tmp = new T[n];\n\t\tif (_start)\n\t\t{\n\t\t\t//这里会造成浅拷贝问题\n\t\t\t//memcpy(tmp, _start, size() * sizeof(T));\n\t\t\tfor (size_t i = 0; i &lt; size(); ++i)\n\t\t\t{\n\t\t\t\ttmp[i] = _start[i];\n\t\t\t}\n\n\t\t\tdelete[] _start; \n\t\t}\n\t\t_start = tmp;\n\t}\n\t_finish = _start + sz;\n\t_endofstoage = _start + n;\n\n}</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>注意：</strong></span></p>\n<p>1、我们在扩容的时候有一个小细节，capacity的容量扩容在vs和g++下分别运行是有区别的，在Vs下caoacity的扩容是按1.5倍增长的；在g++下是按2倍增长的。不能固化的认为，vector的增长都是2倍，具体增长的多少要根据需求定义。Vs是PJ盘本的STL，g++是SGI版本的STL。</p>\n<pre><code class=\"language-cpp\">//vs下\nint main()\n{\n\tvector&lt;int&gt; v;\n\tsize_t sz = v.capacity();\n\tfor (int i = 0; i &lt; 100; ++i)\n\t{\n\t\tv.push_back(i);\n\t\tif (sz != v.capacity())\n\t\t{\n\t\t\tsz = v.capacity();\n\t\t\tcout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n';\n\t\t}\n\t}\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"417\" src=\"..\\..\\static\\image\\98a6375403834e6aaf65e43fa28ea967.png\" width=\"786\"/></p>\n<p><img alt=\"\" height=\"806\" src=\"..\\..\\static\\image\\a143e4b894c84523bbbf6e7532430eb1.png\" width=\"641\"/></p>\n<p></p>\n<h1 id=\"3.%20vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9\">3. vector的增删查改</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>vector</strong></span>\n<span style=\"color:#777777;\"><strong>增删查改 </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>接口说明 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"http://www.cplusplus.com/reference/vector/vector/push_back/\" title=\"push_back\">push_back</a></strong></span>\n<span style=\"color:#777777;\">（重点）</span>\n</div> </td><td>尾插</td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"http://www.cplusplus.com/reference/vector/vector/pop_back/\" title=\"pop_back\">pop_back</a></strong></span>\n<span style=\"color:#777777;\">（重点）</span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">尾删</span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"https://cplusplus.com/reference/algorithm/find/?kw=find\" title=\"find\">find</a> </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">查找。（注意这个是算法模块实现，不是</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">的成员接口）</span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"https://cplusplus.com/reference/vector/vector/insert/\" title=\"insert\">insert</a></strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">在</span>\n<span style=\"color:#777777;\">pos</span>\n<span style=\"color:#777777;\">之前插入</span>\n<span style=\"color:#777777;\">val </span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"https://cplusplus.com/reference/vector/vector/erase/\" title=\"erase\">erase</a></strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">删除</span>\n<span style=\"color:#777777;\">pos</span>\n<span style=\"color:#777777;\">位置的数据 </span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"https://cplusplus.com/reference/vector/vector/swap/\" title=\"swap\">swap</a></strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">交换两个</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">的数据空间 </span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong><a class=\"link-info\" href=\"https://cplusplus.com/reference/vector/vector/operator%5B%5D/\" title=\"operator[]\">operator[]</a></strong></span>\n<span style=\"color:#777777;\">（重点）</span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\">像数组一样访问</span>\n</div> </td></tr></tbody></table>\n<h2 id=\"3.1%20push_back%20%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">3.1 push_back （重点）</h2>\n<pre><code class=\"language-cpp\">\t\tvoid push_back(const T&amp; x)\n\t\t{\n\t\t\tif (_finish == _endofstoage)\n\t\t\t{\n\t\t\t\tsize_t newCapacity = capacity() == 0 ? 4 : capacity() * 2;\n\t\t\t\treserve(newCapacity);\n\t\t\t}\n\t\t\t*_finish = x;\n\t\t\t++_finish;\n\n\t\t\t//insert(end(), x);\n\t\t}</code></pre>\n<p> 方法：</p>\n<p>1、实现要考虑是否需要扩容，如果 _finish == _endofstoage 则需要扩容</p>\n<p>2、尾插元素， ++_finish</p>\n<h2 id=\"3.2%20pop_back%20(%E9%87%8D%E7%82%B9)\">3.2 pop_back (重点)</h2>\n<p>pop_back比较简单，尾删的逻辑不是删除而是覆盖，因此只需要--_finish即可</p>\n<pre><code class=\"language-cpp\">\t\tvoid pop_back()\n\t\t{\n\t\t\tif (_finish &gt; _start)\n\t\t\t{\n\t\t\t\t--_finish;\n\t\t\t}\n\t\t\t//erase(end() - 1);\n\t\t}</code></pre>\n<h2 id=\"3.3%20insert\">3.3 insert</h2>\n<p>insert插入是在pos位置之前插入x</p>\n<p>方法：</p>\n<p>1、判断pos位置的合法性。</p>\n<p>2、判断是否需要扩容，如果需要扩容则注意，这里会引发<span style=\"color:#fe2c24;\">迭代器失效问题。</span></p>\n<blockquote>\n<p>由于迭代器失效问题比较复杂，情况多样，我总结了一篇单独的博客供大家参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_58325487/article/details/126595973\" title=\"[ C++ ] STL_vector -- 迭代器失效问题\">[ C++ ] STL_vector -- 迭代器失效问题</a> </p>\n</blockquote>\n<p>3、 挪动数据，由后往前走，让前一个覆盖后一个。</p>\n<p>4、插入数据，++_finish， 返回pos位置</p>\n<pre><code class=\"language-cpp\">\t\titerator insert(iterator pos, const T&amp; x)\n\t\t{\n\t\t\t//检查\n\t\t\tassert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);\n\t\t\t//空间不够  扩容\n\t\t\t//扩容以后 pos就失效了\n\t\t\tif (_finish == _endofstoage)\n\t\t\t{\n\t\t\t\t//使用相对距离来计算确定pos位置\n\t\t\t\tsize_t n = pos - _start;\n\t\t\t\tsize_t newCapacity = capacity() == 0 ? 4 : capacity() * 2;\n\t\t\t\treserve(newCapacity);\n\t\t\t\tpos = _start + n;\n\t\t\t}\n\n\t\t\t//挪动数据\n\t\t\titerator end = _finish - 1;\n\t\t\twhile (end &gt;= pos)\n\t\t\t{\n\t\t\t\t*(end + 1) = *end;\n\t\t\t\t--end;\n\t\t\t}\n\t\t\t*pos = x;\n\t\t\t++_finish;\n\n\t\t\treturn pos;\n\t\t}</code></pre>\n<h2 id=\"3.4%20erase\">3.4 erase</h2>\n<p><span style=\"color:#777777;\">erase是删除</span><span style=\"color:#777777;\">pos</span><span style=\"color:#777777;\">位置的数据</span></p>\n<p><span style=\"color:#777777;\">方法：</span></p>\n<p><span style=\"color:#777777;\">1、判断pos位置的合法性。</span></p>\n<p><span style=\"color:#777777;\">2.、拿到pos位置下一个位置的迭代器，从前往后，后一个覆盖前一个。</span></p>\n<p><span style=\"color:#777777;\">3、最后--_finish，返回pos位置</span></p>\n<pre><code class=\"language-cpp\">        iterator erase(iterator pos)\n\t\t{\n\t\t\tassert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);\n\t\t\titerator it = pos + 1;\n\t\t\twhile (it != _finish)\n\t\t\t{\n\t\t\t\t*(it - 1) = *it;\n\t\t\t\t++it;\n\t\t\t}\n\t\t\t--_finish;\n\n\t\t\treturn pos;\n\t\t}</code></pre>\n<h2 id=\"3.5%20operator%20%5B%20%5D%C2%A0\">3.5 operator [ ] </h2>\n<p>重载的operator [ ] 就是取到pos位置对应的数据即可，比较简单</p>\n<pre><code class=\"language-cpp\">\t\tT&amp; operator[](size_t pos)\n\t\t{\n\t\t\tassert(pos &lt; size());\n\t\t\treturn _start[pos];\n\t\t}\n\n\t\tconst T&amp; operator[](size_t pos) const\n\t\t{\n\t\t\tassert(pos &lt; size());\n\t\t\treturn _start[pos];\n\t\t}</code></pre>\n<p></p>\n<p> (本篇完)</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-30 09:49:52", "summary": "目录的介绍的介绍的使用的定义迭代器的使用的空间增长问题的增删查改重点重点的介绍的介绍官方文档介绍官方文档介绍是表示可变大小数组的序列容器。就像数组一样，也采用的连续存储空间来存储元素。也就是意味着可以"}