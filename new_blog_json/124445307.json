{"blogid": "124445307", "writerAge": "码龄4年", "writerBlogNum": "1", "writerCollect": "1", "writerComment": "0", "writerFan": "38", "writerGrade": "1级", "writerIntegral": "11", "writerName": "weixin_43303719", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124445307.jpg", "writerRankTotal": "240393", "writerRankWeekly": "1185386", "writerThumb": "1", "writerVisitNum": "2475", "blog_read_count": "2475", "blog_time": "已于 2022-05-21 11:09:38 修改", "blog_title": "Tp5中结合es的使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>es的安装:</h2>\n<p>安装:docker pull elasticsearch:7.12.1</p>\n<p>创建目录:</p>\n<p>mkdir /docker/es</p>\n<p>mkdir /docker/es/conf</p>\n<p>mkdir /docker/es/data</p>\n<p>mkdir /docker/es/plugins</p>\n<p>创建文件:</p>\n<p>touch /docker/es/conf/elasticsearch.yml</p>\n<p>配置文件：</p>\n<pre><code>cluster.name: my-application #集群名称\nnode.name: node-1 #节点名称\n#是不是有主节点资格\nnode.master: true\n\n#是否存储数据\nnode.data: true\n# 是否允许跨域REST请求\nhttp.cors.enabled: true\n \n# 允许REST请求来自何处\nhttp.cors.allow-origin: \"*\"\n#最大集群节点数\nnode.max_local_storage_nodes: 3\n#数据和日志的存储目录 \npath.data: /usr/share/elasticsearch/data\npath.logs: /usr/share/elasticsearch/logs\n\n##设置绑定的ip，设置为0.0.0.0以后就可以让任何计算机节点访问到了 \nnetwork.host: 0.0.0.0\nnetwork.publish_host: 容器ip\nhttp.port: 9200 #端口\n#内部节点直接沟通端口\ntransport.tcp.port: 9300\n##设置在集群中的所有节点名称，这个节点名称就是之前所修改的，当然你也可以采用默认的也行，目前 是单机，放入一个节点即可 \ndiscovery.zen.ping.unicast.hosts: [\"容器ip1:9300\",\"容器ip2:9201\",\"容器ip3:9202\"]\n\n#es7.x之后新增配置，初始化一个新的集群时 需要此配置来选举master\ncluster.initial_master_nodes: [\"node-1\",\"node-2\",\"node-3\"]\ndiscovery.zen.minimum_master_nodes: 2</code></pre>\n<p>启动镜像:</p>\n<p>docker run -p 9200:9200 -d --name es -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -v /docker/es/conf/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /docker/es/data:/usr/share/elasticsearch/data -v /docker/es/plugins:/usr/share/elasticsearch/plugins --privileged=true elasticsearch:7.12.1</p>\n<p>报错处理:</p>\n<p>出现异常：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p>\n<p>解决：</p>\n<ol><li>修改配置sysctl.conf vi /etc/sysctl.conf</li><li>在尾行添加以下内容 vm.max_map_count=655300</li><li>执行命令 sysctl -p</li></ol>\n<p>配置中文分词：</p>\n<p><a href=\"https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.12.1\" title=\"Release v7.12.1 · medcl/elasticsearch-analysis-ik · GitHub\">Release v7.12.1 · medcl/elasticsearch-analysis-ik · GitHub</a></p>\n<p>解压安装包：放到定义的plugins目录中的ik文件夹中</p>\n<h1><strong>kibana的安装:(管理es的工具)</strong></h1>\n<p>docker pull kibana:7.12.1</p>\n<p>创建文件:</p>\n<p>mkidr /docker/kibana</p>\n<p>mkdir /docker/kibana/conf</p>\n<p>touch /docker/kibana/conf/kibana.yml</p>\n<p>配置文件:</p>\n<pre><code>server.name: kibana \nserver.host: \"0.0.0.0\" \nelasticsearch.hosts: [\"http://容器ip:9400\"] \nxpack.monitoring.ui.container.elasticsearch.enabled: true</code></pre>\n<p>启动:</p>\n<p>docker run -p 5601:5601 -d --name -v /docker/kibana/conf/kibana.yml:/usr/share/kibana/config/kibana.yml --privileged=true kibana:7.12.1</p>\n<p></p>\n<h1>logstash增量同步mysql到es配置详解</h1>\n<p>docker 镜像安装</p>\n<p>docker pull logstash:7.12.1</p>\n<p></p>\n<pre><code>mkdir /docker/logstash        --创建一个用于存储logstash配置以及插件的目录\nDocker run –p 9900:9900 –d –name logstash –v /docker/logstash:/etc/logstash/pipeline –privileged=true logstash:7.12.1</code></pre>\n<p>进入容器安装插件</p>\n<p>docker exec -it logstash bash</p>\n<p>cd bin目录</p>\n<p>logstash-plugin install logstash-input-jdbc</p>\n<p>logstash-plugin install logstash-output-elasticsearch</p>\n<p>下载与mysql对应的mysql-connector-java-5.1.49.jar</p>\n<p><a href=\"https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.24/mysql-connector-java-8.0.24.jar\" title=\"https://repo1.maven.org/maven2/mysql/mysql-connector-java\">https://repo1.maven.org/maven2/mysql/mysql-connector-java</a></p>\n<p>vi config/logstash.yml 更改logstash.yml文件</p>\n<p>内容如下: http.host: \"0.0.0.0\" xpack.monitoring.elasticsearch.hosts: [ \"<a href=\"http://172.17.0.7:9200\" title='http://172.17.0.7:9200\"'>http://172.17.0.7:9200\"</a> ]</p>\n<p>vi config/pipelines.yml 更改pipelines.yml文件</p>\n<p>- pipeline.id: main<br/>   path.config: \"/etc/logstash/pipeline/logstash.conf\"</p>\n<p>- pipeline.id: table2<br/>   path.config: \"/etc/logstash/pipeline/update.conf\"</p>\n<p>退出容器</p>\n<p>配置映射文件update.conf用于执行更改同步数据并新增updateposts.txt</p>\n<pre><code>input {\n    stdin { }\n    jdbc {\n        #mysql的jdbc连接方式以及mysql地址与端口和数据设置\n        jdbc_connection_string =&gt; \"jdbc:mysql://mysql ip地址:3306/库名\"\n        jdbc_user =&gt; \"账号\"\n        jdbc_password =&gt; \"密码\"\n        #mysql连接驱动的jar地址，这个地址需要写的是容器内部的地址\n        jdbc_driver_library =&gt; \"/etc/logstash/pipeline/mysql-connector-java-5.1.49.jar\"\n        jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\"\n        jdbc_paging_enabled =&gt; true\n        #每次同步的数量\n        jdbc_page_size =&gt; \"5000\"\n        statement =&gt; \"更新sql语句updatetime &gt; :sql_last_value\"\n        use_column_value =&gt; true\n        #是否将字段名转为小写，默认为true（如果具备序列化或者反序列化，建议设置为false）\n        lowercase_column_names =&gt; false\n        #需要记录的字段，同于增量同步，需要是数据库字段\n        tracking_column =&gt; updatetime\n        #记录字段的数据类型\n        tracking_column_type =&gt; numeric\n        #上次数据存放位置\n        record_last_run =&gt; true\n        #上一个sql_last_value的存放路径，必须在文件中指定字段的初始值\n        last_run_metadata_path =&gt; \"/etc/logstash/pipeline/updateposts.txt\"\n        #是否清除last_run_metadata_path的记录，需要增量同步这个字段的值必须为false\n        clean_run =&gt; false\n        #同步的频率（分 时 天 月 年）默认为每分钟同步一次\n        schedule =&gt; \"*/1 * * * * *\"\n        type =&gt; \"_doc\"\n        # schedule =&gt; \"*/5 * * * * *\"\n    }\n}\n\noutput {\n    elasticsearch {\n        hosts =&gt; \"esip:9400\"\n        index =&gt; \"posts\"\n        document_type =&gt; \"_doc\"\n        document_id =&gt; \"%{id}\"\n    }\n\n    stdout {\n        codec =&gt; json_lines\n    }\n}</code></pre>\n<p>配置映射文件logstash.conf用于执行新增同步数据并新增posts.txt</p>\n<pre><code>input {\n    stdin { }\n    jdbc {\n        #mysql的jdbc连接方式以及mysql地址与端口和数据设置\n        jdbc_connection_string =&gt; \"jdbc:mysql://mysqlip:3306/库名\"\n        jdbc_user =&gt; \"账号\"\n        jdbc_password =&gt; \"密码\"\n        #mysql连接驱动的jar地址，这个地址需要写的是容器内部的地址\n        jdbc_driver_library =&gt; \"/etc/logstash/pipeline/mysql-connector-java-5.1.49.jar\"\n        jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\"\n        jdbc_paging_enabled =&gt; true\n        #每次同步的数量\n        jdbc_page_size =&gt; \"5000\"\n//id &gt; :sql_last_value用于自动更新数据\n        statement =&gt; \"执行的sql语句 WHERE id &gt; :sql_last_value\"\n        use_column_value =&gt; true\n        #是否将字段名转为小写，默认为true（如果具备序列化或者反序列化，建议设置为false）\n        lowercase_column_names =&gt; false\n        #需要记录的字段，同于增量同步，需要是数据库字段\n        tracking_column =&gt; id\n        #记录字段的数据类型\n        tracking_column_type =&gt; numeric\n        #上次数据存放位置\n        record_last_run =&gt; true\n        #上一个sql_last_value的存放路径，必须在文件中指定字段的初始值\n        last_run_metadata_path =&gt; \"/etc/logstash/pipeline/posts.txt\"\n        #是否清除last_run_metadata_path的记录，需要增量同步这个字段的值必须为false\n        clean_run =&gt; false\n        #同步的频率（分 时 天 月 年）默认为每分钟同步一次\n        schedule =&gt; \"*/1 * * * * *\"\n        type =&gt; \"_doc\"\n        # schedule =&gt; \"*/5 * * * * *\"\n    }\n}\n\noutput {\n    elasticsearch {\n        hosts =&gt; \"esip:9400\"\n        index =&gt; \"posts\"\n        document_type =&gt; \"_doc\"\n        document_id =&gt; \"%{id}\"\n    }\n\n    stdout {\n        codec =&gt; json_lines\n    }\n}</code></pre>\n<h2> tp5 先引入扩展composer require elasticsearch/elasticsearch</h2>\n<h1></h1>\n<ol><li> <pre><code class=\"language-php\">&lt;?php\n\nnamespace app\\common\\library;\n\nuse Elasticsearch\\ClientBuilder;\nuse think\\Config;\nuse think\\Exception;\n/**\n * ES专用操作类\n */\nclass ElasticClient\n{\n    private $_host;\n    private $_client = null;\n    private $_index_prefix = '';\n    private $error = '';\n     public function __construct()\n    {\n        $this-&gt;setHost();\n        $this-&gt;_client = ClientBuilder::create()-&gt;setHosts($this-&gt;_host)-&gt;build();\n       \n    }\n    /**\n     * 设置配置\n     */\n    private function setHost()\n    {\n        //实例化一个客户端\n        $cfg = Config::get('eshosts');\n        $this-&gt;_host = [\n            $cfg['scheme'] . '://' . $cfg['user'] . ':' . $cfg['pass'] . '@' . $cfg['host'] . ':' . $cfg['port']\n        ];\n        \n    }\n    /*\n     * 返回结构体\n     */\n    public function getClient()\n    {\n        return $this-&gt;_client;\n    }\n    /**\n     * 删除文档(删除数据记录)\n     */\n    public function delDoc($index, $id)\n    {\n        $chk = $this-&gt;checkParams($index, $id, ['def_key' =&gt; 'only_for_delete_doc']); //参数3无实际意义,仅用过能通过验证而已\n        if ($chk === false) {\n            return false;\n        }\n        try {\n            $data = [\n                'index' =&gt; $index,\n                'id' =&gt; $id,\n                'type'=&gt;'_doc'\n            ];\n            $this-&gt;_client-&gt;delete($data);\n        } catch (Exception $e) {\n            $this-&gt;error = $e-&gt;getMessage();\n            return false;\n        }\n\n        return true;\n    }\n     /**\n     * 参数验证\n     */\n    private function checkParams($index, $id, $body)\n    {\n        $result = true;\n        foreach ($body as $key =&gt; $value) {\n            if (!isset($key) || empty($key)) {\n                $result = false;\n                break;\n            }\n        }\n        if ($result === false) {\n            $this-&gt;error = '索引文档的主体内容输入不正确';\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     *返回异常信息\n     */\n    public function getError()\n    {\n        return $this-&gt;error;\n    }\n\n}</code></pre> <p></p> </li><li> <pre><code class=\"language-php\">&lt;?php\n\nnamespace app\\common\\library;\n\n\n\n/**\n * ES专用操作类\n */\nclass ElasticSearch\n{\n\n    protected $params = [\n        'index' =&gt; 'posts',//索引\n        'type'  =&gt; '_doc',//类型\n        'body' =&gt; [\n            \"query\" =&gt; [\n                \"bool\" =&gt; [\n                    'filter' =&gt; [],\n                    'must'  =&gt; []\n                ]\n            ]\n        ]\n    ];\n    /**\n     * @param $index\n     * 通过构造函数进行索引初始化\n     */\n    public function __construct($index)\n    {\n        $this-&gt;params[\"index\"] = $index;\n        return $this;\n    }\n     /**\n     * @param $fields\n     * @return $this\n     * 过滤字段，查询我们需要的字段\n     */\n    public function source($fields)\n    {\n        $fields = is_array($fields)?$fields:[$fields];\n        $this-&gt;params[\"body\"][\"_source\"] = $fields;\n        return $this;\n    }\n\n\n    /**\n     * @param $size  数据量\n     * @param $page   索引起始\n     * @return $this\n     * 搜索分页构建\n     */\n    public function paginate($size,$page)\n    {\n        $this-&gt;params['body']['from'] = ($page - 1) * $size;\n        $this-&gt;params['body']['size'] = $size;\n        return $this;\n    }\n\n    /**\n     * @return $this\n     * 判断消息是否经过审核\n     */\n    public function IsStatus()\n    {\n        $this-&gt;params['body']['query']['bool']['filter'][] = ['term' =&gt; ['status' =&gt; true]];\n        return $this;\n    }\n    /**\n     * @return $this\n     * 选择城市数据\n     */\n    public function province($province)\n    {\n        $this-&gt;params['body']['query']['bool']['filter'][] = ['term' =&gt; ['province' =&gt; $province]];\n        return $this;\n    }\n     /**\n     * @return $this\n     * 过滤软删除的数据\n     */\n    public function Isnotnull()\n    {\n        $this-&gt;params['body']['query']['bool']['must_not'][] = ['exists' =&gt; ['field' =&gt; 'deletetime']];\n        return $this;\n    }\n    /**\n     * @return $this\n     * 判断消息是否屏蔽\n     */\n    public function Isshield($ids)\n    {\n        $this-&gt;params['body']['query']['bool']['must_not'][] = ['terms' =&gt; ['user_id' =&gt; $ids]];\n        return $this;\n    }\n    /**\n     * @return $this\n     * 屏蔽列表\n     */\n    public function shield($ids)\n    {\n        $this-&gt;params['body']['query']['bool']['must'][] = ['terms' =&gt; ['user_id' =&gt; $ids]];\n        return $this;\n    }\n    /**\n     * @return $this\n     * 点赞/收藏列表\n     */\n    public function getlists($ids)\n    {\n        $this-&gt;params['body']['query']['bool']['must'][] = ['terms' =&gt; ['id' =&gt; $ids]];\n        return $this;\n    }\n\n    /**\n     * @return $this\n     * 获取关注人的消息\n     */\n    public function follow($ids)\n    {\n        $this-&gt;params['body']['query']['bool']['filter'][] = ['terms' =&gt; ['user_id' =&gt; $ids]];\n        return $this;\n    }\n    /**\n     * @return $this\n     * 获取某圈子的帖子\n     */\n    public function circle($circle_id)\n    {\n        $this-&gt;params['body']['query']['bool']['filter'][] = ['term' =&gt; ['circle_id' =&gt; $circle_id]];\n        return $this;\n    }\n    /**\n     * @param ProductCategory $category 用户传递过来的分类对象或者id\n     * @return $this\n     * 分类筛选\n     */\n    public function category($category)\n    {\n\n        $this-&gt;params['body']['query']['bool']['filter'][] = ['term' =&gt; ['cat_id' =&gt; $category]];\n        return $this;\n    }\n      /**\n     * @return $this\n     * 我的发布筛选\n     */\n    public function myposts($user_id)\n    {\n\n        $this-&gt;params['body']['query']['bool']['filter'][] = ['term' =&gt; ['user_id' =&gt; $user_id]];\n        return $this;\n    }\n    /**\n     * @param $keywords 关键词数组\n     * @return $this\n     * 关键词按照权重进行搜索\n     */\n    public function keywords($keywords)\n    {\n        //如果不是数组需要转为数组\n        $keywords = is_array($keywords) ? $keywords : [$keywords];\n\n        foreach ($keywords as $keyword){\n            $this-&gt;params['body']['query']['bool']['must'][] = [\n                'multi_match' =&gt; [\n                    'query' =&gt; $keyword,\n                    'fields' =&gt; [\n                        'content^3',\n                    ]\n                ]\n            ];\n        }\n\n        return $this;\n    }\n\n    /*\n     * 排序\n     */\n    public function orderBy($filed,$lon,$lat)\n    {\n        if (!isset($this-&gt;params['body']['sort'])){\n            $this-&gt;params['body']['sort'] = [];\n        }\n        $this-&gt;params['body']['sort'][] = ['is_top' =&gt; 'desc','pinglun_num'=&gt;'desc'];\n        if($filed=='location'){\n            $this-&gt;params['body']['sort'][] = ['_geo_distance' =&gt;[$filed=&gt;['lat'=&gt;$lat,'lon'=&gt;$lon],'order'=&gt;'asc','unit'=&gt;'km']];\n        }elseif($filed=='createtime'){\n            $this-&gt;params['body']['sort'][] = [$filed =&gt; 'desc'];\n        }\n        \n        return $this;\n    }\n     /*\n     * 返回结构体\n     */\n    public function getParams()\n    {\n        return $this-&gt;params;\n    }\n    //查询\n    public function search()\n    {\n        $searchParams['index'] = 'posts';\n        $searchParams['type'] = '_doc';\n        $searchParams['from'] = 0;\n        $searchParams['size'] = 100;\n        $searchParams['body']['query']['match']['content'] = 'ces';\n        $retDoc = $this-&gt;_client-&gt;search($searchParams);\n        return $retDoc;\n    }\n\n    /**\n     *返回异常信息\n     */\n    public function getError()\n    {\n        return $this-&gt;error;\n    }\n}\n</code></pre> <p></p> </li><li> <pre><code class=\"language-php\">\n \n    /**控制器中使用     \n     * 帖子列表\n     */\n    public function posts_list()\n    {\n        $ElasticClient=new ElasticClient();\n        $page = $this-&gt;request-&gt;get('page',1);\n        $perPage = 10;\n        $builder = (new ElasticSearch(\"posts\"))-&gt;IsStatus()-&gt;Isnotnull()-&gt;Isshield($this-&gt;getshield($this-&gt;userinfo-&gt;id))-&gt;circle($this-&gt;request-&gt;get('circle'))-&gt;paginate($perPage,$page);\n        //分类搜索\n        if ($category=$this-&gt;request-&gt;get('category_id')){\n            $builder-&gt;category($category);\n        }\n        //城市选择搜搜\n        if ($province=$this-&gt;request-&gt;get('province')){\n            $builder-&gt;province($province);\n        }\n        //关键词搜索\n        if ($search = $this-&gt;request-&gt;get('search','')){\n            $keywords = array_filter(explode(' ',$search));\n            $builder-&gt;keywords($keywords);\n        }\n        //关注数据搜索\n        if ($follow= $this-&gt;request-&gt;get('follow')){\n            $builder-&gt;follow($this-&gt;getfollow($this-&gt;userinfo-&gt;id));\n        }\n        //最新、离我最近的数据搜索\n        if ($order = $this-&gt;request-&gt;get('order','pinglun_num')){\n                if (in_array($order,['createtime','location','is_top','pinglun_num'])){\n                    $builder-&gt;orderBy($order,$this-&gt;request-&gt;get('lon'),$this-&gt;request-&gt;get('lat'));\n                }\n        }\n        $data['list']=$ElasticClient-&gt;getClient()-&gt;search($builder-&gt;getParams())['hits']['hits'];\n        $data['followids']=$this-&gt;getfollow($this-&gt;userinfo-&gt;id);\n        $data['zanids']=\\app\\admin\\model\\posts\\Zan::where(['user_id'=&gt;$this-&gt;userinfo-&gt;id])-&gt;column('posts_id');\n        $data['collectionids']=\\app\\admin\\model\\posts\\Collection::where(['user_id'=&gt;$this-&gt;userinfo-&gt;id])-&gt;column('posts_id');\n        $this-&gt;success($data);\n    }\n    /**</code></pre> <p> </p> <pre><code>  //放在config文件中\n'eshosts'=&gt;[\n        'scheme'=&gt;'http',\n        'user'=&gt; '',\n        'pass'=&gt;'',\n        'host'=&gt;'',\n        'port'=&gt;''\n    ]</code></pre> <p></p> </li></ol>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 1, "time": "2022-05-21 11:09:38", "summary": "的安装安装创建目录创建文件配置文件：集群名称节点名称是不是有主节点资格是否存储数据是否允许跨域请求允许请求来自何处最大集群节点数数据和日志的存储目录设置绑定的，设置为以后就可以让任何计算机节点访问到了"}