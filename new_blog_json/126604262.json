{"blogid": "126604262", "writerAge": "码龄4年", "writerBlogNum": "774", "writerCollect": "60722", "writerComment": "36927", "writerFan": "104417", "writerGrade": "10级", "writerIntegral": "171968", "writerName": "兔老大RabbitMQ", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126604262.jpg", "writerRankTotal": "4", "writerRankWeekly": "136", "writerThumb": "88703", "writerVisitNum": "5001000", "blog_read_count": "14741", "blog_time": "已于 2022-09-01 11:02:34 修改", "blog_title": "兔老大的系统设计（二）定时系统（延时队列）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>之前文章：</p>\n<p><a class=\"link-info\" href=\"https://fantianzuo.blog.csdn.net/article/details/126389319\" title=\"兔老大的系统设计（一）健康度系统\">兔老大的系统设计（一）健康度系统</a></p>\n<h1>一、背景</h1>\n<p id=\"b604048736ebb8618cdcaf994627688c\">延迟队列的应用场景非常广泛，如客户主动操作：</p>\n<ul><li>股票定投</li><li>顾客预约场景</li><li>会员定时续费/缴费</li><li>CSDN定时发布</li></ul>\n<p><img alt=\"\" height=\"102\" src=\"..\\..\\static\\image\\3ac07bbc04ca4499a0a305a3d261fe6b.png\" width=\"359\"/></p>\n<p></p>\n<p>或系统内部操作：</p>\n<ul><li id=\"15d765913a045b8074a364220634e825\">订单成功后，在30分钟内没有支付，自动取消订单</li><li id=\"97551b0a841c11ee72bb7bd7f5f1c77e\">外卖平台发送订餐通知，下单成功后60s给用户推送短信。</li><li id=\"0f202a730bc9b3785521242250bd202d\">如果订单一直处于某一个未完结状态时，及时处理关单，并退还库存</li><li id=\"43f95a9d5366bd3e4080a4fc1e496fd1\">淘宝新建商户一个月内还没上传商品信息，将冻结商铺等</li></ul>\n<h1>二、需求分析</h1>\n<p>场景多种多样，我们尽量做出一个通用的，功能完备的，能满足大部分场景的系统。</p>\n<p>可以以顾客预约场景为例进行设计，假设会量大、量不稳定、存储时间长（比如几个月后执行），这样设计出来的系统就普遍适用。</p>\n<h1>三、目标明确</h1>\n<h2 style=\"margin-left:.0001pt;text-align:justify;\">3.1功能</h2>\n<p id=\"ec03619a76b990bcbc812a4d632cdf79\">延时队列相比于普通队列最大的区别就体现在其延迟的属性上.</p>\n<p>普通队列的元素是先进先出，按入队顺序进行处理，而延时队列中的元素在入队时会指定一个延迟时间，表示其希望能够在经过该指定时间后处理。</p>\n<p>从某种意义上来讲，延迟队列的结构并不像一个队列，而更像是一种以时间为权重的有序堆结构。</p>\n<p><strong>要实现的功能如下：</strong></p>\n<p>1）可以设置定时任务</p>\n<p>2）可以修改未到执行时间的任务属性（包括执行时间）</p>\n<p>3）可以查询任务情况，人工干预</p>\n<h2 style=\"margin-left:.0001pt;text-align:justify;\">3.2设计重点</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">大部分系统的重点一般在：<strong>性能、可用性、安全</strong>三方面。</p>\n<h2 style=\"margin-left:.0001pt;text-align:justify;\">3.2.1性能</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">及时：时间到了立刻执行，不能延迟太久。（如crontab分钟粒度就太粗了）</p>\n<h2 style=\"margin-left:.0001pt;text-align:justify;\">3.2.2可用</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可靠：保证任务不重不漏的执行，不能丢任务、不能重复执行</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">高可用可扩展：服务尽量不挂、可抗住突发的大量请求</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可恢复：系统挂了或者任务失败/丢失等等，可以恢复</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<h2 style=\"margin-left:.0001pt;text-align:justify;\">3.2.3其它</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可撤回/修改：如果定时任务还没到执行时间，可以修改执行时间和其他内容，也可取消。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">存时间长：有些场景甚至要保存一年以上，比如用户办理年卡后，要有一些策略诱导消费。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<h1>四、一些探索</h1>\n<p>本章不局限于实现所有的目标，提出一些业内常见的实现方案，供大家增长知识面，和最终方案可以有个对比。</p>\n<p><strong>请注意看每种方案下的分析</strong></p>\n<h2>4.0 数据库</h2>\n<p>在小型项目中，通过一个线程定时扫数据库，通过执行时间字段来判断是否到时，然后进行操作</p>\n<p>优点:简单，支持集群操作</p>\n<p>缺点:   (1)对服务器内存消耗大</p>\n<p>(2)存在延迟，执行时间粒度和mysql本身的速度都会影响</p>\n<p>(3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大</p>\n<h2>4.1 DelayQueue 延时队列</h2>\n<h3>4.1.1 介绍</h3>\n<p>JDK 中提供了一组实现延迟队列的 API，位于Java.util.concurrent包下的 DelayQueue。</p>\n<p>DelayQueue 是一个 BlockingQueue，本质就是封装了一个 PriorityQueue(优先队列)，内部用堆来实现队列元素排序，向 DelayQueue 队列中添加元素时，会给元素一个 Delay(延迟时间)作为排序条件，队列中最小的元素会优先放在队首。队列中的元素只有到了 Delay 时间才允许从队列中取出。</p>\n<h3>4.1.2简单实现</h3>\n<p>1）实现 Delayed 接口，接口里只有一个 getDelay 方法，用于设置延期时间。</p>\n<p>2）Order 类中compareTo()负责对队列中的元素进行排序。</p>\n<pre><code class=\"language-java\">public class Order implements Delayed {\n    //延迟时间\n    @JsonFormat(locale = \"zh\", timezone = \"GMT+8\", pattern = \"yyyy-MM-dd HH:mm:ss\")\n    private long time;\n    String name;\n\n    public Order(String name, long time, TimeUnit unit) {\n        this.name = name;\n        this.time = System.currentTimeMillis() + (time &gt; 0 ? unit.toMillis(time) : 0);\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return time - System.currentTimeMillis();\n    }\n    @Override\n    public int compareTo(Delayed o) {\n        Order Order = (Order) o;\n        long diff = this.time - Order.time;\n        if (diff &lt;= 0) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n}</code></pre>\n<p><br/> DelayQueue 的 put 方法是线程安全的，内部使用了ReentrantLock进行线程同步。</p>\n<p>上边只是简单的实现，实际开发中会有专门的线程负责消息的入队与消费。</p>\n<h3>4.1.3 分析</h3>\n<p><strong>分析：事实上，如无必要，我们应该尽可能使用语言自带的库，而非过度设计。从这方面考虑，DelayQueue无疑是一个简单优秀的实现，但是在大型项目中，本地存储的方案确实不太适用。</strong></p>\n<p><strong>无论如何，我们仍然可以对它大根堆和线程控制的方法进行学习和借鉴。</strong></p>\n<p></p>\n<h2>4.2 RabbitMQ</h2>\n<p id=\"d07795f86517fea7f8c8722a9396080b\">RabbitMQ 本身并不直接提供对延迟队列的支持，我们依靠 RabbitMQ 的<strong>TTL</strong>以及<strong>死信队列</strong>功能，来实现延迟队列的效果。那就让我们首先来了解一下，RabbitMQ 的死信队列以及 TTL 功能。</p>\n<h3>4.2.1死信队列</h3>\n<p id=\"ac766c0b38391d8c0b0451970880f47f\">死信队列实际上是一种 RabbitMQ 的消息处理机制，当 RabbmitMQ 在生产和消费消息的时候，消息遇到如下的情况，就会变成“死信”：</p>\n<ul><li id=\"8e380dc3d46ed4b4b457e508f5631cfc\">消息被拒绝并且不再重新投递</li><li id=\"0abe253686adec8c4bfcdd344188746d\">消息超时未消费，也就是 TTL 过期了</li><li id=\"cdf6449f24f04efa5eb4720c9e9a7580\">消息队列到达最大长度</li></ul>\n<p id=\"91f4b427de5fa9d0926761894de3d214\">消息一旦变成一条死信，便会被重新投递到死信交换机（Dead-Letter-Exchange），然后死信交换机根据绑定规则转发到对应的死信队列上，监听该队列就可以让消息被重新消费。</p>\n<h3>4.2.2消息生存时间 TTL</h3>\n<p id=\"d5a368db89118af92e83cee44a422d29\">TTL（Time-To-Live）表示了一条消息的最大生存时间，单位为毫秒。如果一条消息在 TTL 设置的时间内没有被消费，那么它就会变成一条死信，进入我们上面所说的死信队列。</p>\n<p id=\"37f4b6ebf2f9cbc63f0ede54f516ca39\">如何设置消息的 TTL 属性</p>\n<ul><li id=\"f281736ad7fdf1a7ee230b6c4cccd91d\">一种方式是直接在创建队列的时候设置整个队列的 TTL 过期时间，所有进入队列的消息，都被设置成了统一的过期时间，一旦消息过期，马上就会被丢弃，进入死信队列，在延迟队列的延迟时间为固定值的时候，比较适合使用这种方式：</li></ul>\n<pre><code class=\"language-cpp\">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();\nargs.put(\"x-message-ttl\", 6000);\nchannel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</code></pre>\n<p id=\"dcc164c5490f61d9fa71d8618e3ac4ca\"></p>\n<ul><li id=\"e1e20657ce31ba8302bcf8055e8ee218\">另一种方式是针对单条消息设置，参考代码如下，该消息被设置了 6 秒的过期时间：</li></ul>\n<pre><code class=\"language-cpp\">AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();\nbuilder.expiration(\"6000\");\nAMQP.BasicProperties properties = builder.build();\nchannel.basicPublish(exchangeName, routingKey, mandatory, properties, \"msg content\".getBytes());</code></pre>\n<h3 id=\"95c077c5fe0b11215d7e39f0651551cd\">4.2.3实现延迟队列</h3>\n<p id=\"60b440bf3e0f9b13fd5152efcb2c64ae\">我们利用死信队列的这个属性，把需要延迟的消息，将 TTL 设置为其延迟时间，投递到 RabbitMQ 的普通队列中，一直不去消费它，那么经过 TTL 的时间后，消息就会自动被投递到死信队列，这时候我们使用消费者进程实时地去消费死信队列中的消息，就实现了延迟队列的效果。</p>\n<p id=\"de6da9be73adefe8af22df8ca61eb5a3\">从下图可以直观的看出使用 RabbitMQ 实现延迟队列的整体流程：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/942256f591668282ff48c64deb17f210.webp?x-oss-process=image/format,png\"/></p>\n<p id=\"46ac8be27142fbe70d43eb886de897ba\">使用 RabbitMQ 来实现延迟队列，具有很明显的一些优势：比如消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延迟队列不可用或者消息丢失。</p>\n<h3>4.2.4存在的bug</h3>\n<p id=\"d742c8fe0a2cf4f78be2619a2849eeb6\">RabbitMQ 在检查消息是否过期时，只会检查第一个消息是否过期，并不会校验后面消息过期的情况比如第一个消息设置了 20s 的 TTL，第二个消息设置了 10s 的 TTL，那么 RabbitMQ 会等到第一个消息过期之后，才会让第二个消息过期。</p>\n<p id=\"28a60b7780e188b8874833d97ac42a1b\">解决这个问题的方法也很简单，只需要安装 RabbitMQ 的一个插件即可：</p>\n<p id=\"15509763558ba28577cfb53022474a61\"><a href=\"https://www.rabbitmq.com/community-plugins.html\" title=\"Community Plugins — RabbitMQ\">Community Plugins — RabbitMQ</a></p>\n<p id=\"3fba68844a5574111bcee3ae1ecea4f1\">安装好这个插件后，所有的消息就都能按照被设置的 TTL 过期了。</p>\n<h3> 4.2.5插件实现原理</h3>\n<p>上面使用 DLX + TTL 的模式，消息首先会路由到一个正常的队列，根据设置的 TTL 进入死信队列，与之不同的是通过 x-delayed-message 声明的交换机，它的消息在发布之后不会立即进入队列，先将消息保存至 Mnesia。</p>\n<p>这个插件将会尝试确认消息是否过期，首先要确保消息的延迟范围是 Delay &gt; 0, Delay =&lt;ERL_MAX_T（在 Erlang 中可以被设置的范围为 (2^32)-1 毫秒），如果消息过期通过 x-delayed-type 类型标记的交换机投递至目标队列，整个消息的投递过程也就完成了。</p>\n<h3>4.2.6 分析</h3>\n<p><strong>作为网上流传非常广的一种方案</strong>，它似乎真的是一种不错的实现。</p>\n<p>尤其是，由于 RabbitMQ 本身的消息可靠发送、消息可靠投递、死信队列等特性，可以保障消息至少被消费一次以及未被正确处理的消息不会被丢弃，让消息的可靠性有了保障。</p>\n<p>但是这方案有如下缺点：</p>\n<p>1、为了解决一个问题，又引入了队列交换机+mq+私信队列交换机+私信队列+插件，我们并不希望引入如此复杂不可控的架构。</p>\n<p>2、配置麻烦，额外增加死信交换机和死信队列等配置，不好维护</p>\n<p>3、不可靠，实际测试环境延时插件有时收不到消息，不是很稳定。配置错误、生产者消费者连接的队列错误和其他未知因素都有可能造成延迟失效。</p>\n<p>4、真实消费原因不唯一：消息被拒绝、消息过期、消息超长等等原因都会进入死信队列，这种不唯一也是我们无法忍受的。，我们无法知道死信队列中是否都是过期消息。</p>\n<p></p>\n<h2 id=\"UVdur\">4.3 kafka-TimeWheel</h2>\n<p id=\"c3f3257f8534d780a69391deb317c888\">TimeWheel 时间轮算法，是一种实现延迟队列的巧妙且高效的算法，被应用在 Netty，Zookeeper，Kafka 等各种框架中。</p>\n<p id=\"aaa9290dac7a27a294cd9c1dfad2371a\"></p>\n<h3 id=\"02daa135c41aac5e4ea74a9996d32cc1\">4.3.1时间轮</h3>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/589068043053547a2cae6a62ca11325f.webp?x-oss-process=image/format,png\"/></p>\n<p>如上图所示，时间轮是一个存储延迟消息的环形队列，其底层采用数组实现，可以高效循环遍历。这个环形队列中的每个元素对应一个延迟任务列表，这个列表是一个双向环形链表，链表中每一项都代表一个需要执行的延迟任务。时间轮会有表盘指针，表示时间轮当前所指时间，随着时间推移，该指针会不断前进，并处理对应位置上的延迟任务列表。</p>\n<h3>4.3.2添加延迟任务</h3>\n<p id=\"a67a06a1e44804b0b240be66f6d39cee\">由于时间轮的大小固定，并且时间轮中每个元素都是一个双向环形链表，我们可以在<code>O(1)</code> 的时间复杂度下向时间轮中添加延迟任务。</p>\n<p id=\"a343762e51bdcfb0c7a4ccdedb20f064\">如下图，例如我们有一个这样的时间轮，在表盘指针指向当前时间为 2 时，我们需要新添加一个延迟 3 秒的任务，我们可以快速计算出延迟任务在时间轮中所对应的位置为 5，并添加到位置 5 上任务列表尾部。</p>\n<p id=\"009e60008e213780c147764f73c903ce\"></p>\n<h3>4.3.3多层时间轮</h3>\n<p id=\"834de9a2317b561add910b8ed31a2cbb\">上面的时间轮的大小是固定的，只有 12 秒。如果此时我们有一个需要延迟 200 秒的任务，我们应该怎么处理呢？直接扩充整个时间轮的大小吗？这显然不可取，因为这样做的话我们就需要维护一个非常非常大的时间轮，内存是不可接受的，而且底层数组大了之后寻址效率也会降低，影响性能。</p>\n<p id=\"6d323bd8bb72f28eb0cd6a23cd1880ed\">为此，Kafka 引入了多层时间轮的概念。其实多层时间轮的概念和我们的机械表上时针、分针、秒针的概念非常类似，当仅使用秒针无法表示当前时间时，就使用分针结合秒针一起表示。同样的，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中，如下图所示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/3464d275c1c88af7c6caeacf70dbfe17.webp?x-oss-process=image/format,png\"/></p>\n<p id=\"8bfa674941a60a46df4411af3148efe2\">第一层时间轮整个时间轮所表示时间范围是 0-12 秒，第二层时间轮每格能表示的时间范围是整个第一层时间轮所表示的范围也就是 12 秒，所以整个第二层时间轮能表示的时间范围即 12*12=144 秒，依次类推第三层时间轮能表示的范围是 1728 秒，第四层为 20736 秒等等。</p>\n<p id=\"73e1d61c715842a1210b23fa18e532ac\">比如现在我们需要添加一个延时为 200 秒的延迟消息，我们发现其已经超过了第一层时间轮能表示的时间范围，我们就需要继续往上层时间轮看，将其添加在第二层时间轮 200/12 = 17 的位置，然后我们发现 17 也超过了第二次时间轮的表示范围，那么我们就需要继续往上层看，将其添加在第三层时间轮的 17/12 = 2 的位置。</p>\n<h3>4.3.4具体实现</h3>\n<p id=\"816413f5a59995ff27afc05bcb1004ea\">Kafka 中时间轮算法添加延迟任务以及推动时间轮滚动的核心流程如下，其中 Bucket 即时间轮中的延迟任务队列，并且 Kafka 引入的 DelayQueue 解决了多数 Bucket 为空导致的时间轮滚动效率低下的问题：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/620144082e3a681c08bcdf8c605e1239.webp?x-oss-process=image/format,png\"/></p>\n<p id=\"3495fa49837486a931184d1d14497e7c\">使用时间轮实现的延迟队列，能够支持大量任务的高效触发。并且在 Kafka 的时间轮算法的实现方案中，还引入了 DelayQueue，使用 DelayQueue 来推送时间轮滚动，而延迟任务的添加与删除操作都放在时间轮中，这样的设计大幅提升了整个延迟队列的执行效率。</p>\n<h3 id=\"72c3537f9dd33868ea71052c3ff953a0\">4.3.5 分析</h3>\n<p id=\"Vx1NW\">从复杂度上说：相比 DelayQueue ，时间轮在复杂度上有优势。DelayQueue 由于涉及到调整数据的位置，插入和移除复杂度是 O(lgn)，而时间轮在插入和移除的复杂度都是 O(1)。</p>\n<p>从实际上说：相比其它MQ，kafka在我的认知里是最优秀的，事实上在我的十万级压测中，它是唯一性能达标的MQ（有些MQ已经接近挂了它还很健康）。同时kafka也有一定的持久化方案。</p>\n<p>但是这种方案依旧有一些问题：</p>\n<p>1、正如我开头提到的，需求很可能是保存一个月甚至更长时间，超过了默认的log.retention.hours（168）的大小。</p>\n<p>2、我们希望执行时间视可修改的，但是kafka的消息一旦由生产者发送，则不可变。关于这方面讨论我贴了一个链接，感兴趣的可以看看。<a class=\"link-info has-card\" href=\"https://stackoverflow.com/questions/60046428/what-is-kafka-message-tweaking\" title=\"stackoverflow问题\"><span class=\"link-card-box\"><span class=\"link-title\">stackoverflow问题</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://stackoverflow.com/questions/60046428/what-is-kafka-message-tweaking</span></span></a></p>\n<blockquote>\n<p><strong>其实探索到想用众多MQ来实现延迟队列时，我越来越清晰的有一种感觉：非逼着众多MQ（比如kafka）做不擅长的事情本身就有问题，人家的定位就是消息队列，而不是替你保存动辄一个月才执行的消息然后精准执行。</strong></p>\n</blockquote>\n<h2>4.4 一些其他方案</h2>\n<p>这里我不准备继续分析所有方案的优缺点了，因为这是很无聊的（而且影响接下来方案叙述的节奏），如<strong>Quartz、ActiveMQ、RocketMQ、nsq、pulsar等等</strong>，原因无非是性能不达标、时间粒度不够、存储时间不够等等，在这里放一张MQ的对比图：（如果满足你的要求，当然也可以用）</p>\n<p><img alt=\"\" height=\"477\" src=\"..\\..\\static\\image\\f25379cdcbf04bde91d7ed2ce1fd4d17.png\" width=\"669\"/></p>\n<p></p>\n<h2> 4.5 Redis ZSet</h2>\n<blockquote>\n<p>基于4.3结尾的考虑，首先要有地方做持久化，redis作为nosql的老大，呼之欲出。</p>\n</blockquote>\n<h3>4.5.1过期回调</h3>\n<p>只是提一嘴，这种歪门邪道的实现就不要想了，事实上容易出大问题，有兴趣可以了解。</p>\n<h3>4.5.2 正解介绍</h3>\n<p id=\"6a80dcbc249232f2cbaeed794b081c1d\">Redis有一个有序集合的数据结构ZSet，ZSet中每个元素都有一个对应Score，ZSet 中所有元素是按照其 Score 进行排序的。我们利用它Score有序的属性，可以对入队的成员，按过期时间从小到大排列！</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\650e2d531c98301d344b91b451712409.png\"/></p>\n<p id=\"8f5bb59d36deed0ebab351fdb9650bc5\">那么我们可以通过以下这几个操作使用 Redis 的 ZSet 来实现一个延迟队列：</p>\n<ol><li id=\"7e9c2f65da49a1af3f4befd288df1d9b\">入队操作：我们将需要处理的任务，按其需要延迟处理时间作为 Score 加入到 ZSet 中。Redis 的 ZAdd 的时间复杂度是<code>O(logN)</code>，<code>N</code>是ZSet 中元素个数，因此我们能相对比较高效的进行入队操作。</li><li id=\"2ce6529a851dd793b5e3d1dcb0d65166\">起一个进程定时（比如每隔一秒）查询 ZSet 中 Score 最小的元素，查询结果有两种情况：</li></ol>\n<ul><li id=\"b8c50322e049ffd4a56c4f6a750a5fdb\">查询出的分数小于等于当前时间戳，说明到这个任务需要执行的时间了，则去异步处理该任务；</li><li id=\"5408bc2a717af1c618dc3fb393d5454d\">查询出的分数大于当前时间戳，说明 ZSet 中所有的任务都还没有到需要执行的时间，则休眠一秒后继续查询；</li></ul>\n<h3>4.5.3 分析</h3>\n<p id=\"bc0fd095b0d2b17283bc419da307c789\">从上述的讨论中我们可以看到，通过 Redis Zset 实现延迟队列是一种理解起来较为直观，可以快速落地的方案。并且我们可以依赖 Redis 自身的持久化来实现持久化，使用 Redis 集群来支持高并发和高可用，是一种不错的延迟队列的实现方案。</p>\n<p>但是redis同样有缺点（但是被解决了）：</p>\n<p>1、定位问题：和上文提到的众多mq一样，redis的定位并不是延迟队列。</p>\n<p>（经验告诉我们，如果硬要用与需求定位不符的东西，就是容易出问题）</p>\n<blockquote>\n<p>但是由于这种方式实在过于简单好用，在业界确实非常太有市场，我记得redis作者本人都曾经谈过这个问题，告诉大家最好不要把redis用作消息队列之类的，只不过貌似没人听。</p>\n</blockquote>\n<p>2、持久化不是百分百可靠：redis持久化两种方式我就不讲了，最高级的持久化配置就是每次操作都记录，但是由于性能问题，基本不可能这样配（事实上大公司有明确规定不能这样配）。</p>\n<p>3、 真实案例，如果qps过高，虽然redis扛得住（和kafka一样，真男人啊），但是我们的服务扛不住。</p>\n<p></p>\n<h1>五、方案</h1>\n<h2>5.1 思考</h2>\n<p>读者紧接着4.5.3的想法不要断，我们想用redis，但是有三个问题，如何解决呢？</p>\n<p>问题2：没的说，上mysql万事大吉。</p>\n<p>问题3：redis接MQ，完美解决问题，这不就是mq天天吹的其中一大作用吗。</p>\n<p>问题1：我们只是用来排个序，消息队列和持久化都不是redis做了，符合定位。</p>\n<h2>5.2 整体架构</h2>\n<p>基于这些考虑，最终我们的架构是这样的：</p>\n<p><img alt=\"\" height=\"466\" src=\"..\\..\\static\\image\\171da8c016e34bb38e72cf49d706ff22.png\" width=\"1123\"/></p>\n<p id=\"dcacebb0cc32099fa010169e81c49e84\">其他服务想使用定时功能，调用写接口，核心线路有两条：</p>\n<p>第一条：</p>\n<p>1）将延迟的消息任务通过 hash 算法路由至不同的 Redis Key 上</p>\n<p>2）每个 Redis Key 都对应建立一个处理进程，称为 Event ，轮询，查询是否有待处理的延迟消息</p>\n<p>3） Event 进程不负责业务，基本只负责分发消息，具体的业务逻辑通过kafka解耦，消费者实现。</p>\n<p>4）我们规定消费者一定要上报执行结果，以便我们决定是否重复请求</p>\n<p>第二条：</p>\n<p>1）将消息写入DB（或更改）</p>\n<p>2）event进程扫过期一段时间的任务（可配置）</p>\n<p>3）主动请求消费者执行</p>\n<h2>5.3 细节补充</h2>\n<p>1）mysql</p>\n<p>表结构</p>\n<p>2）redis</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如觉得写mysql这条链路也太麻烦，并且没有存储很久的需求，可以用<strong>redis自身的持久化功能</strong>，同时开启RDB和AOF，AOF设置everysec，即每秒异步刷盘一次。极端情况下，可能会丢失一秒的数据。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong>高可用</strong>使用的是redis的主从复制模式。服务高可用方面，在实现过程中考虑了服务节点的横向扩展，Timer、Cleaner等对同一个redis队列的操作都加了分布式锁。每个服务节点都是无状态的，不需要进行元数据同步等操作，少数服务节点宕机不影响整个服务的可用性。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong>3）监控</strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">对于消息堆积，以及消息超过重试次数被丢弃等场景，说明消费端服务异常，没有正常消费及ack，需要及时上报并通知给业务方及服务提供方，方便快速发现并排查问题。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">4）mq</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">mq的选择上文有对比图，详细分析以后补充吧。</p>\n<h1>六、总结和QA</h1>\n<h2>分析架构</h2>\n<p>可能很多人会有些疑惑：你抛出来看起来这么复杂的图，实现起来是不是很麻烦？它真的很好用吗？</p>\n<p>下面首先回忆第三章，看是否实现目标。</p>\n<p><strong>从性能出发，整条链路看：</strong></p>\n<p>1）redis key可以增加，不用担心量大影响性能</p>\n<p>2）event定时任务每秒轮询，基本没延迟</p>\n<p>3）event没业务逻辑，校验+转发个消息很快</p>\n<p>3）消息队列选用的性能最强的kafka</p>\n<p>实际测试也符合要求</p>\n<p><strong>从可用出发，整条链路看：</strong></p>\n<p>1）将延迟的消息任务通过 hash 算法路由至不同的 Redis Key 上，这样做有两大好处：</p>\n<ul><li>避免了当一个 KEY 在存储了较多的延时消息后，入队操作以及查询操作速度变慢的问题（两个操作的时间复杂度均为<code>O(logN)</code>）。</li><li>系统具有了更好的横向可扩展性，当数据量激增时，我们可以通过增加Redis Key 的数量来快速的扩展整个系统。</li></ul>\n<blockquote>\n<p>但是会存在一个问题，因为增加key的数量，必然涉及到hash算法范围的调整，那么原先集合中的元素就不能通过新的hash算法路由到，所以需要采用一致性hash算法。</p>\n</blockquote>\n<p>2）所有的 Event 进程只负责分发消息，具体的业务逻辑通过MQ解耦，由消费者异步处理，这么做的好处也是显而易见的：</p>\n<ul><li>Event 进程只负责分发消息，那么其处理消息的速度就会非常快，就不太会出现因为业务逻辑复杂而导致消息堆积的情况。</li><li>采用一个额外的消息队列后，消息处理的可扩展性也会更好，我们可以通过增加消费者进程数量来扩展整个系统的消息处理能力。</li><li>Event 是多机多进程模型，保证整个系统的高可用性。采用 Zookeeper 选主的方式，保证同一时间只会有一个进程去处理消息，一旦 Zookeeper 的 leader 主机宕机，会自动选择新的 leader 来处理。</li></ul>\n<p><strong>从其他功能看：</strong></p>\n<p>要求可恢复、可撤回、可修改、保存时间超长。</p>\n<p>我们用mysql解决了大部分问题，修改时，记得把redis也改了（这也是比用kafka好的点，可修改）</p>\n<h2>到底如何设计？</h2>\n<p>这是本人一点粗浅的理解</p>\n<p>回看我们的方案，第一，无论是基于死信队列还是数据先存储（mysql/redis）后投递（kafka），亦或是redis超时时间，本质上都是将延迟待发送的消息数据与正常订阅的队列分开存储，这么做<strong>一方面降低耦合度，另一方面也是为了降低数据不可控的时间。</strong></p>\n<blockquote>\n<p>这也是我想说的，经验告诉我们，大量数据存在不可操作、不可见的地方是一件很糟糕的事（本文提的很多方案有这个毛病），服务不是写完就完了，还要维护，所以我们尽量不要这么做。</p>\n</blockquote>\n<p>第二，<strong>既然选择了数据分离，整条链路的存储组件和队列组件的选择，按需选择</strong>，十分重要。</p>\n<p>本方案就是mysql/redis+kafka</p>\n<p>第三、无论是检查队头消息TTL还是调度存储的数据，本质上都是通过定时任务来完成的，<strong>定时任务的触发策略</strong>也是决定你方案优劣的决定性因素：你是crontab配置，还是主备选举策略、还是大家一起抢分布式锁，也值得根据具体情况具体分析</p>\n<p></p>\n<h2>还是觉得太复杂，能否简化一点？</h2>\n<p>可以，我的建议是，如果qps不高的话，去掉kafka会是一个简单方案。</p>\n<p></p>\n<h2>多线程如何处理？</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如果你指的是，高并发场景下存在同一条消息被多次消费的情况，你可以使用分布式锁，如zookpeer、redis的红锁、自己做一个等等。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">本方案目前不存在这类问题</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-09-01 11:02:34", "summary": "之前文章：兔老大的系统设计一健康度系统兔老大的系统设计一健康度系统一、背景延迟队列的应用场景非常广泛，如客户主动操作：股票定投顾客预约场景会员定时续费缴费定时发布或系统内部操作：订单成功后，在分钟内没"}