{"blogid": "125260092", "writerAge": "码龄2年", "writerBlogNum": "106", "writerCollect": "110", "writerComment": "7", "writerFan": "20", "writerGrade": "4级", "writerIntegral": "1094", "writerName": "茂桑", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125260092.jpg", "writerRankTotal": "19140", "writerRankWeekly": "31496", "writerThumb": "26", "writerVisitNum": "35655", "blog_read_count": "4300", "blog_time": "已于 2022-06-13 16:22:31 修改", "blog_title": "Spring的7种事务传播机制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>前言</h2>\n<p><strong>什么是事务？</strong><br/> <strong>事务就是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。对数据库的增删改查操作</strong></p>\n<p><strong>传播机制是什么？</strong><br/> 当A调用B的时候，两个事务是怎么运行的？A出现异常，或者B出现异常，A回不回滚，B回不回滚？还是A回滚，B不回滚？这些问题</p>\n<p><strong>事务 以非事务性方式运行是什么意思？</strong><br/> 非事务的方式运行，其实<strong>就是设置为自动提交</strong>了，如果一个方法中有多个操作，则每个操作都会在不同事务中完成，不会保证他们的原子性。</p>\n<p><strong>事务挂起是什么意思？</strong><br/> 在方法A开始运行时，系统为它建立Transaction（“全赞可凶弄”）,方法A中对于数据库的处理操作，会在该Transaction的控制之下。<br/> 这时，方法A调用方法B,方法A打开的 Transaction将挂起，方法B中任何数据库操作，都不在该Transaction的管理之下。<br/> 当方法B返回，方法A继续运行，之前的Transaction回复，后面的数据库操作继续在该Transaction的控制之下 提交或回滚。</p>\n<p><strong>怎么使用？</strong><br/> 在方法上使用@Transactional（事务，“全赞可凶弄”）注解，后面设置参数<br/> 这些传播机制都是修饰被调用者的，也就是这里的B</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Transactional</span><span class=\"token punctuation\">(</span>propagation<span class=\"token operator\">=</span><span class=\"token class-name\">Propagation</span><span class=\"token punctuation\">.</span>REQUIRES_NEW<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">updateAcct</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TradeData</span> trade<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"7_23\"></a>7种事务传播机制：</h2>\n<p>以下事务传播机制都用这个例子解释：有A方法，B方法两个方法，A调用B<br/> （如果A、B中都没有事务，那就不存在什么事务传播机制了，所以其中一个或都有事务才讨论事务传播机制）</p>\n<blockquote>\n<p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p>\n</blockquote>\n<p><strong>REQUIRED(Spring默认的事务传播类型 required：需要、依赖、依靠)</strong>：如果当前没有事务，则自己新建一个事务，如果当前存在事务则加入这个事务<br/> 当A调用B的时候：如果A中没有事务，B中有事务，那么B会新建一个事务；如果A中也有事务、B中也有事务，那么B会加入到A中去，变成一个事务，这时，要么都成功，要么都失败。（假如A中有2个SQL，B中有两个SQL，那么这四个SQL会变成一个SQL，要么都成功，要么都失败）</p>\n<p><strong>SUPPORTS（supports：支持;拥护）</strong>:当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行<br/> 如果A中有事务，则B方法的事务加入A事务中，成为一个事务（一起成功，一起失败），如果A中没有事务，那么B就以非事务方式运行（执行完直接提交）；</p>\n<p><strong>MANDATORY（mandatory：强制性的）</strong>:当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。<br/> 如果A中有事务，则B方法的事务加入A事务中，成为一个事务（一起成功，一起失败）；如果A中没有事务，B中有事务，那么B就直接抛异常了，意思是B必须要支持回滚的事务中运行</p>\n<p><strong>REQUIRES_NEW（requires_new：需要新建）</strong>:创建一个新事务，如果存在当前事务，则挂起该事务。<br/> B会新建一个事务，A和B事务互不干扰，他们出现问题回滚的时候，也都只回滚自己的事务；</p>\n<p><strong>NOT_SUPPORTED（not supported：不支持）</strong>:以非事务方式执行,如果当前存在事务，则挂起当前事务<br/> 被调用者B会以非事务方式运行（直接提交），如果当前有事务，也就是A中有事务，A会被挂起（不执行，等待B执行完，返回）；A和B出现异常需要回滚，互不影响</p>\n<p><strong>NEVER（never：从不）</strong>: 如果当前没有事务存在，就以非事务方式执行；如果有，就抛出异常。就是B从不以事务方式运行<br/> A中不能有事务，如果没有，B就以非事务方式执行，如果A存在事务，那么直接抛异常</p>\n<p><strong>NESTED（nested：嵌套的）嵌套事务</strong>:如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样(开启一个事务)<br/> 如果A中没有事务，那么B创建一个事务执行，如果A中也有事务，那么B会会把事务嵌套在里面。</p>\n<p>什么叫嵌套呢？<br/> A是父事务，B是子事务</p>\n<blockquote>\n<p>NESTED嵌套事务 和REQUIRES_NEW的区别<br/> REQUIRES_NEw是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我们把当前事务称之为父事务）会开启一个<strong>嵌套事务</strong>（称之为一个子事务)。在NESTED情况下<strong>父事务回滚时，子事务也会回滚</strong>，而在REQUIRES_NEw情况下，原有事务回滚，不会影响新开启的事务。<br/> 和REQUIRED的区别<br/> REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚而<strong>在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响</strong></p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-06-13 16:22:31", "summary": "前言什么是事务？事务就是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。对数据库的增删改查操作传播机制是什么？当调用的时候，"}