{"blogid": "123557666", "writerAge": "码龄3年", "writerBlogNum": "32", "writerCollect": "223", "writerComment": "48", "writerFan": "19", "writerGrade": "3级", "writerIntegral": "504", "writerName": "猫四爷", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123557666.jpg", "writerRankTotal": "31217", "writerRankWeekly": "160295", "writerThumb": "91", "writerVisitNum": "26524", "blog_read_count": "5239", "blog_time": "已于 2022-08-16 15:02:35 修改", "blog_title": "Vue-cli(vue脚手架)上万字总结，超详细教程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"1Vue_0\"></a>1、创建Vue脚手架</h1>\n<h3><a id=\"11Vue_1\"></a>1.1、首先系统需要全局安装Vue脚手架</h3>\n<blockquote>\n<p>npm install -g @vue/cli</p>\n</blockquote>\n<h3><a id=\"12Vue_5\"></a>1.2、创建Vue脚手架工程</h3>\n<p>进入你想创建vue脚手架的目录，然后输入命令</p>\n<blockquote>\n<p>vue create xxx项目名</p>\n</blockquote>\n<p>需要注意的是工程名字不能大写，这里我们选择选择Vue2，敲下回车，那么vue将会为我们创建vue脚手架<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9e8c026c29da4b0bb9d12a8e86e6c16d.png\"/><br/> 显示如图所示说明创建成功<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f59dfd9fda774dd3ae347b4ce1acffd8.png\"/><br/> 如图命令所示 我们进入myvue工程，执行命令<br/> npm run serve<br/> 然后浏览器访问http://localhost:8080/<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\aec2ab1515644c14a1ab8d61375de6ad.png\"/><br/> 到这里 我们的vue脚手架工程就跑起来了，关闭为Ctrl+C</p>\n<h1><a id=\"2Vue_19\"></a>2、Vue脚手架的文件结构说明</h1>\n<pre><code>├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n</code></pre>\n<h1><a id=\"3_40\"></a>3、修改默认配置</h1>\n<p>Vue-cli官网配置参考:https://cli.vuejs.org/zh/config/#publicpath</p>\n<p>在工程根目录下创建文件vue.config.js</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\67f12709a21545518eab81e33720e9b8.png\"/><br/> <strong>这里我们演示配置一下语法检查</strong></p>\n<h3><a id=\"31_47\"></a>3.1、配置前</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e063c50aa8c24ee887af445f0fe4e43b.png\"/><br/> 会发现，默认语法检查是开启的，然后我们写了一个function没有被使用的话就会导致整个项目启动不了，所以在实际开发中，会带来很多障碍，所以我们将它关闭。</p>\n<h3><a id=\"32_51\"></a>3.2、配置后</h3>\n<p>在vue.config.js中，加入以下代码<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5e5ed5d803d1471db0568826a5177233.png\"/><br/> 这时发现，默认配置已被修改，项目正常启动。<br/> 后序我们修改默认都可以结合官网的文档在该文件夹中配置</p>\n<h1><a id=\"4_ref_57\"></a>4、标签的 ref属性</h1>\n<p>因为在Vue里使用原生js拿去Dom元素不太好，所以就有了ref属性</p>\n<h3><a id=\"41ref_59\"></a>4.1、ref属性的作用</h3>\n<p>1、被用来给元素或子组件注册引用信息(id的替代者)<br/> 2.应用在html标签上获取的是真是Dmo元素，应用在组件标签上的是组件实例对象(vc)<br/> 3.使用方法:</p>\n<pre><code> &lt;h1 ref=\"xxx\"&gt;......&lt;/h1&gt; 或&lt;组件ref=\"xxx\"&gt;&lt;/组件&gt;\n 获取:this.$refs.xxx\n</code></pre>\n<p>作用就相当于给一个表情加了个id=“xxx” 然后通过document.getElementById(“xxx”)的效果一样。</p>\n<h3><a id=\"42_71\"></a>4.2、示范</h3>\n<p>编写一个School.vue组件，然后在App.vue中引入<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\00bc7b57dcd04dce80e7b187e773ac3c.png\"/><br/> 我们访问网页 会发现，拿得到Dom元素，测试成功!<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\288b95edaa5141e5b547f9293fcc2964.png\"/></p>\n<h1><a id=\"5props_77\"></a>5、props配置</h1>\n<h3><a id=\"51_78\"></a>5.1、功能</h3>\n<p>让组件接收外部传递过来的数据,从而达到组件复用的目的<br/> <strong>(1).传递数据</strong></p>\n<pre><code class=\"prism language-bash\"><span class=\"token operator\">&lt;</span>Demo <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"xxx\"</span>/<span class=\"token operator\">&gt;</span>\n</code></pre>\n<p><strong>(2).接收数据</strong></p>\n<p>第一种方式(只接收):</p>\n<pre><code class=\"prism language-bash\">props:<span class=\"token punctuation\">[</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9cab15b9d12c4ee4937265273087b738.png\"/><br/> 会发现以上会出现一个问题，如果我们需要传递18而显示19的话，那就需要做一下调整，因为默认传递过去的是一个字符串类型的数据，所以会造成字符串的拼接，所以我们得在传递的属性上面加 : 或者 v-bind ，他就会将表达式中的值正真的传递过去而不是以字符串的形式。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\452997ec5d2749e3b09f205e409bef4a.png\"/><br/> 第二种方式(限制类型):</p>\n<pre><code class=\"prism language-bash\">props<span class=\"token punctuation\">{<!-- --></span>\n\tname:String\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1294b5c43f28442194567b0ad81a483f.png\"/><br/> 会发现传递字符串的话就会报错，一样通过：或者v-bind解决<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f6212acdae2044ce934b908f094dfb21.png\"/></p>\n<p>第三种方式(限制类型、限制必要性、指定默认值)<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\93b6d29d2a1c4db3b772317e186f9042.png\"/></p>\n<pre><code class=\"prism language-bash\">props:<span class=\"token punctuation\">{<!-- --></span>\n\tname:<span class=\"token punctuation\">{<!-- --></span>\n    \t   type:String, //类型\n    \t   required:true, //是否必传\n    \t   default:<span class=\"token string\">'老王'</span>//默认值\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>备注：props是只读的，不能修改,Vue底层会检测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。<br/> 如图所示:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ef22f82faeb94147856f0be22600e6fb.png\"/></p>\n<h1><a id=\"6mixin_122\"></a>6、mixin混入</h1>\n<h3><a id=\"61_123\"></a>6.1、功能</h3>\n<p><strong>（1）示范准备</strong></p>\n<p>可以看到School和Student组件中有相同的方法<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d914d40058c249bb862c492a8f08d4c7.png\"/><br/> 我们可以将其抽取出来达到复用的效果。</p>\n<p><strong>(2)创建一个js文件将相同的代码抽取出来，然后在Student和School组件中分别导入。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cdf456795e8f4f8c9f97b872319868e8.png\"/><br/> <strong>(3) 测试</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6b3856049c974159af3e5e3973518a45.png\"/><br/> 会发现 抽取出来的方法生效了！！！</p>\n<h3><a id=\"62_137\"></a>6.2、补充</h3>\n<p>不光上面演示的代码能在写在混合中，Vue中的声明的东西也都可以写在混合中，比如mounted、create，也包括自己定义的一些属性等方法等…混合中的数据最终都会和组件中的数据作一个整合</p>\n<p><strong>(1)、示范</strong></p>\n<p>一、我们在混合中加入mounted代码块<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\44357f0ff2ec4cdb8f735a560e147fb2.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d1743accaaf54dd9bb17604dd9b850eb.png\"/><br/> 二、我们在混合文件中加入一些属性。<br/> 这里我们重新暴露一个代码块，然后代码块中声明name数据，然后School和Student中导入<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7a2e95d4f4784a9391cc8d56eeebff1e.png\"/><br/> 测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ec398d6a47bd40dcb6f525ddf41b993e.png\"/><br/> 会发现使用name值成功了。注意：从示例中我们可以看到，如果混合和组件中有相同的组件和方法，会以组件中的为准。但是如果是mounted钩子函数，那么都要。并且混合中的钩子函数中的内容会先被执行。</p>\n<p>mounted钩子函数测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cf3d7d5327254d52bc62d1d6e9a59316.png\"/><br/> 两个组件都引入，会发现混合中的钩子函数内容会先被执行<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\435ab1c35d3a4f22a635ff1a0176f85f.png\"/></p>\n<h3><a id=\"63_158\"></a>6.3、全局混入</h3>\n<p>上面那些都属于局部混入，导入某个组件内仅供该组件使用。这里介绍全局混入，导入一次可在所有组件中使用混入文件。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\13b4fbc68c394dd89449c8794d5d7e8f.png\"/></p>\n<h3><a id=\"64_161\"></a>6.4、总结</h3>\n<p>功能:可以吧多个组件的共同配置提取成一个混入对象<br/> 使用方式:</p>\n<pre><code class=\"prism language-bash\">第一步定义混合,例如:\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t  <span class=\"token function-name function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">}</span>,\n\t  methods:<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n第二部使用混入，例如:\n    <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>.全局混入：Vue.minxin<span class=\"token punctuation\">(</span>xxx<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>.局部混入:mixins:<span class=\"token punctuation\">[</span>xxx<span class=\"token punctuation\">]</span>\n</code></pre>\n<h1><a id=\"7_178\"></a>7、插件</h1>\n<h3><a id=\"71_179\"></a>7.1、功能</h3>\n<p>功能:用于增强Vue<br/> 本质：包含install方法的一个对象，install的第一个参数就是Vue，第二个以后的参数是插件使用者传递的数据。<br/> 定义插件：</p>\n<pre><code class=\"prism language-bash\">\t对象.install<span class=\"token operator\">=</span>function<span class=\"token punctuation\">(</span>Vue,options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t\t\n\t\t//1.添加全局过滤器\n\t\tVue.filter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">)</span>\n\t\t\n\t\t//2.添加全局指令\n\t\tVue.directive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">)</span>\n\t\t\n\t\t//3.配置全局混入\n\t\tVue.minxin<span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">)</span>\n\n\t\t//4.添加实例方法\n\t\tVue.prototype.xxx<span class=\"token operator\">=</span><span class=\"token function-name function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t\t  <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>.\n\t\t<span class=\"token punctuation\">}</span>\n\t\tVue.prototype.xxx<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">{<!-- --></span>\n\t\t <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>1、示范</strong></p>\n<p>先创建一个plugins.js文件，然后在文件中install方法中声明一些全局混入 或者方法等…<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e2d1f9326bc340ecb21db7a8666cc5c1.png\"/><br/> <strong>2、导入并且使用插件</strong><br/> 在main.js 中导入并且在School组件中使用插件中定义的各种混入，方法，过滤器等…<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0e32e24961d544229398b97314c72a02.png\"/><br/> <strong>3、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\75a422c7b0124bc59c70bb282902aa97.png\"/><br/> <strong>4、补充</strong></p>\n<p>在使用插件的时候 还可以传递参数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\31a45fb324974221b98bd3c69d99c597.png\"/></p>\n<h1><a id=\"8scoped_220\"></a>8、scoped样式</h1>\n<p><strong>8.1、功能</strong><br/> 作用:让样式在局部生效<br/> 写法：在style标签上加上scoped即可</p>\n<pre><code class=\"prism language-bash\"><span class=\"token operator\">&lt;</span>style scoped<span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>/style<span class=\"token operator\">&gt;</span>\n</code></pre>\n<p><strong>示范</strong><br/> 在两个组件中都使用相同的样式<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e9351a0f9f524e9f810be4892a56b15f.png\"/><br/> 会发现样式会有冲突，所以我们在标签上加上 scoped<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\867285fd53b5456fbc15bb84253fcb3f.png\"/><br/> 会发现，成功啦！！！</p>\n<h1><a id=\"9_236\"></a>9、组件的自定义事件</h1>\n<h3><a id=\"91props__237\"></a>9.1、props传递 方法</h3>\n<p>通过前面的知识我们可以知道，父组件在向子组件传递数据的时候可以在使用子组件时传递参数然后子组件中通过props属性接收参数，其实不光可以接受传递过来的属性，然后也可以接收传递过来的方法。然后子组件中调用方法，通过参数列表像父组件的方法中传递数据。</p>\n<p><strong>示范</strong></p>\n<p>需求：子组件中的数据传递到父组件中然后显示</p>\n<p><strong>(1)、准备一个student组件，然后父组件传递方法，子组件接收传递过来的方法</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a8260d26dac84cadba4d4c2fd61ffe53.png\"/><br/> 在子组件中调用父组件中的方法，则会回调父组件中传递的那个方法，参数则为子组件中传递的参数，那么父组件中就拿到子组件中传递过来的数据了。<br/> <strong>(2)、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\550e18cbd90e4df8a5c7a1255aa0d950.png\"/><br/> 测试成功!!!</p>\n<h3><a id=\"92_251\"></a>9.2、自定义事件(写法一)</h3>\n<p>上面的例子是通过props属性的方式实现的，我们还可以通过自定义事件的方式实现子组件 像父组件传递数据</p>\n<p><strong>示范</strong></p>\n<p><strong>(1)、同样准备一个Student组件，然后在父组件中为子组件绑定事件和回调函数，然后在子组件触发父组件绑定的事件</strong></p>\n<pre><code class=\"prism language-bash\">触发事件用this.<span class=\"token variable\">$emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx'</span>,参数1,参数2<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\eec34f259527425786bfe6d99a4fdbb0.png\"/><br/> 当然，参数想传递多少都是可以的。</p>\n<p><strong>(2)、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c4f0bd9927f643b694467ce8d351ea53.png\"/><br/> 哈哈，成功啦！！！</p>\n<h3><a id=\"93_268\"></a>9.3、自定义事件(写法二)</h3>\n<p><strong>(1)、我们还可以通过ref的方式给指定的组件绑定事件</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d020aa539dfb478989db0f1c7ba967c4.png\"/><br/> <strong>(2)、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5e5ab39a94714d7f90390e1025224d1c.png\"/><br/> 成功啦！！！咋样，是不是很简单呢。</p>\n<p><strong>(3)、补充</strong><br/> 既然能给组件绑定自定义事件，那么我们也可以解绑自定义事件，记住，给哪个组件绑定的事件就找那个组件触发去，同样，给哪个组件绑定的事件，就找哪个组件解绑</p>\n<pre><code class=\"prism language-bash\">解绑指定的事件:this.<span class=\"token variable\">$off</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxxxxx'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n解绑多个事件:this.<span class=\"token variable\">$off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'xxx'</span>,<span class=\"token string\">'xxx'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n如果解绑所有事件，直接用: this.<span class=\"token variable\">$off</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7226700e20b54e00865c2cd63ca1e53f.png\"/><br/> 解绑之后，那么这个事件就无法被触发了。</p>\n<h3><a id=\"94_288\"></a>9.4、总结</h3>\n<blockquote>\n<p>组件的自定义事件</p>\n</blockquote>\n<p>1、是一种组件间的通信方式，适用于子组件===&gt;父组件<br/> 2、使用场景: A是父组件，B是子组件，B想给A传递数据，那么就要在A中给B绑定自定义事件和回调函数(回调函数在A中,参数则为B传递过来的)<br/> 3、绑定自定义事件：</p>\n<ol><li>第一种，在父组件中</li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token operator\">&lt;</span>Demo @zidingyi<span class=\"token operator\">=</span><span class=\"token string\">\"test\"</span>/<span class=\"token operator\">&gt;</span>\n或\n<span class=\"token operator\">&lt;</span>Demo v-on:zidingyi<span class=\"token operator\">=</span><span class=\"token string\">\"test\"</span>/<span class=\"token operator\">&gt;</span>\n</code></pre>\n<ol start=\"2\"><li>第二种，在父组件中</li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token operator\">&lt;</span>Demo <span class=\"token assign-left variable\">ref</span><span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span>/<span class=\"token operator\">&gt;</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n<span class=\"token function-name function\">mounted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\tthis.<span class=\"token variable\">$refs</span>.demo.<span class=\"token variable\">$on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zidingyi'</span>,this.test<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre><code>         3.若想让事件只出发一次,可以使用**once**修饰符，或**$once**方法。\n</code></pre>\n<ol start=\"4\"><li>触发自定义事件：</li></ol>\n<pre><code class=\"prism language-bash\">在子组件中\nthis.<span class=\"token variable\">$emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zidingyi'</span>,参数1，参数二<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">)</span>\n</code></pre>\n<ol start=\"5\"><li>解绑自定义事件</li></ol>\n<pre><code class=\"prism language-bash\">this.<span class=\"token variable\">$off</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zidingyi'</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<ol start=\"6\"><li>组件也可以绑定原生DOM事件，需要使用native修饰符。<br/> 比如:</li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token operator\">&lt;</span>Demo @click.native<span class=\"token operator\">=</span><span class=\"token string\">\"xxxx\"</span>/<span class=\"token operator\">&gt;</span>\n</code></pre>\n<h1><a id=\"10_331\"></a>10、全局事件总线</h1>\n<h3><a id=\"101_332\"></a>10.1、功能</h3>\n<p>从上面props和自定义事件例子中可以看到，他们适用于父组件与子组件或者子组件与父组件中的数据传递进行通信，那么如何实现任意两个组件中的通讯呢?</p>\n<p>我们可以使用全局事件总线，全局事件总线并不是一个新的技术或者API，只是编码的经验而已。</p>\n<p><strong>(1)、首先得先有一个存放数据的地方，并且这个存放的地方必须是所有组件都能看到的。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\74cf308a383d4e719af1a25e3c03ea45.png\"/><br/> 通过图中我们可以看到，若所有的vc要拿数据 x (this.xxx)，如果x在vc中找不到，那么就会去找VueComponent的原型对象中找，但是每一个组件都会有一个新的VueComponent，所以数据是不共享的，所以不能存在这里，那么就继续往上找到Vue，Vue的原型对象是所有的组件vm或vc都能看到的，所以存在Vue的原型对象中再合适不过了。</p>\n<p><strong>(2)、在Vue的原型对象中存入一个组件，那么这个组件就能被其他所有的组件绑定事件或者触发事件，从而达到通讯的目的</strong></p>\n<p>在main.js文件中，构建一个组件并且存入Vue的原型对象中<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5623dbced6b74b458aac0f0205abe1ed.png\"/><br/> <strong>(3)、准备两个组件Student和School组件，然后在Student给Vue原型对象中的组件绑定事件，然后School中触发事件</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d900fa4afcab4197b61e09d1ad12097f.png\"/><br/> <strong>(4)、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fe15116f1d9744508e8be134f39c16b9.png\"/><br/> 会发现，Student组件中触发了School中给公用组件绑定的方法并且拿到了数据。到这里就实现了兄弟组件中的通讯了，不再局限于父穿子，子传父了。</p>\n<p><strong>(5)补充</strong><br/> 除了上面那种在main.js 中先构建一个组件然后再存入Vue的原型对象中的写法外还有一种比较标准的写法<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6b25cc5630374f3caaccc87f275bb753.png\"/><br/> 将之前原型对象的k为x都改为$bus （起这名是因为bus也总线的意思，哈哈）,测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5feef195d2734685b25b9123a61f4b03.png\"/></p>\n<h3><a id=\"102_358\"></a>10.2、总结</h3>\n<p>全局事件总进线(GlobalEventBus)</p>\n<ol><li> <p>一种组件间通信的方式，适用于任意组件间的通信。</p> </li><li> <p>在main.js中开启全局事件总线:</p> </li></ol>\n<pre><code class=\"prism language-bash\">new Vue<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n\t<span class=\"token function-name function\">beforeCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t    Vue.prototype.<span class=\"token variable\">$bus</span><span class=\"token operator\">=</span>this //开启全局配置总线\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<ol start=\"3\"><li>使用事件总线:<br/> 3.1. 接收数据：A组件想要接收数据，则在A组件中给$bug绑定自定义事件，事件的回调留在A组件自身.</li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token function-name function\">methods</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\tdemo<span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n<span class=\"token function-name function\">mounted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\tthis.<span class=\"token variable\">$bus</span><span class=\"token builtin class-name\">.</span><span class=\"token variable\">$on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx'</span>,this.demo<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>3.2. 提供数据</p>\n<pre><code class=\"prism language-bash\">this.<span class=\"token variable\">$bus</span><span class=\"token builtin class-name\">.</span><span class=\"token variable\">$emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx'</span>,数据<span class=\"token punctuation\">)</span> \n</code></pre>\n<ol start=\"4\"><li>最好是在beforeDestory构子中，用$off去解绑当前组件所用到的事件。</li></ol>\n<h1><a id=\"11pubsubjs_393\"></a>11、消息的订阅与发布（pubsub.js）</h1>\n<h3><a id=\"111_394\"></a>11.1、介绍和使用步骤</h3>\n<blockquote>\n<p>除了上面全局事件总线的方式实现任意组件中的通讯，我们还可以借助 消息的订阅与发布(pubsub.js)实现任意的组件中的通讯。</p>\n</blockquote>\n<p><strong>使用步骤</strong></p>\n<ol><li>安装pubsub: <code>npm i pubsub-js</code></li><li>在组件中引入: <code>import pubsub from 'pubsub-js'</code></li><li>接收数据：A组件中想要接收数据，则先在A组件中订阅消息，订阅的回调函数留在A组件自身</li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token function-name function\">methods</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\tdemo<span class=\"token punctuation\">(</span>msgName,参数1,参数2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>,\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n<span class=\"token function-name function\">mounted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\tthis.pid<span class=\"token operator\">=</span>pubsub.subscribe<span class=\"token punctuation\">(</span><span class=\"token string\">'xxx'</span>,this.demo<span class=\"token punctuation\">)</span>//订阅消息\n<span class=\"token punctuation\">}</span>,\n<span class=\"token function-name function\">beforeDestroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n pubsub.unsubscribe<span class=\"token punctuation\">(</span>this.pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<ol start=\"4\"><li>提供数据:<code>pubsub.publish('xxx',数据)</code></li><li>最好在beforeDestroy钩子中，用<code>pubsub.unsubscribe(pid)</code>取消订阅</li></ol>\n<h3><a id=\"112_418\"></a>11.2、示范</h3>\n<p>将之前给公用组件绑定自定义事件的方式替换成消息的订阅与发布<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c4e92c5ad92c4e7585e583d1daacb962.png\"/></p>\n<p>测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4801eb4123e84b05a287b89b47b6c90b.png\"/><br/> 测试成功啦！！！</p>\n<h1><a id=\"12nextTick_425\"></a>12、$nextTick</h1>\n<h3><a id=\"121_426\"></a>12.1、功能</h3>\n<p><strong>1、需求</strong><br/> 如图所示，点击按钮，显示输入框并且输入框获取焦点<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9c06cc6225cb42fcafbe7c715c3ef945.png\"/><br/> <strong>2、代码如图所示</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\17833a9f6539469b8f35074f75bc1b32.png\"/><br/> <strong>3、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\488bf018503b47b49ee612fa2efc5c25.png\"/><br/> 会发现根本就没有获取焦点</p>\n<p><strong>4、分析原因</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e4164282b44443c981bb9b71810936ee.png\"/><br/> 在模版都没成功渲染的时候显然连Dom元素都没有获取到</p>\n<p><strong>5、解决</strong><br/> 这里我们需要借助$nextTick解决<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d959296be9924ac5a410e8f2b25b0db6.png\"/><br/> <strong>6、再次测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cbab16dcd90e4e998305b3c8dbbca94a.png\"/><br/> 会发现，成功显示输入框并且输入框也获取了焦点</p>\n<h3><a id=\"122_447\"></a>12.2、总结</h3>\n<ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次DOM更新结束后执行指定的回调。</li><li>什么时候用：当改变数据后，要基于<strong>更新后的DOM进行某些操作时</strong>，要在nextTick所指定的回调函数中执行</li></ol>\n<h1><a id=\"13animatecss_452\"></a>13、animate.css</h1>\n<h3><a id=\"131_453\"></a>13.1、功能</h3>\n<p>animate.css包含了很多动画效果，这里我们试一下 显示/隐藏 的动画效果。有了它，我们不再需要自己手写C3动画样式了。非常nice</p>\n<p>官网：<a href=\"https://animate.style\">点击进入首页</a></p>\n<p><strong>示范:</strong></p>\n<p>我们准备一个Test组件</p>\n<p>1、安装animate.css :<code>npm install animate.css</code></p>\n<p>2、在组件中引入<code>import 'animate.css'</code></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5bbee8ef61954ea39cfee9c350479cb1.png\"/><br/> 3、设置显示和隐藏时的动画效果<br/> 我们在官网找到想要的样式<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\89f6a95056e44487a236e677d5923189.png\"/><br/> 编写代码，appear为true时表示进入网页时组件第一次渲染就开始显示配置的效果<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8c38d22c828e4143b79cfd911729077f.png\"/><br/> 4、测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3b12776ba9fa44c6bc0a51b3372cce21.png\"/><br/> 很方便对不对，nice</p>\n<h1><a id=\"14_476\"></a>14、反向代理</h1>\n<p>在解决ajax跨域问题时，后端人员经常会配置CORS解决跨域，但是作为前端，我们也可以通过自己的反向代理的方式解决跨域，这样就不用麻烦后端开发人员。</p>\n<p>我们先准备两个接口，这里有使用node-js写的两个服务器。先下载运行起来</p>\n<blockquote>\n<p>链接：https://pan.baidu.com/s/1Tbezmmg7vj_NpqxysYgCjg<br/> 提取码：1024</p>\n</blockquote>\n<p>解压之后我们通过node运行<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\63fea72e2f3644c1b1e80e40db0ae7ed.png\"/><br/> 测试一下接口是否正常返回数据:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\43634a16ee6d40b8b4ed7d6ad5bea2c8.png\"/><br/> 接下来我们写一个组件通过ajax的方式去请求接口，这里我们使用axios发起请求，当然得先安装axios：<code>npm i axios</code></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\34d5096d6b11437f9b581b428e2dcbcd.png\"/><br/> 会发现，产生了跨域问题，接下来我们用以下两种方式解决跨域</p>\n<h3><a id=\"141_494\"></a>14.1、方式一</h3>\n<p>官网配置说明：<a href=\"https://cli.vuejs.org/zh/config/#devserver-proxy\">点击直达</a><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\08d4916aacc14e5c90e81d5b815969dd.png\"/><br/> 在vue.config.js中加入配置</p>\n<pre><code class=\"prism language-bash\"> module.exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n\tdevServer: <span class=\"token punctuation\">{<!-- --></span>\n   \tproxy: <span class=\"token string\">'http://localhost:4000'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\39046cd5f5be4e2fbaef80a8b3c7fe37.png\"/><br/> <strong>重启脚手架项目，这样vue-cli就为你开启了一个8080的代理服务器去代理5000的服务器</strong></p>\n<p>重新发起请求<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2a7ec9d7683c41e6a5319d07891b9817.png\"/><br/> <strong>注意，如果我们8080的服务器上本身就有和5000相同的资源，代理服务器就不会把我们的请求转发给5000</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\886f529899e748e5a66f7f6561dcd691.png\"/></p>\n<h3><a id=\"142_514\"></a>14.2、方式二</h3>\n<p>会发现方式一存在两个问题，一是不能配置多个代理，二是不能灵活的控制请求是否转发。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a782c8d225ac4ed6a40fed56b4e0d29a.png\"/><br/> 编写vue.config.js具体规则</p>\n<pre><code class=\"prism language-bash\">module.exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n\tdevServer: <span class=\"token punctuation\">{<!-- --></span>\n      proxy: <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token string\">'/api1'</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{<!-- --></span>// 匹配所有以 <span class=\"token string\">'/api1'</span>开头的请求路径\n        target: <span class=\"token string\">'http://localhost:5000'</span>,// 代理目标的基础路径\n        changeOrigin: true,\n        pathRewrite: <span class=\"token punctuation\">{<!-- --></span><span class=\"token string\">'^/api1'</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>,\n      <span class=\"token string\">'/api2'</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{<!-- --></span>// 匹配所有以 <span class=\"token string\">'/api2'</span>开头的请求路径\n        target: <span class=\"token string\">'http://localhost:5001'</span>,// 代理目标的基础路径\n        changeOrigin: true,\n        pathRewrite: <span class=\"token punctuation\">{<!-- --></span><span class=\"token string\">'^/api2'</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n/*\n   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000\n   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080\n   changeOrigin默认值为true\n*/\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f887e5b680d8477f952ec78ac2473558.png\"/><br/> 配置完我们需要重启服务器,我们将请求前缀加上/api1 或/api2,测试。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2b2acf12b3c54290a832df0c6abb6246.png\"/><br/> 说明：<br/> 1.优点：可以配置多个代理，且可以灵活控制请求是否走代理<br/> 2.缺点：配置略微繁琐，请求资源时必须加前缀。</p>\n<h1><a id=\"15_549\"></a>15、插槽</h1>\n<h3><a id=\"151_550\"></a>15.1、插槽的介绍和使用方式</h3>\n<p><strong>1、作用</strong>：让父组件可以向子组件指定的位置插入html结构，也是一种组件间通信的方式，适用于父组件===&gt;子组件。</p>\n<p><strong>2、分类</strong>：默认插槽、具名插槽、作用域插槽</p>\n<p><strong>3、使用方式</strong>：</p>\n<ol><li>默认插槽:</li></ol>\n<pre><code class=\"prism language-bash\">父组件中：\n\t\t<span class=\"token operator\">&lt;</span>xxx组件<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">&gt;</span>html结构<span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>&lt;</span>/div<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/xxx组件<span class=\"token operator\">&gt;</span>\n子组件中：\n\t\t<span class=\"token operator\">&lt;</span>template<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">&gt;</span>\n\t\t\t\t<span class=\"token operator\">&lt;</span>slot<span class=\"token operator\">&gt;</span>插槽默认内容<span class=\"token punctuation\">..</span>.<span class=\"token operator\">&lt;</span>/slot<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>/div<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/template<span class=\"token operator\">&gt;</span>\n</code></pre>\n<ol start=\"2\"><li>具名插槽</li></ol>\n<pre><code class=\"prism language-bash\">父组件中：\n\t<span class=\"token operator\">&lt;</span>xxx组件<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>template <span class=\"token assign-left variable\">slot</span><span class=\"token operator\">=</span><span class=\"token string\">\"center\"</span><span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">&gt;</span>html结构<span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>&lt;</span>/div<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/templat<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>template v-slot:footer<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">&gt;</span>html结构<span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>&lt;</span>/div<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/templat<span class=\"token operator\">&gt;</span>\t\n\t<span class=\"token operator\">&lt;</span>xxx组件<span class=\"token operator\">&gt;</span>\t\t\n子组件中:\n\t<span class=\"token operator\">&lt;</span>template<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>--定义插槽--<span class=\"token operator\">&gt;</span>\t\n\t\t\t<span class=\"token operator\">&lt;</span>slot <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"center\"</span><span class=\"token operator\">&gt;</span>插槽默认内容<span class=\"token punctuation\">..</span>.<span class=\"token operator\">&lt;</span>/slot<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>slot <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"footer\"</span><span class=\"token operator\">&gt;</span>插槽默认内容<span class=\"token operator\">&lt;</span>/slot<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/div<span class=\"token operator\">&gt;</span>\n\t<span class=\"token operator\">&lt;</span>/template<span class=\"token operator\">&gt;</span>\n</code></pre>\n<ol start=\"3\"><li>作用于插槽<br/> 1、理解：<strong>数据在组件自身，但数据生成的结构需要组件的使用者来决定</strong>，意思就是说，组件的使用者可以拿到组件中提前定义好的数据 然后在使用时根据自己的需求进行渲染。<br/> 2、具体编码</li></ol>\n<pre><code class=\"prism language-bash\">父组件中：\n\t<span class=\"token operator\">&lt;</span>xxx组件<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>--或者scope换成slot-scope也行--<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>template <span class=\"token assign-left variable\">scope</span><span class=\"token operator\">=</span><span class=\"token string\">\"scopeData\"</span><span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>--生成的是ul列表<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">&gt;</span>\n\t\t\t\t<span class=\"token operator\">&lt;</span>li v-for<span class=\"token operator\">=</span><span class=\"token string\">\"g in scopeData.games\"</span> :key<span class=\"token operator\">=</span><span class=\"token string\">\"g\"</span> <span class=\"token operator\">&gt;</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">{<!-- --></span>g<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span>/li<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>/ul<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/template<span class=\"token operator\">&gt;</span>\t\n\t<span class=\"token operator\">&lt;</span>/xxx组件<span class=\"token operator\">&gt;</span>\n\n子组件中:\n\t<span class=\"token operator\">&lt;</span>template<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token operator\">&lt;</span>slot :games<span class=\"token operator\">=</span><span class=\"token string\">\"games\"</span><span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>/slot<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token operator\">&lt;</span>/div<span class=\"token operator\">&gt;</span>\n\t<span class=\"token operator\">&lt;</span>/template<span class=\"token operator\">&gt;</span>\n\t<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">&gt;</span>\n\t\t<span class=\"token builtin class-name\">export</span> default<span class=\"token punctuation\">{<!-- --></span>\n\t\t\tname:<span class=\"token string\">'Category'</span>,\n\t\t\t//数据在组件自身\n\t\t\t<span class=\"token function-name function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\treturn<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\t\tgames:<span class=\"token punctuation\">[</span><span class=\"token string\">'红色警戒'</span>,<span class=\"token string\">'穿越火线'</span>,<span class=\"token string\">'劲舞团'</span><span class=\"token punctuation\">]</span> \n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token operator\">&lt;</span>/script<span class=\"token operator\">&gt;</span>\t\n\n</code></pre>\n<h3><a id=\"152_629\"></a>15.2、默认插槽</h3>\n<p>首先我们准备一Category1组件，在组件中定义一个插槽，然后使用这个组件时动态是插入html结构内容<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f5d76af222b94c36b4b9fe01e7ec88d6.png\"/><br/> 测试成功、<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a38830e872554611926fc4f3868134e3.png\"/></p>\n<h3><a id=\"153_634\"></a>15.3、具名插槽</h3>\n<p>默认插槽只能定义一个插槽，我们可以使用具名插槽定义多个插槽。我们准备一个Category2组件,在其中声明两个插槽<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d6a4b88557744f158b4adea449063b33.png\"/><br/> 测试成功<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\48b74ed89c874702b16beb983f32fca6.png\"/></p>\n<h3><a id=\"154_639\"></a>15.4、作用域插槽</h3>\n<p>准备一个组件Category3,并定义插槽携带数据<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\88b4dfeea6de4fcaa7a4df82f5160db4.png\"/><br/> 测试成功<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\50820c7352fb40bea7f371689d19b0ae.png\"/></p>\n<h1><a id=\"16Vuex_644\"></a>16、Vuex</h1>\n<h3><a id=\"161vuex_645\"></a>16.1、vuex是什么？</h3>\n<ol><li> <p>概念：专门在Vue中实现集中式状态(数据)管理的一个Vue插件，在Vue应用中多个组件共享状态进行集中式管理(读/写),也是一种组件间通信方式，且适用于任意组件中的通信。（说白了就像后端中的redis可以用来多个应用中做数据共享）</p> </li><li> <p>Github地址：https://github.com/vuejs/vuex</p> </li></ol>\n<h3><a id=\"162Vuex_650\"></a>16.2、什么时候使用Vuex</h3>\n<ol><li>多个组件依赖于同一状态</li><li>多个组件的行为需要变更同一状态</li></ol>\n<h3><a id=\"163Vuex_654\"></a>16.3、Vuex原理图</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fed72a39d3e9442098872fedd58e7705.png\"/><br/> 现在看不懂没关系，我们逐个分析…</p>\n<h3><a id=\"164Vuex_658\"></a>16.4、搭建Vuex环境</h3>\n<p>注意：在2022年的2月7日，vue3成为了默认版本，如果我们现在去执行npm i vue ，安装的直接就是vue3了，并且在vue3成为默认版本后。vuex更新到了4版本，所以我们如果执行npm i vuex，安装的是vuex4，而vue3版本只能在vue3版本中使用。<br/> 所以简单来说：<br/> <strong>vue2中，要用vuex的3版本<br/> vue3中，要用vuex的4版本</strong></p>\n<p><strong>1、安装vuex并使用vuex插件</strong></p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">npm</span> i vuex@3\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ac5f15c76aa641c7b70c4f389562ec88.png\"/><br/> <strong>2、为了让所有的vm和vc都拥有$store，所以我们需要配置store</strong><br/> 在src文件夹下创建store文件夹和index.js文件<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\eb5a276f70b4463b8b8d4d30a962d4df.png\"/><br/> 测试:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c7209b6b2a27405eb1c2868352afb79d.png\"/></p>\n<p>调整写法<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\67561705dc3842e795cab4fe2925d53d.png\"/><br/> index.js文件内容</p>\n<pre><code class=\"prism language-bash\">//该文件用于创建VUex中最为核心的store\n<span class=\"token function\">import</span> Vue from <span class=\"token string\">'vue'</span>\n\n//引入VUex\n<span class=\"token function\">import</span> Vuex from <span class=\"token string\">'vuex'</span>\n\nVue.use<span class=\"token punctuation\">(</span>Vuex<span class=\"token punctuation\">)</span>\n\n//准备actions-用于响应组件中的动作\nconst <span class=\"token assign-left variable\">actions</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n//准备mutations-用于操作数据<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span>\nconst <span class=\"token assign-left variable\">mutations</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n//准备state-用于存储数据\nconst <span class=\"token assign-left variable\">state</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n//创建并暴露store\n<span class=\"token builtin class-name\">export</span> default new Vuex.Store<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>\n    actions,\n    mutations,\n    state,\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>这回，就没有报错了！！！<br/> 测试vm和vc中是否包含$store，我们直接在mounted钩子中打印this<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ff24194a830a40a3989065eec554efaf.png\"/></p>\n<p>成功啦，之后$store中那些强大的API我们就都可以在任意vm和vc中使用了。</p>\n<h3><a id=\"165_710\"></a>16.5、求和案例</h3>\n<p>现在的需求：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\23325fe4cf05419a8e7291f762d5d859.png\"/></p>\n<h4><a id=\"1651Vue_713\"></a>16.5.1、纯Vue版本</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6e90321b4002444f9d522df98cd70571.png\"/></p>\n<h4><a id=\"1652Vuex_715\"></a>16.5.2、Vuex版本</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fa31a58903204067bfa82ee9aa2e49cb.png\"/><br/> 测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ac4abc6c8b91418094d33d5c262a129d.png\"/></p>\n<h3><a id=\"166Storegetters_719\"></a>16.6、Store中的getters配置项</h3>\n<p>1、概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。他就和vue中的计算属性是一样的。<br/> 2、在./store/index.js中追加getters配置</p>\n<pre><code class=\"prism language-bash\"><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n\nconst <span class=\"token assign-left variable\">getters</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n\tbigSum<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token builtin class-name\">return</span> state.sum*10\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//创建并暴露store\n<span class=\"token builtin class-name\">export</span> default new Vuex.Store<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n\tgetters\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n</code></pre>\n<p>3、组件中读取数据:$store.getters.bigSum</p>\n<p>4、示范<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\199eb959bbb94a8993b93925bbced5af.png\"/>5、测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\55c1bc30a5c2467ca733bcae59a2cc98.png\"/><br/> 完美。</p>\n<h3><a id=\"167mapStatemapGetters_744\"></a>16.7、mapState与mapGetters</h3>\n<h4><a id=\"1671mapState_745\"></a>16.7.1、mapState</h4>\n<p><strong>1、会发现如过store中的state中有多个属性数据需要读取，就比较繁琐</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3ca6adee5f8d484c865ba89eb6f64c0a.png\"/><br/> <strong>2、我们可以通过计算属性来进行简化</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2a1cdd47260a4151aa314a3ad1338c57.png\"/></p>\n<h4><a id=\"1672mapGetters_750\"></a>16.7.2、mapGetters</h4>\n<p>mapGetters和mapState的用法一样，只不过它拿的是store中的getters中的数据<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\25e6c43e85fd4887acc6cdd38cfa4ff9.png\"/></p>\n<h4><a id=\"1673_753\"></a>16.7.3、总结</h4>\n<p>1.<strong>mapState方法</strong>：用于帮助我们映射<strong>state</strong>中的数据为计算属性</p>\n<pre><code class=\"prism language-bash\">computed:<span class=\"token punctuation\">{<!-- --></span>\n\t//借助mapState生产计算属性:sum、address、subject\n\t<span class=\"token punctuation\">..</span>.mapState<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>sum:<span class=\"token string\">'sum'</span>,address:<span class=\"token string\">'address'</span>,subject:<span class=\"token string\">'subject'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\t//借助mapState生成计算属性：sum、address、subject\n    <span class=\"token punctuation\">..</span>.mapState<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'sum'</span>,<span class=\"token string\">'address'</span>,<span class=\"token string\">'subject'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>2.<strong>mapGetters方法</strong>：用于帮助我们映射<strong>getters</strong>中的数据为计算属性</p>\n<pre><code class=\"prism language-bash\">computed:<span class=\"token punctuation\">{<!-- --></span>\n\t//借助mapGetters生成计算属性：bigSum<span class=\"token punctuation\">(</span>对象写法<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">..</span>.mapGetters<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>bigSum:<span class=\"token string\">'bigSum'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>,\n\t//借助mapGetters生成计算属性:bigsum <span class=\"token punctuation\">(</span>数组写法<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">..</span>.mapGetters<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bigSum'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"168mapActionsmapMutations_776\"></a>16.8、mapActions和mapMutations</h3>\n<h4><a id=\"1681mapActions_777\"></a>16.8.1、mapActions</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ca80e700670743309ef1c1a5725e6d22.png\"/></p>\n<h4><a id=\"1682mapMutations_779\"></a>16.8.2、mapMutations</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2943db65d7694489a9af381f9cea626a.png\"/></p>\n<h4><a id=\"1683_781\"></a>16.8.3、总结</h4>\n<ol><li><strong>mapActions方法：<strong>帮助我们生成与</strong>actions</strong>对话的方法，即：包含$store.dispath(xxx)的函数</li></ol>\n<pre><code class=\"prism language-bash\">methods:<span class=\"token punctuation\">{<!-- --></span>\n\t//借助mapActions生成与actins的对话的方式<span class=\"token punctuation\">(</span>对象写法<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">..</span>.mapActions<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>increment:<span class=\"token string\">'increment'</span>,incrementWait:<span class=\"token string\">'incrementWait'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n \t//数组形式的写法\n    <span class=\"token punctuation\">..</span>.mapActions<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'increment'</span>,<span class=\"token string\">'incrementWait'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\t\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol start=\"2\"><li><strong>mapMutations方法</strong>：用于帮助我们生成与<strong>mutations</strong>对话的方法，即: 包含$store.commit(xxx)的函数</li></ol>\n<pre><code class=\"prism language-bash\">methods:<span class=\"token punctuation\">{<!-- --></span>\n\t//借助mapMutation生成与**mutations**对话的方法<span class=\"token punctuation\">(</span>对象形式<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">..</span>.mapMutations<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>INCREMENT:<span class=\"token string\">\"INCREMENT\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t\n\t//数组写法\n\t<span class=\"token punctuation\">..</span>.mapMutations<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'INCREMENT'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"169Vuex_806\"></a>16.9、Vuex的模块化编码</h3>\n<p>会发现，结合上面的技术，我们已经能完成数据的共享以及我们想要的功能。但随之也带来了一些问题，那就是如果业务量很大，模块很多，那么Store中的actions或者mutations以及state就会写得很长，不利于<br/> 所以我们可以使用<strong>模块化+命名空间</strong>将Vuex的模块进行分类，<br/> 就是说<br/> <strong>订单模块调用订单模块的store</strong>，<br/> <strong>支付模块调用支付模块的store</strong></p>\n<h4><a id=\"1691_813\"></a>16.9.1、模块化+命名空间</h4>\n<p>1.目的：让代码更好维护，让多种数据分类更加明确<br/> 2.修改store.js</p>\n<pre><code class=\"prism language-bash\">const <span class=\"token assign-left variable\">module1</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n\tnamespaced:true,\n\tactions:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>,\n\tmutations:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>,\n\tstate:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>,\n\tgetters:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nconst <span class=\"token assign-left variable\">module2</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{<!-- --></span>\n\tnamespaced:true,\n\tactions:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>,\n\tmutations:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>,\n\tstate:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>,\n\tgetters:<span class=\"token punctuation\">{<!-- --></span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nconst store <span class=\"token operator\">=</span> new Vuex.Store<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>\n\tmodules:<span class=\"token punctuation\">{<!-- --></span>\n\t\t//module:module\n\t\t// es6 简写\n\t\tmodule1,\n\t\tmodule2\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>3、开启命名空间后，组件中读取state数据:</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">//方式一:直接读取</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>xxxxx模块<span class=\"token punctuation\">.</span>sum\n<span class=\"token comment\">//方式二:借助mapState读取</span>\n<span class=\"token operator\">...</span><span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxxxx模块'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'sum'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'subject'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>4、开启命名空间后，组件中读取getters数据:</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">//方式一：自己直接读取  不能直接写 getters.xxx模块.BigSum </span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">[</span><span class=\"token string\">'xxx模块/bigSum'</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">//方式二：借助mapGetters读取：</span>\n<span class=\"token operator\">...</span><span class=\"token function\">mapGetters</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx模块'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'bigSum'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>5、开启命名空间后，组件中调用dispath</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">//方式一：自己直接dispath</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span><span class=\"token function\">dispath</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx模块/increment'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>xxx<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//方式二：借助mapActions 或者对象写法('xxx模块',{increment:'increment'})</span>\n<span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx模块'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n</code></pre>\n<p>6、开启命名空间后，组件中调用commit</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">//方式一：自己直接commit</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx模块/INCREMENT'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>xxx<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//方式二：通过mapMutations</span>\n<span class=\"token operator\">...</span><span class=\"token function\">mapMutations</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx模块'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'INCREMENT'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h4><a id=\"1692_876\"></a>16.9.2、测试</h4>\n<p>通过$store的方式，我们准备一个Count组件和Count模块<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3324d49bb6b542dea4992fe9965aef7e.png\"/><br/> 测试完美！！！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5bdfffc6b96d4ae4adec8b4fbfd920dd.png\"/></p>\n<p>通过map映射的方式，准备另外一个Studentr组件和studentOptions模块<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c9d88e1c2f5e47f4be21de606c1378b0.png\"/><br/> 测试完美！！！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8b001c92ce134a91aeface520ba28baa.png\"/><br/> <strong>补充、</strong><br/> 当然也可以将各个模块抽取出来，然后在index文件中导入，这样模块的划分就更加清晰<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f5d9f80693bd4287b6088e6c429741ba.png\"/></p>\n<h1><a id=\"17_890\"></a>17、路由</h1>\n<h3><a id=\"171_891\"></a>17.1、路由的简介</h3>\n<p>说白了，路由就是一组组Key–Value的对应关系。</p>\n<p>(1)、理解：一个路由(route)就是一组映射关系(key-value)，多个路由需要路由器(router)进行管理</p>\n<p>(2)、前端路由：key是路径，value是组件</p>\n<h3><a id=\"172_898\"></a>17.2、路由的基本使用</h3>\n<h4><a id=\"1721vuerouter_899\"></a>17.2.1、安装vue-router</h4>\n<p>注意，在2022年2月7日以后，vue-router的默认版本为4版本，并且：<strong>Vue-router3才能再Vue2中使用</strong></p>\n<p>所以我们得安装Vue-router3</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">npm</span> i vue-router@3\n</code></pre>\n<h4><a id=\"1721vuerouter_907\"></a>17.2.1、使用vue-router</h4>\n<p>1、<strong>首先创建一个叫router的文件夹，并创建index.js,我们创建并暴露一个路由器VueRouter</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ae28566cb949412dbe65c156425701b1.png\"/><br/> <strong>2、在main.js中引入VueRouter并use，然后配置router</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\808e8ff9346d49709e55d101a0c97712.png\"/><br/> <strong>3、准备两个组件，随便写点内容</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c7dc8e667a0d4b349f6085f06ceeeb47.png\"/><br/> <strong>4、在路由器中配置路由数组routes 它里面包含很多路由。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8578f36bdced49bfb84e1346ac4db800.png\"/></p>\n<p><strong>5、然后我们在App.vue中可以开始使用路由了</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dca405772b864077978f49473bb507f4.png\"/><br/> <strong>6、测试</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cc764265a9a64a3a9ab3c40bf2f80321.png\"/></p>\n<h3><a id=\"173_922\"></a>17.3、几个注意点</h3>\n<p><strong>1、用单独的文件夹保存路由跳转的组件</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a87cd177ce6348c19d179f3fedb5f046.png\"/><br/> <strong>2、通过切换后，\"隐藏\"了的路由组件默认是被自动销毁掉的，需要的时候会自动从新挂载。</strong></p>\n<p><strong>3、每个组件都有自己的<code>$route</code>属性，里面存储着关于自己的路由信息。</strong></p>\n<p><strong>4、整个应用只有一个路由器router，可以通过组件的<code>$router</code>属性获取到。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0049da0bd07e4c199206b1979ce1d5b4.png\"/></p>\n<h3><a id=\"174_932\"></a>17.4、嵌套路由</h3>\n<p>就是路由组件里继续路由跳转到路由组件<br/> 1、首先，我们添加一些样式，并说明一下需求<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\081021827b7f4974a59a73797a3f8be6.png\"/><br/> 我们点击“学生管理”，然后会出现旁边父路由的信息，然后点击父路由组件中的 “学生信息” 或者 “学生地址”</p>\n<p>2、我们再准备两个组件News和Address，随便加点内容，这两个是子组件中要显示的内容<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\edc73d28e99a43d391de43a29479be4a.png\"/><br/> 3、我们编写路由规则<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3eff322f0788436d871cf1960f60a8c4.png\"/><br/> 4、测试，完美！！！</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\15e3801b66924c799520b7c7a71020e0.png\"/><br/> <strong>总结：</strong><br/> 多级路由：<br/> 1.配置路由规则，使用children配置项:</p>\n<pre><code class=\"prism language-bash\">routes:<span class=\"token punctuation\">[</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tpath:<span class=\"token string\">'/class'</span>,\n\t\tcomponent:Class\n\t<span class=\"token punctuation\">}</span>,\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tpath:<span class=\"token string\">'/student'</span>,\n\t\tcomponent:Student,\n\t\tchildren:<span class=\"token punctuation\">[</span>\n\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\tpath:<span class=\"token string\">'news'</span>,\n\t\t\t\tcomponent:News\n\t\t\t<span class=\"token punctuation\">}</span>,\n\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\tpath:<span class=\"token string\">'address'</span>, //此处千万不要写 /address \n\t\t\t\tcomponent:Message\n\t\t\t<span class=\"token punctuation\">}</span>\n\n\n\t\t<span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n</code></pre>\n<h3><a id=\"175query_973\"></a>17.5、路由的query参数(路由跳转时传递参数)</h3>\n<p>1.、现在新的需求，要求点击某条消息，然后显示消息的id和消息的详情信息<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d18768e37cd64aefbce2c17f0f790433.png\"/><br/> 2、可以看到 学生消息路由里面还包含路由，<strong>三级路由</strong>了<br/> 并且点击的时候还还需要将参数动态的传递给第三级的路由组件。</p>\n<p>首先我们创建一个Details组件并配置好路由规则<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8a20dbeebeb84e43a51d890f78893c6e.png\"/><br/> 3、路由跳转时携带参数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ac234002f3204d2aac3615473c6a506b.png\"/><br/> 4、测试成功啦！！！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f63085e6613347f3b3249599a7d3a048.png\"/></p>\n<h3><a id=\"176_985\"></a>17.6、命名路由（简化跳转）</h3>\n<p>我们会发现，从上述的例子中可以看到，如果路由嵌套过多，那么跳转的时候 路径就会写得很长，那么我们可以给该路由定义一个名字来简化跳转<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6191793d02314dcbaf10bf850d0efdb7.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c580f968175c4946ab6a62f7f07a2e71.png\"/></p>\n<h3><a id=\"177params_989\"></a>17.7、路由的params参数</h3>\n<p>打印this 我们可以看到不光query可以携带参数，我们也可以通过params携带参数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bd20f211a31f4892a733e576616fc982.png\"/><br/> 在路由的path中添加占位符，通过params携带参数，然后路由组件中就可以从params中携带拿到参数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\33f2e165104f4f54b392e53eb64f1520.png\"/></p>\n<p>测试 接收参数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\26cb5760c08c4297bfcba5a62e74fb25.png\"/></p>\n<h3><a id=\"178props_997\"></a>17.8、路由的props配置</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e442a620e43b400caade5c4e94819ed5.png\"/><br/> 路由的props配置的三种写法</p>\n<pre><code class=\"prism language-javascript\"><span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span><span class=\"token string\">'ces'</span><span class=\"token punctuation\">,</span>\n <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span><span class=\"token string\">'detail/:id/:detail'</span>\n <span class=\"token literal-property property\">component</span><span class=\"token operator\">:</span>Detail<span class=\"token punctuation\">,</span>\n <span class=\"token comment\">//第一种写法：props值为对象，该对象所有的的key-value最终通过通过props传给Detail组件</span>\n <span class=\"token comment\">// props:{a:900}</span>\n \n<span class=\"token comment\">//第二种写法:props值为布尔值，布尔值为true，则把路由收到所有params参数通过props传递给Detail</span>\n<span class=\"token comment\">//props:true</span>\n\n<span class=\"token comment\">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传递给Detail组件</span>\n   <span class=\"token function\">props</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">$route</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">{<!-- --></span>\n\t \t<span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span>$route<span class=\"token punctuation\">.</span>query<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n\t \t<span class=\"token literal-property property\">detail</span><span class=\"token operator\">:</span>$route<span class=\"token punctuation\">.</span>query<span class=\"token punctuation\">.</span>detail\n\t<span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>第一种写法只能传递固定的数据，不灵活，所以就不演示了。<br/> 第二种写法：注意这种写法只能传递params中的key-value…<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b38eda078d084d83bb2f68a7f70c7715.png\"/><br/> 第三种写法<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\723f1d03be724d10a29bcb4548226bba.png\"/></p>\n<h3><a id=\"179routerlinkreplace_1026\"></a>17.9、router-link的replace属性</h3>\n<p>1、作用：控制路由跳转时操作浏览器历史记录的模式<br/> 2、浏览器的历史记录有两种写入方式：分别是<strong>push</strong>和<strong>replace</strong>，<strong>push</strong>是追加历史记录，<strong>replace</strong>是替换当前记录。路由跳转时候默认为<strong>push</strong><br/> 3.如何开启<strong>replace模式</strong>:<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></p>\n<p>首先，我们点击<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a44db79db61a49be94d9a8629589e03e.png\"/><br/> 会发现 会从消息二回到消息一<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a8428ddd9a7748ecaea99907852548a9.png\"/></p>\n<p>测试 我们在Student的组件和他的子路由 News的路由跳转中加入replace属性<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6bfafa59c91a4c52a6a79c52cd1b1296.png\"/><br/> 再按照刚刚的点击顺序<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cb8ae335df1d40ec98c64248ede72e30.png\"/><br/> 说白了 replace 加入之后 该路由 跳转的记录不会在浏览器留下痕迹</p>\n<h3><a id=\"1710_router_1046\"></a>17.10、编程式路由导航 (通过$router跳转)</h3>\n<p>通过上面的例子，我们不仅可以通过<code>&lt;router-link&gt;</code>标签进行跳转，我们还可以通过<code>$router</code>进行跳转，我们之前就说过，每个组件都有自己的<code>$route</code>而所有的组件共用一个<code>$router</code></p>\n<p>我们看一下现在的需求：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f9c2b0feb95b4a8cb15a4ecf57e6a743.png\"/><br/> 我们通过点击按钮然后调用<code>$router.push</code>跳转到指定组件<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cb99fd19237f4257938adf062e5ca264.png\"/><br/> 通过<code>$replace</code>进行跳转<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\52a5015167a44f04bf1ef7e0541d7248.png\"/><br/> 测试成功<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\601a154170144273a57ca8fee0696e98.png\"/><br/> 接下来编写前进和后退的代码以及go的代码<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1aed87bba05e47d2b051c43719b75602.png\"/><br/> 就和点击浏览器前进和后退的箭头一样。之后我们就可以通过<code>$router</code>的这些API实现各种组件 类似于页面条页面的路由跳转啦！！！</p>\n<h3><a id=\"1711_1061\"></a>17.11、缓存路由组件</h3>\n<p>1.作用：让不展示的路由组件保持挂载，不被销毁。<br/> 2.具体编码：</p>\n<pre><code class=\"prism language-bash\">//指定一个组件不被销毁\n<span class=\"token operator\">&lt;</span>keep-alive <span class=\"token assign-left variable\">include</span><span class=\"token operator\">=</span><span class=\"token string\">\"具体不被销毁的组件名\"</span><span class=\"token operator\">&gt;</span>\n\t<span class=\"token operator\">&lt;</span>router-view<span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>/router-view<span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span>/keep-alive<span class=\"token operator\">&gt;</span>\n\n//指定多个缓存不被销毁\n<span class=\"token operator\">&lt;</span>keep-alive :include<span class=\"token operator\">=</span><span class=\"token string\">\"['xxx','xxx']\"</span><span class=\"token operator\">&gt;</span>\n\t<span class=\"token operator\">&lt;</span>router-view<span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>/router-view<span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span>/keep-alive<span class=\"token operator\">&gt;</span>\n</code></pre>\n<p><strong>示范：</strong><br/> 我们希望从新回到该路由组件的时候，输入的内容还在<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ecf3c60744a34db89ad90c53f83717bd.png\"/><br/> 所以我们可以使用缓存路由组件<code>keep-alive</code>，我们在显示的视图使用<code>router-view</code>时顺便使用<code>keep-alive</code>即可<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\57a7b6fd43aa477896b49fcce083f585.png\"/>测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\42d9786411524f32801019fbb90cca22.png\"/></p>\n<h3><a id=\"1712_1082\"></a>17.12、两个新的生命周期钩子</h3>\n<ol><li>作用：路由组件所独有的两个钩子</li><li>具体名字： \n  <ol><li><code>activated</code>路由组件被激活时触发</li><li><code>deactivated</code>路由组件失活时触发</li></ol> </li></ol>\n<p><strong>示范：</strong><br/> 我们在Address组件中添加上这两个钩子函数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e7f5eac42c8b4942b4e65d2907408b43.png\"/></p>\n<h3><a id=\"1713__1091\"></a>17.13、 路由守卫（权限控制）</h3>\n<h4><a id=\"17131_1092\"></a>17.13.1、全局前置守卫</h4>\n<p>需求：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\58410c473f574547b4b095a08512bd71.png\"/><br/> 所以 我们可以在可以使用路由的前置守卫控制某个路由是否放行</p>\n<p>1、首先在LocalStorage中存入key<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\05925e53e3ce4fc8a7093eac3637c950.png\"/><br/> 2、在路由器中配置前置守卫<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\53b8edafec514c8eb25a5a774cf1f1d8.png\"/><br/> 3、当role为vip时<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3b870d3beb9b4cf8a2aa32e2e9612db3.png\"/><br/> 4、我们改一下role的值、测试成功<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9bebb667d0d1468493031e4b3a57ae73.png\"/><br/> <strong>补充</strong><br/> 从上面的例子中我们可以看到，如果每次都拿到path或者name去判断的话太长了，也不方便，。我们可以通过在meta属性中加上数据，表面这个路由是否需要被判断。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c98c1c624e65475d842c8eebc8291f0d.png\"/></p>\n<h4><a id=\"17132_1109\"></a>17.13.2、全局后置守卫</h4>\n<p>很少使用，一般用来修改网页的title<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fdcc2d8f614f49ff9c9d7238d27e0625.png\"/></p>\n<h4><a id=\"17133_1112\"></a>17.13.3、独享守卫</h4>\n<p>上面的都是对所有路由都有效的，独享守卫就是对某一个路由有效，<br/> 并且 独享守卫只有前置，没有后置。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1a010e1e20d944869cf9611ee663f9da.png\"/></p>\n<h4><a id=\"17134_1116\"></a>17.13.4、组件内守卫</h4>\n<p>说白了就是写在组件内的路由守卫，我们直接写在Class组件中。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ede2e2db83ef4bb38e6d96d4b2c64ebd.png\"/><br/> 测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9d3540d35f7c40feb42ea7afff34cc58.png\"/></p>\n<h3><a id=\"1714_1121\"></a>17.14、路由器的两种工作模式</h3>\n<ol><li>对于一个url来说，什么是hash值？—#以及后面的内容就是hash值，</li><li>hash值不会包含在HTTP请求中，即：hash值不会带给服务器。</li><li>hash模式： \n  <ol><li>地址中永远带着#号，不美观。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol> </li><li>history模式： \n  <ol><li>地址干净，美观。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol> </li></ol>\n<p><strong>设置：</strong></p>\n<p>默认是hash，如果想换成history则可设置<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\65865ccef81f4a6ea4a2f270311b68bf.png\"/><br/> hash模式下的地址栏<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bf36ab04f6a641c0a0d647a4228a3d69.png\"/><br/> history模式下的地址栏<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0a796ec69c264651a505b6179e652406.png\"/><br/> 记住：history模式部署上线前记得对服务器进行相关配置解决history刷新地址栏报404的问题。</p>\n<h1><a id=\"18ElementUI__1143\"></a>18、Element-UI 组件库</h1>\n<h3><a id=\"181ElementUI_1144\"></a>18.1、Element-UI基本使用</h3>\n<blockquote>\n<p>官网：<code>https://element.eleme.cn/#/zh-CN/component/installation</code></p>\n</blockquote>\n<p>根据官网进行安装</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">npm</span> i element-ui\n</code></pre>\n<p>安装完之后在main.js 中添加以下代码，则可在所有的组件中使用element ui了</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">import</span> ElementUI from <span class=\"token string\">'element-ui'</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">import</span> <span class=\"token string\">'element-ui/lib/theme-chalk/index.css'</span><span class=\"token punctuation\">;</span>\nVue.use<span class=\"token punctuation\">(</span>ElementUI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>我们在App.vue中直接使用一下Element-UI提供的组件库<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7b452d87aad94a599077e5185b9c7923.png\"/></p>\n<h3><a id=\"182ElementUI_1163\"></a>18.2、Element-UI按需引入</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\03fc02f4075b4b38932583a36d8f28e0.png\"/><br/> 1、安装babel插件</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> babel-plugin-component -D  \n</code></pre>\n<p>2、配置.babelrc文件，注意：vue-cli中已经不存在.babelrc文件了，babel的配置在 <code>babel.config.js</code>文件中</p>\n<pre><code class=\"prism language-bash\">module.exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n  presets: <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'@vue/cli-plugin-babel/preset'</span>,\n    <span class=\"token punctuation\">[</span><span class=\"token string\">\"@babel/preset-env\"</span>, <span class=\"token punctuation\">{<!-- --></span> <span class=\"token string\">\"modules\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">]</span>,\n  plugins: <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">\"component\"</span>,\n      <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token string\">\"libraryName\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"element-ui\"</span>,\n        <span class=\"token string\">\"styleLibraryName\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"theme-chalk\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>注意，如果按照官网的话可能会出现，这个错误（因为官网的文档可能不是最新的）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\eaa05a95a6dc44f38cd80b489d754ac2.png\"/><br/> 我们改个地方就可以了。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\743c16ff9da64474841d3bb608e02679.png\"/><br/> 3、我们根据官网，按需引入即可<br/> 比如我只使用button和row组件</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">import</span> <span class=\"token punctuation\">{<!-- --></span> Button, Row <span class=\"token punctuation\">}</span> from <span class=\"token string\">'element-ui'</span><span class=\"token punctuation\">;</span>\nVue.component<span class=\"token punctuation\">(</span>Button.name, Button<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nVue.component<span class=\"token punctuation\">(</span>Row .name, Row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ae40e584b8d840fe9aa3c851944bab4d.png\"/><br/> 测试<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\febc8192ec4f4a47ab1c07ab9826465c.png\"/></p>\n<h1><a id=\"19_1206\"></a>19、后记</h1>\n<p>生活朗朗，万物可爱，人间值得，未来可期。恭喜你，完结撒花！！！</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-08-16 15:02:35", "summary": "、创建脚手架、首先系统需要全局安装脚手架、创建脚手架工程进入你想创建脚手架的目录，然后输入命令项目名需要注意的是工程名字不能大写，这里我们选择选择，敲下回车，那么将会为我们创建脚手架在这里插入图片描述"}