{"blogid": "126727834", "writerAge": "码龄1年", "writerBlogNum": "27", "writerCollect": "241", "writerComment": "263", "writerFan": "1089", "writerGrade": "4级", "writerIntegral": "1013", "writerName": "天海奈奈", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126727834.jpg", "writerRankTotal": "20000", "writerRankWeekly": "188", "writerThumb": "267", "writerVisitNum": "5945", "blog_read_count": "68", "blog_time": "于 2022-09-06 16:45:38 发布", "blog_title": "算法面试 | 40天刷完LeetCode 精选 TOP 面试题（2/40）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p><strong> 个人主页：</strong><a href=\"https://blog.csdn.net/weixin_57169969?type=blog\" title=\"天海奈奈的博客\">天海奈奈的博客</a><br/><strong>刷题专栏： </strong><a href=\"https://leetcode.cn/problem-list/2ckc81c/?page=1&amp;difficulty=MEDIUM\" title=\"题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台\">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a>面试top<br/><strong>刷题网站: </strong> <a href=\"https://leetcode.cn/\" title=\"力扣\">力扣</a> 让我们一起加油~</p>\n</blockquote>\n<p> </p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%C2%A020.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A020.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7\"> 20. 有效的括号</a></p>\n<p id=\"%C2%A021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\"> 21. 合并两个有序链表</a></p>\n<p id=\"26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-toc\" style=\"margin-left:0px;\"><a href=\"#26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9\">26. 删除有序数组中的重复项</a></p>\n<p id=\"2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-toc\" style=\"margin-left:0px;\"><a href=\"#2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0\">2. 两数相加</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%C2%A020.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7\"> <a href=\"https://leetcode.cn/problems/valid-parentheses/\" title=\"20. 有效的括号\">20. 有效的括号</a></h1>\n<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br/> 左括号必须以正确的顺序闭合。<br/> 每个右括号都有一个对应的相同类型的左括号。</p>\n<p>示例 1：</p>\n<p>输入：s = \"()\"<br/> 输出：true<br/> 示例 2：</p>\n<p>输入：s = \"()[]{}\"<br/> 输出：true<br/> 示例 3：</p>\n<p>输入：s = \"(]\"<br/> 输出：false</p>\n<blockquote>\n<p>这个题我们需要判断所给的字符串中的前后括号是否能成对存在，也就是一一对应的关系。</p>\n<p></p>\n<p>既然括号是成对存在并且我们只需要判断对错，根据括号一一对应的性质我们考虑红使用栈的方法来解决，遍历的时候出现左括号我们就将对应的右括号入栈，利用栈的同进同出的性质，当遍历到右括号时如果右括号存在且在栈顶，我们就出栈如果没有或不是同一种类我们就出栈</p>\n</blockquote>\n<p>代码实现</p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isValid(String s) {\n     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n    char[] chars = s.toCharArray();\n    //遍历所有的元素\n    for (char c : chars) {\n        //如果是左括号，就把他们对应的右括号压栈\n        if (c == '(') {\n            stack.push(')');\n        } else if (c == '{') {\n            stack.push('}');\n        } else if (c == '[') {\n            stack.push(']');\n        } else if (stack.isEmpty() || stack.pop() != c) {\n            //否则就只能是右括号。\n            //1，如果栈为空，说明括号无法匹配。\n            //2，如果栈不为空，栈顶元素就要出栈，和这个右括号比较。\n            //如果栈顶元素不等于这个右括号，说明无法匹配，\n            //直接返回false。\n            return false;\n        }\n    }\n    //最后如果栈为空，说明完全匹配，是有效的括号。\n    //否则不完全匹配，就不是有效的括号\n    return stack.isEmpty();\n\n\n    }\n}</code></pre>\n<h1 id=\"%C2%A021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\"> <a href=\"https://leetcode.cn/problems/merge-two-sorted-lists/\" title=\"21. 合并两个有序链表\">21. 合并两个有序链表</a></h1>\n<p><img alt=\"\" height=\"721\" src=\"..\\..\\static\\image\\730479806c094cf4aafd61a11eecbb45.png\" width=\"724\"/></p>\n<p>这个题我们要合并两个有序链表，我们新建一个链表，只要有一个链表没完我们就不停，比对两个链表当前节点的大小，将小的接入新建链表，一个链表空了就直接接入未空链表。</p>\n<p> 代码实现</p>\n<pre><code class=\"language-java\">/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode cur = dummyHead;\n        while (list1 != null &amp;&amp; list2 != null) {\n            if (list1.val &lt; list2.val) {\n                cur.next = list1;\n                cur = cur.next;\n                list1 = list1.next;\n            } else {\n                cur.next = list2;\n                cur = cur.next;\n                list2 = list2.next;\n            }\n        }\n        // 任一为空，直接连接另一条链表\n        if (list1 == null) {\n            cur.next = list2;\n        } else {\n            cur.next = list1;\n        }\n        return dummyHead.next;\n    }\n}</code></pre>\n<h1 id=\"26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9\"><a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array/\" title=\"26. 删除有序数组中的重复项\">26. 删除有序数组中的重复项</a></h1>\n<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>\n<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>\n<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>\n<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<p>判题标准:</p>\n<p>系统会用下面的代码来测试你的题解:</p>\n<p>int[] nums = [...]; // 输入数组<br/> int[] expectedNums = [...]; // 长度正确的期望答案</p>\n<p>int k = removeDuplicates(nums); // 调用</p>\n<p>assert k == expectedNums.length;<br/> for (int i = 0; i &lt; k; i++) {<!-- --><br/>     assert nums[i] == expectedNums[i];<br/> }<br/> 如果所有断言都通过，那么您的题解将被 通过。</p>\n<p></p>\n<p>示例 1：</p>\n<p>输入：nums = [1,1,2]<br/> 输出：2, nums = [1,2,_]<br/> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br/> 示例 2：</p>\n<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br/> 输出：5, nums = [0,1,2,3,4]<br/> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>\n<p>        </p>\n<blockquote>\n<p>使用双指针，这题第一遍做过了，i来存数字，j来遍历数组，j != i, i++ 并将j对应的值赋给 i。遍历完成后j会遍历到数组尾部，有几个不同的数字i的下标就是i-1。</p>\n</blockquote>\n<p> </p>\n<p>代码实现</p>\n<pre><code class=\"language-java\">class Solution {\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        for(int j = 1;j &lt; nums.length; j++){\n            if(nums[i] != nums[j]){\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i+1;\n    }\n}</code></pre>\n<h1 id=\"2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0\"><a href=\"https://leetcode.cn/problems/add-two-numbers/\" title=\"2. 两数相加\">2. 两数相加</a></h1>\n<p><img alt=\"\" height=\"682\" src=\"..\\..\\static\\image\\3a995feb75be477fbd7573fefb008eaf.png\" width=\"655\"/></p>\n<blockquote>\n<p> 看他那提示就能看出来其实就是写反过来的两个数相加，只不过我们输出的时候相加的结果也是反过来的 既然要反过来我们就直接反着做，返回值类型是链表也不用考虑位数，那我们直接把链表当前节点进行相加，对10取余的到个位，把这个数加进新链表，十位如果有进位就再当前节点和的基础上加入进位。这个题的关键就是要考虑到进位的问题</p>\n</blockquote>\n<p>代码实现</p>\n<pre><code class=\"language-java\">/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        //新链表，头结点\n        ListNode blindNode = new ListNode(0);\n        //pre为当前节点的前一个节点\n        ListNode preNode = blindNode;\n        int curry = 0;//curry来放进位的数\n    while(l1 != null || l2 != null || curry != 0){\n        int sum = curry;//\n        if(l1 != null){//第一个链表\n            sum = sum + l1.val;\n            l1 = l1.next;\n        }\n         if(l2 != null){//第二个\n            sum = sum + l2.val;\n            l2 = l2.next;\n        }\n        preNode.next = new ListNode(sum % 10);//个位\n        curry = sum /10;//十位\n        preNode = preNode.next;\n    }\n    return blindNode.next;\n    }\n}</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-06 16:45:38", "summary": "个人主页：天海奈奈的博客天海奈奈的博客刷题专栏：题库力扣全球极客挚爱的技术成长平台题库力扣全球极客挚爱的技术成长平台面试刷题网站力扣力扣让我们一起加油目录有效的括号合并两个有序链表删除有序数组中的重复"}