{"blogid": "126561938", "writerAge": "码龄1年", "writerBlogNum": "179", "writerCollect": "578", "writerComment": "615", "writerFan": "717", "writerGrade": "5级", "writerIntegral": "3633", "writerName": "一个风轻云淡", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126561938.jpg", "writerRankTotal": "5524", "writerRankWeekly": "82", "writerThumb": "741", "writerVisitNum": "45822", "blog_read_count": "521", "blog_time": "于 2022-08-27 20:24:29 发布", "blog_title": "SpringMVC执行流程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>SpringMVC常用组件</strong></p>\n<p><strong><span style=\"color:#1c7331;\">DispatcherServlet：前端控制器，不需要工程师开发，由框架提供<br/> 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</span></strong><br/><span style=\"color:#1a439c;\"><strong>HandlerMapping：处理器映射器，不需要工程师开发，由框架提供</strong></span></p>\n<p><strong><span style=\"color:#1a439c;\">作用：根据请求的url、method等信息查找Handler，即控制器方法</span><br/><span style=\"color:#be191c;\">Handler：处理器，需要工程师开发<br/> 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</span><br/><span style=\"color:#511b78;\">HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供<br/> 作用：通过HandlerAdapter对处理器（控制器方法）进行执行</span><br/><span style=\"color:#be191c;\">ViewResolver：视图解析器，不需要工程师开发，由框架提供<br/> 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、</span><br/><span style=\"color:#be191c;\">RedirectView</span><br/><span style=\"color:#1c7331;\">View：视图<br/> 作用：将模型数据通过页面展示给用户</span></strong></p>\n<h3>DispatcherServlet初始化过程 </h3>\n<p> DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet生命周期来进行调度。</p>\n<p><img alt=\"\" height=\"1018\" src=\"..\\..\\static\\image\\69733e97874942bcb061df1b68bf0fd5.png\" width=\"1137\"/></p>\n<p><img alt=\"\" height=\"622\" src=\"..\\..\\static\\image\\a46d6ad6b97647938b1654cfc816615c.png\" width=\"1200\"/> </p>\n<p><span style=\"color:#1c7892;\"><strong> 初始化WebApplicationContext</strong></span></p>\n<p><span style=\"color:#ad720d;\"><strong>所在类：org.springframework.web.servlet.FrameworkServle</strong></span></p>\n<p> </p>\n<pre><code class=\"language-java\">protected WebApplicationContext initWebApplicationContext() {\nWebApplicationContext rootContext =\nWebApplicationContextUtils.getWebApplicationContext(getServletContext());\nWebApplicationContext wac = null;\nif (this.webApplicationContext != null) {\n// A context instance was injected at construction time -&gt; use it\nwac = this.webApplicationContext;\nif (wac instanceof ConfigurableWebApplicationContext) {\nConfigurableWebApplicationContext cwac =\n(ConfigurableWebApplicationContext) wac;\nif (!cwac.isActive()) {\n// The context has not yet been refreshed -&gt; provide services\nsuch as\n// setting the parent context, setting the application context\nid, etc\nif (cwac.getParent() == null) {\n// The context instance was injected without an explicit\nparent -&gt; set\n// the root application context (if any; may be null) as the\nparent\ncwac.setParent(rootContext);\n}\nconfigureAndRefreshWebApplicationContext(cwac);\n}\n}\n}\nif (wac == null) {\n// No context instance was injected at construction time -&gt; see if one\n// has been registered in the servlet context. If one exists, it is\nassumed\n// that the parent context (if any) has already been set and that the\n// user has performed any initialization such as setting the context id\nwac = findWebApplicationContext();\n}\nif (wac == null) {\n// No context instance is defined for this servlet -&gt; create a local one\n// 创建WebApplicationContext\nwac = createWebApplicationContext(rootContext);\n}\nif (!this.refreshEventReceived) {\n// Either the context is not a ConfigurableApplicationContext with\nrefresh\n// support or the context injected at construction time had already been\n// refreshed -&gt; trigger initial onRefresh manually here.\nsynchronized (this.onRefreshMonitor) {\n// 刷新WebApplicationContext\nonRefresh(wac);\n}\n}\nif (this.publishContext) {\n// Publish the context as a servlet context attribute.\n// 将IOC容器在应用域共享\nString attrName = getServletContextAttributeName();\ngetServletContext().setAttribute(attrName, wac);\n}\nreturn wac;\n}</code></pre>\n<p><span style=\"color:#1c7892;\"><strong> ②创建WebApplicationContext</strong></span></p>\n<p><strong>所在类：org.springframework.web.servlet.FrameworkServlet </strong></p>\n<pre><code class=\"language-java\">protected WebApplicationContext createWebApplicationContext(@Nullable\nApplicationContext parent) {\nClass&lt;?&gt; contextClass = getContextClass();\nif (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass))\n{\nthrow new ApplicationContextException(\n\"Fatal initialization error in servlet with name '\" +\ngetServletName() +\n\"': custom WebApplicationContext class [\" + contextClass.getName() +\n\"] is not of type ConfigurableWebApplicationContext\");\n}\n// 通过反射创建 IOC 容器对象\nConfigurableWebApplicationContext wac =\n(ConfigurableWebApplicationContext)\nBeanUtils.instantiateClass(contextClass);\nwac.setEnvironment(getEnvironment());\n// 设置父容器\nwac.setParent(parent);\nString configLocation = getContextConfigLocation();\nif (configLocation != null) {\nwac.setConfigLocation(configLocation);\n}\nconfigureAndRefreshWebApplicationContext(wac);\nreturn wac;\n}</code></pre>\n<p><br/><span style=\"color:#1c7892;\"><strong>③DispatcherServlet初始化策略</strong></span><br/><strong>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化<br/> DispatcherServlet的各个组件<br/> 所在类：org.springframework.web.servlet.DispatcherServlet</strong></p>\n<pre><code class=\"language-java\">protected void initStrategies(ApplicationContext context) {\ninitMultipartResolver(context);\ninitLocaleResolver(context);\ninitThemeResolver(context);\ninitHandlerMappings(context);\ninitHandlerAdapters(context);\ninitHandlerExceptionResolvers(context);\ninitRequestToViewNameTranslator(context);\ninitViewResolvers(context);\ninitFlashMapManager(context);\n}</code></pre>\n<h3>SpringMVC的执行流程 </h3>\n<p><strong><span style=\"color:#fe2c24;\">用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</span><br/> 2) DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：<br/><span style=\"color:#1c7331;\">a) 不存在<br/> i. 再判断是否配置了mvc:default-servlet-handler<br/> ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</span></strong></p>\n<p><img alt=\"\" height=\"423\" src=\"..\\..\\static\\image\\5f307f1d195840af8d7c27eba84a154f.png\" width=\"1200\"/></p>\n<p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 </p>\n<p><img alt=\"\" height=\"450\" src=\"..\\..\\static\\image\\cb728bc874184ed593faab0d1af5932e.png\" width=\"1200\"/></p>\n<p><strong><span style=\"color:#1c7892;\">b) 存在则执行下面的流程<br/> 3) 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。<br/> 4) DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。<br/> 5) 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(...)方法【正向】</span><br/><span style=\"color:#1a439c;\">6) 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：<br/> a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</span><br/><span style=\"color:#1c7892;\">b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等<br/> c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等<br/> d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中<br/> 7) Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</span><br/><span style=\"color:#b95514;\">8) 此时将开始执行拦截器的postHandle(...)方法【逆向】。<br/> 9) 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行<br/> HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model<br/> 和View，来渲染视图。<br/> 10) 渲染视图完毕执行拦截器的afterCompletion(...)方法【逆向】。<br/> 11) 将渲染结果返回给客户端。 </span></strong></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-27 20:24:29", "summary": "常用组件：前端控制器，不需要工程师开发，由框架提供作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求：处理器映射器，不需要工程师开发，由框架提供作用：根据请求的、等信息查找，"}