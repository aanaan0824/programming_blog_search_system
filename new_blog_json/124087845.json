{"blogid": "124087845", "writerAge": "码龄3年", "writerBlogNum": "485", "writerCollect": "1744", "writerComment": "200", "writerFan": "836", "writerGrade": "6级", "writerIntegral": "6451", "writerName": "小段学长", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124087845.jpg", "writerRankTotal": "2396", "writerRankWeekly": "21265", "writerThumb": "805", "writerVisitNum": "339570", "blog_read_count": "4465", "blog_time": "于 2022-04-10 22:43:47 发布", "blog_title": "双亲委派机制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>双亲委派机制定义：</h2>\n<p>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。<br/> Java中提供如下四种类型的加载器，每一种加载器都有指定的加载对象，具体如下<br/> Bootstrap ClassLoader（启动类加载器） ：主要负责加载Java核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。<br/> Extention ClassLoader（扩展类加载器）：主要负责加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。<br/> Application ClassLoader（应用程序类加载器） ：主要负责加载当前应用的classpath下的所有类<br/> User ClassLoader（用户自定义类加载器） ： 用户自定义的类加载器,可加载指定路径的class文件<br/> 这四种类加载器存在如下关系，当进行类加载的时候，虽然用户自定义类不会由bootstrap classloader或是extension classloader加载（由类加载器的加载范围决定），但是代码实现还是会一直委托到bootstrap classloader, 上层无法加载，再由下层是否可以加载，如果都无法加载，就会触发findclass,抛出classNotFoundException.<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f18d3841947640f192d5e72d02af9fd6.png\"/></p>\n<p>注意：这里存在的加载器之间的层级关系并不是以继承的方式存在的，而是以组合的方式处理的。如下是classLoader源码。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9d471a43675b4595bc764395279a8b56.png\"/></p>\n<h2><a id=\"_14\"></a>双亲委派机制存在的意义：</h2>\n<p>1.通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。<br/> 2.通过双亲委派的方式，还保证了安全性。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。<br/> 双亲委派机制是在classLoader里的loadclass方法里实现的，<br/> 源码：<br/> 简单说下实现流程：</p>\n<ol><li>首先判断该类是否已经被加载<br/> 2.该类未被加载，如果父类不为空，交给父类加载<br/> 3.如果父类为空，交给bootstrap classloader 加载<br/> 4.如果类还是无法被加载到，则触发findclass,抛出classNotFoundException(findclass这个方法当前只有一个语句，就是抛出classNotFoundException），如果想自己实现类加载器的话，可以继承classLoader后重写findclass方法，加载对应的类）</li></ol>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">protected</span> <span class=\"token class-name\">ClassloadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getClassLoadingLock</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">// First, check if the class has already been loaded</span>\n        <span class=\"token class-name\">Class</span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">long</span> t0 <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\nc <span class=\"token operator\">=</span>parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\nc <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">// ClassNotFoundException thrown if class not found</span>\n<span class=\"token comment\">// from the non-null parent class loader</span>\n            <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">// If still not found, then invoke findClass in order</span>\n<span class=\"token comment\">// to find the class.</span>\n                <span class=\"token keyword\">long</span> t1 <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">// this is the defining class loader; record the stats</span>\n                <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getParentDelegationTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addTime</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFindClassTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addElapsedTimeFrom</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>PerfCounter</span><span class=\"token punctuation\">.</span><span class=\"token function\">getFindClasses</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token function\">resolveClass</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"_64\"></a>总结：</h2>\n<p>双亲委派机制有他存在的意义，不过也存在许多场景是需要破坏这个机制的，所以双亲委派机制也非必然。比如 tomcat web容器里面部署了很多的应用程序，但是这些应用程序对于第三方类库的依赖版本却不一样，但这些第三方类库的路径又是一样的，如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。<br/> Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。<br/> <em><strong>欢迎大家加我微信交流讨论（请备注csdn上添加）</strong></em><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a9d6f9f8803b4df39e9af0d282b69398.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-10 22:43:47", "summary": "双亲委派机制定义：当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。中提"}