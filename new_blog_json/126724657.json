{"blogid": "126724657", "writerAge": "码龄3年", "writerBlogNum": "39", "writerCollect": "205", "writerComment": "252", "writerFan": "363", "writerGrade": "4级", "writerIntegral": "1166", "writerName": "枫玄雾隐", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126724657.jpg", "writerRankTotal": "27857", "writerRankWeekly": "333", "writerThumb": "314", "writerVisitNum": "2619", "blog_read_count": "204", "blog_time": "于 2022-09-06 15:32:45 发布", "blog_title": "ES6笔记————let，箭头函数，剩余参数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.let%2Cvar%2Cconst%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.let%2Cvar%2Cconst%E5%8C%BA%E5%88%AB\">一.let,var,const区别</a></p>\n<p id=\"let-toc\" style=\"margin-left:40px;\"><a href=\"#let\">let</a></p>\n<p id=\"const-toc\" style=\"margin-left:40px;\"><a href=\"#const\">const</a></p>\n<p id=\"%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8C%BA%E5%88%AB\">区别</a></p>\n<p id=\"%E4%BA%8C%EF%BC%8C%E8%A7%A3%E6%9E%84%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%EF%BC%8C%E8%A7%A3%E6%9E%84%C2%A0\">二，解构 </a></p>\n<p id=\"1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84-toc\" style=\"margin-left:40px;\"><a href=\"#1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84\">1 数组解构</a></p>\n<p id=\"2%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84-toc\" style=\"margin-left:40px;\"><a href=\"#2%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84\">2对象解构</a></p>\n<p id=\"%E4%B8%89%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%C2%A0\">三，箭头函数 </a></p>\n<p id=\"1%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#1%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\">1 基础语法</a></p>\n<p id=\"2%20%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#2%20%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95\">2 省略写法</a></p>\n<p id=\"3%C2%A0%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84this-toc\" style=\"margin-left:40px;\"><a href=\"#3%C2%A0%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84this\">3 对象方法里的this</a></p>\n<p id=\"4%20apply%2Fcall%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84this-toc\" style=\"margin-left:40px;\"><a href=\"#4%20apply%2Fcall%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84this\">4 apply/call调用时的this</a></p>\n<p id=\"5%C2%A0%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis-toc\" style=\"margin-left:40px;\"><a href=\"#5%C2%A0%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis\">5 箭头函数中this</a></p>\n<p id=\"8%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#8%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8\">8 箭头函数应用</a></p>\n<p id=\"%E5%9B%9B%EF%BC%8C%E5%89%A9%E4%BD%99%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%EF%BC%8C%E5%89%A9%E4%BD%99%E5%87%BD%E6%95%B0\">四，剩余函数</a></p>\n<hr id=\"hr-toc\"/>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\9a3b076fef5c4de99504aed2c754f341.jpeg\"/></p>\n<p> </p>\n<blockquote>\n<h1 id=\"%E4%B8%80.let%2Cvar%2Cconst%E5%8C%BA%E5%88%AB\"><span style=\"color:#7b7f82;\"><span style=\"background-color:#eaf4fc;\">一.let,var,const区别</span></span></h1>\n</blockquote>\n<p></p>\n<h2 id=\"let\" style=\"margin-left:0px;text-align:justify;\"><span style=\"color:#ffd900;\">let </span></h2>\n<h3 id=\"%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%9D%A5%E5%A3%B0%E6%98%8E%E5%9D%97%E7%BA%A7%E5%8F%98%E9%87%8F%E3%80%82\" style=\"margin-left:0px;text-align:justify;\">关键字用来声明块级变量。</h3>\n<h3 id=\"--%20%E7%89%B9%E7%82%B9%E5%B0%B1%E6%98%AF%E5%9C%A8%7B%7D%E5%A3%B0%E6%98%8E%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cvar%E5%8F%98%E9%87%8F%E6%97%A0%E6%AD%A4%E7%89%B9%E7%82%B9%E3%80%82\" style=\"margin-left:0px;text-align:justify;\">-- 特点就是在{}声明具有块级作用域，var变量无此特点。</h3>\n<h3 id=\"--%20%E9%98%B2%E6%AD%A2%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E7%BC%96%E7%A8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%82\" style=\"margin-left:0px;text-align:justify;\">-- 防止循环变量编程全局变量。</h3>\n<h3 id=\"--%20let%20%E5%85%B3%E9%94%AE%E8%AF%8D%E6%97%A0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%82\" style=\"margin-left:0px;text-align:justify;\">-- let 关键词无变量提升。</h3>\n<h3 id=\"--%20let%20%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9C%89%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%82%7B%E5%85%88%E5%A3%B0%E6%98%8E%E5%90%8E%E4%BD%BF%E7%94%A8%7D\" style=\"margin-left:0px;text-align:justify;\">-- let 关键词有暂时性死区的特点。{先声明后使用}</h3>\n<h2 id=\"const\"><span style=\"color:#ffd900;\">const</span></h2>\n<h3 id=\"%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%E5%B0%B1%E6%98%AF%E5%80%BC%EF%BC%88%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%EF%BC%89%E4%B8%8D%E8%83%BD%E5%8F%98%E5%8C%96%E7%9A%84%E9%87%8F%E3%80%82\" style=\"margin-left:0px;text-align:justify;\"><strong>声明常量，常量就是值（内存地址）不能变化的量。</strong></h3>\n<h3 id=\"%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%BA%AB%E6%98%AF%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98\">对象的本身是可变的，所以可以添加属性，但是地址不可改变</h3>\n<h2 id=\"%E5%8C%BA%E5%88%AB\"><span style=\"color:#ffd900;\">区别</span></h2>\n<h3 id=\"%C2%A0%E4%BD%BF%E7%94%A8%20var%20%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%85%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%BA%E8%AF%A5%E8%AF%AD%E5%8F%A5%E6%89%80%E5%9C%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%85%EF%BC%8C%E4%B8%94%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%8E%B0%E8%B1%A1\" style=\"margin-left:0px;text-align:justify;\"> 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</h3>\n<h3 id=\"-%20%E4%BD%BF%E7%94%A8%20let%20%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%85%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%BA%E8%AF%A5%E8%AF%AD%E5%8F%A5%E6%89%80%E5%9C%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87\" style=\"margin-left:0px;text-align:justify;\">- 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</h3>\n<h3 id=\"-%20%E4%BD%BF%E7%94%A8%20const%20%E5%A3%B0%E6%98%8E%E7%9A%84%E6%98%AF%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%86%8D%E4%BF%AE%E6%94%B9%E8%AF%A5%E5%B8%B8%E9%87%8F%E7%9A%84%E5%80%BC\" style=\"margin-left:0px;text-align:justify;\">- 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</h3>\n<h3 id=\"-%20%E4%BD%BF%E7%94%A8let%EF%BC%8Cconst%E7%9A%84%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8D%E5%B1%9E%E6%80%A7%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%94%E5%9B%9Eundefined%E3%80%82\" style=\"margin-left:0px;text-align:justify;\"><strong>- </strong><strong>使用</strong><strong>let</strong><strong>，</strong><strong>const</strong><strong>的声明的变量不属性顶层对象，返回</strong><strong>undefined</strong><strong>。</strong></h3>\n<blockquote>\n<h1 id=\"%E4%BA%8C%EF%BC%8C%E8%A7%A3%E6%9E%84%C2%A0\"><span style=\"color:#7b7f82;\"><span style=\"background-color:#eaf4fc;\">二，解构</span></span> </h1>\n</blockquote>\n<h2 id=\"1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84\" style=\"margin-left:0px;text-align:justify;\"><strong>1 </strong><strong>数组解构</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\">let [x, y, ...z] = ['a'];</p>\n<p style=\"margin-left:0;text-align:justify;\">x // \"a\"</p>\n<p style=\"margin-left:0;text-align:justify;\">y // undefined</p>\n<p style=\"margin-left:0;text-align:justify;\">z // []</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">let[a,...c] = [1,2,3];//合并运算符可以展开数组也可合并数组</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(c);//[2, 3]</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(...c);//2 3</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">let [x,y='2'] = ['a',undefined];</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(y);//如果没有定义，可以用默认值</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>说明：</strong>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员<strong>严格等于undefined，默认值才会生效。</strong></p>\n<h2 id=\"2%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84\" style=\"margin-left:0px;text-align:justify;\"><strong>2对象解构</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\"><strong>根据key解构</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">let person = {name:\"小帅\",age:18};</p>\n<p style=\"margin-left:0;text-align:justify;\">let {name,age,height} = person;</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(name);//小帅</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(age);//18</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(height);//undefined</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#FF0000;\">说明：</span></strong>对象的解构与数组有一个重要的不同。数组的元素是按顺序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值，否则解构失败就是undefined。</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">let { realname: myname,height=173 } = { realname: '张三', age: 18};</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(Myname);//张三</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(Myage)//18</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(realname)//realname is not defined</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(height)//当属性没有的时候支持默认值</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#FF0000;\">说明：</span></strong>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>.3 </strong><strong>字符串解构</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">let [a,b,c] = \"hello\";</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(a);//h</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(b);//e</p>\n<p style=\"margin-left:0;text-align:justify;\">console.log(c);//l</p>\n<blockquote>\n<h1 id=\"%E4%B8%89%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%C2%A0\" style=\"margin-left:0px;text-align:justify;\"><span style=\"color:#7b7f82;\"><span style=\"background-color:#eaf4fc;\">三，箭头函数</span></span> </h1>\n</blockquote>\n<h2 id=\"1%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\" style=\"margin-left:0px;text-align:justify;\"><strong>1 </strong><strong>基础语法</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\">//原js写法</p>\n<p style=\"margin-left:0;text-align:justify;\">function myFun(k,v){   </p>\n<p style=\"margin-left:0;text-align:justify;\">        return k + v;</p>\n<p style=\"margin-left:0;text-align:justify;\">}</p>\n<p style=\"margin-left:0;text-align:justify;\">//es6 写法</p>\n<p style=\"margin-left:0;text-align:justify;\">const myFun1 = (k,v) =&gt; {<!-- --></p>\n<p style=\"margin-left:0;text-align:justify;\">        return k+v;</p>\n<p style=\"margin-left:0;text-align:justify;\">}</p>\n<h2 id=\"2%20%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95\" style=\"margin-left:0px;text-align:justify;\"><strong>2 </strong><strong>省略写法</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">如果形参或者代码块只有一句可以简写：</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">Const myFun = (k) =&gt; {return k+1;} 简写：</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">Const myFun = k =&gt;  k +1;</p>\n<h2 id=\"3%C2%A0%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84this\" style=\"margin-left:0px;text-align:justify;\"><strong>3 </strong><strong>对象方法里的</strong><strong>this</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">如果函数作为对象的方法调用，this指向的是这个上级对象，即调用方法的对象。</p>\n<p style=\"margin-left:0;text-align:justify;\">const person = {<!-- --></p>\n<p style=\"margin-left:0;text-align:justify;\">                           name:\"张三\",</p>\n<p style=\"margin-left:0;text-align:justify;\">                           age:18,</p>\n<p style=\"margin-left:0;text-align:justify;\">                           say:function(){<!-- --></p>\n<p style=\"margin-left:0;text-align:justify;\">                                  console.log(this.name);// 张三 这时候的this是person的对象</p>\n<p style=\"margin-left:0;text-align:justify;\">                           }</p>\n<p style=\"margin-left:0;text-align:justify;\"> }</p>\n<p style=\"margin-left:0;text-align:justify;\">person.say();</p>\n<h2 id=\"4%20apply%2Fcall%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84this\" style=\"margin-left:0px;text-align:justify;\"><strong>4 apply/call</strong><strong>调用时的</strong><strong>this</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\">myfun1();//对象是Windows</p>\n<p style=\"margin-left:0;text-align:justify;\">myfun1.call(person1);//对象改变为person1</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">说明：两者的区别，myfun.call(person,18,29); myfun.apply(person,[18,29]);</p>\n<h2 id=\"5%C2%A0%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis\" style=\"margin-left:0px;text-align:justify;\"><strong>5 </strong><strong>箭头函数中</strong><strong>this</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\">箭头函数不绑定this关键字，箭头函数中的this，<strong>指向的是函数定义位置的上下文this。</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">箭头函数中的this指向是它所定义（声明）的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁。</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">const obj = { name: '张三'}</p>\n<p style=\"margin-left:0;text-align:justify;\">                 function fn () {<!-- --></p>\n<p style=\"margin-left:0;text-align:justify;\">                         console.log(this);//this 指向 是obj对象</p>\n<p style=\"margin-left:0;text-align:justify;\">                         return () =&gt; {<!-- --></p>\n<p style=\"margin-left:0;text-align:justify;\">                                 console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</p>\n<p style=\"margin-left:0;text-align:justify;\">                         }</p>\n<p style=\"margin-left:0;text-align:justify;\">                 }</p>\n<p style=\"margin-left:0;text-align:justify;\">               </p>\n<p style=\"margin-left:0;text-align:justify;\">const resFn = fn.call(obj); //{ name: '张三'}</p>\n<p style=\"margin-left:0;text-align:justify;\">resFn();//{ name: '张三'}</p>\n<pre><code class=\"language-javascript\">一：全局作用域下this指向\n\t\t\t1:普通函数\n\t\t\tfunction global(){\n\t\t\t\tconsole.log(this);//window\n\t\t\t}\n\t\t\tglobal();\n\t\t\t2：箭头函数\n\t\t\tconst global = ()=&gt;{\n\t\t\t\tconsole.log(this);//window\n\t\t\t}\n\t\t\tglobal();\n\t\t\t\n\t\t\t\n\t\t\t二：对象里面的this指向\n\t\t\t1:普通函数\n\t\t\tconst Person = {realname:\"张三\",age:19,\n\t\t\t   say:function(){\n\t\t\t\t   console.log(this.realname);//当前的对象 \"张三\"\n\t\t\t   }\n\t\t\t}\n\t\t\tPerson.say();\n\t\t\t\n\t\t\t2:箭头函数\n\t\t\tconst Person = {realname:\"张三\",age:19,\n\t\t\t   say:()=&gt;{\n\t\t\t\t   console.log(this);//window\n\t\t\t   }\n\t\t\t}\n\t\t\tPerson.say();\n\t\t\t\n\t\t\t三：构造函数的this指向\n\t\t\t1:普通函数\n\t\t\t\n\t\t\tfunction  Person(realname,age){\n\t\t\t\tthis.realname = realname;\n\t\t\t\tthis.age = age;\n\t\t\t\tthis.say = function(){\n\t\t\t\t\tconsole.log(this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst P1 = new Person(\"张三\",19);\n\t\t\tP1.say();\n\t\t\t\n\t\t\tconst P2 = new Person(\"李四\",19);\n\t\t\tP2.say.call(P1);//原来李四，现在是张三 call和apply改变this指向，区别传输参数的区别\n\t\t\t\n\t\t\t\n\t\t\t2:箭头函数\n\t\t\t\n\t\t\tfunction  Person(realname,age){\n\t\t\t\tthis.realname = realname;\n\t\t\t\tthis.age = age;\n\t\t\t\tthis.say = ()=&gt;{\n\t\t\t\t\tconsole.log(this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst P1 = new Person(\"张三\",19); \n\t\t\tP1.say();\n\n\t\t\tconst P2 = new Person(\"李四\",19);\n\t\t\tP2.say.call(P1);//不能改变箭头函数的this指向\n\t\t\t\n\t\t\t\n\t\t\t总结：普通函数与箭头函数this的区别\n\t\t\t1：普通的函数this与调用者有关，调用者是谁就是谁;\n\t\t\t2：箭头函数的this与当时定义的上下文的this有关，this是静态的一旦定义了就无法改变\n\t\t\t</code></pre>\n<h2 id=\"8%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8\" style=\"margin-left:0px;text-align:justify;\"><strong>8 </strong><strong>箭头函数应用</strong></h2>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>练习</strong><strong>1</strong><strong>：</strong>单击按钮2s后改变按钮文字：按钮被点击，在单击按钮改变文字：点击被取消。</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;!-- 点击按钮   2s后显示：文字被点击，在点击出现文字：点击被取消。 --&gt;\n&lt;!-- （附加：点击10次后提示“今日点击次数已上限，按钮变成灰色”） --&gt;\n\n&lt;body&gt;\n    &lt;button&gt;点击&lt;/button&gt;\n    &lt;script&gt;\n        let bth = document.querySelector(\"button\")\n        let flag = false\n        let num=0\n        bth.addEventListener(\"click\", function () {\n            flag = !flag\n            num++\n            if(num&gt;10){   \n                this.innerHTML=\"今日点击次数已上限\"\n                this.disabled=true\n                this.style.backgroundColor=\"grey\"\n                return false\n            }\n            time1=setTimeout(() =&gt; { \n                if (flag) {\n                    // console.log(this);\n                    this.innerHTML=\"文字被点击\"\n                }\n                else{\n                    this.innerHTML=\"点击被取消\"\n                }\n            }, 100);\n\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<blockquote>\n<h1 id=\"%E5%9B%9B%EF%BC%8C%E5%89%A9%E4%BD%99%E5%87%BD%E6%95%B0\" style=\"margin-left:0px;text-align:justify;\"><span style=\"color:#7b7f82;\"><span style=\"background-color:#eaf4fc;\">四，剩余函数</span></span></h1>\n</blockquote>\n<p style=\"margin-left:0;text-align:justify;\">剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数。</p>\n<pre><code class=\"language-javascript\">1:rest参数\n\t\t\tfunction demo(...nums){\n\t\t\t\tconsole.log(nums);//数组\n\t\t\t\tconsole.log(...nums);//解构数组\n\t\t\t}\n\t\t\tdemo(1,2,3);\n\t\t\t\n\t\t\t2:rest参数 对象\n\t\t\tfunction connect({username,...info}){\n\t\t\t\tconsole.log(username);\n\t\t\t\tconsole.log(info);\n\t\t\t}\n\t\t\tconnect(\n\t\t\t   {username:\"root\",password:\"123456\",port:\"3306\"}\n\t\t\t)\n\t\t\t\n\t\t\t3:输出数组\n\t\t\tconst arr = [1,2,3];\n\t\t\tconsole.log(...arr);\n\t\t\t\n\t\t\t4:合并两个数组\n\t\t\tconst arr1 = [1,2,3];\n\t\t\tconst arr2 = [4,5,6];\n\t\t\tconsole.log([...arr1,...arr2]);\n\t\t\t\n\t\t\t\n\t\t\t5:将类数组转为数组\n\t\t\tconst liNode = document.querySelectorAll(\"li\");\n\t\t\tconsole.log(typeof [...liNode]);\n\t\t\t\n\t\t\tconst arr1 =  [1,2,3];\n\t\t\tconst arr2 =  [...arr1];//复制数组\n\t\t\tarr1[0] = 10;\n\t\t\tconsole.log(arr2);\n\t\t\t\n\t\t\t\n\t\t\t6:剩余参数必须放入最后(rest参数) 不然报错\n\t\t\tfunction demo(a,b,...nums){\n\t\t\t\tconsole.log(nums);//数组\n\t\t\t}\n\t\t\tdemo(1,2,3,4,5);</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 15:32:45", "summary": "目录一区别区别二，解构数组解构对象解构三，箭头函数基础语法省略写法对象方法里的调用时的箭头函数中箭头函数应用四，剩余函数一区别关键字用来声明块级变量。特点就是在声明具有块级作用域，变量无此特点。防止循"}