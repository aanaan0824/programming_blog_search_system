{"blogid": "123801017", "writerAge": "码龄1年", "writerBlogNum": "76", "writerCollect": "152", "writerComment": "19", "writerFan": "174", "writerGrade": "4级", "writerIntegral": "992", "writerName": "__JAN__", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123801017.jpg", "writerRankTotal": "18506", "writerRankWeekly": "215917", "writerThumb": "44", "writerVisitNum": "52239", "blog_read_count": "9793", "blog_time": "已于 2022-06-06 08:17:16 修改", "blog_title": "C++——模板（超详细的模板解析）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>模板是一个非常强大的C++功能，STL的各种组件也是基于模板的。所以，无论是写程序了，还是读程序，都有必要了解一下C++的模板。</p>\n<p>关于什么是模板或者模板的基本定义，这里就不讲述了，本篇文章主要罗列出在使用模板过程中的一些问题和模板一些令人头疼的语法，并配合简单的demo，如果你只是希望查阅语法或者了解一些知识点，这篇文章可能会帮到你。</p>\n<p>声明：使用了using namespace std。对于应该包含进来的头文件，不再显示的声明。文中所有demo均经过测试。本文章基于《C++ Primer Plus》和《C++ Prime》。</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89\">模板的基本声明和定义</a></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E\">模板的声明</a></p>\n<p id=\"%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0\">定义一个模板函数</a></p>\n<p id=\"%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB\">定义一个模板类</a></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\">模板参数作用域</a></p>\n<p id=\"%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\">关于模板工作原理</a></p>\n<p id=\"%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0\">非类型模板参数</a></p>\n<p id=\"inline%E5%92%8Cconstexp-toc\" style=\"margin-left:80px;\"><a href=\"#inline%E5%92%8Cconstexp\">inline和constexp</a></p>\n<p id=\"%C2%A0%E5%9C%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E5%9C%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB\"> 在模板类中使用模板类</a></p>\n<p id=\"%C2%A0%E5%8F%8B%E5%85%83%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E5%8F%8B%E5%85%83%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB\"> 友元与模板类</a></p>\n<p id=\"%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82\">默认模板实参</a></p>\n<p id=\"%3A%C2%A0%3A%20%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3-toc\" style=\"margin-left:80px;\"><a href=\"#%3A%C2%A0%3A%20%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3\">: : 二义性的解决</a></p>\n<p id=\"%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">类模板成员函数</a></p>\n<p id=\"%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%C2%A0\">类模板的成员模板 </a></p>\n<p id=\"%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%BC%98%E5%8C%96%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%BC%98%E5%8C%96%C2%A0\">实例化优化 </a></p>\n<p id=\"%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD\">类型转换和参数推断</a></p>\n<p id=\"%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD\">返回值类型推断</a></p>\n<p id=\"%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%98\">兼容类型的模板问题</a></p>\n<p id=\"%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD\">函数指针实参推断</a></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD\">模板实参推断</a></p>\n<p id=\"%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8\">左值引用</a></p>\n<p id=\"%C2%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8\"> 右值引用</a></p>\n<p id=\"%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0\">引用折叠</a></p>\n<p id=\"std%3A%3Amove-toc\" style=\"margin-left:40px;\"><a href=\"#std%3A%3Amove\">std::move</a></p>\n<p id=\"%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E7%9A%84std%3A%3Amove%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E7%9A%84std%3A%3Amove%E5%AE%9A%E4%B9%89\">短小精悍的std::move定义</a></p>\n<p id=\"std%3A%3Amove%E7%9A%84%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#std%3A%3Amove%E7%9A%84%E8%A7%A3%E6%9E%90\">std::move的解析</a></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7\">模板函数匹配的特殊性</a></p>\n<p id=\"%E6%B3%A8%E6%84%8F%E9%87%8D%E8%BD%BD%E6%A8%A1%E6%9D%BF%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B3%A8%E6%84%8F%E9%87%8D%E8%BD%BD%E6%A8%A1%E6%9D%BF%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F%C2%A0\">注意重载模板声明顺序 </a></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96\">模板特例化</a></p>\n<p id=\"%E7%89%B9%E4%BE%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%89%B9%E4%BE%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD%20%E7%9A%84%E5%8C%BA%E5%88%AB\">特例化和重载 的区别</a></p>\n<p id=\"%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96%C2%A0\">类模板特例化 </a></p>\n<p id=\"%E9%83%A8%E5%88%86%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%83%A8%E5%88%86%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96\">部分模板特例化</a></p>\n<p id=\"%E7%89%B9%E4%BE%8B%E5%8C%96%E6%88%90%E5%91%98-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%89%B9%E4%BE%8B%E5%8C%96%E6%88%90%E5%91%98\">特例化成员</a></p>\n<p id=\"%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF\">可变参数模板</a></p>\n<p id=\"%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8\">可变模板参数的具体作用</a></p>\n<p id=\"%E6%A8%A1%E6%9D%BF%E6%8A%80%E5%B7%A7-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%9D%BF%E6%8A%80%E5%B7%A7\">模板技巧</a></p>\n<p id=\"%E8%BD%AC%E5%8F%91%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BD%AC%E5%8F%91%C2%A0\">转发 </a></p>\n<p id=\"%E4%BD%BF%E7%94%A8std%3A%3Aforward%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BD%BF%E7%94%A8std%3A%3Aforward%C2%A0\">使用std::forward </a></p>\n<p id=\"%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85%C2%A0\">转发参数包 </a></p>\n<p id=\"make_shared%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#make_shared%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\">make_shared的工作原理</a></p>\n<hr/>\n<p></p>\n<h2 id=\"%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89\">模板的基本声明和定义</h2>\n<h3 id=\"%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E\">模板的声明</h3>\n<pre><code>template &lt;typename T&gt;  int compare (T t1, T t2);\ntemplate &lt;typename T&gt; class compare;</code></pre>\n<h3 id=\"%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0\">定义一个模板函数</h3>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nint compare(T &amp; t1, T &amp; t2)\n{\n    if(t1 &gt; t2) \n        return 1;\n    if(t1 == t2)\n        return 0;\n    if(t1 &lt; t2)\n        return -1;\n}</code></pre>\n<h3 id=\"%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB\">定义一个模板类</h3>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass compare\n{\nprivate:\n    T _val;\npublic:\n    explicit compare(T &amp; val) : _val(val) { }\n    explicit compare(T &amp;&amp; val) : _val(val) { }\n    bool operator==(T &amp; t)\n    {\n        return _val == t;\n    }\n};</code></pre>\n<h3 id=\"%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\">模板参数作用域</h3>\n<p>就如同其他的函数参数一样，或者是变量一样，就是普通的作用域规则。</p>\n<pre><code class=\"language-cpp\">using T = int;\nT a = 10;\ntemplate &lt;typename T&gt; class A;</code></pre>\n<p> 模板声明里的T不是上面的int而是模板参数。</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; class A\n{\n    U val; //error\n    template&lt;typename U&gt; class B;\n};</code></pre>\n<h3 id=\"%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\">关于模板工作原理</h3>\n<blockquote>\n<p>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，<span style=\"color:#fe2c24;\">这个过程叫做模板实例化</span>。编译器成成的版本通常被称为模板的<span style=\"color:#fe2c24;\">实例</span>。编译器为程序员生成对应版本的具体过程。类似宏替换。</p>\n<p>模板类在没有调用之前是不会生成代码的。</p>\n<p>由于编译器并不会直接编译模板本身，所以模板的定义通常放在头文件中。</p>\n</blockquote>\n<h3 id=\"%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0\">非类型模板参数</h3>\n<p>顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。</p>\n<p>当一个模板被实例化时，，非类型参数被一个<strong>用户提供</strong>的或者<strong>编译器推断</strong>出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。</p>\n<p>有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。</p>\n<pre><code class=\"language-cpp\">template &lt;size_t N, size_t M&gt;\nint str_compare(const char (&amp;str1)[N], const char (&amp;str2)[M])\n{\n    return strcmp(str1,str2);\n}</code></pre>\n<p> 使用方法</p>\n<pre><code class=\"language-cpp\">str_compare(\"hello\",\"nihao\")</code></pre>\n<p>为什么？？？我们甚至没有用&lt;&gt;来传递模板参数。这是因为编译器在编译阶段已经帮助我们计算好了应该开辟多大空间的数组。我们也可以指定长度。N，M只是隐式的传入进去。</p>\n<p>编译器也可以自动帮助我们推断参数时什么类型，从而不用显示的调用模板函数，对于上面的compare函数，我们可以这样调用，前提时保证参数类型相同。</p>\n<pre><code class=\"language-cpp\">compare(10,20);</code></pre>\n<p>非类型模板参数的范围</p>\n<p>整形，指针或者左值引用都是一个非类型模板参数。</p>\n<p>我们可以想到，对于指针或者引用，应当保证实参必须具有静态的生存期，保证其不会被释放。</p>\n<h3 id=\"inline%E5%92%8Cconstexp\">inline和constexp</h3>\n<p>放在模板之后，函数之前即可</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\ninline int compare(T t1, T  t2);</code></pre>\n<h3 id=\"%C2%A0%E5%9C%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB\"> 在模板类中使用模板类</h3>\n<p>这个应该很好理解，根据自己的需求，我们可以这样定义</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass A\n{\nprivate:\n    vector&lt;T&gt; vec;\n};</code></pre>\n<p> 也可以这样定义</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass B\n{\nprivate:\n    vector&lt;int&gt; vec;\n};</code></pre>\n<h3 id=\"%C2%A0%E5%8F%8B%E5%85%83%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB\"> 友元与模板类</h3>\n<p>通过上面编译器为模板生成具体代码的原理可以看出这样有什么不同</p>\n<pre><code class=\"language-cpp\">template &lt;typename N&gt;  \nclass C\n  friend A&lt;N&gt;;\n  friend B&lt;int&gt;;</code></pre>\n<p> 由于具体的原理类似宏替换，每个对应的C&lt;N&gt;都有友元A&lt;N&gt;和B&lt;int&gt;、</p>\n<p>即有这样友元关系C&lt;int&gt; A&lt;int&gt; B&lt;int&gt;, C&lt;string&gt; A&lt;string&gt; B&lt;string&gt;以此类推。</p>\n<p>还有这样的模板友元——所有的实例化都是其友元</p>\n<pre><code class=\"language-cpp\">template &lt;typename N&gt;\nclass C\n    template &lt;typename T&gt; friend class D;</code></pre>\n<p> 但是没有这样的写法</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; friend class D&lt;T&gt;;</code></pre>\n<p>或者这样的写法</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; friend D&lt;T&gt;;</code></pre>\n<p>模板允许模板参数为自己的友元</p>\n<p>首先说明，模板允许内置类型为自己的友元。</p>\n<pre><code class=\"language-cpp\">friend int;</code></pre>\n<p>这样写是完全正确的，但是实际上有什么意义呢？</p>\n<p>还是有意义的，我们可以这样写</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass People\n{\n    friend T;\n};</code></pre>\n<p>这样就保证了在传入内置类型的时候不会有错误。</p>\n<h3 id=\"%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82\">默认模板实参</h3>\n<p>用法和函数的默认参数基本相同</p>\n<pre><code class=\"language-cpp\">template &lt;typename T = int&gt; class A;</code></pre>\n<p>默认的情况下T就是int</p>\n<pre><code class=\"language-cpp\">A&lt;&gt; a; // T is int</code></pre>\n<h3 id=\"%3A%C2%A0%3A%20%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3\">: : 二义性的解决</h3>\n<p>对于普通类的:: ，我们可以知道它究竟是一个类还是一个静态成员，就像下面这样。</p>\n<pre><code class=\"language-cpp\">string::size_type a;\nstring::npos;</code></pre>\n<p>对于模板类来说，我们还是知道表达的是什么，但是已经说过了，模板类在没有 调用之前不会生成代码，这可坏了。对于T::mem，究竟是什么呢？是静态成员？还是一个类型的typedef？</p>\n<p>对于这个问题，使用typename修饰。</p>\n<p>当我们希望通知编译器一个名字表示一个类型时，使用且必须使用关键字typename，来表示其是一个类型。</p>\n<p>于是，我们可以写出这样的代码。</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\ntypename T::val_typefunc ();</code></pre>\n<p>表的不是一个静态数据成员而是一个类型。</p>\n<p>或者这样的代码</p>\n<pre><code class=\"language-cpp\">typedef typename T::mem s_type;</code></pre>\n<p>表示s_type是一个类型的别名而不是数据成员的别名。</p>\n<p>如果转到string::size_type的定义，可以看见他是一个typename 的 typedef。</p>\n<h3 id=\"%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">类模板成员函数</h3>\n<p>本质上就是个函数，只要掌握了模板的工作原理，我们我们就可以轻松的写出类模板成员函数。</p>\n<pre><code class=\"language-cpp\">class Math\n{\npublic:\n    template &lt;typename N&gt; inline static  N sqrt(N);\n};\n\ntemplate&lt;typename N&gt;\nN Math::sqrt(N val)\n{\n    return val * val;\n}</code></pre>\n<p>首先来一点一点解析</p>\n<p>这是一个模板函数，返回值为N类型，所以，模板语法写在前面，让编译器知道应该返回类型，紧接着就是返回类型，返回类型同上都是写在比较靠前的位置。接着就是函数的标签。</p>\n<p>对于定义来说，应该知道是哪个类下的函数，所以和普通的方法一样加上一个作用域即可。</p>\n<p>假如把类写成这样呢？</p>\n<pre><code class=\"language-cpp\">template &lt;typename N&gt;\nclass Math\n{\npublic:\n    inline static  N sqrt(N);\n};\n</code></pre>\n<p>那方法的定义应该是写成这样的。</p>\n<pre><code class=\"language-cpp\">template&lt;typename N&gt;\nN Math&lt;N&gt;::sqrt(N val) \n{\n    return val * val;\n}</code></pre>\n<p>这里就可以看出</p>\n<blockquote>\n<p>前面说到的，模板不是一个具体的类，而是根据这个模板编译器生成对应的版本。</p>\n<p>对于每一个版本，都是不同的类。就像重载函数一样，即便参数个数和函数的具体算法完全一样，但类型不同他们也是不同的函数，只不过函数名相同而已。</p>\n<p>那么就应该可以得到每个版本的类都对应的一个相应版本的静态成员。所以Math&lt;N&gt;::这样写也就很好理解了。</p>\n</blockquote>\n<h3 id=\"%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%C2%A0\">类模板的成员模板 </h3>\n<p>我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。</p>\n<p>无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。 </p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; class A\n{\npublic:\n    template &lt;typename It&gt;  A&lt;T&gt; sum(It _begin, It _end);\n};\n\ntemplate &lt;typename T&gt;        //最外层模板\ntemplate &lt;typename It&gt;       //内层模板\nA&lt;T&gt;                         //返回值\nA&lt;T&gt;::sum(It _begin, It _end)//函数标签 \n{}                           //算法实现\n\n//不妨写的更美观一点\ntemplate &lt;typename T&gt;\n  template &lt;typename It&gt;\n  A&lt;T&gt; A&lt;T&gt;::sum(It _begin, It _end){\n      \n  }</code></pre>\n<p>注意：上面的代码和下面的代码写的足够复杂，下面的代码对其进行一些小小的修改。 </p>\n<p>具体的用法，虽然下面的例子看起来有些造作，但是还是能说明一些问题的</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\nusing namespace std;\ntemplate &lt;typename T&gt; class A\n{\nprivate:\n    vector&lt;T&gt; vec;\npublic:\n    template &lt;typename It&gt;  T sum(It _begin, It _end);\n    A(initializer_list&lt;T&gt; initlist)    \n    {\n        for(auto it = initlist.begin();it != initlist.end();++it)\n        {\n            vec.push_back(*it);\n        }\n    }\n    typename vector&lt;T&gt;::iterator begin()\n    {\n        return vec.begin();\n    }\n    typename vector&lt;T&gt;::iterator end()\n    {\n        return vec.end();\n    }\n};\n\ntemplate &lt;typename T&gt;\n  template &lt;typename It&gt;\n  T A&lt;T&gt;::sum(It _begin, It _end)\n  {\n    T tot ;\n    memset(&amp;tot,0,sizeof (T));\n    while(_begin != _end)\n    {\n        tot += *_begin++;\n    }\n    return tot;\n  }\n\n\nint main()\n{\n    A&lt;int&gt; a {1,2,3,4};\n    cout &lt;&lt; a.sum(a.begin(),a.end());\n    return 0;\n}</code></pre>\n<p> 虽然这样的语法很是令人头疼，但是多用即可熟练，或者说使用类型别名来避免这样的问题，并且最好不要把学习精力放在语法上——在没有熟悉语法之前。</p>\n<h3 id=\"%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%BC%98%E5%8C%96%C2%A0\">实例化优化 </h3>\n<p>当模板被调用时才会被编译，那么就会存在这样一种情况——<strong>相同地实例化可能出现在多个文件对象中</strong>。当两个或多个独立编译地源文件适用了相同地模板，并提供了相同地模板参数时，每个文件中就都会有该模板的一个实例。</p>\n<p>为了解决这种问题，我们可以控制显示实例化。具体的做法如下</p>\n<p>用关键字extern显示的实例化声明</p>\n<pre><code class=\"language-cpp\">extern template class A&lt;string&gt;;                   //声明\ntemplate int compare(const int &amp;, const int &amp;);    //定义</code></pre>\n<blockquote>\n<p>将一个实例化声明为extern就表示承诺在程序的其他位置有该实例化的一个非extern声明（定义）。</p>\n<p>由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何用此实例化版本的代码之前。 </p>\n</blockquote>\n<p>解释的来说：因为文件其他处已将有一个实例化——编译器生成好的或者是自己定义的，由于编译单元为.cpp文件，所以在一个文件中实例号的代码并不能用于另一个文件，这就显着很捞。而extern正是解决这个问题的。 </p>\n<h2 id=\"%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD\">类型转换和参数推断</h2>\n<p>与非普通地类型转换一样，模板类在传递模板参数的时候也会进行相应的转换，只不过这种转换增添了更多的规则，参数推断和类型转换的关系是非常紧密的。</p>\n<p>类型转换这里的问题如果想要清楚的了解，那恐怕是非常可怕的，我有时候在想，通过这么多的转换规则 ，我们就可见一斑的看出C++的设计是多么的巧妙。虽然这的知识点很乱，但其实只要抓住隐藏在这背后的观念就能清晰的对付各种转换了。</p>\n<p>其中一个规则是：如果能够进行安全转换，那么编译器可以隐式转换</p>\n<p>最经典的一个例子就是non-const  到const的转换。</p>\n<p>为了展示的方便，会忽略掉一些代码</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nbool func(const T t1, const T t2)\n{\n    return less&lt;T&gt;()(t1,t2);\n}\n\n...\n\n    int a = 10;\n    const int b = 20;\n    func&lt;int&gt;(a,b);</code></pre>\n<p>这里的int转为cosnt int是允许的，因为这是按值传递，并且non-const 转为 cosnt也不会带来什么坏处。因此，编译器会执行这样的转换。</p>\n<p>我们不妨修改一下这个函数</p>\n<pre><code class=\"language-cpp\">bool func(const T &amp; t1, const T &amp; t2);\nbool func(T &amp; t1, T &amp; t2);</code></pre>\n<p>上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。</p>\n<p>而第二个却不会正常调用——因为b是一个cosnt 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。</p>\n<p>假设我们这样调用两个函数</p>\n<pre><code class=\"language-cpp\">func&lt;int&gt;(10,20);</code></pre>\n<p>同样的，对于第一个是允许的——虽然讲右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。</p>\n<p>而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。</p>\n<p>基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。</p>\n<blockquote>\n<p>上面的是C++ Primer的原文，实际上笔者在学习的过程中，发现了其错误。</p>\n</blockquote>\n<p>先来看一下代码</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; bool func(const T &amp; t1, const T &amp; t2);\n...\nint a[10];\nint b[10];\nfunc(a,b);</code></pre>\n<p>这样是可以的。那这样呢？</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; T func(const T &amp; t1, const T &amp; t2);</code></pre>\n<pre><code class=\"language-cpp\">template&lt;typename T1, typename T2, typename T3&gt;\nT1 sum(T2 t2, T3 t3)\n{\n    return t2 + t3;\n}\n\n...\n\nsum&lt;long long&gt;(10,200); //or sum&lt;long long, int, int&gt;();</code></pre>\n<p>就不可以了，这个声明对应着C++ Primer的声明。</p>\n<p>为什么一样的形参列表只有返回值不同编译器就会发出警告，这是为什么。</p>\n<p>其实我们到目前为止的讨论，都适用于普通函数，模板的本质其实也是模板为我们生成对应的版本，为了解开上面的疑惑，我们可以先来复习以下引用的知识。</p>\n<pre><code class=\"language-cpp\">    int *&amp; ref_apple_point = &amp;apple; //error\n    int * const &amp; ref_apple_point_const = &amp;apple; //ok</code></pre>\n<p>根据这两行代码我们可以得到一些启示。</p>\n<p>因为数组名是一个常量，const T &amp; t1这样的形参是可以接受的。但对于返回值来说，可就麻烦了。返回值为内置数据类型的模板函数，对于这个问题，这没有什么好说的。返回类型为T的模板函数，他返回的是一个什么具体类型呢？首先T被u推断为* const，那么返回类型也应该是 *const</p>\n<p> 在这里我们先留下一个悬念，当我们理解和编译器是如何推断T是何种类型的时候，这个问题可能就会迎刃而解。</p>\n<h3 id=\"%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD\">返回值类型推断</h3>\n<p>在编译器遇见函数列表之前，所有的形参都是不存在的，那么我们需要使用这样的尾置返回类型。</p>\n<pre><code class=\"language-cpp\">auto func(It &amp; _beg, It &amp; _end) -&gt; decltype(*_beg)\n{\n    //...\n    auto sum = *_beg;\n    sum = 0;\n    for_each(_beg,_end,[&amp;sum](const int &amp; val){ sum+= val;});\n    //...\n    return sum;\n}</code></pre>\n<p>这样的代码还是有一些问题的，如果我们要返回一个拷贝而不是引用呢？要用到一个类型转换模板工具。</p>\n<p>remove_reference&lt;&gt;        移除引用——关于其他的类型转换，不再本文章讨论范围内读者可自行查阅。</p>\n<p>这个模板类有一个名为type的public成员，能够获得相应的类型。所以我们可以这样写</p>\n<pre><code class=\"language-cpp\">template &lt;typename It&gt;\nauto func(It &amp; _beg, It &amp; _end) -&gt; typename remove_reference&lt;decltype(*_beg)&gt;::type //don't forget typename\n{\n    //...\n    auto sum = *_beg;\n    sum = 0;\n    for_each(_beg,_end,[&amp;sum](const int &amp; val){ sum+= val;});\n    //...\n    return sum;\n}\n</code></pre>\n<p>在某些情况下我们可以指定返回u类型，例如</p>\n<pre><code class=\"language-cpp\">template&lt;typename T1, typename T2, typename T3&gt;\nT1 sum(T2 t2, T3 t3)\n{\n    return t2 + t3;\n}\n\nsum&lt;long long&gt;(10,200); //or sum&lt;long long, int, int&gt;();</code></pre>\n<p>显示模板参数按从左到右的顺序一次匹配。</p>\n<h3 id=\"%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%98\">兼容类型的模板问题</h3>\n<p>有这样的代码</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nT sum(T t1, T t2)\n{\n    return t1 + t2;\n}\n\nsum(10,3.14);</code></pre>\n<p>虽然int和double兼容，但是只有一个类型参数，编译器傻了，T为int？精度会丢失，肯定是不可行的，T为double?貌似也不行，这样会导致数据溢出。无奈我们只好这样了。</p>\n<pre><code class=\"language-cpp\">template&lt;typename T1， typename T2&gt;\n??? sum(T1 t1, T2 t2)\n{\n    return t1 + t2;\n}</code></pre>\n<p>至于返回类型，全交给程序员来规定，或者用尾部返回类型。</p>\n<h3 id=\"%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD\">函数指针实参推断</h3>\n<p>有趣的是，虽然在未实例化之前，编译器没有生成具体的代码，但我们仍然可以进行函数指针绑定的操作。</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; int compare(const T &amp; t1, const T &amp; t2) { }\n\nint (*pf_int)(const int &amp;,const int &amp;) = compare;</code></pre>\n<p>同样的我们也可以将模板函数作为回调函数进行传参，但此时可能会产生二义性，所以注意显示的写出模板参数。</p>\n<blockquote>\n<p>当参数是一个函数模板实例的地址时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型的值。</p>\n</blockquote>\n<h2 id=\"%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD\">模板实参推断</h2>\n<p>这里是重中之重！！！重中之重！！！</p>\n<p>很多的模板问题都与此有关。</p>\n<p>关于const和&amp;的问题，我们上面已经讲过了。这里再进行进一步的说明。</p>\n<h3 id=\"%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8\">左值引用</h3>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; void func1(T &amp;) { }\ntemplate &lt;typename T&gt; void func2(const T &amp;) { }\nvoid aa()\n{\n    int a = 10;\n    const int b = 20;\n    func1(a);   //T is int \n    func1(b);      //T is const int\n    func2(a);      //T is int\n    func2(b);      //T is int\n    func2(10);     //T is int \n}</code></pre>\n<p>还是比较有意思的，看func2(b)的调用，虽然我们将const int类型传入进去，但是编译器为我们推导的还是int，原因应该和参数类型有关，如果编译器为我们推导的是const int ，那么const const int是不合法的，所以只好为我们推倒为int，即使我们调用时候的类型是const int。</p>\n<h3 id=\"%C2%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8\"> 右值引用</h3>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt; void func(T &amp;&amp;);\nfunc(10);         //T is int\nfunc(b);          //b is a left_val T is ???</code></pre>\n<p>我们可以根据引用折叠可以推断出类型。</p>\n<h3 id=\"%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0\"><strong>引用折叠和万能引用</strong></h3>\n<p>众所周知在非模板函数中可以使用const &amp; 来接受任意类型参数，在模板中，也有类似这样的万能引用，就是&amp;&amp;。知道了这样的原因是有着引用折叠得的存在。</p>\n<p>先说结论：在传递参数的过程中，无论多么复杂的引用传参，最后都会被折叠为&amp; 或者 &amp;&amp;.</p>\n<blockquote>\n<p>如果我们间接创建了一个引用的引用，则这些引用形成折叠。除了右值引用的右值引用会被折叠为一个右值引用，剩下全部折叠为一个左值引用。即</p>\n<p>T&amp; &amp;, T&amp; &amp;&amp;， T&amp;&amp; &amp;都会折叠为T&amp;</p>\n<p>T&amp;&amp; &amp;&amp;会被折叠为&amp;&amp;</p>\n</blockquote>\n<p>这就意味着我们 可以解释上面的问题。</p>\n<p>当我们将一个左值传递给一个右值引时候，编译器推断T的类型为&amp;。注意是T的类型为左值引用，不是整个形参是T &amp;。</p>\n<p>所以</p>\n<pre><code class=\"language-cpp\">func(b);          //b is a left_val T is int&amp;</code></pre>\n<p>上述的两个规则导致了</p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">如果一个函数参数是一个指向模板类型参数的右值引用，则他可以被绑定到一个左值。</span></p>\n<p><span style=\"color:#fe2c24;\">如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数将被参数将被实例化为一个普通左值引用参数。</span></p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"> 这两个规则又暗示了我们——我们可以将任意类型的实参传递给参数为右值引用的函数。</span></p>\n<p>当代码中涉及的类型可能是非引用类型，也可能是引用类型的时候，编写正确的代码就变得异常困难（虽然remove_reference这样的转换类型对我们可能有所帮助）。</p>\n<blockquote>\n<p>PS：由于这里的知识是在是很乱，笔者在写这里的时候也实在无能为力，所以大量了引用C++ Primer的原文。但是有一点可以保证——笔者在这里写的demo虽然没有什么实际意义仅用于演示——但是也能说明一些问题。</p>\n<p>如果读者对模板的细节想以探究经，可以翻越C++ Primer——中文第五版P508-P610。</p>\n<p>如果想巩固这里的语法，可以作相应的配套习题。</p>\n</blockquote>\n<h2 id=\"std%3A%3Amove\">std::move</h2>\n<p>折磨的篇章终于过去了，让我们用好奇心来看一看std::move这个工具。</p>\n<h3 id=\"%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E7%9A%84std%3A%3Amove%E5%AE%9A%E4%B9%89\">短小精悍的std::move定义</h3>\n<p>如下</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type &amp;&amp; move(T &amp;&amp; t)\n{\n    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); \n}</code></pre>\n<h3 id=\"std%3A%3Amove%E7%9A%84%E8%A7%A3%E6%9E%90\">std::move的解析</h3>\n<p>因为move可以接受任意对象，所以应当是一个模板类。</p>\n<p>既然我们要保证返回一个右值，那我们应当明确的得到一个非左右值引用类型——即普通类型。</p>\n<p>那么就可以先移除引用再加上右值引用——这样保证了返回一个右值引用对应了</p>\n<pre><code class=\"language-cpp\">typename remove_reference&lt;T&gt;::type &amp;&amp;</code></pre>\n<p>既然接受任意一个对象，那美可以用&amp;&amp;来接受实参，对应</p>\n<pre><code class=\"language-cpp\">move(T &amp;&amp; t)</code></pre>\n<p>我们只需要返回一个右值即可，所以只有一个return语句。</p>\n<p>我们回想以下为什么要使用std::move——获得一个右值进行移动构造？又或者是仅仅需要一个右值？不管出于什么原因，最终的目的就是为了优化程序，所以通过形参创建一个额外的右值并返回这样是不可取的，是脱裤子放屁，所以我们要使用这条语句</p>\n<pre><code class=\"language-cpp\">static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</code></pre>\n<p>通常情况下，static——cast用于合法的类型转换，但是又一种情况例外，虽然一个左值不能隐式转换为右值，但是可以使用static_cat将其显示的转换为右值——前提我们先移除对象身上的引用效果。</p>\n<p>模板和重载</p>\n<p>模板也是可以被重载的，只要没有二义性。像在C++库中，存在着大量的模板重载技术，或者是可变模板参数中，也存在着模板的重载。</p>\n<p>对于实例化的选择，遵循以下的规则。</p>\n<blockquote>\n<p>1.对于一个调用，其候选函数是所有可行的实例化</p>\n<p>2.可行函数按类型转换来排序。当然，可用于函数模板调用和的类型转换是非常有限的。</p>\n<p>3.和普通函数一样，如果恰又一个函数比任何其他函数都更好的匹配，则选择此函数。</p>\n<p>4.如果多个函数提供了同样好的匹配</p>\n<p>        1）优先选择非模板函数</p>\n<p>        2）没有非模板函数我选择更加特例化的模板</p>\n<p>        3）否则有二意性</p>\n<p>正确的定义一组重载的函数模板需要对类型键的关系以及模板幻术允许的优先的实参类型转换有着深刻的理解。</p>\n<p><span style=\"color:#fe2c24;\">注意：虽然非模板函数的优先级很高——但那也是没有对应模板匹配的情况下，所以，在重载模板的时候仔细观察和思考。</span></p>\n</blockquote>\n<p>所以我们为了适配字符串的比较，可以写出这样的代码</p>\n<pre><code class=\"language-cpp\">template&lt;size_t N, size_t M&gt;\nint compare(const char str1[N], const char str2[M])\n{\n    return strcmp(str1,str2);\n}\n//或者\nint compare(const char * const str1, const char * const str2)\n{\n    return strcmp(str1,str2);\n}</code></pre>\n<p> 根据上面的匹配规则，我们还可以递归的调用模板类自己实现某些功能</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt; string debug_rep(const T &amp; t)\n{\n    ostringstream ret;\n    ret &lt;&lt; t ;\n    return ret.str();\n}\n\ntemplate&lt;typename T&gt; string debug_rep(const T * p)\n{\n    ostringstream ret;\n    ret &lt;&lt; \"pointer :\" &lt;&lt; p;\n    if(p != nullptr)\n        ret &lt;&lt; \" \" &lt;&lt; debug_rep(*p);\n    else\n        ret &lt;&lt; \" nullptr\";\n    return ret.str();\n}\n\n//适配C风格字符串\nstring debug_reo(char * p)\n{\n    return debug_rep(string(p));    //这是一个右值，不能获取其地址\n}\n\nstring debug_rep(const char * p)\n{\n    return debug_rep(string(p));\n}\n\nint main()\n{\n    string s(\"hello\");\n    string* ps = &amp;s;\n    cout &lt;&lt; debug_rep(ps) &lt;&lt; endl &lt;&lt; debug_rep(s);\n    return 0;\n}</code></pre>\n<p>运行结果</p>\n<p><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\d552c7ad9be5484282089868bd42fd4c.png\" width=\"441\"/></p>\n<h3 id=\"%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7\">模板函数匹配的特殊性</h3>\n<p>难道没有发现一个异常的地方吗？对于指针版本的调用，可以这样实例化两个函数</p>\n<pre><code class=\"language-cpp\">string debug_rep(const string* &amp; t);\nstring debug_rep(string * p);</code></pre>\n<p> 对于普通函数，这是无疑的二义性，但是模板会选择特例化高的，原因是const T&amp;可以实例化任何类型，而const T * p只能实例化指针类型——特例化程度更高。所以会调用后者。</p>\n<p><span style=\"color:#fe2c24;\">这就说明了：不要将普通函数的匹配机制应用于模板函数匹配机制——虽然两者很像，但是还是有某些地方是不一样的。</span></p>\n<h3 id=\"%E6%B3%A8%E6%84%8F%E9%87%8D%E8%BD%BD%E6%A8%A1%E6%9D%BF%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F%C2%A0\"><span style=\"color:#0d0016;\">注意重载模板声明顺序 </span></h3>\n<p>由于模板的特性，使得其可以递归的调用自己的不同版本，但是注意要<span style=\"color:#fe2c24;\">调用的版本一定要事先声明或者定义，否则可能出现函数不匹配的情况</span></p>\n<p>我们把适配char * 接口的字符串的函数放到最前面，我们发现编译器会右值河阳的错误。</p>\n<blockquote>\n<p>No matching function for call to 'debug_rep'</p>\n<p>调用“debug_rep”没有匹配的函数 </p>\n</blockquote>\n<p>或者我们将两个debug_rep的模板版本调换以下顺序。 </p>\n<blockquote>\n<p>Call to function 'debug_rep' that is neither visible in the template definition nor found by argument-dependent lookup</p>\n<p>调用函数“debug_rep”，该函数在模板定义中既不可见，也不通过参数相关查找找到</p>\n</blockquote>\n<h2 id=\"%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96\">模板特例化</h2>\n<p>我们编写的模板，不可能保证对于所有的类型都能适用——compare函数就是很经典的例子，对于两个指针类型，仅仅是毫无意义的比较。这时候我们用到模板特例化的技术可以很好的解决这样的问题。</p>\n<p>由于less的底层是使用&lt;来比较的，所以less并没有适配字符指针。那么，我们可以编写这样的模板特例化。</p>\n<pre><code class=\"language-cpp\">template &lt;&gt;        //表示一个模板特例化——语法规定\nint compare(const char * const &amp; str1, const char * const &amp; str2) //具体的类型\n{\n    return strcmp(str1,str2);\n}\n</code></pre>\n<p>可以看出，模板特例化的尖括号中没有任何说明，所以模板特例化要对所有模板那参数都进行特例化。 </p>\n<p>注意，上面的特例化只能处理字符指针，不能处理数组或者字符串面量——这和函数匹配机制有关。这个特例化仅仅接受char*以及其const版本，虽然字符数组的名字就是他的地址，但是在模板中会被解释为一个字符数组的引用，更加的精准匹配。如果想要支持字符面量（本质上是字符数组）和字符数组，请写一个重载的模板函数——见模板重载。</p>\n<p>我们可以使用调试观察是如何推断实参类型的</p>\n<p><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\cac84050194042999a46dff60b811f6e.png\" width=\"1200\"/></p>\n<p>推断为一个数组的引用——这显然比将数组转换为指针再进行匹配更加精确。</p>\n<h3 id=\"%E7%89%B9%E4%BE%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD%20%E7%9A%84%E5%8C%BA%E5%88%AB\">特例化和重载 的区别</h3>\n<p>特例化就是一个特殊的实例化——模板的实例化，所以，特例化仅仅是模板的一个实例化，不会影响函数匹配。 </p>\n<p>并且，模板特例化一定要保证模板的之前的声明或者定义。如果不这样做——编译器不会报错，但是会有一些令人匪夷所思的地方。模板会由编译器实例化，而不是调用自己特例化版本——这种错误往往很难查找。所以，<span style=\"color:#fe2c24;\">记住一个规则：特例化一个模板，一定要保证其在原模板的定义域中。</span></p>\n<h3 id=\"%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96%C2%A0\">类模板特例化 </h3>\n<p> 这里引用《C++ Primer》的例子——对其做一些解析。</p>\n<p>hash容器是能够进行十分快速的查找容器，像hash_map, hash_set等。他们的底层使用什么来映射哈希值呢? hash模板类。<a href=\"http://www.cplusplus.com/reference/functional/hash/?kw=hash\" title=\"hash - C++ Reference (cplusplus.com)\">hash - C++ Reference (cplusplus.com)</a></p>\n<p>那么对于我们自定义的类型来说，没有其对应算法，为了能够使用我们的自定义类型，我们可以定义一个其特例化版本。</p>\n<p> 一个hash的特例化必须包括</p>\n<blockquote>\n<p>一个重载的调用运算符，接受一个容器关键字类型的对象，返回一个size_t——用于映射对象的哈希值。</p>\n<p>两个类型成员，result_type, argument_type，分别调用运算符返回类型和参数类型。</p>\n<p>默认构造函数和拷贝赋值运算符。</p>\n</blockquote>\n<p>于是我们可以写出如下的代码。</p>\n<pre><code class=\"language-cpp\">class Book\n{\n    friend class std::hash&lt;Book&gt;;    //hash使用了私有成员，所以将其声明为友元\nprivate:\n    int book_id;\n    string book_name;\npublic:\n    Book() = default;\n    Book(const int a, const string &amp; _name) : book_id(a), book_name(_name) { }\n    bool operator==(const Book &amp; b) const\n    {\n        return book_id == b.book_id;\n    }\n};</code></pre>\n<p> 我们首先定义一个Book类，然后提供其==运算符确保hash模板能够自持我们的自定义类型。</p>\n<p>随后我们在std命名空间中特例化一个和hash，</p>\n<pre><code class=\"language-cpp\">namespace std\n{\n    template &lt;&gt;\n    struct hash&lt;Book&gt;\n    {\n        //必须提供的成员\n        typedef size_t result_type;\n        typedef Book argument_type;\n        size_t operator()(const Book &amp; b) const;\n    };\n    size_t\n    hash&lt;Book&gt;::operator()(const Book &amp;b) const {\n        //自定义如何组织hash_val\n        return hash&lt;string&gt;()(b.book_name) ^ hash&lt;int&gt;()(b.book_id);\n    }\n}</code></pre>\n<p>之后，我们就可以使用unordered_set/map，来操纵我们的自定义类型了。 </p>\n<p>为了能够让自定义数据类型的特例化能够被正常使用，应该将其放在类声明对应的头文件中，或者用别的头文件将其包含进来。</p>\n<h3 id=\"%E9%83%A8%E5%88%86%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96\">部分模板特例化</h3>\n<p>我们可以指定<strong>一部分而非所有的模板参数，或者是参数的一部分而非全部特性</strong>。一个模板的部分特例化本身是一个模板，使用它时用户还必须为哪些在特例化版本呢中未指定的模板参数提供实参。</p>\n<p>部分特例化一部分模板参数特例化，没有特例化的部分额外的提供实参。</p>\n<p>标准库的remove_reference 就是使用一系列的特例化完成其功能的，我们将其转到定义。</p>\n<p>这里部分特例化的时参数的引用性质。</p>\n<pre><code class=\"language-cpp\">  template&lt;typename _Tp&gt;\n    struct remove_reference\n    { typedef _Tp   type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_reference&lt;_Tp&amp;&gt;\n    { typedef _Tp   type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_reference&lt;_Tp&amp;&amp;&gt;\n    { typedef _Tp   type; };</code></pre>\n<p> 具体的语法：</p>\n<p>在正常的模板声明之后，在类的后面使用尖括号&lt;&gt;放入要特例化的实参，这些实参于原始模板中的参数按照位置对应。也就是对应着上面源码中的</p>\n<pre><code class=\"language-cpp\">struct remove_reference&lt;_Tp&amp;&amp;&gt;</code></pre>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">注意：模板部分特例化并不是对于某个单单的模板参数特例化，也可能是模板参数属性的特例化，这点对于理解类模板部分特例化十分重要</span></p>\n<p><span style=\"color:#fe2c24;\">注意：我们只能部分特例化类模板，而不能部分特例化模板函数。 </span></p>\n</blockquote>\n<p>例如我们定义一个泛用的模板类和实例化一个其专门用来处理指针的类</p>\n<pre><code class=\"language-cpp\">\ntemplate &lt;typename T&gt;\nclass A;\n\ntemplate &lt;typename T&gt;\nclass A&lt;T *&gt;;</code></pre>\n<h3 id=\"%E7%89%B9%E4%BE%8B%E5%8C%96%E6%88%90%E5%91%98\">特例化成员</h3>\n<p>我们可以只特例化特定的成员函数而不是特例化整个模板类。</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass A\n{\nprivate:\n    T val;\npublic:\n    A(const T &amp; t) : val(t) { }\n    void func();\n};\n\ntemplate&lt;&gt;\nvoid A&lt;int&gt;::func()\n{ }\n\n\n</code></pre>\n<p> 那我们这样得到的就是对于A&lt;int&gt;的实例化下的一个特例化func——这个func只在int的实例化版本生效。也就是说，实例化int版本的A其对应的func是我们特例化的这个版本，而其他成员还是正常的实例化。</p>\n<h2 id=\"%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF\">可变参数模板</h2>\n<p>声明：关于模板的递归调用，都有一个基线函数，只不过是没有写出。</p>\n<p>关于可变参数模板，一部分引用我之前的文章，再在这里做一些补充</p>\n<blockquote>\n<p><strong>可变模板参数 </strong><em>variadic template</em></p>\n<p><strong>包      </strong>             <em>packet</em></p>\n<p><strong>模板参数包 </strong>   <em> template parameter packet</em></p>\n<p><strong>函数参数包  </strong>  <em> function paremeter packet</em> </p>\n</blockquote>\n<p> <a class=\"has-card\" href=\"https://blog.csdn.net/JAN6055/article/details/122818685?spm=1001.2014.3001.5501\" title=\"C++——C++11的标准（下）___JAN__的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">C++——C++11的标准（下）___JAN__的博客-CSDN博客</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://blog.csdn.net/JAN6055/article/details/122818685?spm=1001.2014.3001.5501</span></span></a></p>\n<p>详情见这篇文章的可变模板参数。 </p>\n<p><strong>补充：</strong></p>\n<p><strong>sizeof...运算符</strong></p>\n<p>能够获得包中参数的个数</p>\n<pre><code class=\"language-cpp\">template&lt;typename T, typename... Args&gt;\nvoid var_fun(const T &amp; t, const Args&amp;... args)\n{\n    //cout &lt;&lt; t;\n    cout &lt;&lt; \"element numbers of packs is \" &lt;&lt; sizeof...(Args);\n    //var_fun(args...);\n}</code></pre>\n<p><strong>包拓展</strong></p>\n<blockquote>\n<p><strong>拓展 </strong>     <em>  packs expand</em></p>\n<p>包拓展简单的来说将他分解为其构成的元素，如果说将参数变为包的过成类比为压缩未见，那么包拓展就是解压文件，但包拓展不仅仅是包展开。</p>\n</blockquote>\n<p>当拓展一个包时，我们还要提供用于，每个拓展元素的<strong>模式</strong>。拓展一个包就是将它费解为构成的原书，对每个元素应用模式，获得拓展后的列表。我们通过在模式右边防一个省略号...来触发拓展操作 。</p>\n<blockquote>\n<p>什么是模式？</p>\n<p>在实际生活中，当我们说以一种模式打开某个东西，或者是什么模式打开时。指定的是固有的模式，比如说性能模式，均衡模式等。而抱拓展的模式更像是对于每个元素都调用一次相应的函数，包拓展需要我们自定义模式——其实就是一个函数，返回值为包中的一个元素应用模式后的结果，所有这样的结果组合在一起，也就是包以这个模式（函数）展开。</p>\n</blockquote>\n<p>看一下标准库的配置器中是如何使用的展开</p>\n<pre><code class=\"language-cpp\">noexcept(noexcept(::new((void *)__p)\n\t\t\t    _Up(std::forward&lt;_Args&gt;(__args)...)))</code></pre>\n<p>这是一个函数异常声明的部分，当用一个包构造一个元素的时候不会抛出异常，仅当，使用转发模式对参数包进行展开的时候不抛出异常。</p>\n<pre><code class=\"language-cpp\">    var_func(args...);      //默认的包展开\n    //注释部分的...不为关键字，和C++语法没有任何关系\n    //相当于这样{ele1, ele2, ele3, ... ,elen}\n    var_fun(mul(2,args)...);    //带有模式的包展开\n    //第二种展开模式相当于这样\n    //{ mul(2,ele0),mul(2,ele1),mul(2,ele2), ... mul(2,elen) }</code></pre>\n<p>具体实验</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nvoid print(const T &amp; t)\n{\n  cout &lt;&lt; t &lt;&lt; endl;\n}\ntemplate &lt;typename T, typename... Args&gt;\nvoid print(const T &amp;t ,const Args... args)\n{\n  cout &lt;&lt; t &lt;&lt; endl;\n  print(args...);\n}\n\ntemplate &lt;typename T&gt;\nint up(T &amp; t)\n{\n  t *= 2;\n  return t;\n}\ntemplate &lt;typename... Args&gt;\nvoid func(Args&amp;&amp;... args)\n{\n  print(up(args)...);\n}\n\nint main()\n{\n  func(1,2,3,4,5);\n  return 0;\n}\n</code></pre>\n<p> 运行结果</p>\n<p><img alt=\"\" height=\"245\" src=\"..\\..\\static\\image\\07fd5425aa89414d88e86c521823742e.png\" width=\"316\"/></p>\n<h3 id=\"%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8\">可变模板参数的具体作用</h3>\n<p>可变模板参数可以说是一个核弹，比如tuple就是使用其实现的，模板类tuple以私有继承的方式继承它自己并结合模板部分特例化。如下</p>\n<pre><code class=\"language-cpp\">template&lt;typename T, typename ... Args&gt;\nclass tuple&lt;T,Args...&gt; : private tuple&lt;Args...&gt;\n{\n    //something\n};</code></pre>\n<p> 还是很奇妙的，具体详情请观看侯捷老师的视频——bilibili ： <img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\d4465dc3a3e84b0ba1857922cf22379d.png\" width=\"362\"/></p>\n<h2 id=\"%E6%A8%A1%E6%9D%BF%E6%8A%80%E5%B7%A7\">模板技巧</h2>\n<p>模板的功能还是很强大的，我们有必要学习一些模板技巧。</p>\n<h3 id=\"%E8%BD%AC%E5%8F%91%C2%A0\">转发 </h3>\n<blockquote>\n<p> 什么是转发？</p>\n<p>某些函数需要将其一个或多个实参连<strong>同类型不变的</strong><strong>传递</strong>给其他函数。这个过程就叫<strong>转发。</strong></p>\n<p>很形象，一个函数把数据原封不动的传递给另一个函数，就是转发。</p>\n</blockquote>\n<p>什么时候会用到转发呢？比如说我们有这样的一个函数，在容器尾部直接使用我们穿进来的参数构造一个元素，这个时候使用转发就是很有必要的。如果我们不适用转发技术，可能会造成变量的复制，也许有的时候这个函数能正常使用，但是有的时候我们就需要引用来做事，所以这样做留下的错误的隐患。 </p>\n<p>假设有func1(int &amp;，args)  fun2 work(args，int&amp;);</p>\n<p>我们需要传进func1一个整形，经过func2的中间媒介，传入work，并在work中改变那个变量。</p>\n<p>读者可以试一下func2中使用什么样的参数，经过怎样的变换可以对原来的参数的性质原封不动的传递给work。这是比较简单的情况了。STL的部分函数实现会有恐怖的调用层次，如果不使用转发技术后果可想而知。</p>\n<h3 id=\"%E4%BD%BF%E7%94%A8std%3A%3Aforward%C2%A0\">使用std::forward </h3>\n<p>要说转发一定离不开std::forward</p>\n<p>forward返回实参类型的右值引用。它和move很像，但前者是返回给定类型的右值引用，如果给定的类型是左值引用也返回其右值引用——左值引用，并且其必须显式的指定模板参数；而move无论模板参数类型是什么都返回一个右值引用（只能是右值引用），因为前面已经看到了move的实现方法。</p>\n<p>于是我们可以定义下面的转发函数        </p>\n<pre><code class=\"language-cpp\">template &lt;typename F, typename T1, typename T2&gt;\nvoid fun(F f, T1 &amp;&amp; t1, T2 &amp;&amp; t2)\n{\n    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));\n}</code></pre>\n<p>使用右值引用作为模板参数——确保接受任意对象，并保证其能保持原来的性质不变（见引用折叠）。在发送参数的过程中获得对应类型的右值——确保其传递给函数的参数的性质不变（见引用折叠）。</p>\n<p>更简单的来说，上述的写法是对于所有类型的对象，无论进行何种参数传递，其参数的性质都不会改变的通用情况。</p>\n<h3 id=\"%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85%C2%A0\">转发参数包 </h3>\n<p>根据上面转发的关键字，我们可以知道，在进行转发的时候应该以何种模式进行包展开。</p>\n<pre><code>(Args&amp;&amp; ... args) //以右值引用展开参数包\nstd::forward&lt;Args&gt;(args)... //将包中的每一个元素应用于forward</code></pre>\n<p> 所以我们可以这样做</p>\n<pre><code class=\"language-cpp\">template&lt;typename ... Args&gt;\nvoid buffer_fun(Args &amp;&amp;... args)\n{\n    work(std::forward&lt;Args&gt;(args)...);\n}</code></pre>\n<h3 id=\"make_shared%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\">make_shared的工作原理</h3>\n<p>std::make_shred就是基于转发参数包实现的。</p>\n<p>让我们先来回忆make_shared的其中一个使用方法。</p>\n<p>make_shared&lt;T&gt; name (args);</p>\n<p>很明显的可以推断其应该使用用可变模板参数，我们转到其定义</p>\n<pre><code class=\"language-cpp\">  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }</code></pre>\n<p>可以看见，其使用部分特例化和可变参数模板，将包转发给了std::allocate_shared进行空间分配，我们进一步的转到std::allocate_shared中可以看见其有进一步的将其转发给了其他的模板</p>\n<pre><code class=\"language-cpp\">  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, \"make_shared&lt;T[]&gt; not supported\");\n\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }</code></pre>\n<hr/>\n<p>至此，C++的模板的基础知识点大抵应该是都讲完了，如果日后有一些杂项补充的话会更在下面。</p>\n<blockquote>\n<p>后来的话: 这篇文章有一些地方讲的还是比较不清晰的，现在已经修正了一部分，并且增添了对一部分知识点的代码，日后也会慢慢修改。如果你发现本篇文章的错误或者对本篇文章有什么建议可以评论区留言或者私信笔者。</p>\n<p>                                                                                                                        ——2022.6.1</p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-06 08:17:16", "summary": "模板是一个非常强大的功能，的各种组件也是基于模板的。所以，无论是写程序了，还是读程序，都有必要了解一下的模板。关于什么是模板或者模板的基本定义，这里就不讲述了，本篇文章主要罗列出在使用模板过程中的一些"}