{"blogid": "123442085", "writerAge": "码龄1年", "writerBlogNum": "266", "writerCollect": "706", "writerComment": "31", "writerFan": "29775", "writerGrade": "5级", "writerIntegral": "3128", "writerName": "普通网友", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123442085.jpg", "writerRankTotal": "暂无排名", "writerRankWeekly": "暂无排名", "writerThumb": "151", "writerVisitNum": "289136", "blog_read_count": "11394", "blog_time": "于 2022-03-12 13:03:33 发布", "blog_title": "Java实现Token登录验证(基于JWT的token认证实现)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_2\"></a>文章目录</h3>\n<ul><li><a href=\"#JWT_10\">一、JWT是什么？</a></li><li><a href=\"#_73\">二、使用步骤</a></li><li>\n<ul><li><a href=\"#1_74\">1.项目结构</a></li><li><a href=\"#2_79\">2.相关依赖</a></li><li><a href=\"#3_161\">3.数据库</a></li><li><a href=\"#4_165\">4.相关代码</a></li></ul> </li><li><a href=\"#_807\">三、测试结果</a></li></ul>\n<hr/>\n<h1><a id=\"JWT_14\"></a>一、JWT是什么？</h1>\n<p><strong>在介绍JWT之前，我们先来回顾一下利用token进行用户身份验证的流程：</strong></p>\n<p>1、客户端使用用户名和密码请求登录</p>\n<p>2、服务端收到请求，验证用户名和密码</p>\n<p>3、验证成功后，服务端会签发一个token，再把这个token返回给客户端</p>\n<p>4、客户端收到token后可以把它存储起来，比如放到cookie中</p>\n<p>5、客户端每次向服务端请求资源时需要携带服务端签发的token，可以在cookie或者header中携带</p>\n<p>6、服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求数据</p>\n<p><strong>这种基于token的认证方式相比传统的session认证方式更节约服务器资源，并且对移动端和分布式更加友好。其优点如下</strong>：</p>\n<p><strong>支持跨域访问</strong>：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题<br/> <strong>无状态</strong>：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力<br/> <strong>更适用CDN</strong>：可以通过内容分发网络请求服务端的所有资料<br/> <strong>更适用于移动端</strong>：当客户端是非浏览器平台时，cookie是不被支持的，此时采用token认证方式会简单很多<br/> <strong>无需考虑CSRF</strong>：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御</p>\n<p>而JWT就是上述流程当中token的一种具体实现方式，其全称是JSON Web Token，官网地址：https://jwt.io/</p>\n<p><strong>通俗地说，JWT的本质就是一个字符串，它是将用户信息保存到一个Json字符串中，然后进行编码后得到一个JWT token，并且这个JWT token带有签名信息，接收后可以校验是否被篡改，所以可以用于在各方之间安全地将信息作为Json对象传输。JWT的认证流程如下：</strong></p>\n<p>1、首先，前端通过Web表单将自己的用户名和密码发送到后端的接口，这个过程一般是一个POST请求。建议的方式是通过SSL加密的传输(HTTPS)，从而避免敏感信息被嗅探</p>\n<p>2、后端核对用户名和密码成功后，将包含用户信息的数据作为JWT的Payload，将其与JWT Header分别进行Base64编码拼接后签名，形成一个JWT Token，形成的JWT Token就是一个如同lll.zzz.xxx的字符串<br/> 3、后端将JWT Token字符串作为登录成功的结果返回给前端。前端可以将返回的结果保存在浏览器中，退出登录时删除保存的JWT Token即可</p>\n<p>4、前端在每次请求时将JWT Token放入HTTP请求头中的Authorization属性中(解决XSS和XSRF问题)</p>\n<p>5、后端检查前端传过来的JWT Token，验证其有效性，比如检查签名是否正确、是否过期、token的接收方是否是自己等等</p>\n<p>6、验证通过后，后端解析出JWT Token中包含的用户信息，进行其他逻辑操作(一般是根据用户信息得到权限等)，返回结果<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6a5fc85d64234b81a7fcdddd8aec0cfc.png\"/></p>\n<p>最后：说白了，JWT：JSON Web Token，其实token就是一段字符串，由三部分组成：Header，Payload，Signature</p>\n<h1><a id=\"_57\"></a>二、使用步骤</h1>\n<h2><a id=\"1_60\"></a>1.项目结构</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a8472eb2c9f2427aaa02a64cae5f8eb5.png\"/></p>\n<h2><a id=\"2_65\"></a>2.相关依赖</h2>\n<pre><code>    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;8.0.22&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;\n            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;\n            &lt;version&gt;5.7.21&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.3.2&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.79&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;\n            &lt;version&gt;1.9.4&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.22&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-io&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n            &lt;version&gt;2.11.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;\n            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;\n            &lt;version&gt;4.1.2&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.13.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;version&gt;2.3.8.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.auth0&lt;/groupId&gt;\n            &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;\n            &lt;version&gt;3.18.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<h2><a id=\"3_148\"></a>3.数据库</h2>\n<p>这里进行测试，所以用户类只有用户名密码，自行创建<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7b47df126705476d8db70cb03d542c84.png\"/></p>\n<h2><a id=\"4_154\"></a>4.相关代码</h2>\n<p><strong>1、annotation包</strong><br/> PassToken：</p>\n<pre><code>package com.geesun.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:26\n * @description：用来跳过验证的 PassToken\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface PassToken {\n    boolean required() default true;\n}\n</code></pre>\n<p>UserLoginToken：</p>\n<pre><code>package com.geesun.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:26\n * @description：用于登录后才能操作的token\n */\n/*RetentionPolicy.RUNTIME:这种类型的Annotations将被JVM保留,\n所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用。*/\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UserLoginToken {\n    boolean required() default true;\n}\n</code></pre>\n<p><strong>2、common包</strong><br/> CodeMsg：</p>\n<pre><code>package com.geesun.common;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:26\n * @description：返回提示\n */\npublic class CodeMsg {\n    private int retCode;\n    private String message;\n    // 按照模块定义CodeMsg\n    // 通用异常\n    public static CodeMsg SUCCESS = new CodeMsg(0,\"success\");\n    public static CodeMsg SERVER_EXCEPTION = new CodeMsg(500100,\"服务端异常\");\n    public static CodeMsg PARAMETER_ISNULL = new CodeMsg(500101,\"输入参数为空\");\n    // 业务异常\n    public static CodeMsg USER_NOT_EXSIST = new CodeMsg(500102,\"用户不存在\");\n    public static CodeMsg ONLINE_USER_OVER = new CodeMsg(500103,\"在线用户数超出允许登录的最大用户限制。\");\n    public static CodeMsg SESSION_NOT_EXSIST =  new CodeMsg(500104,\"不存在离线session数据\");\n    public static CodeMsg NOT_FIND_DATA = new CodeMsg(500105,\"查找不到对应数据\");\n    public static CodeMsg USER_OR_PASS_ERROR = new CodeMsg(500102,\"账号或者密码错误，请重试！\");\n\n\n    private CodeMsg(int retCode, String message) {\n        this.retCode = retCode;\n        this.message = message;\n    }\n\n    public int getRetCode() {\n        return retCode;\n    }\n    public String getMessage() {\n        return message;\n    }\n    public void setMessage(String message) {\n        this.message = message;\n    }\n}\n</code></pre>\n<p>Result：</p>\n<pre><code>package com.geesun.common;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:26\n * @description：返回统一结果集\n */\npublic class Result&lt;T&gt; {\n\n    private String message;\n    private int retCode;\n    private T data;\n\n    private Result(T data) {\n        this.retCode = 200;\n        this.message = \"成功\";\n        this.data = data;\n    }\n\n    private Result(CodeMsg cm) {\n        if(cm == null){\n            return;\n        }\n        this.retCode = cm.getRetCode();\n        this.message = cm.getMessage();\n    }\n\n    /**\n     * 成功时候的调用\n     * @return\n     */\n    public static &lt;T&gt; Result&lt;T&gt; success(T data){\n        return new Result&lt;T&gt;(data);\n    }\n\n    /**\n     * 成功，不需要传入参数\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; Result&lt;T&gt; success(){\n        return (Result&lt;T&gt;) success(\"\");\n    }\n    /**\n     * 失败时候的调用\n     * @return\n     */\n    public static &lt;T&gt; Result&lt;T&gt; error(CodeMsg cm){\n        return new Result&lt;T&gt;(cm);\n    }\n    /**\n     * 失败时候的调用,扩展消息参数\n     * @param cm\n     * @param msg\n     * @return\n     */\n    public static &lt;T&gt; Result&lt;T&gt; error(CodeMsg cm,String msg){\n        cm.setMessage(cm.getMessage()+\"--\"+msg);\n        return new Result&lt;T&gt;(cm);\n    }\n    public T getData() {\n        return data;\n    }\n    public String getMessage() {\n        return message;\n    }\n    public int getRetCode() {\n        return retCode;\n    }\n}\n</code></pre>\n<p><strong>3、config包</strong><br/> InterceptorConfig：</p>\n<pre><code>package com.geesun.config;\n\nimport com.geesun.Interceptor.AuthenticationInterceptor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.format.FormatterRegistry;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.validation.MessageCodesResolver;\nimport org.springframework.validation.Validator;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.HandlerMethodReturnValueHandler;\nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.config.annotation.*;\nimport java.util.List;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:25\n * @description：新建Token拦截器\n */\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(authenticationInterceptor())\n                .addPathPatterns(\"/**\");    // 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录\n    }\n    @Bean\n    public AuthenticationInterceptor authenticationInterceptor() {\n        return new AuthenticationInterceptor();\n    }\n    @Override\n    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void addCorsMappings(CorsRegistry arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void addFormatters(FormatterRegistry arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void addViewControllers(ViewControllerRegistry arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configureAsyncSupport(AsyncSupportConfigurer arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configurePathMatch(PathMatchConfigurer arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; arg0) {\n        // TODO Auto-generated method stub\n\n    }\n    @Override\n    public MessageCodesResolver getMessageCodesResolver() {\n        // TODO Auto-generated method stub\n        return null;\n    }\n    @Override\n    public Validator getValidator() {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n}\n</code></pre>\n<p><strong>4、Interceptor包</strong><br/> AuthenticationInterceptor：</p>\n<pre><code>package com.geesun.Interceptor;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.exceptions.JWTDecodeException;\nimport com.auth0.jwt.exceptions.JWTVerificationException;\nimport com.geesun.annotation.PassToken;\nimport com.geesun.annotation.UserLoginToken;\nimport com.geesun.pojo.User;\nimport com.geesun.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.method.HandlerMethod;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.lang.reflect.Method;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:24\n * @description：拦截器\n */\npublic class AuthenticationInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    UserService userService;\n\n    @Override\n    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception {\n        String token = httpServletRequest.getHeader(\"token\");// 从 http 请求头中取出 token\n        // 如果不是映射到方法直接通过\n        if(!(object instanceof HandlerMethod)){\n            return true;\n        }\n        HandlerMethod handlerMethod=(HandlerMethod)object;\n        Method method=handlerMethod.getMethod();\n        //检查是否有passtoken注释，有则跳过认证\n        if (method.isAnnotationPresent(PassToken.class)) {\n            PassToken passToken = method.getAnnotation(PassToken.class);\n            if (passToken.required()) {\n                return true;\n            }\n        }\n        //检查有没有需要用户权限的注解\n        if (method.isAnnotationPresent(UserLoginToken.class)) {\n            UserLoginToken userLoginToken = method.getAnnotation(UserLoginToken.class);\n            if (userLoginToken.required()) {\n                // 执行认证\n                if (token == null) {\n                    throw new RuntimeException(\"无token，请重新登录\");\n                }\n                // 获取 token 中的 user id\n                String userId;\n                try {\n                    userId = JWT.decode(token).getAudience().get(0);\n                } catch (JWTDecodeException j) {\n                    throw new RuntimeException(\"401\");\n                }\n                User user = userService.findUserById(userId);\n                if (user == null) {\n                    throw new RuntimeException(\"用户不存在，请重新登录\");\n                }\n                // 验证 token\n                JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build();\n                try {\n                    jwtVerifier.verify(token);\n                } catch (JWTVerificationException e) {\n                    throw new RuntimeException(\"401\");\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n\n    }\n    @Override\n    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n\n    }\n}\n</code></pre>\n<p><strong>5、utils包</strong><br/> TokenUtil：</p>\n<pre><code>package com.geesun.utils;\n\nimport com.auth0.jwt.JWT;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:24\n * @description：\n */\npublic class TokenUtil {\n\n    public static String getTokenUserId() {\n        String token = getRequest().getHeader(\"token\");// 从 http 请求头中取出 token\n        String userId = JWT.decode(token).getAudience().get(0);\n        return userId;\n    }\n\n    /**\n     * 获取request\n     * @return\n     */\n    public static HttpServletRequest getRequest() {\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder\n                .getRequestAttributes();\n        return requestAttributes == null ? null : requestAttributes.getRequest();\n    }\n\n}\n</code></pre>\n<p><strong>6、pojo包</strong><br/> User：</p>\n<pre><code>package com.geesun.pojo;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@TableName(value = \"`user`\")\npublic class User implements Serializable {\n    @TableId(value = \"id\", type = IdType.NONE)\n    private String id;\n\n    @TableField(value = \"username\")\n    private String username;\n\n    @TableField(value = \"password\")\n    private String password;\n\n    private static final long serialVersionUID = 1L;\n}\n</code></pre>\n<p><strong>7、controller包</strong><br/> UserController：</p>\n<pre><code>package com.geesun.controller;\n\nimport cn.hutool.json.JSONObject;\nimport com.geesun.annotation.UserLoginToken;\nimport com.geesun.common.CodeMsg;\nimport com.geesun.common.Result;\nimport com.geesun.pojo.User;\nimport com.geesun.service.UserService;\nimport com.geesun.service.impl.TokenService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/26 10:47\n * @description：\n */\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private TokenService tokenService;\n\n    /**\n     * 查询用户信息\n     * @return\n     */\n    @UserLoginToken\n    @GetMapping(\"/list\")\n    public Result&lt;Object&gt; list(){\n        return Result.success(userService.list());\n    }\n\n\n    /**\n     * 登录验证\n     * @param user\n     * @param response\n     * @return\n     */\n    @RequestMapping(value = \"/login\" ,method = RequestMethod.GET)\n    public Result&lt;Object&gt; login(User user, HttpServletResponse response) {\n        JSONObject jsonObject = new JSONObject();\n        //获取用户账号密码\n        User userForBase = new User();\n        userForBase.setId(userService.findByUsername(user).getId());\n        userForBase.setUsername(userService.findByUsername(user).getUsername());\n        userForBase.setPassword(userService.findByUsername(user).getPassword());\n        //判断账号或密码是否正确\n        if (!userForBase.getPassword().equals(user.getPassword())) {\n            return Result.error(CodeMsg.USER_OR_PASS_ERROR);\n        } else {\n            String token = tokenService.getToken(userForBase);\n            jsonObject.put(\"token\", token);\n            Cookie cookie = new Cookie(\"token\", token);\n            cookie.setPath(\"/\");\n            response.addCookie(cookie);\n            return Result.success(jsonObject);\n        }\n    }\n    \n}\n</code></pre>\n<p><strong>8、service包</strong><br/> UserService接口：</p>\n<pre><code>package com.geesun.service;\n\nimport com.baomidou.mybatisplus.extension.service.IService;\nimport com.geesun.pojo.User;\n\npublic interface UserService extends IService&lt;User&gt; {\n\n\n    int deleteByIds(Long[] ids);\n\n    int addUser(User user);\n\n    User findByUsername(User user);\n\n    User findUserById(String userId);\n}\n</code></pre>\n<p>UserServiceImpl实现类:</p>\n<pre><code>package com.geesun.service.impl;\n\nimport cn.hutool.core.util.ArrayUtil;\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.geesun.mapper.UserMapper;\nimport com.geesun.pojo.User;\nimport com.geesun.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Arrays;\n\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n    \n    /**\n     * 判断用户名\n     * @param user\n     * @return\n     */\n    public User findByUsername(User user){\n        return userMapper.selectOne(new LambdaQueryWrapper&lt;User&gt;().eq(User::getUsername,user.getUsername()));\n    }\n\n    public User findUserById(String userId) {\n        return userMapper.selectById(userId);\n    }\n\n}\n</code></pre>\n<p>TokenService:</p>\n<pre><code>package com.geesun.service.impl;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.geesun.pojo.User;\nimport org.springframework.stereotype.Service;\nimport java.util.Date;\n\n/**\n * @author ：Mr.ZJW\n * @date ：Created 2022/2/28 10:20\n * @description：\n */\n@Service\npublic class TokenService {\n\n    public String getToken(User user) {\n        Date start = new Date();\n        long currentTime = System.currentTimeMillis() + 60* 60 * 1000;//一小时有效时间\n        Date end = new Date(currentTime);\n        String token = \"\";\n\n        token = JWT.create().withAudience(user.getId()).withIssuedAt(start).withExpiresAt(end)\n                .sign(Algorithm.HMAC256(user.getPassword()));\n        return token;\n    }\n}\n</code></pre>\n<p><strong>9、mapper包</strong></p>\n<pre><code>package com.geesun.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.geesun.pojo.User;\n\npublic interface UserMapper extends BaseMapper&lt;User&gt; {\n\n}\n</code></pre>\n<h1><a id=\"_797\"></a>三、测试结果</h1>\n<p><strong>1、登录验证</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\62f8146951be45bda886a3c45aa510ee.png\"/><br/> <strong>2、查询用户信息</strong><br/> 这个方法加上了@UserLoginToken，所以要token才能查询<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\feaa3c6973b94f27b9edb8a7dcd7754d.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a31df33b052e412fa3e7ae1dd04ab6a0.png\"/><br/> 3、不加上Token进行测试就会出错提示<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fa9a54a017624038be1929e7c92910c7.png\"/><br/> 出错提示：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6a530c6d91134095b565b7a4142ee610.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\733cb18cc9f94aaf9ccddad436625188.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-03-12 13:03:33", "summary": "文章目录一、是什么？二、使用步骤项目结构相关依赖数据库相关代码三、测试结果一、是什么？在介绍之前，我们先来回顾一下利用进行用户身份验证的流程：、客户端使用用户名和密码请求登录、服务端收到请求，验证用户"}