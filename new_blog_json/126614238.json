{"blogid": "126614238", "writerAge": "码龄171天", "writerBlogNum": "33", "writerCollect": "739", "writerComment": "1037", "writerFan": "1865", "writerGrade": "5级", "writerIntegral": "3106", "writerName": "雪芙花", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126614238.jpg", "writerRankTotal": "7107", "writerRankWeekly": "553", "writerThumb": "1179", "writerVisitNum": "14505", "blog_read_count": "540", "blog_time": "已于 2022-09-05 09:01:14 修改", "blog_title": "C++精通之路：设计模式（特殊类设计）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#C_5\">C++精通之路：设计模式（特殊类设计）</a></li><li><ul><li><a href=\"#1_15\">1.请设计一个类，只能在堆上创建对象</a></li><li><a href=\"#2___61\">2. 请设计一个类，只能在栈上创建对象</a></li><li><a href=\"#3__100\">3. 请设计一个类，不能被拷贝</a></li><li><a href=\"#4__145\">4. 请设计一个类，不能被继承</a></li><li><a href=\"#5__179\">5. 请设计一个类，只能创建一个对象(单例模式)</a></li><li><ul><li><a href=\"#_181\">设计模式</a></li><li><a href=\"#_205\">饿汉模式</a></li><li><a href=\"#_241\">懒汉模式</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_318\">总结：</a></li><li><a href=\"#ps_331\">ps</a></li></ul>\n</div>\n<p></p>\n<blockquote>\n<p>很多小伙伴为了刷题发愁<br/> 今天为大家推荐一款刷题神奇哦：<a href=\"https://www.nowcoder.com/link/pc_csdncpt_xfh_sf\">刷题面试神器牛客</a><br/> 各大互联网大厂面试真题。从基础到入阶乃至原理刨析类面试题 应有尽有，赶快来装备自己吧！助你面试稳操胜券，solo全场面试官</p>\n</blockquote>\n<h1><a id=\"C_5\"></a>C++精通之路：设计模式（特殊类设计）</h1>\n<ul><li>本节内容：</li></ul>\n<blockquote>\n<p>介绍常见特殊类的设计方式</p>\n</blockquote>\n<h2><a id=\"1_15\"></a>1.请设计一个类，只能在堆上创建对象</h2>\n<ul><li>实现方式：</li></ul>\n<ol><li>将类的构造函数<strong>私有</strong>，拷贝构造声明成私有。防止别人调用拷贝在栈上生成对象。</li><li>提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建</li><li>从而达到了在栈上无法开辟空间，只能通过CreateObject（）函数在堆上创建空间</li></ol>\n<pre><code class=\"prism language-c++\">class HeapOnly\n{\npublic:\n\tstatic HeapOnly* CreateObj()\n\t{\n\t\treturn new HeapOnly;//因为构造函数已经是私有的了，所以只能通过这个函数来创建对象\n\t}\n     //在堆区的拷贝函数\n\t//static HeapOnly* CopyObj(const HeapOnly&amp; h)\n\t//{\n\t//\treturn new HeapOnly(h);\n\t//}\nprivate:\n\tHeapOnly()\n\t{}\n\t// 拷贝构造私有，并且只声明不实现(实现也是可以，但是没人用)\n\t// C++98 -- 防拷贝\n\t/*HeapOnly(const HeapOnly&amp;)\n\t{}*/\n\t//public:\n\t//\t// C++11\n\tHeapOnly(const HeapOnly&amp;) = delete;\n};\n</code></pre>\n<blockquote>\n<p>在堆上不能创建：</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\32d9d41e5fb0257885ab0bb0000594e1.png\"/></p>\n</blockquote>\n<blockquote>\n<p>在堆上通过CreateObj()函数即可创建对象</p>\n<p><img alt=\"image-20220830175531681\" src=\"..\\..\\static\\image\\1d941f1445ee1ba9b8856d2c55276d08.png\"/></p>\n</blockquote>\n<h2><a id=\"2___61\"></a>2. 请设计一个类，只能在栈上创建对象</h2>\n<ul><li>方法一：</li></ul>\n<blockquote>\n<p>同理，将构造函数私有化，然后设计静态方法创建对象返回即可。</p>\n</blockquote>\n<pre><code class=\"prism language-c++\">class StackOnly\n{\npublic:\nstatic StackOnly CreateObject()\n{\nreturn StackOnly();\n}\nprivate:\nStackOnly() {}\n};\n</code></pre>\n<ul><li>方法二：屏蔽new</li></ul>\n<blockquote>\n<ol><li> <p>原理是用私有的new来覆盖掉编译器提供的全局new，从而达到屏蔽new的效果</p> </li><li> <p>因为new<strong>在底层调用</strong>void* operator new(size_t size)<strong>函数，只需将该函数屏蔽掉</strong>即可。<br/> 注意：<strong>也要防止定位</strong>new</p> </li></ol>\n</blockquote>\n<pre><code class=\"prism language-c++\">class StackOnly\n{\npublic:\nStackOnly() {}\nprivate:\nvoid* operator new(size_t size);\nvoid operator delete(void* p);\n};\n</code></pre>\n<h2><a id=\"3__100\"></a>3. 请设计一个类，不能被拷贝</h2>\n<p>拷贝只会放生在两个场景中：</p>\n<ol><li>拷贝构造函数</li><li>赋值运算符重载</li></ol>\n<blockquote>\n<p>因此<strong>想要让一个类禁止拷贝，只需让该类不能调用拷贝构造函数以及赋值运算符重载即可</strong></p>\n</blockquote>\n<ul><li>C++98</li></ul>\n<pre><code class=\"prism language-c++\">class CopyBan\n{\n// ...\nprivate:\nCopyBan(const CopyBan&amp;);\nCopyBan&amp; operator=(const CopyBan&amp;);\n//...\n};\n</code></pre>\n<blockquote>\n<p>将拷贝构造函数与赋值运算符重载只声明不定义，并且将其访问权限设置为私有即可</p>\n</blockquote>\n<ul><li>原理：</li></ul>\n<ol><li>设置成私有：如果只声明没有设置成private，用户自己如果在类外定义了，就可以不能禁止拷贝了</li><li>只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不写反而还简单，而且如果定义了就不会防止成员函数内部拷贝了。</li></ol>\n<ul><li>C++11 ：</li></ul>\n<blockquote>\n<p>C++11扩展delete的用法，delete除了释放new申请的资源外，如果在默认成员函数后跟上=delete，表示让编译器删除掉该默认成员函数</p>\n</blockquote>\n<pre><code class=\"prism language-c++\">class CopyBan\n{\n// ...\nCopyBan(const CopyBan&amp;)=delete;\nCopyBan&amp; operator=(const CopyBan&amp;)=delete;\n//...\n};\n</code></pre>\n<h2><a id=\"4__145\"></a>4. 请设计一个类，不能被继承</h2>\n<ul><li>C++98方式</li></ul>\n<pre><code class=\"prism language-c++\">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承\nclass NonInherit\n{\npublic:\nstatic NonInherit GetInstance()\n{\nreturn NonInherit();\n}\nprivate:\nNonInherit()\n{}\n};\n</code></pre>\n<blockquote>\n<p>原理：子类调不到父类的构造函数，所以不能实例化，所以无法继承</p>\n</blockquote>\n<ul><li>C++11方法</li></ul>\n<blockquote>\n<p>final关键字，**final****修饰类，表示该类不能被继承。</p>\n</blockquote>\n<pre><code class=\"prism language-c++\">class A final\n{\n// ....\n};\n</code></pre>\n<h2><a id=\"5__179\"></a>5. 请设计一个类，只能创建一个对象(单例模式)</h2>\n<h3><a id=\"_181\"></a>设计模式</h3>\n<ul><li>介绍：</li></ul>\n<blockquote>\n<p>设计模式（Design Pattern）是一套<strong>被反复使用、多数人知晓的、经过分类的、代码设计经验的总结</strong>。为什么会产生设计模式这样的东西呢？就像人类历史发展会产生兵法。最开始部落之间打仗时都是人拼人的对砍。后来春秋战国时期，七国之间经常打仗，就发现打仗也是有<strong>套路</strong>的，后来孙子就总结出了《孙子兵法》。孙子兵法也是类似。</p>\n</blockquote>\n<ul><li>使用设计模式的目的：</li></ul>\n<blockquote>\n<ol><li>为了代码可重用性</li><li>让代码更容易被他人理解</li><li>保证代码可靠性。</li><li>设计模式使代码编写真正工程化</li><li>设计模式是软件工程的基石脉络，如同大厦的结构一样。</li></ol>\n</blockquote>\n<ul><li>实现：</li></ul>\n<blockquote>\n<p>一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。</p>\n</blockquote>\n<ul><li>单例模式有两种实现模式：</li></ul>\n<h3><a id=\"_205\"></a>饿汉模式</h3>\n<blockquote>\n<p>就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。</p>\n</blockquote>\n<pre><code class=\"prism language-c++\">class Singleton\n{\npublic:\nstatic Singleton* GetInstance()\n{\nreturn &amp;m_instance;\n}\nprivate:\n// 构造函数私有\nSingleton(){};\n// C++98 防拷贝\nSingleton(Singleton const&amp;);\nSingleton&amp; operator=(Singleton const&amp;);\n// or\n// C++11\nSingleton(Singleton const&amp;) = delete;\nSingleton&amp; operator=(Singleton const&amp;) = delete;\nstatic Singleton m_instance;\n};\nSingleton Singleton::m_instance; // 在程序入口之前就完成单例对象的初始化\n</code></pre>\n<ul><li>优点： \n  <ol><li>简单</li><li>如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避免资源竞争，提高响应速度更好。</li></ol> </li><li>缺点： \n  <ol><li>可能会导致进程启动慢(因为要在程序运行初始化好对象，对象过大时可能会导致初始化运行时间过长，从而让用户感受到进程启动慢)。</li><li>且如果有多个单例类对象实例启动顺序不确定。所以假如在继承条件下，无法保证父类在子类之前初始化。</li></ol> </li></ul>\n<h3><a id=\"_241\"></a>懒汉模式</h3>\n<blockquote>\n<p>如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（<strong>延迟加载</strong>）更好。</p>\n</blockquote>\n<pre><code class=\"prism language-C++\">#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\nusing namespace std;\nclass Singleton\n{\npublic:\nstatic Singleton* GetInstance() {\n// 注意这里一定要使用Double-Check的方式加锁，才能保证效率和线程安全\nif (nullptr == m_pInstance) //双重判断，使效率提高\n{\n     m_mtx.lock();\n  if (nullptr == m_pInstance) \n  {\n  m_pInstance = new Singleton();\n  }\n    m_mtx.unlock();\n}\nreturn m_pInstance;\n}\n// 实现一个内嵌垃圾回收类\nclass CGarbo {\npublic:\n~CGarbo(){\nif (Singleton::m_pInstance)\ndelete Singleton::m_pInstance;\n}\n};\n// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象\nstatic CGarbo Garbo;\nprivate:\n// 构造函数私有\nSingleton(){};\n// 防拷贝\nSingleton(Singleton const&amp;);\nSingleton&amp; operator=(Singleton const&amp;);\nstatic Singleton* m_pInstance; // 单例对象指针\nstatic mutex m_mtx; //互斥锁\n};\nSingleton* Singleton::m_pInstance = nullptr;\nSingleton::CGarbo Garbo;\nmutex Singleton::m_mtx;\nvoid func(int n)\n{\ncout&lt;&lt; Singleton::GetInstance() &lt;&lt; endl;\n}\n\nint main()\n{\nthread t1(func, 10);\nthread t2(func, 10);\nt1.join();\nt2.join();\ncout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;\ncout &lt;&lt; Singleton::GetInstance() &lt;&lt; endl;\n}\n</code></pre>\n<ul><li>优点：</li></ul>\n<ol><li>进程启动无负载。</li><li>多个单例实例启动顺序自由控制。</li><li>不会出现饿汉模式下：如果有多个单例类对象实例启动顺序不确定的情况</li></ol>\n<ul><li>缺点：</li></ul>\n<ol><li>复杂 ，因为在多线程下，单例模式下的对象相当于<strong>临界资源</strong>. \n  <ol><li>饿汉模式下,在程序启动时就将对象初始化了，要调用对象时，只需返回指针（只进行了读操作，没有进行写操作）。所以不需要管理此行为</li><li>而在懒汉模式下，在程序启动时，对象未初始化。需要在static Singleton* GetInstance() 函数内初始化，这里就有对临界资源的写操作了，所以要用到互斥锁等工具来保护临界资源，较为复杂</li></ol> </li></ol>\n<h1><a id=\"_318\"></a>总结：</h1>\n<blockquote>\n<p>以上这几种设计都是通过staic的特性来实现的</p>\n</blockquote>\n<ol><li> <p>前面四种条件是通过将目标函数<strong>私有化</strong>，使其在外部不可调用。且用staic成员函数来在特定的条件下实行构造。（用到了staic成员函数可在类未初始化时就可调用的特性）</p> </li><li> <p>单例模式则是通过staic成员变量的<strong>原子性</strong>来实现的。单例模式利用了一个<strong>staic 成员指针</strong>，指向一个类。再通过将目标函数（构造函数等）私有化，使其在外部不可调用。且用staic成员函数来实现对类的构造。</p>\n<ol><li> <p>在创造的时机上又有两种模式：</p> <pre><code>      1. 懒汉模式\n      2. 饿汉模式\n</code></pre> </li></ol> </li></ol>\n<h1><a id=\"ps_331\"></a>ps</h1>\n<blockquote>\n<p>想和博主一样刷优质面试和算法题嘛，快来<a href=\"https://www.nowcoder.com/link/pc_csdncpt_xfh_sf\">刷题面试神器牛客</a>吧，期待与你在牛客相见</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 09:01:14", "summary": "文章目录精通之路：设计模式特殊类设计请设计一个类，只能在堆上创建对象请设计一个类，只能在栈上创建对象请设计一个类，不能被拷贝请设计一个类，不能被继承请设计一个类，只能创建一个对象单例模式设计模式饿汉模"}