{"blogid": "126360273", "writerAge": "码龄5年", "writerBlogNum": "41", "writerCollect": "140", "writerComment": "4", "writerFan": "182", "writerGrade": "3级", "writerIntegral": "441", "writerName": "观于海者难为水", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126360273.jpg", "writerRankTotal": "36963", "writerRankWeekly": "2080", "writerThumb": "14", "writerVisitNum": "15233", "blog_read_count": "5662", "blog_time": "于 2022-08-16 10:25:23 发布", "blog_title": "有哪些SQL优化的手段？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><ul><li><a href=\"#11_SQL_2\">1.1 SQL的性能分析</a></li><li><ul><li><a href=\"#111__show_status__SQL__6\">1.1.1 通过 show status 命令了解各种 SQL 的执行频率</a></li><li><a href=\"#112__34\">1.1.2 慢查询日志</a></li><li><a href=\"#113_profile_61\">1.1.3 profile分析</a></li><li><a href=\"#114__EXPLAIN__SQL__105\">1.1.4 通过 EXPLAIN 分析低效 SQL 的执行计划</a></li></ul>\n</li><li><a href=\"#12_SQL_185\">1.2 常用的SQL语句优化</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h3><a id=\"11_SQL_2\"></a>1.1 SQL的性能分析</h3>\n<p>  当面对一个有 SQL 性能问题的数据库时，我们应该首先进行系统的分析，使得能够尽快定位问题 ，并通过优化SQL 从而解决问题。</p>\n<h4><a id=\"111__show_status__SQL__6\"></a>1.1.1 通过 show status 命令了解各种 SQL 的执行频率</h4>\n<p>  MySQL 客户端连接成功后，通过 show [session|global]status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">like</span> <span class=\"token string\">'Com_%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\592e5f4f75b14d8e93604b717fcddf26.png\"/></p>\n<p>Com_xxx 表示执行xxx操作，Value表示每个 xxx 语句执行的次数，通常比较关心的是以下几个统计参数。</p>\n<ul><li>Com_select：执行 SELECT 操作的次数，一次查询只累加 1。</li><li>Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</li><li>Com_update：执行 UPDATE 操作的次数。</li><li>Com_delete：执行 DELETE 操作的次数。</li></ul>\n<p>  通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。</p>\n<p>  对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p>\n<p>此外，以下几个参数便于用户了解数据库的基本情况。</p>\n<ul><li>Connections：试图连接 MySQL 服务器的次数。</li><li>Uptime：服务器工作时间。</li><li>Slow_queries：慢查询的次数。</li></ul>\n<h4><a id=\"112__34\"></a>1.1.2 慢查询日志</h4>\n<p>  通过慢查询日志定位那些执行效率较低的 SQL 语句。慢查询日志会记录超出自己设置的时间还没有执行完毕的sql。默认情况下，MySQL数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%slow_query_log%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9b30ed2a94404682b6244f2d0e7a0b07.png\"/></p>\n<p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启。</p>\n<p>开启慢查询日志sql：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> slow_query_log<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>设置慢查询的超时时间（以秒为单位）：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> long_query_time<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf。</p>\n<h4><a id=\"113_profile_61\"></a>1.1.3 profile分析</h4>\n<ol><li>查看profile是否可用：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@profiling</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b27a3f49909843ab964a0be812bb0274.png\"/></p>\n<ol start=\"2\"><li>开启profile：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> profiling <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"3\"><li>查看当前会话下的所有sql执行时间：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> PROFILES<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6c9e754092424cc2baeff211664d0a21.png\"/></p>\n<ol start=\"4\"><li>查看具体sql的每个步骤消耗时间：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> PROFILE <span class=\"token keyword\">FOR</span> QUERY xx<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- xx是上图的query_id</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\799a23981295451d8fa21f16c6212128.png\"/></p>\n<ol start=\"5\"><li>查看具体sql的cpu消耗时间：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> PROFILE cpu <span class=\"token keyword\">FOR</span> QUERY xx<span class=\"token punctuation\">;</span>  <span class=\"token comment\">-- xx是query_id</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c13985bd7c984d3bb9e877468ccb7ea9.png\"/></p>\n<h4><a id=\"114__EXPLAIN__SQL__105\"></a>1.1.4 通过 EXPLAIN 分析低效 SQL 的执行计划</h4>\n<p>explain是非常重要的关键字，通过explain我们可以获得以下信息：</p>\n<ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul>\n<p>使用方法：<code>explain + SQL语句</code>，例如：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token number\">100030011</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dd9f2441a7d04c089d0aa2a5ebb0f7a9.png\"/></p>\n<ol><li><strong>id字段</strong></li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\13eccd5a6b4440e1ae155e8450e27e94.png\"/></p>\n<p>id可以认为是查询序列号，每一个id代表一个select，一句sql有两个select，就会有两行数据，两个id，不同的id代表不同的子查询。</p>\n<ul><li>id相同执行顺序由上至下。</li><li>id不同，id值越大优先级越高，越先被执行。</li><li>id为NULL最后执行。</li></ul>\n<ol start=\"2\"><li><strong>select_type：表示查询的类型</strong></li></ol>\n<p>常见的类型有：</p>\n<table><thead><tr><th align=\"left\">select_type</th><th align=\"left\">description</th></tr></thead><tbody><tr><td align=\"left\">SIMPLE</td><td align=\"left\">简单表，即不使用表连接或者子查询</td></tr><tr><td align=\"left\">PRIMARY</td><td align=\"left\">包含子查询时，外层查询就显示为 PRIMARY</td></tr><tr><td align=\"left\">UNION</td><td align=\"left\">UNION 中的第二个或者后面的查询语句</td></tr><tr><td align=\"left\">SUBQUERY</td><td align=\"left\">子查询中的第一个 SELECT</td></tr></tbody></table>\n<ol start=\"3\"><li><strong>table：输出结果集的表</strong></li></ol>\n<p>显示这一行的数据是关于哪张表的，有时不是真实的表名字，也可能是表的别名。</p>\n<ol start=\"4\"><li><strong>type：表示表的连接类型</strong></li></ol>\n<p>性能由好到差的连接类型为：system、const、eq_ref、ref、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、all等。</p>\n<table><thead><tr><th align=\"left\">type</th><th align=\"left\">description</th></tr></thead><tbody><tr><td align=\"left\">system</td><td align=\"left\">表中仅有一行，即常量表</td></tr><tr><td align=\"left\">const</td><td align=\"left\">单表中最多有一个匹配行，例如 primary key 或者 unique index</td></tr><tr><td align=\"left\">eq_ref</td><td align=\"left\">对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key或者 unique index</td></tr><tr><td align=\"left\">ref</td><td align=\"left\">与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index，而是使用普通的索引</td></tr><tr><td align=\"left\">ref_or_null</td><td align=\"left\">与 ref 类似，区别在于条件中包含对 NULL 的查询</td></tr><tr><td align=\"left\">index_merge</td><td align=\"left\">索引合并优化</td></tr><tr><td align=\"left\">unique_subquery</td><td align=\"left\">in 的后面是一个查询主键字段的子查询</td></tr><tr><td align=\"left\">index_subquery</td><td align=\"left\">与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询</td></tr><tr><td align=\"left\">range</td><td align=\"left\">单表中的范围查询</td></tr><tr><td align=\"left\">index</td><td align=\"left\">对于前面的每一行，都通过查询索引来得到数据</td></tr><tr><td align=\"left\">all</td><td align=\"left\">对于前面的每一行，都通过全表扫描来得到数据</td></tr></tbody></table>\n<ol start=\"5\"><li><strong>possible_keys：表示查询时，可能使用的索引。</strong></li><li><strong>key：表示实际使用的索引。</strong></li><li><strong>key_len：索引字段的长度。</strong></li><li><strong>rows：扫描行的数量。</strong></li><li><strong>Extra：执行情况的说明和描述。</strong></li></ol>\n<h3><a id=\"12_SQL_185\"></a>1.2 常用的SQL语句优化</h3>\n<ol><li>不要使用 SELECT *， 必须使用 SELECT &lt;字段列表&gt; 查询。查找哪个字段，就写具体的字段。例如：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> name<span class=\"token punctuation\">,</span> age <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> address <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>原因：</p>\n<ul><li>消耗更多的 CPU 和 IO 以网络带宽资源</li><li>无法使用和覆盖索引</li><li>可减少表结构变更带来的影响</li></ul>\n<ol start=\"2\"><li>不要使用不含字段列表的 INSERT 语句，例如：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">-- 不使用：</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> t <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 应该使用：</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> t<span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">,</span>c2<span class=\"token punctuation\">,</span>c3<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"3\"><li>避免使用子查询，可以把子查询优化为 join 操作。</li></ol>\n<p>子查询性能差的原因：</p>\n<p>  子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>\n<ol start=\"4\"><li>避免使用 JOIN 关联太多的表。</li></ol>\n<ul><li> <p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p> </li><li> <p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p> </li><li> <p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p> </li><li> <p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 张表，建议不超过 5 个。</p> </li></ul>\n<ol start=\"5\"><li>减少同数据库的交互次数。</li></ol>\n<ul><li>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</li></ul>\n<ol start=\"6\"><li>禁止使用 order by rand() 进行随机排序。</li></ol>\n<ul><li> <p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p> </li><li> <p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p> </li></ul>\n<ol start=\"7\"><li>WHERE 从句中禁止对列进行函数转换和计算。</li></ol>\n<ul><li> <p>对列进行函数转换或计算时，会导致引擎放弃使用索引而进行全表扫描。</p> </li><li> <p>这样的查询也会导致全表扫描：<code>select id from student where name like '%李%'</code>，可以考虑使用全文索引。</p> </li></ul>\n<ol start=\"8\"><li>在明显不会有重复值时使用 UNION ALL 而不是 UNION。</li></ol>\n<ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul>\n<ol start=\"9\"><li>拆分复杂的大 SQL 为多个小 SQL。</li></ol>\n<ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-08-16 10:25:23", "summary": "文章目录的性能分析通过命令了解各种的执行频率慢查询日志分析通过分析低效的执行计划常用的语句优化的性能分析当面对一个有性能问题的数据库时，我们应该首先进行系统的分析，使得能够尽快定位问题，并通过优化从而"}