{"blogid": "124761293", "writerAge": "码龄3年", "writerBlogNum": "28", "writerCollect": "116", "writerComment": "111", "writerFan": "52", "writerGrade": "3级", "writerIntegral": "608", "writerName": "Massachusetts_11", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124761293.jpg", "writerRankTotal": "31912", "writerRankWeekly": "56088", "writerThumb": "142", "writerVisitNum": "19238", "blog_read_count": "994", "blog_time": "已于 2022-05-17 14:24:23 修改", "blog_title": "内联函数（inline）详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"_0\"></a>为什么要有内联函数</h1>\n<p>在学习内联函数之前，大家可以写一个实现加法的宏<code>ADD()</code>，检测一下自己。</p>\n<p>如果对宏等预编译知识不太熟悉的话，可以先看一下这篇文章：<a href=\"http://t.csdn.cn/f5sge\">预编译</a>——2.2.4</p>\n<p>以下是一个正确的ADD宏：</p>\n<blockquote>\n<p>#define ADD(x,y) ((x)+(y))</p>\n</blockquote>\n<p>灵魂三问：</p>\n<ul><li> <p>你在 x 和 y 前面加类型了吗？</p> </li><li> <p>x 和 y 都加括号了吗？</p> </li><li> <p>整体加括号了吗？</p> </li></ul>\n<p>如果以上三个问题都对了，那么恭喜你，宏定义表达式学的还不错</p>\n<img alt=\"牛逼\" src=\"https://tse1-mm.cn.bing.net/th/id/OIP-C.1-EnCIQviJSauE3Bnr_bLAHaHa?pid=ImgDet&amp;rs=1\"/>\n<p>一个简简单单的<code>ADD（）</code>，就需要注意这么多问题，可以说宏这个知识点用起来着实是鸡肋，晦涩难懂；</p>\n<p>同时宏也是不支持调试的，也没有类型安全的检查。</p>\n<p>发明c++的大佬无疑也发现了这个问题，于是引出了内联函数的概念：用<strong>函数的语法</strong>解决<strong>宏</strong>的事。</p>\n<p>可能兄弟们要说了，直接用函数不就好了？</p>\n<p>如果是一个几十行的函数，函数本身执行就很耗时，那调用函数、创建栈帧的一两行可以忽略不计；但是如果一个函数本身就一两行，因为<strong>调用函数</strong>本身而产生的那一部分消耗，就格外突出，而宏或者内联的提前替换就显得格外优秀，提高了效率。</p>\n<h1><a id=\"_32\"></a>内联函数</h1>\n<h2><a id=\"_34\"></a>语法</h2>\n<p>只需要在函数的最前面加一句 <code>inline</code> ，如下：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"_45\"></a>概念</h2>\n<blockquote>\n<p>以 inline <strong>修饰</strong>的函数叫做内联函数，<strong>编译时</strong>C++编译器会在<strong>调用内联函数的地方展开</strong>，没有函数压栈的开销，内联函数提升程序运行的效率。</p>\n</blockquote>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\tret <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n\tret <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>为了观察内联函数的调用方式，我们看一下汇编代码：</p>\n<img alt=\"image-20220513102655067\" src=\"..\\..\\static\\image\\202205131026115.png\"/>\n<p>这是Debug模式下main函数的汇编代码。</p>\n<p>可以发现 <code>call add (0EA1465h)</code>这一句其实是在调用函数，但是如果按照开始的定义，既然直接展开了，那就不会有调用函数这一步。</p>\n<p>这是因为Debug模式下，为了调试方便，编译器默认不进行优化，也就是不会展开，依然使用一般函数的调用方式。</p>\n<p>以下，在VS环境下，打开对 <code>inline</code> 的优化再展示一遍：</p>\n<p><strong>设置优化<code>inline</code> ：</strong></p>\n<img alt=\"image-20220513103607003\" src=\"..\\..\\static\\image\\202205131036220.png\"/>\n<p><strong>优化后的汇编代码：</strong></p>\n<p>（注：汇编代码的打开方式：F10或Fn+F10进到调试模式–&gt;对任意语句右键–&gt;转到反汇编）</p>\n<p><img alt=\"image-20220513104111346\" src=\"..\\..\\static\\image\\e3af2138addadd3d634cdd6c6f5118bc.png\"/></p>\n<p>可以看到，优化之后<code>inline</code>修饰过的函数会直接展开。</p>\n<p>也就是说，在<strong>Debug模式</strong>下你写代码、调试代码时，<code>inline</code> 相当于普通函数，可以进行调试；在<strong>release模式</strong>下，又可直接进行原地展开，提高效率（这里指的是避免了调用函数、创建栈帧等方面的资源消耗）</p>\n<h1><a id=\"_88\"></a>特性</h1>\n<ol><li> <p>inline是一种以空间换时间的做法，省去调用函数、建立栈帧的额外开销；<br/>但是如果<strong>代码很长</strong>（一般是10行左右，具体取决于编译器），或者有<strong>递归函数</strong>，就不适宜使用递归函数。</p> </li><li> <p><strong>inline对于编译器而言只是一个建议</strong>，编译器归自动优化，如果定义的<strong>函数很长</strong>或者<strong>递归函数</strong>等等，编译器优化时会忽略掉内联。</p> </li><li> <p>inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。<br/> 测试：<br/> <code>F.h</code></p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre> <p><code>F.cpp</code></p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"F.h\"</span></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre> <p><code>main.cpp</code></p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"F.h\"</span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre> <p><strong>报错：</strong></p>\n<blockquote>\n<p>error LNK2019: 无法解析的外部符号 “void __cdecl f(int)” (?f@@YAXH@Z)，函数 _main 中引用了该符号</p>\n</blockquote> <p><strong>分析：</strong><br/> 首先把.h中的内容替换到.cpp中，替换之后<br/> <code>F.cpp</code></p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre> <p>在编译过程中，编译器一看，这里的 <code>f()</code> 是个inline，</p> <p>inline就是说，“我”在调用的地方已经展开了，那么还需要这个给函数一个地址吗？不需要。</p> <p>也就说F.cpp生成的符号表中，不会有<code>f()</code>的地址。</p> <p>然后一链接，main.cpp中的 <code>f(10)；</code> 就要去<code>F文件</code>给过来的符号表找 <code>f()</code> 的地址，找不到就会报链接错误。</p> <p><em>(注：如果大家对编译链接的知识感兴趣，可以看一下这篇文章：<a href=\"https://blog.csdn.net/yue152152/article/details/124507560?spm=1001.2014.3001.5502\">点我</a>)</em></p> <p><strong>改正：</strong></p> <p>那怎么写呢？</p> <p>不在F.cpp中写这个函数的定义，直接把声明、定义（可以只有定义，更香）都放到 <code>F.h</code> 中去，预编译阶段会直接把内联函数换到main.cpp，相当于在main.cpp头顶上定义了这个内联函数，编译阶段就直接在调用的地方被展开。<br/> <code>F.h</code></p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre> <p><code>main.cpp</code></p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"F.h\"</span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre> </li></ol>\n<h1><a id=\"_176\"></a>知识大总结</h1>\n<ul><li>宏的优缺点： \n  <ul><li>优点： \n    <ol><li>增强代码的复用性。</li><li>提高性能。</li></ol> </li><li>缺点： \n    <ol><li>不方便宏调试（因为预编译就进行了替换）</li><li>导致代码可读性变差，可维护性变差，容易误用。</li><li>没有类型安全的检查。</li></ol> </li></ul> </li><li>C++有哪些技术替代宏： \n  <ol><li>常量定义——换用const</li><li>函数定义——换用内联函数</li></ol> </li></ul>\n<p>：<br/> - 优点：<br/> 1. 增强代码的复用性。<br/> 2. 提高性能。<br/> - 缺点：<br/> 1. 不方便宏调试（因为预编译就进行了替换）<br/> 2. 导致代码可读性变差，可维护性变差，容易误用。<br/> 3. 没有类型安全的检查。</p>\n<ul><li>C++有哪些技术替代宏： \n  <ol><li>常量定义——换用const</li><li>函数定义——换用内联函数</li></ol> </li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-17 14:24:23", "summary": "为什么要有内联函数在学习内联函数之前，大家可以写一个实现加法的宏，检测一下自己。如果对宏等预编译知识不太熟悉的话，可以先看一下这篇文章：预编译以下是一个正确的宏：灵魂三问：你在和前面加类型了吗？和都加"}