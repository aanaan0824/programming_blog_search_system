{"blogid": "126640744", "writerAge": "码龄1年", "writerBlogNum": "89", "writerCollect": "1108", "writerComment": "1784", "writerFan": "4058", "writerGrade": "5级", "writerIntegral": "4245", "writerName": "小白又菜", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126640744.jpg", "writerRankTotal": "4022", "writerRankWeekly": "310", "writerThumb": "1871", "writerVisitNum": "66897", "blog_read_count": "296", "blog_time": "于 2022-09-01 14:10:05 发布", "blog_title": "[ C++ ] template 模板进阶 (特化，分离编译)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>本篇内容包括C++ 非典型模板参数，类模板的特化，模板的分离编译。C++模板简单概念及其使用大家可点击此链接：<a href=\"https://blog.csdn.net/qq_58325487/article/details/126009209?spm=1001.2014.3001.5501\" title=\"[ C++ ] C++之模板template\">[ C++ ] C++之模板template</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%C2%A0%20%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#1.%C2%A0%20%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0\">1.  数组模板示例和非类型模板参数</a></p>\n<p id=\"2.%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96\">2.模板的特化</a></p>\n<p id=\"2.1%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96\">2.1什么是模板的特化</a></p>\n<p id=\"2.2%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96\">2.2 函数模板特化</a></p>\n<p id=\"2.3%C2%A0%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.3%C2%A0%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%C2%A0\">2.3 类模板特化 </a></p>\n<p id=\"2.3.1%20%E5%85%A8%E7%89%B9%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.1%20%E5%85%A8%E7%89%B9%E5%8C%96\">2.3.1 全特化</a></p>\n<p id=\"2.3.2%20%E5%81%8F%E7%89%B9%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.2%20%E5%81%8F%E7%89%B9%E5%8C%96\">2.3.2 偏特化</a></p>\n<p id=\"3.%20%E6%A8%A1%E6%9D%BF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20%E6%A8%A1%E6%9D%BF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91\">3. 模板分离编译</a></p>\n<p id=\"3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91\">3.1 什么是分离编译</a></p>\n<p id=\"3.2%20%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91\">3.2 模板的分离编译</a></p>\n<p id=\"3.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#3.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\">3.3 解决方法</a></p>\n<p id=\"4.%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93\">4.模板总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%C2%A0%20%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0\">1.  数组模板示例和非类型模板参数</h1>\n<p>        模板常用作容器类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同的类型。</p>\n<p>        首先介绍一个允许指定数组大小的简单数组模板。一种方法是在类中使用动态数组和构造函数参数来提供元素数目；另一种方法是使用模板参数来提供常规数组的大小，C++ 11 新增的模板array就是这样做的。</p>\n<p>代码示例：</p>\n<pre><code class=\"language-cpp\">// 定义一个模板类型的静态数组\ntemplate&lt;class T, size_t N = 10&gt;\nclass array\n{\npublic:\n\tT&amp; operator[](size_t index) { return _array[index]; }\n\tconst T&amp; operator[](size_t index)const { return _array[index]; }\n\n\tsize_t size()const { return _size; }\n\tbool empty()const { return 0 == _size; }\n\nprivate:\n\tT _array[N];\n\tsize_t _size;\n};</code></pre>\n<p>        上述代码中，关键字class(或在这种上下文中等价的关键字typename)指出T为类型参数，size_t 指出N的类型为无符号整数。这种参数(指定特殊的类型而不是用作泛型名)称为<span style=\"color:#fe2c24;\"><strong>非类型</strong></span>(non-type)或<strong><span style=\"color:#fe2c24;\">表达式</span>(</strong>expression)参数。</p>\n<p>        表达式参数有一些限制，<span style=\"color:#511b78;\"><strong>表达式参数可以是整型，枚举，引用或指针</strong></span>。因此，double是不合法的，但是double* 却是合法的。另外，模板代码不能修改参数的值，也不能使用参数的地址。所以，在array模板中不能使用类似++N或者&amp;N等表达式。另外，实例化模板时，用作表达式参数的值必须是常量表达式。</p>\n<p><span style=\"color:#0d0016;\"><strong>表达式参数的优点：</strong></span>        </p>\n<p>        与平常使用的构造函数方法相比，这种改变数组大小的方法有一个优点。构造函数 方法使用的是通过new和delete管理堆内存，而表达式参数方法使用的是为自动变量维护的内存栈。这样执行速度将更快，尤其是在使用了很多小型数组时。</p>\n<p><span style=\"color:#0d0016;\"><strong>表达式参数的缺点：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>        </strong>表达式参数的主要缺点是每种数组大小都将生成自己的模板。也就是说，下面的声明将生成两个独立的类声明：</span></p>\n<pre><code class=\"language-cpp\">ArrayTP&lt;double, 12&gt; eggweights; \nArrayTP&lt;double, 13&gt; donuts;</code></pre>\n<p>但下面的声明只生成一个类声明，并将数组大小信息传递给类的构造函数：</p>\n<pre><code class=\"language-cpp\">Stack&lt;int&gt; eggs(12);\nStack&lt;int&gt; dunkers(13);</code></pre>\n<p>        另一个区别是，构造函数方法更通用，这是因为数组大小是作为类成员(而不是硬编码)存储在定义中的。这样可以将一种尺寸的数组赋给另一种尺寸的数组，也可以创建允许数组大小可变的类。 </p>\n<p>       </p>\n<h1 id=\"2.%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96\">2.模板的特化</h1>\n<h2 id=\"2.1%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96\">2.1什么是模板的特化</h2>\n<div>\n<span style=\"color:#777777;\">通常情况下，</span>\n<span style=\"color:#777777;\"><strong>使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结</strong></span>\n<span style=\"color:#777777;\"><strong>果</strong></span>\n<span style=\"color:#777777;\">，需要特殊处理，比如：实现了一个专门用来进行小于比较的函数模板</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#777777;\">代码实例：</span>\n</div>\n<div></div>\n<div>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nbool Less(T left, T right)\n{\n\treturn left &lt; right;\n}\n\nint main()\n{\n\tcout &lt;&lt; Less(1, 2) &lt;&lt; endl;//可以比较\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"378\" src=\"..\\..\\static\\image\\1c25977aa6454a52a56ff9a2dfa7c9ea.png\" width=\"618\"/></p>\n<p></p>\n<p>当然我们之前实现的日期类，也可以通过模板来进行日期比较。</p>\n<p><img alt=\"\" height=\"488\" src=\"..\\..\\static\\image\\70429abee64340569c82b3c1394c3c1a.png\" width=\"669\"/></p>\n<p> </p>\n</div>\n<p>但是如果这下面这种情况还能拿到我们想要的结果吗？</p>\n<pre><code class=\"language-cpp\">\tDate* p1 = &amp;d1;\n\tDate* p2 = &amp;d2;\n\tcout &lt;&lt; Less(p1, p2) &lt;&lt; endl;</code></pre>\n<p>        此时的结果是不能，因此我们可以看到，Less绝大多数情况下都是可以正常比较的，但是在特殊场景下就得到错误的结果。正如此例，p1指向的d1显然小于p2指向的d2对象，但是Less内部并没有比较p1和p2指向的对象内容，而是比较的是p1和p2指针的地址，就无法达到预期而出现错误。</p>\n<p>        此时，就需要对模板进行特化。即：在原模板的基础上，针对特殊类型所进行特殊化的实现方式。模板特化中分为函数模板特化与类模板特化。</p>\n<p></p>\n<h2 id=\"2.2%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96\">2.2 函数模板特化</h2>\n<blockquote>\n<p>函数模板特化步骤：</p>\n<p>        1.必须先有一个基础的函数模板。</p>\n<p>        2.关键字template后面接一个对空的尖括号&lt;&gt;</p>\n<p>        3.函数名后跟一对进括号，尖括号中指定需要特化的类型</p>\n<p>        4.函数形参表：必须要和模板函数的基础参数类型完全相同，如果不同编译可能会报错。</p>\n</blockquote>\n<p>现就将刚才日期类进行函数模板特化：</p>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nbool Less(T left, T right)\n{\n\treturn left &lt; right;\n}\n\n//日期类函数模板特化\ntemplate&lt;&gt;\nbool Less&lt;Date*&gt;(Date* left, Date* right)\n{\n\treturn *left &lt; *right;\n}\nint main()\n{\n\tcout &lt;&lt; Less(1, 2) &lt;&lt; endl;//可以比较\n\n\tDate d1(2022, 7, 7);\n\tDate d2(2022, 7, 8);\n\tcout &lt;&lt; Less(d1, d2) &lt;&lt; endl;\n\n\tDate* p1 = &amp;d1;\n\tDate* p2 = &amp;d2;\n\tcout &lt;&lt; Less(p1, p2) &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p>此时，我们就达到了想要的结果。注意，一般情况下如果函数模板遇到不能处理或者处理有误的类型时，为了实现简单通常都是将该函数直接给出。也就是直接给出一个指针类型的函数模板。</p>\n<pre><code class=\"language-cpp\">指针类型  (* , *) \ntemplate&lt;class T&gt;\nbool Less(T* left, T* right)\n{\n\treturn *left &lt; *right;\n}</code></pre>\n<p>这种实现简单明了，代码可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化时特别给出，因此函数模板不建议特化。</p>\n<p></p>\n<h2 id=\"2.3%C2%A0%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%C2%A0\">2.3 类模板特化 </h2>\n<h3 id=\"2.3.1%20%E5%85%A8%E7%89%B9%E5%8C%96\">2.3.1 全特化</h3>\n<p>所谓全特化就是将模板参数列表中所有的都确定化。我们使用自定Data类来举例说明：</p>\n<pre><code class=\"language-cpp\">template&lt;class T1,class T2&gt;\nclass Data\n{\npublic:\n\tData()\n\t{\n\t\tcout &lt;&lt; \"Data&lt;T1,T2&gt;\" &lt;&lt; endl;\n\t}\n\nprivate:\n\tT1 _d1;\n\tT2 _d2;\n};</code></pre>\n<p>此时，我们如果传入两个参数int，double根据模板他会匹配到T1,T2 但是如果我们想要匹配到int和double时，我们就需要全特化类模板。</p>\n<pre><code class=\"language-cpp\">全特化\ntemplate&lt;&gt;\nclass Data&lt;int, double&gt;\n{\npublic:\n\tData()\n\t{\n\t\tcout &lt;&lt; \"Date&lt;int,double&gt;\"&lt;&lt;endl;\n\t}\n};</code></pre>\n<p>此时如果我们测试输入查看结果：</p>\n<p><img alt=\"\" height=\"213\" src=\"..\\..\\static\\image\\461e3352c60b4ea8b3fb6037c850ac9d.png\" width=\"340\"/></p>\n<h3 id=\"2.3.2%20%E5%81%8F%E7%89%B9%E5%8C%96\">2.3.2 偏特化</h3>\n<p>偏特化：任何针对模板参数进一步进行条件限制设计的特化版本。</p>\n<blockquote>\n<p>偏特化有一下两种表现形式：</p>\n<p>        1. 部分特化 -- 将模板参数类表中的一部分参数特化</p>\n<p>        2. 参数更进一步限制 -- 偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。</p>\n</blockquote>\n<p><span style=\"color:#0d0016;\"><strong>1.部分特化 </strong></span></p>\n<p>假设我要将第二个参数特化为int</p>\n<pre><code class=\"language-cpp\">半特化  第二个参数总是int类型\n1、将模板参数类表中的一部分参数特化。\ntemplate&lt;class T1&gt;\nclass Data&lt;T1,int&gt;\n{\npublic:\n\tData()\n\t{\n\t\tcout &lt;&lt; \"Date&lt;T1,int&gt;\"&lt;&lt;endl;\n\t}\n};</code></pre>\n<p><img alt=\"\" height=\"230\" src=\"..\\..\\static\\image\\d5c4f610c3874ad6a3a60831010aa386.png\" width=\"362\"/></p>\n<p> </p>\n<p><span style=\"color:#0d0016;\"><strong>2.参数更近一步限制</strong></span></p>\n<p>两个参数偏特化为指针类型</p>\n<pre><code class=\"language-cpp\">//偏特化 参数给定了 两个指针类型 具体那种不确定\n//2、偏特化并不仅仅是指特化部分参数，\n//   而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。\ntemplate&lt;class T1,class T2&gt;\nclass Data&lt;T1*, T2*&gt;\n{\npublic:\n\tData()\n\t{\n\t\tcout &lt;&lt; \"Data&lt;T1*,T2*&gt;\" &lt;&lt; endl;\n\t}\n};</code></pre>\n<p><img alt=\"\" height=\"338\" src=\"..\\..\\static\\image\\a5c917890bb7484f87278c52aac4855b.png\" width=\"347\"/></p>\n<p></p>\n<p>两个参数偏特化为引用类型</p>\n<pre><code class=\"language-cpp\">template&lt;class T1, class T2&gt;\nclass Data&lt;T1&amp;, T2&amp;&gt;\n{\npublic:\n\tData()\n\t{\n\t\tcout &lt;&lt; \"Data&lt;T1&amp;,T2&amp;&gt;\" &lt;&lt; endl;\n\t}\n};</code></pre>\n<p><img alt=\"\" height=\"437\" src=\"..\\..\\static\\image\\21909366abb244959f888b7c8b1c25b3.png\" width=\"378\"/></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\"><strong>注：</strong></span><span style=\"color:#fe2c24;\"><strong>优先级 ：全特化 &gt; 半特化 &gt; 默认 </strong></span></p>\n<p></p>\n<h1 id=\"3.%20%E6%A8%A1%E6%9D%BF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91\">3. 模板分离编译</h1>\n<h2 id=\"3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91\">3.1 什么是分离编译</h2>\n<div>\n<span style=\"color:#777777;\">一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来形成单一的可执行文件的过程称为分离编译模式。</span>\n</div>\n<div></div>\n<h2 id=\"3.2%20%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91\"><span style=\"color:#777777;\">3.2 模板的分离编译</span></h2>\n<div>\n<span style=\"color:#777777;\">假如有以下场景，模板的声明与定义分离开，在头文件中进行声明，源文件中完成定义：</span>\n</div>\n<div></div>\n<div>\n<pre><code class=\"language-cpp\">// a.h\ntemplate&lt;class T&gt; \nT Add(const T&amp; left, const T&amp; right);\n// a.cpp\ntemplate&lt;class T&gt; T Add(const T&amp; left, const T&amp; right) {\n\treturn left + right;\n}\n// main.cpp\n\n#include\"a.h\"\n\nint main()\n{\n\tAdd(1, 2);\n\tAdd(1.0, 2.0);\n\n\treturn 0;\n}</code></pre>\n<p>分析：C/C++程序要运行，一般要经历以下步骤：预处理--&gt;编译--&gt;汇编--&gt;链接</p>\n<p>编译:对程序按照语言特性进行词法，语法，语义分析，错误检查无误后生成汇编代码，注意头文件不参与编译 编译器对工程中的多个源文件是分离开单独编译的。</p>\n<p>链接:将多个obj文件合并成一个，并处理没有解决的地址问题。</p>\n<p><img alt=\"\" height=\"472\" src=\"..\\..\\static\\image\\e402d4efec504373a430face9843ab8b.png\" width=\"1200\"/></p>\n<p></p>\n<h2 id=\"3.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\">3.3 解决方法</h2>\n</div>\n<blockquote>\n<div>\n<span style=\"color:#777777;\">1. </span>\n<span style=\"color:#777777;\"><strong>将声明和定义放到一个文件</strong></span>\n<span style=\"color:#777777;\"><strong> \"xxx.hpp\" </strong></span>\n<span style=\"color:#777777;\"><strong>里面或者</strong></span>\n<span style=\"color:#777777;\"><strong>xxx.h</strong></span>\n<span style=\"color:#777777;\"><strong>其实也是可以的</strong></span>\n<span style=\"color:#777777;\">。推荐使用这种。 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">2. </span>\n<span style=\"color:#777777;\"><strong>模板定义的位置显式实例化</strong></span>\n<span style=\"color:#777777;\">。这种方法不实用，不推荐使用。</span>\n</div>\n</blockquote>\n<p></p>\n<h1 id=\"4.%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93\">4.模板总结</h1>\n<p><span style=\"color:#0d0016;\"><strong>优点：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>       </strong> 1.模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库(STL)因此而产生</span></p>\n<p>        2.增强了代码的灵活性，简化编程工作，提高程序的可靠性。</p>\n<p><span style=\"color:#0d0016;\"><strong>缺点：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>     </strong>   1.模板会导致代码膨胀问题，也会导致编译时间变长</span>       </p>\n<p>        2.出现模板编译错误时，错误信息非常凌乱，不易定位错误</p>\n<p></p>\n<p>（本篇完）</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-01 14:10:05", "summary": "本篇内容包括非典型模板参数，类模板的特化，模板的分离编译。模板简单概念及其使用大家可点击此链接：之模板之模板目录数组模板示例和非类型模板参数模板的特化什么是模板的特化函数模板特化类模板特化全特化偏特化"}