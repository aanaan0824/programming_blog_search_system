{"blogid": "124778789", "writerAge": "码龄1年", "writerBlogNum": "21", "writerCollect": "67", "writerComment": "20", "writerFan": "505", "writerGrade": "2级", "writerIntegral": "308", "writerName": "go_with_dream", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124778789.jpg", "writerRankTotal": "69649", "writerRankWeekly": "115775", "writerThumb": "76", "writerVisitNum": "9023", "blog_read_count": "1041", "blog_time": "于 2022-05-15 12:15:55 发布", "blog_title": "C# SignalR 实现数据实时传输", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/acc523b6f04247f4accbe981ff3eef85.gif\"/></p>\n<p> </p>\n<p>上次我们用websocket做了一个后端实时传输数据的例子<a class=\"link-info\" href=\"https://sihan.blog.csdn.net/article/details/124770808?spm=1001.2014.3001.5502\" title=\"websocket 传输实时数据到前端，并用 Echart 动态展示数据\">websocket 传输实时数据到前端，并用 Echart 动态展示数据</a>，这次我打算换成SignalR来做数据传输试试。</p>\n<blockquote>\n<p>SignalR 这个机制让后端可以主动调用前端的方法，在实际开发中解决了很多问题。比如说数据库进行了更新，但是前端并不知道，并不能实时反应出数据库的实时数据。这时候在后端更新数据库的逻辑中加入调用前端获取数据的方法，这时前端变受到后端的驱动进行数据更新，从而只要数据库有变化前端就会实时更新。</p>\n</blockquote>\n<p>首先我们在服务器端的console项目中来建立一个hub，里边可以定义前端的方法供后端调用，也可定义后端的方法供前端调用：</p>\n<pre><code class=\"language-cs\">public class DataHub : Hub\n    {\n        public DataHub()\n        {\n            Program.dataHub = this;\n        }\n\n        public void Push(string data)\n        {\n            Clients.All.Push(data);\n        }\n\n        public void SetCmd(string cmd)\n        {\n            Program.Cmd = cmd;\n        }\n\n\n        public override Task OnConnected()\n        {\n            return base.OnConnected();\n        }\n\n        public override Task OnDisconnected(bool stopCalled)\n        {\n            return base.OnDisconnected(stopCalled);\n        }\n    }</code></pre>\n<blockquote>\n<p>        Push方法为后端调用前端的方法，若后端执行push方法，则让所有与此hub相连接的的前端都执行自己的Push方法。SetCmd是后端的方法，它设定后端的Cmdproperty的值，所以一旦前端调用此方法可以改变后端Cmd的值。</p>\n</blockquote>\n<p>        之后我们要将hub部署到本地，做一些基本的配置：</p>\n<pre><code class=\"language-cs\">using Microsoft.AspNet.SignalR;\nusing Microsoft.Owin.Cors;\nusing Owin;\n\nnamespace signalr\n{\n    public class Startup\n    {\n        public void Configuration(IAppBuilder app)\n        {\n            app.UseCors(CorsOptions.AllowAll);\n            app.MapSignalR(new HubConfiguration() { EnableJSONP = true });\n        }\n    }\n}</code></pre>\n<p>        先解决跨域问题，再之后部署signalR。</p>\n<pre><code class=\"language-cs\">static void Main(string[] args){\n    WebApp.Start&lt;Startup&gt;(\"http://localhost:8000\");\n}</code></pre>\n<p>        那么这样一来signalr的hub就配置好了。我打算后端不停的去推送一些实时的随机数据，让前端以echart图表的方式展现出来。并当前端喊停时停止推送，具体代码如下：</p>\n<pre><code class=\"language-cs\">using Microsoft.Owin.Hosting;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.Serialization.Json;\nusing System.Text;\nusing System.Threading;\n\nnamespace signalr\n{\n    public class Program\n    {\n        public static DataHub dataHub { get; set; }\n        public static string Cmd { get; set; }\n        private static string ConvertObjectToString(Data obj)\n        {\n            DataContractJsonSerializer serializer = new DataContractJsonSerializer(obj.GetType());\n            MemoryStream memoryStream = new MemoryStream();\n            serializer.WriteObject(memoryStream, obj);\n\n            string json = Encoding.Default.GetString(memoryStream.ToArray());\n            return json;\n        }\n\n        static void Main(string[] args)\n        {\n\n            WebApp.Start&lt;Startup&gt;(\"http://localhost:8000\");\n            while(true)\n            {\n                if (Cmd == \"ACD\")\n                {\n                    while (Cmd == \"ACD\")\n                    {\n                        Thread.Sleep(300);\n                        Data a = new Data()\n                        {\n                            x = new List&lt;int&gt;(),\n                            y = new List&lt;int&gt;()\n                        };\n                        Random r = new Random();\n                        for (int i = 1; i &lt; 100; i++)\n                        {\n                            a.x.Add(i);\n                            a.y.Add(r.Next(1, 100));\n                        }\n\n                        dataHub.Push(ConvertObjectToString(a));\n                    }\n                }\n                else if (Cmd == \"STOP\")\n                {\n                    Cmd = string.Empty;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>        至此后端代码就完成了，接下来就是前端，首先前端代码需要引用echart，jquery，signalr以及后端给前端的咱们自定义的hub代码，这样前后端才能都知道互相暴露出的方法：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;\n    &lt;script src=\"./echarts.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"./jquery-1.6.4.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"./jquery.signalR-2.4.3.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"http://localhost:8000/signalr/hubs\"&gt;&lt;/script&gt;\n    &lt;script src=\"./main.js\" defer&gt;&lt;/script&gt;\n    &lt;title&gt;signalR data&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"main-chart\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;\n    &lt;button class=\"btn_close\"&gt;close&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<blockquote>\n<p>        值得注意的时jquery的版本不能低于1.6哦，不然执行不了signalR。我将jquery.signalR-2.4.3.min.js上传了，大家可以来这里免费<a class=\"link-info\" href=\"https://download.csdn.net/download/weixin_63197216/85378852\" title=\"下载\">下载</a></p>\n</blockquote>\n<p>        前端的JS代码也是非常的简单，初始化echart，连接到hub，初始化Push方法，并调用后端setCmd方法改变Cmd来让后端开始push实时数据。点击按钮时将Cmd设置为“STOP” 后端便停止推送：</p>\n<pre><code class=\"language-javascript\">let myChart = echarts.init(document.getElementById('main-chart'));\n\nlet option = {\n    title: {\n      text: 'ECharts real time chart!!!'\n    },\n    tooltip: {},\n    legend: {\n      data: ['y']\n    },\n    xAxis: {\n      data: []\n    },\n    yAxis: {},\n    series: [\n      {\n        name: 'y',\n        type: 'bar',\n        data: []\n      }\n    ]\n  };\n\n\nlet btn = document.getElementsByClassName('btn_close');\n\nlet hub = $.connection.dataHub;\n//连接到dataHub上\n$.connection.hub.url = \"http://localhost:8000/signalr\";\n//设置前端的Push方法\nhub.client.Push = function(data)\n{\n    let jsonData = JSON.parse(data);\n    option.xAxis.data = jsonData.x;\n    option.series[0].data = jsonData.y;\n    myChart.setOption(option);\n}\n//一旦连接到dataHub后就调用后端setCmd方法，从而让后端开始推送数据\n$.connection.hub.start().done(function () {\n  hub.server.setCmd(\"ACD\");\n});\n//停止按钮：设置Cmd为STOP来停止推送\nbtn[0].addEventListener(\"click\",function(){hub.server.setCmd(\"STOP\");});</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 1, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-05-15 12:15:55", "summary": "上次我们用做了一个后端实时传输数据的例子传输实时数据到前端，并用动态展示数据传输实时数据到前端，并用动态展示数据，这次我打算换成来做数据传输试试。这个机制让后端可以主动调用前端的方法，在实际开发中解决"}