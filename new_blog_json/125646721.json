{"blogid": "125646721", "writerAge": "码龄2年", "writerBlogNum": "13", "writerCollect": "37", "writerComment": "7", "writerFan": "2", "writerGrade": "2级", "writerIntegral": "156", "writerName": "Sunnyztg", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125646721.jpg", "writerRankTotal": "86072", "writerRankWeekly": "360978", "writerThumb": "20", "writerVisitNum": "17064", "blog_read_count": "1632", "blog_time": "于 2022-07-12 00:40:48 发布", "blog_title": "第26次ccf认证第二题：寻宝！大冒险！", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" height=\"181\" src=\"..\\..\\static\\image\\0bd33fb4f2e94d299345dc417f66ad00.png\" width=\"1200\"/></p>\n<p>ccfcsp认证的第二题近几次难度有所增加，不再是简单模拟就可以得满分。</p>\n<p>简单模拟会因为超时或者超空间等限制最多只能拿70分。</p>\n<p>另外30分，限制难度也是越来越大。</p>\n<p>比较青睐的考点：差分+前缀和 、 二维前缀和。</p>\n<p>让我们一起看下此题。</p>\n<h2 id=\"题目背景\">题目背景</h2>\n<p>暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……</p>\n<p>某天，小 P 获得了一张神秘的藏宝图。</p>\n<h2 id=\"问题描述\">问题描述</h2>\n<p>西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。<br/> 简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，<br/> 地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 A[0][0] 和 A[L][L]。<br/> 其中 A[i][j]=1 表示坐标 (i,j) 处种有一棵树，A[i][j]=0 则表示坐标 (i,j) 处没有树。<br/> 换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。</p>\n<p>传说，大冒险家顿顿的宝藏就埋藏在某棵树下。<br/> 并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。<br/> 具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。<br/> 理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：<br/> 对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 A[x+i][y+j]=B[i][j]。<br/> 当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。</p>\n<p>实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。<br/> 请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。</p>\n<p>特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]=B[0][0]=1，表示了宝藏埋藏的位置。</p>\n<h2 id=\"输入格式\">输入格式</h2>\n<p>从标准输入读入数据。</p>\n<p>输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。</p>\n<p>由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。</p>\n<p>最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 B[S−i][0]⋯B[S−i][S]。<br/><strong>需要注意</strong>，最先输入的是 B[S][0]⋯B[S][S] 一行，B[0][0]⋯B[0][S] 一行最后输入。</p>\n<h2 id=\"输出格式\">输出格式</h2>\n<p>输出到标准输出。</p>\n<p>输出一个整数，表示绿化图中有多少处坐标可以与藏宝图左下角对应，即可能埋藏着顿顿的宝藏。</p>\n<h2 id=\"样例-1-输入\">样例 1 输入</h2>\n<pre><code>5 100 2\n0 0\n1 1\n2 2\n3 3\n4 4\n0 0 1\n0 1 0\n1 0 0</code></pre>\n<p>Data</p>\n<h2 id=\"样例-1-输出\">样例 1 输出</h2>\n<pre><code>3</code></pre>\n<p>Data</p>\n<h2 id=\"样例-1-解释\">样例 1 解释</h2>\n<p>绿化图上 (0,0)、(1,1) 和 (2,2) 三处均可能埋有宝藏。</p>\n<p></p>\n<p>思路：</p>\n<p>或许可以试试二维前缀和。锁定藏宝图（很小区域）中的1的个数，用二维前缀和在O（1）时间内查询到以该顶点为左下角的藏宝图中的树木个数如果匹配，再一一遍历。</p>\n<p>这个题就是二维前缀和。</p>\n<p>但是我用数组和前缀和写出来此题后，有两个问题：</p>\n<p>1.由于L和L+1等条件限制，数组之间的逻辑非常复杂，甚至遍历的时候出现了s+i-p-1等奇怪的计算方式，是很不好的习惯，这也导致我最后写出来只有50分。</p>\n<p>2.发现L数据量巨大，计算前缀和的时间复杂度和内存很可能会超出限制。最多应该也是70分。</p>\n<p>所以发现这题卡的点应该在内存上和数据存储方式上！</p>\n<p>感觉可以用stl，所以我学习了vector和pair等数据结构，加以用之，用稀疏数组的思想解决此题。发现藏宝图最下边一定是1，更验证确定了这个方案的正确性。但是此题用数组就可以解决。没必要用stl，stl还是留到三四五题里。</p>\n<p>（计算机一秒大概运行2亿次）</p>\n<p>第一次只得了八十分：</p>\n<p><img alt=\"\" height=\"57\" src=\"..\\..\\static\\image\\bf7828915f854c17bbacf70218803ee9.png\" width=\"1200\"/></p>\n<p> 代码如下，问题在于我对于每个地图中为1的点，向右上方遍历的时候，每个点都去遍历稀疏数组中的n个元素，太浪费时间了，实际上可以通过预处理减少时间复杂度，只需要记录一遍藏宝图中树木个数，然后遍历一遍n稀疏数组，如果树木个数对上了，再遍历也不迟。</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n    int n,l,s;\n    cin&gt;&gt;n&gt;&gt;l&gt;&gt;s;\n    int A[n][2];\n    int B[s+1][s+1];\n    for(int i=0;i&lt;n;i++){\n        cin&gt;&gt;A[i][0]&gt;&gt;A[i][1];\n    }\n    for(int i=s;i&gt;=0;i--){\n        for(int j=0;j&lt;=s;j++){\n            cin&gt;&gt;B[i][j];\n        }\n    }\n\n    int ans = 0;\n    for(int i=0;i&lt;n;i++){\n        int p = A[i][0],q = A[i][1];\n        bool flag = true;\n        for(int j=0;j&lt;s+1;j++){\n            for(int m = 0;m&lt;s+1;m++){\n                if(p+j &gt; l || q+m &gt;l){\n                        flag = false;\n                        break;\n                    }\n                if(B[j][m]==0){\n                    for(int k = 0;k&lt;n;k++){\n                    if(A[k][0] == p+j &amp;&amp; A[k][1]==q+m){\n                    flag = false;\n                    break;}\n                    }\n                }\n                else{\n                for(int k = 0;k&lt;n;k++){\n                    if(A[k][0] == p+j &amp;&amp; A[k][1]==q+m)\n                    break;\n                    if(k==n-1){\n                        flag = false;\n                    }\n                }\n            }\n        }\n    }\n    if(flag){\n            ans++;\n          //  cout&lt;&lt;ans&lt;&lt;endl;\n        }\n}\n    cout&lt;&lt;ans;\n}</code></pre>\n<p>根据上述思想改进后的代码：100分！</p>\n<p><img alt=\"\" height=\"181\" src=\"..\\..\\static\\image\\0bd33fb4f2e94d299345dc417f66ad00.png\" width=\"1200\"/></p>\n<p>一定要学会灵活变通啊！多多提升编程能力！仔细优化！</p>\n<p> </p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n    int n,l,s;\n    cin&gt;&gt;n&gt;&gt;l&gt;&gt;s;\n    int A[n][2];\n    int B[s+1][s+1];\n    for(int i=0;i&lt;n;i++){\n        cin&gt;&gt;A[i][0]&gt;&gt;A[i][1];\n    }\n    int num = 0;\n    for(int i=s;i&gt;=0;i--){\n        for(int j=0;j&lt;=s;j++){\n            cin&gt;&gt;B[i][j];\n            if(B[i][j]==1){\n                num++;\n            }\n        }\n    }\n    //cout&lt;&lt;num&lt;&lt;endl;\n    int ans = 0;\n    for(int i=0;i&lt;n;i++){\n        int p = A[i][0],q = A[i][1];\n        bool flag = true;\n        int temp = 0;\n        for(int j=0;j&lt;n;j++){\n            if(A[j][0]-p&gt;=0 &amp;&amp; A[j][0]-p&lt;=s &amp;&amp;A[j][1]-q&gt;=0 &amp;&amp; A[j][1]-q&lt;=s ){\n                temp++;\n            }\n        }\n        if(temp == num){\n        for(int j=0;j&lt;s+1;j++){\n            for(int m = 0;m&lt;s+1;m++){\n                if(p+j &gt; l || q+m &gt;l){\n                        flag = false;\n                        break;\n                    }\n                if(B[j][m]==0){\n                    for(int k = 0;k&lt;n;k++){\n                    if(A[k][0] == p+j &amp;&amp; A[k][1]==q+m){\n                    flag = false;\n                    break;}\n                    }\n                }\n                else{\n                for(int k = 0;k&lt;n;k++){\n                    if(A[k][0] == p+j &amp;&amp; A[k][1]==q+m)\n                    break;\n                    if(k==n-1){\n                        flag = false;\n                    }\n                }\n            }\n        }\n        }\n    if(flag){\n            ans++;\n          //  cout&lt;&lt;ans&lt;&lt;endl;\n        }\n        }\n}\n    cout&lt;&lt;ans;\n}</code></pre>\n<p>切记！CSP就是考STL的！</p>\n<p>要注意理清题意，熟练编程，注意优化时间空间！！</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-12 00:40:48", "summary": "认证的第二题近几次难度有所增加，不再是简单模拟就可以得满分。简单模拟会因为超时或者超空间等限制最多只能拿分。另外分，限制难度也是越来越大。比较青睐的考点：差分前缀和、二维前缀和。让我们一起看下此题。题"}