{"blogid": "125872542", "writerAge": "码龄3年", "writerBlogNum": "45", "writerCollect": "76", "writerComment": "13", "writerFan": "95", "writerGrade": "3级", "writerIntegral": "493", "writerName": "盖玥希圈外男友(섭소우)", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125872542.jpg", "writerRankTotal": "35438", "writerRankWeekly": "279203", "writerThumb": "29", "writerVisitNum": "22137", "blog_read_count": "9417", "blog_time": "于 2022-07-19 15:28:07 发布", "blog_title": "瀑布流布局", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"%E9%9C%80%E6%B1%82-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%9C%80%E6%B1%82\">需求</a></p>\n<p id=\"%E6%80%9D%E8%B7%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C\">实现效果</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%E5%92%8C%E4%BF%AE%E6%AD%A3-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%97%AE%E9%A2%98%E5%92%8C%E4%BF%AE%E6%AD%A3\">问题和修正</a></p>\n<p id=\"%E4%BF%AE%E6%AD%A3%E5%90%8E%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%AE%E6%AD%A3%E5%90%8E%E6%95%88%E6%9E%9C\">修正后效果</a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E9%9C%80%E6%B1%82\">需求</h2>\n<p>所谓瀑布流布局，就是含有若干个等宽的列，每一列分别放置图片、视频等，放置的元素都是等宽的，因此可能是不等高的。新的元素到来时，会插入高度较低的那一列，这样形成参差的、视觉上像瀑布一样的布局。</p>\n<p>这里简化一下，只要两列等宽布局展示图片即可。</p>\n<h2 id=\"%E6%80%9D%E8%B7%AF\">思路</h2>\n<p>两列布局，直接使用flex布局实现即可。不过，这里不能设置align-items为center，如果设置了将会使图片列居中显示，不符合瀑布流的视觉效果。我设置left和right两列，两列的宽度相等，结构和样式基本就写完了。</p>\n<p>然后写JavaScript。其逻辑是，判断当前left和right的高度（我使用clientHeight），如果左边&lt;=右边，则放入左边，否则放入右边。遍历所有的图片，按照这个逻辑放入即可。</p>\n<h2 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</h2>\n<p>html部分</p>\n<pre><code class=\"language-html\">&lt;!-- 瀑布流父容器 --&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;!-- 两列等宽布局 --&gt;\n    &lt;div class=\"col left\"&gt;&lt;/div&gt;\n    &lt;div class=\"col right\"&gt;&lt;/div&gt;\n  &lt;/div&gt;</code></pre>\n<p>css部分</p>\n<pre><code class=\"language-css\">    .container {\n      width: 700px;\n      background-color: aliceblue;\n      margin: auto;\n      /* flex布局 */\n      display: flex;\n      align-items: flex-start;\n    }\n\n    .col {\n      flex-basis: 350px;\n    }\n\n    .col img {\n      /* 固定图片的宽度 */\n      width: 100%;\n    }</code></pre>\n<p>JavaScript部分</p>\n<pre><code class=\"language-javascript\">  // 获取三个元素\n  let container = document.getElementsByClassName('container')[0]\n  let left = document.getElementsByClassName('col')[0]\n  let right = document.getElementsByClassName('col')[1]\n\n  // 插入图片\n  function initImg() {\n    for (let i = 1; i &lt; 27; i++) {\n      let img = new Image();\n      img.src = \"./pictures/\" + i + \".jpg\"\n      if (left.clientHeight &lt;= right.clientHeight) {\n        left.appendChild(img)\n      } else {\n        right.appendChild(img)\n      }\n    }\n  }\n  \n  initImg()</code></pre>\n<p>如代码所示，获取了父元素和左右两列，然后遍历每一张图片，依次判断插入即可。看上去很完美，但是真的如此吗？</p>\n<h2 id=\"%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C\">实现效果</h2>\n<p><img alt=\"\" height=\"486\" src=\"..\\..\\static\\image\\3aa65d17027b48608c5bfcc912edbb56.png\" width=\"487\"/></p>\n<p> 看上去貌似很完美，也有瀑布的样子。但当拉到页面底部发现：</p>\n<p><img alt=\"\" height=\"463\" src=\"..\\..\\static\\image\\0c3dce01b37d462681f8ef2e2fb10575.png\" width=\"465\"/></p>\n<p>左边的一大块都是空的，全部放在了右边。这显然不对，因为按照逻辑，左边更短，应该加在左边才对。</p>\n<h2 id=\"%E9%97%AE%E9%A2%98%E5%92%8C%E4%BF%AE%E6%AD%A3\">问题和修正</h2>\n<p>问题就在于，img的加载是个异步的过程。再看刚才的for循环：</p>\n<pre><code class=\"language-javascript\">  // 插入图片\n  function initImg() {\n    for (let i = 1; i &lt; 27; i++) {\n      let img = new Image();\n      img.src = \"./pictures/\" + i + \".jpg\"\n      if (left.clientHeight &lt;= right.clientHeight) {\n        left.appendChild(img)\n      } else {\n        right.appendChild(img)\n      }\n    }\n  }</code></pre>\n<p>new了Image对象后，指定了其src，然后立刻判断左右两边的高度。这时，img还没有加载完毕。然而，for循环不会等待它加载完毕。下一张图片产生后，立刻也会判断，但此时上一张图片还没有放到页面上，所以左右的高度很可能就是错误的，从而产生了错误的判断。这就出现了上图中，右列出现了很多很多图片，而左列空白的样子。</p>\n<p>解决办法就是，把这个循环写成异步的，只有上一张图片加载完毕后，才去判断下一张图片。</p>\n<p>很容易想到，使用Promise完成异步判断。但是对于循环中的Promise，很难清楚地通过then的变化来推进。于是，我决定采用async和await。</p>\n<p>这就需要再封装一个方法，这个方法返回Promise，在Promise中加载某一张图片。然后再遍历所有图片，使用async/await，依次调用这个方法，就能得到结果了。</p>\n<p>而在Promise中，我们在什么时候调用resolve呢？这就需要监听img的onload事件，设置onload事件的回调函数，在回调函数中调用resolve即可。</p>\n<p>经过分析，再次完善代码：</p>\n<pre><code class=\"language-javascript\">  // 加载第index张图片\n  function loadIndexImg(index) {\n    return new Promise((resolve, reject) =&gt; {\n      // 当前加载的图片\n      let img = new Image();\n      img.src = './pictures/' + index + '.jpg'\n      img.onload = () =&gt; {\n        if (left.clientHeight &lt;= right.clientHeight) {\n          left.appendChild(img)\n        } else {\n          right.appendChild(img)\n        }\n        resolve();\n      }\n    })\n  }\n\n  // 插入图片\n  async function initImg() {\n    // 要在加载完并插入图片后才去判断下一张，因此采用async/await\n    for (let i = 1; i &lt;= 26; i++) {\n      await loadIndexImg(i)\n    }\n  }\n\n  initImg()</code></pre>\n<p>可以看到，在initImg中，依次调用loadIndexImg，并且是异步调用。在图片加载完成后再去加载下一张图片，效果应该就可以了。</p>\n<h2 id=\"%E4%BF%AE%E6%AD%A3%E5%90%8E%E6%95%88%E6%9E%9C\">修正后效果</h2>\n<p><img alt=\"\" height=\"646\" src=\"..\\..\\static\\image\\8af0003f52da43c79bb69e14a8c570ff.png\" width=\"594\"/></p>\n<p>效果很好！！！</p>\n<h2 id=\"%E6%80%BB%E7%BB%93\">总结</h2>\n<p>本文实现了简单的两列瀑布流布局，其中需要用到Promise等异步操作。</p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-07-19 15:28:07", "summary": "目录需求思路代码实现实现效果问题和修正修正后效果总结需求所谓瀑布流布局，就是含有若干个等宽的列，每一列分别放置图片、视频等，放置的元素都是等宽的，因此可能是不等高的。新的元素到来时，会插入高度较低的那"}