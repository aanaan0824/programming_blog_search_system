{"blogid": "125641875", "writerAge": "码龄1年", "writerBlogNum": "19", "writerCollect": "2057", "writerComment": "1005", "writerFan": "2713", "writerGrade": "5级", "writerIntegral": "3587", "writerName": "小张﹉", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125641875.jpg", "writerRankTotal": "7465", "writerRankWeekly": "83142", "writerThumb": "1617", "writerVisitNum": "37865", "blog_read_count": "2783", "blog_time": "已于 2022-07-17 18:16:09 修改", "blog_title": "二叉树相关操作---纯代码实现详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\" style=\"text-align:center;\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E5%89%8D%E8%A8%80%C2%A0\">前言 (很重要)</a></p>\n<p id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">二叉树的概念</a></p>\n<p id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD\">二叉树的相关术语</a></p>\n<p id=\"%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E8%8F%9C%E5%8D%95-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E8%8F%9C%E5%8D%95\">相关操作菜单</a></p>\n<p id=\"%C2%A0%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0\">  二叉树的构造</a></p>\n<p id=\"%C2%A0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91\"> 创建二叉树</a></p>\n<p id=\"%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0%C2%A0\">先序遍历二叉树  </a></p>\n<p id=\"%C2%A0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"> 中序遍历二叉树</a></p>\n<p id=\"%C2%A0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"> 后序遍历二叉树</a></p>\n<p id=\"%C2%A0%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"> 层次遍历二叉树</a></p>\n<p id=\"%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6\"> 二叉树的深度</a></p>\n<p id=\"%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0\"> 二叉树的叶子结点数</a></p>\n<p id=\"%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0\"> 二叉树的结点数</a></p>\n<p id=\"%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81\">整体代码</a></p>\n<p id=\"%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA\">结果展示</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80%C2%A0\">前言 (很重要)</h1>\n<blockquote>\n<p>        <strong>大家好，今天给大家带来的是二叉树的相关操作，希望能够给大家带来帮助。</strong></p>\n<p><strong>        另外有很多小伙伴们在学习算法的时候，只去学习一些关于算法理论的知识，并不知道自己的代码实战能力如何</strong>，<strong>也不清楚到底对该算法的了解有多深，所以在这里小张给大家推荐一个很棒的平台，在这里有很多的面试和算法题，也有很多的面试和求职的机会，大家可以点击下方链接进入牛客网刷算法真题，提高自己代码实战能力，早日拿到满意的offer！<a class=\"link-info\" href=\"https://www.nowcoder.com/exam/oj/ta?tpId=13&amp;fromPut=pc_csdncpt_xiaozhang_jzsf\" title=\"点击这里进入牛客网刷算法和面试真题提高代码实战能力\">点击这里进入牛客网刷算法和面试真题提高代码实战能力</a></strong></p>\n</blockquote>\n<h1 id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">二叉树的概念</h1>\n<blockquote>\n<p>        <strong>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分 。</strong></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD\">二叉树的相关术语</h1>\n<blockquote>\n<p><strong>①节点：包含一个数据元素及若干指向子树分支的信息 。</strong></p>\n<p><strong>②节点的度：一个节点拥有子树的数目称为节点的度 。</strong></p>\n<p><strong>③叶子节点：也称为终端节点，没有子树的节点或者度为零的节点 。</strong></p>\n<p><strong>④分支节点：也称为非终端节点，度不为零的节点称为非终端节点 。</strong></p>\n<p><strong>⑤树的度：树中所有节点的度的最大值 。</strong></p>\n<p><strong>⑥节点的层次：从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层 。</strong></p>\n<p><strong>⑦树的深度：也称为树的高度，树中所有节点的层次最大值称为树的深度  <a name=\"ref_5\"></a>。</strong></p>\n</blockquote>\n<h1 id=\"%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E8%8F%9C%E5%8D%95\">相关操作菜单</h1>\n<pre><code class=\"language-cpp\">//菜单\nvoid menu()\n{\n\tcout &lt;&lt; \"\\t\\t\\t******************************************************************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  1.输入-1  退出程序           *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  2.输入1   初始化二叉树       *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  3.输入2   对二叉树先序遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  4.输入3   对二叉树中序遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  5.输入4   对二叉树后序遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  6.输入5   对二叉树层次遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  7.输入6   二叉树深度         *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  8.输入7   二叉树叶子结点数   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  9.输入8   二叉树的结点数     *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t******************************************************************\" &lt;&lt; endl;\n}</code></pre>\n<h1 id=\"%C2%A0%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0\">  二叉树的构造</h1>\n<pre><code class=\"language-cpp\">//构造二叉树\ntypedef struct Binode\n{\n\t//数据域\n\tchar data;\n\t//定义左孩子和右孩子\n\tstruct Binode*lchid, *rchid;\n}Binode, *StrBinode;</code></pre>\n<h1 id=\"%C2%A0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91\"> 创建二叉树</h1>\n<pre><code class=\"language-cpp\">//先序遍历创建二叉树\nvoid creatBinode(StrBinode&amp;T)\n{\n\tcin &gt;&gt; ch;\n\tif (ch == '#')\n\t{\n\t\t//如果输入是#的话就说明根结点就是叶子结点\n\t\t//就没必要再去进行开辟一个二叉树空间\n\t\tT = NULL;\n\t}\n\telse\n\t{\n\t\tT = new Binode;\n\t\tT-&gt;data = ch;\n\t\tcreatBinode(T-&gt;lchid);\n\t\tcreatBinode(T-&gt;rchid);\n\t}\n}</code></pre>\n<h1 id=\"%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0%C2%A0\">先序遍历二叉树  </h1>\n<pre><code class=\"language-cpp\">//先序遍历二叉树\nvoid visitBinode(StrBinode&amp;T)\n{\n\tif (T!=NULL)\n\t{\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t\tvisitBinode(T-&gt;lchid);\n\t\tvisitBinode(T-&gt;rchid);\n\t}\n\tif(T==NULL)\n\t{\n\t\tcout &lt;&lt; \"#\" &lt;&lt; \" \";\n\t}\n}\n</code></pre>\n<h1 id=\"%C2%A0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"> 中序遍历二叉树</h1>\n<pre><code class=\"language-cpp\">//中序遍历二叉树\nvoid MidvisitBinode(StrBinode&amp;T)\n{\n\tif (T != NULL)\n\t{\n\t\tvisitBinode(T-&gt;lchid);\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t\tvisitBinode(T-&gt;rchid);\n\t}\n\tif (T == NULL)\n\t{\n\t\tcout &lt;&lt; \"#\" &lt;&lt; \" \";\n\t}\n}</code></pre>\n<h1 id=\"%C2%A0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"> 后序遍历二叉树</h1>\n<pre><code class=\"language-cpp\">//后序遍历二叉树\nvoid BackvisitBinode(StrBinode&amp;T)\n{\n\tif (T != NULL)\n\t{\n\t\tvisitBinode(T-&gt;lchid);\n\t\tvisitBinode(T-&gt;rchid);\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t}\n\tif (T == NULL)\n\t{\n\t\tcout &lt;&lt; \"#\" &lt;&lt; \" \";\n\t}\n}\n</code></pre>\n<h1 id=\"%C2%A0%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"> 层次遍历二叉树</h1>\n<pre><code class=\"language-cpp\">//二叉树的层次遍历\nvoid Levelorder(StrBinode&amp;HT)\n{\n\tStrBinode T;\n\tT = new Binode;\n\t//创建一个队列qu\n\tqueue&lt;StrBinode&gt; qu;\n\t//将根结点的指针压入队列\n\tqu.push(HT);\n\t//当队列不为空的时候就继续进行循环\n\twhile (!qu.empty())\n\t{\n\t\t//让T里面存放队列中第一个元素的值\n\t\tT = qu.front();\n\t\t//C++自带的队列出队的话是删除值不返回值\n\t\tqu.pop();\n\t\t//访问出队元素的值\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t\t//当该节点左孩子不为空的时候就让左孩子入队\n\t\tif (T-&gt;lchid != NULL)\n\t\t{\n\t\t\tqu.push(T-&gt;lchid);\n\t\t}\n\t\t//当该节点右孩子不为空的时候就让左孩子入队\n\t\tif (T-&gt;rchid != NULL)\n\t\t{\n\t\t\tqu.push(T-&gt;rchid);\n\t\t}\n\t}\n\t\n}\n</code></pre>\n<h1 id=\"%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6\"> 二叉树的深度</h1>\n<pre><code class=\"language-cpp\">//二叉树的深度\nint deep(StrBinode&amp;T)\n{\n\tif (T == NULL)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint m = deep(T-&gt;lchid);\n\t\tint n = deep(T-&gt;rchid);\n\t\tif (m &gt; n)\n\t\t{\n\t\t\treturn (m + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (n + 1);\n\t\t}\n\t}\n}</code></pre>\n<h1 id=\"%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0\"> 二叉树的叶子结点数</h1>\n<pre><code class=\"language-cpp\">//求二叉树的叶子结点\nint leaf(StrBinode&amp;T)\n{\n\t//如果是空树\n\tif (T == NULL)\n\t{\n\t\t//返回0\n\t\treturn 0;\n\t}\n\t//如果是叶子结点\n\tif (T-&gt;lchid == NULL &amp;&amp; T-&gt;rchid == NULL)\n\t{\n\t\t//返回1\n\t\treturn 1;\n\t}\n\treturn leaf(T-&gt;lchid) + leaf(T-&gt;rchid);\n}</code></pre>\n<h1 id=\"%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0\"> 二叉树的结点数</h1>\n<pre><code class=\"language-cpp\">//求二叉树的结点数\nint Nodecount(StrBinode&amp;T)\n{\n\t//如果是根结点没有数据\n\tif (T == NULL)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn Nodecount(T-&gt;lchid) + Nodecount(T-&gt;rchid) + 1;\n\t}\n}</code></pre>\n<h1 id=\"%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81\">整体代码</h1>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;queue&gt;\nusing namespace std;\nchar ch = 0;\n\n//构造二叉树\ntypedef struct Binode\n{\n\t//数据域\n\tchar data;\n\t//定义左孩子和右孩子\n\tstruct Binode*lchid, *rchid;\n}Binode, *StrBinode;\n\n//先序遍历创建二叉树\nvoid creatBinode(StrBinode&amp;T)\n{\n\tcin &gt;&gt; ch;\n\tif (ch == '#')\n\t{\n\t\t//如果输入是#的话就说明根结点就是叶子结点\n\t\t//就没必要再去进行开辟一个二叉树空间\n\t\tT = NULL;\n\t}\n\telse\n\t{\n\t\tT = new Binode;\n\t\tT-&gt;data = ch;\n\t\tcreatBinode(T-&gt;lchid);\n\t\tcreatBinode(T-&gt;rchid);\n\t}\n}\n\n//先序遍历二叉树\nvoid visitBinode(StrBinode&amp;T)\n{\n\tif (T!=NULL)\n\t{\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t\tvisitBinode(T-&gt;lchid);\n\t\tvisitBinode(T-&gt;rchid);\n\t}\n\tif(T==NULL)\n\t{\n\t\tcout &lt;&lt; \"#\" &lt;&lt; \" \";\n\t}\n}\n\n//中序遍历二叉树\nvoid MidvisitBinode(StrBinode&amp;T)\n{\n\tif (T != NULL)\n\t{\n\t\tvisitBinode(T-&gt;lchid);\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t\tvisitBinode(T-&gt;rchid);\n\t}\n\tif (T == NULL)\n\t{\n\t\tcout &lt;&lt; \"#\" &lt;&lt; \" \";\n\t}\n}\n\n//后序遍历二叉树\nvoid BackvisitBinode(StrBinode&amp;T)\n{\n\tif (T != NULL)\n\t{\n\t\tvisitBinode(T-&gt;lchid);\n\t\tvisitBinode(T-&gt;rchid);\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t}\n\tif (T == NULL)\n\t{\n\t\tcout &lt;&lt; \"#\" &lt;&lt; \" \";\n\t}\n}\n\n//二叉树的层次遍历\nvoid Levelorder(StrBinode&amp;HT)\n{\n\tStrBinode T;\n\tT = new Binode;\n\t//创建一个队列qu\n\tqueue&lt;StrBinode&gt; qu;\n\t//将根结点的指针压入队列\n\tqu.push(HT);\n\t//当队列不为空的时候就继续进行循环\n\twhile (!qu.empty())\n\t{\n\t\t//让T里面存放队列中第一个元素的值\n\t\tT = qu.front();\n\t\t//C++自带的队列出队的话是删除值不返回值\n\t\tqu.pop();\n\t\t//访问出队元素的值\n\t\tcout &lt;&lt; T-&gt;data &lt;&lt; \" \";\n\t\t//当该节点左孩子不为空的时候就让左孩子入队\n\t\tif (T-&gt;lchid != NULL)\n\t\t{\n\t\t\tqu.push(T-&gt;lchid);\n\t\t}\n\t\t//当该节点右孩子不为空的时候就让左孩子入队\n\t\tif (T-&gt;rchid != NULL)\n\t\t{\n\t\t\tqu.push(T-&gt;rchid);\n\t\t}\n\t}\n\t\n}\n\n//二叉树的深度\nint deep(StrBinode&amp;T)\n{\n\tif (T == NULL)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint m = deep(T-&gt;lchid);\n\t\tint n = deep(T-&gt;rchid);\n\t\tif (m &gt; n)\n\t\t{\n\t\t\treturn (m + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (n + 1);\n\t\t}\n\t}\n}\n\n//求二叉树的叶子结点\nint leaf(StrBinode&amp;T)\n{\n\t//如果是空树\n\tif (T == NULL)\n\t{\n\t\t//返回0\n\t\treturn 0;\n\t}\n\t//如果是叶子结点\n\tif (T-&gt;lchid == NULL &amp;&amp; T-&gt;rchid == NULL)\n\t{\n\t\t//返回1\n\t\treturn 1;\n\t}\n\treturn leaf(T-&gt;lchid) + leaf(T-&gt;rchid);\n}\n\n//求二叉树的结点数\nint Nodecount(StrBinode&amp;T)\n{\n\t//如果是根结点没有数据\n\tif (T == NULL)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn Nodecount(T-&gt;lchid) + Nodecount(T-&gt;rchid) + 1;\n\t}\n}\n\n//菜单\nvoid menu()\n{\n\tcout &lt;&lt; \"\\t\\t\\t******************************************************************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  1.输入-1  退出程序           *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  2.输入1   初始化二叉树       *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  3.输入2   对二叉树先序遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  4.输入3   对二叉树中序遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  5.输入4   对二叉树后序遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  6.输入5   对二叉树层次遍历   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  7.输入6   二叉树深度         *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  8.输入7   二叉树叶子结点数   *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t****************  9.输入8   二叉树的结点数     *******************\" &lt;&lt; endl;\n\tcout &lt;&lt; \"\\t\\t\\t******************************************************************\" &lt;&lt; endl;\n}\n\nint main()\n{\n\tint n = 0;\n\tStrBinode T;\n\tmenu();\n\twhile (cin &gt;&gt; n)\n\t{\n\t\tif (n &lt; 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tswitch (n)\n\t\t{\n\t\tcase 1:\n\t\t\t//初始化二叉树\n\t\t\tcout &lt;&lt; \"请输入值对二叉树进行初始化\" &lt;&lt; endl;\n\t\t\tcreatBinode(T);\n\t\t\tcout &lt;&lt; \"初始化完成\" &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t//先序遍历\n\t\t\tcout &lt;&lt; \"先序遍历的结果为\" &lt;&lt; endl;\n\t\t\tvisitBinode(T);\n\t\t\tcout &lt;&lt; \"先序遍历结束\" &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t//中序遍历\n\t\t\tcout &lt;&lt; \"中序遍历的结果为\" &lt;&lt; endl;\n\t\t\tMidvisitBinode(T);\n\t\t\tcout &lt;&lt; \"中序遍历结束\" &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t//后序遍历\n\t\t\tcout &lt;&lt; \"后序遍历的结果为\" &lt;&lt; endl;\n\t\t\tBackvisitBinode(T);\n\t\t\tcout &lt;&lt; \"后序遍历结束\" &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t//层次遍历\n\t\t\tcout &lt;&lt; \"层次遍历的结果为\" &lt;&lt; endl;\n\t\t\tLevelorder(T);\n\t\t\tcout &lt;&lt; \"层次遍历结束\" &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tcout &lt;&lt; \"二叉树的深度为：\";\n\t\t\tcout &lt;&lt; deep(T) &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcout &lt;&lt; \"二叉树的叶子结点数为：\";\n\t\t\tcout &lt;&lt; leaf(T) &lt;&lt; endl;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tcout &lt;&lt; \"二叉树的结点数为；\";\n\t\t\tcout &lt;&lt; Nodecount(T) &lt;&lt; endl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout &lt;&lt; \"您的输入有误，请重新输入\" &lt;&lt; endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA\">结果展示</h1>\n<h1 id=\"%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"612\" src=\"..\\..\\static\\image\\ae88ff9eefa444c59bc6867291756b8e.png\" width=\"1200\"/><img alt=\"\" height=\"452\" src=\"..\\..\\static\\image\\8a0dc96979a94e2a9fabaa2923e8b554.png\" width=\"1200\"/></h1>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</h1>\n<blockquote>\n<p>        到这里今天的内容就已经全部结束了，这里的代码是运用C++语言实现的，其他语言的话也大同小异，<strong>只要相关的思想掌握了，就能写出来相应的代码</strong>，<strong>最后小张在这里感谢大家的支持 ！</strong></p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-17 18:16:09", "summary": "目录前言很重要二叉树的概念二叉树的相关术语相关操作菜单二叉树的构造创建二叉树先序遍历二叉树中序遍历二叉树后序遍历二叉树层次遍历二叉树二叉树的深度二叉树的叶子结点数二叉树的结点数整体代码结果展示结束语前"}