{"blogid": "125345906", "writerAge": "码龄1年", "writerBlogNum": "67", "writerCollect": "230", "writerComment": "38", "writerFan": "82", "writerGrade": "4级", "writerIntegral": "917", "writerName": "int 我", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125345906.jpg", "writerRankTotal": "21515", "writerRankWeekly": "11953", "writerThumb": "98", "writerVisitNum": "54050", "blog_read_count": "8304", "blog_time": "已于 2022-09-04 16:22:52 修改", "blog_title": "第十三届蓝桥杯c++b组2022年国赛决赛题解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>写的不是很好，8000+浏览量后开的粉丝可见，希望涨一点点粉。</p>\n<p>觉得还阔以的，就不要取关了Fight!!(ｏ^-^)~''☆ミ☆ミ</p>\n<p></p>\n<p><strong>题目pdf下载</strong>：<a class=\"link-info\" href=\"http://124.223.62.164/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B%E8%BD%AF%E4%BB%B6%E8%B5%9B%E5%86%B3%E8%B5%9B_CB.pdf\" title=\"十三届蓝桥杯c++b组2022国赛题目pdf下载\">十三届蓝桥杯c++b组2022国赛题目pdf下载</a></p>\n<p>G题没有写，J题是暴力的，其他好像都写出来，但是估计还是有错的。</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E6%AD%A3%E6%96%87%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%AD%A3%E6%96%87%EF%BC%9A\">正文：</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20A%3A%202022-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20A%3A%202022\">试题 A: 2022</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20B%3A%20%E9%92%9F%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20B%3A%20%E9%92%9F%E8%A1%A8\">试题 B: 钟表</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20C%3A%20%E5%8D%A1%E7%89%8C-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20C%3A%20%E5%8D%A1%E7%89%8C\">试题 C: 卡牌</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20D%3A%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20D%3A%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97\">试题 D: 最大数字</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20E%3A%20%E5%87%BA%E5%B7%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20E%3A%20%E5%87%BA%E5%B7%AE\">试题 E: 出差</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20F%3A%20%E8%B4%B9%E7%94%A8%E6%8A%A5%E9%94%80-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20F%3A%20%E8%B4%B9%E7%94%A8%E6%8A%A5%E9%94%80\">试题 F: 费用报销</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20G%3A%20%E6%95%85%E9%9A%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20G%3A%20%E6%95%85%E9%9A%9C\">试题 G: 故障</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20H%3A%20%E6%9C%BA%E6%88%BF-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20H%3A%20%E6%9C%BA%E6%88%BF\">试题 H: 机房</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20I%3A%20%E9%BD%BF%E8%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20I%3A%20%E9%BD%BF%E8%BD%AE\">试题 I: 齿轮</a></p>\n<p id=\"%E8%AF%95%E9%A2%98%20J%3A%20%E6%90%AC%E7%A0%96-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%95%E9%A2%98%20J%3A%20%E6%90%AC%E7%A0%96\">试题 J: 搬砖</a></p>\n<p id=\"%E7%BB%93%E5%B0%BE%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E5%B0%BE%EF%BC%9A\">结尾：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E6%AD%A3%E6%96%87%EF%BC%9A\">正文：</h1>\n<h2 id=\"%E8%AF%95%E9%A2%98%20A%3A%202022\" style=\"text-align:center;\">试题 A: 2022</h2>\n<p><img alt=\"\" height=\"742\" src=\"..\\..\\static\\image\\539aef8ddc064c08a24865ed2b7e65d3.png\" width=\"841\"/></p>\n<p><strong>题意：</strong> 2022分为不同十个不同的正整数的情况数。</p>\n<p><strong>思路：</strong><strong>动态规划,我的答案是：379187662194355221</strong>。</p>\n<p>        以为挺简单的，但是dfs写完连100都跑不出来，这题难度不简单，估计卡了不少人时间</p>\n<p>后面暴力出了答案，从55开始有答案（因为最小的十个不同的正整数是：1,2,3,4...10，和是55），根据前10个数很像<strong>哈代-拉马努金拆分数列</strong>，然后求出来和后面的不一样，而且会炸long long，所以这个数列应该是错的。</p>\n<p><img alt=\"\" height=\"129\" src=\"..\\..\\static\\image\\8dc63af453a44b2086933860bacf715e.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"142\" src=\"..\\..\\static\\image\\936f53b0804f400ea7bc9d1d1a335791.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"142\" src=\"..\\..\\static\\image\\f9980497d4d24eaaa642158806f7cc87.png\" width=\"1200\"/></p>\n<p><strong>动态规划思路：</strong></p>\n<p>       解释在下面动态规划代码的注释，大致就是dp[2022][10]=dp[1][9]+dp[2][9]+dp[3][9]....+dp[2021][9]的动态规划，用倒叙去实现每个整数只用一次（类似01背包）。</p>\n<p><strong>暴力代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a=55;\nint ans=0;\nvoid dfs(int d,int sum,int pre){        //d是选的数量，sum是选的和，pre是上次选的点\n    if(d==10){\n        if(sum==a)\n        ans++;\n        return;\n    }\n    for(int i=pre+1;i&lt;=a;i++){\n        if(i+sum&lt;=a){\n            dfs(d+1,sum+i,i);\n        }\n    }\n}\nint main()\n{\n    dfs(0,0,0);\n    cout&lt;&lt;ans&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>动态规划代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nlong long i,j,k,dp[50000][20];\n//dp[i][j]表示选j个数总和为i的方案数\nint main()\n{\n    for(i=2022;i&gt;=1;i--)\n    {\n        //这里i的顺序不影响结果\n        for(j=2022;j&gt;=1;j--)\n        {\n            //为了dp不相互影响这里从大到小dp\n            //如果从小到大的话需要再开数组存结果\n            for(k=1;k&lt;=9;k++)\n            {\n                dp[j+i][k+1]+=dp[j][k];\n                //对于k个数总和为j的方案dp[j][j];\n                //可以选i使得k+1个数总和为j+i\n            }\n        }\n        dp[i][1]=1;//表示选1个数总和为i的方法加1\n    }\n    for(i=1;i&lt;=100;i++)\n    {\n        cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;dp[i][10]&lt;&lt;endl;\n    }\n    cout&lt;&lt;dp[2022][10]&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20B%3A%20%E9%92%9F%E8%A1%A8\" style=\"text-align:center;\">试题 B: 钟表</h2>\n<p><img alt=\"\" height=\"803\" src=\"..\\..\\static\\image\\7ecbb50f2da0490b82630d705a790e5c.png\" width=\"803\"/></p>\n<p></p>\n<p><strong>题意：</strong>一个钟表的时针、分针的角度差==分针、秒针的角度差，求此时的时分秒。</p>\n<p><strong>思路：暴力，我的答案是：</strong>4 48 0</p>\n<p>        三个for起手不难，主要就是计算三个针的角度，</p>\n<p>秒的角度就是：m/60</p>\n<p>分的角度就是：f/60+(m/60)/*60，因为秒贡献的度数最多是1/60，贡献了m/60*(1/60)</p>\n<p>时的角度就是：s/12+(f+m*60)/(60*12);，因为分钟贡献的度数最多是1/12，如果有res分钟，那么a=s/12+res/12</p>\n<p>注意优弧劣弧的概念，小数的角度是&lt;=0.5的。</p>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define dou double\n#define EXP 1e-6\n#define M 100010\nint main()\n{\n    for(dou s=0;s&lt;=6;s++)\n        for(dou f=0;f&lt;60;f++)\n            for(dou m=0;m&lt;60;m++){\n                dou a=s/12+(f+m*60)/(60*12);    //时针在表上角度\n                dou b=f/60+m/(60*60);       //分针在表上角度\n                dou c=m/60;             //秒针在表上角度\n                dou x=fabs(a-b)&gt;0.5?1-fabs(a-b):fabs(a-b);      //x是时针和分针夹角\n                dou y=fabs(b-c)&gt;0.5?1-fabs(b-c):fabs(b-c);      //x是分针和秒针夹角\n                if(fabs(x-2*y)&lt;EXP){                //如果A==2*B\n                    cout&lt;&lt;s&lt;&lt;\" \"&lt;&lt;f&lt;&lt;\" \"&lt;&lt;m&lt;&lt;endl;\n                }\n            }\n    return 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20C%3A%20%E5%8D%A1%E7%89%8C\" style=\"text-align:center;\">试题 C: 卡牌</h2>\n<p><img alt=\"\" height=\"1086\" src=\"..\\..\\static\\image\\811fa8af280340e0974ab51247633326.png\" width=\"801\"/></p>\n<p> <img alt=\"\" height=\"372\" src=\"..\\..\\static\\image\\00e62214a7494e249c17cf49bc69b89f.png\" width=\"784\"/></p>\n<p><strong> 题意：</strong>a[i]数组是已有的 i 类手牌的数量，每个类（1-n类）的出1张可以组成一套，还有m张空白的，可以随便写成任意i类。b数组是该类最多被空白牌写成几张，求组成的最多套牌。</p>\n<p><strong>修改：这题比赛的时候被改成a,b&lt;n*2了，不是原来的n*n了</strong></p>\n<p><strong>思路：二分</strong></p>\n<p><strong>        </strong>容易知道是把空白牌用到少的类上，这题思路就是直接二分答案了</p>\n<p>如果当前类牌不够mid张，当然是将空白的编变成该类牌，一是看是否超过了b数组的限制，二是看是否超过了最大空白牌数量。</p>\n<p>直到最后也是没有被返回NO，那么返回YES</p>\n<p><strong>check函数：</strong></p>\n<pre><code class=\"language-cpp\">int check(int mid){        //看看mid套行不行\n    LL sum=0;\n    for(int i=1;i&lt;=n;i++){\n        if(a[i]&lt;mid){        //i类原来数量就超过mid张就不用考虑了\n            if(mid-a[i]&gt;b[i]) return 0;        //如果需要的比限制多返回NO\n            sum+=mid-a[i];\n            if(sum&gt;m) return 0;        //如果使用空白牌多与m，返回NO\n        }\n    }\n    return 1;\n}</code></pre>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define LL long long\n#define M 1000005\nLL n,m;\nLL a[M],b[M];\nint check(int mid){\n    LL sum=0;\n    for(int i=1;i&lt;=n;i++){\n        if(a[i]&lt;mid){\n            if(mid-a[i]&gt;b[i]) return 0;\n            sum+=mid-a[i];\n            if(sum&gt;m) return 0;\n        }\n    }\n    return 1;\n}\nint main()\n{\n    scanf(\"%lld%lld\",&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]);\n    for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;b[i]);\n    LL l=0,r=n*2,ans=0;\n    while(l&lt;=r){\n        LL mid=(l+r)/2;\n        if(check(mid)){\n            l=mid+1;\n            ans=mid;\n        }else{\n            r=mid-1;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20D%3A%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97\" style=\"text-align:center;\">试题 D: 最大数字</h2>\n<h2 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\" style=\"text-align:center;\"><img alt=\"\" height=\"1099\" src=\"..\\..\\static\\image\\7366769aa5644ac8a976d41fdcff2abf.png\" width=\"788\"/></h2>\n<p><img alt=\"\" height=\"77\" src=\"..\\..\\static\\image\\428750397b8a4d5fab6ee1e4a5f846e7.png\" width=\"764\"/></p>\n<p><strong> 题意：</strong>给一个小于1e18的数字，不超过a次可以给一位+1，9再+就变成0，</p>\n<p>不超过b次可以给一位-1，0再-变成9。</p>\n<p> <strong>思路：思维+暴力深搜（dfs）</strong></p>\n<p>        使用肯定是从前面开始的，因为是不超过多少次使用，前面就是能省则省，但是但凡有用，必须使用，暴力出答案即可。</p>\n<p>对于每种情况只能是暴力的搜答案，时间复杂度最坏应该是2^18了差不多。</p>\n<p>然后一直纠结用字符串还是整数来表示，整数肯定更方便计算和简洁，字符串便于修改，后面用数量级还是实现了整数的修改。</p>\n<p><strong>dfs代码：</strong></p>\n<pre><code class=\"language-cpp\">void dfs(LL a,LL ans,LL b,LL c){    //a表示当前的N，ans是10的某次方,表示数量级,b和c是剩余数量\n    if(ans==0){\n        maxx=max(maxx,a);        //更新答案\n        return;\n    }\n    int d=a/ans%10;\n    if(b&gt;9-d){                        //能变成9就变9,\n        int r=b-(9-d);\n        dfs(a+(9-d)*ans,ans/10,r,c);\n    }else{                        //不能变成9就全用\n        dfs(a+b*ans,ans/10,0,c);\n    }\n    if(c!=0){\n        if(c&gt;=d+1){                //能变成9就用，不能变就省着\n            int r=c-(d+1);\n            dfs(a-d*ans+9*ans,ans/10,b,r);\n        }\n    }\n}</code></pre>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define fo(a,b) for(int i=a;i&lt;=b;i++)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define M 100010\nLL a,b,c;\nLL maxx=0;\nvoid dfs(LL a,LL ans,LL b,LL c){\n    if(ans==0){\n        maxx=max(maxx,a);\n        return;\n    }\n    int d=a/ans%10;\n    if(b&gt;9-d){\n        int r=b-(9-d);\n        dfs(a+(9-d)*ans,ans/10,r,c);\n    }else{\n        dfs(a+b*ans,ans/10,0,c);\n    }\n    if(c!=0){\n        if(c&gt;=d+1){\n            int r=c-(d+1);\n            dfs(a-d*ans+9*ans,ans/10,b,r);\n        }\n    }\n}\nint main()\n{\n    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n    LL tmp=a;\n    LL ans=1;\n    while(a){\n        a/=10;\n        ans*=10;\n    }\n    dfs(tmp,ans/10,b,c);\n    cout&lt;&lt;maxx&lt;&lt;endl;\n\treturn 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20E%3A%20%E5%87%BA%E5%B7%AE\" style=\"text-align:center;\">试题 E: 出差</h2>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\7e0a31f6ed68451fb91b00c1b4a4c693.png\" width=\"806\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"1179\" src=\"..\\..\\static\\image\\77f257f734254a8eba7b362334b46e6c.png\" width=\"805\"/></p>\n<p><strong> 题意：</strong>n个点，m条边构成一个有边权的无向图，然后每个顶点都有自己的停留时间，即到达该点要停的时间，都是正数，求1到n点的最短时间</p>\n<p><strong>思路：最短路的贝尔曼-福特算法(Bellman-Ford)</strong></p>\n<p>        这题就是最短路模板题，只是加上了顶点要停留，感觉<strong>迪杰斯特拉算法（Dijkstra）</strong>应该也行，但觉得<strong>贝尔曼-福特算法(Bellman-Ford)</strong>应该更合适。</p>\n<p>只是在使用边的时候，将边权+终点停留时间，终点为n时不加</p>\n<p><strong>更新代码：</strong></p>\n<pre><code class=\"language-cpp\"> for(int k=1;k&lt;=n;k++){        //n次更新\n        for(int i=1;i&lt;=m;i++){\n            int res1=0,res2=0;\n            if(b[i]!=n) res1=x[b[i]];        //终点不为n，边权+停留时间\n            if(a[i]!=n) res2=x[a[i]];\n            dist[b[i]]=min(dist[b[i]],dist[a[i]]+c[i]+res1);\n            dist[a[i]]=min(dist[a[i]],dist[b[i]]+c[i]+res2);\n        }\n    }</code></pre>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define fo(a,b) for(int i=a;i&lt;=b;i++)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define M 100005\nint n,m;\nint x[M];\nint dist[M],a[M],b[M],c[M];\nint main(){\n    scanf(\"%d%d\",&amp;n,&amp;m);\n    memset(dist,inf,sizeof(dist));\n    dist[1]=0;\n    for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i];\n    for(int i=1;i&lt;=m;i++)\n        scanf(\"%d%d%d\",&amp;a[i],&amp;b[i],&amp;c[i]);\n    for(int k=1;k&lt;=n;k++){\n        for(int i=1;i&lt;=m;i++){\n            int res1=0,res2=0;\n            if(b[i]!=n) res1=x[b[i]];\n            if(a[i]!=n) res2=x[a[i]];\n            dist[b[i]]=min(dist[b[i]],dist[a[i]]+c[i]+res1);\n            dist[a[i]]=min(dist[a[i]],dist[b[i]]+c[i]+res2);\n        }\n    }\n    cout&lt;&lt;dist[n]&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20F%3A%20%E8%B4%B9%E7%94%A8%E6%8A%A5%E9%94%80\" style=\"text-align:center;\">试题 F: 费用报销</h2>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\2c68772580b944539e72f24e22917dcc.png\" width=\"813\"/></p>\n<p> <img alt=\"\" height=\"600\" src=\"..\\..\\static\\image\\85b2f395d41b4c4f81494a92938158cf.png\" width=\"834\"/></p>\n<p><strong> 题意：</strong>给同一年的一些天，这些天都<strong>一个或多个</strong>的钱，选一些天使金额最多<strong>且不超多m</strong>，其中所有相邻的天数相差<strong>不低于k</strong>（&gt;=k）</p>\n<p><strong>思路：动态规划</strong></p>\n<p><strong>    </strong>    比较简单得到动态规划，首先将天转变为一维数组，dp[i]表示该天最大的金额。</p>\n<p>那么dp[i]=max(dp[i-1],dp[i-k]+a[i])                //对应的就是不选和选</p>\n<p><strong>核心代码：</strong></p>\n<pre><code class=\"language-cpp\">\n    for(int i=1;i&lt;=500;i++){            //一年365天，dp超过365就行\n        if(dp[i]+dp[max(0,i-k)]&lt;=m)\n            dp[i]=max(dp[i]+dp[max(0,i-k)],dp[i-1]);\n        else        //如果选了会超过m，就不选了\n            dp[i]=dp[i-1];\n    }</code></pre>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define fo(a,b) for(int i=a;i&lt;=b;i++)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define M 100005\nint n,m,k;\nint x,y,z;\nint mp[105][105],dp[10005];\nint r[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main(){\n    int sum=0;\n    for(int i=1;i&lt;=12;i++){\n        for(int j=1;j&lt;=r[i];j++){\n            sum++;\n            mp[i][j]=sum;        //映射天数\n        }\n    }\n    scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k);\n    for(int i=1;i&lt;=n;i++){\n        scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z);\n        dp[mp[x][y]]=max(dp[mp[x][y]],z);        //k最小为1，当天的就选个最大的就行\n    }\n    for(int i=1;i&lt;=500;i++){\n        if(dp[i]+dp[max(0,i-k)]&lt;=m)\n            dp[i]=max(dp[i]+dp[max(0,i-k)],dp[i-1]);\n        else\n            dp[i]=dp[i-1];\n    }\n    cout&lt;&lt;dp[500]&lt;&lt;endl;\n    return 0;\n}</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20G%3A%20%E6%95%85%E9%9A%9C\" style=\"text-align:center;\">试题 G: 故障</h2>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\1a59b45c6f4e4ef787ba3b401c8fbb7d.png\" width=\"861\"/></p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\d1d73ed629ce47c09dd2f44e9a922111.png\" width=\"794\"/></p>\n<p><img alt=\"\" height=\"236\" src=\"..\\..\\static\\image\\dc762aaa84d0444f888b164856ea44cc.png\" width=\"818\"/></p>\n<p><strong> 题意：</strong>不知</p>\n<p><strong>思路：</strong>不知，题有点多，做不过来</p>\n<p><strong>代码：</strong>未有</p>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20H%3A%20%E6%9C%BA%E6%88%BF\" style=\"text-align:center;\">试题 H: 机房</h2>\n<p><img alt=\"\" height=\"1173\" src=\"..\\..\\static\\image\\17683902f18b4049a8a14d72c6680ffd.png\" width=\"826\"/></p>\n<p><img alt=\"\" height=\"921\" src=\"..\\..\\static\\image\\038b6189fbd04aaa8e7baf5b97423435.png\" width=\"838\"/></p>\n<p><strong> 题意：</strong>给一颗无边权的树，查询m次两点路劲之间，所有点的<strong>直接连接点的数量</strong>和。</p>\n<p> <strong>思路：LCA+树形DP</strong></p>\n<p>        还是比较好想的，dfs处理出给个点的<strong>直接连接点的数量，</strong>再dfs，求出每个点到顶点的<strong>直接连接点的数量</strong>的前缀和，用dp[i]表示。</p>\n<p>d表示两点x和y的LCA（共公祖先），pre[d]表示d的父点，结果就是dp[x]+dp[y]-dp[d]-dp[pre[d]]。</p>\n<p><strong>核心代码：</strong></p>\n<pre><code class=\"language-cpp\">void dfs(int d,int pre,int sum)\n{\n    for(int i=1;i&lt;n+5;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);           //LCA倍增\n    fa[d][0]=pre;                   //LCA倍增\n    h[d]=h[pre]+1;                  //LCA倍增\n    p[d]=pre;                  //父点\n    for(int i=1;i&lt;=lg[h[d]]+1;i++)                  //LCA倍增\n        fa[d][i]=fa[fa[d][i-1]][i-1];\n    int l=v[d].size();                    //l也是当前结点直接连接其他结点数量\n    dp[d]=l+sum;                          //sum是之前父链的和\n    fo(0,l-1){\n        int now=v[d][i];\n        if(pre!=now){\n            dfs(now,d,dp[d]);\n        }\n    }\n}</code></pre>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define fo(a,b) for(int i=a;i&lt;=b;i++)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define M 200005\nint n,m,x,y;\nint dp[M],p[M];\nvector&lt;int&gt;v[M];\nint h[M],lg[M],fa[M][35];\nvoid dfs(int d,int pre,int sum)\n{\n    for(int i=1;i&lt;n+5;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);           //LCA倍增\n    fa[d][0]=pre;                   //LCA倍增\n    h[d]=h[pre]+1;                  //LCA倍增\n    p[d]=pre;                  //父点\n    for(int i=1;i&lt;=lg[h[d]]+1;i++)                  //LCA倍增\n        fa[d][i]=fa[fa[d][i-1]][i-1];\n    int l=v[d].size();                    //l也是当前结点直接连接其他结点数量\n    dp[d]=l+sum;                          //sum是之前父链的和\n    fo(0,l-1){\n        int now=v[d][i];\n        if(pre!=now){\n            dfs(now,d,dp[d]);\n        }\n    }\n}\nint LCA(int a,int b)\n{\n    if(h[a]&lt;h[b]) swap(a,b);\n    for(int i=lg[h[a]]+1;i&gt;=0;i--){\n        if(h[a]-(1&lt;&lt;i)&gt;=h[b])\n            a=fa[a][i];\n    }\n    if(a==b) return a;\n    for(int i=lg[h[a]]+1;i&gt;=0;i--)\n        if(fa[a][i]!=fa[b][i]){\n            a=fa[a][i];\n            b=fa[b][i];\n        }\n    return fa[a][0];\n}\nint main(){\n    cin&gt;&gt;n&gt;&gt;m;\n    fo(1,n-1){\n        cin&gt;&gt;x&gt;&gt;y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1,0,0);\n    while(m--){\n        int x,y;\n        cin&gt;&gt;x&gt;&gt;y;\n        int d=LCA(x,y);\n        cout&lt;&lt;dp[x]+dp[y]-dp[d]-dp[p[d]]&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20I%3A%20%E9%BD%BF%E8%BD%AE\" style=\"text-align:center;\">试题 I: 齿轮</h2>\n<p><img alt=\"\" height=\"1012\" src=\"..\\..\\static\\image\\0ba32f8591aa4715a09729214d01c2bb.png\" width=\"779\"/></p>\n<p><img alt=\"\" height=\"713\" src=\"..\\..\\static\\image\\dfb162deb63b4411a61ddba94cf1ecc4.png\" width=\"786\"/></p>\n<p><strong> 题意：</strong>给一个数组为齿轮大小，问能不能换顺序后，尾转的速度是首转的速度的qi倍，询问Q次。</p>\n<p><strong>思路：</strong>不难发现这个中间的没有用，就是首的半径=尾的半径*qi就可。而且这种排序是随便的，只需要找这个数组中<strong>有没有两个数相除==qi</strong>即可。</p>\n<p>那么需处理出这个数组所有的可有倍数即可。具体看代码更容易理解，这个时间复杂度是n*logn的，对1e6也应该能用，注意倍数1的判断</p>\n<p><strong>预处理代码：</strong></p>\n<pre><code class=\"language-cpp\">for(int i=1;i&lt;=MAX;i++){            //MAX=2e5\n        if(vis[i]==1){                //vis[i]表示i在该数组中\n            for(int j=i*2;j&lt;=MAX;j+=i){\n                if(vis[j]==1) ans[j/i]=1;        //ans是结果数组\n            }    \n        }\n    }\n</code></pre>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define LL long long\n#define M 1000005\nint MAX=400005;\nint n,m,flag=0;\nint a[M];\nint vis[M],ans[M];\nint main(){\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++){\n        cin&gt;&gt;a[i];\n        if(vis[a[i]]==1) flag=1;        //单独判断ans[1]\n        vis[a[i]]=1;            //表明数组有这个数\n    }\n    if(flag) ans[1]=1;\n    for(int i=1;i&lt;=MAX;i++){\n        if(vis[i]==1){\n            for(int j=i*2;j&lt;=MAX;j+=i){\n                if(vis[j]==1) ans[j/i]=1;\n            }\n        }\n    }\n    int x;\n    while(m--){\n        cin&gt;&gt;x;\n        if(ans[x]) cout&lt;&lt;\"YES\"&lt;&lt;endl;\n        else cout&lt;&lt;\"NO\"&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n<hr/>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%AF%95%E9%A2%98%20J%3A%20%E6%90%AC%E7%A0%96\" style=\"text-align:center;\">试题 J: 搬砖</h2>\n<p><img alt=\"\" height=\"1080\" src=\"..\\..\\static\\image\\487f0086ee6e4bcfa3e35aad5a8c6112.png\" width=\"776\"/></p>\n<p><img alt=\"\" height=\"320\" src=\"..\\..\\static\\image\\e0463d4e81ad401c8248ee9aa4b4d549.png\" width=\"782\"/></p>\n<p><strong> 题意：</strong>选取若干个从上到下放，重量不能小于上面的和，求总价值最大</p>\n<p><strong>思路：</strong>可能是<strong>动态规划</strong>，写差不多觉得和题意有点出入，就直接<strong>dfs暴力</strong>了</p>\n<p>暴力挺简单的，先结构体排序，重量小的一定先选在上面，不然直接压垮了。然后同重量的价值大的一定先选。</p>\n<p>dfs出所有的1-n排序，也就是：</p>\n<p>1 2 3 4 5</p>\n<p>1 2 3 4</p>\n<p>3 4 5</p>\n<p>2 4 5</p>\n<p>这些</p>\n<p>....</p>\n<p>然后计算判断更新最后答案</p>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define fo(a,b) for(int i=a;i&lt;=b;i++)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define M 200005\nint n,maxx=0;\nstruct Node\n{\n    int a,b;\n    bool operator&lt;(const Node temp)const{\n        if(a==temp.a) return b&gt;temp.b;\n        return a&lt;temp.a;\n    }\n}x[M];\n\n//此代码是暴力代码，只能过30%\n\nint q[M],v=0;\nvoid dfs(int d,int pre){\n    if(d==n){                //判断q数组中的顺序是否合法\n        int sum=0,ans=0;\n        for(int i=1;i&lt;=v;i++){\n            if(x[q[i]].a&lt;sum) break;\n            sum+=x[q[i]].a;\n            ans+=x[q[i]].b;\n            if(i==v) maxx=max(maxx,ans);\n        }\n        return;\n    }\n    for(int i=pre+1;i&lt;=n;i++){\n        q[++v]=i;\n        dfs(d+1,i);\n        v--;\n    }\n    if(v!=0) dfs(d+1,pre);\n}\nint main(){\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;i++)\n        cin&gt;&gt;x[i].a&gt;&gt;x[i].b;\n    sort(x+1,x+n+1);\n    dfs(0,0);\n    cout&lt;&lt;maxx&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p></p>\n<p></p>\n<h1 id=\"%E7%BB%93%E5%B0%BE%EF%BC%9A\">结尾：</h1>\n<p>        看了下演草纸，才用了1页多，一般比赛要好几页的。不少题是算法及相关的题，总体acm选手估计是叫好，但是对其他选手不清楚了，这题个人觉得难度适中，因为往年很多题不能暴力，而且到现在，那些题也没有题解（csdn上）。今年只有一题没看，一个暴力，难度肯定是降了不少的。</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-04 16:22:52", "summary": "写的不是很好，浏览量后开的粉丝可见，希望涨一点点粉。觉得还阔以的，就不要取关了题目下载：十三届蓝桥杯组国赛题目下载十三届蓝桥杯组国赛题目下载题没有写，题是暴力的，其他好像都写出来，但是估计还是有错的。"}