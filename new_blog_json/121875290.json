{"blogid": "121875290", "writerAge": "码龄6年", "writerBlogNum": "87", "writerCollect": "936", "writerComment": "124", "writerFan": "129", "writerGrade": "5级", "writerIntegral": "2388", "writerName": "樱花花", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121875290.jpg", "writerRankTotal": "14576", "writerRankWeekly": "17419", "writerThumb": "367", "writerVisitNum": "875353", "blog_read_count": "3903", "blog_time": "于 2021-12-11 16:45:03 发布", "blog_title": "C# Winform中使用SendMessage方法(发送消息与接收消息)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>C# Winform窗口间消息通知，使用Windows API SendMessage方法跨进程实现消息发送，重写WndProc方法接收消息并消息处理</h1>\n<p><strong>主要使用到如下三个方法函数：</strong></p>\n<ul><li>WndProc：主要用在拦截并处理系统消息和自定义消息 \n  <ul><li> <p>可以重写WndProc函数，来捕捉所有发生的窗口消息。这样，我们就可以\"篡改\"传入的消息，而人为的让窗口改变行为</p> </li></ul></li><li>SendMessage：该函数将指定的消息发送到一个或多个窗口。此函数为指定的窗口调用窗口程序，直到窗口程序处理完消息再返回。该函数是应用程序和应用程序之间进行消息传递的主要手段之一 \n  <ul><li>函数原型：IntPtr SendMessage(int hWnd, int msg, IntPtr wParam, IntPtr lParam)；</li><li>参数 \n    <ul><li>hWnd：其窗口程序将接收消息的窗口的句柄。如果此参数为HWND_BROADCAST，则消息将被发送到系统中所有顶层窗口，包括无效或不可见的非自身拥有的窗口、被覆盖的窗口和弹出式窗口，但消息不被发送到子窗口</li><li>Msg：指定被发送的消息</li><li>wParam：指定附加的消息指定信息</li><li>IParam：指定附加的消息指定信息</li><li>返回值：返回值指定消息处理的结果，依赖于所发送的消息</li></ul></li><li>备注：需要用HWND_BROADCAST通信的应用程序应当使用函数RegisterWindowMessage来为应用程序间的通信取得一个唯一的消息。</li></ul></li><li>FindWindow：函数获得一个顶层窗体的句柄，该窗体的类名和窗体名与给定的字符串相匹配。这个函数不查找子窗体。在查找时不区分大写和小写 \n  <ul><li>函数原型：int FindWindow(string lpClassName, string lpWindowName)；</li><li>参数 \n    <ul><li>IpClassName ：指向一个指定了类名的空结束字符串，或一个标识类名字符串的成员的指针。假设该參数为一个成员，则它必须为前次调用theGlobafAddAtom函数产生的全局成员。该成员为16位，必须位于IpClassName的低 16位，高位必须为 0</li><li>IpWindowName：指向一个指定了窗体名（窗体标题）的空结束字符串。假设该參数为空，则为全部窗体全匹配</li></ul></li><li>返回值：假设函数成功，返回值为具有指定类名和窗体名的窗体句柄；假设函数失败，返回值为NULL</li></ul></li><li></li></ul>\n<p><strong>例子代码如下：</strong></p>\n<pre><code class=\"language-cs\">public partial class Form1 : Form\n    {\n        public const int LOGINFORM_MSG = 0x400;\n        protected override void WndProc(ref System.Windows.Forms.Message msg)\n        {\n\n            switch (msg.Msg)\n            {\n\n                case LOGINFORM_MSG: //自定义消息\n                    switch ((msg.LParam.ToInt32()))\n                    {\n                        case 301:\n                            {\n                                MessageBox.Show(\"收到发来消息:\" + msg.WParam.ToInt32());\n                                //if (msg.WParam.ToInt32() == 1)\n                                //{\n                                //}\n                                //else\n                                //{\n                                //}\n                            }\n                            break;\n\n                    }\n                    break;\n            }\n            base.WndProc(ref msg);     //调用基类函数处理非自定义消息。 \n        }\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            //扫码线程\n            Thread m_Thread1 = new Thread(Thread1Handle);\n            m_Thread1.IsBackground = true;\n            m_Thread1.Start();\n        }\n        static void Thread1Handle()\n        {\n            Thread.Sleep(3000);\n            new Demo().Test();\n        }\n    }</code></pre>\n<pre><code class=\"language-cs\">public class Demo\n    {\n        /// &lt;summary&gt;\n        /// 发送消息到指定窗口\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"hWnd\"&gt;其窗口程序将接收消息的窗口的句柄。如果此参数为HWND_BROADCAST，则消息将被发送到系统中所有顶层窗口，\n        /// 包括无效或不可见的非自身拥有的窗口、被覆盖的窗口和弹出式窗口，但消息不被发送到子窗口&lt;/param&gt;\n        /// &lt;param name=\"msg\"&gt;指定被发送的消息&lt;/param&gt;\n        /// &lt;param name=\"wParam\"&gt;指定附加的消息指定信息&lt;/param&gt;\n        /// &lt;param name=\"lParam\"&gt;指定附加的消息指定信息&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [DllImport(\"User32.dll\", EntryPoint = \"SendMessage\")]\n        private static extern IntPtr SendMessage(int hWnd, int msg, IntPtr wParam, IntPtr lParam);//窗口句柄、、\n\n        /// &lt;summary&gt;\n        /// 获取窗体句柄\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"lpClassName\"&gt;指向一个指定了类名的空结束字符串，或一个标识类名字符串的成员的指针。假设该參数为一个成员，\n        /// 则它必须为前次调用theGlobafAddAtom函数产生的全局成员。该成员为16位，必须位于IpClassName的低 16位，高位必须为 0&lt;/param&gt;\n        /// &lt;param name=\"lpWindowName\"&gt;指向一个指定了窗体名（窗体标题）的空结束字符串。假设该參数为空，则为全部窗体全匹配&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [DllImport(\"User32.dll\", EntryPoint = \"FindWindow\")]\n        private static extern int FindWindow(string lpClassName, string lpWindowName);\n        public const int LOGINFORM_MSG = 0x400;\n\n        public void Test()\n        {\n            int WINDOW_HANDLER = FindWindow(null, \"Form1\");//发送消息窗口句柄this.Handle.ToInt32()\n            if (WINDOW_HANDLER == 0)\n            {\n                throw new Exception(\"Could not find Main window!\");//找不到主窗口\n            }\n\n            //long result = SendMessage(WINDOW_HANDLER, LOGINFORM_MSG, new IntPtr(MSG), new IntPtr(ID)).ToInt64();\n            long result = SendMessage(WINDOW_HANDLER, LOGINFORM_MSG, new IntPtr(0), new IntPtr(301)).ToInt64();\n            for (int i = 0; i &lt; 100000; i++)\n            {\n                Application.DoEvents();\n            }\n            result = SendMessage(WINDOW_HANDLER, LOGINFORM_MSG, new IntPtr(1), new IntPtr(301)).ToInt64();\n        }\n    }\n</code></pre>\n<p><strong>实现效果：</strong></p>\n<p><img alt=\"\" height=\"217\" src=\"..\\..\\static\\image\\0c742d0f9c704209b0d93f784553eb3e.png\" width=\"333\"/><img alt=\"\" height=\"218\" src=\"..\\..\\static\\image\\8fe8e7f695dd4d98a0f7179627018302.png\" width=\"335\"/></p>\n<p></p>\n<p><strong>例子下载地址：</strong></p>\n<p><a href=\"https://download.csdn.net/download/qq_37192571/60970345\" title=\"C#Winform中使用SendMessage消息发送拦截-C#文档类资源-CSDN下载\">C#Winform中使用SendMessage消息发送拦截-C#文档类资源-CSDN下载</a></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-12-11 16:45:03", "summary": "窗口间消息通知，使用方法跨进程实现消息发送，重写方法接收消息并消息处理主要使用到如下三个方法函数：：主要用在拦截并处理系统消息和自定义消息可以重写函数，来捕捉所有发生的窗口消息。这样，我们就可以篡改传"}