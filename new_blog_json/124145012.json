{"blogid": "124145012", "writerAge": "码龄2年", "writerBlogNum": "97", "writerCollect": "465", "writerComment": "153", "writerFan": "581", "writerGrade": "4级", "writerIntegral": "1398", "writerName": "Youcan.", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124145012.jpg", "writerRankTotal": "13252", "writerRankWeekly": "31046", "writerThumb": "212", "writerVisitNum": "64883", "blog_read_count": "6730", "blog_time": "已于 2022-04-14 20:44:27 修改", "blog_title": "线程池的使用（7种创建方法）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%C2%A01.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\"> 1. 固定数量的线程池</a></p>\n<p id=\"a.%C2%A0%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C-toc\" style=\"margin-left:80px;\"><a href=\"#a.%C2%A0%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\">a.  线程池返回结果</a></p>\n<p id=\"b.%C2%A0%E2%BE%83%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0%E6%88%96%E4%BC%98%E5%85%88%E7%BA%A7-toc\" style=\"margin-left:80px;\"><a href=\"#b.%C2%A0%E2%BE%83%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0%E6%88%96%E4%BC%98%E5%85%88%E7%BA%A7\">b. ⾃定义线程池名称或优先级</a></p>\n<p id=\"2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\">2. 带缓存的线程池</a></p>\n<p id=\"3.%C2%A0%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-toc\" style=\"margin-left:40px;\"><a href=\"#3.%C2%A0%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\">3. 执⾏定时任务</a></p>\n<p id=\"a.%C2%A0%E5%BB%B6%E8%BF%9F%E6%89%A7%E2%BE%8F(%E2%BC%80%E6%AC%A1)-toc\" style=\"margin-left:80px;\"><a href=\"#a.%C2%A0%E5%BB%B6%E8%BF%9F%E6%89%A7%E2%BE%8F%28%E2%BC%80%E6%AC%A1%29\">a. 延迟执⾏(⼀次)</a></p>\n<p id=\"b.%C2%A0%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E2%BE%8F-toc\" style=\"margin-left:80px;\"><a href=\"#b.%C2%A0%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E2%BE%8F\">b. 固定频率执⾏</a></p>\n<p id=\"c.%20scheduleAtFixedRate%20VS%20scheduleWithFixedDelay-toc\" style=\"margin-left:80px;\"><a href=\"#c.%20scheduleAtFixedRate%20VS%20scheduleWithFixedDelay\">c. scheduleAtFixedRate VS scheduleWithFixedDelay</a></p>\n<p id=\"4.%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#4.%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B\">4. 定时任务单线程</a></p>\n<p id=\"5.%C2%A0%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:40px;\"><a href=\"#5.%C2%A0%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0\">5. 单线程线程池</a></p>\n<p id=\"6.%C2%A0%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:40px;\"><a href=\"#6.%C2%A0%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0\">6. 根据当前CPU⽣成线程池</a></p>\n<p id=\"7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89\">7. ThreadPoolExecutor</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n</div>\n<div>\n<span style=\"color:#262626;\">线程池的创建⽅法总共有 </span>\n<span style=\"color:#262626;\">7 </span>\n<span style=\"color:#262626;\">种，但总体来说可分为 </span>\n<span style=\"color:#262626;\">2 </span>\n<span style=\"color:#262626;\">类：</span>\n</div>\n<div>\n<blockquote>\n<div>\n<span style=\"color:#ff9900;\"><strong><em>        1. 通过 ThreadPoolExecutor 创建的线程池； </em></strong></span>\n</div>\n<div>\n<span style=\"color:#ff9900;\"><strong><em>        2. 通过 Executors 创建的线程池。 </em></strong></span>\n</div>\n</blockquote>\n<div></div>\n<div>\n<div>\n<span style=\"color:#262626;\">线程池的创建⽅式总共包含以下 </span>\n<span style=\"color:#262626;\">7 </span>\n<span style=\"color:#262626;\">种（其中 </span>\n<span style=\"color:#262626;\">6 </span>\n<span style=\"color:#262626;\">种是通过 </span>\n<span style=\"color:#262626;\">Executors </span>\n<span style=\"color:#262626;\">创建的，</span>\n<span style=\"color:#262626;\">1 </span>\n<span style=\"color:#262626;\">种是通过 </span>\n</div>\n<div>\n<span style=\"color:#262626;\">ThreadPoolExecutor 创建的）： </span>\n</div>\n<div>\n<blockquote>\n<div>\n<span style=\"color:#262626;\">        1. Executors.newFixedThreadPool：创建⼀个固定⼤⼩的线程池，可控制并发的线程数，超出的线程会在队列中等待； </span>\n</div>\n<div>\n<span style=\"color:#262626;\">        2. Executors.newCachedThreadPool：创建⼀个可缓存的线程池，若线程数超过处理所需，缓存⼀段时间后会回收，若线程数不够，则新建线程； </span>\n</div>\n<div>\n<span style=\"color:#262626;\">        3. Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执⾏顺序； </span>\n</div>\n<div>\n<span style=\"color:#262626;\">        4. Executors.newScheduledThreadPool：创建⼀个可以执⾏延迟任务的线程池； </span>\n</div>\n<div>\n<span style=\"color:#262626;\">        5. Executors.newSingleThreadScheduledExecutor：创建⼀个单线程的可以执⾏延迟任务的线程池； </span>\n</div>\n<div>\n<p></p>\n<div>\n<span style=\"color:#262626;\">        6. Executors.newWorkStealingPool：创建⼀个抢占式执⾏的线程池（任务执⾏顺序不确定）【JDK1.8 </span>\n<span style=\"color:#262626;\">添加】。 </span>\n</div>\n<div>\n<span style=\"color:#262626;\">        7. ThreadPoolExecutor：最原始的创建线程池的⽅式，它包含了 </span>\n<span style=\"color:#262626;\">7 </span>\n<span style=\"color:#262626;\">个参数可供设置，后⾯会详细讲。 </span>\n</div>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n<h2 id=\"%C2%A01.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\"> 1. 固定数量的线程池</h2>\n<pre><code class=\"language-java\">public class ThreadPoolDemo3 {\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(2);\n        //添加任务方式 1\n        threadPool.submit(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        });\n\n        //添加任务方式2\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        });\n    }\n}\n输出：\npool-1-thread-1\npool-1-thread-2</code></pre>\n<h3 id=\"a.%C2%A0%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\">a.  <span style=\"color:#262626;\">线程池返回结果 </span></h3>\n<pre><code class=\"language-java\">public class ThreadPoolDemo4 {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService threadPool =  Executors.newFixedThreadPool(2);\n        //执行任务\n        Future&lt;Integer&gt; result = threadPool.submit(new Callable&lt;Integer&gt;() {\n            @Override\n            public Integer call() throws Exception {\n                int num = new Random().nextInt(10);\n                System.out.println(\"随机数\" + num);\n                return num;\n            }\n        });\n\n        //打印线程池返回方式\n        System.out.println(\"返回结果：\" + result.get());\n    }\n}\n输出\n随机数8\n返回结果：8</code></pre>\n<blockquote>\n<p><em><span style=\"color:#ff9900;\"><strong>使用submit可以执行有返回值的任务或者是无返回值的任务；而execute只能执行不带返回值的任务。 </strong></span></em></p>\n</blockquote>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"173\" src=\"..\\..\\static\\image\\58160ec92ac147ba94e6960e0382b13c.png\" width=\"522\"/></p>\n<p></p>\n<h3 id=\"b.%C2%A0%E2%BE%83%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0%E6%88%96%E4%BC%98%E5%85%88%E7%BA%A7\">b. <span style=\"color:#262626;\">⾃定义线程池名称或优先级 </span></h3>\n<pre><code class=\"language-java\">public class ThreadPoolDemo5 {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n         // 创建线程工厂\n        ThreadFactory threadFactory = new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                //！！！！！！！一定要注意：要把任务Runnable设置给新创建的线程\n                Thread thread = new Thread(r);\n                //设置线程的命名规则\n                thread.setName(\"我的线程\" + r.hashCode());\n                //设置线程的优先级\n                thread.setPriority(Thread.MAX_PRIORITY);\n                return thread;\n            }\n        };\n        ExecutorService threadPool = Executors.newFixedThreadPool(2,threadFactory);\n        //执行任务1\n        Future&lt;Integer&gt; result = threadPool.submit(new Callable&lt;Integer&gt;() {\n            @Override\n            public Integer call() throws Exception {\n                int num = new Random().nextInt(10);\n                System.out.println(Thread.currentThread().getPriority() + \", 随机数：\" + num);\n                return num;\n            }\n        });\n        //打印线程池返回结果\n        System.out.println(\"返回结果：\" + result.get());\n    }\n}\n</code></pre>\n<blockquote>\n<p> 提供的功能：</p>\n<p><em><strong><span style=\"color:#ff9900;\">        1. 设置（线程池中）线程的命名规则。</span></strong></em></p>\n<p><em><strong><span style=\"color:#ff9900;\">        2. 设置线程的优先级。</span></strong></em></p>\n<p><em><strong><span style=\"color:#ff9900;\">        3. 设置线程分组。</span></strong></em></p>\n<p><em><strong><span style=\"color:#ff9900;\">        4. 设置线程类型（用户线程、守护线程）。</span></strong></em></p>\n</blockquote>\n<h2 id=\"2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\">2. <span style=\"color:#262626;\">带缓存的线程池 </span></h2>\n<pre><code class=\"language-java\">public class ThreadPoolDemo6 {\n    public static void main(String[] args) {\n        //创建线程池\n        ExecutorService service = Executors.newCachedThreadPool();\n        for (int i = 0; i &lt; 10; i++) {\n            int finalI = i;\n            service.submit(() -&gt; {\n                System.out.println(\"i : \" + finalI + \"|线程名称：\" + Thread.currentThread().getName());\n            });\n        }\n    }\n}\n输出\ni : 1|线程名称：pool-1-thread-2\ni : 4|线程名称：pool-1-thread-5\ni : 3|线程名称：pool-1-thread-4\ni : 5|线程名称：pool-1-thread-6\ni : 0|线程名称：pool-1-thread-1\ni : 2|线程名称：pool-1-thread-3\ni : 6|线程名称：pool-1-thread-7\ni : 7|线程名称：pool-1-thread-8\ni : 8|线程名称：pool-1-thread-9\ni : 9|线程名称：pool-1-thread-1</code></pre>\n<blockquote>\n<p><em><span style=\"color:#ff9900;\"><strong> 优点：线程池会根据任务数量创建线程池，并且在一定时间内可以重复使用这些线程，产生相应的线程池。</strong></span></em></p>\n<p><em><span style=\"color:#ff9900;\"><strong>缺点：适用于短时间有大量任务的场景，它的缺点是可能会占用很多的资源。</strong></span></em></p>\n</blockquote>\n<h2 id=\"3.%C2%A0%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\">3. <span style=\"color:#262626;\">执⾏定时任务</span></h2>\n<h3 id=\"a.%C2%A0%E5%BB%B6%E8%BF%9F%E6%89%A7%E2%BE%8F(%E2%BC%80%E6%AC%A1)\"><span style=\"color:#262626;\">a. 延迟执⾏(⼀次) </span></h3>\n<pre><code class=\"language-java\">public class ThreadPoolDemo7 {\n    public static void main(String[] args) {\n        //创建线程池\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);\n        System.out.println(\"添加任务的时间：\" + LocalDateTime.now());\n        //执行定时任务（延迟3s执行）只执行一次\n        service.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"执行子任务：\" + LocalDateTime.now());\n            }\n        },3, TimeUnit.SECONDS);\n    }\n}\n输出\n添加任务的时间：2022-04-13T14:19:39.983\n执行子任务：2022-04-13T14:19:42.987</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"213\" src=\"..\\..\\static\\image\\1bb6de00a83b4a03a0ab714a459f7b41.png\" width=\"538\"/></p>\n<p>  </p>\n<h3 id=\"b.%C2%A0%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E2%BE%8F\"><span style=\"color:#262626;\">b. 固定频率执⾏ </span></h3>\n<pre><code class=\"language-java\">public class ThreadPoolDemo8 {\n    public static void main(String[] args) {\n        //创建线程池\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);\n        System.out.println(\"添加任务时间：\" + LocalDateTime.now());\n        //2s之后开始执行定时任务，定时任务每隔4s执行一次\n        service.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"执行任务：\" + LocalDateTime.now());\n            }\n        },2,4, TimeUnit.SECONDS);\n    }\n}\n输出\n添加任务时间：2022-04-13T14:24:38.810\n执行任务：2022-04-13T14:24:40.814\n执行任务：2022-04-13T14:24:44.814\n执行任务：2022-04-13T14:24:48.813\n执行任务：2022-04-13T14:24:52.815\n执行任务：2022-04-13T14:24:56.813\n执行任务：2022-04-13T14:25:00.813\n执行任务：2022-04-13T14:25:04.814\n执行任务：2022-04-13T14:25:08.813\n... ...\n... ...\n执行任务：2022-04-13T14:26:44.814\n执行任务：2022-04-13T14:26:48.813</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"204\" src=\"..\\..\\static\\image\\d302cc93fa734ee38fdb96c4ec0d0abb.png\" width=\"558\"/></p>\n<p></p>\n<p><strong><span style=\"color:#fe2c24;\"> 注意事项：</span></strong></p>\n<pre><code class=\"language-java\">public class ThreadPoolDemo9 {\n    public static void main(String[] args) {\n        //创建线程池\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);\n        System.out.println(\"添加任务时间：\" + LocalDateTime.now());\n        service.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"执行任务： \" + LocalDateTime.now());\n                try {\n                    Thread.sleep(5 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },2,4, TimeUnit.SECONDS);\n    }\n}\n输出\n添加任务时间：2022-04-13T14:33:34.551\n执行任务： 2022-04-13T14:33:36.556\n执行任务： 2022-04-13T14:33:41.557\n执行任务： 2022-04-13T14:33:46.559\n执行任务： 2022-04-13T14:33:51.561\n执行任务： 2022-04-13T14:33:56.562\n执行任务： 2022-04-13T14:34:01.564\n执行任务： 2022-04-13T14:34:06.566\n执行任务： 2022-04-13T14:34:11.566\n执行任务： 2022-04-13T14:34:16.567\n执行任务： 2022-04-13T14:34:21.570\n执行任务： 2022-04-13T14:34:26.570\n... ....</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"208\" src=\"..\\..\\static\\image\\6b542f145d6941fb89a3c9f3c874bf23.png\" width=\"609\"/></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"202\" src=\"..\\..\\static\\image\\2d69c80bb6634055871a2b7fa81b5720.png\" width=\"605\"/></p>\n<p></p>\n<h3 id=\"c.%20scheduleAtFixedRate%20VS%20scheduleWithFixedDelay\"><span style=\"color:#262626;\">c. scheduleAtFixedRate VS scheduleWithFixedDelay </span></h3>\n<p></p>\n<blockquote>\n<div>\n<em><span style=\"color:#ff9900;\"><strong>scheduleAtFixedRate 是以上⼀次任务的开始时间，作为下次定时任务的参考时间的（参考时间+延迟任务=任务执⾏）。 </strong></span></em>\n</div>\n<div></div>\n<div>\n<em><span style=\"color:#ff9900;\"><strong>scheduleWithFixedDelay 是以上⼀次任务的结束时间，作为下次定时任务的参考时间的。</strong></span></em>\n<span style=\"color:#262626;\"> </span>\n</div>\n</blockquote>\n<pre><code class=\"language-java\">public class ThreadPoolDemo10 {\n    public static void main(String[] args) {\n        //创建线程池\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);\n        System.out.println(\"添加任务时间：\" + LocalDateTime.now());\n        //2s之后开始执行定时任务，定时任务每隔4s执行一次\n        service.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"执行任务：\" + LocalDateTime.now());\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, 2, 4, TimeUnit.SECONDS);\n    }\n}\n输出\n添加任务时间：2022-04-13T14:46:02.871\n执行任务：2022-04-13T14:46:04.876\n执行任务：2022-04-13T14:46:09.878\n执行任务：2022-04-13T14:46:14.880\n执行任务：2022-04-13T14:46:19.883\n执行任务：2022-04-13T14:46:24.885\n执行任务：2022-04-13T14:46:29.888\n执行任务：2022-04-13T14:46:34.888\n执行任务：2022-04-13T14:46:39.891\n执行任务：2022-04-13T14:46:44.893\n执行任务：2022-04-13T14:46:49.895\n执行任务：2022-04-13T14:46:54.897\n执行任务：2022-04-13T14:46:59.900\n执行任务：2022-04-13T14:47:04.901\n... ...\n</code></pre>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"166\" src=\"..\\..\\static\\image\\06ff563acbad4eb284f6916c862a1fcf.png\" width=\"521\"/></p>\n<p></p>\n<h2 id=\"4.%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span style=\"color:#262626;\">4. 定时任务单线程</span></h2>\n<pre><code class=\"language-java\">public class ThreadPoolDemo11 {\n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();\n        System.out.println(\"添加任务的时间:\" + LocalDateTime.now());\n        service.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"执行时间：\" + LocalDateTime.now());\n            }\n        },2, TimeUnit.SECONDS );\n    }\n}\n输出\n添加任务的时间:2022-04-13T15:06:38.100\n执行时间：2022-04-13T15:06:40.106</code></pre>\n<h2 id=\"5.%C2%A0%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span style=\"color:#262626;\">5. 单线程线程池</span></h2>\n<pre><code class=\"language-java\">public class ThreadPoolDemo12 {\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newSingleThreadScheduledExecutor();\n        for (int i = 0; i &lt; 10; i++) {\n            service.submit(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"线程名：\" + Thread.currentThread().getName());\n                }\n            });\n        }\n    }\n}\n输出\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n线程名：pool-1-thread-1\n</code></pre>\n<p><em><span style=\"color:#fe2c24;\"><strong>（MS） 为什么不直接用线程？</strong></span></em></p>\n<blockquote>\n<p><em><span style=\"color:#fe2c24;\"><strong>单线程的线程池又什么意义？</strong></span></em></p>\n<p><em><span style=\"color:#fe2c24;\"><strong>        1. 复用线程。</strong></span></em></p>\n<p><em><span style=\"color:#fe2c24;\"><strong>        2. 单线程的线程池提供了任务队列和拒绝策略（当任务队列满了之后（Integer.MAX_VALUE），新来的任务就会拒绝策略）</strong></span></em></p>\n</blockquote>\n<h2 id=\"6.%C2%A0%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span style=\"color:#262626;\">6. </span><span style=\"color:#262626;\">根据当前CPU⽣成线程池</span></h2>\n<pre><code class=\"language-java\">public class ThreadPoolDemo13 {\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newWorkStealingPool();\n        for (int i = 0; i &lt; 10; i++) {\n            service.submit(() -&gt; {\n                System.out.println(\"线程名\" + Thread.currentThread().getName());\n            });\n            \n            while(!service.isTerminated()) {\n            }\n        }\n    }\n}\n输出\n线程名ForkJoinPool-1-worker-1</code></pre>\n<h2 id=\"7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89\"><span style=\"color:#262626;\">7. </span><span style=\"color:#262626;\">ThreadPoolExecutor</span></h2>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/m0_48273471/article/details/124171220\" title=\"线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/m0_48273471/article/details/124171220</span></span></a></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-14 20:44:27", "summary": "目录固定数量的线程池线程池返回结果定义线程池名称或优先级带缓存的线程池执定时任务延迟执次固定频率执定时任务单线程单线程线程池根据当前成线程池线程池的创建法总共有种，但总体来说可分为类：通过创建的线程池"}