{"blogid": "126616349", "writerAge": "码龄1年", "writerBlogNum": "369", "writerCollect": "279", "writerComment": "28", "writerFan": "12629", "writerGrade": "5级", "writerIntegral": "3918", "writerName": "m0_67391521", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126616349.jpg", "writerRankTotal": "4843", "writerRankWeekly": "616", "writerThumb": "66", "writerVisitNum": "176389", "blog_read_count": "447", "blog_time": "于 2022-08-31 08:24:42 发布", "blog_title": "狂神说Java--Java学习笔记(合集)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>笔记参考来源狂神说Java视频<a href=\"https://www.bilibili.com/video/BV12J41137hu\">https://www.bilibili.com/video/BV12J41137hu</a><br/> 本篇笔记有点长，可以根据目录定位，建议配合视频学习。</p>\n<h1><a id=\"_5\"></a>预科</h1>\n<h2><a id=\"_8\"></a>什么是计算机</h2>\n<ol><li>名称：Computer，全称电子计算机，俗称电脑。</li><li>定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。</li><li>组成：由硬件和软件组成。</li><li>形式：常见显示有台式计算机、笔记本计算机、大型计算机等。</li><li>应用：科学计算、数据处理、自动控制、计算机辅助设计、人工智能、网络等领域。</li></ol>\n<h2><a id=\"_17\"></a>硬件及冯诺依曼结构</h2>\n<h3><a id=\"_20\"></a>计算机硬件</h3>\n<p>组成：cpu，主板，内存，电源，主机箱，硬盘，显卡，键盘、鼠标，显示器。</p>\n<h3><a id=\"_24\"></a>冯诺依曼结构</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427081055529.png\"/></p>\n<h2><a id=\"_28\"></a>软件及软件开发</h2>\n<h3><a id=\"_31\"></a>计算机软件</h3>\n<h2><a id=\"Windows_33\"></a>Windows常用快捷键</h2>\n<p>Alt+f4关闭窗口 Shift+Delete永久删除 ctrl+w自动保存</p>\n<p>死机：任务管理器结束进程</p>\n<h2><a id=\"Dos_40\"></a>基本的Dos命令</h2>\n<p>打开CMD的方式</p>\n<ol><li>开始+系统+命令提示符</li><li>win键+R+输入cmd (推荐使用)</li><li>在任意的文件夹下，按住Shift键+鼠标右击，打开命令行窗口</li><li>在资源管理器地址栏路径前面加 “cmd ”</li><li>管理员运行方式：命令提示符右键以管理员身份运行（最高权限运行）</li></ol>\n<p>常用的Dos命令</p>\n<pre><code># 盘符切换 E:\n# 查看当前目录下所有文件 dir\n# 切换目录 cd /d E:idea\n# 返回上一级目录 cd ..\n# 进入同级目录下的下一级目录 cd tmp(该目录下的文件名)\n# 清屏 cls (clear screen)\n# 退出终端 exit\n# 查看电脑当前IP地址 ipconfig\n\n# 打开计算器 calc\n# 打开画图 mspaint\n# 新建记事本 notepad\n\n# 在当前目录新建文件夹 md test(文件夹名)\n# 新建文件 cd&gt; a.txt(文件名)\n# 删除文件 del a.txt(文件名)\n# 删除目录 rd test(目录名)\n\n# ping命令(复制链接进入Dos直接单击鼠标右键粘贴)\n\tping www.baidu.com\n</code></pre>\n<h2><a id=\"_75\"></a>计算机语言发展史</h2>\n<ul><li>第一代语言：机器语言</li><li>第二代语言：汇编语言</li><li>第三代语言：高级语言</li></ul>\n<h3><a id=\"_82\"></a>高级语言</h3>\n<p>C、C++、Java、C#、Python、PHP、JavaScript …</p>\n<p>大体上分为：<strong>面向过程</strong>与<strong>面向对象</strong>两大类</p>\n<ul><li>C语言是典型的<strong>面向过程</strong>的语言，C++，Java是典型的<strong>面向对象</strong>的语言</li></ul>\n<hr/>\n<hr/>\n<h1><a id=\"Java_94\"></a>Java入门</h1>\n<h2><a id=\"Java_97\"></a>Java帝国的诞生</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427081209316.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427081218160.png\"/></p>\n<h2><a id=\"Java_103\"></a>Java特性与优势</h2>\n<ul><li>简单性</li><li>面对对象</li><li>可移植性</li><li>高性能</li><li>分布式</li><li>多态性</li><li>多线程</li><li>安全性</li><li>健壮性</li></ul>\n<h2><a id=\"Java_116\"></a>Java三大版本</h2>\n<ul><li> <p>Write Once，Run Anywhere</p> </li><li> <p><strong>JavaSE</strong>: 标准版 (桌面程序，控制台开发…)</p> </li><li> <p>JavaME: 嵌入式开发 (手机，小家电…)，已经凉了</p> </li><li> <p><strong>JavaEE</strong>: E企业级开发 (Web端，服务端开发…)，JavaSE为基础</p> </li></ul>\n<h2><a id=\"JDK_JRE_JVM_125\"></a>JDK JRE JVM</h2>\n<ul><li>JDK：Java Development Kit (Java开发者工具，包括 JRE，JVM)</li><li>JRE：Java Runtime Environment (Java运行时环境)</li><li>JVM：Java Virtual Machine (Java虚拟机，跨平台核心)</li></ul>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\20210427081317290.png\"/></p>\n<h2><a id=\"_134\"></a>安装开发环境</h2>\n<h3><a id=\"JDk_137\"></a>卸载JDk</h3>\n<ol><li>删除Java安装目录</li><li>删除环境变量JAVA_HOME</li><li>删除path下关于JAVA的目录</li><li>Java -version</li></ol>\n<h3><a id=\"JDK_144\"></a>安装JDK</h3>\n<ol><li>百度搜索JDK8，找到下载地址</li><li>同意协议，下载电脑对应的版本，如64位操作系统下载 jdk-8u281-windows-x64.exe</li><li>双击安装JDK</li><li>记住安装路径</li><li>配置环境变量 \n  <ol><li>我的电脑-》属性-》系统高级设置-》环境变量</li><li>系统变量 新建–&gt; JAVA_HOME 输入对应的jdk安装路径</li><li>path变量–&gt;% JAVA_HOME%in</li></ol> </li><li>测试是否成功 cmd–&gt;Java -version</li></ol>\n<hr/>\n<hr/>\n<h1><a id=\"Java_160\"></a>Java基础</h1>\n<h2><a id=\"_163\"></a>注释</h2>\n<ol><li>单行注释 //</li><li>多行注释 /* */</li><li>文档注释 /** */</li></ol>\n<h2><a id=\"_170\"></a>标识符和关键字</h2>\n<ul><li>Java 所有的组成部分都需要名字。类名、变量名、方法名都被称为<strong>标识符</strong></li></ul>\n<h3><a id=\"_175\"></a>关键字</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2021042708142877.png\"/></p>\n<h3><a id=\"_179\"></a>标识符注意点</h3>\n<ul><li>所有标识符都应该以 字母、$(美元符)、_(下划线) 开头</li><li>首字母之后可以是 字母、$、_ 或数字任何字符组合</li><li><strong>关键字不能作为变量名或方法名</strong></li><li>标识符<strong>大小写敏感</strong></li><li><strong>可以用中文命名，但不建议使用</strong>，即使用拼音命名也Low</li></ul>\n<h2><a id=\"_187\"></a>数据类型</h2>\n<ul><li> <p><strong>强类型语言</strong></p>\n<ul><li>要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</li></ul> </li><li> <p>弱类型语言：JavaScript，Python</p> </li><li> <p>Java的数据类型分为两大类</p>\n<ul><li><strong>基本类型</strong>（primitive type），有8大基本类型，此外都是引用类型</li><li><strong>引用类型</strong>（reference type）</li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427081748164.png\"/></p>\n<pre><code>//整数\nint num1 = 10; //最常用，只要别超过21亿（2^31-1）\nbyte num2 = 20; //-128~127\nshort num3 = 30;\nlong num4 = 30L; //long类型数字后面要加个L(尽量用大写，小写l容易与1搞混)\n\n\n//小数：浮点数\nfloat num5 = 50.1F; //float类型数字后面要加个F\ndouble num6 = 3.141592653589793238;\n\n\n//字符\nchar name = '国';\n//字符串, String不是关键字，是类\n//String namea = \"薛之谦\";\n\n\n//布尔值：是非\nboolean flag = true\n</code></pre>\n<h3><a id=\"_224\"></a>什么是字节</h3>\n<ul><li>位(bit)：是计算机内部数据存储的最小单位，11001100是一个八位二进制数</li><li>字节(byte, B)：是计算机中 数据处理 的基本单位，习惯上用大写B表示</li><li>1B(byte) = 8bit，1字节等于8位</li><li>字符：指计算机中使用的字母，数字，字和符号 \n  <ul><li>1bit表示1位</li><li>1Byte表示一个字节 1B=8b</li><li>1024B = 1KB, 1024KB = 1M, 1024M = 1G</li></ul> </li></ul>\n<h3><a id=\"_234\"></a>扩展及面试题</h3>\n<pre><code>//整数扩展： 二进制0b\t\t八进制0\t\t十进制\t\t十六进制0x\nint i = 10;\nint i2 = 010; //八进制 8\nint i3 = 0x10; //十六进制 16\n\n\n//浮点数扩展：\n//面试题：银行业务字母怎么表示钱? BigDecimal(数学工具类)\n//float double是有问题的，最好避免使用浮点数进行比较\nfloat f = 0.1f; \t//0.1\ndouble d = 1.0/10;  //0.1\nSystem.out.println(f==d); //false\n//浮点数 位有限，舍入误差，大约\n//最好避免使用浮点数进行比较\nfloat f1 = 23131313131f;\nfloat f2 = f1+1;\nSystem.out.println(f1==f2); //true\n\n\n//字符扩展：所有字符本质还是数字\nchar c1 = 'a';\nchar c2 = '中';\n\nSystem.out.println(c1);\t\t//a\nSystem.out.println((int)c1);//强制类型转换,97\nSystem.out.println(c2);\t\t//中\nSystem.out.println((int)c2);//强制类型转换,20013\n\n//编码 Unicode表（97=a,65=A）2字节 0-65536\n//U000~UFFFF 十六进制（u0061=a,相当于十进制的97）\nSystem.out.println('a');  //a ''是转义字符\n\n\n//布尔值扩展\nboolean flag = true;\nif(flag==true){} //新手\nif(flag){}\t//老手这样写 Less is More(代码要精简易读)\n</code></pre>\n<h2><a id=\"_275\"></a>类型转换</h2>\n<ul><li> <p>由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</p> </li><li> <p>容量高–&gt;低：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427081848182.png\"/></p> </li><li> <p>运算中，不同类型的数据先转化位同一类型，再进行运算。</p>\n<ul><li>强制转换，（类型）变量名，容量由高到低</li><li>自动转换，容量由低到高</li></ul> <p>//强制转换 （类型）变量名 高–低<br/> //自动转换 低–高<br/> int i = 128;<br/> byte b = (byte)i; //强制转换 内存溢出 -128~127<br/> double d =i; //自动转换</p> <p>System.out.println(i); //128<br/> System.out.println(b); //-128<br/> System.out.println(d); //128.0<br/> /*<br/> 注意点：<br/> 1.不能对布尔值进行转换<br/> 2.不能把对象类型转换为不相干的类型<br/> 3.在把高容器转换到低容量的时候，强制转换<br/> 4.可能存在内存溢出，或者精度问题</p>\n<ul><li>*/<br/> System.out.println((int)23.7); //23 丢失精度<br/> char c = ‘a’;<br/> int n = c+1;<br/> System.out.println(n); //98<br/> System.out.println((char)n); //b</li></ul> <p>//当操作数比较大时，注意溢出问题<br/> //JDK7新特性，数字之间可以用下划线分割<br/> int money = 10_0000_0000; //10亿，下划线不会被打印出来<br/> System.out.println(money); //1000000000<br/> int years = 20;</p> <p>int total = money*years; //数据大，溢出<br/> System.out.println(total); //-1474836480</p> <p>long total2 = money*years; //默认是int，转换前就有溢出问题<br/> System.out.println(total2); //-1474836480</p> <p>long total3 = money*(long)years; //先把一个数转Long<br/> System.out.println(total3); //20000000000</p> </li></ul>\n<h2><a id=\"_327\"></a>变量、常量、作用域</h2>\n<ul><li> <p>变量是什么：就是可以变化的量</p> </li><li> <p>Java是一种强类型语言，每个变量都必须声明其类型</p> </li><li> <p>Java变量是程序中最基本的存储单元，要素包括变量名，变量类型和作用域</p> <p>//数据类型 变量名 = 值;<br/> type varName [=value][{,varName[=value]}];<br/> //可以使用逗号隔开同多个类型的变量，但不建议在一行定义多个变量</p> </li></ul>\n<h3><a id=\"_339\"></a>变量作用域</h3>\n<ul><li> <p>类变量（static）</p> </li><li> <p>实例变量</p> </li><li> <p>局部变量</p> <p>public class Variable{<!-- --><br/> static int allClicks = 0; //类变量<br/> String str = “hello world”; //实例变量<br/> public void method(){<!-- --><br/> int i=0; //局部变量<br/> }<br/> }</p> </li></ul>\n<h3><a id=\"_354\"></a>常量</h3>\n<ul><li> <p>常量：初始化后不能再改变的值，不会变动的值。</p> </li><li> <p>可以理解为一种特殊的变量，其值被设定后，在程序运行过程不允许被更改。</p> <p>//常量一般用大写字符<br/> final 常量名=值;<br/> final double PI=3.14;</p> <p>//修饰符 不存在先后顺序，static可以写final后面<br/> static final doube PI=3.14; //类变量，该类下的全局范围</p> </li></ul>\n<h3><a id=\"_368\"></a>变量的命名规范</h3>\n<ul><li>所有变量、方法、类名：<strong>见名知意</strong></li><li>类成员变量：首字母小写+驼峰原则：lastName</li><li>局部变量：首字母小写+驼峰原则</li><li>常量：大写字母和下划线：MAX_VALUE</li><li>类名：首字母大写+驼峰原则：Man，GoodMan</li><li>方法名：首字母小写+驼峰原则：run()，fastRun()</li></ul>\n<h2><a id=\"_377\"></a>运算符</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427081956511.png\"/></p>\n<pre><code>int a=10;\nint b=20;\nSystem.out.println(a/b); //0\nSystem.out.println((double)a/b); //0.5\n\nlong c=12300000000;\nSystem.out.println(a+b); //int\nSystem.out.println(a+c); //long 自动转换式子中容量大的数据类型\n</code></pre>\n<h3><a id=\"_392\"></a>自增自减运算符</h3>\n<pre><code>// ++自增 --自减 单目运算符\nint a = 3;\nint b = a++; //b=a,a=a+1 先赋值 即b=3 a=4\nint c = ++a; //a=a+1,c=a 先自增 即a=5 c=5\n\nSystem.out.println(a); //5\nSystem.out.println(b); //3\nSystem.out.println(c); //5\n\n\n//幂运算 2^3 2*2*2=8\ndouble pow = Math.pow(2,3); // (底数，指数)double型\nSystem.out.println(pow); //8.0\n\n\n//扩展：笔试题 i=5 s=(i++)+(++i)+(i--)+(--i) s=?\nint i=5;\nint s=(i++)+(++i)+(i--)+(--i);\nSystem.out.println(s); //24\n</code></pre>\n<h3><a id=\"_415\"></a>逻辑运算符</h3>\n<ul><li> <p>&amp;&amp; 逻辑与运算：两个变量都为真，结果为true</p> </li><li> <p>|| 逻辑与运算：两个变量有一个为真，结果为true</p> </li><li> <p>! 取反，真变为假，假变为真</p> <p>// 与(snd) 或(or) 非(取反)<br/> boolean a = true;<br/> boolean b = false;</p> <p>System.out.println(a&amp;&amp;b); // false<br/> System.out.println(a||b); // true<br/> System.out.println(!(a&amp;&amp;b)); // true</p> <p>int c=5;<br/> boolean d = (c&lt;5)&amp;&amp;(c++&lt;5); //第一个值为false，后面就不进行判定了<br/> System.out.println(d); //false<br/> System.out.println©; //5 c++未执行</p> </li></ul>\n<h3><a id=\"_435\"></a>位运算</h3>\n<pre><code>/*\n    A = 0011 1100\n    B = 0000 1101\n\n    A&amp;B 0000 1101 按位与\n    A|B 0011 1101 按位或\n    A^B 0011 0001 异或\n    ~B  1111 0010 非\n\n    面试题：2*8 怎么算最快？ 2&lt;&lt;3\n    &lt;&lt;左移  *2 效率极高！！\n    &gt;&gt;右移  /2\n   */\nSystem.out.println(2&lt;&lt;3); // 16\n</code></pre>\n<h3><a id=\"_453\"></a>三元运算符</h3>\n<pre><code>int a = 10;\nint b = 20;\n\na+=b; // a = a+b\na-=b; // a = a-b\n\nSystem.out.println(a); //10\n//字符串连接符 + ，转化为String类型,然后拼接    注意！！\nSystem.out.println(\"\"+a+b); //1020\nSystem.out.println(a+b+\"\"); //30 先进行运算，再转为String拼接\nSystem.out.println(a+b+\"str\"); //30str\n\n\n// x ? y : z\n//如果x为真，则结果为y,否则为z\n//if(x) y; else z;\nint score = 80;\nString type = score&lt;60?\"及格\":\"不及格\";\nSystem.out.println(type); //及格\n</code></pre>\n<h2><a id=\"_476\"></a>包机制</h2>\n<ul><li> <p>为了更好地组织类，Java提供了包机制，由于区分类名的命名空间</p> </li><li> <p>包的语法格式：</p> <p>package pkg1[.pkg2[.pkg3…]];</p> </li><li> <p>一般利用公司域名倒置作为包名；com.kuangstudy.www</p> </li><li> <p>为了能够使用一个包的成员，需要在Java程序中导入该包</p> <p>import package1[.package2…].(className|<em>); //通配符</em> 导入包下所有的类</p> </li><li> <p>参考：阿里巴巴Java开发手册</p> </li></ul>\n<h2><a id=\"JavaDoc_495\"></a>JavaDoc生成文档</h2>\n<ul><li> <p>javadoc命令是用来生成自己API文档的</p> </li><li> <p>参数信息</p>\n<ul><li>@author 作者名</li><li>@version 版本号</li><li>@since 指明最早用的jdk版本</li><li>@param 参数名</li><li>@return 返回值情况</li><li>@throws 异常抛出情况</li></ul> </li><li> <p>API文档：<a href=\"https://docs.oracle.com/javase/8/docs/api/\">https://docs.oracle.com/javase/8/docs/api/</a></p> <p>/**</p>\n<ul><li> <p>@author Kuangshen</p> </li><li> <p>@version 1.0</p> </li><li> <p>@since 1.8<br/> */<br/> public class Demo05 {<!-- --><br/> String name;</p> <p>/**</p>\n<ul><li>@author kuangshen</li><li>@param name</li><li>@return</li><li>@throws Exception<br/> */<br/> public String test(String name) throws Exception{<!-- --><br/> return name;<br/> }</li></ul> </li></ul> <p>}</p> </li></ul>\n<ol><li>打开某个类所在文件夹下的cmd命令行</li><li>输入：javadoc -encoding UTF-8 -charset UTF-8 Doc(类名).java</li><li>会自动生成该类有关的API文档，查看文件夹发现多了一些文件</li><li>打开 index.html（首页）查看文档注释</li></ol>\n<hr/>\n<hr/>\n<h1><a id=\"Java_541\"></a>Java流程控制</h1>\n<h2><a id=\"Scanner_544\"></a>用户交互Scanner</h2>\n<ul><li> <p>之前我们学的基本语法并没有实现<strong>程序和人的交互</strong>，Java给我们提供了一个工具类，可以获取用户的输入java.util.Scanner是Java5的新特征，我们通过Scanner类来获取用户的输入。</p> </li><li> <p>基本语法</p> <p>Scanner s = new Scanner(System.in);</p> </li><li> <p>通过Scanner类的 next()与 nextLine()方法获取用户的字符串，读取前一般用hasNext()与hasNextLine()判断是否还有输入的数据。</p> <p>//创建一个扫描器对象<br/> Scanner scanner = new Scanner(System.in);</p> <p>System.out.println(“使用next方式接收”);<br/> //判断用户有没有输入字符串<br/> if(scanner.hasNext()){ //使用hasNextLie()会接收一行 “hello word”<br/> //使用next方式接收<br/> String str = scanner.next();<br/> System.out.println(“输入的内容为：”+str);<br/> //input: hello word<br/> //输入的内容为：hello<br/> }<br/> //凡是属于IO流的类如果不关闭会一直占用资源<br/> scanner.close();</p> </li></ul>\n<h4><a id=\"next_571\"></a>next()</h4>\n<ol><li>一定要读取到有效字符才可以结束输入</li><li>对输入有效字符之前遇到的空白，next()方法会将其去掉</li><li>只有输入有效字符后才将其后面输入的<strong>空白作为结束符</strong></li><li><strong>next()不能得到带有空格的字符串</strong></li></ol>\n<h4><a id=\"nextLine_578\"></a>nextLine()</h4>\n<ol><li> <p>以<strong>Enter作为结束符</strong>，即返回输入回车之前所有的字符</p> </li><li> <p><strong>nextLine()可以获取空白</strong></p> <p>//从键盘接收数据<br/> Scanner scanner = new Scanner(System.in);<br/> System.out.println(“请输入数据：”);</p> <p>String str = scanner.nextLine();<br/> System.out.println(“输入的内容为：”+str);<br/> scanner.close();</p> <p>System.out.println(“请输入整数：”);<br/> if(scanner.hasNextInt()){<!-- --><br/> int i=scanner.nextInt();<br/> System.out.println(“输入的整数为：”+i);<br/> }else {<!-- --><br/> System.out.println(“输入的不是整数数据”);<br/> }</p> </li></ol>\n<h2><a id=\"_601\"></a>顺序结构</h2>\n<ul><li>Java的基本结构就是顺序结构，除非特别指明，否则就按语句一条一条执行。</li><li>顺序结构是最简单的算法结构。</li><li>语句语句之间是按从上到下执行的，它是由若干个依次执行的处理步骤组成的，它是如何一种算法都离不开的一种基本算法结构。</li></ul>\n<h3><a id=\"_608\"></a>选择结构</h3>\n<ul><li> <p>if单选择结构 if( )</p> </li><li> <p>if双选择结构 if( ){ }else{ }</p> </li><li> <p>if多选择结构 if( ){ }else if{ }else{}</p> </li><li> <p>嵌套的if结构 if( ){ if( ) }</p> <p>int a = 80;<br/> if(a&gt;60){<!-- --><br/> System.out.println(“及格”);<br/> if(a&gt;80) System.out.println(“且优秀”);<br/> }else if(a&gt;0){<!-- --><br/> System.out.println(“不及格”);<br/> }else {<!-- --><br/> System.out.println(“缺考”);<br/> }</p> </li></ul>\n<h4><a id=\"switch_626\"></a>switch多选择结构</h4>\n<pre><code>char grade = 'C'; //JDK新特性 可以是字符串(字符本质还是数字)\nswitch (grade){\n    case 'A':\n        System.out.println(\"优秀\");\n        break; //可选，跳出当前结构\n    case 'B':\n        System.out.println(\"良好\");\n        break;\n    case 'C':\n        System.out.println(\"合格\");\n        break;\n    default: //默认，以上值没匹配到\n        System.out.println(\"不及格\");\n        break;\n}\n</code></pre>\n<p>IDEA反编译之后.class文件与源代码对比</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082240517.png\"/></p>\n<h2><a id=\"_649\"></a>循环结构</h2>\n<ul><li> <p><strong>while循环</strong></p> <p>//计算1+2+3+…+100<br/> int i=0;<br/> int sum=0;<br/> while(i&lt;100){<!-- --><br/> i++;<br/> sum+=i;<br/> }<br/> System.out.println(sum); //5050</p> </li><li> <p>do…while循环</p> <p>//先执行后判断，至少执行一次<br/> do{<!-- --><br/> i++;<br/> sum+=i;<br/> }while(i&lt;100) //跟上面效果一样</p> </li><li> <p><strong>for循环</strong></p> <p>//（初始化;条件判断;迭代）<br/> for(int i=0;i&lt;100;i++){<!-- --><br/> i++;<br/> sum+=i;<br/> }<br/> for(; ; ){…} //死循环</p> <p>//练习：输出1-1000能被5整除的数，每行输出3个<br/> for (int i = 1; i &lt;= 1000; i++) {<!-- --><br/> if(i%5==0){<!-- --><br/> System.out.print(i+\" \"); //输出完不换行<br/> }<br/> if(i%(3*5)==0){<!-- --><br/> System.out.println();<br/> }<br/> }</p> <p>//练习2：输出九九乘法表<br/> for(int i=1;i&lt;=9;i++){<!-- --><br/> for(int j=1;j&lt;=i;j++){<!-- --><br/> System.out.print(j+“<em>“+i+”=\"+i</em>j+” \");<br/> }<br/> System.out.println();<br/> }</p> </li></ul>\n<h4><a id=\"for_703\"></a>增强for循环</h4>\n<pre><code>int [] numbers = {10,20,30,40,50}; //定义一个数组\nfor (int x:numbers){\n    System.out.println(x); //遍历数组的元素 10 20 30 40 50\n}\n//相当于\nfor(int i=0;i&lt;5;i++){\n    System.out.println(numbers[i]);\n}\n</code></pre>\n<h4><a id=\"break__continue_715\"></a>break &amp; continue</h4>\n<ul><li> <p>break可用在任何循环的主体部分，由于<strong>强行退出循环</strong>，也可以用在switch语句。</p> </li><li> <p>continue用于循环语句中，<strong>终止某次循环过程</strong>，跳过剩余语句，之间进行下一次循环条件判断。</p> </li><li> <p>标签：后面跟一个冒号的标识符 label:</p> <p>//打印101-150之间所有的质数<br/> int count = 0;<br/> outer:for(int i=101;i&lt;=150;i++){<!-- --><br/> for (int j=2;j&lt;i/2;j++){<!-- --><br/> if(i%j==0)<br/> continue outer; //不建议使用标签<br/> }<br/> System.out.print(i+\" \");<br/> }</p> </li></ul>\n<h2><a id=\"_732\"></a>流程控制练习</h2>\n<pre><code>//打印等腰空心三角形\n/*  例如：输入为4时\n          *\n         * *\n        *   *\n       * * * *\n*/\nScanner scanner = new Scanner(System.in);\nint n = scanner.nextInt(); //n为三角形高\nfor(int i=1;i&lt;=n;i++){\n    for(int j=1;j&lt;=2*n-1;j++){\n        if(i!=n){ //若不为最后一行\n            if(i+j==n+1)\n                System.out.print(\"*\"); //三角形左腰边\n            else if(i+j==n+2*i-1)\n                System.out.print(\"*\"); //三角形右腰边\n            else System.out.print(\" \");\n        }\n        else if(j%2!=0){  //最后一行，底边\n            System.out.print(\"*\");\n        }else {\n            System.out.print(\" \");\n        }\n    }\n    System.out.println(); //换行\n}\n</code></pre>\n<hr/>\n<hr/>\n<h1><a id=\"Java_767\"></a>Java方法</h1>\n<h2><a id=\"_770\"></a>方法的定义</h2>\n<ul><li> <p>Java的方法类似与其他语言的函数，是<strong>一段用来完成特定功能的代码片段</strong>。</p> </li><li> <p><strong>方法包含一个方法头和一个方法体</strong>。</p>\n<ul><li><strong>修饰符</strong>：可选，定义了方法的访问类型，告诉编译器如何调用该方法。</li><li><strong>返回值类型</strong>：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法没有返回值，则returnValueType为关键字void。</li><li><strong>方法名</strong>：是方法的实际名称，方法名与参数表共同构成方法签名。</li><li><strong>参数类型</strong>：像一个占位符。方法被调用时，传递值给参数，该值称为实参或变量。参数列表是指方法的参数类型、顺序和参数个数。参数是可选的，方法可以不包含任何参数。 \n    <ul><li>形式参数：在方法被调用时用于接收外界输入的数据。</li><li>实参：调用方法时实际传给方法的数据。</li></ul> </li><li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li></ul> <p>修饰符 返回值类型 方法名（参数类型 参数名,…）{<!-- --><br/> 方法体…<br/> return 返回值；<br/> }</p> </li></ul>\n<h2><a id=\"_789\"></a>方法的调用</h2>\n<ul><li> <p>调用方法：对象名.方法名(实参列表)。</p> </li><li> <p>Java支持两种调用方法的方式，根据方法是否返回值来选择。</p> </li><li> <p><strong>当方法返回一个值的时候，方法调用通常被当成一个值</strong>。</p> <p>int larger = max(30,40);</p> </li><li> <p>如果方法返回值是void，方法调用一定是一条语句。</p> </li><li> <p>扩展：值传递和引用传递 ( <strong>Java都是值传递</strong>)。</p> </li><li> <p><strong>调用其他类的方法，除非是static静态方法，不然必须实例化这个类(new)</strong></p> <p>public class Demo01 {<!-- --></p> <pre><code>public static void main(String[] args) {\n    int add = Demo01.add(1,2); // 通过类名直接调用静态方法\n    System.out.println(add); // 3\n}\n// static静态方法，否则就要new实例化来调用\npublic static int add(int a,int b){\n    return a+b;\n}\n</code></pre> <p>}</p> </li></ul>\n<h3><a id=\"__819\"></a>值传递 &amp;引用传递</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082403886.png\"/></p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082454225.png\"/></p>\n<h2><a id=\"_827\"></a>方法的重载</h2>\n<ul><li> <p>重载是在一个类中，有相同的方法名，参数列表不同的方法。</p> </li><li> <p>方法重载的规则：</p>\n<ul><li><strong>方法名称必须相同</strong></li><li><strong>参数列表必须不同</strong>（个数、参数类型、或排序不同）</li><li>返回类型可以相同也可以不相同</li><li>仅仅返回类型不同不足以成为方法的重载</li></ul> </li><li> <p>实现理论</p>\n<ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li></ul> </li></ul>\n<h2><a id=\"_842\"></a>命令行传参</h2>\n<ul><li> <p>有时候你希望运行一个程序时候传递给它消息，这要靠传递命令行参数给main()函数实现。</p> <p>public static void main(String[] args) {<!-- --><br/> //args.length 数组长度<br/> for (int i = 0; i &lt; args.length; i++) {<!-- --><br/> System.out.println(“args[”+i+\"]: \"+args[i]);<br/> }<br/> }</p> </li></ul>\n<p>找到当前类的文件夹，打开cmd.</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082556110.png\"/></p>\n<h2><a id=\"_859\"></a>可变参数</h2>\n<ul><li> <p>Jdk1.5开始，Java支持传递同类型的可变参数给一个方法。</p> </li><li> <p>在方法声明中，在指定参数类型后加一个省略号 (…)。</p> </li><li> <p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</p> <p>//打印最大值<br/> public static void printMax(int… num){<!-- --><br/> if(num.length==0){<!-- --><br/> System.out.println(“没有值传入”);<br/> return;<br/> }<br/> int result = num[0];<br/> for (int i = 1; i &lt; num.length; i++) {<!-- --><br/> if(num[i] &gt; result){<!-- --><br/> result = num[i];<br/> }<br/> }<br/> System.out.println(“最大值是：”+result);<br/> }<br/> public static void main(String[] args) {<!-- --><br/> printMax(1,2,3,4); //最大值是：4<br/> printMax(new int[]{1,2,3,4,5}); //最大值是：5<br/> }</p> </li></ul>\n<h2><a id=\"_886\"></a>递归</h2>\n<ul><li> <p>递归就是：A方法调用A方法，自己调用自己！</p> </li><li> <p>递归策略只需少量的代码可描述解题过程中多次重复计算，大大减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p> </li><li> <p>递归结构</p>\n<ul><li><strong>递归头</strong>：什么时候不调用自身方法，没有头 将陷入死循环。</li><li><strong>递归体</strong>：什么时候需要调用自身方法。</li></ul> <p>//阶乘 n! n*(n-1)<em>…<em>2</em>1<br/> public static int f(int n){<!-- --><br/> if(n==1) return 1;<br/> return n</em>f(n-1); //递归：调用自身<br/> }<br/> public static void main(String[] args) {<!-- --><br/> System.out.println(f(5)); //5!= 120<br/> }</p> </li></ul>\n<hr/>\n<hr/>\n<h1><a id=\"Java_912\"></a>Java数组</h1>\n<h2><a id=\"_915\"></a>数组的定义</h2>\n<ul><li>数组是相同类型数据的有序集合</li><li>数组描述的是相同类型的若干数据，按照一定先后次序排序组合而成</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过下标访问它们</li></ul>\n<h3><a id=\"_922\"></a>数组的声明创建</h3>\n<ul><li> <p>首先必须声明数组变量，才能在程序中使用数组。</p> <p>dataType[] arrayRefVar; //首选<br/> dataType arrayRefVar[]; //效果相同,但不是首选</p> </li><li> <p>Java语言使用new操作符来创建数组，语法如下</p> <p>dataType[] arrayRefVar = new dataType[arraySize]; //int[] nums=new int[10]</p> </li><li> <p>数组的元素是通过索引访问的，数组索引从0开始</p> </li><li> <p>获取数组长度：<strong>arrays.length</strong></p> <p>int[] nums; //1.声明一个数组<br/> nums = new int[3]; //2.创建一个数组<br/> //3.给数组元素赋值<br/> nums[0]=1;<br/> nums[1]=2;<br/> nums[2]=3;<br/> for (int num : nums) { //打印数组所有元素<br/> System.out.println(num);<br/> }</p> </li></ul>\n<h3><a id=\"_949\"></a>内存分析</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082623150.png\"/></p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082639964.png\"/></p>\n<hr/>\n<h3><a id=\"_959\"></a>数组的三种初始化</h3>\n<ul><li> <p>静态初始化</p> <p>//静态初始化：创建+赋值<br/> int[] a={1,2,3};<br/> Man[] mans={new Man(1,1),new Man(2,2)}</p> </li><li> <p>动态初始化</p> <p>//包含默认初始化<br/> int[] a=new int[2]; //默认值为0<br/> a[0]=1;<br/> a[1]=2;</p> </li><li> <p>默认初始化</p>\n<ul><li>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</li></ul> </li></ul>\n<h3><a id=\"_979\"></a>数组的基本特点</h3>\n<ol><li> <p>其长度是确定的，数组一旦被创建，它的大小就是不可改变的。</p> </li><li> <p>其元素必须是相同类型，不允许出现混合类型。</p> </li><li> <p>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</p> </li><li> <p>数组变量属于引用类型，数组也可以看作对象，其中每个元素相当于该对象的成员变量。</p> <p>数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，</p> <p><strong>数组本身是在堆中的</strong>。</p> </li></ol>\n<h3><a id=\"_994\"></a>数组边界</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082726194.png\"/></p>\n<h2><a id=\"_998\"></a>数组的使用</h2>\n<ul><li> <p><strong>For-Each循环</strong></p> <p>int[] arrays = {1,2,3,4,5};<br/> //打印全部的数组元素 JDK1.5 没有下标<br/> for (int array : arrays) {<!-- --><br/> System.out.println(array);<br/> }</p> </li><li> <p><strong>数组作方法入参</strong></p> <p>//打印数组元素<br/> public static void printArray(int[] a){<!-- --><br/> for (int i = 0; i &lt; a.length; i++) {<!-- --><br/> System.out.print(a[i]+\" \");<br/> }<br/> }</p> </li><li> <p><strong>数组作返回值</strong></p> <p>//反转数组<br/> public static int[] reverse(int[] arrays){<!-- --><br/> int[] result = new int[arrays.length];<br/> //反转的操作<br/> for (int i = 0; i &lt; arrays.length; i++) {<!-- --><br/> result[i] = arrays[arrays.length-i-1];<br/> }<br/> return result;<br/> }</p> </li></ul>\n<h2><a id=\"_1033\"></a>多维数组</h2>\n<ul><li> <p>多维数组可以看成数组的数组，比如二维数组就是一个特殊的数组，其每一个元素都是一个一维数组。</p> <p>int arr[][] = new int[3][2]; //二维数组,三行两列</p> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082746289.png\"/></p>\n<pre><code>int[][] array = {<!-- -->{1,2},{3,4},{5,6}};\n//打印二维数组所有元素\nfor (int i = 0; i &lt; array.length; i++) { //arrays.length=3\n    for (int j = 0; j &lt; array[i].length; j++) {\n        System.out.print(array[i][j]+\" \");\n    }\n    System.out.println();\n}\n</code></pre>\n<h2><a id=\"Arrays_1053\"></a>Arrays类</h2>\n<ul><li> <p>数组的工具类java.util.Arrays</p> </li><li> <p>由于数组对象本身并没有什么方法可以供我们使用，但API提供了一个工具类Arrays供我们使用。</p> </li><li> <p>Array类中的方法都是static修饰的静态方法，使用时直接使用类名进行调用，可以不用对象调用。</p> </li><li> <p>常用功能</p>\n<ul><li>给数组赋值：fill方法。</li><li>排序：sort方法，升序。</li><li>比较数组：equals方法比较数组中元素值是否相等。</li><li>查找数组元素：binarySearch对排序好的数组进行二分查找法操作。</li></ul> <p>int[] a = {1,2,3,4,9000,32145,451,21};<br/> System.out.println(a); // [I@28d93b30 (hashcode)</p> <p>//Arrays.toString 打印数组元素<br/> System.out.println(Arrays.toString(a)); //[1, 2, 3, 4, 9000, 32145, 451, 21]</p> <p>//二分法查找某值 返回下标<br/> System.out.println(Arrays.binarySearch(a, 9000)); // 4</p> <p>//填充<br/> Arrays.fill(a,2,4,0); //数组[a[2]~a[4])之间填充0<br/> System.out.println(Arrays.toString(a)); //[1, 2, 0, 0, 9000, 32145, 451, 21]</p> <p>//升序排序<br/> Arrays.sort(a);</p> </li></ul>\n<h2><a id=\"_1082\"></a><strong>冒泡排序</strong></h2>\n<ul><li> <p>冒泡排序是八大排序最出名的排序算法。</p> </li><li> <p>代码：两层循环，外层冒泡轮数，里层依次比较。</p> </li><li> <p>当我们看到嵌套循环，应该立马就可以得出这个算法的<strong>时间复杂度为O(n2)</strong>。</p> <p>//冒泡排序<br/> //1.比较数组中两个相邻的元素，如果第一个数大于第二个数，交换它们位置<br/> //2.每一次比较，都会产生一个最大或最小的数字(升序为最大数)<br/> //3.下一轮则可以少一次排序<br/> //4.依次循环，直到结束<br/> public static int[] sort(int[] array){<!-- --><br/> int temp=0;<br/> //外层循环，次数length-1<br/> for (int i = 0; i &lt; array.length-1; i++) {<!-- --><br/> //内层循环：如果第一个数大于第二个数，交换它们位置<br/> for (int j = 0; j &lt; array.length-1-i; j++) {<!-- --><br/> if(array[j]&gt;array[j+1]){<!-- --><br/> temp=array[j];<br/> array[j]=array[j+1];<br/> array[j+1]=temp;<br/> }<br/> }<br/> }<br/> return array;<br/> }</p> <p>public static void main(String[] args) {<!-- --><br/> int[] a={8,1,35,47,19,-2};<br/> int[] sort = sort(a);<br/> System.out.println(Arrays.toString(sort)); //[-2, 1, 8, 19, 35, 47]<br/> }</p> </li><li> <p>思考：如何优化？</p> </li></ul>\n<h2><a id=\"_1119\"></a>稀疏数组</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427082948815.png\"/></p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083015623.png\"/></p>\n<hr/>\n<pre><code>//创建一个二维数组 11*11  0：没有棋子，1：黑棋  2：白棋\nint[][] array1 = new int[11][11];\narray1[1][2] = 1;\narray1[2][3] = 2;\n//输出原始的数组\nSystem.out.println(\"原始的数组：\");\nfor (int[] array : array1) {\n    for (int i : array) {\n        System.out.print(i+\"\t\");\n    }\n    System.out.println();\n}\n\n//转换为稀疏数组保存\n//1.有效值的个数\nint sum = 0; //有效值总数\nfor (int i = 0; i &lt; 11; i++) {\n    for (int j = 0; j &lt; 11; j++) {\n        if(array1[i][j]!=0){\n            sum++;\n        }\n    }\n}\n//2.创建一个稀疏数组\nint[][] array2 = new int[sum+1][3];\narray2[0][0] = 11;\narray2[0][1] = 11;\narray2[0][2] = sum;\n\n//3.遍历二维数组，将有效值存放到稀疏数组\nint count = 0;\nfor (int i = 0; i &lt; array1.length; i++) {\n    for (int j = 0; j &lt; array1[i].length; j++) {\n        if(array1[i][j]!=0){\n            count++;\n            array2[count][0] = i;\n            array2[count][1] = j;\n            array2[count][2] = array1[i][j];\n        }\n    }\n}\n\n//4.输出稀疏数组\nSystem.out.println(\"稀疏数组：\");\nfor (int i = 0; i &lt; array2.length; i++) {\n    for (int j = 0; j &lt; array2[i].length; j++) {\n        System.out.print(array2[i][j]+\"\t\");\n    }\n    System.out.println();\n}\n/* 结果：\n输出原始的数组\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n稀疏数组\n11\t11\t2\t\n1\t2\t1\t\n2\t3\t2\t\n*/\n</code></pre>\n<hr/>\n<h1><a id=\"_1202\"></a>面向对象</h1>\n<h2><a id=\"_1205\"></a>初识面向对象</h2>\n<h3><a id=\"_1208\"></a>面向过程&amp;面向对象</h3>\n<ul><li><strong>面向过程思想</strong>\n<ul><li>步骤清晰简单，第一步做什么，第二部做什么…</li><li>面向过程适合处理一些较为简单的问题</li></ul> </li><li><strong>面向对象思想</strong>\n<ul><li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li></ul> </li><li><strong>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</strong></li></ul>\n<h3><a id=\"_1218\"></a>什么是面向对象</h3>\n<ul><li>面向对象编程（Object-Oriented Programming, OOP）</li><li>本质：以类的方式组织代码，以对象的组织(封装)数据。</li><li><strong>抽象</strong></li><li>三大特性 \n  <ul><li>封装</li><li>继承</li><li>多态</li></ul> </li><li>从认识论的角度考虑是先有对象后有类。<strong>对象是具体的事物</strong>，类是对象的抽象。</li><li>从代码运行角度考虑是先有类后有对象。<strong>类是对象的模板</strong>。</li></ul>\n<h3><a id=\"_1230\"></a>类与对象的关系</h3>\n<ul><li>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但并不能代表某一个具体的事物。 \n  <ul><li>动物、植物、手机、电脑…</li><li>Person类、Pet类、Cat类等，都是用来描述/定义某一具体的事物应该具备的特点和行为。</li></ul> </li><li>对象是抽象概念的具体实例，如张三是人的一个具体实例、张三家里的狗旺财就是狗的一个具体实例。</li></ul>\n<h2><a id=\"_1237\"></a>创建与初始化对象</h2>\n<ul><li>使用new来创建对象。</li><li>使用new关键字创建的时候，除了分配内存之外，还会给创建好的对象进行默认的初始化，以及对类中构造器的调用。</li><li>类中的<strong>构造器</strong>也被称为构造方法，创建对象时必须要调用。有以下特点： \n  <ul><li><strong>必须和类的名字相同</strong></li><li><strong>没有返回类型，也不能写void</strong></li></ul> </li><li>一个类即使什么都不写，也会存在一个默认的构造方法</li></ul>\n<h3><a id=\"_1247\"></a>构造器</h3>\n<pre><code>public class Person {\n    //一个类即使什么都不写，也会存在一个默认的无参构造方法\n    //显示地定义构造器\n    String name;\n    \n    //作用：1. 使用new关键字，本质是在调用构造器\n    //2. 用来初始化对象的值\n    public Person(){} //无参构造\n    \n    //有参构造 3.一旦定义了有参构造，无参就必须显示定义\n    public Person(String name){\n        this.name=name;\n    }\n\t//Alt+insert 快捷键插入构造方法\n}\n</code></pre>\n<h3><a id=\"_1266\"></a>内存分析</h3>\n<pre><code>//定义一个宠物类\npublic class Pet {\n    public String name; //默认 null\n    public int age; \t//默认 0\n    //无参构造\n\n    public void shout(){\n        System.out.println(\"叫了一声\");\n    }\n}\n\n\n//应用类，创建调用对象\npublic class Application {\n    public static void main(String[] args) {\n        \n        Pet dog = new Pet();\n\n        dog.name = \"旺财\";\n        dog.age = 3;\n        dog.shout();\n    }\n}\n</code></pre>\n<ul><li><strong>对象通过引用类型来操作：栈 - - -&gt;堆</strong></li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083120326.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083125469.png\"/></p>\n<h2><a id=\"_1298\"></a>封装</h2>\n<ul><li>该露的露，该藏的藏 \n  <ul><li>我们程序设计要追求“<strong>高内聚，低耦合</strong>”。高内聚就是类的内部数据细节由自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li></ul> </li><li>封装（数据的隐藏） \n  <ul><li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，称为信息隐藏。</li></ul> </li><li>作用 \n  <ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护性增加了</li></ol> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083157156.png\"/></p>\n<h2><a id=\"_1313\"></a>继承</h2>\n<ul><li> <p>继承的本质是对某一批类的抽象，从而实现对世界更好地建模。</p> </li><li> <p><strong>extends</strong>的意思是”扩展“。子类是父类的扩展，使用关键字extends来表示。</p> </li><li> <p><strong>Java中类只有单继承</strong>，没有多继承！一个类只能继承一个父类。</p> </li><li> <p>继承是<strong>类与类之间的一种关系</strong>，此外还有依赖、组合、聚合等。</p> </li><li> <p>继承关系的两个类，一个为<strong>子类（派生类）</strong>，一个为**父类（基类）**子类继承父类。</p> </li><li> <p>子类和父类之间，从意义上讲应该具有”is a“的关系。</p> <p>//学生类(子类)继承 人类(父类)<br/> public class Student extends Person{ /<em>Person extends Object</em>/<br/> …<br/> }</p> </li><li> <p>子类继承了父类，就会拥有父类的全部方法，而private<strong>私有属性及方法无法继承</strong>。</p> </li><li> <p>在Java中，所有类，都默认直接或间接继承<strong>Object</strong>类 (Ctrl+H 可以查看类关系)</p> </li><li> <p><strong>被final修饰的类</strong>，无法被继承（断子绝孙）。</p> </li></ul>\n<h3><a id=\"super__this_1339\"></a>super &amp; this</h3>\n<ol><li>super()调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的方法或构造方法中</li><li>**super()<strong>和</strong>this()**不能同时调用构造方法，因为this也必须写在第一行</li></ol>\n<ul><li> <p><strong>super与this的区别</strong>：super代表<strong>父类对象的引用，只能在继承条件下使用</strong>；this调用自身对象，没有继承也可以使用。</p> <p>super(); //隐藏代码，默认调用了父类的无参构造，要写只能写第一行</p> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083247265.png\"/></p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083318162.png\"/></p>\n<h3><a id=\"_1356\"></a>方法的重写</h3>\n<ul><li> <p>重写：子类的方法必须与父类方法必须一致，方法体不同。</p> </li><li> <p>重写是方法的重写，与属性无关</p> </li><li> <p>重写方法只与非静态方法有关，与静态方法无关（静态方法不能被重写）</p> <p>public class B {<!-- --><br/> public static void test(){ //静态方法<br/> System.out.println(“B==&gt;test()”);<br/> }<br/> }</p> <p>public class A extends B{ //继承<br/> public static void test(){<!-- --><br/> System.out.println(“A==&gt;test()”);<br/> }<br/> }</p> <p>public class Application {<!-- --><br/> public static void main(String[] args) {<!-- --><br/> //方法的调用之和左边定义的类型有关<br/> A a = new A();<br/> a.test(); //打印 A==&gt;test()</p> <pre><code>    //父类的引用指向了子类，但静态方法没有被重写\n    B b = new A();\n    b.test(); //打印 B==&gt;test()\n}\n</code></pre> <p>}</p> </li></ul>\n<p><strong>修改A.java, B.java</strong></p>\n<pre><code>public class B {\n    public void test(){ //非静态方法\n        System.out.println(\"B==&gt;test()\");\n    }\n}\npublic class A extends B{\n    @Override //重写了B的方法\n    public void test() {\n        System.out.println(\"A==&gt;test()\");\n    }\n}\n\n\n//父类的引用指向了子类\nB b = new A(); //子类重写了父类的方法，执行子类的方法\nb.test(); //打印变成了 A==&gt;test()\n/* \n静态方法是类的方法，非静态方法是对象的方法\n有static时，b调用了B类的方法，因为b是b类定义的\n没有static时，b调用的是对象的方法，而b是A类new出来的对象，调用A的方法\n*/\n</code></pre>\n<ul><li>静态方法属于类，非静态方法属于对象</li><li>注意点：</li></ul>\n<ol><li>方法名、参数列表必须相同</li><li>修饰符范围可以扩大，不能缩小（public&gt;protect&gt;private）</li><li>抛出的异常 范围可以被缩小，不能扩大</li><li>被**static(属于类，不属于实例)，final(常量方法)，private(私有)**修饰的方法不能重写</li></ol>\n<h2><a id=\"_1425\"></a>多态</h2>\n<ul><li> <p>动态编译：类型</p> </li><li> <p><strong>即同一方法可以根据发送对象的不同而采用不同的行为方式</strong></p> </li><li> <p>一个对象的实际类型是确定的，但可以指向对象的引用可以有很多</p> </li><li> <p>多态存在条件</p>\n<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2021042708335834.png\"/></p>\n<hr/>\n<ul><li>注意点： \n  <ol><li><strong>多态是方法的多态，没有属性的多态</strong></li><li>父类和子类，有联系 类型转换异常: ClassCastException</li><li>存在条件：继承关系，方法需要重写，父类引用指向子类对象！</li></ol> </li></ul>\n<h3><a id=\"instanceof_1449\"></a>instanceof和类型转换</h3>\n<ul><li> <p><strong>instanceof 引用类型比较</strong>，判断一个对象是什么类型</p> <p>public static void main(String[] args) {<!-- --></p> <pre><code>// Object &gt; String\n// Objest &gt; Person &gt; Student\n// Objest &gt; Person &gt; Teacher\nObject object = new Student();\n// X instanceof Y，X引用指向的对象是不是Y的子类\nSystem.out.println(object instanceof Student); //true\nSystem.out.println(object instanceof Person); //true\nSystem.out.println(object instanceof Teacher); //false\nSystem.out.println(object instanceof Object); //true\nSystem.out.println(object instanceof String); //false\n\n//类型之间的转化：父-子（高-低）,低可以转换为高\nPerson obj = new Syudent(); //只能用Person方法（重写了用子类重写过的方法）\n(Syudent)obj.go(); //强转之后可以用Student方法(Student-&gt;go())\n</code></pre> <p>}</p> </li></ul>\n<p><strong>类型转换</strong></p>\n<ol><li>父类引用指向子类的对象</li><li>把子类转换为父类，向上转型，会丢失自己原来的一些方法</li><li>把父类转换为子类，向下转型，强制转换，才调用子类方法</li><li>方便方法的调用(转型)，减少重复的代码，简洁。</li></ol>\n<h2><a id=\"Static_1479\"></a>Static</h2>\n<ul><li> <p>静态变量可以直接用类名访问，也称类变量。</p> </li><li> <p>静态变量(或方法)对于类，所有对象（实例）所共享。</p> </li><li> <p>静态区代码 加载类时一起被初始化，最早执行且只执行一次（第一次new）。</p> </li><li> <p>Math-&gt;随机数:</p> <p>//静态导入包<br/> import static java.lang.Math.random;</p> <p>public class Application {<!-- --><br/> public static void main(String[] args) {<!-- --></p> <pre><code>    //第一种随机数，不用导包\n    System.out.println(Math.random()); //0.7562202902634543\n\n    //第二种随机数，静态导入包\n    System.out.println(random()); //0.5391606223844663\n}\n</code></pre> <p>}</p> </li></ul>\n<h2><a id=\"abstract_1502\"></a>抽象类(abstract)</h2>\n<ul><li> <p>abstract修饰的类就是抽象类，修饰的方法就是抽象方法。</p> </li><li> <p>抽象类中可以没有抽象方法，但有抽象方法的类一定要声明为抽象类。</p> </li><li> <p>抽象类不能使用new来创建对象，它是用来让子类继承的。</p> </li><li> <p><strong>抽象方法只有方法的声明，没有实现</strong>，让其子类实现。</p> </li><li> <p>子类继承抽象类，<strong>必须实现抽象类的所有方法</strong>，否则该子类也要声明为抽象类。</p> <p>//abstract 抽象类 类只能单继承（接口可以多继承）<br/> public abstract class Action {<!-- --></p> <pre><code>//约束~有人帮我们实现~\n//抽象方法只有方法名，没有方法的实现\npublic abstract void doSth();\n\n//1.不能new抽象类，只能靠子类去实现它，仅作为一个约束\n//2.抽象方法只能出现在抽象类中，抽象类可以有普通方法\n//3.抽象类有构造器，可以派生子类\n//4.抽象类的意义：约束，提高开发效率。但是类只能单继承，所以有局限 用的不多\n</code></pre> <p>}</p> </li></ul>\n<h2><a id=\"interface_1525\"></a>接口(interface)</h2>\n<ul><li> <p>普通类：只有具体实现</p> </li><li> <p>抽象类：具体实现和规范(抽象方法)都有</p> </li><li> <p>接口：<strong>只有规范，没有方法实现</strong>，专业的约束！约束与实现分离：面向接口编程~</p> </li><li> <p>接口就是规范，定义的是一组规则，\"你是什么…必须做什么…\"的思想。</p> </li><li> <p><strong>接口的本质是约束</strong>，就像人间法律一样，制定好大家都遵守。</p> <p>//interface接口,接口都要有继承类<br/> //实现类（implements 可以继承多个接口）<br/> //多继承，利用接口实现多继承<br/> public interface UserService {<!-- --><br/> //定义的属性都是常量,默认修饰 public static final<br/> public static final int AGE = 99; //一般不用<br/> //所有的定义的方法都是抽象的 默认public abstract<br/> public abstract void run();<br/> void add();<br/> void query();<br/> void delete();<br/> }</p> </li></ul>\n<p>注意点</p>\n<ul><li>接口没有构造方法，不能被实例化</li><li>实现类必须要重写接口中的方法</li><li>实现类（implements） 可以实现多个接口</li></ul>\n<h2><a id=\"_1555\"></a>内部类</h2>\n<ul><li>内部类就是在一个类的内部再定义一个类，比如A类中定义了一个B类，那么B就是A的内部类，而A相对B来说就是外部类 \n  <ol><li>成员内部类：<strong>可以操作外部类的私有属性及方法</strong></li><li>静态内部类：static修饰，不能访问外部类私有属性</li><li>局部内部类：外部类的方法里定义的类</li><li>匿名内部类：没有名字初始化类</li></ol> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083429180.png\"/></p>\n<hr/>\n<hr/>\n<h1><a id=\"_1570\"></a>异常</h1>\n<ul><li> <p>软件程序在运行过程中，经常可能遇到异常问题，异常英文(<strong>Exception</strong>)，意思是例外，这些例外情况需要我们写程序做出合理的处理，而不至于让程序崩溃。</p> </li><li> <p>异常指程序运行中出现的不期而至的各种状况：文件找不到，网络连接错误，非法参数等。</p> </li><li> <p>异常发生在程序运行期间，它影响了正常的执行流程。</p> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083507444.png\"/></p>\n<h2><a id=\"_1582\"></a>简单分类</h2>\n<ul><li><strong>检查型异常</strong>：最具代表性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如用户要打开一个不存在的文件时引发的异常，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常</strong>：是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时忽略。</li><li><strong>错误Error</strong>：错误不是异常，而是脱离程序员控制的问题。错误在代码经常被忽略。例如当栈溢出，一个异常就发生了，它们在编译也检查不到。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083535592.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083557330.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2021042708360855.png\"/></p>\n<h2><a id=\"_1593\"></a>异常处理机制</h2>\n<ul><li> <p><strong>抛出异常</strong></p> </li><li> <p><strong>捕获异常</strong></p> </li><li> <p>异常处理关键字：<strong>try、catch、finally、throw、throws</strong></p> <p>public static void main(String[] args) {<!-- --><br/> int a = 1;<br/> int b = 0;</p> <pre><code>try { //try监控区域\n    System.out.println(a/b);\n}catch (ArithmeticException e){ //catch 捕获异常\n    System.out.println(\"程序出现异常，变量b不能为0\");\n}catch (Exception e){\n    e.printStackTrace();\n}finally { //一定会执行，处理善后工作，如关闭资源\n    System.out.println(\"finally\");\n}\n\nif(b==0){ //抛出异常一般在方法中使用\n    throw new ArithmeticException(); //主动抛出异常\n}\n</code></pre> <p>}<br/> //Ctrl+Alt+T 快捷键插入 try-catch</p> </li></ul>\n<h2><a id=\"_1621\"></a>自定义异常</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083645704.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2021042708372149.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083725235.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210427083739287.png\"/><br/> 如果本篇文章对你有帮助，不妨点个赞再走吧！</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 1, "csharp": 1, "python": 1, "javascript": 1, "java": 0, "sql": 0, "php": 1, "time": "2022-08-31 08:24:42", "summary": "笔记参考来源狂神说视频本篇笔记有点长，可以根据目录定位，建议配合视频学习。预科什么是计算机名称：，全称电子计算机，俗称电脑。定义：能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。组成：由"}