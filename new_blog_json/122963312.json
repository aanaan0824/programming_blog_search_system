{"blogid": "122963312", "writerAge": "码龄12年", "writerBlogNum": "68", "writerCollect": "30", "writerComment": "27", "writerFan": "9", "writerGrade": "5级", "writerIntegral": "3140", "writerName": "龙井茶Sky", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122963312.jpg", "writerRankTotal": "7753", "writerRankWeekly": "55344", "writerThumb": "24", "writerVisitNum": "249833", "blog_read_count": "3864", "blog_time": "于 2022-02-16 16:11:02 发布", "blog_title": "C#之Func初学习", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>上午简单跟前同事聊了聊技术相关的东西，说到了委托</p>\n<p>最原始的都是用delegate event</p>\n<p>但是技术发展日新月异，这小哥就提到了Func&lt;T, TREsult&gt;</p>\n<p>之前也见过，但是几无了解，于是找度娘先科普一下。</p>\n<p>用T的好处就是适应Linq的使用，泛型，先定义个类型，具体啥类型，运行的时候才知道，这样就增加了程序的灵活性。</p>\n<p>Func&lt;T, TREsult&gt;</p>\n<p>参数说明，前面都是参数，最后一个T是返回类型，因为参数个数不固定，但是返回值只有一个，所以不用多想，也能知道最后一个是返回类型</p>\n<p>具体到Func呢，先来几句代码看看呗（我们还是以猫和老鼠委托事件举例）</p>\n<p>猫Cat类，以及猫来了委托事件</p>\n<pre><code class=\"language-cs\">    public class Cat\n    {\n\n        public Func&lt;Cat, string&gt; CatCome02;\n\n        public string Name;\n\n        public Page Page;\n\n        public Cat(string name, Page page)\n        {\n            Name = name;\n            Page = page;\n        }\n\n        public void Come()\n        {\n            Page.Response.Write(\"猫来了&lt;br/&gt;\");\n\n            if (CatCome02 != null)\n            {\n                CatCome02(this);\n            }\n        }\n\n    }</code></pre>\n<p> 老鼠Mouse类，包括具体实践方法老鼠跑路Run</p>\n<pre><code class=\"language-cs\">    public class Mouse\n    {\n        public string Name;\n        public Page Page;\n\n        public Mouse(string name, Page page)\n        {\n            Name = name;\n            Page = page;\n        }\n\n\n        public string Run02(Cat cat)\n        {\n            Page.Response.Write($\"{cat.Name}来了,{Name}快跑&lt;br/&gt;\");\n\n            return \"\";\n        }\n    }</code></pre>\n<p>具体调用，定义1只猫Tom和两只老鼠，然后猫来了，自动执行老鼠跑了</p>\n<pre><code class=\"language-cs\">        protected void Test()\n        {\n            Cat cat = new Cat(\"Tom\", this);\n            Mouse m1 = new Mouse(\"xx\", this);\n            Mouse m2 = new Mouse(\"yy\", this);\n\n            cat.CatCome02 += m1.Run02;\n            cat.CatCome02 += m2.Run02;\n\n            cat.Come();\n\n        }</code></pre>\n<p>这么看下来和delegate、event方式差不多，不过是简化了一些，而且类型更加灵活，不过这个必须有返回类型，delegate可以是void（那就用用Action吧哈哈）</p>\n<p>另外，方法里也可以传递Func，个人认为主要是为了解耦吧（类、程序集之间功能职责分离设计），比如我的A.dll就是很底层的dll，B是业务dll，但是我现在想在A某个逻辑里添加日志（不过A是很基础的dll，没有写日志这些功能），我为了不影响A的功能，那就可以通过Func来搞。</p>\n<p>A中只需要定义一个Func参数 （委托也可以，这里只是举例），然后在业务中具体实现写日志功能即可（这样A想咋写就写，写哪儿也行，和A没关系的）</p>\n<p>A底层dll，定义一个Func参数</p>\n<pre><code class=\"language-cs\">        public void ExecSomething(Func&lt;string, string&gt; logFunc)\n        {\n            //底层逻辑xxx\n            string info = \"\";\n\n            //记录日志\n            logFunc(info);\n        }</code></pre>\n<p>B具体记录日志方法实现（方法参数、返回值需要与A中Func参数一致）</p>\n<pre><code>        protected string Log(string info)\n        {\n            //用各种log插件\n            //写到数据库、txt文件我随意\n            return \"\";\n        }</code></pre>\n<p>具体调用，传递B中具体记录日志方法进去 </p>\n<pre><code>ExecSomething(Log);</code></pre>\n<p>今天分享就到这里。</p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-02-16 16:11:02", "summary": "上午简单跟前同事聊了聊技术相关的东西，说到了委托最原始的都是用但是技术发展日新月异，这小哥就提到了之前也见过，但是几无了解，于是找度娘先科普一下。用的好处就是适应的使用，泛型，先定义个类型，具体啥类型"}