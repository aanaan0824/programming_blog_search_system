{"blogid": "123346430", "writerAge": "码龄3年", "writerBlogNum": "422", "writerCollect": "5022", "writerComment": "928", "writerFan": "52830", "writerGrade": "6级", "writerIntegral": "8229", "writerName": "Resourceful!", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123346430.jpg", "writerRankTotal": "1521", "writerRankWeekly": "258", "writerThumb": "1727", "writerVisitNum": "636746", "blog_read_count": "6988", "blog_time": "已于 2022-08-15 15:13:03 修改", "blog_title": "2022 最新 Vue 3.0 面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atelier-sulphurpool-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>2022 最新 Vue 3.0 面试题</h3>\n<ul><li><a href=\"#1Vue__3\">1、Vue 的最大的优势是什么？（必会）</a></li><li><a href=\"#2Vue__jQuery__18\">2、Vue 和 jQuery 两者之间的区别是什么？（必会）</a></li><li><a href=\"#3MVVM__MVC__43\">3、MVVM 和 MVC 区别是什么？哪些场景适合？（必会）</a></li><li><a href=\"#4Vue__71\">4、Vue 数据双向绑定的原理是什么?（必会）</a></li><li><a href=\"#5ObjectdefineProperty__Proxy__90\">5、Object.defineProperty 和 Proxy 的区别（必会）</a></li><li><a href=\"#6Vue__104\">6、Vue 生命周期总共分为几个阶段？（必会）</a></li><li><a href=\"#7_141\">7、第一次加载页面会触发哪几个钩子函数？（必会）</a></li><li><a href=\"#8_Vue__145\">8、请说下封装 Vue 组件的过程？（必会）</a></li><li><a href=\"#9Vue___155\">9、Vue 组件如何进行传值的? （必会）</a></li><li><a href=\"#10_name__170\">10、组件中写 name 选项有什么作用？（必会）</a></li><li><a href=\"#11Vue__data__175\">11、Vue 组件 data 为什么必须是函数（必会）</a></li><li><a href=\"#12_183\">12、讲一下组件的命名规范（必会）</a></li><li><a href=\"#13_191\">13、怎么在组件中监听路由参数的变化？（必会）</a></li><li><a href=\"#14_Vue__204\">14、怎么捕获 Vue 组件的错误信息？（必会）</a></li><li><a href=\"#15Vue__210\">15、Vue 组件里的定时器要怎么销毁？（必会）</a></li><li><a href=\"#16Vuecli__220\">16、Vue-cli 用自定义的组件？有遇到过哪些问题吗？（必</a></li><li><a href=\"#17Vue__solt__solt__230\">17、Vue 中 solt 的使用方式，以及 solt 作用域插槽的用法</a></li><li><a href=\"#18Vue__239\">18、Vue 该如何实现组件缓存?（必会）</a></li><li><a href=\"#19_keepalive__252\">19、跟 keep-alive 有关的生命周期是哪些？（必会）</a></li><li><a href=\"#20Vue__273\">20、Vue 常用的修饰符都有哪些？（必会）</a></li><li><a href=\"#21Vue__279\">21、Vue 常用的指令都有哪些？并且说明其作用（必会）</a></li><li><a href=\"#22vcheckvfocus_300\">22、自定义指令(v-check、v-focus)的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</a></li><li><a href=\"#23_vel__307\">23、指令 v-el 的作用是什么?（必会）</a></li><li><a href=\"#24vshow__vif__311\">24、v-show 和 v-if 指令的共同点和不同点?（必会）</a></li><li><a href=\"#25_vif__vfor__336\">25、为什么避免 v-if 和 v-for 用在一起（必会）</a></li><li><a href=\"#26watchmethods__computed__395\">26、watch、methods 和 computed 的区别?（必会）</a></li><li><a href=\"#27_watch__423\">27、怎么在 watch 监听开始之后立即被调用？（必会）</a></li><li><a href=\"#28watch__426\">28、watch 怎么深度监听对象变化？（必会）</a></li><li><a href=\"#29computed__data___439\">29、computed 中的属性名和 data 中的属性名可以相同吗？ （必会）</a></li><li><a href=\"#30_Vue__448\">30、什么是 Vue 的计算属性（必会）</a></li><li><a href=\"#31Vue__key__458\">31、Vue 中 key 值的作用是什么？（必会）</a></li><li><a href=\"#32Vueloader__464\">32、Vue-loader 是什么？使用它的用途有哪些？（必会）</a></li><li><a href=\"#33Vue__497\">33、Vue 中怎么自定义过滤器（必会）</a></li><li><a href=\"#34_Vuex__507\">34、你是怎么认识 Vuex 的?（必会）</a></li><li><a href=\"#35Vuex__5__515\">35、Vuex 的 5 个核心属性是什么?（必会）</a></li><li><a href=\"#36Vuex__537\">36、Vuex 的出现解决了什么问题?（必会）</a></li><li><a href=\"#37_Vuex__544\">37、简述 Vuex 的数据传递流程（必会）</a></li><li><a href=\"#38Vuex__Mutation__Action__553\">38、Vuex 的 Mutation 和 Action 之间的区别是什么？（必</a></li><li><a href=\"#39Vuerouter__565\">39、Vue-router 是干什么的，原理是什么？（必会）</a></li><li><a href=\"#40_576\">40、路由之间是怎么跳转的？有哪些方式？（必会）</a></li><li><a href=\"#41Vuerouter__588\">41、Vue-router 怎么配置路由（必会）</a></li><li><a href=\"#42Vuerouter__616\">42、Vue-router 有哪几种路由守卫?（必会）</a></li><li><a href=\"#43Vuerouter__622\">43、Vue-router 的钩子函数都有哪些?（必会）</a></li><li><a href=\"#44_640\">44、路由传值的方式有哪几种(必会)</a></li><li><a href=\"#45_Vuerouter__655\">45、怎么定义 Vue-router 的动态路由?怎么获取传过来的动态参数?</a></li><li><a href=\"#46JQuery__params__667\">46、JQuery 和 params 之间的区别是什么？（必会）</a></li><li><a href=\"#47route_router__674\">47、<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n       \n        \n         \n          \n           r\n          \n          \n           o\n          \n          \n           u\n          \n          \n           t\n          \n          \n           e\n          \n          \n           和\n          \n         \n         \n          route 和\n         \n        \n       </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">和</span></span></span></span></span>router 的区别是什么？（必会）</a></li><li><a href=\"#48activeclass__680\">48、active-class 属于哪个组件中的属性？该如何使用？</a></li><li><a href=\"#49Vue_hash__history__733\">49、Vue 的路由实现模式：hash 模式和 history 模式（必</a></li><li><a href=\"#50_743\">50、请说出路由配置项常用的属性及作用（必会）</a></li><li><a href=\"#51_752\">51、编程式导航使用的方法以及常用的方法（必会）</a></li><li><a href=\"#52Vue__758\">52、Vue 怎么实现跨域（必会）</a></li><li><a href=\"#53Vue__781\">53、Vue 中动画如何实现（必会）</a></li><li><a href=\"#54_Vuejs__template__791\">54、你对 Vue.js 的 template 编译的理解？（必会）</a></li><li><a href=\"#55Vue__HTML__800\">55、Vue 渲染模板时怎么保留模板中的 HTML 注释呢？</a></li><li><a href=\"#56Vue20__IE__808\">56、Vue2.0 兼容 IE 哪个版本以上吗？（必会）</a></li><li><a href=\"#57Vue__URL__811\">57、Vue 如何去除 URL 中的#（必会）</a></li><li><a href=\"#58_Vue__819\">58、说一下你在 Vue 中踩过的坑（必会）</a></li><li><a href=\"#59_Vue__830\">59、在 Vue 中使用插件的步骤（必会）</a></li><li><a href=\"#60Vue__835\">60、Vue 项目优化的解决方案都有哪些？（必会）</a></li><li><a href=\"#61_Vue__845\">61、使用 Vue 的时候一下加载造成页面卡顿，该如何解决？</a></li><li><a href=\"#62_Vuecli__src__858\">62、请说出 Vue.cli 项目中 src 目录每个文件夹和文件的用</a></li><li><a href=\"#63_style__scoped__871\">63、你知道 style 上加 scoped 属性的原理吗？（必会）</a></li><li><a href=\"#64_SPA__902\">64、说说你对 SPA 单页面的理解，它的优缺点分别是什么？（必会）</a></li><li><a href=\"#65_Vue__926\">65、怎样理解 Vue 的单向数据流？（必会）</a></li><li><a href=\"#66VNone__DOM_940\">66、VNone 是什么？什么是虚拟 DOM？（高薪常问）</a></li><li><a href=\"#67Vue__DOM_967\">67、Vue 中如何实现一个虚拟 DOM？说说你的思路（高薪</a></li><li><a href=\"#68Vue__data__977\">68、Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法？（高薪常</a></li><li><a href=\"#69Vue__data__992\">69、Vue 中如何重置 data? （高薪常问）</a></li><li><a href=\"#70_Vue___1010\">70、如何对 Vue 首屏加载实现优化? （高薪常问）</a></li><li><a href=\"#71Vue__nextTick___1021\">71、Vue 的 nextTick 的原理是什么? （高薪常问）</a></li><li><a href=\"#72_Vue__hook__1035\">72、在 Vue 实例中编写生命周期 hook 或其他</a></li><li><a href=\"#73is__1044\">73、is 这个特性你有用过吗？主要用在哪些方面？（高薪常</a></li><li><a href=\"#74scss__Vuecli__1079\">74、scss 是什么？在 Vue-cli 中的安装使用步骤是？有哪几大特性？（高薪常问）</a></li><li><a href=\"#75_packagejson__1098\">75、请详细介绍一些 package.json 中的配置的作用（了解）</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"1Vue__3\"></a>1、Vue 的最大的优势是什么？（必会）</h1>\n<p>Vue 作为一款轻量级框架、简单易学、双向数据绑定、组件化、数据和结构的分离、虚拟<br/> DOM、运行速度快，并且作者是中国人尤雨溪，对应的 API 文档对国内开发者优化，作为前端<br/> 开发人员的首选入门框架<br/> Vue 的优势：<br/> 1、Vue.js 可以进行组件化开发，使代码编写量大大减少，读者更加易于理解。<br/> 2、Vue.js 最突出的优势在于可以对数据进行双向绑定。<br/> 3、使用 Vue.js 编写出来的界面效果本身就是响应式的，这使网页在各种设备上都能<br/> 显示出非常好看的效果。<br/> 4、相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页<br/> 面。<br/> 5、vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和<br/> dom，这样大大加快了访问速度和提升用户体验。<br/> 6、而且他的第三方 UI 组件库使用起来节省很多开发时间，从而提升开发效率。</p>\n<h1><a id=\"2Vue__jQuery__18\"></a>2、Vue 和 jQuery 两者之间的区别是什么？（必会）</h1>\n<p>1、jQuery 介绍：<br/> jQuery 曾经也是现在依然最流行的 web 前端 js 库，可是现在无论是国内还是国外他的使<br/> 用率正在渐渐被其他的 js 库所代替，随着浏览器厂商对 HTML5 规范统一遵循以及 ECMA6 在浏<br/> 览器端的实现，jQuery 的使用率将会越来越低<br/> 2、vue 介绍：<br/> vue 是一个兴起的前端 js 库，是一个精简的 MVVM。从技术角度讲，Vue.js 专注于 MVVM<br/> 模型的 ViewModel 层。它通过双向数据绑定把 View 层和 Model 层连接了起来，通过对数<br/> 据的操作就可以完成对页面视图的渲染。当然还有很多其他的 mvmm 框架如 Angular，react 都<br/> 是大同小异，本质上都是基于 MVVM 的理念，然而 vue 以他独特的优势简单，快速，组合，紧<br/> 凑，强大而迅速崛起<br/> 3、vue 和 jQuery 区别：<br/> 3.1）vue 和 jQuery 对比 jQuery 是使用选择器（）选取 DOM 对象，对其进行赋值、取<br/> 值、事件绑定等操作，其实和原生的 HTML 的区别只在于可以更方便的选取和操作 DOM 对<br/> 象，而数据和界面是在一起的</p>\n<p>3.2）比如需要获取 label 标签的内容：）选取 DOM 对象，对其进行赋值、取值、事件<br/> 绑定等操作，其实和原生的 HTML 的区别只在于可以更方便的选取和操作 DOM 对象，而数据<br/> 和界面是在一起的<br/> 3.3）比如需要获取 label 标签的内容：(“lable”).val();,它还是依赖 DOM 元素的值。<br/> Vue 则是通过 Vue 对象将数据和 View 完全分离开来了<br/> 3.4）对数据进行操作不再需要引用相应的 DOM 对象，可以说数据和 View 是分离的，<br/> 他们通过 Vue 对象这个 vm 实现相互的绑定，这就是传说中的 MVVM</p>\n<h1><a id=\"3MVVM__MVC__43\"></a>3、MVVM 和 MVC 区别是什么？哪些场景适合？（必会）</h1>\n<p>1、基本定义<br/> 1.1）MVVM 基本定义<br/> MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型，模型（Model）<br/> 指的是后端传递的数据，视图(View)指的是所看到的页面，视图模型(ViewModel)是 mvvm 模式<br/> 的核心，它是连接 view 和 model 的桥梁。它有两个方向：<br/> 1.1.1）一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到<br/> 的页面，实现的方式是：数据绑定，<br/> 1.1.2）二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。<br/> 实现的方式是：DOM 事件监听，这两个方向都实现的，我们称之为数据的双向绑定<br/> 1.2）MVC 基本定义<br/> MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V 指的意思和<br/> MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑，使用 MVC 的目的就是将<br/> M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启<br/> 下<br/> 2、使用场景<br/> 主要就是 MVC 中 Controller 演变成 MVVM 中的 viewModel，MVVM 主要解决了 MVC<br/> 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验，vue 数据驱动，通<br/> 过数据来显示视图层而不是节点操作， 场景：数据操作比较多的场景，需要大量操作 DOM 元<br/> 素时，采用 MVVM 的开发方式，会更加便捷，让开发者更多的精力放在数据的变化上，解放繁<br/> 琐的操作 DOM 元素<br/> 3、两者之间的区别<br/> MVC 和 MVVM 其实区别并不大，都是一种设计思想， MVC 和 MVVM 的区别并不是<br/> VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，<br/> ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图<br/> 操作业务等还是应该放在 Controller 中实现，也就是说 MVVM 实现的是业务逻辑组件的重用，<br/> 使开发更高效，结构更清晰，增加代码的复用性</p>\n<h1><a id=\"4Vue__71\"></a>4、Vue 数据双向绑定的原理是什么?（必会）</h1>\n<p>V ue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫<br/> 持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<p>1、需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和<br/> getter，这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化<br/> 2、compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将<br/> 每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更<br/> 新视图<br/> 3、Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:<br/> 3.1）在自身实例化时往属性订阅器(dep)里面添加自己<br/> 3.2）自身必须有一个 update()方法<br/> 3.3）待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile<br/> 中绑定的回调，则功成身退。<br/> 4、MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通 Observer<br/> 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起<br/> Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt;<br/> 数据 model 变更的双向绑定效果</p>\n<h1><a id=\"5ObjectdefineProperty__Proxy__90\"></a>5、Object.defineProperty 和 Proxy 的区别（必会）</h1>\n<p>Object.defineProperty 和 Proxy 的区别如下:<br/> 1、Proxy 可以直接监听对象而非属性；<br/> 2、Proxy 可以直接监听数组的变化；<br/> 3、Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等<br/> 是 Object.defineProperty 不具备的<br/> 4、Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而<br/> Object.defineProperty 只能遍历对象属性直接修改<br/> 5、Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准<br/> 的性能红利<br/> 6、Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,<br/> 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重<br/> 写</p>\n<h1><a id=\"6Vue__104\"></a>6、Vue 生命周期总共分为几个阶段？（必会）</h1>\n<p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模<br/> 板、挂载 Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。<br/> 1、beforeCreate<br/> 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调<br/> 用<br/> 2、created<br/> 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data<br/> observer)属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目<br/> 前不可见<br/> 3、beforeMount</p>\n<p>在挂载开始之前被调用：相关的 render 函数首次被调用<br/> 4、mounted<br/> el 被新创建的 vm.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        e\n       \n       \n        l\n       \n       \n        替换，并挂载到实例上去之后调用该钩子，如果\n       \n       \n        r\n       \n       \n        o\n       \n       \n        o\n       \n       \n        t\n       \n       \n        实例挂载了一个文档内元素，当\n       \n       \n        m\n       \n       \n        o\n       \n       \n        u\n       \n       \n        n\n       \n       \n        t\n       \n       \n        e\n       \n       \n        d\n       \n       \n        被调用时\n       \n       \n        v\n       \n       \n        m\n       \n       \n        .\n       \n      \n      \n       el 替换，并挂载到实例上去之后调用该钩子，如果 root 实例挂载了 一个文档内元素，当 mounted 被调用时 vm.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0197em;\">l</span><span class=\"mord cjk_fallback\">替换，并挂载到实例上去之后调用该钩子，如果</span><span class=\"mord mathnormal\">roo</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">实例挂载了一个文档内元素，当</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord cjk_fallback\">被调用时</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"mord mathnormal\">m</span><span class=\"mord\">.</span></span></span></span></span>el 也在文档内<br/> 5、beforeUpdate<br/> 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的<br/> DOM，比如手动移除已添加的事件监听器，该钩子在服务器端渲染期间不被调用，因为只有初<br/> 次渲染会在服务端进行<br/> 6、updated<br/> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子<br/> 7、activated<br/> keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用<br/> 8、deactivated<br/> keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用<br/> 9、beforeDestroy<br/> 实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被<br/> 调用<br/> 10、destroyed<br/> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件<br/> 监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用<br/> 11、errorCaptured（2.5.0+ 新增）<br/> 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生<br/> 错误的组件实例以及一个包含错误来源信息的字符串，此钩子可以返回 false 以阻止该错误继<br/> 续向上传播</p>\n<h1><a id=\"7_141\"></a>7、第一次加载页面会触发哪几个钩子函数？（必会）</h1>\n<p>当页面第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩<br/> 子函数</p>\n<h1><a id=\"8_Vue__145\"></a>8、请说下封装 Vue 组件的过程？（必会）</h1>\n<p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决<br/> 了我们传统项目开发：效率低、难维护、复用性等问题<br/> 1、分析需求：确定业务需求，把页面中可以服用的结构，样式以及功能，单独抽离成一<br/> 个文件，实现复用<br/> 2、具体步骤：使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组<br/> 件，子组件需要数据，可以在 props 中接受定义，而子组件修改好数据后，想把数据传递给父<br/> 组件，可以采用$emit 方法</p>\n<h1><a id=\"9Vue___155\"></a>9、Vue 组件如何进行传值的? （必会）</h1>\n<p>1、父组件向子组件传递数据<br/> 父组件内设置要传的数据，在父组件中引用的子组件上绑定一个自定义属性并把数据<br/> 绑定在自定义属性上，在子组件添加参数 props 接收即可<br/> 2、子组件向父组件传递数据<br/> 子组件通过 vue 实例方法<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        e\n       \n       \n        m\n       \n       \n        i\n       \n       \n        t\n       \n       \n        进行触发并且可以携带参数，父组件监听使用\n       \n       \n        @\n       \n       \n        （\n       \n       \n        v\n       \n       \n        −\n       \n       \n        o\n       \n       \n        n\n       \n       \n        ）进行监听，然后进行方法处理\n       \n       \n        3\n       \n       \n        、非父子组件之间传递数据\n       \n       \n        3.1\n       \n       \n        引入第三方\n       \n       \n        n\n       \n       \n        e\n       \n       \n        w\n       \n       \n        v\n       \n       \n        u\n       \n       \n        e\n       \n       \n        定义为\n       \n       \n        e\n       \n       \n        v\n       \n       \n        e\n       \n       \n        n\n       \n       \n        t\n       \n       \n        B\n       \n       \n        u\n       \n       \n        s\n       \n       \n        3.2\n       \n       \n        ）在组件中\n       \n       \n        c\n       \n       \n        r\n       \n       \n        e\n       \n       \n        a\n       \n       \n        t\n       \n       \n        e\n       \n       \n        d\n       \n       \n        中订阅方法\n       \n       \n        e\n       \n       \n        v\n       \n       \n        e\n       \n       \n        n\n       \n       \n        t\n       \n       \n        B\n       \n       \n        u\n       \n       \n        s\n       \n       \n        .\n       \n      \n      \n       emit 进行触发并且可以携带参数，父组件监听使用@（v- on）进行监听，然后进行方法处理 3、非父子组件之间传递数据 3.1 引入第三方 new vue 定义为 eventBus 3.2）在组件中 created 中订阅方法 eventBus.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">mi</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">进行触发并且可以携带参数，父组件监听使用</span><span class=\"mord\">@</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord cjk_fallback\">）进行监听，然后进行方法处理</span><span class=\"mord\">3</span><span class=\"mord cjk_fallback\">、非父子组件之间传递数据</span><span class=\"mord\">3.1</span><span class=\"mord cjk_fallback\">引入第三方</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0269em;\">w</span><span class=\"mord mathnormal\">vu</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">定义为</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0502em;\">tB</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">3.2</span><span class=\"mord cjk_fallback\">）在组件中</span><span class=\"mord mathnormal\">cre</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord cjk_fallback\">中订阅方法</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0502em;\">tB</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span></span>on(“自定义事件名”,methods 中的方法<br/> 名)<br/> 3.3) 在另一个兄弟组件中的 methods 中写函数，在函数中发布 eventBus 订阅的方法<br/> eventBus.$emit(\"自定义事件名”)<br/> 3.4) 在组件的 template 中绑定事件(比如 click)</p>\n<h1><a id=\"10_name__170\"></a>10、组件中写 name 选项有什么作用？（必会）</h1>\n<p>1、项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤<br/> 2、DOM 做递归组件时需要调用自身 name<br/> 3、vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>\n<h1><a id=\"11Vue__data__175\"></a>11、Vue 组件 data 为什么必须是函数（必会）</h1>\n<p>1、个组件都是 Vue 的实例<br/> 2、组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他<br/> 3、组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就<br/> 会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护<br/> 各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变<br/> 了全都会变的结果</p>\n<h1><a id=\"12_183\"></a>12、讲一下组件的命名规范（必会）</h1>\n<p>给组件命名有两种方式，一种是使用链式命名 my-component，一种是使用大驼峰命名<br/> MyComponent 在字符串模板中 和<br/> 都可以使用，在非字符串模板中最好使用<br/> ，因为要遵循 W3C 规范中的自定义组件名 (字母全小写且<br/> 必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突</p>\n<h1><a id=\"13_191\"></a>13、怎么在组件中监听路由参数的变化？（必会）</h1>\n<p>有两种方法可以监听路由参数的变化，但是只能用在包含的组件内。<br/> 第一种<br/> watch: {<!-- --><br/> ‘$route’(to, from) {<!-- --><br/> // 在此处监听<br/> },<br/> },<br/> 第二种<br/> beforeRouteUpdate (to, from, next) {<!-- --><br/> //这里监听<br/> }</p>\n<h1><a id=\"14_Vue__204\"></a>14、怎么捕获 Vue 组件的错误信息？（必会）</h1>\n<p>1、errorCaptured 是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收<br/> error、vm、info 三个参数，return false 后可以阻止错误继续向上抛出<br/> 2、errorHandler 为全局钩子，使用 Vue.config.errorHandler 配置，接收参数与<br/> errorCaptured 一致，2.6 后可捕捉 v-on 与 promise 链的错误，可用于统一错误处理与错误兜底</p>\n<h1><a id=\"15Vue__210\"></a>15、Vue 组件里的定时器要怎么销毁？（必会）</h1>\n<p>如果页面上有很多定时器，可以在 data 选项中创建一个对象 timer，给每个定时器取个名<br/> 字一一映射在对象 timer 中， 在 beforeDestroy 构造函数中 for(let k in<br/> this.timer){clearInterval(k)}；<br/> 如果页面只有单个定时器，可以这么做<br/> const timer = setInterval(() =&gt;{}, 500);<br/> this.$once(‘hook:beforeDestroy’, () =&gt; {<!-- --><br/> clearInterval(timer);<br/> })</p>\n<h1><a id=\"16Vuecli__220\"></a>16、Vue-cli 用自定义的组件？有遇到过哪些问题吗？（必</h1>\n<p>会）<br/> 1、在 components 目录新建你的组件文件（indexPage.vue），script 一定要 export default<br/> {}<br/> 2、在需要用的页面（组件）中导入：import indexPage from<br/> ‘@/components/indexPage.vue’</p>\n<p>3、注入到 vue 的子组件的 components 属性上面,components:{indexPage}<br/> 4、在 template 视图 view 中使用，例如有 indexPage 命名，使用的时候则 index-page</p>\n<h1><a id=\"17Vue__solt__solt__230\"></a>17、Vue 中 solt 的使用方式，以及 solt 作用域插槽的用法</h1>\n<p>（必会）<br/> 使用方式<br/> 当组件当做标签进行使用的时候，用 slot 可以用来接受组件标签包裹的内容，当给<br/> solt 标签添加 name 属性的 时候，可以调换响应的位置<br/> 插槽作用域<br/> 作用域插槽其实就是带数据的插槽，父组件接收来自子组件的 slot 标签上通过 v-bind<br/> 绑定进而传递过来的数 据，父组件通过 scope 来进行接受子组件传递过来的数据</p>\n<h1><a id=\"18Vue__239\"></a>18、Vue 该如何实现组件缓存?（必会）</h1>\n<p>在面向组件化开发中，我们会把整个项目拆分为很多业务组件，然后按照合理的方式组<br/> 织起来，那么自然会存在组件之前切换的问题，vue 中有个动态组件的概念，它能够帮助开发<br/> 者更好的实现组件之间的切换，但是在面对需求频繁的变化，去要切换组件时，动态组件在切<br/> 换的过程中，组件的实例都是重新创建的，而我们需要保留组件的状态，为了解决这个问题，<br/> 需要使用到 vue 中内置组件<br/> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组<br/> 件状态或避免重新渲染，<br/> 简答的说: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打<br/> 开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不<br/> 是重新渲染</p>\n<h1><a id=\"19_keepalive__252\"></a>19、跟 keep-alive 有关的生命周期是哪些？（必会）</h1>\n<p>1、前言：在开发 Vue 项目的时候，大部分组件是没必要多次渲染的，所以 Vue 提供了一<br/> 个内置组件 keep-alive 来缓存组件内部状态，避免重新渲染，在开发 Vue 项目的时候，大部分<br/> 组件是没必要多次渲染的，所以 Vue 提供了一个内置组件 keep-alive 来缓存组件内部状态，避<br/> 免重新渲染<br/> 2、生命周期函数：在被 keep-alive 包含的组件/路由中，会多出两个生命周期的钩<br/> 子:activated 与 deactivated。<br/> 2.1）activated 钩子：在在组件第一次渲染时会被调用，之后在每次缓存组件被激活<br/> 时调用。<br/> 2.2）Activated 钩子调用时机： 第一次进入缓存路由/组件，在 mounted 后面，<br/> beforeRouteEnter 守卫传给 next 的回调函数之前调用，并且给因为组件被缓存了，再次进入<br/> 缓存路由、组件时，不会触发这些钩子函数，beforeCreate created beforeMount mounted 都<br/> 不会触发</p>\n<p>2.3）deactivated 钩子：组件被停用（离开路由）时调用：deactivated 钩子调用时<br/> 机：使用 keep-alive 就不会调用 beforeDestroy(组件销毁前钩子)和 destroyed(组件销毁)，因为<br/> 组件没被销毁，被缓存起来了，这个钩子可以看作 beforeDestroy 的替代，如果你缓存了组<br/> 件，要在组件销毁的的时候做一些事情，可以放在这个钩子里，组件内的离开当前路由钩子<br/> beforeRouteLeave =&gt; 路由前置守卫 beforeEach =&gt;全局后置钩子 afterEach =&gt; deactivated<br/> 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由)</p>\n<h1><a id=\"20Vue__273\"></a>20、Vue 常用的修饰符都有哪些？（必会）</h1>\n<p>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本<br/> 身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</p>\n<h1><a id=\"21Vue__279\"></a>21、Vue 常用的指令都有哪些？并且说明其作用（必会）</h1>\n<p>1、v-model 多用于表单元素实现双向数据绑定（同 angular 中的 ng-model）<br/> 2、v-for 格式： v-for=“字段名 in(of) 数组 json” 循环数组或 json(同 angular 中的 ng-<br/> repeat),需要注意从 vue2 开始取消了$index<br/> 3、v-show 显示内容 （同 angular 中的 ng-show）<br/> 4、v-hide 隐藏内容（同 angular 中的 ng-hide）<br/> 5、v-if 显示与隐藏 （dom 元素的删除添加 同 angular 中的 ng-if 默认值为 false）v-<br/> else-if 必须和 v-if 连用 v-else 必须和 v-if 连用 不能单独使用 否则报错 模板编译错误<br/> 6、v-bind 动态绑定 作用： 及时对页面的数据进行更改<br/> 7、v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在<br/> methods 里面<br/> 8、v-text 解析文本<br/> 9、v-html 解析 html 标签<br/> 10、v-bind:class 三种绑定方法 1、对象型 ‘{red:isred}’ 2、三元型 ‘isred?“red”:“blue”’ 3、<br/> 数组型 ‘[{red:“isred”},{blue:“isblue”}]’<br/> 11、v-once 进入页面时 只渲染一次 不在进行渲染<br/> 12、v-cloak 防止闪烁<br/> 13、v-pre 把标签内部的元素原位输出</p>\n<h1><a id=\"22vcheckvfocus_300\"></a>22、自定义指令(v-check、v-focus)的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</h1>\n<p>1、全局定义指令：在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另外<br/> 一个是函数。<br/> 2、组件内定义指令：directives：钩子函数：bind(绑定事件触发)、inserted(节点插入的时<br/> 候触发)、update(组件内相关更新)钩子函数参数：el、binding</p>\n<h1><a id=\"23_vel__307\"></a>23、指令 v-el 的作用是什么?（必会）</h1>\n<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，<br/> 也可以是一个 HTMLElement 实例</p>\n<h1><a id=\"24vshow__vif__311\"></a>24、v-show 和 v-if 指令的共同点和不同点?（必会）</h1>\n<p>1、相同点：<br/> v-show 和 v-if 都能控制元素的显示和隐藏。<br/> 2、不同点：<br/> 2.1）实现本质方法不同<br/> v-show 本质就是通过设置 css 中的 display 设置为 none，控制隐藏<br/> v-if 是动态的向 DOM 树内添加或者删除 DOM 元素<br/> 2.2）编译的区别<br/> v-show 其实就是在控制 css<br/> v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件<br/> 监听和子组件<br/> 2.3）编译的条件<br/> v-show 都会编译，初始值为 false，只是将 display 设为 none，但它也编译了<br/> v-if 初始值为 false，就不会编译了<br/> 2.4）性能比较<br/> v-show 只编译一次，后面其实就是控制 css，而 v-if 不停的销毁和创建，故 v-<br/> show 性能更好一。<br/> 3、注意点：<br/> 因为 v-show 实际是操作 display:\" \"或者 none，当 css 本身有 display：none 时，v-<br/> show 无法让显示<br/> 4、总结（适用场景）：<br/> 如果要频繁切换某节点时，使用 v-show（无论 true 或者 false 初始都会进行渲染，此<br/> 后通过 css 来控制显示隐藏，因此切换开销比较小，初始开销较大），如果不需要频繁切换某<br/> 节点时，使用 v-if（因为懒加载，初始为 false 时，不会渲染，但是因为它是通过添加和删除<br/> dom 元素来控制显示和隐藏的，因此初始渲染开销较小，切换开销比较大）</p>\n<h1><a id=\"25_vif__vfor__336\"></a>25、为什么避免 v-if 和 v-for 用在一起（必会）</h1>\n<p>vue2.x 中v-for优先级高于v-if，vue3.x 相反。所以2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用，造成性能浪费；3.x 版本中 v-if 总是优先于 v-for 生效，导致v-if访问不了v-for中的变量。</p>\n<p>扩展;<br/> 一般我们在两种常见的情况下会倾向于这样做：</p>\n<p>为了过滤一个列表中的项目 (比如 v-for=“user in users” v-if=“user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</p>\n<p>为了避免渲染本应该被隐藏的列表 (比如 v-for=“user in users” v-if=“shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。</p>\n<p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，所以这个模板：</p>\n<pre><code>&lt;ul&gt;\n  &lt;li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  &gt;\n    {<!-- -->{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>将会经过如下运算：</p>\n<pre><code>this.users.map(function (user) {\n  if (user.isActive) {\n    return user.name\n  }\n})\n</code></pre>\n<p>因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。</p>\n<p>通过将其更换为在如下的一个计算属性上遍历：</p>\n<pre><code>computed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}\n\n&lt;ul&gt;\n  &lt;li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  &gt;\n    {<!-- -->{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>我们将会获得如下好处：</p>\n<p>过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。<br/> 使用 v-for=“user in activeUsers” 之后，我们在渲染的时候只遍历活跃用户，渲染更高效。<br/> 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。</p>\n<h1><a id=\"26watchmethods__computed__395\"></a>26、watch、methods 和 computed 的区别?（必会）</h1>\n<p>1、基本说明<br/> 1.1)computed：<br/> 计算属性将被混入到 Vue 实例中,所有 getter 和 setter 的 this 上下文自动地绑<br/> 定为 Vue 实例<br/> 1.2)methods：<br/> methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者<br/> 在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。<br/> 1.3)watch：<br/> 观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式，值是对<br/> 应回调函数,值也可以是方法名，或者包含选项的对象，Vue 实例将会在实例化时调,$watch()，<br/> 遍历 watch 对象的每一个属性<br/> 2、三者的加载顺序<br/> 2.1)computed 是在 HTML DOM 加载后马上执行的，如赋值；（属性将被混入到 Vue 实<br/> 例）<br/> 2.2)methods 则必须要有一定的触发条件才能执行，如点击事件，watch 呢？它用于观<br/> 察 Vue 实例上的数据变动，<br/> 2.3）默认加载的时候<br/> 先 computed 再 watch，不执行 methods；<br/> 2.4）触发某一事件后<br/> 先 computed 再 methods 再到 watch，computed 属性 vs method 方，<br/> computed 计算属性是基于它们的依赖进行缓存的<br/> 3、总结<br/> 计算属性 computed 只有在它的相关依赖发生改变时才会重新求值，当有一个性能开<br/> 销比较大的的计算属性 A ，它需要遍历一个极大的数组和做大量的计算，然后我们可能有其<br/> 他的计算属性依赖于 A ，这时候，我们就需要缓存，每次确实需要重新加载，不需要缓存时<br/> 用 methods</p>\n<h1><a id=\"27_watch__423\"></a>27、怎么在 watch 监听开始之后立即被调用？（必会）</h1>\n<p>在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调</p>\n<h1><a id=\"28watch__426\"></a>28、watch 怎么深度监听对象变化？（必会）</h1>\n<p>1、有个原则监听谁,写谁的名字,然后是对应的执行函数, 第一个参数为最新的改变值,第二<br/> 个值为上一次改变的值, 注意: 除了监听 data,也可以监听计算属性 或者一个 函数的计算结果<br/> 2、启用深度监听对象<br/> watch:{<!-- --><br/> a:{<!-- --><br/> handler:function(val,oldval){<!-- --></p>\n<p>},<br/> deep:true<br/> }<br/> }</p>\n<h1><a id=\"29computed__data___439\"></a>29、computed 中的属性名和 data 中的属性名可以相同吗？ （必会）</h1>\n<p>不能同名，因为不管是 computed 属性名还是 data 数据名还是 props 数据名都会被挂载在<br/> vm 实例上，因此这三个都不能同名<br/> if (key in vm.<span class=\"katex--inline\">KaTeX parse error: Expected '}', got 'EOF' at end of input: …uted property \"</span>{key}\" is already defined in data.<code>, vm) } else if (vm.$options.props &amp;&amp; key in vm.$options.props) { warn(</code>The computed property “${key}” is already defined as a prop.`, vm)<br/> }</p>\n<h1><a id=\"30_Vue__448\"></a>30、什么是 Vue 的计算属性（必会）</h1>\n<p>在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可<br/> 能多次使用的情况下，尽量采取计算属性的方式，好处：使得数据处理结构清晰；<br/> 依赖于数据，数据更新，处理结果自动更新；<br/> 1、计算属性内部 this 指向 vm 实例<br/> 2、在 template 调用时，直接写计算属性名即可<br/> 3、常用的是 getter 方法，获取数据，也可以使用 set 方法改变数据<br/> 4、相较于 methods，不管依赖的数据变不变，methods 都会重新计算，但是依赖数据不<br/> 变的时候 computed 从缓存中获取，不会重新计算</p>\n<h1><a id=\"31Vue__key__458\"></a>31、Vue 中 key 值的作用是什么？（必会）</h1>\n<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果<br/> 数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处<br/> 每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，key 的作用主要是为了高效<br/> 的更新虚拟 DOM</p>\n<h1><a id=\"32Vueloader__464\"></a>32、Vue-loader 是什么？使用它的用途有哪些？（必会）</h1>\n<p>vue-loader 会解析文件，提取出每个语言块，如果有必要会通过其他 loader 处理，最后将<br/> 他们组装成一个 commonjs 模块；module.exports 出一个 vue.js 组件对象<br/> 1、&lt; temlate&gt;语言块<br/> 1,1）默认语言：html<br/> 1,2）每个.vue 文件最多包含一个&lt; template&gt;块</p>\n<p>1,3）内容将被提取为字符串，将编译用作 VUE 组件的 template 选项<br/> 2、&lt; script&gt;<br/> 2,1）默认语言：JS（在监测到 babel-loader 或者 buble-loader 配置时，自动支持<br/> ES2015）<br/> 2,2）每个.vue 文件最多包含一个&lt; script&gt;块<br/> 2,3）该脚本在类 CommonJS 环境中执行（就像通过 webpack 打包的正常 JS 模块）。所以<br/> 你可以 require()其他依赖。在 ES2015 支持下，也可以使用 import 跟 export 语法<br/> 2,4）脚本必须导出 Vue.js 组件对象，也可以导出由 VUE.extend()创建的扩展对象；但是普<br/> 通对象是更好的选择<br/> 3、&lt; style&gt;<br/> 默认语言：css<br/> 3,1）一个.vue 文件可以包含多个&lt; style&gt;标签<br/> 3,2）这个标签可以有 scoped 或者 module 属性来帮助你讲样式封装到当前组件；具有不<br/> 同封装模式的多个&lt; style&gt;标签可以在同一个组件中混合使用<br/> 3,3）默认情况下，可以使用 style-loader 提取内容，并且通过&lt; style&gt;标签动态假如文档<br/> 的&lt; head&gt;中，也可以配置 webpack 将所有的 styles 提取到单个 CSS 文件中<br/> 4、自定义块<br/> 可以在.vue 文件中添加额外的自定义块来实现项目的特殊需求；例如&lt; docs&gt;块；vue-<br/> loader 将会使用标签名来查找对应的 webpack loaders 来应用到对应的模块上；webpack 需要<br/> 在 vue-loader 的选项 loaders 中指定<br/> vue-loader 支持使用非默认语言，比如 CSS 预处理器，预编译的 HTML 模板语言，通过设置语<br/> 言块的 lang 属性：</p>\n<h1><a id=\"33Vue__497\"></a>33、Vue 中怎么自定义过滤器（必会）</h1>\n<p>Vue.js 允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<br/> 双花括号插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符<br/> 号指示<br/> 可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤<br/> 器函数。过滤器函数以值为参数，返回转换后的值<br/> Vue .filter( ‘reverse’ , function (value) { return value.split( ‘’ ).reverse().join( ‘’ ) })<br/> <br/> 过滤器也同样接受全局注册和局部注册</p>\n<h1><a id=\"34_Vuex__507\"></a>34、你是怎么认识 Vuex 的?（必会）</h1>\n<p>vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等，通过状<br/> 态(数据源)集中管理驱动组件的变化(好比 spring 的 IOC 容器对 bean 进行集中管理)<br/> 1、应用级的状态集中放在 store 中</p>\n<p>2、改变状态的方式是提交 mutations，这是个同步的事物<br/> 3、异步逻辑应该封装在 action 中</p>\n<h1><a id=\"35Vuex__5__515\"></a>35、Vuex 的 5 个核心属性是什么?（必会）</h1>\n<p>分别是 State、 Getter、Mutation 、Action、 Module<br/> 1、state<br/> state 为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符串等等，<br/> 只有在这里定义了，在 vue.js 的组件中才能获取你定义的这个对象的状态<br/> 2、getter<br/> getter 有点类似 vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，<br/> 那么我们就需要使用 getter，getter 会接收 state 作为第一个参数，而且 getter 的返回值会<br/> 根据它的依赖被缓存起来，只有 getter 中的依赖值（state 中的某个需要派生状态的值）发<br/> 生改变的时候才会被重新计算<br/> 3、mutation<br/> 更改 store 中 state 状态的唯一方法就是提交 mutation，就很类似事件。每个 mutation<br/> 都有一个字符串类型的事件类型和一个回调函数，我们需要改变 state 的值就要在回调函<br/> 数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法<br/> store.commit<br/> 4、action<br/> action 可以提交 mutation，在 action 中可以执行 store.commit，而且 action 中可以有<br/> 任何的异步操作。在页面中如果我们要嗲用这个 action，则需要执行 store.dispatch<br/> 5、module<br/> module 其实只是解决了当 state 中很复杂臃肿的时候，module 可以将 store 分割成<br/> 模块，每个模块中拥有自己的 state、mutation、action 和 getter</p>\n<h1><a id=\"36Vuex__537\"></a>36、Vuex 的出现解决了什么问题?（必会）</h1>\n<p>主要解决了以下两个问题<br/> 1、多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄<br/> 弟组件间的状态传递无能为力<br/> 2、来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来<br/> 变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码</p>\n<h1><a id=\"37_Vuex__544\"></a>37、简述 Vuex 的数据传递流程（必会）</h1>\n<p>当组件进行数据修改的时候我们需要调用 dispatch 来触发 actions 里面的方法。actions 里<br/> 面的每个方法中都会 有一个<br/> 1、commit 方法，当方法执行的时候会通过 commit 来触 mutations 里面的方法进行数据<br/> 的修改<br/> 2、mutations 里面的每个函数都会有一个 state 参数，这样就可以在 mutations 里面进行<br/> state 的数据修改 ，当数据修改完毕后，会传导给页面，页面的数据也会发生改变</p>\n<h1><a id=\"38Vuex__Mutation__Action__553\"></a>38、Vuex 的 Mutation 和 Action 之间的区别是什么？（必</h1>\n<p>会）<br/> 1、流程顺序<br/> “相应视图—&gt;修改 State”拆分成两部分，视图触发 Action，Action 再触发 Mutation<br/> 2、角色定位<br/> 基于流程顺序，二者扮演不同的角色<br/> 1）Mutation：专注于修改 State，理论上是修改 State 的唯一途径<br/> 2）Action：业务代码、异步请求<br/> 3、限制<br/> 1）角色不同，二者有不同的限制<br/> 2）Mutation：必须同步执行<br/> 3）Action：可以异步，但不能直接操作 State</p>\n<h1><a id=\"39Vuerouter__565\"></a>39、Vue-router 是干什么的，原理是什么？（必会）</h1>\n<p>Vue-router 是 Vue.js 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页<br/> 面应用，vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映<br/> 射起来，传统的页面应用，是用一些超链接来实现页面切换和跳转的，在 vue-router 单页面应<br/> 用中，则是路径之间的切换，也就是组件的切换，路由模块的本质 就是建立起 url 和页面之间<br/> 的映射关系<br/> “更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功<br/> 能的实现主要有两种方式：<br/> 1、利用 URL 中的 hash（“#”）<br/> 2、利用 History interface 在 HTML5 中新增的方法</p>\n<h1><a id=\"40_576\"></a>40、路由之间是怎么跳转的？有哪些方式？（必会）</h1>\n<pre><code>1、&lt;router-link to=\"需要跳转到页面的路径\"&gt;\n2、this.$router.push()跳转到指定的 url，并在 history 中添加记录，点击回退返回到上一个\n页面\n3、this.$router.replace()跳转到指定的 url，但是 history 中不会添加记录，点击回退到上上\n个页面\n4、this.$touter.go(n)向前或者后跳转 n 个页面，n 可以是正数也可以是负数\n\n</code></pre>\n<h1><a id=\"41Vuerouter__588\"></a>41、Vue-router 怎么配置路由（必会）</h1>\n<p>在 vue 中配置路由分为 5 个步骤，分别是：</p>\n<p>1、安装<br/> npm install --save vue-router<br/> 2、引用<br/> import VueRouter from ‘vue-router’<br/> 3、配置路由文件<br/> var router = new VueRouter({<!-- --><br/> routes:[<br/> {<!-- --><br/> path:“/hello”,<br/> component:HelloWorld<br/> },<br/> {<!-- --><br/> path:“/wen”,<br/> component:HelloWen<br/> new Vue({<!-- --><br/> el: ‘#app’,<br/> components: { App },<br/> router,<br/> template: ‘’<br/> })<br/> 4、视图加载的位置<br/> 默认 App.vue 文件中加<br/> 5、跳转导航<br/> helloword（渲染出来的是 a 标签）</p>\n<h1><a id=\"42Vuerouter__616\"></a>42、Vue-router 有哪几种路由守卫?（必会）</h1>\n<p>1、路由守卫为<br/> 2、全局守卫：beforeEach<br/> 3、后置守卫：afterEach<br/> 4、全局解析守卫：beforeResolve<br/> 5、路由独享守卫：beforeEnter</p>\n<h1><a id=\"43Vuerouter__622\"></a>43、Vue-router 的钩子函数都有哪些?（必会）</h1>\n<p>关于 vue-router 中的钩子函数主要分为 3 类<br/> 1、全局钩子函数要包含 beforeEach<br/> 1,1）beforeEach 函数有三个参数,分别是<br/> 1,2）to:router 即将进入的路由对象<br/> 1,3）from:当前导航即将离开的路由<br/> 1,4）next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是<br/> confirmed （确认的）否则为 false,终止导航</p>\n<p>2、单独路由独享组件<br/> 2,1）beforeEnter<br/> 3、组件内钩子<br/> 3,1）beforeRouterEnter<br/> 3,2）beforeRouterUpdate<br/> 3,3）beforeRouterLeave</p>\n<h1><a id=\"44_640\"></a>44、路由传值的方式有哪几种(必会)</h1>\n<p>Vue-router 传参可以分为两大类，分别是编程式的导航 router.push 和声明式的导航<br/> 1、router.push<br/> 1.1）字符串：直接传递路由地址，但是不能传递参数<br/> this.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        .\n       \n       \n        p\n       \n       \n        u\n       \n       \n        s\n       \n       \n        h\n       \n       \n        (\n       \n       \n        \"\n       \n       \n        h\n       \n       \n        o\n       \n       \n        m\n       \n       \n        e\n       \n       \n        \"\n       \n       \n        )\n       \n       \n        对象：\n       \n       \n        1.2\n       \n       \n        ）命名路由这种方式传递参数，目标页面刷新会报错\n       \n       \n        t\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        .\n       \n      \n      \n       router.push(\"home\") 对象： 1.2）命名路由 这种方式传递参数，目标页面刷新会报错 this.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord\">\"</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mord\">\"</span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">对象：</span><span class=\"mord\">1.2</span><span class=\"mord cjk_fallback\">）命名路由这种方式传递参数，目标页面刷新会报错</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span></span>router.push({name:“news”,params:{userId:123})<br/> 1.3）查询参数 和 name 配对的式 params，和 path 配对的是 query<br/> this.<span class=\"katex--inline\">KaTeX parse error: Expected '}', got 'EOF' at end of input: … 1.4）接收参数 this.</span>route.query<br/> 2、声明式导航<br/> 2.1）字符串 &lt;router-link to:“news”&gt;<br/> 2.2）命名路由 &lt;router-link :to:“{name:‘news’,params:{userid:1111}}”&gt;<br/> 2.3）查询参数 </p>\n<h1><a id=\"45_Vuerouter__655\"></a>45、怎么定义 Vue-router 的动态路由?怎么获取传过来的动态参数?</h1>\n<p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件，例如，我们有一个<br/> User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染，那么，我们可以在<br/> vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果<br/> 1、动态路径参数，使用“冒号”开头，一个路径参数，使用冒号标记，当匹配到一个路<br/> 由时，参数会被设置到 this.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        .\n       \n       \n        p\n       \n       \n        a\n       \n       \n        r\n       \n       \n        a\n       \n       \n        m\n       \n       \n        s\n       \n       \n        中，并且可以在每个组件中使用\n       \n       \n        2\n       \n       \n        、现在我们知道了可以通过动态路由传参，在路由中设置了，多段路径参数后，对应的值分别都会设置到\n       \n      \n      \n       router.params 中，并且可以在每个组件中使用 2、现在我们知道了可以通过动态路由传参，在路由中设置了，多段路径参数后，对应的 值分别都会设置到\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8778em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">r</span><span class=\"mord mathnormal\">am</span><span class=\"mord mathnormal\">s</span><span class=\"mord cjk_fallback\">中，并且可以在每个组件中使用</span><span class=\"mord\">2</span><span class=\"mord cjk_fallback\">、现在我们知道了可以通过动态路由传参，在路由中设置了，多段路径参数后，对应的值分别都会设置到</span></span></span></span></span>router.query 和$router.params 中</p>\n<h1><a id=\"46JQuery__params__667\"></a>46、JQuery 和 params 之间的区别是什么？（必会）</h1>\n<p>1、query 要用 path 来引入，params 要用 name 来引入<br/> 2、接收参数时，分别是 this.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        .\n       \n       \n        q\n       \n       \n        u\n       \n       \n        e\n       \n       \n        r\n       \n       \n        y\n       \n       \n        .\n       \n       \n        n\n       \n       \n        a\n       \n       \n        m\n       \n       \n        e\n       \n       \n        和\n       \n       \n        t\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        .\n       \n      \n      \n       route.query.name 和 this.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">ery</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">nam</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">和</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span></span>route.params.name（注意：是<br/> <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        而不是\n       \n      \n      \n       route 而不是\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">而不是</span></span></span></span></span>router<br/> 3、query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，前者在浏览器的地址<br/> 栏中显示，params 不显示<br/> 4、params 传值一刷新就没了，query 传值刷新还存在</p>\n<h1><a id=\"47route_router__674\"></a>47、<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        和\n       \n      \n      \n       route 和\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">和</span></span></span></span></span>router 的区别是什么？（必会）</h1>\n<p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，<br/> name 等路由信息参数<br/> <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        为\n       \n       \n        V\n       \n       \n        u\n       \n       \n        e\n       \n       \n        R\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        t\n       \n       \n        o\n       \n       \n        r\n       \n       \n        y\n       \n       \n        对象，经常用的跳转链接就可以用\n       \n       \n        t\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        .\n       \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        .\n       \n       \n        p\n       \n       \n        u\n       \n       \n        s\n       \n       \n        h\n       \n       \n        会往\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        t\n       \n       \n        o\n       \n       \n        r\n       \n       \n        y\n       \n       \n        栈中添加一个新的记录。返回上一个\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        t\n       \n       \n        o\n       \n       \n        r\n       \n       \n        y\n       \n       \n        也是使用\n       \n      \n      \n       router 为 VueRouter 的实例，相当于一个全局的路由器对象，里面含有很多属性和子对 象，例如 history 对象，经常用的跳转链接就可以用 this.router.push 会往 history 栈中添加一个 新的记录。返回上一个 history 也是使用\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">V</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0077em;\">R</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord cjk_fallback\">的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">ory</span><span class=\"mord cjk_fallback\">对象，经常用的跳转链接就可以用</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">h</span><span class=\"mord cjk_fallback\">会往</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">ory</span><span class=\"mord cjk_fallback\">栈中添加一个新的记录。返回上一个</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">ory</span><span class=\"mord cjk_fallback\">也是使用</span></span></span></span></span>router.go 方法</p>\n<h1><a id=\"48activeclass__680\"></a>48、active-class 属于哪个组件中的属性？该如何使用？</h1>\n<p>首先 active-class 是 vue-router 模块中 router-link 组件中的属性，主要作用是用来实现选<br/> 中样式的切换，在 vue-router 中要使用 active-class 有两种方式：<br/> 1、 在 router-link 中写入 active-class<br/> active-class 选择样式时根据路由中的路径（to=“/home”）去匹配，然后显示<br/> 首页<br/> 2、直接在路由 js 文件中配置 linkActiveClass<br/> export default new Router({<!-- --><br/> linkActiveClass: ‘active’,<br/> })</p>\n<pre><code class=\"prism language-java\">\n\n<span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"menu-btn\"</span><span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>link <span class=\"token keyword\">to</span><span class=\"token operator\">=</span><span class=\"token string\">\"/\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"menu-home\"</span> active<span class=\"token operator\">-</span><span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"active\"</span><span class=\"token operator\">&gt;</span>\n首页\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>router<span class=\"token operator\">-</span>link <span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">&gt;</span>   \n\n<span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"menu-btn\"</span><span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>link <span class=\"token keyword\">to</span><span class=\"token operator\">=</span><span class=\"token string\">\"/my\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"menu-my\"</span> active<span class=\"token operator\">-</span><span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"active\"</span><span class=\"token operator\">&gt;</span>\n我的\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>router<span class=\"token operator\">-</span>link<span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">&gt;</span>\n</code></pre>\n<p>​</p>\n<p>​<br/> ​</p>\n<p>3、引起的问题<br/> 因为 to=“/” 引起的，active-class 选择样式时根据路由中的路径去匹配，然后显示，<br/> 例如在 my 页面中，路由为 localhost:8081/#/my，那么 to=“/”和 to=”/my\"都可以匹配到，所<br/> 有都会激活选中样式<br/> 4、解决方法<br/> 4,1）在 router-link 中写入 exact<br/> 首页&lt;/router-<br/> link&gt;<br/> 4,2）在路由中加入重定向</p>\n<pre><code class=\"prism language-java\">\n<span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>link <span class=\"token keyword\">to</span><span class=\"token operator\">=</span><span class=\"token string\">\"/\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"menu-home\"</span> active<span class=\"token operator\">-</span><span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"active\"</span> exact<span class=\"token operator\">&gt;</span>首页<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>router<span class=\"token operator\">-</span>link<span class=\"token operator\">&gt;</span>\n<span class=\"token punctuation\">{<!-- --></span>\npath<span class=\"token operator\">:</span> <span class=\"token char\">'/'</span><span class=\"token punctuation\">,</span>\nredirect<span class=\"token operator\">:</span> <span class=\"token char\">'/home'</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h1><a id=\"49Vue_hash__history__733\"></a>49、Vue 的路由实现模式：hash 模式和 history 模式（必</h1>\n<p>会）<br/> 1、hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，<br/> 用 window.location.hash 读取。特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来<br/> 指导浏览器动作，对服务端安全无用，hash 不会重加载页面<br/> 2、history 模式：history 采用 HTML5 的新特性，且提供了两个新方法：<br/> 2.1）pushState()<br/> 2.2）replaceState()可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状<br/> 态变更</p>\n<h1><a id=\"50_743\"></a>50、请说出路由配置项常用的属性及作用（必会）</h1>\n<p>路由配置参数：<br/> 1、path : 跳转路径<br/> 2、component : 路径相对于的组件<br/> 3、name:命名路由<br/> 4、children:子路由的配置参数(路由嵌套)<br/> 5、props:路由解耦<br/> 6、redirect : 重定向路由</p>\n<h1><a id=\"51_752\"></a>51、编程式导航使用的方法以及常用的方法（必会）</h1>\n<p>1、路由跳转：this.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        .\n       \n       \n        p\n       \n       \n        u\n       \n       \n        s\n       \n       \n        h\n       \n       \n        (\n       \n       \n        )\n       \n       \n        2\n       \n       \n        、路由替换\n       \n       \n        :\n       \n       \n        t\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        .\n       \n      \n      \n       router.push() 2、路由替换: this.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span><span class=\"mord\">2</span><span class=\"mord cjk_fallback\">、路由替换</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span></span>router.replace()<br/> 3、后退： this.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        r\n       \n       \n        o\n       \n       \n        u\n       \n       \n        t\n       \n       \n        e\n       \n       \n        r\n       \n       \n        .\n       \n       \n        b\n       \n       \n        a\n       \n       \n        c\n       \n       \n        k\n       \n       \n        (\n       \n       \n        )\n       \n       \n        4\n       \n       \n        、前进：\n       \n       \n        t\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        .\n       \n      \n      \n       router.back() 4、前进 ：this.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">er</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">ba</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0315em;\">k</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span><span class=\"mord\">4</span><span class=\"mord cjk_fallback\">、前进：</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span></span>router.forward()</p>\n<h1><a id=\"52Vue__758\"></a>52、Vue 怎么实现跨域（必会）</h1>\n<p>1、什么是跨域<br/> 跨域指浏览器不允许当前页面的所在的源去请求另一个源的数据。源指协议，端<br/> 口，域名。只要这个 3 个中有一个不同就是跨域<br/> 2、使用 vue-cli 脚手架搭建项目时 proxyTable 解决跨域问题<br/> 打开 config/index.js,在 proxyTable 中添写如下代码：<br/> proxyTable: {<!-- --><br/> ‘/api’: { // 使用\"/api\"来代替\"http://f.apiplus.c\"<br/> target: ‘http://f.apiplus.cn’, //源地址<br/> changeOrigin: true, //改变源<br/> pathRewrite: {<!-- --><br/> ‘^/api’: ‘http://f.apiplus.cn’ //路径重写<br/> }<br/> 3、使用 CORS（跨域资源共享）<br/> 3.1）前端设置，vue 设置 axios 允许跨域携带 cookie（默认是不带 cookie）<br/> axios.defaults.withCredentials = true;<br/> 3,2）后端设置：<br/> 3.2.1）跨域请求后的响应头中需要设置<br/> 3.2.2）Access-Control-Allow-Origin 为发起请求的主机地址<br/> 3.2.3）Access-Control-Allow-Credentials，当它被设置为 true 时，允许跨域<br/> 带 cookie，但此时 Access-Control- Allow-Origin 不能为通配符*<br/> 3.2.4）Access-Control-Allow-Headers，设置跨域请求允许的请求头<br/> 3.2.5）Access-Control-Allow-Methods，设置跨域请求允许的请求方式</p>\n<h1><a id=\"53Vue__781\"></a>53、Vue 中动画如何实现（必会）</h1>\n<p>1、哪个元素需要动画就给那个元素加 transition 标签<br/> 2、进入时 class 的类型分为以下几种<br/> -enter -enter-active -enter-to<br/> 3、离开时 class 的类型分为以下几种<br/> -leave -leave-active -leave-to<br/> 如果需要一组元素发生动画需要用标签</p>\n<h1><a id=\"54_Vuejs__template__791\"></a>54、你对 Vue.js 的 template 编译的理解？（必会）</h1>\n<p>简而言之，就是先转化成 AST 树，再得到的 render 函数返回 Vnode（Vue 的虚拟 DOM 节<br/> 点）<br/> 1、首先通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree 即 源代<br/> 码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是<br/> 用以创建编译器的，另外 compile 还负责合并 option<br/> 2、然后 AST 会经过 generate（将 AST 语法树转化成 render funtion 字符串的过程）得到<br/> render 函数，render 的返回值是 Vnode，Vnode 是 Vue 的虚拟 DOM 节点，里面有（标签名、<br/> 子节点、文本等等）</p>\n<h1><a id=\"55Vue__HTML__800\"></a>55、Vue 渲染模板时怎么保留模板中的 HTML 注释呢？</h1>\n<p>（必会）<br/> 在组件中将 comments 选项设置为 true</p>\n<pre><code class=\"prism language-java\"><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>template comments<span class=\"token punctuation\">&gt;</span></span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>template<span class=\"token punctuation\">&gt;</span></span>\n</code></pre>\n<h1><a id=\"56Vue20__IE__808\"></a>56、Vue2.0 兼容 IE 哪个版本以上吗？（必会）</h1>\n<p>不支持 ie8 及以下，部分兼容 ie9 ，完全兼容 10 以上，因为 vue 的响应式原理是基于 es5<br/> 的 Object.defineProperty(),而这个方法不支持 ie8 及以下</p>\n<h1><a id=\"57Vue__URL__811\"></a>57、Vue 如何去除 URL 中的#（必会）</h1>\n<p>vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 URL 会自带 “#”，<br/> 如果不想使用 “#”， 可以使用 vue-router 的另一种模式 history：new Router ({ mode :<br/> ‘history’, routes: [ ]})<br/> 需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所<br/> 以在路由跳转的时候，就会出现访问不到静态资源而出现 “404” 的情况，这时候就需要服<br/> 务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一<br/> 个 “index.html” 页面</p>\n<h1><a id=\"58_Vue__819\"></a>58、说一下你在 Vue 中踩过的坑（必会）</h1>\n<p>1、第一个是给对象添加属性的时候，直接通过给 data 里面的对象添加属性然后赋值，新<br/> 添加的属性不是响应式的<br/> 1.1）解决办法：通过 Vue.set(对象，属性，值)这种方式就可以达到，对象新添加的属<br/> 性是响应式的<br/> 2、在 created 操作 dom 的时候，是报错的，获取不到 dom，这个时候实例 vue 实例没有挂<br/> 载<br/> 2.2）解决办法：通过：Vue.nextTick(回调函数进行获取)</p>\n<h1><a id=\"59_Vue__830\"></a>59、在 Vue 中使用插件的步骤（必会）</h1>\n<p>采用 ES6 的 import … from …语法或 CommonJS 的 require()方法引入插件<br/> 使用全局方法 Vue.use( plugin )使用插件,可以传入一个选项对象 Vue.use(MyPlugin,<br/> { someOption: true })</p>\n<h1><a id=\"60Vue__835\"></a>60、Vue 项目优化的解决方案都有哪些？（必会）</h1>\n<p>1、 使用 mini-css-extract-plugin 插件抽离 css<br/> 2、 配置 optimization 把公共的 js 代码抽离出来<br/> 3、 通过 webpack 处理文件压缩<br/> 4、 不打包框架、库文件，通过 cdn 的方式引入<br/> 5、 小图片使用 base64<br/> 6、 配置项目文件懒加载<br/> 7、 UI 库配置按需加载<br/> 8、 开启 Gzip 压缩</p>\n<h1><a id=\"61_Vue__845\"></a>61、使用 Vue 的时候一下加载造成页面卡顿，该如何解决？</h1>\n<p>（必会）<br/> vue-router 解决首次加载缓慢的问题。懒加载简单来说就是按需加载<br/> 1、像 vue 这种单页面应用，如果没有应用懒加载，运用 webpack 打包后的文件<br/> 将会异常的大，造成进入首页时， 需要加载的内容过多，时间过长，会出现长时间的白<br/> 屏，即使做了 loading 也是不利于用户体验，<br/> 2、而运用懒加载 则可以将页面进行划分，需要的时候加载页面，可以有效的分<br/> 担首页所承担的加载压力，减少首页加载用时。<br/> 3、用法：在配置路由时使用：component:resolve=&gt;require([“@components/路<br/> 由的路径”]，resolve)。 就是用了懒加载后打完包直接运行那个 index.html 会报错，报文<br/> 件引用错误其实是打包时候路径配置有点问 题，找到 build 下面的<br/> webpack.prod.conf.js 添加 publicPath：“./”,</p>\n<h1><a id=\"62_Vuecli__src__858\"></a>62、请说出 Vue.cli 项目中 src 目录每个文件夹和文件的用</h1>\n<p>法？（必会）<br/> 1、assets 文件夹是放静态资源<br/> 2、components 是放组件<br/> 3、router 是定义路由相关的配置<br/> 4、view 视图<br/> 5、app.vue 是一个应用主组件<br/> 6、main.js 是入口文件</p>\n<h1><a id=\"63_style__scoped__871\"></a>63、你知道 style 上加 scoped 属性的原理吗？（必会）</h1>\n<p>1、什么是 scoped<br/> 在 Vue 组件中，为了使样式私有化（模块化），不对全局造成污染，可以在 style 标<br/> 签上添加 scoped 属性以表示它的只属于当下的模块，局部有效。如果一个项目中的所有 vue<br/> 组件 style 标签全部加上了 scoped，相当于实现了样式的私有化。如果引用了第三方组件，需<br/> 要在当前组件中局部修改第三方组件的样式，而又不想去除 scoped 属性造成组件之间的样式<br/> 污染。此时只能通过穿透 scoped 的方式来解决，选择器。<br/> 2、scoped 的实现原理：<br/> Vue 中的 scoped 属性的效果主要通过 PostCSS 转译实现，如下是转译前的 Vue 代码：</p>\n<p>`</p>\n<div>\n Vue.js scoped\n</div>\n<p></p> ` \n<p>浏览器渲染后的代码：</p>\n<pre><code>\n&lt;div data-v-fed36922&gt;Vue.js scoped&lt;/div&gt;\n</code></pre>\n<p>.scoped[data-v-fed36922]{font-size:14px;}<br/> 即：PostCSS 给所有 dom 添加了一个唯一不重复的动态属性，然后，给 CSS 选择器额外添加一<br/> 个对应的属性选择器来选择该组件中 dom，这种做法使得样式私有化</p>\n<h1><a id=\"64_SPA__902\"></a>64、说说你对 SPA 单页面的理解，它的优缺点分别是什么？（必会）</h1>\n<p>单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用，它将<br/> 所有的活动局限于一个 Web 页面中，仅在该 Web 页面初始化时加载相应的 HTML、JavaScript<br/> 和 CSS，一旦页面加载完成了，SPA 不会因为用户的操作而进行页面的重新加载或跳转，取而<br/> 代之的是利用 JavaScript 动态的变换 HTML 的内容，从而实现 UI 与用户的交互，由于避免了<br/> 页面的重新加载，SPA 可以提供较为流畅的用户体验，得益于 ajax，我们可以实现无跳转刷<br/> 新，又多亏了浏览器的 histroy 机制，我们用 hash 的变化从而可以实现推动界面变化，从而模<br/> 拟元素客户端的单页面切换效果：<br/> SPA 被人追捧是有道理的，但是它也有不足之处，当然任何东西都有两面性，以下是卤煮<br/> 总结的一些目前 SPA 的优缺点：<br/> 1、 优点：<br/> 1,1）无刷新界面，给用户体验原生的应用感觉<br/> 1,2）节省原生（android 和 ios）app 开发成本<br/> 1,3）提高发布效率，无需每次安装更新包<br/> 1,4）容易借助其他知名平台更有利于营销和推<br/> 1,5）符合 web2.0 的趋势<br/> 2、 缺点：<br/> 1） 效果和性能确实和原生的有较大差距<br/> 2） 各个浏览器的版本兼容性不一样</p>\n<p>3） 业务随着代码量增加而增加，不利于首屏优化<br/> 4） 某些平台对 hash 有偏见，有些甚至不支持 pushstate<br/> 5） 不利于搜索引擎抓取</p>\n<h1><a id=\"65_Vue__926\"></a>65、怎样理解 Vue 的单向数据流？（必会）</h1>\n<p>1、数据从父级组件传递给子组件，只能单向绑定<br/> 2、子组件内部不能直接修改从父级传递过来的数据<br/> 3、所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新<br/> 会向下流动到子组件中，但是反过来则不行，这样会防止从子组件意外改变父级组件的状态，<br/> 从而导致你的应用的数据流向难以理解。<br/> 4、每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值，这意味着<br/> 你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警<br/> 告<br/> 5、子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件<br/> 修改</p>\n<h1><a id=\"66VNone__DOM_940\"></a>66、VNone 是什么？什么是虚拟 DOM？（高薪常问）</h1>\n<p>1、Vnode 是什么<br/> Vnode 是 JavaScript 对象，Vnode 表示 Virtual DOM，用 JavaScript 对象来描述真实的<br/> DOM 把 DOM 标签，属性，内容都变成对象的属性。就像使用 JavaScript 对象对一种动物进行<br/> 说明一样{name: ‘Hello Kitty’, age: 1, children: null}。<br/> 1）Vnode 的作用<br/> 通过 render 将 template 模版描述成 Vnode，然后进行一系列操作之后形成真实<br/> 的 DOM 进行挂载。<br/> 2) Vnode 的优点<br/> 2-1) 兼容性强，不受执行环境的影响。Vnode 因为是 JS 对象，不管 node 还是<br/> 浏览器，都可以统一操作，从而获得了服务端渲染、原生渲染、手写渲染函数等能力。<br/> 2-2) 减少操作 DOM，任何页面的变化，都只使用 Vnode 进行操作对比，只需要<br/> 在最后一步挂载更新 DOM，不需要频繁操作 DOM，从而提高页面性能。<br/> 3、 什么是虚拟 DOM?<br/> 1、文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操<br/> 作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出<br/> 代价，大量非常频繁的 DOM 操作会使页面速度变的非常缓慢<br/> 2、Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（Vnode）<br/> 表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM 的 内存中执行计算和操作，而不<br/> 是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式<br/> 来更新实际 DOM 结构,一旦计算出，就将其应用于实际的 DOM 树，这就提高了性能，这就<br/> 是为什么基于虚拟 DOM 的框架（例如 Vue 和 react）如此突出的原因。</p>\n<h1><a id=\"67Vue__DOM_967\"></a>67、Vue 中如何实现一个虚拟 DOM？说说你的思路（高薪</h1>\n<p>常问）<br/> 首先要构建一个 Vnode 的类，DOM 元素上的所有属性在 Vnode 类实例化出来的对象上都<br/> 存在对应的属性。例如 tag 表示一个元素节点的名称，text 表示一个文本节点的文本，chlidren<br/> 表示子节点等。将 Vnode 类实例化出来的对象进行分类，例如注释节点、文本节点、元素节<br/> 点、组件节点、函数式节点、克隆节点。<br/> 然后通过编译将模板转成渲染函数 render，执行渲染函数 render，在其中创建不同类型的<br/> Vnode 类，最后整合就可以得到一个虚拟 DOM（vnode），最后通过 patch 将 vnode 和<br/> oldVnode 进行比较后，生成真实 DOM</p>\n<h1><a id=\"68Vue__data__977\"></a>68、Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法？（高薪常</h1>\n<p>问）<br/> 1、可以被改变的<br/> push()、pop()、shift()、unshift()、splice()、sort()、reverse()这些方法会改变被操作的数<br/> 组；<br/> 2、不可以改变的<br/> filter()、concat()、 slice()这些方法不会改变被操作的数组，并且返回一个新的数组，以上<br/> 方法都可以触发视图更新<br/> 3、解决方案<br/> 1、利用索引直接设置一个数组项，例：this.array[index] = newValue，直接修改数组<br/> 的长度，例：this.array.length = newLength<br/> 2、以上两种方法不可以触发视图更新<br/> 1）可以使用 this.$set(this.array,index,newValue)，this.array.splice(index,1,newValue)<br/> 2）可以使用 this.array.splice(newLength)</p>\n<h1><a id=\"69Vue__data__992\"></a>69、Vue 中如何重置 data? （高薪常问）</h1>\n<p>要初始化 data 中的数据，可以使用 Object.assign()方法，实现重置 data 中的数据，以下就<br/> 是对该方法的详细介绍，以及如何使用该方法，重置 data 中的数据<br/> 1、Object.assign()方法基本定义<br/> 1，1）Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目<br/> 标对象。它将返回目标对象。<br/> 1，2）用法： Object.assign(target, …sources)，第一个参数是目标对象，第二个参数<br/> 是源对象，就是将源对象属性复制到目标对象，返回目标对象</p>\n<p>2、具体使用方式<br/> 使用 Object.assign()，vm.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        d\n       \n       \n        a\n       \n       \n        t\n       \n       \n        a\n       \n       \n        可以获取当前状态下的\n       \n       \n        d\n       \n       \n        a\n       \n       \n        t\n       \n       \n        a\n       \n       \n        ，\n       \n       \n        v\n       \n       \n        m\n       \n       \n        .\n       \n      \n      \n       data 可以获取当前状态下的 data，vm.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord cjk_fallback\">可以获取当前状态下的</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"mord mathnormal\">m</span><span class=\"mord\">.</span></span></span></span></span>options.data(this)<br/> 可以获取到组件初始化状态下的 data，复制 Object.assign(this.<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        d\n       \n       \n        a\n       \n       \n        t\n       \n       \n        a\n       \n       \n        ,\n       \n       \n        t\n       \n       \n        h\n       \n       \n        i\n       \n       \n        s\n       \n       \n        .\n       \n      \n      \n       data, this.\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span></span>options.data(this))<br/> // 注意加 this，不然取不到 data() { a: this.methodA } 中的 this.methodA</p>\n<h1><a id=\"70_Vue___1010\"></a>70、如何对 Vue 首屏加载实现优化? （高薪常问）</h1>\n<p>1、把不常改变的库放到 index.html 中，通过 cdn 引入<br/> 2、vue 路由的懒加载<br/> 3、不生成 map 文件<br/> 4、vue 组件尽量不要全局引入<br/> 5、使用更轻量级的工具库<br/> 6、开启 gzip 压缩<br/> 7、首页单独做服务端渲染</p>\n<h1><a id=\"71Vue__nextTick___1021\"></a>71、Vue 的 nextTick 的原理是什么? （高薪常问）</h1>\n<p>1、为什么需要 nextTick<br/> Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须<br/> 对数据更改–刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个<br/> api 了<br/> 2、理解原理前的准备<br/> 首先需要知道事件循环中宏任务和微任务这两个概念<br/> 2,1）常见的宏任务有：script, setTimeout, setInterval, setImmediate, I/O, UI rendering<br/> 2,2）常见的微任务有：process.nextTick(nodejs),Promise.then(), MutationObserver<br/> 3、理解 nextTick 的原理<br/> 正是 vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。如果<br/> 大家看过这部分的源码，会发现其中做了很多 isNative()的判断，因为这里还存在兼容性<br/> 优雅降级的问题</p>\n<h1><a id=\"72_Vue__hook__1035\"></a>72、在 Vue 实例中编写生命周期 hook 或其他</h1>\n<p>option/propertie 时，为什么不使用箭头函数？（高薪常<br/> 问）<br/> 箭头函数自己没有定义 this 上下文，而是绑定到其父函数的上下文中，当你在 Vue 程序<br/> 中使用箭头函数（=&gt;）时，this 关键字病不会绑定到 Vue 实例，因此会引发错误，所以强烈<br/> 建议改用标准函数声明</p>\n<h1><a id=\"73is__1044\"></a>73、is 这个特性你有用过吗？主要用在哪些方面？（高薪常</h1>\n<p>问）</p>\n<p>1、动态组件<br/> <code>&lt;component :is=\"componentName\"&gt;&lt;/component&gt;</code>， componentName 可以是在本页面<br/> 已经注册的局部组件名和全局组件名,也可以是一个组件的选项对象。 当控制 componentName<br/> 改变时就可以动态切换选择组件</p>\n<p>2、is 的用法<br/> 有些 HTML 元素，诸如 </p>\n<ul><li>\n 、\n <ol><li>\n  、和，对于哪些元素可以出现在其内\n  <br/> 部是有严格限制的\n  <br/> 而有些 HTML 元素，诸如 \n  </li><li>、</li><li> 和 ，只能出现在其它某些特定的元素内\n  <br/> 部\n  <table><tbody><tr></tr></tbody></table>\n</li></ol>\n</li></ul>\n<p></p>\n<pre><code>&lt;ul&gt;\n&lt;card-list&gt;&lt;/card-list&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>所以上面会被作为无效的内容提升到外部，并导致最终渲染结果出<br/> 错。应该这么写：</p>\n<pre><code> &lt;ul&gt;\n&lt;li is=\"cardList\"&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h1><a id=\"74scss__Vuecli__1079\"></a>74、scss 是什么？在 Vue-cli 中的安装使用步骤是？有哪几大特性？（高薪常问）</h1>\n<p>1、基本定义<br/> SCSS 即是 SASS 的新语法，是 Sassy CSS 的简写，是 CSS3 语法的超集，也就是说<br/> 所有有效的 CSS3 样式也同样适合于 SASS，SASS 是 CSS3 的一个扩展，增加了规则嵌套、<br/> 变量、混合、选择器继承等等，通过使用命令行的工具或 WEB 框架插件把它转换成标准<br/> 的、格式良好的 CSS 代码<br/> 2、使用步骤：<br/> 1,1）先装 css-loader、node-loader、sass-loader 等加载器模块<br/> 1,2）在 build 目录找到 webpack.base.config.js，在那个 extends 属性中加一个拓<br/> 展.scss<br/> 1,3）在同一个文件，配置一个 module 属性<br/> 1,4）然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss”<br/> 3、特性:<br/> 3,1）可以用变量，例如（$变量名称=值）<br/> 3,2）可以用混合器，例如（）<br/> 3,3）可以嵌套</p>\n<h1><a id=\"75_packagejson__1098\"></a>75、请详细介绍一些 package.json 中的配置的作用（了解）</h1>\n<p>1、Name:项目名称<br/> 3、 Version: 项目版本<br/> 3、Description: 项目描述<br/> 4、 Author：作者<br/> 5、 Prinate：项目是否私有<br/> 6、 Scripts:npm run *** 命令用于调用 node 执行的.js 文件</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\842633fd8b0942d69c26f8dbeac52684.png\"/></p>\n<p>如果大家觉得还不错，点赞，收藏，分享，一键三连支持我一下~</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 1, "time": "2022-08-15 15:13:03", "summary": "最新面试题、的最大的优势是什么？必会、和两者之间的区别是什么？必会、和区别是什么？哪些场景适合？必会、数据双向绑定的原理是什么必会、和的区别必会、生命周期总共分为几个阶段？必会、第一次加载页面会触发哪"}