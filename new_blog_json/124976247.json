{"blogid": "124976247", "writerAge": "码龄3年", "writerBlogNum": "12", "writerCollect": "2", "writerComment": "0", "writerFan": "2", "writerGrade": "2级", "writerIntegral": "120", "writerName": "eden0218", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124976247.jpg", "writerRankTotal": "90916", "writerRankWeekly": "557661", "writerThumb": "0", "writerVisitNum": "2156", "blog_read_count": "1412", "blog_time": "于 2022-05-25 23:33:25 发布", "blog_title": "c++析构函数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>析构函数·</p>\n<p>定义一个对象，c++自动调用构造函数建立该对象并进行初始化，那么当一个对象的生命周期结束时，c++会自动调用一个函数注销该对象并进行善后工作，这个特殊的成员函数叫做析构函数</p>\n<p>析构函数和类名相同，但在前面要加<sub>，如</sub>CGoods().</p>\n<p>析构函数无函数返回类型，与构造函数在这方面是一样的。但析构函数不带任何参数。</p>\n<p>一个类只有一个析构函数，这是和构造函数不一样的，</p>\n<p>对象注销时，系统自动调用析构函数。</p>\n<p>若类说明中没有给出析构函数，则c++会给出一个缺省的析构函数。</p>\n<pre><code>class complex\n\n{\n\n   double real;\n\n   double image;\n\npublic:\n\ncomplex():real{},image{}\n\n{\n\ncout&lt;&lt;\"create object:\"&lt;&lt;this&lt;&lt;endl;\n\n}\n\ncomplex(double r,double i):real{r},image{i}{\n\ncout&lt;&lt;\"create object:\"&lt;&lt;this&lt;&lt;endl;\n\n}\n\n~complex()\n\n{\n\ncout&lt;&lt;\"destroy object:\"&lt;&lt;this&lt;&lt;endl;\n\n}\n\nvoid print()const\n\n{\n\ncout&lt;&lt;\"real=\"&lt;&lt;real&lt;&lt;'t'&lt;&lt;\"image=\"&lt;&lt;image&lt;&lt;endl;\n\n}\n\n};\n\n</code></pre>\n<p>类的对象不能调动构造函数，但对象可以调动析构函数，对自己销毁。</p>\n<p>构造函数是对资源的获取，析构函数是释放资源。</p>\n<pre><code>class Int()\n\n{\n\nprivate:\n\nvalue;\n\npublic:\n\nInt (int x=0):value(x)\n\n{\n\ncout&lt;&lt;\"create Int:\"&lt;&lt;this&lt;&lt;value&lt;&lt;endl;\n\n}\n\n~Int():value()\n\n{\n\ncout&lt;&lt;\"destory Int:\"&lt;&lt;this&lt;&lt;endl;\n\n}\n\nvoid print() const\n\n{\n\ncout&lt;&lt;value&lt;&lt;endl;\n\n}\nvoid show()const{\ncout &lt;&lt;\"Int::show\"&lt;&lt;endl;\n}\n\n};\n\n\n\nint main()\n\n{\n\nInt a(1);\n\nInt b(2);\n\nInt c(3);\n\nreturn 0;\n\n}\n</code></pre>\n<pre><code>int main()\n\n{\n\nInt *ip=nullptr;\n\nip-&gt;show();\n\nip-&gt;print();\n\nreturn 0;\n\n}\n</code></pre>\n<p>ip指针可以调用show，但是不能调用print，因为print中打印value需要对ip解引用。</p>\n<p>局部变量区设置为栈区。上面的例子中调用构造函数的顺序为abc，调用析构函数的顺序为cba。</p>\n<p>在c++中开辟了空间没有对象，当想给这块空间赋值时需要使用定位new</p>\n<p>如 int *p=new Int(10)(区别int *p=new Int{10})</p>\n<p>new开辟空间时不用去判空，因为如果开辟失败会有返回bad alloc.(malloc 与 operator new的区别，开辟失败时的返回)。</p>\n<pre><code>//ip用operator new来开辟,释放时也用operator delete\nfor (int i=0;i&lt;n;++i){\n\nnew(&amp;ip[i]) Int(i)\n\n}\n</code></pre>\n<p>ps：成员函数设计时加const的好处:1.安全2.通用性好，既适用于普通对象也适用于常对象。</p>\n<p>属性的值不能被外部找到，要想看到得通过函数将值带出来。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-25 23:33:25", "summary": "析构函数定义一个对象，自动调用构造函数建立该对象并进行初始化，那么当一个对象的生命周期结束时，会自动调用一个函数注销该对象并进行善后工作，这个特殊的成员函数叫做析构函数析构函数和类名相同，但在前面要加"}