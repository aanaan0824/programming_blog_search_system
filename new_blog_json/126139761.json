{"blogid": "126139761", "writerAge": "码龄4年", "writerBlogNum": "164", "writerCollect": "4583", "writerComment": "2524", "writerFan": "25519", "writerGrade": "6级", "writerIntegral": "8067", "writerName": "fanstuck", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126139761.jpg", "writerRankTotal": "1632", "writerRankWeekly": "25", "writerThumb": "2599", "writerVisitNum": "326477", "blog_read_count": "480", "blog_time": "于 2022-08-03 19:15:40 发布", "blog_title": "一文速学-特征数据类别分析与预处理方法详解+Python代码", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E7%89%B9%E5%BE%81%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%88%AB-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E7%89%B9%E5%BE%81%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%88%AB\">一、特征类型判别</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%AE%9A%E9%87%8F%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%AE%9A%E9%87%8F%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86\">二、定量数据特征处理</a></p>\n<p id=\"%E4%B8%89.%E5%AE%9A%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E5%AE%9A%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86\">三.定类数据特征处理</a></p>\n<p id=\"1.LabelEncoding-toc\" style=\"margin-left:40px;\"><a href=\"#1.LabelEncoding\">1.LabelEncoding</a></p>\n<p id=\"2.OneHot%20Encoding-toc\" style=\"margin-left:40px;\"><a href=\"#2.OneHot%20Encoding\">2.OneHot Encoding</a></p>\n<p id=\"%E4%BC%98%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BC%98%E7%82%B9%EF%BC%9A\">优点：</a></p>\n<p id=\"%E7%BC%BA%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BC%BA%E7%82%B9%EF%BC%9A\">缺点：</a></p>\n<p id=\"%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\">应用场景：</a></p>\n<p id=\"%E6%97%A0%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%A0%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\">无用场景：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A\">方法二：</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:40px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2\">点关注，防走丢，如有纰漏之处，请留言指教，非常感谢</a></p>\n<p id=\"%E5%8F%82%E9%98%85%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%82%E9%98%85%EF%BC%9A\">参阅：</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_7\"></a>前言</h1>\n<p>当我们开始准备数据建模、构建机器学习模型的时候，第一时间考虑的不应该是就考虑到选择模型的种类和方法。而是首先拿到特征数据和标签数据进行研究，挖掘特征数据包含的信息以及思考如何更好的处理这些特征数据。那么数据类型本身代表的含义就需要我们进行思考，究竟是定量计算还是进行定类分析更好呢？这就是这篇文章将要详解的一个问题。</p>\n<hr/>\n<h1 id=\"%E4%B8%80%E3%80%81%E7%89%B9%E5%BE%81%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%88%AB\">一、特征类型判别</h1>\n<p>特征类型判断以及处理是前期特征工程重要的一环，也是决定特征质量好坏和权衡信息丢失最重要的一环。其中涉及到的数据有数值类型的数据，例如：年龄、体重、身高这类特征数据。也有字符类型特征数据，例如性别、社会阶层、血型、国家归属等数据。</p>\n<p>按照数据存储的数据格式可以归纳为两类：</p>\n<p><img alt=\"\" height=\"410\" src=\"..\\..\\static\\image\\ecabf1e69d8742bb85b8a2db3a54d145.png\" width=\"1200\"/></p>\n<p> 按照特征数据含义又可分为：</p>\n<ul><li>离散型随机变量：取值只能是可取范围内的指定数值类型的随机变量，比如年龄、车流量此类数据。</li><li>连续随机变量：按照测量或者计算方法得到，在某个范围内连取n个值，此类数据可化为定类数据。</li><li>二分类数据：此类数据仅只有两类：例如是与否、成功与失败。</li><li>多分类数据：此类数据有多类：例如天气出太阳、下雨、阴天。</li><li>周期型数据：此类数据存在一个周期循环：例如周数月数。</li></ul>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%AE%9A%E9%87%8F%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86\">二、定量数据特征处理</h1>\n<p>拿到获取的原始特征，必须对每一特征分别进行归一化，比如，特征A的取值范围是[-1000,1000]，特征B的取值范围是[-1,1].如果使用logistic回归，w1*x1+w2*x2，因为x1的取值太大了，所以x2基本起不了作用。所以，必须进行特征的归一化，每个特征都单独进行归一化。</p>\n<p>关于处理定量数据我已经在：<a class=\"link-info\" href=\"https://blog.csdn.net/master_hunter/article/details/108847086?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165951054916782395350270%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165951054916782395350270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-108847086-null-null.nonecase&amp;utm_term=%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86&amp;spm=1018.2226.3001.4450\" title=\"数据预处理归一化详细解释\">数据预处理归一化详细解释</a>这篇文章里面讲述的很详细了，这里进行前后关联，共有min-max标准化、Z-score标准化、Sigmoid函数标准化三种方法：</p>\n<p>根据特征数据含义类型来选择处理方法：</p>\n<ul><li>离散型随机变量处理方法：min-max标准化、Z-score标准化、Sigmoid函数标准</li><li>连续随机变量处理：Z-score标准化，Sigmoid函数标准</li></ul>\n<h1 id=\"%E4%B8%89.%E5%AE%9A%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86\">三.定类数据特征处理</h1>\n<p>我的上篇文章<a class=\"link-info\" href=\"https://blog.csdn.net/master_hunter/article/details/108847086?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165951054916782395350270%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165951054916782395350270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-108847086-null-null.nonecase&amp;utm_term=%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86&amp;spm=1018.2226.3001.4450\" title=\"数据预处理归一化详细解释\">数据预处理归一化详细解释</a> 并没有介绍关于定类数据我们如何去处理，在本篇文章详细介绍一些常用的处理方法：</p>\n<h2 id=\"1.LabelEncoding\">1.LabelEncoding</h2>\n<p>直接替换方法适用于原始数据集中只存在少量数据需要人工进行调整的情况。如果需要调整的数据量非常大且数据格式不统一，直接替换的方法也可以实现我们的目的，但是这种方法需要的工作量会非常大。因此， 我们需要能够快速对整列变量的所有取值进行编码的方法。</p>\n<p>LabelEncoding，即标签编码，作用是为变量的 n 个唯一取值分配一个[0, n-1]之间的编码，将该变量转换成连续的数值型变量。</p>\n<pre><code class=\"language-python\">from sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nle.fit(['拥堵','缓行','畅行'])\nle.transform(['拥堵','拥堵','畅行','缓行'])</code></pre>\n<pre>array([0, 0, 1, 2])</pre>\n<h2 id=\"2.OneHot%20Encoding\">2.OneHot Encoding</h2>\n<p>对于处理定类数据我们很容易想到将该类别的数据全部替换为数值：比如车辆拥堵情况，我们把拥堵标为1，缓行为2，畅行为3.那么这样是实现了标签编码的，但同时也给这些无量纲的数据转为了有量纲数据，我们本意是没有将它们比较之意的。机器可能会学习到“拥堵&lt;缓行&lt;畅行”，所以采用这个标签编码是不够的，需要进一步转换。因为有三种区间，所以有三个比特，即拥堵编码为100，缓行为010，畅行为001.如此一来每两个向量之间的距离都是根号2，在向量空间距离都相等，所以这样不会出现偏序性，基本不会影响基于向量空间度量算法的效果。</p>\n<p>自然状态码为：000,001,010,011,100,101</p>\n<p>独热编码为：000001,000010,000100,001000,010000,100000</p>\n<p>我们可以使用sklearn的onehotencoder来实现：</p>\n<pre><code class=\"language-python\">from sklearn import preprocessing\nenc = preprocessing.OneHotEncoder()\nenc.fit([[0, 0, 1], [0, 1, 0], [1, 0, 0]])    # fit来学习编码\nenc.transform([[0, 0, 1]]).toarray()    # 进行编码</code></pre>\n<pre>array([[1., 0., 1., 0., 0., 1.]])</pre>\n<p>数据矩阵是3*3的，那么原理是怎么来的呢？我们仔细观察：</p>\n<p><img alt=\"\\begin{bmatrix} 0 &amp;0 &amp;1 \\\\ 0 &amp;1 &amp;0 \\\\ 1 &amp;0 &amp;0 \\end{bmatrix}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%200%20%260%20%261%20%5C%5C%200%20%261%20%260%20%5C%5C%201%20%260%20%260%20%5Cend%7Bbmatrix%7D\"/></p>\n<p>第一列的第一个特征维度有两种取值0/1，所以对应的编码方式为10、01.</p>\n<p>第二列的第二个特征也是一样的，类比第三列的第三哥特征。固001的独热编码就是101001了。</p>\n<p>因为大部分算法是基于向量空间中的度量来进行计算的，为了使非偏序关系的变量取值不具有偏序性，并且到圆点是等距的。使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。</p>\n<p>将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。</p>\n<h3 id=\"%E4%BC%98%E7%82%B9%EF%BC%9A\"><strong>优点：</strong></h3>\n<p>独热编码解决了分类器不好处理属性数据的问题，在一定程度上也起到了扩充特征的作用。它的值只有0和1，不同的类型存储在垂直的空间。</p>\n<h3 id=\"%E7%BC%BA%E7%82%B9%EF%BC%9A\"><strong>缺点：</strong></h3>\n<p>当类别的数量很多时，特征空间会变得非常大。在这种情况下，一般可以用PCA来减少维度。而且one hot encoding+PCA这种组合在实际中也非常有用。</p>\n<h3 id=\"%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\"><strong>应用场景：</strong></h3>\n<p>独热编码用来解决类别型数据的离散值问题。</p>\n<h3 id=\"%E6%97%A0%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\"><strong>无用场景：</strong></h3>\n<p>将离散型特征进行one-hot编码的作用，是为了让距离计算更合理，但如果特征是离散的，并且不用one-hot编码就可以很合理的计算出距离，那么就没必要进行one-hot编码。 有些基于树的算法在处理变量时，并不是基于向量空间度量，数值只是个类别符号，即没有偏序关系，所以不用进行独热编码。  Tree Model不太需要one-hot编码： 对于决策树来说，one-hot的本质是增加树的深度。</p>\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</h3>\n<p><strong>方法一：</strong></p>\n<p>实现one-hot编码有两种方法：<span style=\"color:#0d0016;\">sklearn库中的 OneHotEncoder() 方法只能处理数值型变量</span>如果是字符型数据，需要先对其使用 LabelEncoder() 转换为数值数据，再使用 OneHotEncoder() 进行独热编码处理，并且需要自行在原数据集中删去进行独热编码处理的原变量。</p>\n<pre><code class=\"language-python\">import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\nlE = LabelEncoder()\ndf=pd.DataFrame({'路况':['拥堵','畅行','畅行','拥堵','畅行','缓行','缓行','拥堵','缓行','拥堵','拥堵','拥堵']})\ndf['路况']=lE.fit_transform(df['路况'])\nOHE = OneHotEncoder()\nX = OHE.fit_transform(df).toarray()\ndf = pd.concat([df, pd.DataFrame(X, columns=['拥堵', '缓行','畅行'])],axis=1)\ndf</code></pre>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"507\" src=\"..\\..\\static\\image\\77fd6c63336744c3a59a1548f2a6595a.png\" width=\"285\"/></h3>\n<p> </p>\n<h3 id=\"%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A\">方法二：</h3>\n<p><span style=\"color:#0d0016;\">pandas<code>自带get_dummies()方法</code></span></p>\n<p>get_dummies() 方法可以对数值数据和字符数据进行处理，直接在原数据集上应用该方法即可。该方法产生一个新的Dataframe，列名由原变量延伸而成。将其合并入原数据集时，需要自行在原数据集中删去进行虚拟变量处理的原变量。</p>\n<pre><code class=\"language-python\">import pandas as pd\ndf=pd.DataFrame({'路况':['拥堵','畅行','畅行','拥堵','畅行','缓行','缓行','拥堵','缓行','拥堵','拥堵','拥堵']})\npd.get_dummies(df,drop_first=False) </code></pre>\n<h2><img alt=\"\" height=\"525\" src=\"..\\..\\static\\image\\e37312ed2597485b91a4afa93d13a5ae.png\" width=\"380\"/></h2>\n<p> </p>\n<h2 id=\"%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2\">点关注，防走丢，<strong>如有纰漏之处，请留言指教，非常感谢</strong></h2>\n<p>以上就是本期全部内容。我是fanstuck ，有问题大家随时留言讨论 ，我们下期见。</p>\n<hr/>\n<h1 id=\"%E5%8F%82%E9%98%85%EF%BC%9A\">参阅：</h1>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/ccblogger/article/details/80010974\" title=\"数据挖掘OneHotEncoder独热编码和LabelEncoder标签编码\">数据挖掘OneHotEncoder独热编码和LabelEncoder标签编码</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_30697239/article/details/96220260?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165951127916782246446529%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165951127916782246446529&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-96220260-null-null.142%5Ev39%5Epc_rank_34_1&amp;utm_term=%E5%AE%9A%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&amp;spm=1018.2226.3001.4187\" title=\"类别型数据的预处理方法\">类别型数据的预处理方法</a></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-03 19:15:40", "summary": "目录前言一、特征类型判别二、定量数据特征处理三定类数据特征处理优点：缺点：应用场景：无用场景：代码实现编辑方法二：编辑点关注，防走丢，如有纰漏之处，请留言指教，非常感谢参阅：前言当我们开始准备数据建模"}