{"blogid": "124825804", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5465", "writerComment": "4193", "writerFan": "7301", "writerGrade": "7级", "writerIntegral": "13153", "writerName": "三分苦", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124825804.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4502", "writerVisitNum": "115934", "blog_read_count": "614", "blog_time": "于 2022-06-04 06:35:55 发布", "blog_title": "【 C++ 】类和对象（中）—— 类的6个默认成员函数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">1、类的6个默认成员函数</a></p>\n<p id=\"2%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">2、构造函数</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">        </a><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">构造函数概念</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">        </a><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">构造函数特性</a></p>\n<p id=\"3%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">3、析构函数</a></p>\n<p id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">        </a><a href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">析构函数概念</a></p>\n<p id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">        </a><a href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">析构函数特性</a></p>\n<p id=\"4%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">4、拷贝构造函数</a></p>\n<p id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">        </a><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">拷贝构造函数概念</a></p>\n<p id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">        </a><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">拷贝构造函数特性</a></p>\n<p id=\"5%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#5%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">5、赋值运算符重载</a></p>\n<p id=\"%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">        </a><a href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">运算符重载</a></p>\n<p id=\"%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">        </a><a href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">赋值运算符重载</a></p>\n<p id=\"6%E3%80%81const%E6%88%90%E5%91%98-toc\" style=\"margin-left:80px;\"><a href=\"#6%E3%80%81const%E6%88%90%E5%91%98\">6、const成员</a></p>\n<p id=\"const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">        </a><a href=\"#const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">const修饰类的成员函数</a></p>\n<p id=\"7%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#7%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD\">7、取地址及const取地址操作符重载</a></p>\n<hr/>\n<h3>1、类的6个默认成员函数</h3>\n<blockquote>\n<p>在我们前面学习的类中，我们会定义成员变量和成员函数，这些我们自己定义的函数都是普通的成员函数，但是如若我们定义的类里什么也没有呢？是真的里面啥也没吗？如下：</p>\n<pre><code class=\"language-cpp\">class Date {};</code></pre>\n<p>如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情况下，<span style=\"color:#956fe7;\">都会自动生成6个默认成员函数。</span></p>\n<p><img alt=\"\" height=\"334\" src=\"..\\..\\static\\image\\8ae8cc15fe5240e0980a2f6caaa3b675.png\" width=\"1001\"/></p>\n</blockquote>\n<hr/>\n<h3 id=\"2%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">2、构造函数</h3>\n<h3 id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">构造函数概念</h3>\n<blockquote>\n<p>如下的日期类：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tvoid Init(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\td1.Init(2022, 5, 17);\n\td1.Print();\n\treturn 0;\n}</code></pre>\n<p>正常情况下，我们写的这个日期类，首先初始化，其次打印。但如果说你突然忘记初始化了，直接就开始访问会怎么样呢？</p>\n<p><img alt=\"\" height=\"180\" src=\"..\\..\\static\\image\\d5802ff556b34bb7809b4952d84a2793.png\" width=\"769\"/></p>\n<p>从运行结果上看，没初始化直接访问输出的是<span style=\"color:#956fe7;\">随机值</span>。 忘记初始化其实是一件很正常的事情，C++大佬在这一方面为了填补C语言的坑（必须得手动初始化）。因而就设计出了<strong><span style=\"color:#956fe7;\">构造函数</span></strong>。</p>\n<p><span style=\"color:#956fe7;\">构造函数是一个特殊的成员函数</span>，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次。其目的就是为了方便我们不需要再初始化。</p>\n</blockquote>\n<h3 id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">构造函数特性</h3>\n<blockquote>\n<p><span style=\"color:#956fe7;\">构造函数是特殊的成员函数</span>，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的<span style=\"color:#fe2c24;\">主要任务并不是开空间创建对象，而是初始化对象。</span></p>\n<p>其特征如下：</p>\n<ol><li>函数名和类名相同</li><li>无返回值</li><li>对象实例化时编译器<strong>自动调用</strong>对应的构造函数</li><li>构造函数<strong>可以重载</strong></li><li>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成</li><li>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。</li></ol>\n<p>如下即为构造函数：</p>\n<pre><code class=\"language-cpp\">Date()\n{\n\t_year = 1;\n\t_month = 1;\n\t_day = 1;\n}</code></pre>\n<ul><li><strong>解释特性3：<span style=\"color:#fe2c24;\">对象实例化时编译器自动调用对应的构造函数</span></strong></li></ul>\n<p>也就是说我们在实例化一个对象后，它会自动调用这个构造函数，<span style=\"color:#956fe7;\">自动就初始化了</span>，我们可以通过调试看看：</p>\n<p><img alt=\"\" height=\"626\" src=\"..\\..\\static\\image\\fc42a6204b5a4a47b3918a780a6fcc0b.png\" width=\"1200\"/></p>\n<p></p>\n<ul><li><strong>解释特性4：<span style=\"color:#fe2c24;\">构造函数支持重载，</span></strong></li></ul>\n<p><span style=\"color:#0d0016;\">如下的函数：</span></p>\n<pre><code class=\"language-cpp\">Date(int year, int month, int day)\n{\n\t_year = year;\n\t_month = month;\n\t_day = day;\n}</code></pre>\n<p>像这个重载函数是明确了我们要传参的，所以我们<span style=\"color:#956fe7;\">在实例化对象后就必须把参数写上去</span>（虽然看着奇奇怪怪，但是没有办法，毕竟我们普通的调用，参数都是在函数名后面，而这个参数在实例化对象后面）：</p>\n<pre><code class=\"language-cpp\">Date d2(2022, 5, 17);</code></pre>\n<p>来输出和我们先前的构造函数对比看看：</p>\n<p><img alt=\"\" height=\"783\" src=\"..\\..\\static\\image\\f6ca870c35684dffbed0b322a14300f0.png\" width=\"1145\"/></p>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：没有参数时我在调用的时候不能加上括号（），切忌！！构造函数尤为特殊</span></li><li>如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</li></ul>\n<p><img alt=\"\" height=\"71\" src=\"..\\..\\static\\image\\52f42c16fb93417c8e2c99b2a01526e8.png\" width=\"571\"/></p>\n<p><span style=\"color:#0d0016;\">无参的情况下必须要像我们刚开始实例化的d1那样：</span></p>\n<pre><code class=\"language-cpp\">Date d1;\nd1.Print();</code></pre>\n<ul><li><span style=\"color:#956fe7;\"> 构造函数的重载我们推荐写成全缺省的样子：</span></li></ul>\n<pre><code class=\"language-cpp\">//普通的构造函数\n\tDate()\n\t{\n\t\t_year = 1;\n\t\t_month = 1;\n\t\t_day = 1;\n\t}\n//全缺省的构造函数\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}</code></pre>\n<p>首先，普通的构造函数和全缺省的构造函数在不调用的情况下可以同时存在，编译也没有错误。但是在实际调用的过程中，会存在歧义。如下的调用：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n//普通的构造函数\n\tDate()\n\t{\n\t\t_year = 1;\n\t\t_month = 1;\n\t\t_day = 1;\n\t}\n//全缺省的构造函数\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\td1.Print();\n}</code></pre>\n<p>此时我实例化的d1到底是调用普通的构造函数？还是调用全缺省的构造函数？并且此段代码编译出现错误。何况我在没有调用函数的情况下编译是没错的。</p>\n<p><strong>由此可见：</strong><span style=\"color:#956fe7;\">它们俩在语法上可以同时存在，但是使用上不能同时存在</span>，因为会存在调用的歧义，不知道调用的是谁，所以一般情况下，<span style=\"color:#fe2c24;\">我们更推荐直接写个全缺省版的构造函数，因为是否传参数可由你决定。传参数数量也是由你决定。</span></p>\n<p></p>\n<ul><li><strong>解释特性5：<span style=\"color:#fe2c24;\">如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的</span><span style=\"color:#956fe7;\">默认构造函数</span><span style=\"color:#fe2c24;\">，一旦用户显式定义编译器将不再生成</span></strong></li></ul>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t\n\t// 我们不写，编译器会生成一个默认无参构造函数\n\t/*Date(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}*/\n\t\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\t// 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数\n\tDate d;\n\td.Print();\n}</code></pre>\n<p><img alt=\"\" height=\"69\" src=\"..\\..\\static\\image\\0802b6a6d3b3457db214e26404e8f064.png\" width=\"559\"/></p>\n<p>不是说好我不自己写构造函数，编译器会默认生成吗？为什么到这又是随机值了？这难道也算初始化？别急，搞清楚这个得先明白<strong>默认构造函数</strong>：</p>\n<p><strong><span style=\"background-color:#fefcd8;\">注意：C++把变量分成两种</span></strong></p>\n<ul><li>内置类型/基本类型：int、char、double、指针……</li><li>自定义类型：class、struct去定义的类型对象</li></ul>\n<p><span style=\"color:#fe2c24;\">C++默认生成的构造函数对于内置类型成员变量不做处理，对于自定义类型的成员变量才会处理</span>，这也就能很好的说明了为什么刚才没有对年月日进行处理（初始化），因为它们是<span style=\"color:#956fe7;\">内置类型</span>（int类型的变量）</p>\n<p>让我们来看看自定义类型是如何处理的。</p>\n<pre><code class=\"language-cpp\">class A\n{\npublic:\n\tA()\n\t{\n\t\tcout &lt;&lt; \"A()\" &lt;&lt; endl;\n\t\t_a = 0;\n\t}\nprivate:\n\tint _a;\n};\n</code></pre>\n<p>首先，这是一个名为A的类，有成员变量_a，并且还有一个无参的构造函数，对_a初始化为0。接着：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n\tA _aa;\n};\nint main()\n{\n\tDate d;\n\td.Print();\n}</code></pre>\n<p>日期类里有三个内置类型，一个自定义类型（A_aa），我们编译运行看看结果：</p>\n<p><img alt=\"\" height=\"84\" src=\"..\\..\\static\\image\\3588326ff148436aa385cc8f41f0170e.png\" width=\"601\"/></p>\n<p><img alt=\"\" height=\"211\" src=\"..\\..\\static\\image\\433616dd9aae4e11ac508f001fe94dcf.png\" width=\"887\"/></p>\n<p>通过运行结果以及调试，也正验证了默认构造函数对自定义类型才会处理。这也就告诉我们，当出现内置类型时，就需要我们自己写构造函数了。</p>\n<p>什么时候使用默认构造函数会凸显出其价值呢？就比如我们之前写的括号匹配这道题：</p>\n<pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\tStack()\n\t{\n\t\t_a = nullptr;\n\t\t_top = _capacity;\n\t}\nprivate:\n\tint* _a;\n\tint _top;\n\tint _capacity;\n\n};\n\nclass MyQueue \n{\npublic:\n\t//默认生成的构造函数就可以用了\n\tvoid push(int x)\n\t{}\n\n\tint pop() \n\t{}\nprivate:\n\tStack _S1;\n\tStack _s2;\n};\n</code></pre>\n<p>此时我队列里自定义类型_s1和_s2就不需要单独写初始化了，直接用默认的。但是如果栈里没有写构造函数，那么其输出的还是随机的，因为栈里的也是内置类型。就是一层套一层，下一层生效的前提是上一层地基打稳了。</p>\n<p>总结：</p>\n<ol><li>如果一个类中的成员全是自定义类型，我们就可以用默认生成的函数</li><li>如果有内置类型的成员，或者需要显示传参初始化，那么都要自己实现构造函数。</li></ol>\n<ul><li><strong>解释特性6：<span style=\"color:#fe2c24;\">无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：</span><span style=\"color:#956fe7;\">无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数</span><span style=\"color:#fe2c24;\">，都可以认为是默认成员函数。</span></strong></li></ul>\n<p>特性6可以简单总结为<strong>不用传参</strong>就可以调用的即为默认构造函数</p>\n<p><img alt=\"\" height=\"770\" src=\"..\\..\\static\\image\\053427249cdd43b39e35eb5b7b4e693d.png\" width=\"1200\"/></p>\n<p>既然我默认构造函数只对自定义类型才会处理，那如果我不想自己再写构造函数也要对内置类型处理呢？我们可以这样做：（后续的博文会继续详细讲解这块）</p>\n<p><img alt=\"\" height=\"480\" src=\"..\\..\\static\\image\\93685324c2024d0cace3e3922362a33d.png\" width=\"1200\"/></p>\n</blockquote>\n<hr/>\n<h3 id=\"3%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">3、析构函数</h3>\n<h3 id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">析构函数概念</h3>\n<blockquote>\n<p>前面通过构造函数的学习，我们知道一个对象时怎么来的，<span style=\"color:#ff9900;\">那一个对象又是怎么没呢的？</span></p>\n<p>析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。<span style=\"color:#956fe7;\"><strong>而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</strong></span></p>\n</blockquote>\n<h3 id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">析构函数特性</h3>\n<blockquote>\n<p>析构函数是特殊的成员函数。</p>\n<p>其特征如下：</p>\n<ol><li>析构函数名是在类名前加上字符 ~。</li><li>无参数无返回值。</li><li>一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。</li><li>对象生命周期结束时，C++编译系统系统自动调用析构函数</li><li>编译器生成的默认析构函数，对会自定类型成员调用它的析构函数</li></ol>\n<p>我们实际写一个析构函数看看：</p>\n<pre><code class=\"language-cpp\">~Date()\n{\n\tcout &lt;&lt; \"~Date()\" &lt;&lt; endl;\n}</code></pre>\n<p>带入示例再看看：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\n\t~Date()\n\t{\n\t\tcout &lt;&lt; \"~Date()\" &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"65\" src=\"..\\..\\static\\image\\b04298f1b42742b6b7e70df8ac2fd485.png\" width=\"674\"/></p>\n<p>首先，我实例化出的d1会调用它的默认构造函数进行初始化，其次，出了作用域后又调用其析构函数，这也就是为什么输出结果会是~Date()</p>\n<p>析构的目的是为了完成资源清理，什么样的才能算是资源清理呢？像我这里定义的年月日变量就不需要资源清理，因为出了函数栈帧就销毁，<span style=\"color:#956fe7;\">真正需要清理的是malloc、new、fopen这些的，</span><span style=\"color:#494949;\">就比如清理栈里malloc出的</span></p>\n<pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\t//构造函数\n\tStack(int capacity = 10)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\tassert(_a);\n\t\t_top = 0;\n\t\t_capacity = capacity;\n\t}\n\t//析构函数\n\t~Stack()\n\t{\n\t\tfree(_a);\n\t\t_a = nullptr;\n\t\t_top = _capacity = 0;\n\t}\nprivate:\n\tint* _a;\n\tint _top;\n\tint _capacity;\n};\nint main()\n{\n\tStack st;\n}</code></pre>\n<p>这里不难感慨C++的构造函数就像先前C语言常写的Init，而析构函数就像Destroy</p>\n<ul><li><strong>看如下的题目：</strong></li></ul>\n<pre><code class=\"language-cpp\">int main()\n{\n\tStack st1;\n\tStack st2;\n}\n</code></pre>\n<p>现在我用类实例化出st1和st2两个对象，首先，st1肯定先构造，st2肯定后构造，这点毋庸置疑，那关键是谁先析构呢？</p>\n<p><strong>答案：</strong><span style=\"color:#fe2c24;\">st2先析构，st1后析构</span></p>\n<p><strong>解析：</strong>这里st1和st2是在栈上的，建立栈帧，其性质和之前一样，后进先出，st2后压栈，那么它肯定是最先析构的。所以栈里面定义对象，析构顺序和构造顺序是反的。</p>\n<ul><li><strong>解释特性3：<span style=\"color:#fe2c24;\">一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。</span></strong></li></ul>\n<p>若自己没有定义析构函数，虽说系统会自动生成默认析构函数，不过也是有要求的，和构造函数一样，<span style=\"color:#956fe7;\">内置类型不处理，自定义类型会去调用它的析构函数</span>，如下：</p>\n<pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\t//构造函数\n\tStack(int capacity = 10)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\tassert(_a);\n\t\t_top = 0;\n\t\t_capacity = capacity;\n\t}\n\t//析构函数\n\t~Stack()\n\t{\n\t\tcout &lt;&lt; \"~Stack():\" &lt;&lt; this &lt;&lt; endl;\n\t\tfree(_a);\n\t\t_a = nullptr;\n\t\t_top = _capacity = 0;\n\t}\nprivate:\n\tint* _a;\n\tint _top;\n\tint _capacity;\n\n};\nclass MyQueue\n{\npublic:\n\t//默认生成的构造函数可以用\n\t//默认生成的析构函数也可以用\n\tvoid push(int x)\n\t{}\n\n\tint pop()\n\t{}\nprivate:\n\tStack _S1;\n\tStack _s2;\n};\nint main()\n{\n\tMyQueue q;\n}</code></pre>\n<p><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\d72cdb583a074963ae9b0ea5f427988f.png\" width=\"581\"/></p>\n<p>对于MyQueue而言，我们不需要写它的默认构造函数，因为编译器对于自定义类型成员（_S1和_S2）会去调用它的默认构造，Stack提供了默认构造，出了作用域，编译器会针对自定义类型的成员去默认调用它的析构函数，因为有两个自定义成员（_S1和_S2），自然析构函数也调了两次，所以会输出两次Stack()……</p>\n</blockquote>\n<hr/>\n<h3>4、拷贝构造函数</h3>\n<h3 id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\">拷贝构造函数概念</h3>\n<blockquote>\n<p>我们在创建对象时，可否创建一个与一个对象一某一样的新对象呢？</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tDate d1(2022, 5, 18);\n\tDate d2(d1);\n\treturn 0;\n}</code></pre>\n<p>能否让d2的值跟d1一样呢？也就是说我拿d1去初始化d2，此时调用的函数就是拷贝构造函数。</p>\n<p><strong>拷贝构造函数：</strong><span style=\"color:#956fe7;\">只有单个形参</span>，该形参是对本<span style=\"color:#956fe7;\">类类型对象的引用(一般常用const修饰)</span>，在用<span style=\"color:#956fe7;\">已存在的类类型对象创建新对象时由编译器自动调用</span></p>\n</blockquote>\n<h3 id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7\">拷贝构造函数特性</h3>\n<blockquote>\n<p>拷贝构造函数也是特殊的成员函数，其特征如下：</p>\n<ol><li>拷贝构造函数<span style=\"color:#956fe7;\">是构造函数的一个重载形式。</span></li><li>拷贝构造函数的参数<span style=\"color:#956fe7;\">只有一个且必须使用引用传参</span>，使用<span style=\"color:#fe2c24;\">传值方式会引发无穷递归调用。</span></li><li>若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储<span style=\"color:#956fe7;\">按字节序完成拷贝</span>，这种拷贝我们叫做浅拷贝，或者值拷贝。</li></ol>\n<p>如下即为拷贝构造函数：</p>\n<pre><code class=\"language-cpp\">Date(Date&amp; d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n}</code></pre>\n<ul><li><strong>解释特性2：<span style=\"color:#fe2c24;\">拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用。</span></strong></li></ul>\n<p>为什么传值传参会引发无穷递归呢？</p>\n<p>我们先举一个普通的func函数作为例子：</p>\n<pre><code class=\"language-cpp\">//传值传参\nvoid Func(Date d)\n{}\nint main()\n{\n\tDate d1(2022, 5, 18);\n\tFunc(d1);\n\treturn 0;\n}</code></pre>\n<p>此函数调用传参是传值传参。在C语言中，把实参传给形参是把实参的值拷贝给形参，而我的实参d1是自定义类型的，需要调用拷贝构造，传值传参是要调用拷贝构造的，但是我如果不想调用拷贝构造呢？就需要引用传参，因为此时d就是d1的别名</p>\n<pre><code class=\"language-cpp\">void Func(Date&amp; d) {}</code></pre>\n<p>此时再回到我们刚才的例子：如若我不传引用传参，就会疯狂的调用拷贝构造：</p>\n<pre><code class=\"language-cpp\">Date(Date d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n}</code></pre>\n<p><img alt=\"\" height=\"387\" src=\"..\\..\\static\\image\\8ac502b022324ac292766cfe161b3f35.png\" width=\"1200\"/></p>\n<p>为了避免出现无限递归调用拷贝构造，所以要加上引用，加上引用后，d就是d1的别名，不存在拷贝构造了。<strong><span style=\"color:#fe2c24;\">同类型的传值传参是要调用拷贝构造的</span></strong></p>\n<pre><code class=\"language-cpp\">Date(const Date&amp; d) {} \n//最好加上const，对d形成保护</code></pre>\n<ul><li><strong>解释特性3：</strong><strong><span style=\"color:#fe2c24;\">若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝。</span></strong></li></ul>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n//构造函数\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n//拷贝构造函数\n    /*\n\tDate(const Date&amp; d)\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\n    */\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nvoid Func(Date&amp; d)\n{\n\td.Print();\n}\nint main()\n{\n\tDate d1(2022, 5, 18);\n\tDate d2(d1);\n\tFunc(d1);\n\td2.Print();\n}</code></pre>\n<p><img alt=\"\" height=\"83\" src=\"..\\..\\static\\image\\e8a3a082114e47d6bdb55ea0a22f69b5.png\" width=\"581\"/></p>\n<p>为什么我这里没有写拷贝构造函数，它也会自动完成拷贝构造呢？由此我们要深思，拷贝构造与构造和析构是不一样的，构造和析构都是针对自定义类型才会处理而内置类型不会处理，<span style=\"color:#956fe7;\"><strong>而默认拷贝构造针对内置类型的成员会完成值拷贝，浅拷贝</strong></span>，也就是像把d1的内置类型成员按字节拷贝给d2。</p>\n<p></p>\n<p>由此得知，对于日期类这种内置类型的成员是不需要我们写拷贝构造的，那是不是所有的类都不需要我们写拷贝构造呢？来看下面的栈类。</p>\n<pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\t//构造函数\n\tStack(int capacity = 10)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\tassert(_a);\n\t\t_top = 0;\n\t\t_capacity = capacity;\n\t}\n//不写拷贝构造，编译器调用默认拷贝构造\n\t/*\n\tStack(const Stack&amp; st)\n\t{\n\t\t_a = st._a;\n\t\t_top = st._top;\n\t\t_capacity = st._capacity;\n\t}\n\t*/\n\t//析构函数\n\t~Stack()\n\t{\n\t\tcout &lt;&lt; \"~Stack():\" &lt;&lt; this &lt;&lt; endl;\n\t\tfree(_a);\n\t\t_a = nullptr;\n\t\t_top = _capacity = 0;\n\t}\nprivate:\n\tint* _a;\n\tint _top;\n\tint _capacity;\n};\nint main()\n{\n\tStack st1(10);\n\tStack st2(st1);\n}</code></pre>\n<p>是这也写吗？</p>\n<p><img alt=\"\" height=\"774\" src=\"..\\..\\static\\image\\65131855993346ed83dcd1df26170f1d.png\" width=\"1200\"/></p>\n<p>我们通过调试看到运行崩溃了，可见栈的拷贝构造函数不能像日期类一样不写而让编译器去调用默认拷贝构造（就是按照日期类的模式写了拷贝构造也会出错），因为此时的st1（指针）和st2（指针）指向的就是同一块空间，通过调试可以看出：</p>\n<p><img alt=\"\" height=\"279\" src=\"..\\..\\static\\image\\7a86a008538840ceba93bffd0e0ec1ed.png\" width=\"896\"/></p>\n<p><img alt=\"\" height=\"235\" src=\"..\\..\\static\\image\\135e22c377c248a2ac5dc2a7abb9c3df.png\" width=\"625\"/></p>\n<p>st1和st2指向同一块空间会引发一个巨大的问题：<span style=\"color:#956fe7;\">析构函数那出错</span>，因为我st2会先析构，析构完后我st1再析构，不过我st1指向的空间已经被st2析构过了，因为它俩指向同一块空间，<span style=\"color:#fe2c24;\">同一块空间我释放两次就会有问题。 </span><span style=\"color:#494949;\">出了析构存在问题，增删查改那也会有问题，这个后续会谈到。</span></p>\n<p></p>\n<p>其实刚才写的栈的拷贝构造就是<strong>浅拷贝</strong>，真正栈的拷贝构造应该用<span style=\"color:#fe2c24;\"><strong>深拷贝</strong></span>来完成，此部分内容我等后续会专门出一篇博文详解，这里大家先简单接触下。</p>\n<p></p>\n<p>综上，我们可以得知，浅拷贝针对日期类这种是没有问题的，而类的成员若是指向一块空间的话就不能用浅拷贝了。</p>\n<p></p>\n<ul><li><strong>如果是自定义类型呢？让编译器自己生成拷贝构造会怎么样呢？</strong></li></ul>\n<p><span style=\"color:#fe2c24;\">自定义类型的成员，去调用这个成员的拷贝构造。</span></p>\n<pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\t//构造函数\n\tStack(int capacity = 10)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\tassert(_a);\n\t\t_top = 0;\n\t\t_capacity = capacity;\n\t}\n//不写拷贝构造，编译器调用默认拷贝构造\n\t/*\n    浅拷贝\n\tStack(const Stack&amp; st)\n\t{\n\t\t_a = st._a;\n\t\t_top = st._top;\n\t\t_capacity = st._capacity;\n\t}\n\t*/\nprivate:\n\tint* _a;\n\tint _top;\n\tint _capacity;\n};\nclass MyQueue\n{\n//默认拷贝构造针对内置类型的成员会完成值拷贝，浅拷贝\n//自定义类型的成员，去调用这个成员的拷贝构造。\nprivate:\n\tint _size = 0;\n\tStack _S1;\n\tStack _s2;\n};\nint main()\n{\n\tMyQueue mq1;\n\tMyQueue mq2(mq1);\n}</code></pre>\n<p><span style=\"color:#956fe7;\">其实这里同样是发生了浅拷贝，归根结底在于我栈的深拷贝还没写。</span></p>\n<p><img alt=\"\" height=\"279\" src=\"..\\..\\static\\image\\7ab7c9dcd0914212ba7538ea33d3a767.png\" width=\"932\"/></p>\n<p></p>\n<p>仔细看我的调试，mq2调用了其成员栈的拷贝构造，而我mq1和mq2的两个栈又发生了<span style=\"color:#956fe7;\">浅拷贝</span>，它们对应的_S1和_S2指向的地址都是一样的，<span style=\"color:#956fe7;\">这也就意味着析构时同一块空间又会析构两次，</span>出错。这里套了两层。</p>\n<ul><li><strong>总结：</strong>一般的类，自己生成拷贝构造就够用了，只有像Stack这样自己直接管理资源的类，需要自己实现深拷贝。</li></ul>\n<p><span style=\"color:#fe2c24;\"><strong>补充：</strong></span></p>\n<pre><code class=\"language-cpp\">void TestDate2()\n{\n\tDate d1(2022, 5, 18);\n\tDate d3 = d1; //等价于 Date d3(d1);\n}</code></pre>\n<p>Date d3 = d1 是拷贝构造，不是赋值，拿一个对象初始化另一个对象是拷贝构造。</p>\n<p></p>\n</blockquote>\n<h3 id=\"5%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">5、赋值运算符重载</h3>\n<h3 id=\"%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">运算符重载</h3>\n<blockquote>\n<p>如下的日期类：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t//构造函数\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<p>我能否按照如下的方式对日期类的对象进行大小比较呢？</p>\n<p><img alt=\"\" height=\"346\" src=\"..\\..\\static\\image\\3bfbec7974554be8839317728f873314.png\" width=\"617\"/></p>\n<p>很明显是不可以的，从波浪线提示的警告就能看出。我们都清楚内置类型是可以直接进行比较的，但是自定义类型是不能直接通过上述的运算符进行比较的，<span style=\"color:#956fe7;\">为了能够让自定义类型使用各种运算符，于是就提出了运算符重载的规则。</span></p>\n<p>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p>\n<ul><li>函数名字为：关键字<strong>operator</strong>后面接需要重载的<strong>运算符符号</strong>。</li><li>函数参数：运算符操作数</li><li>函数返回值：运算符运算后结果</li><li>函数原型：返回值类型 operator操作符(参数列表)</li></ul>\n<p><span style=\"background-color:#fefcd8;\">注意：</span></p>\n<ul><li>运算符重载函数的参数由运算符决定，比如运算符==应有两个参数，<span style=\"color:#956fe7;\">双操作数运算符就有两个参数，单操作数运算符（++或--）就有一个参数</span></li></ul>\n<p>就比如我现在写一个日期比较相等的运算符重载（<span style=\"color:#fe2c24;\">传值传参会引发拷贝构造，所以要加上引用，最好再加上const</span>）：</p>\n<pre><code class=\"language-cpp\">bool operator==(const Date&amp; d1, const Date&amp; d2) //避免传值传参调用拷贝构造\n{\n\treturn d1._year == d2._year &amp;&amp;\n\t\td1._month == d2._month &amp;&amp;\n\t\td1._day == d2._day;\n}</code></pre>\n<p><img alt=\"\" height=\"712\" src=\"..\\..\\static\\image\\6774669e5d784a2db0676be5e2f1c4ff.png\" width=\"1200\"/></p>\n<p>最好把运算符重载函数放到类里面（像图示的将成员变量变成公有也可以），因为类外不允许访问私有的成员变量（虽然可以通过友元来解决，不过现如今暂未学到）</p>\n<p>仔细观察我的截图：毕竟我都写好了运算符重载，可是我调用运算符重载的方式怎么还能跟调用普通函数一样呢？与其这样还取名运算符重载又有何意义，所以真正的调用应该如下：</p>\n<p><img alt=\"\" height=\"323\" src=\"..\\..\\static\\image\\fa620c96cf924b5f8de15d85625f0bd9.png\" width=\"1015\"/></p>\n<p>调用的时候直接和内置类型进行运算符操作那样，编译器会自动处理成调用运算符重载的样子 </p>\n<ul><li><strong>注意：</strong>上述的运算符重载就算完成了吗？当然不是，<span style=\"color:#956fe7;\">按理说我们要把运算符重载函数放成类里的成员函数。</span></li></ul>\n<p>并且，这里的参数也不能像如上的方式写：</p>\n<p><img alt=\"\" height=\"566\" src=\"..\\..\\static\\image\\79b7ea3afcf24d7a8eb51102d19d9eb1.png\" width=\"724\"/></p>\n<p>如若直接把运算符重载函数放到类里，编译器会报错（<span style=\"color:#956fe7;\">运算符函数的参数太多</span>）。<span style=\"color:#fe2c24;\">报错的原因就在于成员函数存在隐含的this指针</span>。 这也就意味着实际的参数有3个，因此我们要少写一个参数：</p>\n<pre><code class=\"language-cpp\">bool operator==(const Date&amp; d)//编译器会处理成 bool operator(Date* const this, const Date&amp; d)\n{\n\treturn _year == d._year &amp;&amp;\n\t\t_month == d._month &amp;&amp;\n\t\t_day == d._day;\n}</code></pre>\n<p>并且我在调用成员函数的时候也要做出改变：</p>\n<pre><code class=\"language-cpp\">if (d1.operator==(d2))\n{\n\tcout &lt;&lt; \"==\" &lt;&lt; endl;\n}</code></pre>\n<p>和刚才一样，为了凸显出运算符重载的意义，我们调用的时候可以直接像内置类型一样操作运算符，因为编译器会帮我们处理：</p>\n<pre><code class=\"language-cpp\">if (d1 == d2)//编译器会处理成对应重载运算符调用if (d1.operator==(d2))或者if (d1.operator==(&amp;d1, d2))\n{\n\tcout &lt;&lt; \"==\" &lt;&lt; endl;\n}</code></pre>\n<p>如下：</p>\n<p><img alt=\"\" height=\"850\" src=\"..\\..\\static\\image\\8604ab2d59264455984277ac3bd9b740.png\" width=\"1200\"/></p>\n<ul><li><strong>现在，我们来写一个日期类的比较大小来练练手：</strong></li></ul>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\t//日期比较大小\n\tbool operator&lt;(const Date&amp; d)\n\t{\n\t\tif (_year &gt; d._year ||\n\t\t\t_year == d._year &amp;&amp; _month &gt; d._month ||\n\t\t\t_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1(2022, 5, 17);\n\tDate d2(2022, 5, 20);\n\tif (d1 &lt; d2)\n\t\tcout &lt;&lt; \"&lt;\" &lt;&lt; endl;\n}</code></pre>\n<p> <img alt=\"\" height=\"62\" src=\"..\\..\\static\\image\\6b7ca0b678274761bb92d1bb47100149.png\" width=\"450\"/></p>\n<p><strong>接下来，再来总结下运算符重载的注意点：</strong></p>\n<ul><li>不能通过连接其他符号来创建新的操作符：比如operator@</li><li>重载操作符必须有一个类类型（对自定义类型成员才可运算符重载）或者枚举类型的操作数</li><li>用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义</li><li>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参</li><li><strong>.*</strong> 、<strong>::</strong> 、<strong>sizeof </strong>、<strong>?: </strong>、<strong>.</strong> 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</li></ul>\n</blockquote>\n<h3 id=\"%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">赋值运算符重载</h3>\n<blockquote>\n<p>前面我们已经学习了拷贝构造，是拿同类型的对象去初始化另一个对象，那如果我不想用拷贝构造呢？</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tDate d1(2022, 5, 17);\n\tDate d2(2022, 5, 20);\n\tDate d3(d1);//拷贝构造 -- 一个存在的对象去初始化另一个要创建的对象\n\td2 = d1; //赋值重载/复制拷贝 -- 两个已经存在的对象之间赋值\n}</code></pre>\n<p>可不可以直接拿d1去赋值给d2呢？这就是我们要谈的赋值运算符重载。赋值运算符重载和上文的运算符重载是有点相似的。有了运算符重载的基础，写一个赋值重载还是很简单的。</p>\n<pre><code class=\"language-cpp\">//d2 = d1;  -&gt; d2.operator=(&amp;d2, d1);\nvoid operator=(const Date&amp; d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n}</code></pre>\n<p>但是这里的赋值重载是存在一定问题的，我们C语言的赋值是支持<span style=\"color:#956fe7;\">连等赋值</span>的，如下：</p>\n<pre><code class=\"language-cpp\">int i = 0, j, k;\nk = j = i;</code></pre>\n<p>我们把i赋值给j，随后把j作为返回值再赋值给k。要知道C++是建立在C的基础上的，刚刚我们写的赋值重载支持连等吗？</p>\n<p><img alt=\"\" height=\"746\" src=\"..\\..\\static\\image\\4cc59a4667e54c9f9e97ccae155f6cc4.png\" width=\"763\"/></p>\n<p>很显然是不支持的，<span style=\"color:#956fe7;\">原因就是当我把d1赋值给d2后，没有一个返回值来赋给d3</span>，这就导致出错。改正如下： </p>\n<pre><code class=\"language-cpp\">Date operator=(const Date&amp; d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n\treturn *this;\n}</code></pre>\n<p><img alt=\"\" height=\"716\" src=\"..\\..\\static\\image\\da14e8aace3949eda21b0a9e1de6d429.png\" width=\"1200\"/></p>\n<p>此外：这里的赋值重载还可进一步改进。</p>\n<ul><li><strong>改进1：</strong>刚才我们写的赋值重载是传值返回，传值返回会生成一个拷贝，会调用拷贝构造。如果出了作用域要让其对象还在我们就可以用传引用返回：</li><li><strong>改进2：</strong>有可能会存在这样的情况：d1=d1，像这样自己给自己赋值的情况还要再调用赋值重载函数属实没必要，所以我们还可以加个if条件判断。</li></ul>\n<p>修正如下：</p>\n<pre><code class=\"language-cpp\">\t//d2 = d1;  -&gt; d2.operator=(&amp;d2, d1);\n\tDate&amp; operator=(const Date&amp; d)\n\t{\n\t\tif (this != &amp;d) //不推荐写成if (*this != d) ，怕的是万一没有重载!=呢？，因为这里是对象的比较\n\t\t{\n\t\t\t_year = d._year;\n\t\t\t_month = d._month;\n\t\t\t_day = d._day;\n\t\t}\n\t\treturn *this;\n\t}</code></pre>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：</span></li></ul>\n<p><span style=\"color:#956fe7;\">operator赋值也是默认成员函数，我们不写赋值重载，编译器也会默认生成</span>，不过编译器完成的依旧是<span style=\"color:#fe2c24;\">值拷贝或浅拷贝</span>，像这个日期类就可以不写赋值重载：</p>\n<p><img alt=\"\" height=\"549\" src=\"..\\..\\static\\image\\21db66d178ed42a3bbee85c892ae7aeb.png\" width=\"1200\"/></p>\n<p>赋值重载和拷贝构造一样，<span style=\"color:#956fe7;\">我们不写，它会对内置类型完成值拷贝</span>，而像栈这样的就不能不写了，因为我们要写一个<span style=\"color:#fe2c24;\">深拷贝</span>的赋值重载才可以，理由和拷贝构造类似。 具体实现等真正谈到深拷贝再来。</p>\n<ul><li><span style=\"color:#fe2c24;\"><strong> 补充：</strong></span></li></ul>\n<pre><code class=\"language-cpp\">void TestDate2()\n{\n\tDate d1(2022, 5, 18);\n\tDate d3 = d1; //等价于 Date d3(d1);\n}</code></pre>\n<p>Date d3 = d1 是拷贝构造，不是赋值，<span style=\"color:#956fe7;\">拿一个对象初始化另一个对象是拷贝构造</span>。如下d2 =d1才是赋值：</p>\n<pre><code class=\"language-cpp\">void TestDate2()\n{\n\tDate d1(2022, 5, 18);\n    Date d2(2022, 5, 20);\n\tDate d3 = d1; //等价于 Date d3(d1); 是拷贝构造\n    d2 = d1; //两个已经存在的对象才是赋值\n}</code></pre>\n</blockquote>\n<h3 id=\"6%E3%80%81const%E6%88%90%E5%91%98\">6、const成员</h3>\n<h3 id=\"const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">const修饰类的成员函数</h3>\n<blockquote>\n<ul><li><span style=\"color:#956fe7;\">将const修饰的类成员函数称之为const成员函数</span>，const修饰类成员函数，实际修饰该成员函数<span style=\"color:#956fe7;\">隐含的this指针</span>，表明在该成员函数中<span style=\"color:#956fe7;\">不能对类的任何成员进行修改。</span></li></ul>\n<p>假如我现在有一个日期类，并且有如下的Func函数即调用情况：</p>\n<p><img alt=\"\" height=\"764\" src=\"..\\..\\static\\image\\e984392e7ef041ca9b3491076b9f3234.png\" width=\"983\"/></p>\n<p>很明显，这里Func函数d的调用Print()出错了，而d1调用Print()却没出错，为何呢？</p>\n<p>这里涉及到<span style=\"color:#956fe7;\">权限问题</span>。我们先把实际调用过程中，隐含的this指针写出来：</p>\n<p><img alt=\"\" height=\"483\" src=\"..\\..\\static\\image\\7c04ad54d86d4eaeb52f47760cb15a91.png\" width=\"901\"/></p>\n<p>Print()函数里的const修饰this本身，this不能修改，但是this可以初始化，接着我们要搞清楚&amp;d1和&amp;d的类型分别是啥：</p>\n<ul><li>&amp;d1：<span style=\"color:#fe2c24;\">Date*</span></li><li>&amp;d：<span style=\"color:#fe2c24;\">const Date*</span></li></ul>\n<ol><li>Date*传给Date* const没有问题，都是可读也可修改，所以d1调用Print()不会出错</li><li>而const Date* 指向的内容不能被修改，可是当它传给Date*时就出错了，因为Date*是可以修改的，这里传过去会导致<span style=\"color:#956fe7;\">权限放大</span>。所以当然d调用Print()函数报错。</li></ol>\n<p>解决办法：</p>\n<p>加上const去保护this指向的内容，也就是在Date*的前面加上const：</p>\n<pre><code class=\"language-cpp\">void Print(const Date* const this)\n{\n\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n}</code></pre>\n<p>但是这里又不能之间加上const，因为this指针是隐含的，你不能显示的将const写出来。因此，C++为了解决此问题，允许在函数后面加上const以达到刚才的效果：</p>\n<pre><code class=\"language-cpp\">void Print() const// 编译器默认处理成：void Print(const Date* const this)\n{\n\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n}</code></pre>\n<p>此时我const Date*传给const Date*就是<span style=\"color:#956fe7;\">权限不变</span>，自然不会出错了，同样我Date*传给const Date*就是<span style=\"color:#956fe7;\">权限缩小</span>也不会有问题。<span style=\"color:#fe2c24;\">因为权限不能放大，只能缩小或不变。</span></p>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：</span></li></ul>\n<p>建议成员函数中不修改成员变量的成员函数，都加上const，此时普通对象和const对象都可以调用。</p>\n<p><strong><span style=\"background-color:#fefcd8;\">补充：请思考下面几个问题：</span></strong></p>\n<ul><li><span style=\"color:#956fe7;\">const对象</span>可以调用<span style=\"color:#956fe7;\">非const成员函数</span>吗？</li></ul>\n<p>答案：不能，const调用非const是权限放大</p>\n<ul><li><span style=\"color:#956fe7;\">非const对象</span>可以调用<span style=\"color:#956fe7;\">const成员函数</span>吗？</li></ul>\n<p>答案：可以，此时权限缩小</p>\n<ul><li><span style=\"color:#fe2c24;\">const成员函数</span>内可以调用其它的<span style=\"color:#fe2c24;\">非const成员函数</span>吗？</li></ul>\n<p>答案：不可以，依旧是权限放大</p>\n<ul><li><span style=\"color:#fe2c24;\">非const成员函数</span>内可以调用其它的<span style=\"color:#fe2c24;\">const成员函数</span>吗？</li></ul>\n<p>答案：可以，权限缩小</p>\n</blockquote>\n<h3 id=\"7%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD\">7、取地址及const取地址操作符重载</h3>\n<blockquote>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n    //取地址&amp;重载\n\tDate* operator&amp;()\n\t{\n\t\treturn this;\n\t}\n    //const取地址&amp;重载\n\tconst Date* operator&amp;()const\n\t{\n\t\treturn this;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<p>当然，如果我们自己不写&amp;重载，编译器也会默认生成，可以通过打印来看看：</p>\n<p><img alt=\"\" height=\"686\" src=\"..\\..\\static\\image\\34723932d25444afa3e741321ba4546c.png\" width=\"1080\"/></p>\n<p>这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容！</p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-04 06:35:55", "summary": "目录、类的个默认成员函数、构造函数构造函数概念构造函数特性、析构函数析构函数概念析构函数特性、拷贝构造函数拷贝构造函数概念拷贝构造函数特性、赋值运算符重载运算符重载赋值运算符重载、成员修饰类的成员函数"}