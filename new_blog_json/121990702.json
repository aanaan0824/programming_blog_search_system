{"blogid": "121990702", "writerAge": "码龄2年", "writerBlogNum": "15", "writerCollect": "473", "writerComment": "85", "writerFan": "441", "writerGrade": "2级", "writerIntegral": "367", "writerName": "虚梦年华", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121990702.jpg", "writerRankTotal": "70796", "writerRankWeekly": "486947", "writerThumb": "161", "writerVisitNum": "62087", "blog_read_count": "5518", "blog_time": "已于 2022-04-29 16:18:35 修改", "blog_title": "C# 串口通讯", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3>简介</h3>\n<p>串口是目前最常用的通讯接口之一，常用的标准接口有RS-232和RS-485，ModbusRTU通讯协议使用的一般也是串口。</p>\n<p>Virtual Serial Port Driver是一款串口仿真软件，如果当前没有设备或者连接线，而又需要进行串口通讯测试，它将是你的得力助手。</p>\n<p>以下为官网介绍：</p>\n<blockquote>\n<p>Virtual COM Port Driver is a powerful technology designed specifically for those who develop, test, or debug serial port software and hardware. This solution will provide your system with as many virtual COM interfaces as you need.<br/><br/> If there are not enough physical COM ports or even if you don’t have a single real serial port on your computer, this dedicated software will come to the rescue. It will help you create pairs of virtual serial interfaces communicating via a virtual null-modem connection.<br/><br/> You can use Virtual Serial Port Driver as a standalone solution or integrate its advanced functionality into your own product.</p>\n</blockquote>\n<p>本文将使用Virtual Serial Port Driver软件虚拟两个串口，并用C#实现串口通讯。</p>\n<p>本文代码已上传至GitHub，项目地址如下：</p>\n<p><a class=\"link-info\" href=\"https://github.com/XMNHCAS/SerialPortWPFDemo\" title=\"https://github.com/XMNHCAS/SerialPortWPFDemo\">https://github.com/XMNHCAS/SerialPortWPFDemo</a></p>\n<hr/>\n<h3>软件下载</h3>\n<p><a class=\"link-info\" href=\"https://www.eltima.com/products/vspdxp/\" title=\"Virtual Serial Port Driver官网下载\">Virtual Serial Port Driver官网下载</a>（如需汉化版，可以自行百度）</p>\n<p><a class=\"link-info\" href=\"http://www.cmsoft.cn/resource/101.html\" title=\"UartAssist串口调试助手\">UartAssist串口调试助手</a>（免安装免注册，提供了各种校验算法、生成报文等功能）</p>\n<h3>创建虚拟串口</h3>\n<p>打开Virtual Serial Port Driver，设定需要创建的端口号，点击添加按钮就可以创建出两个相连的虚拟串行端口，如下图所示：</p>\n<p><img alt=\"\" height=\"372\" src=\"..\\..\\static\\image\\36806a50178a427089d98916a73dd588.png\" width=\"606\"/></p>\n<p> 此时打开UartAssist串口调试助手，可以看到刚刚已经创建出来的虚拟串口。</p>\n<p><img alt=\"\" height=\"554\" src=\"..\\..\\static\\image\\818369b081e044b4aead73444d8a8e34.png\" width=\"655\"/></p>\n<hr/>\n<h3>搭建界面 </h3>\n<p>首先创建一个WPF项目，接着按照个人喜好设计界面，可参考下图：</p>\n<p><img alt=\"\" height=\"572\" src=\"..\\..\\static\\image\\a33832a900644b668968b35dc2335246.png\" width=\"962\"/></p>\n<p>XAML如下：</p>\n<pre><code class=\"language-XML\">&lt;!--左右布局--&gt;\n    &lt;Grid Margin=\"10\"&gt;\n        &lt;Grid.ColumnDefinitions&gt;\n            &lt;ColumnDefinition Width=\"40*\"/&gt;\n            &lt;ColumnDefinition Width=\"60*\"/&gt;\n        &lt;/Grid.ColumnDefinitions&gt;\n        \n        &lt;!--控制面板--&gt;\n        &lt;GroupBox Header=\"控制面板\" Grid.Column=\"0\" Margin=\"10\" Padding=\"10\" &gt;\n            &lt;Grid&gt;\n                &lt;Grid.RowDefinitions&gt;\n                    &lt;RowDefinition/&gt;\n                    &lt;RowDefinition/&gt;\n                    &lt;RowDefinition/&gt;\n                    &lt;RowDefinition/&gt;\n                    &lt;RowDefinition/&gt;\n                    &lt;RowDefinition/&gt;\n                    &lt;RowDefinition/&gt;\n                &lt;/Grid.RowDefinitions&gt;\n                &lt;Grid.ColumnDefinitions&gt;\n                    &lt;ColumnDefinition Width=\"40*\"/&gt;\n                    &lt;ColumnDefinition Width=\"70*\"/&gt;\n                &lt;/Grid.ColumnDefinitions&gt;\n                &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" VerticalAlignment=\"Center\" Text=\"可用串口：\"  /&gt;\n                &lt;ComboBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"cbxSerialPortList\" ItemsSource=\"{Binding}\" \n                          Margin=\"5\" VerticalAlignment=\"Center\" /&gt;\n\n                &lt;TextBlock  Grid.Row=\"1\" Grid.Column=\"0\" VerticalAlignment=\"Center\" Text=\"连接状态：\"/&gt;\n                &lt;TextBlock x:Name=\"tbxStatus\"  Grid.Row=\"1\" Grid.Column=\"1\" VerticalAlignment=\"Center\" \n                           Margin=\"5,0,0,0\"  Text=\"未连接\" FontWeight=\"Bold\"/&gt;\n\n                &lt;TextBlock  Grid.Row=\"2\" Grid.Column=\"0\" VerticalAlignment=\"Center\" Text=\"波特率：\"/&gt;\n                &lt;ComboBox Grid.Row=\"2\" Grid.Column=\"1\" x:Name=\"cbxBaudRate\" ItemsSource=\"{Binding}\" \n                          Margin=\"5\" VerticalAlignment=\"Center\" /&gt;\n\n                &lt;TextBlock Grid.Row=\"3\" Grid.Column=\"0\" VerticalAlignment=\"Center\" Text=\"奇偶校验：\"/&gt;\n                &lt;ComboBox Grid.Row=\"3\" Grid.Column=\"1\" x:Name=\"cbxParity\" ItemsSource=\"{Binding}\" \n                          Margin=\"5\" VerticalAlignment=\"Center\" /&gt;\n\n                &lt;TextBlock Grid.Row=\"4\" Grid.Column=\"0\" VerticalAlignment=\"Center\" Text=\"数据位：\"/&gt;\n                &lt;ComboBox Grid.Row=\"4\" Grid.Column=\"1\" x:Name=\"cbxDataBits\" ItemsSource=\"{Binding}\" \n                          Margin=\"5\" VerticalAlignment=\"Center\" /&gt;\n\n                &lt;TextBlock Grid.Row=\"5\" Grid.Column=\"0\" VerticalAlignment=\"Center\" Text=\"停止位：\"/&gt;\n                &lt;ComboBox Grid.Row=\"5\" Grid.Column=\"1\" x:Name=\"cbxStopBits\" ItemsSource=\"{Binding}\" \n                          Margin=\"5\" VerticalAlignment=\"Center\" /&gt;\n                &lt;Button x:Name=\"btnSwitch\" Grid.Row=\"6\" Grid.Column=\"1\" Content=\"打开串口\" \n                        Margin=\"5\" Click=\"btnSwitch_Click\"/&gt;\n            &lt;/Grid&gt;\n        &lt;/GroupBox&gt;\n\n        &lt;!--消息面板--&gt;\n        &lt;Grid Grid.Column=\"1\" Margin=\"10\"&gt;\n            &lt;Grid.RowDefinitions&gt;\n                &lt;RowDefinition Height=\"45*\"/&gt;\n                &lt;RowDefinition Height=\"55*\"/&gt;\n            &lt;/Grid.RowDefinitions&gt;\n\n            &lt;!--发送消息--&gt;\n            &lt;GroupBox Grid.Row=\"0\" Header=\"发送消息\" Margin=\"0,10,0,0\" Padding=\"5\"&gt;\n                &lt;StackPanel VerticalAlignment=\"Center\"&gt;\n                    &lt;Grid VerticalAlignment=\"Center\" Margin=\"0,0,0,5\"&gt;\n                        &lt;Grid.ColumnDefinitions&gt;\n                            &lt;ColumnDefinition/&gt;\n                            &lt;ColumnDefinition/&gt;\n                            &lt;ColumnDefinition/&gt;\n                            &lt;ColumnDefinition/&gt;\n                        &lt;/Grid.ColumnDefinitions&gt;\n                        &lt;TextBlock Text=\"消息格式:\" Grid.Column=\"0\" VerticalAlignment=\"Center\"/&gt;\n                        &lt;ComboBox x:Name=\"cbxSendStatus\" Grid.Column=\"1\" ItemsSource=\"{Binding}\"\n                                  SelectionChanged=\"cbxSendStatus_SelectionChanged\" Margin=\"0,0,5,0\" /&gt;\n                        &lt;Button x:Name=\"btnClearSendText\" Grid.Column=\"2\" Content=\"清空\" Margin=\"0,0,5,0\" \n                                Click=\"btnClearSendText_Click\"/&gt;\n                        &lt;Button x:Name=\"btnSend\" Grid.Column=\"3\" Content=\"发送\" Click=\"btnSend_Click\"/&gt;\n                    &lt;/Grid&gt;\n                    &lt;RichTextBox x:Name=\"rbxSendMsg\" Height=\"40\" Margin=\"0,0,0,5\"/&gt;\n                &lt;/StackPanel&gt;\n            &lt;/GroupBox&gt;\n\n            &lt;!--接收消息--&gt;\n            &lt;GroupBox Grid.Row=\"1\" Header=\"接收消息\" Margin=\"0,10,0,0\" Padding=\"5\"&gt;\n                &lt;StackPanel VerticalAlignment=\"Center\"&gt;\n                    &lt;RichTextBox x:Name=\"rbxReceiveMsg\" Height=\"100\"/&gt;\n                &lt;/StackPanel&gt;\n            &lt;/GroupBox&gt;\n        &lt;/Grid&gt;\n    &lt;/Grid&gt;</code></pre>\n<hr/>\n<h3>SerialPort使用示例</h3>\n<p>SerialPort是C#提供的串行端口资源，位于System.IO.Ports，使用时需要引入此命名空间。通过此类可以很轻松地搭建串口通讯。</p>\n<p>使用示例如下：</p>\n<pre><code class=\"language-cs\">        //串口实例\n        SerialPort serialPort = new SerialPort();\n\n        /// &lt;summary&gt;\n        /// 串口参数\n        /// &lt;/summary&gt;\n        public void SetSerialPort()\n        {\n            //获取当前计算机所有的串行端口名\n            string[] serialProtArray = SerialPort.GetPortNames();\n\n            //端口名，如COM1\n            serialPort.PortName = \"COM1\";\n\n            //波特率\n            serialPort.BaudRate = 9600;\n\n            //奇偶校验\n            serialPort.Parity = Parity.None;\n\n            //数据位\n            serialPort.DataBits = 8;\n\n            //停止位\n            serialPort.StopBits = StopBits.One;\n\n            //串口接收数据事件\n            serialPort.DataReceived += ReceiveDataMethod;\n        }\n\n        /// &lt;summary&gt;\n        /// 打开串口\n        /// &lt;/summary&gt;\n        public void Open()\n        {\n            //打开串口\n            serialPort.Open();\n        }\n\n        /// &lt;summary&gt;\n        /// 关闭串口\n        /// &lt;/summary&gt;\n        public void Close()\n        {\n            serialPort.Close();\n        }\n\n        /// &lt;summary&gt;\n        /// 发送数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"data\"&gt;要发送的数据&lt;/param&gt;\n        public void SendDataMethod(byte[] data)\n        {\n            //获取串口状态，true为已打开，false为未打开\n            bool isOpen = serialPort.IsOpen;\n\n            if (!isOpen)\n            {\n                Open();\n            }\n\n            //发送字节数组\n            //参数1：包含要写入端口的数据的字节数组。\n            //参数2：参数中从零开始的字节偏移量，从此处开始将字节复制到端口。\n            //参数3：要写入的字节数。 \n            serialPort.Write(data, 0, data.Length);\n        }\n\n        /// &lt;summary&gt;\n        /// 发送数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"data\"&gt;要发送的数据&lt;/param&gt;\n        public void SendDataMethod(string data)\n        {\n            //获取串口状态，true为已打开，false为未打开\n            bool isOpen = serialPort.IsOpen;\n\n            if (!isOpen)\n            {\n                Open();\n            }\n\n            //直接发送字符串\n            serialPort.Write(data);\n        }\n\n        /// &lt;summary&gt;\n        /// 串口接收到数据触发此方法进行数据读取\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void ReceiveDataMethod(object sender, SerialDataReceivedEventArgs e)\n        {\n            //读取串口缓冲区的字节数据\n            byte[] result = new byte[serialPort.BytesToRead];\n            serialPort.Read(result, 0, serialPort.BytesToRead);\n        }</code></pre>\n<hr/>\n<h3>具体实现示例</h3>\n<p>设置窗体：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 窗体构造函数\n        /// &lt;/summary&gt;\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            //获取串口列表\n            cbxSerialPortList.DataContext = SerialPort.GetPortNames();\n            //设置可选波特率\n            cbxBaudRate.DataContext = new object[] { 9600, 19200 };\n            //设置可选奇偶校验\n            cbxParity.DataContext = new object[] { \"None\", \"Odd\", \"Even\", \"Mark\", \"Space\" };\n            //设置可选数据位\n            cbxDataBits.DataContext = new object[] { 5, 6, 7, 8 };\n            //设置可选停止位\n            cbxStopBits.DataContext = new object[] { 1, 1.5, 2 };\n            //设置发送模式\n            cbxSendStatus.DataContext = new object[] { \"文本\", \"字节\" };\n\n            //设置默认选中项\n            cbxSerialPortList.SelectedIndex = 0;\n            cbxBaudRate.SelectedIndex = 0;\n            cbxParity.SelectedIndex = 0;\n            cbxDataBits.SelectedIndex = 3;\n            cbxStopBits.SelectedIndex = 0;\n            cbxSendStatus.SelectedIndex = 0;\n\n            rbxReceiveMsg.Document.Blocks.Clear();\n            btnSend.IsEnabled = false;\n\n            //注册串口接收到数据事件的回调函数\n            serialPort.DataReceived += GetReceiveMsg;\n        }</code></pre>\n<p>串口开关事件：</p>\n<pre><code class=\"language-cs\"> /// &lt;summary&gt;\n        /// 打开或关闭串口\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void btnSwitch_Click(object sender, RoutedEventArgs e)\n        {\n            if (!serialPort.IsOpen)\n            {\n                //设定参数\n                serialPort.PortName = cbxSerialPortList.SelectedItem.ToString();\n                serialPort.BaudRate = (int)cbxBaudRate.SelectedItem;\n                serialPort.Parity = GetSelectedParity();\n                serialPort.DataBits = (int)cbxDataBits.SelectedItem;\n                serialPort.StopBits = GetSelectedStopBits();\n\n                try\n                {\n                    //打开串口\n                    serialPort.Open();\n                }\n                catch (Exception)\n                {\n                    MessageBox.Show(\"无法打开此串口，请检查是否被占用\");\n                    return;\n                }\n\n                //切换文本\n                tbxStatus.Text = \"已连接\";\n                btnSwitch.Content = \"关闭串口\";\n\n                //切换可用状态\n                cbxSerialPortList.IsEnabled = false;\n                cbxBaudRate.IsEnabled = false;\n                cbxParity.IsEnabled = false;\n                cbxDataBits.IsEnabled = false;\n                cbxStopBits.IsEnabled = false;\n\n                btnSend.IsEnabled = true;\n            }\n            else\n            {\n                if (serialPort != null)\n                {\n                    //关闭串口\n                    serialPort.Close();\n                }\n\n                //切换文本\n                tbxStatus.Text = \"未连接\";\n                btnSwitch.Content = \"打开串口\";\n\n                //切换可用状态\n                cbxSerialPortList.IsEnabled = true;\n                cbxBaudRate.IsEnabled = true;\n                cbxParity.IsEnabled = true;\n                cbxDataBits.IsEnabled = true;\n                cbxStopBits.IsEnabled = true;\n\n                btnSend.IsEnabled = false;\n            }\n        }</code></pre>\n<p>向串口发送数据：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 发送数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void btnSend_Click(object sender, RoutedEventArgs e)\n        {\n            //获取RichTextBox上的文本\n            string str = new TextRange(rbxSendMsg.Document.ContentStart, rbxSendMsg.Document.ContentEnd).Text;\n            if (string.IsNullOrEmpty(str.Replace(\"\\r\\n\", \"\")))\n            {\n                MessageBox.Show(\"未输入消息\");\n                return;\n            }\n\n            //判断读写模式\n            if (sendText)\n            {\n                //发送字符串\n                serialPort.Write(str);\n            }\n            else\n            {\n                str = str.Replace(\" \", \"\").Replace(\"\\r\\n\", \"\");\n\n                //将输入的16进制字符串两两分割为字符串集合\n                var strArr = Regex.Matches(str, \".{2}\").Cast&lt;Match&gt;().Select(m =&gt; m.Value);\n\n                //需要发送的字节数组\n                byte[] data = new byte[strArr.Count()];\n                \n                //循环索引\n                int temp = 0;\n\n                //将字符串集合转换为字节数组\n                foreach (string item in strArr)\n                {\n                    data[temp] = Convert.ToByte(item, 16);\n                    temp++;\n                }\n\n                //发送字节\n                serialPort.Write(data, 0, data.Length);\n            }\n\n            MessageBox.Show(\"发送成功\");\n        }</code></pre>\n<p>读取接收到的数据：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 获取接收到的数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void GetReceiveMsg(object sender, SerialDataReceivedEventArgs e)\n        {\n            //读取串口缓冲区的字节数据\n            byte[] result = new byte[serialPort.BytesToRead];\n            serialPort.Read(result, 0, serialPort.BytesToRead);\n\n            string str = $\"{DateTime.Now}\\n\";\n\n            //判断读写模式\n            //将接收到的字节数组转换为指定的消息格式\n            if (sendText)\n            {\n                str += $\"{Encoding.UTF8.GetString(result)}\";\n            }\n            else\n            {\n                for (int i = 0; i &lt; result.Length; i++)\n                {\n                    str += $\"{result[i].ToString(\"X2\")} \";\n                }\n            }\n\n            //在窗体中显示接收到的消息\n            SetRecMsgRbx(str.Trim());\n        }</code></pre>\n<p>需要注意串口接收到数据的时候触发的事件并不是主线程里面执行的，而是另开了一个新的线程，如果需要访问主线程并将数据在WPF窗口中显示，则需要通过委托的方式进行跨线程操作，如下所示：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 为显示接收消息的富文本框添加文本\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"str\"&gt;&lt;/param&gt;\n        private void SetRecMsgRbx(string str)\n        {\n            rbxReceiveMsg.Dispatcher.BeginInvoke(new Action(() =&gt;\n            {\n                Run run = new Run(str);\n                Paragraph p = new Paragraph();\n                p.Inlines.Add(run);\n                rbxReceiveMsg.Document.Blocks.Add(p);\n            }));\n        }</code></pre>\n<hr/>\n<h3>完整示例</h3>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.IO.Ports;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Markup;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace SerialPortWPF\n{\n    /// &lt;summary&gt;\n    /// MainWindow.xaml 的交互逻辑\n    /// &lt;/summary&gt;\n    public partial class MainWindow : Window\n    {\n        //串口实例\n        SerialPort serialPort = new SerialPort();\n\n        //是否发送文本\n        bool sendText = true;\n\n        /// &lt;summary&gt;\n        /// 窗体构造函数\n        /// &lt;/summary&gt;\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            //获取串口列表\n            cbxSerialPortList.DataContext = SerialPort.GetPortNames();\n            //设置可选波特率\n            cbxBaudRate.DataContext = new object[] { 9600, 19200 };\n            //设置可选奇偶校验\n            cbxParity.DataContext = new object[] { \"None\", \"Odd\", \"Even\", \"Mark\", \"Space\" };\n            //设置可选数据位\n            cbxDataBits.DataContext = new object[] { 5, 6, 7, 8 };\n            //设置可选停止位\n            cbxStopBits.DataContext = new object[] { 1, 1.5, 2 };\n            //设置发送模式\n            cbxSendStatus.DataContext = new object[] { \"文本\", \"字节\" };\n\n            //设置默认选中项\n            cbxSerialPortList.SelectedIndex = 0;\n            cbxBaudRate.SelectedIndex = 0;\n            cbxParity.SelectedIndex = 0;\n            cbxDataBits.SelectedIndex = 3;\n            cbxStopBits.SelectedIndex = 0;\n            cbxSendStatus.SelectedIndex = 0;\n\n            rbxReceiveMsg.Document.Blocks.Clear();\n            btnSend.IsEnabled = false;\n\n            //注册串口接收到数据事件的回调函数\n            serialPort.DataReceived += GetReceiveMsg;\n        }\n\n        /// &lt;summary&gt;\n        /// 打开或关闭串口\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void btnSwitch_Click(object sender, RoutedEventArgs e)\n        {\n            if (!serialPort.IsOpen)\n            {\n                //设定参数\n                serialPort.PortName = cbxSerialPortList.SelectedItem.ToString();\n                serialPort.BaudRate = (int)cbxBaudRate.SelectedItem;\n                serialPort.Parity = GetSelectedParity();\n                serialPort.DataBits = (int)cbxDataBits.SelectedItem;\n                serialPort.StopBits = GetSelectedStopBits();\n\n                try\n                {\n                    //打开串口\n                    serialPort.Open();\n                }\n                catch (Exception)\n                {\n                    MessageBox.Show(\"无法打开此串口，请检查是否被占用\");\n                    return;\n                }\n\n                //切换文本\n                tbxStatus.Text = \"已连接\";\n                btnSwitch.Content = \"关闭串口\";\n\n                //切换可用状态\n                cbxSerialPortList.IsEnabled = false;\n                cbxBaudRate.IsEnabled = false;\n                cbxParity.IsEnabled = false;\n                cbxDataBits.IsEnabled = false;\n                cbxStopBits.IsEnabled = false;\n\n                btnSend.IsEnabled = true;\n            }\n            else\n            {\n                if (serialPort != null)\n                {\n                    //关闭串口\n                    serialPort.Close();\n                }\n\n                //切换文本\n                tbxStatus.Text = \"未连接\";\n                btnSwitch.Content = \"打开串口\";\n\n                //切换可用状态\n                cbxSerialPortList.IsEnabled = true;\n                cbxBaudRate.IsEnabled = true;\n                cbxParity.IsEnabled = true;\n                cbxDataBits.IsEnabled = true;\n                cbxStopBits.IsEnabled = true;\n\n                btnSend.IsEnabled = false;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 切换读写模式\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void cbxSendStatus_SelectionChanged(object sender, SelectionChangedEventArgs e)\n        {\n            sendText = cbxSendStatus.SelectedItem.ToString() == \"文本\" ? true : false;\n        }\n\n        /// &lt;summary&gt;\n        /// 发送数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void btnSend_Click(object sender, RoutedEventArgs e)\n        {\n            //获取RichTextBox上的文本\n            string str = new TextRange(rbxSendMsg.Document.ContentStart, rbxSendMsg.Document.ContentEnd).Text;\n            if (string.IsNullOrEmpty(str.Replace(\"\\r\\n\", \"\")))\n            {\n                MessageBox.Show(\"未输入消息\");\n                return;\n            }\n\n            //判断读写模式\n            if (sendText)\n            {\n                //发送字符串\n                serialPort.Write(str);\n            }\n            else\n            {\n                str = str.Replace(\" \", \"\").Replace(\"\\r\\n\", \"\");\n\n                //将输入的16进制字符串两两分割为字符串集合\n                var strArr = Regex.Matches(str, \".{2}\").Cast&lt;Match&gt;().Select(m =&gt; m.Value);\n\n                //需要发送的字节数组\n                byte[] data = new byte[strArr.Count()];\n                \n                //循环索引\n                int temp = 0;\n\n                //将字符串集合转换为字节数组\n                foreach (string item in strArr)\n                {\n                    data[temp] = Convert.ToByte(item, 16);\n                    temp++;\n                }\n\n                //发送字节\n                serialPort.Write(data, 0, data.Length);\n            }\n\n            MessageBox.Show(\"发送成功\");\n        }\n\n        /// &lt;summary&gt;\n        /// 清空发送框的文本\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void btnClearSendText_Click(object sender, RoutedEventArgs e)\n        {\n            rbxSendMsg.Document.Blocks.Clear();\n        }\n\n        /// &lt;summary&gt;\n        /// 获取接收到的数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void GetReceiveMsg(object sender, SerialDataReceivedEventArgs e)\n        {\n            //读取串口缓冲区的字节数据\n            byte[] result = new byte[serialPort.BytesToRead];\n            serialPort.Read(result, 0, serialPort.BytesToRead);\n\n            string str = $\"{DateTime.Now}：\\n\";\n\n            //判断读写模式\n            //将接收到的字节数组转换为指定的消息格式\n            if (sendText)\n            {\n                str += $\"{Encoding.UTF8.GetString(result)}\";\n            }\n            else\n            {\n                for (int i = 0; i &lt; result.Length; i++)\n                {\n                    str += $\"{result[i].ToString(\"X2\")} \";\n                }\n            }\n\n            //在窗体中显示接收到的消息\n            SetRecMsgRbx(str.Trim());\n        }\n\n        /// &lt;summary&gt;\n        /// 为显示接收消息的富文本框添加文本\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"str\"&gt;&lt;/param&gt;\n        private void SetRecMsgRbx(string str)\n        {\n            rbxReceiveMsg.Dispatcher.BeginInvoke(new Action(() =&gt;\n            {\n                Run run = new Run(str);\n                Paragraph p = new Paragraph();\n                p.Inlines.Add(run);\n                rbxReceiveMsg.Document.Blocks.Add(p);\n            }));\n        }\n\n        /// &lt;summary&gt;\n        /// 获取窗体选中的奇偶校验\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private Parity GetSelectedParity()\n        {\n            switch (cbxParity.SelectedItem.ToString())\n            {\n                case \"Odd\":\n                    return Parity.Odd;\n                case \"Even\":\n                    return Parity.Even;\n                case \"Mark\":\n                    return Parity.Mark;\n                case \"Space\":\n                    return Parity.Space;\n                case \"None\":\n                default:\n                    return Parity.None;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 获取窗体选中的停止位\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private StopBits GetSelectedStopBits()\n        {\n            switch (Convert.ToDouble(cbxStopBits.SelectedItem))\n            {\n                case 1:\n                    return StopBits.One;\n                case 1.5:\n                    return StopBits.OnePointFive;\n                case 2:\n                    return StopBits.Two;\n                default:\n                    return StopBits.One;\n            }\n        }\n    }\n}\n</code></pre>\n<hr/>\n<h3>效果测试</h3>\n<p>文本收发： </p>\n<p><img alt=\"\" height=\"565\" src=\"..\\..\\static\\image\\28bb9d80e2094ccf8292eff8d022cb31.png\" width=\"1200\"/></p>\n<p>字节收发： </p>\n<p><img alt=\"\" height=\"600\" src=\"..\\..\\static\\image\\034653cacb3140718b957ca7e9e1de30.png\" width=\"1200\"/></p>\n<hr/>\n<h3>结尾</h3>\n<p>在C#中实现串口通讯是比较简单的，但是用到真实的设备通讯的时候，往往会涉及到一些报文格式的问题，而报文比较麻烦的就是计算校验码，这里提供常用的两种常用的校验算法：BCC异或校验、CRC16循环冗余校验。</p>\n<p>BCC：</p>\n<pre><code class=\"language-cs\">public static byte[] BCC(byte[] data)\n{\n    int temp = 0;\n    for (int index = 0; index &lt; data.Length; index++)\n    {\n        temp = temp ^ data[index];\n    }\n\n    byte[] result = new byte[1];\n\n    result[0] = Convert.ToByte(temp);\n\n    return result;\n}</code></pre>\n<p>CRC16：</p>\n<pre><code class=\"language-cs\">public static byte[] CRC16(string code)\n{\n    var strArr = Regex.Matches(code, \".{2}\").Cast&lt;Match&gt;().Select(m =&gt; m.Value);\n    byte[] pDataBytes = new byte[strArr.Count()];\n    int temp = 0;\n    foreach (var item in strArr)\n    {\n        pDataBytes[temp] = Convert.ToByte(item, 16);\n        temp++;\n    }\n    ushort crc = 0xffff;\n    ushort polynom = 0xA001;\n\n    for (int i = 0; i &lt; pDataBytes.Length; i++)\n    {\n        crc ^= pDataBytes[i];\n        for (int j = 0; j &lt; 8; j++)\n        {\n            if ((crc &amp; 0x01) == 0x01)\n            {\n                crc &gt;&gt;= 1;\n                crc ^= polynom;\n            }\n            else\n            {\n                crc &gt;&gt;= 1;\n            }\n        }\n    }\n\n    return BitConverter.GetBytes(crc);\n}</code></pre>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-29 16:18:35", "summary": "简介串口是目前最常用的通讯接口之一，常用的标准接口有和，通讯协议使用的一般也是串口。是一款串口仿真软件，如果当前没有设备或者连接线，而又需要进行串口通讯测试，它将是你的得力助手。以下为官网介绍：本文将"}