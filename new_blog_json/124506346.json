{"blogid": "124506346", "writerAge": "码龄2年", "writerBlogNum": "156", "writerCollect": "9129", "writerComment": "2471", "writerFan": "22570", "writerGrade": "7级", "writerIntegral": "13215", "writerName": "柠檬叶子C", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124506346.jpg", "writerRankTotal": "785", "writerRankWeekly": "635", "writerThumb": "6773", "writerVisitNum": "500510", "blog_read_count": "2502", "blog_time": "已于 2022-07-03 13:00:27 修改", "blog_title": "【C++要笑着学】深浅拷贝 | string 模拟实现 | 传统写法与现代写法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p> <img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\451dfef5a53e4c94a3ecbfb02d167973.png\" width=\"286\"/>  ​​​​​​ 🤣 爆笑教程 👉 <a href=\"https://blog.csdn.net/weixin_50502862/category_11602059.html\" title=\"《C++要笑着学》\">《C++要笑着学》</a> 👈 火速订阅<strong>  </strong>🔥</p>\n<p><img alt=\"\" height=\"123\" src=\"..\\..\\static\\image\\32974baa747043f9907e5bbd13639957.png\" width=\"679\"/></p>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\c52b4035e4864f4ba6cbbd9070bc53cd.png\" width=\"324\"/>  <strong> 本篇博客全站热榜排名：<span style=\"color:#be191c;\">2</span></strong></p>\n<p></p>\n<p><strong>💭 写在前面</strong></p>\n<p><img alt=\"\" height=\"110\" src=\"https://img-blog.csdnimg.cn/0ed16f946b2a44dc9e3bc89510902c12.gif\" width=\"180\"/> 本章将正式介绍深浅拷贝，在模拟实现 string 的同时带着去理解深浅拷贝。我们模拟实现 string类不是为了造更好的轮子，而是为了去学习它，理解它的本质！你自己造一次，心里会更清楚，也有利于加深对 string 的理解。</p>\n<p></p>\n<hr/>\n<h2 id=\"%E2%85%A0.%C2%A0%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D\">Ⅰ.  深浅拷贝</h2>\n<h3 id=\"0x00%20%E5%BC%95%E5%85%A5%EF%BC%9A\">0x00 引入：</h3>\n<p><img alt=\"\" height=\"41\" src=\"..\\..\\static\\image\\0b8acaba58854fa78391a2d4f49e38f0.png\" width=\"49\"/> 我们先来实现 string 的构造和析构：</p>\n<p>💬 string.h</p>\n<pre><code class=\"language-cpp\">namespace chaos {      // 命名空间\n\tclass string {   \n\tpublic:\n\t\tstring(const char* str) {\n            // ...\n\t\t}\n\t\t~string() {\n            // ...\n\t\t}\n\n\tprivate:\n\t\tchar* _str;\n\t};\n}</code></pre>\n<p>这里为了和原有的<span style=\"color:#4da8ee;\"> string </span>进行区分，我们搞一个命名空间给它们括起来。</p>\n<p>❓ 思考一个问题，构造函数能不能这样初始化呢？</p>\n<pre><code class=\"language-cpp\">string(char* str)\n\t: _str(str) {}\n</code></pre>\n<p><img alt=\"\" height=\"108\" src=\"..\\..\\static\\image\\1ebeee0dd2904cc39b5f3337be4ff820.png\" width=\"106\"/> 这是不行的，因为你初始化这个<span style=\"color:#4da8ee;\"> string </span>时，比如我们通常情况会这么写：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n}</code></pre>\n<p>这是一个常量字符串，退一万步来讲，就算它不是常量字符串，它也是一个指针，</p>\n<p>是不能被修改的，那我们后面要实现修改、插入删除，怎么扩容嘛？</p>\n<p><img alt=\"\" height=\"177\" src=\"https://img-blog.csdnimg.cn/77b279db8812475a9a9691896b7b3d65.gif\" width=\"214\"/></p>\n<p> 你就只能对堆上的空间扩容了，所以是不能这么写的！那该怎么写呢？</p>\n<p>💬 我们可以这么写：</p>\n<pre><code class=\"language-cpp\">string(const char* str)\n    : _str(new char[strlen(str) + 1]) {    // 开strlen大小的空间\n    strcpy(_str, str);\n}</code></pre>\n<p><img alt=\"\" height=\"72\" src=\"https://img-blog.csdnimg.cn/783adaa473ad4eef85f8899465b1bd73.gif\" width=\"73\"/>值得注意的是，这里要 <span style=\"color:#e6b223;\">strlen</span><span style=\"color:#0d0016;\">(str) + 1</span>，因为 <span style=\"color:#e6b223;\">strlen</span> 算的是有效字符的长度，没算 <span style=\"color:#be191c;\">\\0</span> 。</p>\n<p></p>\n<p>💬 然后我们实现析构，用 <span style=\"color:#956fe7;\">new</span>[] 对应的 <span style=\"color:#956fe7;\">delete</span>[] 来析构：</p>\n<pre><code class=\"language-cpp\">~string() {\n    delete[] _str;    // 释放空间\n\t_str = nullptr;   // 置空\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"132\" src=\"https://img-blog.csdnimg.cn/8601db3dac94434a8de92b685eea3193.gif\" width=\"235\"/> 我们来测试一下：</p>\n<p>💬 string.h</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace chaos {\n\tclass string {\n\tpublic:\n\t\tstring(const char* str)\n\t\t\t: _str(new char[strlen(str) + 1]) {\n\t\t\tstrcpy(_str, str);\n\t\t}\n\t\t~string() {\n\t\t\tdelete[] _str;\n\t\t\t_str = nullptr;\n\t\t}\n\tprivate:\n\t\tchar* _str;\n\t};\n\n\tvoid test_string1() {\n\t\tstring s1(\"hello world\");\n\t}\n}</code></pre>\n<p>💬 test.h</p>\n<pre><code class=\"language-cpp\">#include \"string.h\"\n\nint main(void)\n{\n\tchaos::test_string1();\n\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"133\" src=\"..\\..\\static\\image\\97a742d6139c4b0086a9b4e66c7de5f2.png\" width=\"546\"/></p>\n<p></p>\n<p>💬 此时我们改一下测试用例 <span style=\"color:#4da8ee;\">test_string1</span>，如果我们要用 <span style=\"color:#4da8ee;\">s1</span> 拷贝构造一下 <span style=\"color:#4da8ee;\">s2</span>：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n\tstring s2(s1);\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"361\" src=\"..\\..\\static\\image\\7b70c28f60144b2981ad4dd8781b5338.png\" width=\"509\"/></p>\n<p>🔑 详细解析：</p>\n<p><img alt=\"\" height=\"421\" src=\"..\\..\\static\\image\\b399bd46ae414d5f9105f0dc35ffd2fd.png\" width=\"447\"/></p>\n<p> <img alt=\"\" height=\"488\" src=\"..\\..\\static\\image\\5821ff1eccb24910913b41f2e4f87bfe.png\" width=\"536\"/></p>\n<p>❓ 如何解决这样的问题呢？</p>\n<p>我们 <span style=\"color:#4da8ee;\">s2</span> 拷贝构造你 <span style=\"color:#4da8ee;\">s1</span>，本意并不是想跟你指向一块空间！</p>\n<p>我们的本意是想让<span style=\"color:#4da8ee;\"> s2</span> 有一块自己的空间，并且能内容是<span style=\"color:#4da8ee;\"> s1</span> 里的<span style=\"color:#1c7331;\"> hello world</span></p>\n<p> <img alt=\"\" height=\"193\" src=\"..\\..\\static\\image\\4bec3b550be246279b2c5b9ea1efbd79.png\" width=\"428\"/></p>\n<p>所以这里就涉及到了深浅拷贝的问题，我们下面就来探讨一下深浅拷贝的问题。</p>\n<p></p>\n<h3 id=\"0x01%C2%A0%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98\">0x01  深浅拷贝问题</h3>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\6615ac064dd048cab6a766a6efc9f714.png\" width=\"46\"/> 举个最简单的例子 —— 拷贝就像是在抄作业！</p>\n<p><strong>浅拷贝：</strong>直接无脑照抄，连名字都不改。</p>\n<p>            <span style=\"color:#a5a5a5;\">（直接把内存无脑指过去）</span></p>\n<p><strong>深拷贝：</strong>聪明地抄，抄的像是我自己写的一样。</p>\n<p>          <span style=\"color:#a5a5a5;\">  （开一块一样大的空间，再把数据拷贝下来，指向我自己开的空间）</span></p>\n<p><img alt=\"\" height=\"270\" src=\"..\\..\\static\\image\\9c4bff41ac5a4cb0808a646e24ab5985.png\" width=\"482\"/></p>\n<p><span style=\"background-color:#f9eda6;\">浅拷贝就是原封不动地把成员变量按字节依次拷贝过去，</span></p>\n<p><span style=\"background-color:#f9eda6;\">深拷贝就是进行深一个层次的拷贝，不是直接拷贝，而是拷贝你指向的空间。</span></p>\n<p></p>\n<h3 id=\"0x02%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x02 拷贝构造的实现</h3>\n<p><img alt=\"\" height=\"100\" src=\"https://img-blog.csdnimg.cn/797313dda152439b989850478045b6e9.gif\" width=\"100\"/> 我们之前实现日期类的时候，用自动生成的拷贝构造（浅拷贝）是可以的，</p>\n<p>所以当时我们不用自己实现拷贝构造，让它默认生成就足够了。</p>\n<p><img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\44beffd9c6b34332b0b1e40bf3f852ed.png\" width=\"48\"/> 但是像 <span style=\"color:#4da8ee;\">string </span>这样的类，它的拷贝构造我们不得不亲自写。</p>\n<p></p>\n<p>💬 string 的拷贝构造：</p>\n<pre><code class=\"language-cpp\">/* s2(s1) */\nstring(const string&amp; s)\n\t: _str(new char[strlen(s._str) + 1]) {\n\tstrcpy(_str, s._str);\n}</code></pre>\n<p>🔍 我们监视看一下效果：</p>\n<p><img alt=\"\" height=\"395\" src=\"..\\..\\static\\image\\9dd17f7f0ed340388aa62f389ac1a6e5.png\" width=\"505\"/></p>\n<p></p>\n<h3 id=\"0x03%20%E8%B5%8B%E5%80%BC%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D\">0x03 赋值的深拷贝</h3>\n<p><img alt=\"\" height=\"157\" src=\"..\\..\\static\\image\\adea8fefc49945809f0c7ebcf8bf135f.png\" width=\"394\"/></p>\n<p> 💬 现在有一个<span style=\"color:#4da8ee;\"> s3</span>，如果我们想把<span style=\"color:#4da8ee;\"> s3</span> 赋值给 <span style=\"color:#4da8ee;\">s1</span>：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n\tstring s2(s1);\n\n\tstring s3(\"pig\");\n\ts1 = s3;\n}</code></pre>\n<p>如果你不自己实现赋值，就和之前一样，会是浅拷贝，也会造成崩溃：</p>\n<p><img alt=\"\" height=\"297\" src=\"..\\..\\static\\image\\17b1a0342a734f13944920d8c485575d.png\" width=\"403\"/></p>\n<p></p>\n<p>所以，我们仍然需要自己实现一个 <span style=\"color:#956fe7;\">operator=</span> ，实现思路如下：</p>\n<p><img alt=\"\" height=\"621\" src=\"..\\..\\static\\image\\f9499a93657245b5a932d3a81846d58b.png\" width=\"538\"/></p>\n<p> 💬 代码实现<span style=\"color:#956fe7;\"> operator= </span></p>\n<pre><code class=\"language-cpp\">/* s1 = s3 */\nstring&amp; operator=(const string&amp; s) {\n    if (this != &amp;s) {  // 防止自己给自己赋值\n\t\tdelete[] _str;                        // 释放原有的空间\n\t\t_str = new char[strlen(s._str) + 1];  // 开辟新的空间\n\t\tstrcpy(_str, s._str);                 // 把s3的值赋给s1\n\t}\n\n\treturn *this;\n}</code></pre>\n<p>🔑 代码解析：</p>\n<p>根据我们的实现思路，首先释放原有空间，然后开辟新的空间，</p>\n<p>最后把 <span style=\"color:#4da8ee;\">s3</span> 的值赋值给 <span style=\"color:#4da8ee;\">s1</span>。为了防止自己给自己赋值，我们可以判断一下。</p>\n<p></p>\n<p>这时我们还要考虑一个难以发现的问题，如果 <span style=\"color:#956fe7;\">new</span> 失败了怎么办？</p>\n<p><img alt=\"\" height=\"101\" src=\"..\\..\\static\\image\\99ef06ee812e4327b6c3156c5cd9dddd.png\" width=\"100\"/> 抛异常！抛异常！抛异常！</p>\n<p>失败了没问题，也不会走到 <span style=\"color:#e6b223;\">strcpy</span>，但问题是我们已经把原有的空间释放掉了，</p>\n<p>神不知鬼不觉地，走到析构那里二次释放可能会炸，所以我们得解决这个问题！</p>\n<p></p>\n<p>⚡ 我们可以试着把释放原有空间的步骤放到后面：</p>\n<p><img alt=\"\" height=\"782\" src=\"..\\..\\static\\image\\513708b253d84d019c0bbd776b137aef.png\" width=\"560\"/></p>\n<pre><code class=\"language-cpp\">/* s1 = s3 */\nstring&amp; operator=(const string&amp; s) {\n\tif (this != &amp;s) {  // 防止自己给自己赋值\t\n\t\tchar* tmp = new char[strlen(s._str) + 1];  // 开辟新的空间到tmp中\n\t\tstrcpy(tmp, s._str);                       // 把s3的值赋给 tmp\n\t\tdelete[] _str;                             // 释放原有的空间\n\t\t_str = tmp;                                // 把tmp的值赋给 s1\n\t}\n\n\treturn *this;\n}</code></pre>\n<p>🔑 代码解析：</p>\n<p>这样一来，就算是动态内存开辟失败了，我们也不用担心出问题了。</p>\n<p>这是更标准的实现方式，我们先去开辟空间，放到临时变量 <span style=\"color:#0d0016;\">tmp</span> 中，</p>\n<p><img alt=\"\" height=\"128\" src=\"https://img-blog.csdnimg.cn/7fdad05da2ec4aac94e441e091b622e6.gif\" width=\"128\"/><span style=\"color:#0d0016;\"> tmp</span> 没有翻车，再去释放原有的空间，最后再把<span style=\"color:#0d0016;\"> tmp </span>的值交付给 <span style=\"color:#4da8ee;\">s1</span>，</p>\n<p>这是非常保险的，有效避免了空间没开成还把<span style=\"color:#4da8ee;\"> s1</span> 空间释放掉的 \"偷鸡不成蚀把米\" 的事发生。</p>\n<p></p>\n<h2 id=\"%E2%85%A1.%C2%A0%20string%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">Ⅱ.  string 的实现</h2>\n<h3 id=\"0x00%20%E5%BC%95%E5%85%A5\">0x00 引入</h3>\n<p><img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\b105aa9fd35547d393808b55c142b696.png\" width=\"48\"/> 刚才我们为了方便讲解深浅拷贝的问题，有些地方所以没有写全，</p>\n<p> 是没有考虑增删查改的问题的，所以我们现在要增加一些成员：</p>\n<pre><code class=\"language-cpp\">private:\n\tchar*  _str;\n\tsize_t _size;\n\tsize_t _capacity;   // 有效字符的空间数，不算\\0</code></pre>\n<p></p>\n<h3 id=\"0x01%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20_size%20%E5%92%8C%20_capacity\">0x01 成员函数 _size 和 _capacity</h3>\n<p>💬 加上<span style=\"color:#0d0016;\"> _size</span> 和<span style=\"color:#0d0016;\"> _capacity</span> 后，在刚才实现的 <span style=\"color:#4da8ee;\">string </span>基础上修改完善：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nnamespace chaos \n{\n\tclass string {\n\tpublic:\n\tstring(const char* str) \n\t\t: _size(strlen(str)) \n\t\t, _capacity(_size) {\n\t\t_str = new char[_capacity + 1];     // 多开一个空间给\\0\n\t\tstrcpy(_str, str);\n\t}\n\t/* s2(s1) */\n\tstring(const string&amp; s)\n\t\t: _size(s._size)\n\t\t, _capacity(s._capacity) {\n\t\t_str = new char[_capacity + 1];\n\t\tstrcpy(_str, s._str);\n\t}\n\t/* s1 = s3 */\n\tstring&amp; operator=(const string&amp; s) {\n\t\tif (this != &amp;s) {                              // 防止自己给自己赋值\n\t\t\tchar* tmp = new char[s._capacity + 1];     // 开辟新的空间到tmp中\n\t\t\tstrcpy(tmp, s._str);                       // 把s3的值赋给 tmp\n\t\t\tdelete[] _str;                             // 释放原有的空间\n\t\t\t_str = tmp;                                // 把tmp的值赋给 s1\n\n\t\t\t_size = s._size;\n\t\t\t_capacity = s._capacity;\n\t\t}\n\n\t\treturn *this;\n\t}\n\t~string() {\n\t\tdelete[] _str; \n\t\t_str = nullptr;\n\t\t\t\n\t\t_size = _capacity = 0;\n\t}\n\n\tprivate:\n\tchar*  _str;\n\tsize_t _size;\n\tsize_t _capacity;   // 有效字符的空间数，不算\\0\n\t};\n}</code></pre>\n<p><img alt=\"\" height=\"107\" src=\"https://img-blog.csdnimg.cn/26635ae6aca04e0cab13cd675e028d7f.gif\" width=\"100\"/> 为了减少 <span style=\"color:#e6b223;\">strlen </span>的次数，我们在初始化列表里只处理<span style=\"color:#0d0016;\"> _size</span> 和<span style=\"color:#0d0016;\"> _capacity</span>。</p>\n<p></p>\n<h3 id=\"0x02%20c_str()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x02 c_str() 的实现</h3>\n<p>📚 <span style=\"color:#4da8ee;\">c_str</span>() 返回的是C语言字符串的指针常量，是可读不写的。</p>\n<p>💬<span style=\"color:#4da8ee;\"> c_str </span>的实现：</p>\n<pre><code class=\"language-cpp\">/* 返回C格式字符串：c_str */\nconst char* c_str() const {\n\treturn _str;\n}</code></pre>\n<p><span style=\"background-color:#f9eda6;\">const char*，因为是可读不可写的，所以我们需要用 const 修饰。</span></p>\n<p><span style=\"color:#4da8ee;\">c_str </span>返回的是当前字符串的首字符地址，这里我们直接 <span style=\"color:#956fe7;\">return</span> <span style=\"color:#0d0016;\">_str</span> 即可实现。</p>\n<p></p>\n<p><img alt=\"\" height=\"171\" src=\"..\\..\\static\\image\\daf36ffd15c843639b383a15e9b15ea4.png\" width=\"147\"/> 我们来测试一下：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n\tstring s2;\n\n\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下： </p>\n</blockquote>\n<p><img alt=\"\" height=\"152\" src=\"..\\..\\static\\image\\67898b2b13e44ed68c85b9a60cae8fe4.png\" width=\"473\"/></p>\n<p><span style=\"color:#a5a5a5;\">（c_str 是认 \\0 的，下面我们探讨不带参全缺省值给什么值的时候需要知道这个点）</span></p>\n<p></p>\n<h3 id=\"0x03%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">0x03 全缺省构造函数</h3>\n<p><img alt=\"\" height=\"111\" src=\"https://img-blog.csdnimg.cn/519ab58b0b98408f90505256422353a5.gif\" width=\"109\"/> 我们还要考虑不带参的情况，比如下面的 <span style=\"color:#0d0016;\">s2</span>：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");    // 带参\n\tstring s2;                   // 不带参\n}</code></pre>\n<p>💬 不带参初始化：</p>\n<pre><code class=\"language-cpp\">string()\n\t: _str(new char[1])\n\t, _size(0)\n\t, _capacity(0) {\n\t_str[0] = '\\0';\n}</code></pre>\n<p>这里我们开一个空间给 <span style=\"color:#be191c;\">\\0</span>，既然都这么写了，我们不如直接在缺省值上动手脚：</p>\n<pre><code class=\"language-cpp\">string(const char* str = \"\")\n\t: _size(strlen(str)) \n\t, _capacity(_size) {\n\t_str = new char[_capacity + 1];     // 多开一个空间给\\0\n\tstrcpy(_str, str);\n}</code></pre>\n<p>一般的类都是提供全缺省的，值得注意的是，这里缺省值给的是<span style=\"color:#1c7331;\"> \" \"</span></p>\n<p>有人看到指针 <span style=\"color:#ad720d;\">char* </span>就突发恶疾，这里缺省值就忍不住想给个空 <span style=\"color:#6eaad7;\">nullptr</span>：</p>\n<pre><code class=\"language-cpp\">string(const char* str = nullptr)</code></pre>\n<p><img alt=\"\" height=\"56\" src=\"..\\..\\static\\image\\2ff6e29127a742f5ac61421cf62dbee3.png\" width=\"119\"/> 不能给！给了就崩。因为 <span style=\"color:#e6b223;\">strlen</span> 是不会去检查空的，它是去找 <span style=\"color:#be191c;\">\\0</span> ，</p>\n<pre><code class=\"language-cpp\">\tvoid test_string2() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2;\n\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t\tcout &lt;&lt; s2.c_str() &lt;&lt; endl;\n\t}</code></pre>\n<p>也就相当于直接对这个字符串进行解引用了，这里的字符串又是空，所以会引发空指针问题。</p>\n<p>所以我们这里给的是一个空的字符串 <span style=\"color:#1c7331;\">\" \"</span>，<span style=\"background-color:#f9eda6;\">常量字符串默认就带有 \\0</span>，这样就不会出问题：</p>\n<pre><code class=\"language-cpp\">string(const char* str = \"\")</code></pre>\n<p><img alt=\"\" height=\"245\" src=\"..\\..\\static\\image\\d7b91c64ebc9440db7b3c47954389656.png\" width=\"434\"/></p>\n<p></p>\n<h3 id=\"0x04%C2%A0size()%20%E5%92%8C%20operator%5B%5D%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x04 size() 和 operator[] 的实现</h3>\n<p>💬 <span style=\"color:#4da8ee;\">size</span>() 的实现：</p>\n<pre><code class=\"language-cpp\">size_t size() const {\n\treturn _size;\n}</code></pre>\n<p><img alt=\"\" height=\"102\" src=\"..\\..\\static\\image\\841da3123c8a4fb39e17b34298ddd77b.png\" width=\"118\"/><span style=\"color:#4da8ee;\"> size</span>() 只需要返回成员函数<span style=\"color:#0d0016;\"> _size</span> 即可，考虑到不需要修改，我们加上<span style=\"color:#ad720d;\"> const</span>。</p>\n<p></p>\n<p>💬 <span style=\"color:#956fe7;\">operator[]</span> 的实现：</p>\n<pre><code class=\"language-cpp\">/* operator[] */\nchar&amp; operator[](size_t pos) {\n\treturn _str[pos];  // 返回字符串对应下标位置的元素\n}</code></pre>\n<p><img alt=\"\" height=\"46\" src=\"..\\..\\static\\image\\d7fbeedc13a444cc85fdfb641fa26025.png\" width=\"55\"/> 直接返回字符串对应下标位置的元素，</p>\n<p>因为返回的是一个字符，所以我们这里引用返回 <span style=\"color:#ad720d;\">char</span>。</p>\n<p></p>\n<p>我们来测试一下，遍历整个字符串，这样既可以测试到 <span style=\"color:#e6b223;\">size</span>() 也可以测试到<span style=\"color:#956fe7;\"> operator[]</span> ：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n\tstring s2;\n\n\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"139\" src=\"..\\..\\static\\image\\c292772a596440518bbc00ad86a17a5b.png\" width=\"432\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"43\" src=\"..\\..\\static\\image\\a7577949aca848fb92dbd7cf20f700fe.png\" width=\"52\"/> 我们再来测试一下 <span style=\"color:#956fe7;\">operator[] </span>的 \"写\" 功能：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n\tstring s2;\n\n\ts1[0] = 'F';\n\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"\" height=\"172\" src=\"..\\..\\static\\image\\8dc895b0cdbc43eaaee642691f6f9a6c.png\" width=\"573\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"101\" src=\"..\\..\\static\\image\\13b5737a3bf14e3db306f6f010e4668c.png\" width=\"100\"/> 普通对象可以调用，但是 <span style=\"color:#ad720d;\">const </span>对象呢？所以我们还要考虑一下<span style=\"color:#ad720d;\"> const </span>对象。</p>\n<p>💬 我们写一个 <span style=\"color:#ad720d;\">const </span>对象的重载版本：</p>\n<pre><code class=\"language-cpp\">const char&amp; operator[](size_t pos) const {\n\treturn _str[pos];\n}\n</code></pre>\n<p>因为返回的是 <span style=\"color:#0d0016;\">pos</span> 位置字符的 <span style=\"color:#ad720d;\">const</span> 引用，所以可读但不可写。</p>\n<p></p>\n<p>💬 最后我们还需要考虑一下越界的问题，这里我们使用<span style=\"color:#956fe7;\">断言</span>暴力处理一下：</p>\n<pre><code class=\"language-cpp\">#include &lt;assert.h&gt;\n...\n\nchar&amp; operator[](size_t pos) {\n\tassert(pos &lt; _size);\n\treturn _str[pos];\n}\n\nconst char&amp; operator[](size_t pos) const {\n\tassert(pos &lt; _size);\n\treturn _str[pos];\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"119\" src=\"https://img-blog.csdnimg.cn/8e8024d32efd4d68a34d522bffaa1e34.gif\" width=\"141\"/> 测试一下效果如何：</p>\n<pre><code class=\"language-cpp\">void test_string1() {\n\tstring s1(\"hello world\");\n\ts1[30];\n}</code></pre>\n<p><img alt=\"\" height=\"461\" src=\"..\\..\\static\\image\\e2965a2f7e674942827637f9950c23ad.png\" width=\"496\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A2.%20%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8\">Ⅲ. 实现迭代器</h2>\n<h3 id=\"0x00%20%E5%BC%95%E5%85%A5%20-%20%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8\">0x00 引入 - 再探迭代器</h3>\n<p>在上一章中，我们首次讲解迭代器，为了方便理解，我们当时解释其为像指针一样的类型。</p>\n<p><img alt=\"\" height=\"417\" src=\"..\\..\\static\\image\\082297cd0b9746d09804702e512d577d.png\" width=\"516\"/></p>\n<p>实际上，有没有一种可能，它就是一种指针呢？</p>\n<p>遗憾的是，<span style=\"background-color:#f9eda6;\">迭代器并非指针，而是类模板。</span> 只是它表现地像指针，模拟了指针的部分功能。</p>\n<p></p>\n<h3 id=\"0x01%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x01 迭代器的实现</h3>\n<p>实际上迭代器的实现非常简单，它就是一个 <span style=\"color:#ad720d;\">char*</span> 的指针罢了（但也不一定）。</p>\n<p>后面我们讲解 list 的时候它又™不是指针了，又是自定义类型了。如何评价？</p>\n<p><img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\3d52cf8949bd4abfa9930a0c9e305f83.png\" width=\"171\"/> 我的评价是 —— 似是而非。</p>\n<p>它是一个像指针的东西，有可能是指针有可能不是指针。</p>\n<p></p>\n<p>💬 实现迭代器的 <span style=\"color:#4da8ee;\">begin</span>() 和 <span style=\"color:#4da8ee;\">end</span>() ：</p>\n<pre><code class=\"language-cpp\">typedef char* iterator;\niterator begin() {\n\treturn _str;          // 返回第一个字符位置\n}\niterator end() {\n\treturn _str + _size;  // 返回最后一个数据的下一个位置\n}</code></pre>\n<p></p>\n<p>💬 我们来测试一下：</p>\n<pre><code class=\"language-cpp\">void test_string2() {\n\tstring s1(\"hello world\");\n\n\t// 迭代器写\n\tstring::iterator it = s1.begin();\n\twhile (it != s1.end()) {\n\t\t*it += 1;\n\t\tit++;\n\t}\n\t\t\n\t// 迭代器读\n\tit = s1.begin();   // 重置起点\n\twhile (it != s1.end()) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"150\" src=\"..\\..\\static\\image\\8bbbe736c04140c088b5a8d30be82268.png\" width=\"572\"/></p>\n<p></p>\n<h3 id=\"0x02%20const%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x02 const 迭代器的实现</h3>\n<p><img alt=\"\" height=\"100\" src=\"..\\..\\static\\image\\4d1b53b1a22b41adba6c7f9725bfcd32.png\" width=\"100\"/> 我们知道，<span style=\"color:#ad720d;\">const </span>迭代器就是可以读但是不可以写的迭代器。 </p>\n<p></p>\n<p>💬 const 迭代器：</p>\n<pre><code class=\"language-cpp\">typedef const char* const_iterator;\nconst_iterator begin() const {\n\treturn _str;          // 返回第一个字符位置\n}\nconst_iterator end() const {\n\treturn _str + _size;  // 返回最后一个数据的下一个位置\n}</code></pre>\n<p>这里用 <span style=\"color:#ad720d;\">const</span> 修饰，意味着解引用时可以读但不可以写。</p>\n<p></p>\n<h3 id=\"0x03%C2%A0%E5%86%8D%E5%BA%A6%E6%80%9D%E8%80%83%E8%BF%AD%E4%BB%A3%E5%99%A8\">0x03 再度思考迭代器</h3>\n<p><img alt=\"\" height=\"156\" src=\"..\\..\\static\\image\\318c38e48bfe48c6a5b6ced2d1747c2b.png\" width=\"137\"/></p>\n<p>它的底层是连续地物理空间，给原生指针++解引用能正好贴合迭代器的行为，就能做到遍历。</p>\n<p>但是对于链表和树型结构来说，迭代器的实现就没有这么简单了。</p>\n<p>但是，强大的迭代器通过统一的封装，无论是树、链表还是数组……</p>\n<p>它都能用统一的方式遍历，这就是迭代器的优势，也是它的强大之处。</p>\n<p></p>\n<h3 id=\"0x04%20%E5%86%8D%E7%9C%8B%E8%8C%83%E5%9B%B4%20for\">0x04 再探范围 for</h3>\n<p><img alt=\"\" height=\"223\" src=\"..\\..\\static\\image\\7dd4748e77504c18a235373bf681c391.png\" width=\"564\"/></p>\n<p>上一章讲 string 类对象的遍历时，我们讲的第三种方式就是范围 <span style=\"color:#956fe7;\">for</span>，回忆一下 ——</p>\n<p><img alt=\"\" height=\"184\" src=\"..\\..\\static\\image\\68c5dbdee20b4944b36df1537d019efb.png\" width=\"493\"/>（五毛特效）</p>\n<p>我们上一章提到过，我们现在就来演示一下范围 <span style=\"color:#956fe7;\">for </span>的实现：</p>\n<pre><code class=\"language-cpp\">for (auto e : s1) {\n\tcout &lt;&lt; e &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;</code></pre>\n<p>你会发现根本就不需要自己实现，你只要把迭代器实现好，范围<span style=\"color:#956fe7;\"> for</span> 直接就可以用。</p>\n<p><span style=\"background-color:#f9eda6;\">范围 for 的本质是由迭代器支持的，编译时范围 for 会被替换成迭代器。</span></p>\n<p><img alt=\"\" height=\"47\" src=\"..\\..\\static\\image\\e2d599e999f84f38a635fa12ba347654.png\" width=\"56\"/> 这么一看，又是自动加加，又是自动判断结束的范围 <span style=\"color:#956fe7;\">for</span>，好像也没那么回事儿。</p>\n<p></p>\n<p>📌 注意事项：</p>\n<p>它的替换是认 <span style=\"color:#4da8ee;\">begin</span> 和<span style=\"color:#4da8ee;\"> end</span> 的，我们可以试着把我们实现的迭代器<span style=\"color:#4da8ee;\"> begin</span> 的 b 改成大写 B 试试：</p>\n<pre><code class=\"language-cpp\">\t\ttypedef char* iterator;\n\t\titerator Begin() {\n\t\t\treturn _str;         \n\t\t}\n\t\titerator end() {\n\t\t\treturn _str + _size;  \n\t\t}</code></pre>\n<pre><code class=\"language-cpp\">void test_string2() {\n\tstring s1(\"hello world\");\n\tstring::iterator it = s1.Begin();\n\twhile (it != s1.end()) {\n\t\t*it += 1;\n\t\tit++;\n\t}\n\tit = s1.Begin();   // 重置起点\n\twhile (it != s1.end()) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n\t\n    for (auto e : s1) {\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"\" height=\"79\" src=\"..\\..\\static\\image\\e5d088206b2c443bb5c885bd256acb87.png\" width=\"94\"/> 迭代器是可以正常用的，但是范围<span style=\"color:#4da8ee;\"> for</span> 就寄了。</p>\n<p><img alt=\"\" height=\"132\" src=\"..\\..\\static\\image\\3114b2d86aed49c5b8a5d992024e270c.png\" width=\"592\"/></p>\n<p>因为它是按迭代器固定的名称去替换的，<span style=\"color:#4da8ee;\">begin</span> 和 <span style=\"color:#4da8ee;\">end</span>，</p>\n<p>如果你自己实现迭代器时没有按固定的规范去实现，</p>\n<p>比如 <span style=\"color:#4da8ee;\">begin</span> 取名为<span style=\"color:#0d0016;\"> start</span>，那范围<span style=\"color:#956fe7;\"> for</span> 就不支持了。</p>\n<p></p>\n<h2 id=\"%E2%85%A3.%C2%A0%20string%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9\">Ⅳ.  string的增删查改</h2>\n<h3 id=\"0x00%20reserve()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x00 reserve() 的实现</h3>\n<p>💬 我们先实现一下 <span style=\"color:#4da8ee;\">reserve</span> 增容：</p>\n<pre><code class=\"language-cpp\">/* 增容：reverse */\nvoid reserve(size_t new_capacity) {\n\tif (new_capacity &gt; _capacity) {\n\t\tchar* tmp = new char[new_capacity + 1];  // 开新空间\n\t\tstrcpy(tmp, _str);                       // 搬运\n\t\tdelete[] _str;                           // 释放原空间\n\n\t\t_str = tmp;                              // 没问题，递交给_str\n\t\t_capacity = new_capacity;                // 更新容量\n\t}\n}</code></pre>\n<p>这里可以检查一下是否真的需要增容，万一接收的 <span style=\"color:#0d0016;\">new_capacity</span> 比 <span style=\"color:#0d0016;\">_capacity </span>小，就不动。</p>\n<p><img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\c0c125b2816545a3bc60ae1083fb0bcf.png\" width=\"48\"/> 这里我们之前讲数据结构用的是<span style=\"color:#956fe7;\"> realloc</span>，现在我们熟悉熟悉用<span style=\"color:#956fe7;\"> new</span>，</p>\n<p> 还是用申请新空间、原空间数据拷贝到新空间，再释放空间地方式去扩容。</p>\n<p>我们的<span style=\"color:#0d0016;\"> _capacity</span> 存储的是有效字符，没算<span style=\"color:#be191c;\"> \\0</span>，所以这里还要 <span style=\"color:#ad720d;\">+1</span> 为 <span style=\"color:#be191c;\">\\0</span> 开一个空间。</p>\n<p><img alt=\"\" height=\"462\" src=\"..\\..\\static\\image\\d7f4cfc2b1e642a382bd5d7998f880ac.png\" width=\"586\"/></p>\n<p></p>\n<h3 id=\"0x01%C2%A0push_back()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x01 push_back() 的实现</h3>\n<p>💬 <span style=\"color:#4da8ee;\">push_back</span>：</p>\n<pre><code class=\"language-cpp\">/* 字符串尾插：push_back */\nvoid push_back(char append_ch) {\n\tif (_size == _capacity) {      // 检查是否需要增容\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2); \n\t}\n\n\t_str[_size] = append_ch;       // 插入要追加的字符\n\t_size++;\n\t_str[_size] = '\\0';            // 手动添加'\\0'\n}</code></pre>\n<p>首先检查是否需要增容，如果需要就调用我们上面实现的<span style=\"color:#956fe7;\"> reserve </span>函数，</p>\n<p>参数传递可以用三目操作符，防止容量是0的情况，0乘任何数都是0从而引发问题的情况。</p>\n<p>然后在 <span style=\"color:#be191c;\">\\0</span> 处插入要追加的字符 <span style=\"color:#0d0016;\">append_ch</span>，然后 <span style=\"color:#0d0016;\">_size++</span> 并手动添加一个新的<span style=\"color:#be191c;\"> \\0</span> 即可。</p>\n<p></p>\n<p>我们来测试一下效果如何：</p>\n<pre><code class=\"language-cpp\">\tvoid test_string4() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.push_back('!');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.push_back('A');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p> 🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"166\" src=\"..\\..\\static\\image\\97691753bc254c389ec260afca267cd4.png\" width=\"460\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"0x02%C2%A0append()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x02 append() 的实现</h3>\n<p>💬 <span style=\"color:#4da8ee;\">append</span>：</p>\n<pre><code class=\"language-cpp\">/* 字符串追加：append */\nvoid append(const char* append_str) {\n\tsize_t len = strlen(append_str);     // 计算要追加的字符串的长度\n\tif (_size + len &gt; _capacity) {       // 检查是否需要增容\n\t\treserve(_size + len);\n\t}\n\n\tstrcpy(_str + _size, append_str);    // 首字符+大小就是\\0位置\n\t_size += len;                        // 更新大小\n}</code></pre>\n<p><span style=\"color:#4da8ee;\">append </span>是追加字符串的，首先我们把要追加的字符串长度计算出来，</p>\n<p>然后看容量够不够，不够我们就交给 <span style=\"color:#e6b223;\">reserve </span>去扩容，扩 <span style=\"color:#0d0016;\">_size + len</span>，够用就行。</p>\n<p><img alt=\"\" height=\"443\" src=\"..\\..\\static\\image\\57634f33f182448587e1e705245c5e04.png\" width=\"526\"/></p>\n<p>这里我们甚至都不需要用<span style=\"color:#4da8ee;\"> </span><span style=\"color:#e6b223;\">strcat</span>，因为它的位置我们很清楚，不就在<span style=\"color:#0d0016;\"> _str + _size</span><span style=\"color:#0d0016;\"> </span>后面插入吗。</p>\n<p>用<span style=\"color:#e6b223;\"> strcat</span> 还需要遍历找到原来位置的<span style=\"color:#be191c;\"> \\0</span>，太麻烦了。</p>\n<p></p>\n<h3 id=\"0x03%C2%A0operator%2B%3D%C2%A0%E7%9A%84%E5%AE%9E%E7%8E%B0\">0x03 operator+= 的实现</h3>\n<p>这就是我们一章说的 \"用起来爽到飞起\" 的 += ，因为字符和字符串都可以用 += 去操作。</p>\n<p>所以我们需要两个重载版本，一个是字符的，一个是字符串的。</p>\n<p>我们不需要自己实现了，直接复用 <span style=\"color:#e6b223;\">push_back</span> 和 <span style=\"color:#e6b223;\">append</span> 就好了。</p>\n<p>💬<span style=\"color:#4da8ee;\"> </span><span style=\"color:#956fe7;\">operator</span><span style=\"color:#be191c;\">+= </span></p>\n<pre><code class=\"language-cpp\">/* operator+= */\nstring&amp; operator+=(char append_ch) {\n\tpush_back(append_ch);    // 复用push_back\n\treturn *this;\n}\nstring&amp; operator+=(const char* append_str) {\n\tappend(append_str);      // 复用append\n\treturn *this;\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"86\" src=\"https://img-blog.csdnimg.cn/25fa736f47a0442aa80d0539a2a2c38c.gif\" width=\"100\"/> 测试一下看看：</p>\n<pre><code class=\"language-cpp\">\tvoid test_string5() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1 += '!';\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1 += \"this is new data\";\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"164\" src=\"..\\..\\static\\image\\3c54dd2e7b2644cbbf76e401d64fa5d8.png\" width=\"483\"/></p>\n<p></p>\n<h3 id=\"%C2%A00x04%C2%A0%E5%AE%9E%E7%8E%B0%20insert()\">0x04 insert() 的实现</h3>\n<p>💬 <span style=\"color:#4da8ee;\">insert</span>：字符</p>\n<pre><code class=\"language-cpp\">/* 插入：insert */\nstring&amp; insert(size_t pos, char append_ch) {\n\tassert(pos &lt;= _size);\n\n\t// 检查是否需要增容\n\tif (_size == _capacity) {     \n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t}\n\t\t\t\n\t// 向后挪动数据\n\t//size_t end = _size;\n\t//while (end &gt;= (int)pos) {\n\t//\t_str[end + 1] = _str[end];\n\t//\tend--;\n\t//}\n\n\tsize_t end = _size + 1;\n\twhile (end &gt; pos) {\n\t\t_str[end] = _str[end - 1];\n\t\tend--;\n\t}\n\n\t// 插入\n\t_str[pos] = append_ch;\n\t_size++;\n\n\treturn *this;\n}\n</code></pre>\n<p></p>\n<p>💬<span style=\"color:#4da8ee;\"> insert</span>：字符串</p>\n<pre><code class=\"language-cpp\">string&amp; insert(size_t pos, const char* append_str) {\n\tassert(pos &lt;= _size);\n\tsize_t len = strlen(append_str);\n\n\t// 检查是否需要增容\n\tif (_size + len &gt; _capacity) {\n\t\treserve(_size + len);\n\t}\n\n\t// 向后挪动数据\n\tsize_t end = _size + len;\n\twhile (end &gt; pos + len - 1) {\n\t\t_str[end] = _str[end - len];\n\t\tend--;\n\t}\n\n\t// 插入\n\tstrncpy(_str + pos, append_str, len);\n\t_size += len;\n\n\treturn *this;\n}</code></pre>\n<p></p>\n<p>测试一下：</p>\n<pre><code class=\"language-cpp\">\tvoid test_string6() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.insert(0, 'X');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.insert(0, \"hahahaha\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"156\" src=\"..\\..\\static\\image\\65f69790677a4675acc696fe47d4895c.png\" width=\"433\"/></p>\n<p></p>\n<p><span style=\"color:#4da8ee;\">insert</span> 都实现了，那<span style=\"color:#4da8ee;\"> push_back</span> 和 <span style=\"color:#4da8ee;\">append</span> 直接复用，岂不美哉？</p>\n<p><img alt=\"\" height=\"218\" src=\"..\\..\\static\\image\\37c5ef5daf294b039160e2c2996c5639.png\" width=\"361\"/></p>\n<p>⚡ 修改<span style=\"color:#4da8ee;\"> push_back</span> 和<span style=\"color:#4da8ee;\"> append</span>：</p>\n<pre><code class=\"language-cpp\">/* 字符串尾插：push_back */\nvoid push_back(char append_ch) {\n\t//if (_size == _capacity) {      // 检查是否需要增容\n\t//\treserve(_capacity == 0 ? 4 : _capacity * 2); \n\t//}\n\n\t//_str[_size] = append_ch;       // 插入要追加的字符\n\t//_size++;\n\t//_str[_size] = '\\0';            // 手动添加'\\0'\n\n\tinsert(_size, append_ch);\n}\n\n/* 字符串追加：append */\nvoid append(const char* append_str) {\n\t//size_t len = strlen(append_str);     // 计算要追加的字符串的长度\n\t//if (_size + len &gt; _capacity) {       // 检查是否需要增容\n\t//\treserve(_size + len);\n\t//}\n\n\t//strcpy(_str + _size, append_str);    // 首字符+大小就是\\0位置\n\t//_size += len;                        // 更新大小\n\n\tinsert(_size, append_str);\n}</code></pre>\n<p></p>\n<p>测试一下 <span style=\"color:#4da8ee;\">push_back</span> 和<span style=\"color:#4da8ee;\"> append</span>，和复用它们两实现的 <span style=\"color:#956fe7;\">operator+=</span> 有没有问题：</p>\n<pre><code class=\"language-cpp\">\tvoid test_string4() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.push_back('!');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.push_back('A');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.append(\"this is new data\");\n\t}\n\n    void test_string5() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1 += \"!\";\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1 += \"this is new data\";\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"285\" src=\"..\\..\\static\\image\\138ca665ee224f4bb077b952c08d277a.png\" width=\"626\"/></p>\n<p></p>\n<h3 id=\"0x05%C2%A0%E5%AE%9E%E7%8E%B0%20resize()\">0x05 resize() 的实现</h3>\n<p>我们为了扩容，先实现了 <span style=\"color:#4da8ee;\">reverse</span>，现在我们再顺便实现一下 <span style=\"color:#4da8ee;\">resize</span>。</p>\n<p>这里再提一下<span style=\"color:#4da8ee;\"> reverse</span> 和 <span style=\"color:#4da8ee;\">resize </span>的区别：</p>\n<p></p>\n<p>resize 分给初始值和不给初始值的情况，所以有两种：</p>\n<p><img alt=\"\" height=\"75\" src=\"..\\..\\static\\image\\fe85879a2cc84f6dadb3a70d33c17f1a.png\" width=\"310\"/> 他们也是这么实现的。</p>\n<p>但是我们上面讲构造函数的时候说过，我们可以使用全缺省的方式，这样就可以二合一了。</p>\n<p><span style=\"color:#4da8ee;\">resize</span> 实现的难点是要考虑种种情况，我们来举个例子分析一下：</p>\n<p><img alt=\"\" height=\"255\" src=\"..\\..\\static\\image\\33017672b77049d89976225cb829e3c2.png\" width=\"328\"/></p>\n<p><strong>如果欲增容量比 _size 小的情况：</strong></p>\n<p><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\465c385101634fd5bb7cf933d927e5b1.png\" width=\"416\"/></p>\n<p>因为标准库是没有缩容的，所以我们实现的时候也不考虑去缩容。我们可以加一个 <span style=\"color:#be191c;\">\\0</span> 去截断。</p>\n<p></p>\n<p><strong>如果预增容量比 _size 大的情况：</strong></p>\n<p>resize 是开空间 + 初始化，开空间的工作我们就可以交给已经实现好的<span style=\"color:#e6b223;\"> reserve</span>，</p>\n<p>然后再写 resize 的初始化的功能，我们这里可以使用 <span style=\"color:#e6b223;\">memset</span> 函数。</p>\n<p><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\3c9e63d4a3634dd5b129ebf445db2a70.png\" width=\"587\"/></p>\n<p></p>\n<p>💬 <span style=\"color:#4da8ee;\">resize</span>：</p>\n<pre><code class=\"language-cpp\">/* resize */\nvoid resize(size_t new_capacity, char init_ch = '\\0') {\n\t// 如果欲增容量比_size小\n\tif (new_capacity &lt;= _size) {\n\t\t_str[new_capacity] = '\\0';      // 拿斜杠零去截断\n\t\t_size = new_capacity;           // 更新大小\n\t}\n\t// 欲增容量比_size大\n\telse {\n\t\tif (new_capacity &gt; _capacity) { \n\t\t\treserve(new_capacity);\n\t\t}\n\t\t// 起始位置，初始化字符，初始化个数\n\t\tmemset(_str + _size, init_ch, new_capacity - _size);\n\t\t_size = _capacity;\n\t\t_str[_size] = '\\0';\n\t}\n}</code></pre>\n<p id=\"\"></p>\n<h3 id=\"0x06%C2%A0%E5%AE%9E%E7%8E%B0%20find()\">0x06 find() 的实现</h3>\n<p>💬 <span style=\"color:#4da8ee;\">find</span>：查找字符</p>\n<pre><code class=\"language-cpp\">/* find */\nsize_t find(char aim_ch) {\n\tfor (size_t i = 0; i &lt; _size; i++) {\n\t\tif (aim_ch == _str[i]) { \n\t\t\t// 找到了\n\t\t\treturn i;    // 返回下标\n\t\t}\n\t}\n\t// 找不到\n\treturn npos;\n}</code></pre>\n<p><img alt=\"\" height=\"56\" src=\"..\\..\\static\\image\\ca593bb9d5314342800705677e4271de.png\" width=\"136\"/> 遍历整个字符串，找到了目标字符 <span style=\"color:#0d0016;\">aim_ch</span> 就返回对应的下标。</p>\n<p>如果遍历完整个字符串都没找到，就返回 <span style=\"color:#0d0016;\">npos</span>（找到库的来）。</p>\n<p> 💬 这个<span style=\"color:#0d0016;\"> npos</span> 我们可以在成员变量中定义：</p>\n<pre><code class=\"language-cpp\">...\n    private:\n\t\t/* 成员变量 */\n\t\tchar* _str;\n\t\tsize_t _size;\n\t\tsize_t _capacity;   // 有效字符的空间数，不算\\0\n    public:\n\t\tstatic const size_t npos;\n\t};\n\n\t/* 初始化npos */\n\tconst size_t string::npos = -1;   // 无符号整型的-1，即整型的最大值。\n\n...\n}</code></pre>\n<p></p>\n<p>💬 <span style=\"color:#4da8ee;\">find</span>：查找字符串</p>\n<pre><code class=\"language-cpp\">size_t find(const char* aim_str, size_t pos = 0) {\n\tconst char* ptr = strstr(_str + pos, aim_str);\n\tif (ptr == nullptr) {\n\t\treturn npos;\n\t}\n\telse {\n\t\treturn ptr - _str;  // 减开头\n\t}\n}</code></pre>\n<p><img alt=\"\" height=\"175\" src=\"..\\..\\static\\image\\0155aa43c71e43fb8081acdd46cc2a90.png\" width=\"597\"/></p>\n<p>这里我们可以用 <span style=\"color:#956fe7;\">strstr</span> 去找子串，如果找到了，返回的是子串首次出现的地址。如果没找到，返回的是空。所以我们这里可以做判断，如果是<span style=\"color:#6eaad7;\"> nullptr </span>就返回<span style=\"color:#0d0016;\"> npos</span>。如果找到了，就返回对应下标，子串地址 - 开头，就是下标了。</p>\n<p></p>\n<h3 id=\"0x07%C2%A0%E5%AE%9E%E7%8E%B0%20erase()\">0x07 erase() 的实现</h3>\n<p>💬 erase：</p>\n<pre><code class=\"language-cpp\">/* 删除：erase */\nstring&amp; erase(size_t pos, size_t len = npos) {\n\tassert(pos &lt; _size);\n\n\tif (len == pos || pos + len &gt;= _size) {\n\t\t_str[pos] = '\\0';    // 放置\\0截断\n\t\t_size = pos;\n\t}\n\telse {\n\t\tstrcpy(_str + pos, _str + pos + len);\n\t\t_size -= len;\n\t}\n\n\treturn *this;\n}</code></pre>\n<p></p>\n<p>测试一下：</p>\n<pre><code class=\"language-cpp\">\tvoid test_string7() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.erase(5, 2);   // 从第五个位置开始，删两个字符\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.erase(5, 20);  // 从第五个位置开始，删完\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"143\" src=\"..\\..\\static\\image\\0556054bd5774e93b512865ae8f80d86.png\" width=\"501\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A4.%20%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95\">Ⅴ. 传统写法和现代写法</h2>\n<h3 id=\"0x00%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95\">0x00 拷贝构造的传统写法</h3>\n<p><img alt=\"\" height=\"187\" src=\"..\\..\\static\\image\\864b87e3ec59478c91fcb244a4856bbb.png\" width=\"449\"/></p>\n<p>对于深拷贝，传统写法就是本本分分分地去完成深拷贝。</p>\n<p>💬 我们刚才实现的方式，用的就是传统写法：</p>\n<pre><code class=\"language-cpp\">/* 拷贝构造函数：s2(s1) */\nstring(const string&amp; s)         // 拷贝构造必须使用引用传参，一般用const修饰 \n\t: _size(s._size)            // 将s1的size给给s2\n\t, _capacity(s._capacity)    // 将s1的capacity给给s2\n{\n\t_str = new char[_capacity + 1];   // 开辟空间\n\tstrcpy(_str, s._str);             // 将s1字符串给给s2\n}</code></pre>\n<p>这就是传统写法，非常的老实。</p>\n<p></p>\n<h3 id=\"0x01%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95\">0x01 拷贝构造的现代写法</h3>\n<p>现在我们来介绍一种现代写法，它和传统写法本质工作是一样的，即完成深拷贝。</p>\n<p>现代写法的方式不是本本分分地去按着 Step 一步步干活，而是 \"投机取巧\" 地去完成深拷贝。</p>\n<p>💬 直接看代码：<span style=\"color:#be191c;\">（为了方便讲解，我们暂不考虑 _size 和 _capacity）</span></p>\n<pre><code class=\"language-cpp\">// 现代写法\nstring(const string&amp; s)\n\t: _str(nullptr)        // 为tmp置空做准备\n{\n\tstring tmp(s._str);    \n\tswap(_str, tmp._str);  // 交换\n}</code></pre>\n<p><img alt=\"\" height=\"560\" src=\"..\\..\\static\\image\\5b238f7ff977400f87d402cb977d3366.png\" width=\"620\"/></p>\n<p><img alt=\"\" height=\"185\" src=\"..\\..\\static\\image\\0a884ed12acc46adbe25cf9afd113093.png\" width=\"139\"/>现代写法的本质就是复用了构造函数。</p>\n<p>我想拷贝，但我又不想自己干，我把活交给工具人<span style=\"color:#4da8ee;\"> swap </span>来帮我干。妙啊！资本家看了都说好！</p>\n<p></p>\n<p>❓ 我们为什么要在初始化列表中，给 <span style=\"color:#0d0016;\">_str</span> 个空指针：</p>\n<pre><code class=\"language-cpp\">string(const string&amp; s)\n\t: _str(nullptr)</code></pre>\n<p>我们可以设想一下，如果我们不对他进行处理，那么它的默认指向会是个随机值。</p>\n<p><img alt=\"\" height=\"91\" src=\"..\\..\\static\\image\\cd94cae9e645484da17111e6d2d1debe.png\" width=\"397\"/></p>\n<p>这样交换看上去没啥问题，确实能完成深拷贝，但是会引发一个隐患！</p>\n<p><span style=\"color:#0d0016;\">tmp</span> 是一个局部对象，我们把 <span style=\"color:#4da8ee;\">s2</span> 原来的指针和 <span style=\"color:#0d0016;\">tmp </span>交换了，那么 <span style=\"color:#0d0016;\">tmp </span>就成了个随机值了。</p>\n<p><span style=\"color:#0d0016;\">tmp</span> 出了作用域要调用析构函数，对随机值指向的空间进行释放，怎么释放？</p>\n<p>都不是你自己的 <span style=\"color:#956fe7;\">new</span> / <span style=\"color:#956fe7;\">malloc</span> 出来的，你还硬要对它释放，就可能会引发崩溃。</p>\n<p>但是 <span style=\"color:#956fe7;\">delete</span> /<span style=\"color:#956fe7;\"> free </span>一个空，是不会报错的，因为会进行一个检查。</p>\n<p>所以是可以<span style=\"color:#956fe7;\"> delete</span> 一个空的，我们这里初始化列表中把 <span style=\"color:#6eaad7;\">nullptr</span> 给<span style=\"color:#0d0016;\"> _str</span>，</p>\n<p>是为了交换完之后， <span style=\"color:#6eaad7;\">nullptr</span> 能交到<span style=\"color:#0d0016;\"> tmp </span>手中，这样<span style=\"color:#0d0016;\"> tmp</span> 出了作用域调用析构函数就不会翻车了。</p>\n<p>🐞 我们来看看效果如何：</p>\n<p><img alt=\"\" height=\"116\" src=\"..\\..\\static\\image\\ce567ac514ea4e2d87069472daca81c5.png\" width=\"416\"/></p>\n<p></p>\n<p>💬 如果还是不放心，我们还可以在析构函数那进行一个严格的检查：</p>\n<pre><code class=\"language-cpp\">/* 析构函数 */\n~string() {\n\tif (_str != nullptr) {\n\t\tdelete[] _str;\n\t\t_str = nullptr;\n\t}\n\t_size = _capacity = 0;\n}</code></pre>\n<p></p>\n<h3 id=\"0x02%20%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95\">0x02 赋值重载的现代写法</h3>\n<p><img alt=\"\" height=\"222\" src=\"..\\..\\static\\image\\99348f95ac52429ab51061824750337a.png\" width=\"478\"/></p>\n<p> 💬 传统写法：</p>\n<pre><code class=\"language-cpp\">/* 赋值重载：s1 = s3 */\nstring&amp; operator=(const string&amp; s) {\n\tif (this != &amp;s) {                              // 防止自己给自己赋值  \n\t\tchar* tmp = new char[s._capacity + 1];     // Step1：先在tmp上开辟新的空间\n\t\tstrcpy(tmp, s._str);                       // Step2：把s3的值赋给tmp\n\t\tdelete[] _str;                             // Step3：释放原有的空间\n\t\t_str = tmp;                                // Step4：把tmp的值赋给s1\n\n\t\t// 把容量和大小赋过去\n\t\t_size = s._size;      \n\t\t_capacity = s._capacity;\n\t}\n\n\treturn *this;   // 结果返回*this\n}</code></pre>\n<p><img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\e034e9f7e379479489d7ce1793c626e8.png\" width=\"50\"/> 传统写法，全都自己干，自己开空间自己拷贝数据。</p>\n<p></p>\n<p>💬 现代写法：复用拷贝构造</p>\n<pre><code class=\"language-cpp\">/* 赋值重载：s1 = s3 */\nstring&amp; operator=(const string&amp; s) {\n\tif (this != &amp;s) {\n\t\tstring tmp(s);   // 复用拷贝构造\n\t\tswap(_str, tmp._str);\n\t}\n\n\treturn *this;\n}</code></pre>\n<p><img alt=\"\" height=\"193\" src=\"..\\..\\static\\image\\fb815c99368c436faebb9258276657dc.png\" width=\"594\"/></p>\n<p>我们先通过 <span style=\"color:#4da8ee;\">s3 </span>拷贝构造出<span style=\"color:#0d0016;\"> tmp</span>，这样<span style=\"color:#0d0016;\"> tmp</span> 就是 <span style=\"color:#0d0016;\">_str </span>的工具人了。</p>\n<p><span style=\"color:#0d0016;\">tmp</span> 里的 \"<span style=\"color:#1c7331;\">pig\"</span> ，<span style=\"color:#4da8ee;\">s1 </span>看的简直是垂涎欲滴，我们让<span style=\"color:#0d0016;\"> tmp </span>和 <span style=\"color:#4da8ee;\">s1</span> 交换一下</p>\n<p><img alt=\"\" height=\"239\" src=\"..\\..\\static\\image\\65e4897894564d63ad04fea0caca6f4d.png\" width=\"592\"/></p>\n<p>交换完之后，正好让<span style=\"color:#4da8ee;\"> tmp </span>出作用域调用析构函数，属实是一石二鸟的美事。</p>\n<p>把<span style=\"color:#4da8ee;\"> tmp </span>压榨的干干净净，还让 <span style=\"color:#4da8ee;\">tmp</span> 帮忙把屁股擦干净（释放空间）。</p>\n<p></p>\n<p>⚡ 还有更简洁的写法：</p>\n<pre><code class=\"language-cpp\">/* 赋值重载：s1 = s3 */\nstring&amp; operator=(string s) {\n\tswap(_str, s._str);\n\treturn *this;\n}</code></pre>\n<p>和上面的写法本质是一样的。这种写法不用引用传参，它利用了拷贝构造。</p>\n<p>这里的形参<span style=\"color:#0d0016;\"> s</span> 就充当了<span style=\"color:#0d0016;\"> tmp</span>，<span style=\"color:#0d0016;\">s</span> 就是<span style=\"color:#0d0016;\"> </span><span style=\"color:#4da8ee;\">s3</span> 的拷贝，再把<span style=\"color:#0d0016;\"> s1 </span>和 <span style=\"color:#0d0016;\">s </span>交换。简直是物尽其用！</p>\n<p></p>\n<p>📌 注意：但是这种写法也有小缺点，可能会导致自己给自己赋值时地址被换。</p>\n<p>你会发现我们这里没有加个<span style=\"color:#956fe7;\"> if</span> 去判断自己给自己赋值的问题了。</p>\n<p>因为这里没办法判断自己给自己赋值了。之前 <span style=\"color:#0d0016;\">s </span>就是 <span style=\"color:#4da8ee;\">s3</span>，<span style=\"color:#956fe7;\">this </span>就是<span style=\"color:#4da8ee;\"> s1</span>。</p>\n<p>现在<span style=\"color:#956fe7;\"> this </span>还是<span style=\"color:#4da8ee;\"> s1</span>，但是 <span style=\"color:#0d0016;\">s</span> 已经不是<span style=\"color:#4da8ee;\"> s3 </span>了，所以判断不到自己</p>\n<pre><code class=\"language-cpp\">if (this != &amp;s)   ？？？？？？\n     👆      👆\n     s1      s1</code></pre>\n<p><img alt=\"\" height=\"46\" src=\"..\\..\\static\\image\\eedccf94614a472bb7c72a9487f3b515.png\" width=\"52\"/> 所以这里加上 <span style=\"color:#956fe7;\">if</span> 判断也没用。但是其实也没太大问题，谁会自己给自己赋值啊。</p>\n<p></p>\n<h3 id=\"0x03%20%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B\">0x03 整体代码改进</h3>\n<p>我们现在再去考虑 <span style=\"color:#0d0016;\">_size </span>和 <span style=\"color:#0d0016;\">_capacity</span>，我们来把之前写的传统写法都改成现代写法。</p>\n<p>💬 拷贝构造函数：s2(s1)</p>\n<pre><code class=\"language-cpp\">/* 拷贝构造函数：s2(s1) */\nstring(const string&amp; s)\n\t: _str(nullptr)        // 为tmp置空做准备\n\t, _size(0)\n\t, _capacity(0)\n{\n\tstring tmp(s._str);\n\n\tswap(_str, tmp._str);\n\tswap(_size, tmp._size);\n\tswap(_capacity, tmp._capacity);\n}\n\n</code></pre>\n<p></p>\n<p>💬 赋值重载函数：s1 = s3</p>\n<pre><code class=\"language-cpp\">/* 赋值重载：s1 = s3 */\nstring&amp; operator=(string s) {\n\tswap(_str, s._str);\n\tswap(_size, s._size);\n\tswap(_capacity, s._capacity);\n\n\treturn *this;\n}</code></pre>\n<p>这里也是进行交换的，真是跟<span style=\"color:#0d0016;\"> tmp</span> 交换改成了跟 <span style=\"color:#0d0016;\">s</span> 交换。</p>\n<p>我们不如写一个 <span style=\"color:#4da8ee;\">Swap</span> 函数：</p>\n<pre><code class=\"language-cpp\">void Swap(string&amp; s) {\n\tswap(_str, s._str);\n\tswap(_size, s._size);\n\tswap(_capacity, s._capacity);\n}</code></pre>\n<p></p>\n<p>这样就很简单了 ——</p>\n<pre><code class=\"language-cpp\">/* 拷贝构造函数：s2(s1) */\nstring(const string&amp; s)\n\t: _str(nullptr)        // 为tmp置空做准备\n\t, _size(0)\n\t, _capacity(0)\n{\n\tstring tmp(s._str);\n\tSwap(tmp);             // this-&gt;Swap(tmp);\n}\n\n/* 赋值重载：s1 = s3 */\nstring&amp; operator=(string s) {\n\tSwap(s);\n\treturn *this;\n}</code></pre>\n<p></p>\n<h3 id=\"0x04%20%E6%80%BB%E7%BB%93\">0x04 总结</h3>\n<p><img alt=\"\" height=\"47\" src=\"..\\..\\static\\image\\3935c44138fe460d8b6835369a4bde0f.png\" width=\"58\"/> 现代写法在 string 中体现的优势还不够大，因为好像和传统写法差不多。</p>\n<p> 但是到后面我们实现 vector、list 的时候，你会发现现代写法的优势真的是太大了。</p>\n<p>现代写法写起来会更简单些，比如如果是个链表，传统写法就不是 <span style=\"color:#956fe7;\">strcpy</span> 这么简单的了，</p>\n<p>你还要一个一个结点拷贝过去，但是现代写法只需要调用 <span style=\"color:#956fe7;\">swap </span>交换一下就可以了。</p>\n<p>现代写法更加简洁，只是在<span style=\"color:#956fe7;\"> string</span> 这里优势体现的不明显罢了，我们后面可以慢慢体会。<br/>  </p>\n<p></p>\n<h2 id=\"%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">Ⅵ. operator 运算符重载</h2>\n<h3>0x00 引入</h3>\n<p>学日期类的时候我们就说过，我们只需实现 &lt; 和 ==，剩下的都可以复用解决。</p>\n<p></p>\n<h3 id=\"0x00%20operator%3C\">0x00 operator&lt;</h3>\n<p>💬 我们在全局实现：</p>\n<pre><code class=\"language-cpp\">/* s1 &lt; s2*/\nbool operator&lt;(const string&amp; s1, const string&amp; s2) {\n\tsize_t i1 = 0, i2 = 0;\n\twhile (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {\n\t\tif (s1[i1] &lt; s2[i2]) {\n\t\t\treturn true;\n\t\t} \n\t\telse if (s1[i1] &gt; s2[i2]) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\ti1++;\n\t\t\ti2++;\n\t\t}\n\t}\n\treturn i2 &lt; s2.size() ? true : false;\n}</code></pre>\n<p>当然，我们还可以实现的更简单些，直接用 <span style=\"color:#ad720d;\">strcmp</span> 偷个懒：</p>\n<pre><code class=\"language-cpp\">/* s1 &lt; s2*/\nbool operator&lt;(const string&amp; s1, const string&amp; s2) {\n\treturn strcmp(s1.c_str(), s2.c_str()) &lt; 0;\n}</code></pre>\n<p></p>\n<h3 id=\"0x01%20operator%3D\">0x01 operator=</h3>\n<p>💬 全局作用域下：</p>\n<pre><code class=\"language-cpp\">/* s1 == s2 */\nbool operator==(const string&amp; s1, const string&amp; s2) {\n\treturn strcmp(s1.c_str(), s2.c_str()) == 0;\n}</code></pre>\n<p></p>\n<h3 id=\"0x02%20%E5%89%A9%E4%B8%8B%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%A4%8D%E7%94%A8\">0x02 剩下的直接复用</h3>\n<p>💬<span style=\"color:#956fe7;\"> operator&lt;=</span></p>\n<pre><code class=\"language-cpp\">\t/* s1 &lt;= s2 */\n\tbool operator&lt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn s1 &lt; s2 || s1 == s2;\n\t}\n</code></pre>\n<p></p>\n<p>💬 <span style=\"color:#956fe7;\">operator&gt;</span></p>\n<pre><code class=\"language-cpp\">    /* s1 &gt; s2 */\n\tbool operator&gt;(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt;= s2);\n\t}</code></pre>\n<p></p>\n<p>💬 <span style=\"color:#956fe7;\">operator&gt;=</span></p>\n<pre><code class=\"language-cpp\">\t/* s1 &gt;= s2 */\n\tbool operator&gt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt; s2);\n\t}</code></pre>\n<p></p>\n<p>💬 <span style=\"color:#956fe7;\">operator!=</span></p>\n<pre><code class=\"language-cpp\">\t/* s1 != s2 */\n\tbool operator!=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 == s2);\n\t}\n</code></pre>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96\">Ⅶ.  流插入和流提取</h2>\n<h3>0x00 引入</h3>\n<p><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\fb7ed51284cf437b840b59b741b408e7.png\" width=\"79\"/> 我们当时实现日期类的流插入和流提取时，也详细讲过这些，当时讲解了友元。</p>\n<p> 在友元那一章我们说过 \"占参问题\" ，这里就不再多做解释了。</p>\n<p>如需复习猛戳 👇</p>\n<p><a href=\"https://blog.csdn.net/weixin_50502862/article/details/123616212\" title=\"【C++要笑着学】友元 | 初始化列表 | 关键字explicit | 静态成员static | 内部类\">【C++要笑着学】友元 | 初始化列表 | 关键字explicit | 静态成员static | 内部类</a></p>\n<p></p>\n<p>如果我们重载成成员函数，第一个位置就会被隐含的 this 指针占据。</p>\n<p>这样实现出来的流插入必然会不符合我们的使用习惯，所以我们选择在全局实现。</p>\n<p>在全局里不存在隐含的<span style=\"color:#956fe7;\"> this</span> 指针了。</p>\n<p></p>\n<h3 id=\"0x01%20%E5%AE%9E%E7%8E%B0%20operator%3C%3C\">0x01 operator&lt;&lt; 的实现</h3>\n<p>💬 <span style=\"color:#956fe7;\">operator&lt;&lt;</span></p>\n<pre><code class=\"language-cpp\">// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)\nostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {\n\t//for (auto ch : s) {\n\t//\tout &lt;&lt; ch;\n\t//}\n\n\tfor (size_t i = 0; i &lt; s.size(); i++) {\n\t\tout &lt;&lt; s[i];\n\t}\n\n\treturn out;\n}</code></pre>\n<p></p>\n<h3 id=\"0x02%20%E5%AE%9E%E7%8E%B0%20operator%3E%3E\">0x02 operator&gt;&gt; 的实现</h3>\n<p>💬 <span style=\"color:#956fe7;\">operator&gt;&gt;</span></p>\n<pre><code class=\"language-cpp\">// cin &gt;&gt;\nistream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {\n\tchar ch = in.get();\n\twhile (ch == '\\n') {\n\t\ts += ch;\n\t\tch = in.get();\n\t}\n\n\treturn in;\n}</code></pre>\n<p></p>\n<h2 id=\"%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">Ⅷ.  完整代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\nnamespace chaos\n{\n\tclass string {\n\tpublic:\n\t\t/* 构造函数 */\n\t\tstring(const char* str = \"\")\n\t\t\t: _size(strlen(str))        // 计算出字符串str的大小\n\t\t\t, _capacity(_size) {        // 初始容量等于字符串大小\n\n\t\t\t_str = new char[_capacity + 1];   // 开辟一块 \"容量+1\" 大小的空间 (_capacity存的是有效字符）\n\t\t\tstrcpy(_str, str);                // 将传入的字符串str复制到 _str中\n\t\t}\n\n\t\tvoid Swap(string&amp; tmp) {\n\t\t\tswap(_str, tmp._str);\n\t\t\tswap(_size, tmp._size);\n\t\t\tswap(_capacity, tmp._capacity);\n\t\t}\n\n\t\t/* 拷贝构造函数：s2(s1) \n\t\tstring(const string&amp; src)\n\t\t\t: _size(src._size)                // 拷贝string大小\n\t\t\t, _capacity(src._capacity) {      // 拷贝string容量\n\n\t\t\t// 拷贝string内容\n\t\t\t_str = new char[src._capacity + 1];        // 开辟一块和src相同容量的空间\n\t\t\tstrcpy(_str, src._str);\t\t\t\t\t   // 将src中的_str内容拷贝到自己的_str中\n\t\t}\n\t\t*/\n\t\tstring(const string&amp; src)\n\t\t\t: _str(nullptr)\n\t\t\t, _size(0)\n\t\t\t, _capacity(0) {\n\n\t\t\tstring tmp(src._str);   // 拷贝构造一个src\n\t\t\tSwap(tmp);              // 现代写法：交换\n\t\t}\n\t\n\n\t\t/* 赋值重载：s1 = s3\n\t\tstring&amp; operator=(const string&amp; src) {\n\t\t\t// 防止自己跟自己赋值\n\t\t\tif (this != &amp;src) {\n\t\t\t\t// 1. 暂时用tmp开辟一块相同的空间\n\t\t\t\tchar* tmp = new char[src._capacity + 1];\n\t\t\t\t// 2. 把src的值复制给tmp\n\t\t\t\tstrcpy(tmp, src._str);\n\t\t\t\t// 3. 释放this原空间\n\t\t\t\tdelete[] _str;\n\t\t\t\t// 4. 没翻车，把tmp交付给_src\n\t\t\t\t_str = tmp;\n\n\t\t\t\t_size = src._size;\n\t\t\t\t_capacity = src._capacity;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\tstring&amp; operator=(const string&amp; src) {\n\t\t\t// 防止自己跟自己赋值\n\t\t\tif (this != &amp;src) {\n\t\t\t\tstring tmp(src);   // 复用拷贝构造\n\t\t\t\tSwap(tmp);\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\t*/\n\t\tstring&amp; operator=(string src) {\n\t\t\tSwap(src);    // 正好调用拷贝构造，不如让形参充当tmp\n\t\t\treturn *this;\n\t\t}\n\n\n\t\t/* 返回C格式的字符串：c_str */\n\t\tconst char* c_str() const {\n\t\t\treturn _str;\n\t\t}\n\n\t\t/* 求字符串大小：size() */\n\t\tsize_t size() const {\n\t\t\treturn _size;\n\t\t}\n\n\t\t/* operator[] */\n\t\tchar&amp; operator[](size_t pos) {\n\t\t\tassert(pos &lt; _size);\n\t\t\treturn _str[pos];  // 返回字符串对应下标位置的元素\n\t\t}\n\t\tconst char&amp; operator[](size_t pos) const {\n\t\t\tassert(pos &lt; _size);\n\t\t\treturn _str[pos];\n\t\t}\n\n\t\t/* 迭代器 */\n\t\ttypedef char* iterator;\n\t\titerator begin() { \n\t\t\treturn _str;            // 返回第一个字符的位置\n\t\t}\n\t\titerator end() {\n\t\t\treturn _str + _size;    // 返回最后一个字符的位置\n\t\t}\n\n\t\t/* const迭代器 */\n\t\ttypedef const char* const_iterator;\n\t\tconst_iterator begin() const {\n\t\t\treturn _str;\n\t\t}\n\t\tconst_iterator end() const {\n\t\t\treturn _str + _size;\n\t\t}\n\n\t\t/* reserve() */\n\t\tvoid reserve(size_t new_capacity) {\n\t\t\tif (new_capacity &gt; _capacity) {               // 检查是否真的需要扩容\n\t\t\t\tchar* tmp = new char[new_capacity + 1];   // 开空间\n\t\t\t\tstrcpy(tmp, _str);\t\t\t\t\t\t  // 先搬运数据到tmp\n\n\t\t\t\t_str = tmp;\t\t\t\t\t\t\t\t  // 没翻车，递交给_str\n\t\t\t\t_capacity = new_capacity;\t\t\t\t  // 更新容量\n\t\t\t}\n\t\t}\n\n\t\t/* 字符尾插：push_back() */\n\t\tvoid push_back(char append_ch) {\n\t\t\t/*\n\t\t\tif (_size == _capacity) {                         // 检查是否需要扩容\n\t\t\t\treserve(_capacity == 0 ? 4 : _capacity * 2);  // 首次给4，其他情况默认扩2倍\n\t\t\t}\n\n\t\t\t_str[_size] = append_ch;     // 插入要追加的字符\n\t\t\t_size++;\t\t\t\t\t\t \n\t\t\t_str[_size] = '\\0';\t         // 手动添加'\\0'\n\t\t\t*/\n\n\t\t\tinsert(_size, append_ch);\n\t\t}\n\n\t\t/* 字符串追加：append() */\n\t\tvoid append(const char* append_str) {\n\t\t\t/*\n\t\t\tsize_t len = strlen(append_str);      // 计算出要追加的字符串的长度\n\t\t\tif (_size + len &gt; _capacity) {\t\t  // 检查是否需要扩容\n\t\t\t\treserve(_size + len);\n\t\t\t}\n\n\t\t\tstrcpy(_str + _size, append_str);      // 首字符+大小，就是'\\0'位置\n\t\t\t_size += len;\t\t\t\t\t\t   // 更新大小\n\t\t\t*/\n\t\t\t\n\t\t\tinsert(_size, append_str);\n\t\t}\n\n\t\t/* operator+= */\n\t\tstring&amp; operator+=(char append_ch) {\n\t\t\tpush_back(append_ch);\n\t\t\treturn *this;\n\t\t}\n\t\tstring&amp; operator+=(const char* append_str) {\n\t\t\tappend(append_str);\n\t\t\treturn *this;\n\t\t}\n\n\t\t/* insert */\n\t\tstring&amp; insert(size_t pos, char append_ch) {\n\t\t\tassert(pos &lt;= _size);\n\n\t\t\tif (_size == _capacity) {\t\t// 检查是否需要扩容\n\t\t\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t\t\t}\n\n\t\t\t// 向后挪动数据\n\t\t\tsize_t end = _size + 1;\n\t\t\twhile (end &gt; pos) {\n\t\t\t\t_str[end] = _str[end - 1];\n\t\t\t\tend--;\n\t\t\t}\n\n\t\t\t// 插入\n\t\t\t_str[pos] = append_ch;\n\t\t\t_size++;\n\n\t\t\treturn *this;\n\t\t}\n\t\tstring&amp; insert(size_t pos, const char* append_str) {\n\t\t\tassert(pos &lt;= _size);\n\t\t\tsize_t len = strlen(append_str);\n\n\t\t\tif (_size + len &gt; _capacity) {    // 检查是否需要增容\n\t\t\t\treserve(_size + len);\n\t\t\t}\n\n\t\t\t// 向后挪动数据\n\t\t\tsize_t end = _size + len;\n\t\t\twhile (end &gt; pos + len - 1) {\n\t\t\t\t_str[end] = _str[end - len];\n\t\t\t\tend--;\n\t\t\t}\n\n\t\t\t// 插入\n\t\t\tstrncpy(_str + pos, append_str, len);\n\t\t\t_size += len;\n\n\t\t\treturn *this;\n\t\t}\n\n\t\t/* resize */\n\t\tvoid resize(size_t new_capacity, char init_ch = '\\0') {\n\t\t\t// 如果欲增容量比_size小\n\t\t\tif (new_capacity &lt;= _size) {\n\t\t\t\t_str[new_capacity] = '\\0';      // 拿斜杠零去截断\n\t\t\t\t_size = new_capacity;           // 更新大小\n\t\t\t}\n\t\t\t// 欲增容量比_size大\n\t\t\telse {\n\t\t\t\tif (new_capacity &gt; _capacity) {\n\t\t\t\t\treserve(new_capacity);\n\t\t\t\t}\n\t\t\t\t// 起始位置，初始化字符，初始化个数\n\t\t\t\tmemset(_str + _size, init_ch, new_capacity - _size);\n\t\t\t\t_size = _capacity;\n\t\t\t\t_str[_size] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\t/* find */\n\t\tsize_t find(char aim_ch) {\n\t\t\tfor (size_t i = 0; i &lt; _size; i++) {\n\t\t\t\tif (aim_ch == _str[i]) {\n\t\t\t\t\t// 找到了\n\t\t\t\t\treturn i;    // 返回下标\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 找不到\n\t\t\treturn npos;\n\t\t}\n\t\tsize_t find(const char* aim_str, size_t pos = 0) {\n\t\t\tconst char* ptr = strstr(_str + pos, aim_str);\n\t\t\tif (ptr == nullptr) {\n\t\t\t\treturn npos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ptr - _str;  // 减开头\n\t\t\t}\n\t\t}\n\n\t\t/* 删除：erase */\n\t\tstring&amp; erase(size_t pos, size_t len = npos) {\n\t\t\tassert(pos &lt; _size);\n\n\t\t\tif (len == pos || pos + len &gt;= _size) {\n\t\t\t\t_str[pos] = '\\0';    // 放置\\0截断\n\t\t\t\t_size = pos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrcpy(_str + pos, _str + pos + len);\n\t\t\t\t_size -= len;\n\t\t\t}\n\n\t\t\treturn *this;\n\t\t}\n\n\t\t/* 析构函数 */\n\t\t~string() {\n\t\t\tif (_str != nullptr) {\n\t\t\t\tdelete[] _str;\n\t\t\t\t_str = nullptr;\n\t\t\t}\n\t\t\t_size = _capacity = 0;\n\t\t}\n\n\tprivate:\n\t\t/* 成员变量 */\n\t\tchar* _str;\n\t\tsize_t _size;\n\t\tsize_t _capacity;\n\n\tpublic:\n\t\tstatic const size_t npos;\n\t};\n\n\t/* 初始化npos */\n\tconst size_t string::npos = -1;   // 无符号整型的-1，即整型最大值\n\n\t/* s1 &lt; s2*/\n\tbool operator&lt;(const string&amp; s1, const string&amp; s2) {\n\t\t/*\n\t\tsize_t i1 = 0, i2 = 0;\n\t\twhile (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {\n\t\t\tif (s1[i1] &lt; s2[i2]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (s1[i1] &gt; s2[i2]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti1++;\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\t\treturn i2 &lt; s2.size() ? true : false;\n\t\t*/\n\n\t\treturn strcmp(s1.c_str(), s2.c_str()) &lt; 0;\n\t}\n\n\t/* s1 == s2 */\n\tbool operator==(const string&amp; s1, const string&amp; s2) {\n\t\treturn strcmp(s1.c_str(), s2.c_str()) == 0;\n\t}\n\n\t/* s1 &lt;= s2 */\n\tbool operator&lt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn s1 &lt; s2 || s1 == s2;\n\t}\n\n\t/* s1 &gt; s2 */\n\tbool operator&gt;(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt;= s2);\n\t}\n\n\t/* s1 &gt;= s2 */\n\tbool operator&gt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt; s2);\n\t}\n\n\n\t/* s1 != s2 */\n\tbool operator!=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 == s2);\n\t}\n\n\t// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)\n\tostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {\n\t\t/*\n\t\tfor (auto ch : s) {\n\t\t\tout &lt;&lt; ch;\n\t\t}\n\t\t*/\n\n\t\tfor (size_t i = 0; i &lt; s.size(); i++) {\n\t\t\tout &lt;&lt; s[i];\n\t\t}\n\n\t\treturn out;\n\t}\n\n\t// cin &gt;&gt;\n\tistream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {\n\t\tchar ch = in.get();\n\t\twhile (ch == '\\n') {\n\t\t\ts += ch;\n\t\t\tch = in.get();\n\t\t}\n\n\t\treturn in;\n\t}\n\n\n\n\t/* 测试用 */\n\tvoid test_string1() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2(s1);\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t\tcout &lt;&lt; s2.c_str() &lt;&lt; endl;\n\n\t\tstring s3(\"pig\");\n\t\tcout &lt;&lt; s3.c_str() &lt;&lt; endl;\n\n\t\ts1 = s3;\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n\n\tvoid test_string2() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2;\n\n\t\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n\n\tvoid test_string3() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2;\n\n\t\ts1[0] = 'F';\n\t\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n\n\tvoid test_string4() {\n\t\tstring s1(\"hello world\");\n\n\t\t// 迭代器写\n\t\tstring::iterator it = s1.begin();\n\t\twhile (it != s1.end()) {\n\t\t\t*it += 1;\n\t\t\tit++;\n\t\t}\n\n\t\t// 迭代器读\n\t\tit = s1.begin();   // 重置起点\n\t\twhile (it != s1.end()) {\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\tit++;\n\t\t}\n\t}\n\n\tvoid test_string5() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.push_back('!');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.push_back('A');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n\n\tvoid test_string6() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1 += '!';\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1 += \"this is new data\";\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n\n\tvoid test_string7() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.insert(0, 'X');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.insert(0, \"hahahaha\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n\n\tvoid test_string8() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.erase(5, 2);   // 从第五个位置开始，删两个字符\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t\ts1.erase(5, 20);  // 从第五个位置开始，删完\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\n\t}\n}\n\n</code></pre>\n<p></p>\n<p></p>\n<hr/>\n<p style=\"text-align:right;\"><strong>📜 参考资料</strong></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">. C++reference[EB/OL]. []. http://www.cplusplus.com/reference/.</span></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p>\n<blockquote>\n<p>📌<strong> [ 笔者 ]   </strong>王亦优</p>\n<p>📃<strong> [ 更新 ]   </strong>2022.5.6</p>\n<p>❌<strong> [ 勘误 ] </strong>  /* 暂无 */</p>\n<p>📜<strong> [ 声明 ]</strong>   由于作者水平有限，本文有错误和不准确之处在所难免，本人也很想知道这些错误，恳望读者批评指正！</p>\n</blockquote>\n<p>本章完。</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-03 13:00:27", "summary": "爆笑教程《要笑着学》《要笑着学》火速订阅本篇博客全站热榜排名：写在前面本章将正式介绍深浅拷贝，在模拟实现的同时带着去理解深浅拷贝。我们模拟实现类不是为了造更好的轮子，而是为了去学习它，理解它的本质！你"}