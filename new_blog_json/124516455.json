{"blogid": "124516455", "writerAge": "码龄1年", "writerBlogNum": "34", "writerCollect": "1178", "writerComment": "1472", "writerFan": "3111", "writerGrade": "5级", "writerIntegral": "3802", "writerName": "<vince>", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124516455.jpg", "writerRankTotal": "4665", "writerRankWeekly": "696", "writerThumb": "1376", "writerVisitNum": "41713", "blog_read_count": "653", "blog_time": "于 2022-04-30 20:28:52 发布", "blog_title": "详解双向带头循环链表~", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-kimbie-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<br/>\n<blockquote>\n<p><strong><font color=\"red\"> 年轻是我们唯一拥有权利去编织梦想的时光！💓💓💓</font></strong></p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#_5\">•🌙写在前面</a></li><li><a href=\"#_1_11\">• 🍋知识点1：线性表</a></li><li><ul><li><a href=\"#__21__13\">• 🌰2.1 线性表的概念及分类</a></li><li><ul><li><a href=\"#1_14\">•🔥1.线性表的概念</a></li><li><a href=\"#2_24\">•🔥2.线性表的分类</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_2_30\">• 🍋知识点2：线性表之链表</a></li><li><ul><li><a href=\"#__21__32\">• 🌰2.1 链表的概念及分类</a></li><li><ul><li><a href=\"#1_33\">•🔥1.链表的概念</a></li><li><a href=\"#2_38\">•🔥2.链表的分类</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_3_55\">• 🍋知识点3：双向带头循环链表</a></li><li><ul><li><a href=\"#__31__57\">• 🌰3.1 双向带头循环链表的实现</a></li><li><ul><li><a href=\"#1_59\">•🔥1.创建一个结点</a></li><li><a href=\"#2_81\">•🔥2.初始化双向项链表</a></li><li><a href=\"#3_97\">•🔥3.双向链表尾插函数</a></li><li><a href=\"#4_118\">•🔥4.双向链表尾删函数</a></li><li><a href=\"#5_141\">•🔥5.双向链表头插函数</a></li><li><a href=\"#6_162\">•🔥6.双向链表头删函数</a></li><li><a href=\"#7_182\">•🔥7.双向链表查找函数</a></li><li><a href=\"#8_205\">•🔥8.任意位置插入数据函数</a></li><li><a href=\"#9_226\">•🔥9.任意位置删除数据函数</a></li><li><a href=\"#10_247\">•🔥10.链表销毁释放函数</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_4free_272\">• 🍋知识点4：free函数的理解</a></li><li><ul><li><a href=\"#__41_free_274\">• 🌰4.1 free函数存在的目的</a></li><li><a href=\"#__42_free_277\">• 🌰4.2 该链表里面的free</a></li></ul>\n</li><li><a href=\"#_5_289\">• 🍋知识点5：顺序表和链表的优缺点</a></li><li><ul><li><a href=\"#__51__291\">• 🌰5.1 顺序表优缺点</a></li><li><ul><li><a href=\"#1_292\">•🔥1.顺序表优点</a></li><li><a href=\"#2_297\">•🔥2.顺序表缺点</a></li></ul>\n</li><li><a href=\"#__52__301\">• 🌰5.2 链表优缺点</a></li><li><ul><li><a href=\"#1_302\">•🔥1.链表优点</a></li><li><a href=\"#2_305\">•🔥2.链表缺点</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_309\">•🌙写在后面</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<blockquote>\n<h2><a id=\"_5\"></a>•🌙写在前面</h2>\n<p>💖💖💖Hello，大家好啊，我是vince，小白一名，撰写博客：:⭐️一为更好的锻炼自己，巩固知识；:⭐️二为和大家一起在代码的海洋里探索。<br/><br/> 如果大家感兴趣的话 ——🎉🎉🎉 <font color=\"#00BFFF\"><strong>欢迎关注csdn博客：&lt; vince &gt;</strong></font>，我们互相学习，共同进步哈~🌟<br/><br/> 今天vince将和大家一起去一一<font color=\"#00CED1\"><strong>吃透双向带头循环链表</strong></font>，<strong>接下来这一篇文章将带大家玩转双向带头循环链表</strong>。☀️</p>\n<hr/>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b21a8a51c091416581a9f000c6e584bc.png\"/></p>\n<blockquote>\n<h2><a id=\"_1_11\"></a>• 🍋知识点1：线性表</h2>\n<hr/>\n<h3><a id=\"__21__13\"></a>• 🌰2.1 线性表的概念及分类</h3>\n<h4><a id=\"1_14\"></a>•🔥1.线性表的概念</h4>\n<p>线性表（linear_list）是<font color=\"#00CED1\">n个具有相同特性的数据元素的有限列</font>。 <strong>线性表是一种在实际中最常用且最简单的数据结构</strong>，常见的线性表：顺序表、链表、栈、队列、字符串…<br/> 线性表中的数据元素虽然具有相同特性，但是具体数据的含义根据不同情况而定。</p>\n<pre><code class=\"prism language-C\">例如：\n26个英文字母的字母表：\n            (A,B,C,……,Y,Z)\n就可以构成一个线性表，表中的数据元素是单个字母。\n</code></pre>\n<hr/>\n<h4><a id=\"2_24\"></a>•🔥2.线性表的分类</h4>\n<p><font color=\"#CD853F\"> 线性表在逻辑上是线性结构</font>，也就说是连续的一条直线。<font color=\"#CD853F\"> 但是在物理结构上并不一定是连续的</font>，<strong>线性表在物理上存储时，通常以数组和链式结构的形式存储</strong>。<br/> 💯 图示结构展示：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c5aac30af729489c8fec618e0498dd02.png\"/></p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0819ef7a5a79431bb2e7ea72cf5cfdb0.png\"/></p>\n<blockquote>\n<h2><a id=\"_2_30\"></a>• 🍋知识点2：线性表之链表</h2>\n<hr/>\n<h3><a id=\"__21__32\"></a>• 🌰2.1 链表的概念及分类</h3>\n<h4><a id=\"1_33\"></a>•🔥1.链表的概念</h4>\n<p>线性表的链式存储结构是<font color=\"#00CED1\">用一组任意的存储单元存储线性表的数据元素</font>，<strong>物理存储结构上非连续，非顺序的存储结构</strong>。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的区域称为指针域。指针域中存储的信息称为指针或链。n个结点链接程一个链表，即为线性表的链式结构。<br/> 例如：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0b050970c1154a44adea85c3651fa88b.png\"/></p>\n<hr/>\n<h4><a id=\"2_38\"></a>•🔥2.链表的分类</h4>\n<p>实际中链表的结构非常多样，以下情况组合起来:<br/> 1、单向或者双向链表<br/> 💯 图示结构展示：<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\eef3f59e6fed4395a78e70d89cf85c55.png\"/><br/> 2、带头或者不带头<br/> 💯 图示结构展示：<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e4a6af4468a4438c9c806afdad970be0.png\"/><br/> 3、循环或者不循环<br/> 💯 图示结构展示：<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6dadcfe450a04bc6861863a5f855fa1f.png\"/></p>\n<hr/>\n<p>💯分析：<br/> （1）无头单向非循环链表：<font color=\"blue\">结构简单，一般不会单独用来存数据</font>。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。<strong>另外这种结构在笔试面试中出现很多</strong>。<br/> （2） 带头双向循环链表：<font color=\"blue\">结构最复杂，一般用在单独存储数据</font>。<strong>实际中使用的链表数据结构，都是带头双向循环链表</strong>。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面们代码实现了就知道了。<br/> 图解链表分类组合：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b6f303cc8f8e43f3829540f8491f7aad.png\"/></p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3a73e55322654c399d210d67fcfbce62.png\"/></p>\n<blockquote>\n<h2><a id=\"_3_55\"></a>• 🍋知识点3：双向带头循环链表</h2>\n<hr/>\n<h3><a id=\"__31__57\"></a>• 🌰3.1 双向带头循环链表的实现</h3>\n<p>这里我们就拿<font color=\"#00CED1\"> <strong>双向带头循环链表</strong></font> 来做示例讲解哈~</p>\n<h4><a id=\"1_59\"></a>•🔥1.创建一个结点</h4>\n<p>链表一开始为空或创建头的时候，都需要使用到这里的创建结点的函数。这个函数利于后面链表一些列操作函数的进行。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//创建一个结点\nLNode* BuyList(SLDataType x)\n{\n\tLNode* newnode = (LNode*)malloc(sizeof(LNode));\n\tif (newnode == NULL)\n\t{\n\t\tprintf(\"malloc fail\\n\");\n\t\texit(-1);\n\t}\n\tnewnode-&gt;val = x;\n\tnewnode-&gt;prev = NULL;\n\tnewnode-&gt;next = NULL;\n\treturn newnode;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\581d647e1fa0480abbc1fdb91c616b0c.png\"/></p>\n<hr/>\n<h4><a id=\"2_81\"></a>•🔥2.初始化双向项链表</h4>\n<p>双向链表初始化实际上是<font color=\"#9932CC\">创建一个哨兵位头节点</font>，即建立一个哨兵。这个函数的形参可以用一级指针接受，也可以用二级指针接受。<strong>当然，一般有哨兵位的链表直接用一级指针接受</strong>，这样处理更加合理，若是用二级指针就有点得不偿失。<br/> 代码展示：（形参为一级指针形式）</p>\n<pre><code class=\"prism language-C\">//链表初始化（传一级指针法）\nLNode* ListInit()//初始化实际上是建立一个哨兵位头节点\n{\n\tLNode* Phead = BuyList(0);\n\tPhead-&gt;next = Phead;\n\tPhead-&gt;prev = Phead;\n\treturn Phead;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2e3b2ed8033045f897a893d11fec808e.png\"/></p>\n<hr/>\n<h4><a id=\"3_97\"></a>•🔥3.双向链表尾插函数</h4>\n<p>尾插函数，这里在进行尾插的时候，已经存在哨兵位头结点，所以就算此时最初的链表为空也可以实现尾插，因此这里面不需要检查链表是否为空。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//尾插函数O(1)\nvoid ListPushBack(LNode* Phead, SLDataType x)\n{\n\tassert(Phead);\n\tLNode* newnode = BuyList(x);\n\tLNode* tail = Phead-&gt;prev;\n    tail-&gt;next = newnode;\n\tnewnode-&gt;prev = tail;\n\tnewnode-&gt;next = Phead;\n\tPhead-&gt;prev = newnode;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9ffc8814aed54a38b71be84274e8dc66.png\"/><br/> 💯vs调试分析图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ae4fe06d599a4fbe9f06644548ba6799.png\"/></p>\n<hr/>\n<h4><a id=\"4_118\"></a>•🔥4.双向链表尾删函数</h4>\n<p>尾删函数，在删除数据的时候需要<strong>判断链表是否为空</strong>，如果为空就不能继续操作尾删，即哨兵位头结点不能被删除。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">/尾删函数\nvoid ListPopBack(LNode* Phead)\n{\n\tassert(Phead);\n//判断删除的时候链表是否为空,如果为空的时候就不能再删除了，不能将哨兵删除\n\tassert(Phead-&gt;next != Phead);\n\tLNode* tail = Phead-&gt;prev;\n\tLNode* tailPrev = tail-&gt;prev;\n\tfree(tail);\n\ttail = NULL;\n\tPhead-&gt;next = tailPrev;\n\ttailPrev-&gt;next = Phead;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\aee9ea8195b2468c8307e083820f33b5.png\"/><br/> 💯vs调试分析图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5c9a04b5537f4df48c6815157cd48468.png\"/></p>\n<hr/>\n<h4><a id=\"5_141\"></a>•🔥5.双向链表头插函数</h4>\n<p>双向链表的头插其实在逻辑思维上和尾插类似，其实双向带头循环链表看起来名字复杂，但是操作和思维都是挺简单的。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//头插函数\nvoid ListPushFront(LNode* Phead,SLDataType x)\n{\n\tassert(Phead);\n\tLNode* newnode = BuyList(x);\n\tLNode* cur = Phead-&gt;next;\n\tPhead-&gt;next = newnode;\n    newnode-&gt;prev = Phead;\n\tnewnode-&gt;next = cur;\n\tcur-&gt;prev = newnode;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\325d09f720f74de7a63c26bd2d72ba0b.png\"/><br/> 💯vs调试分析图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\eea59f9c0cd44472be64be634a58379b.png\"/></p>\n<hr/>\n<h4><a id=\"6_162\"></a>•🔥6.双向链表头删函数</h4>\n<p>头删函数，这里依然需要和尾删函数一样<strong>注意链表是否为空</strong>，不能删除哨兵位头结点。</p>\n<pre><code class=\"prism language-C\">//头删函数\nvoid ListPopFront(LNode* Phead)\n{\n\tassert(Phead);\n\tLNode* cur = Phead-&gt;next;\n\tLNode* str = cur-&gt;next;\n\tfree(cur);\n\tcur = NULL;\n\tPhead-&gt;next = str;\n\tstr-&gt;prev = Phead;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\39a7b7ba9cc744d797da89149e216b54.png\"/><br/> 💯vs调试分析图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4f0ef57b614a4d9daf243e06334c808b.png\"/></p>\n<hr/>\n<h4><a id=\"7_182\"></a>•🔥7.双向链表查找函数</h4>\n<p>查找函数，查找链表里面想要的数据，<strong>一般是从哨兵位头结点后面开始查找</strong>，找到再次遇到哨兵位头结点结束。查找函数一般也不单独使用，一般和后面的任意位置删除函数合作使用。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//查找函数\nLNode* ListNodeFind(LNode* Phead, SLDataType x)\n{\n\tassert(Phead);\n\tLNode* cur = Phead-&gt;next;\n\twhile ( cur != Phead)\n\t{\n\t\tif (cur-&gt;val == x)\n\t{\n\treturn cur;\n    }\n\t\tcur = cur-&gt;next;\n\t}\n\treturn NULL;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\19d45d4f18cb4fae9a2cca09b4e1a3ae.png\"/></p>\n<hr/>\n<h4><a id=\"8_205\"></a>•🔥8.任意位置插入数据函数</h4>\n<p>在任意位置插入函数，这里<strong>一般是在这个位置的前面插入数据</strong>，当然也可以在后面插入数据。但是我们这里举例是在前面插入数据，因为之后这种方法用的更多。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//在Pos位置插入x值\nvoid ListInSert(LNode* Pos, SLDataType x)\n{\n\tassert(Pos);\n\tLNode* newnode = BuyList(x);\n\tLNode* cur = Pos-&gt;prev;\n\tnewnode-&gt;prev = cur;\n\tcur-&gt;next = newnode;\n\tnewnode-&gt;next = Pos;\n\tPos-&gt;prev = newnode;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\066705c55a444e78988651ef1b1cb83e.png\"/><br/> 💯vs调试分析图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dfa17ae7a741455e9e1b9fc7e47021b9.png\"/></p>\n<hr/>\n<h4><a id=\"9_226\"></a>•🔥9.任意位置删除数据函数</h4>\n<p>删除任意位置函数一般和前面的查找函数结合使用，在删除函数使用之后，一把最好在调用该函数后面将其里面的指针free释放，防止出现内存泄漏情况。（这里 vince 在下面放一个知识点介绍介绍。）<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//删除Pos位置的数\nvoid ListErase(LNode* Pos)\n{\n\tassert(Pos);\n\tLNode* cur = Pos-&gt;prev;\n\tLNode* str = Pos-&gt;next;\n\tfree(Pos);\n\tPos = NULL;\n\tcur-&gt;next = str;\n\tstr-&gt;prev = cur;\n}\n</code></pre>\n<p>💯图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7d866c75d8f64136829f65fac6f3152a.png\"/><br/> 💯vs调试分析图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\714c8b65aadc4982879dcc6f16aec138.png\"/></p>\n<hr/>\n<h4><a id=\"10_247\"></a>•🔥10.链表销毁释放函数</h4>\n<p>链表在使用结束后，需要对链表的空间进行释放销毁操作，实际上是将空间归还给内存。防止后面程序出现内存泄露问题。<br/> 代码展示：</p>\n<pre><code class=\"prism language-C\">//销毁函数\nvoid Destory(LNode* Phead)\n{\n\tassert(Phead);\n\tLNode* cur = Phead-&gt;next;\n\twhile (cur != Phead)\n\t{\n\tLNode* next = cur-&gt;next;\n\t//ListErase(cur)这里也可以调用Erase来操作，虽然Erase稍微慢一点，\n\t//但是现在计算机速度其实很快，所以没太大影响\n\tfree(cur);\n\tcur = next;\n\t}\n\tfree(Phead);\n\t//Phead = NULL;这里仍然是形参，无法真正实现那边PList = NULL\n\t//所以这里Phead置空与否无所谓\n}\n</code></pre>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\80fe32467ab843699714c59f91706280.png\"/></p>\n<blockquote>\n<h2><a id=\"_4free_272\"></a>• 🍋知识点4：free函数的理解</h2>\n<hr/>\n<h3><a id=\"__41_free_274\"></a>• 🌰4.1 free函数存在的目的</h3>\n<p><strong>free不是真的销毁，而是将空间还给操作系统</strong>。free掉内容是防止发生内存泄漏问题。指针被使用之后如果不及时被free，可能后面会不注意再使用到这个指针，那么就会出现非法内存访问问题从而可能造成内存泄漏问题，可能会使得程序崩溃。当然，如果在这个链表里没有置空也可以，只要注意后面一直不使用这个指针就可以。</p>\n<hr/>\n<h3><a id=\"__42_free_277\"></a>• 🌰4.2 该链表里面的free</h3>\n<p>例如：</p>\n<pre><code class=\"prism language-C\">\tfree(pos)；\n\tpos = NULL;\n</code></pre>\n<p>这里free掉的实际上是pos所指向的结点内容，并不是pos作为指针本身，所以如果这里面处理严谨一些，就在调用该函数结束后，在主函数里面free掉pos指针，不能放在子函数里面free，<strong>因为形参是实参的临时拷贝</strong>，在子函数里面无法真正实现free(pos)。<br/> 图解分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\003349ee1f9c468a99cf94ae2c32c28f.png\"/></p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\38956a096c9c466bb62e24f7de767594.png\"/></p>\n<blockquote>\n<h2><a id=\"_5_289\"></a>• 🍋知识点5：顺序表和链表的优缺点</h2>\n<hr/>\n<h3><a id=\"__51__291\"></a>• 🌰5.1 顺序表优缺点</h3>\n<h4><a id=\"1_292\"></a>•🔥1.顺序表优点</h4>\n<p>（1）<strong>物理空间是连续的</strong>，方便用下标随机访问；<br/> （2）顺序表的<font color=\"#FF1493\"> <strong>空间利用率是高于链表的</strong> </font>；<br/> 因为顺序表储存一个数据就直接存4个字节，链表储存一个数据还要附带一个前后指针（有一些附带的消耗，但是其实顺序表在扩容的时候也有消耗，所以两者其实差距不大，一般对空间要求不大）；<br/> （3）（补充：了解掌握）顺序表CPU高速缓存命中率会更高。</p>\n<h4><a id=\"2_297\"></a>•🔥2.顺序表缺点</h4>\n<p>（1）因为物理空间是连续的，所以空间不够时候需要扩容，<font color=\"#FF1493\"><strong>扩容有一定的消耗，其次扩容机制还存在一定的空间浪费</strong></font>；<br/> （2）<font color=\"#FF1493\"><strong>头插或者中间插入数据，需要挪动数据，时间复杂度较高，</strong></font>都是O(N)。</p>\n<hr/>\n<h3><a id=\"__52__301\"></a>• 🌰5.2 链表优缺点</h3>\n<h4><a id=\"1_302\"></a>•🔥1.链表优点</h4>\n<p>（1）<font color=\"#9932CC\"><strong>链表可以按需申请和释放空间</strong></font>；<br/> （2）<font color=\"#9932CC\"><strong>任意位置插入数据效率高，</strong></font>O(1)。</p>\n<h4><a id=\"2_305\"></a>•🔥2.链表缺点</h4>\n<p>（1）物理空间不是连续的，所以链表访问必须得挨个遍历，不支持下标随机访问。有些算法不适用，如二分查找、排序等。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\957b94b62f0649e6a40a7132c403f147.png\"/></p>\n<blockquote>\n<h2><a id=\"_309\"></a>•🌙写在后面</h2>\n<p>链表这里面有简单的复用写法，将任意位置删除函数和任意位置插入函数写出来之后，对于头插头删、尾插尾删，这些函数就可以直接复用这两个函数，相对来说简单很多。<br/> 因为最近时间少所以vince就在链表这一块，就用双向带头循环链表作为典例介绍，当然前面本应该还有单链表，其实原理都是共通的，<font color=\"blue\"><strong>单链表一般在OJ面试体中有很多题型；双链表在日常生活中或者项目程序中用的最多</strong></font>，大家学习最终的目的就是拿来运用的嘛。所以大家一定要将其<font color=\"#FF1493\"><strong>摸清、拿捏、吃透</strong></font>；✨✨✨<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e9b2227cb0bd4f3ab58b1a193e968867.png\"/><br/> <strong>代码不负有心人，<font color=\"pink\">98加满，向前冲啊</font></strong>🐬</p>\n</blockquote>\n<p>🎉🎉🎉<strong>以上代码均可运行，所用编译环境为 vs2019 ,运行时注意加上编译头文件#define _CRT_SECURE_NO_WARNINGS 1</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-30 20:28:52", "summary": "年轻是我们唯一拥有权利去编织梦想的时光！文章目录写在前面知识点：线性表线性表的概念及分类线性表的概念线性表的分类知识点：线性表之链表链表的概念及分类链表的概念链表的分类知识点：双向带头循环链表双向带头"}