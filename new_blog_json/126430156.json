{"blogid": "126430156", "writerAge": "码龄8年", "writerBlogNum": "42", "writerCollect": "21", "writerComment": "8", "writerFan": "9", "writerGrade": "3级", "writerIntegral": "773", "writerName": "乐活每天", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126430156.jpg", "writerRankTotal": "456532", "writerRankWeekly": "124101", "writerThumb": "9", "writerVisitNum": "45599", "blog_read_count": "19", "blog_time": "于 2022-09-07 13:11:38 发布", "blog_title": "Java的finalize方法探究", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>        finalize方法是Object提供的一个特殊的方法，任何类均可重写它。该方法是在GC回收对象之时进行调用的，但是任何重写了finalize方法的类，其在创建对象之时JVM会自动创建一个类型为java.lang.ref.Finalizer的对象。Finalizer类的作用就是，在GC将要回收一个实现了finalize方法的类的引用对象时，VM会标记将要被处理的类的引用，并将它加入Finalizer对象的一个队列中，这个队列是静态的变量，也就是全局共享的。由此，可见一个明显的问题，就是不当的使用finalize方法会造成内存泄漏问题。</p>\n<p>        下面我们看看finalize方法引起内存泄漏的一个示例。</p>\n<p>        先创建一个带有finalize方法的普通类，如下：</p>\n<pre><code class=\"language-java\">public class AWithFinal {\n\t\n\tpublic void doSomething() {\n\t\t\n\t}\n\t\n\t@Override\n\tprotected void finalize() {\n\t\tSystem.out.println(\"-\");\n\t}\n}</code></pre>\n<p>        类很简单，我们就复写了Object的finalize方法，只打印一个符号以观察其调用情况。下面我们看看当使用到这个AWithFinal的类是，如何会产生内存泄漏问题。看下面代码：</p>\n<pre><code class=\"language-java\">public class Test1 {\n\t\n\tpublic static void checkReferences() throws Throwable {\n\t\tClass&lt;?&gt; finalizerCls = Class.forName(\"java.lang.ref.Finalizer\");\n\t\tField queue</code></pre>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 13:11:38", "summary": "方法是提供的一个特殊的方法，任何类均可重写它。该方法是在回收对象之时进行调用的，但是任何重写了方法的类，其在创建对象之时会自动创建一个类型为的对象。类的作用就是，在将要回收一个实现了方法的类的引用对象"}