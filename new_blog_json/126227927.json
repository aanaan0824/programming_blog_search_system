{"blogid": "126227927", "writerAge": "码龄1年", "writerBlogNum": "30", "writerCollect": "94", "writerComment": "269", "writerFan": "519", "writerGrade": "4级", "writerIntegral": "1155", "writerName": "华华的bit", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126227927.jpg", "writerRankTotal": "18519", "writerRankWeekly": "4036", "writerThumb": "339", "writerVisitNum": "19747", "blog_read_count": "892", "blog_time": "于 2022-08-08 16:30:46 发布", "blog_title": "C++中的继承", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>继承</h2>\n<p>1️⃣ <strong>继承的概念</strong>:继承是是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称<strong>派生类</strong>。<br/> 2️⃣ <strong>继承的定义</strong>:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\tstring _name<span class=\"token punctuation\">;</span>\n\tstring _sex<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _No<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p><strong>下面我们看到Person是父类，也称作基类。Student是子类，也称作派生类</strong><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\35e745cce00d4b91a3100a50a054914e.png\"/><br/> 3️⃣<strong>基类和派生类对象赋值转化</strong>:</p>\n<ul><li>派生类对象 可以赋值给 基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去。<br/> 我们通过代码进行解释</li></ul>\n<blockquote>\n<p>class Person<br/> {<!-- --><br/> public:<br/> string _name;<br/> string _sex;<br/> int _age;<br/> };<br/> class Student :public Person<br/> {<!-- --><br/> public:<br/> int _No;<br/> };</p>\n</blockquote>\n<p>int main()<br/> {<!-- --><br/> Person p;<br/> Student s;<br/> s._name = “张三”;<br/> s._age = 20;<br/> s._sex = “男”;<br/> p = s;<br/> Person&amp; rp = s;<br/> Person* ptrp = &amp;s;</p>\n<pre><code>cout &lt;&lt; &amp;s &lt;&lt; endl;\ncout &lt;&lt; &amp;rp &lt;&lt; endl;\ncout &lt;&lt; ptrp &lt;&lt; endl;\nrp._age++;\nptrp-&gt;_age++;\n\nreturn 0;\n</code></pre>\n<p>}<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a96934a343604e328254b361d8e22b68.png\"/></p>\n<h3><a id=\"_____58\"></a>我们发现地址都一样说明可以赋值给基类的对象 / 基类的指针 / 基类的引用。</h3>\n<ul><li><strong>基类对象不能赋值给派生类对象</strong>。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1f31e405a6aa423880c800ea0d84f9a2.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0f5c88427f854cef95b790793be72c8f.png\"/><br/> 我们会发现它出现了这样的错误。下面的第三点就是对该错误的处理。</li><li><strong>基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型</strong>。<br/> 第一个处理方法是进行强制转换:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f5a23002ba324cf09c31f30152dfdb42.png\"/></li></ul>\n<p>4️⃣<strong>继承中的作用域</strong>:</p>\n<ol><li>在继承体系中基类和派生类都有独立的作用域。</li><li>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）</li><li>需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。</li><li>注意在实际中在继承体系里面最好不要定义同名的成员。</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\00866a6cf035422691d522df0234c680.png\"/><br/> 我们通过上图，发现父类和子类都要_num我们进行实现的时候用的是子类的_num解释了上面的第二点：子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问。我们要处理这个问题我们可以通过确定访问的方式进行指定访问。<br/> <img alt=\"\n\" src=\"..\\..\\static\\image\\fee5bb8a01ea44a98064a5f8e16a77b5.png\"/><br/> 我指定了它是访问父类。通过运行我们发现这个方法是可行的。<br/> 5️⃣.<strong>派生类的默认成员函数</strong><br/> 5. 派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。<br/> 6. 派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。<br/> 7. 派生类的operator=必须要调用基类的operator=完成基类的复制。<br/> 8. 派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。<br/> 9. 派生类对象初始化先调用基类构造再调派生类构造。<br/> 10. 派生类对象析构清理先调用派生类析构再调基类的析构。</p>\n<blockquote>\n<p>class Person<br/> {<!-- --><br/> public:<br/> Person(const char* name)<br/> :_name(name)<br/> {<!-- --><br/> cout &lt;&lt; “Person()” &lt;&lt; endl;<br/> }<br/> Person(const Person&amp; p)<br/> :_name(p._name)<br/> {<!-- --><br/> cout &lt;&lt; “Person(const Person&amp; p)” &lt;&lt; endl;<br/> }<br/> Person&amp; operator=(const Person&amp; p)<br/> {<!-- --><br/> cout &lt;&lt; “Person&amp; operator=(const Person&amp; p)” &lt;&lt; endl;<br/> if (this != &amp;p)<br/> _name = p._name;<br/> return <em>this;<br/> }<br/> ~Person()<br/> {<!-- --><br/> cout &lt;&lt; “~Person” &lt;&lt; endl;<br/> }<br/> protected:<br/> string _name;<br/> };<br/> class Student :public Person<br/> {<!-- --><br/> public:<br/> Student(const char</em> name=\" \",int num=0)<br/> :_num(num)<br/> ,Person(name)<br/> {<!-- --><br/> cout &lt;&lt; “Student(const char* name=” “,int num=0)” &lt;&lt; endl;<br/> }<br/> Student(const Student&amp; s)<br/> :Person(s)<br/> ,_num(s._num)<br/> {<!-- --><br/> cout &lt;&lt; “Student(const Student&amp; s)” &lt;&lt; endl;<br/> }<br/> Student&amp; operator=(const Student&amp; s)<br/> {<!-- --><br/> if (this != &amp;s)<br/> {<!-- --><br/> Person::operator=(s);<br/> _num = s._num;<br/> }<br/> cout &lt;&lt; “Student&amp; operator=(const Student&amp; s)” &lt;&lt; endl;<br/> return *this;<br/> }<br/> ~Student()<br/> {<!-- --><br/> cout &lt;&lt; “~Student()” &lt;&lt; endl;//会去调用父类的所以这边不需要写<br/> }<br/> protected:<br/> int _num;<br/> };<br/> int main()<br/> {<!-- --><br/> Student s1(“李四”, 1);<br/> Student s2(s1);<br/> Student s3(“王五”, 2);<br/> s1 = s3;<br/> return 0;<br/> }</p>\n</blockquote>\n<p><strong>以上10点需要读者自己通过这部分代码进行探究。</strong><br/> 6️⃣<strong>继承与友元</strong></p>\n<p>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\323f263a581f4e37b21a855076dde1cd.png\"/><br/> 如上图对基类使用了友元，编译器报错完美解释了<em><strong>友元关系不能继承</strong></em><br/> 7️⃣<strong>继承与静态成员</strong><br/> <strong>基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。</strong></p>\n<blockquote>\n<p>class Person<br/> {<!-- --><br/> public:<br/> Person()<br/> {<!-- --><br/> ++_count;<br/> }<br/> protected:<br/> string _name;<br/> public:<br/> static int _count;<br/> };<br/> int Person::_count = 0;<br/> class Student : public Person<br/> {<!-- --><br/> protected:<br/> int _stuNum;<br/> };<br/> class Graduate :public Student<br/> {<!-- --><br/> protected:<br/> string _seminarCourse;<br/> };<br/> int main()<br/> {<!-- --><br/> Student s1;<br/> Student s2;<br/> Student s3;<br/> Graduate s4;<br/> Person s;<br/> cout &lt;&lt; \" 人数 :\" &lt;&lt; Person::_count &lt;&lt; endl;<br/> cout &lt;&lt; \" 人数 :\" &lt;&lt; Student::_count &lt;&lt; endl;<br/> cout &lt;&lt; \" 人数 :\" &lt;&lt; s4._count &lt;&lt; endl;<br/> cout &lt;&lt; \" 人数 :\" &lt;&lt; &amp;Person::_count &lt;&lt; endl;<br/> cout &lt;&lt; \" 人数 :\" &lt;&lt; &amp;Student::_count &lt;&lt; endl;<br/> cout &lt;&lt; \" 人数 :\" &lt;&lt; &amp;s4._count &lt;&lt; endl;<br/> return 0;<br/> }</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3caa289ab14b40eea6f135c943a6a548.png\"/><br/> 我们通过该代码进行验证。发现static定义的_count的静态变量在类里面是唯一的。我们可以进行多次改变。<br/> 8️⃣<strong>指定访问</strong><br/> 指定访问是为了解决复杂的菱形继承中的二义性。<br/> 什么是菱形继承?<br/> 菱形继承：是多继承的一种特殊情况。<br/> 多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承。<br/> 单继承：一个子类只有一个直接父类时称这个继承关系为单继承。</p>\n<blockquote>\n<p>lass Person<br/> {<!-- --><br/> public:<br/> string _name;<br/> int _a[10000];<br/> };<br/> class Student : virtual public Person<br/> {<!-- --><br/> protected:<br/> int _num;<br/> };<br/> class Teachar :virtual public Person<br/> {<!-- --><br/> protected:<br/> int _id;<br/> };<br/> class Assistant :public Student, public Teachar<br/> {<!-- --><br/> protected:<br/> string _majorCourse;<br/> };</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7cae4c370ce847458a37e0786941739b.png\"/><br/> 以上就是指定访问的使用。<br/> 9️⃣ <strong>virtual</strong>的使用<br/> <strong>虚拟继承</strong>的出现是为了解决菱形继承中数据冗余和二义性的问题。<br/> 虚拟继承写在继承方式的前面。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\757534d31777407aa1891e297d42f7a8.png\"/><br/> 虚拟继承的使用，请百度。本人对虚拟继承的认知不足。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-08 16:30:46", "summary": "继承继承的概念继承是是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承的定义下面我们看到是父类，也称作基类。是子类，"}