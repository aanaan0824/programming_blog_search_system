{"blogid": "124487246", "writerAge": "码龄165天", "writerBlogNum": "9", "writerCollect": "6", "writerComment": "1", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "93", "writerName": "知勤者", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124487246.jpg", "writerRankTotal": "103176", "writerRankWeekly": "963589", "writerThumb": "1", "writerVisitNum": "6862", "blog_read_count": "2130", "blog_time": "已于 2022-09-04 05:32:17 修改", "blog_title": "PHP创建websocket服务端", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>创建这个服务端需要先开启sockets扩展，没有开启的话，无论如何都会报错</p>\n<p>只需要在php.ini文件中找到sockets扩展并将其前面的分号删除能将其开启</p>\n<p>开启前：</p>\n<div>\n<pre><code>;extension=sockets</code></pre>\n</div>\n<p>开启后：</p>\n<div>\n<pre><code>extension=sockets</code></pre>\n</div>\n<p>开启完毕，接下来我们就可以进入正题了；首先，我们了解几个函数：</p>\n<p>socket_create(AF_INET, SOCK_STREAM, SOL_TCP);//用于创建套接字</p>\n<p>socket_bind( $this-&gt;master,$ip,$port);//用于绑定ip和端口</p>\n<p>socket_listen( $this-&gt;master,1000);//用于调用connect连接的套接字和监听相关端口</p>\n<p>socket_accept($this-&gt;master);//负责握手连接</p>\n<p>socket_recv($socket, $buffer, 1024, 0);//从已连接的socket（客户端）接收数据</p>\n<p>socket_write($socket,$upgrade,strlen($upgrade));//给单独客户端发送数据</p>\n<p>send($message)//发送数据</p>\n<p>socket_close($socket);//断开连接</p>\n<p>很多步骤和PHP创建socket差不多，</p>\n<p>不同主要在于socket_write使用和数据需要解、封帧，我们需要将http升级为websocket</p>\n<p><strong>http升级为websocket</strong></p>\n<div>\n<pre><code class=\"language-php\">if(preg_match(\"/Sec-WebSocket-Key: (.*)\\r\\n/\",$buffer,$match)){\n        \t$responseKey=base64_encode(sha1($match[1] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',true));\n        \t$upgrade=\"HTTP/1.1 101 Switching Protocol\\r\\n\".\n        \t         \"Upgrade: websocket\\r\\n\".\n        \t         \"Connection: Upgrade\\r\\n\".\n        \t         \"Sec-WebSocket-Accept:\".$responseKey.\"\\r\\n\\r\\n\";\n        \t         socket_write($socket,$upgrade,strlen($upgrade));\n        }</code></pre>\n</div>\n<p>$socket是我们创建的连接，$buffer是客户端第一次连接时发送的数据</p>\n<p>注意：Sec-WebSocket-Key: (.*)//括号和冒号之间是要有空格的</p>\n<p><strong>解帧</strong></p>\n<div>\n<pre><code class=\"language-php\">        $len=$masks=$data=$decoded=null;\n\t\t$len=ord($buffer[1]) &amp; 127;\n\n\t\tif($len === 126){\n\t\t\t$masks=substr($buffer,4,4);\n\t\t\t$data=substr($buffer, 8);\n\t\t}else if($len === 127){\n\t\t\t$masks=substr($buffer,10,4);\n\t\t\t$data=substr($buffer, 14);\n\t\t}else{\n\t\t\t$masks=substr($buffer,2,4);\n\t\t\t$data=substr($buffer, 6);\n\t\t}\n\n\t\tfor($index = 0;$index&lt;strlen($data);$index++){\n\t\t\t$decoded.=$data[$index] ^ $masks[$index % 4];\n\t\t}\n\t\treturn $decoded;</code></pre>\n</div>\n<p>$buffer是客户端第一次连接时发送的数据</p>\n<p><strong>封帧</strong></p>\n<div>\n<pre><code class=\"language-php\">        $len=strlen($message);\n\t\tif($len&lt;=125){\n\t\t\treturn \"\\x81\".chr($len).$message;\n\t\t}else if($len&lt;=65535){\n\t\t\treturn \"\\x81\".chr(126).pack(\"n\",$len).$message;\n\t\t}else{\n\t\t\treturn \"\\x81\".chr(127).pack(\"xxxxN\",$len).$message;\n\t\t}</code></pre>\n</div>\n<p>$message是我们需要发送的数据</p>\n<p>前端连接前记得运行服务端，运行方式：</p>\n<p>在cmd输入</p>\n<pre><code>php 你的服务端PHP文件路径</code></pre>\n<p>运行前先配置环境变量：将你的PHP安装路径添加到Path中</p>\n<p><a class=\"link-info has-card\" href=\"https://www.zhiqinzhe.com\" title=\"这是我的个人小站  （未开通，仅做宣传）\"><span class=\"link-card-box\"><span class=\"link-title\">这是我的个人小站 （未开通，仅做宣传）</span><span class=\"link-link\"><img alt=\"icon-default.png?t=M7J4\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://www.zhiqinzhe.com</span></span></a></p>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2022-09-04 05:32:17", "summary": "创建这个服务端需要先开启扩展，没有开启的话，无论如何都会报错只需要在文件中找到扩展并将其前面的分号删除能将其开启开启前：开启后：开启完毕，接下来我们就可以进入正题了；首先，我们了解几个函数：用于创建套"}