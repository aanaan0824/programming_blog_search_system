{"blogid": "126490825", "writerAge": "码龄7年", "writerBlogNum": "51", "writerCollect": "128", "writerComment": "37", "writerFan": "68", "writerGrade": "4级", "writerIntegral": "1074", "writerName": "fl2011sx", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126490825.jpg", "writerRankTotal": "18955", "writerRankWeekly": "2173", "writerThumb": "87", "writerVisitNum": "57932", "blog_read_count": "895", "blog_time": "已于 2022-08-24 18:47:00 修改", "blog_title": "C++的缺陷和思考（六）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>本文继续来介绍C++的缺陷和笔者的一些思考。先序文章请看<br/> <a href=\"https://blog.csdn.net/fl2011sx/article/details/126407455\">C++的缺陷和思考（五）</a><br/> <a href=\"https://blog.csdn.net/fl2011sx/article/details/126353499\">C++的缺陷和思考（四）</a><br/> <a href=\"https://blog.csdn.net/fl2011sx/article/details/126344577\">C++的缺陷和思考（三）</a><br/> <a href=\"https://blog.csdn.net/fl2011sx/article/details/126300435\">C++的缺陷和思考（二）</a><br/> <a href=\"https://blog.csdn.net/fl2011sx/article/details/126242703\">C++的缺陷和思考（一）</a></p>\n<h1><a id=\"_6\"></a>模板的全特化</h1>\n<p>先跑个小题~，模板的「模」正确发音应该是「mú」，原本是工程上的术语，生产一种工件可能需要一种样本，但它和实际生产出的工件可能并不相同。所以说，「模板」本身并不是实际的工件，但可以用于生产出工件。更通俗来说，可以理解成一个浇注用的壳，比如说是圆柱形状，如果你往里灌铁水，那出来的就是铁柱；如果你灌铝水出来的就是铝柱；如果你灌水泥，那出来的就是水泥柱……</p>\n<p>所以C++中用“模板”这个词特别贴切，它本身并不是实际代码，而在实例化的时候才会生成对应的代码。</p>\n<p>而模板又存在“特化”的问题，分为“偏特化”和“全特化”。偏特化也就是部分特化，也就是半成品，本质上来说仍然属于“模板”。但全特化就很特殊了，全特化的模板就已经不是模板了，而是真正的代码了，因此这里的行为也会和模板有所不同，而更加接近普通代码。</p>\n<p>最简单的例子就是，模板的声明和实现一般都会写在头文件中（除非仅在某个源文件中使用）。这是由于模板是编译期代码，在编译期会生成实际代码，而“编译”过程是单文件行为，因此你必须保证每个独立的源文件都能找到这段模板定义。（include头文件本质就是文件内容的复制，所以还是相当于每个使用的源文件都获取了一份模板定义）。而如果拆开则会在编译期间找不到而报错：</p>\n<p>demo.h</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>demo.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>main.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span> <span class=\"token comment\">// 这里只获得了声明</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR，链接报错，因为只有声明而没有实现</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上例中，main.cpp包含了demo.h，因此获得的是<code>f</code>函数的声明。当main.cpp在编译期间，是不会去关联demo.cpp的，在主函数中调用了<code>f&lt;int&gt;</code>，因此会标记<code>f&lt;int&gt;</code>函数已经声明。</p>\n<p>而编译demo.cpp的时候，由于<code>f</code>并没有任何实例化，因此不会产生任何代码。</p>\n<p>此后链接main.cpp和demo.cpp，发现main.cpp中的<code>f&lt;int&gt;</code>没有实现，因此链接阶段报错。</p>\n<p>所以，我们才要求模板的实现也要写在头文件中，也就是变成：</p>\n<p>demo.h</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 声明</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...其他内容</span>\n\n<span class=\"token comment\">// 定义</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>main.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>由于实现也写在了demo.h中，因此当主函数中调用了<code>f&lt;int&gt;</code>时，既会用模板<code>f</code>的声明生成出<code>f&lt;int&gt;</code>的声明，也会用模板<code>f</code>的实现生成出<code>f&lt;int&gt;</code>的实现。</p>\n<p>但是对于全特化的模板，情况将完全不同。因为全特化的模板已经不是模板了，而是一个确定的函数，编译期不会再用它来生成代码，因此，这时如果你把实现也写在头文件里，就会出现重定义错误：</p>\n<p>demo.h</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// f&lt;int&gt;全特化</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>src1.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span> <span class=\"token comment\">// 这里有一份f&lt;int&gt;的实现</span></span>\n</code></pre>\n<p>main.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span> <span class=\"token comment\">// 这里也有一份f&lt;int&gt;的实现</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR, redefine f&lt;int&gt;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这时会报重定义错误，因为<code>f&lt;int&gt;</code>的实现写在了demo.h中，那么src.cpp包含了一次，相当于实现了一次，然后main.cpp也包含了一次，相当于又实现了一次，所以报重定义错误。</p>\n<p>因此，正确的做法是把全特化模板当做普通函数来对待，只能在源文件中定义一次：</p>\n<p>demo.h</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 特化f&lt;int&gt;的声明</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>demo.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span></span>\n<span class=\"token comment\">// 特化f&lt;int&gt;的定义</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>src1.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span> <span class=\"token comment\">// 只得到了声明，没有重复实现</span></span>\n</code></pre>\n<p>main.cpp</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"demo.h\"</span> <span class=\"token comment\">// 只得到了声明，没有重复实现</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK，全局只有一份实现</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>所以在使用模板特化的时候，一定要小心，如果是全特化的话，就要按照普通函数/类来对待，声明和实现需要分开。</p>\n<p>当然了，硬要把实现写在头文件里也是可以的，只不过要用<code>inline</code>修饰，防止重定义。</p>\n<p>demo.h</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 特化f&lt;int&gt;声明</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 特化f&lt;int&gt;内联定义</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">f</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n</code></pre>\n<h1><a id=\"_143\"></a>构造/析构函数调用虚函数</h1>\n<p>我们知道C++用来实现“多态”的语法主要是虚函数。当调用一个对象的虚函数时，会根据对象的实际类型来调用，而不是根据引用/指针的类型。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::f\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child1</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">override</span> <span class=\"token punctuation\">{<!-- --></span>std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Child1::f\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child2</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">override</span> <span class=\"token punctuation\">{<!-- --></span>std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Child2::f\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Base <span class=\"token operator\">*</span>obj1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Child1<span class=\"token punctuation\">;</span>\n  Child2 ch<span class=\"token punctuation\">;</span>\n  Base <span class=\"token operator\">&amp;</span>obj2 <span class=\"token operator\">=</span> ch<span class=\"token punctuation\">;</span>\n  Base obj3<span class=\"token punctuation\">;</span>\n\n  obj1<span class=\"token operator\">-&gt;</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Child1::f</span>\n  obj2<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Child2::f</span>\n  obj3<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Base::f</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但有一种特殊情况，会让多态性失效，请看下面例程：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token function\">Base</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 构造函数调用虚函数</span>\n  <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::f\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token function\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">override</span> <span class=\"token punctuation\">{<!-- --></span>std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Child::f\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Child ch<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Base::f</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们知道子类构造时需要先调用父类构造函数。这里由于<code>Child</code>中没有指定<code>Base</code>的构造函数，因此会调用无参的构造。在<code>Base</code>的无参构造函数中调用了虚函数<code>f</code>。照理说，我们是在构造<code>Child</code>的过程中调用了<code>f</code>，那么应该调用的是<code>Child</code>的<code>f</code>，但实际调的是<code>Base</code>的<code>f</code>，也就是多态性失效了。</p>\n<p>究其原因，我们就要知道C++构造的模式了。由于<code>Child</code>是<code>Base</code>的子类，因此会含有<code>Base</code>类的成员，并且构造时也要先构造。在构造<code>Child</code>的<code>Base</code>部分时，先初始化了虚函数表，由于此时还属于<code>Base</code>的构造函数，因此虚函数表中指向的是<code>Base::f</code>。虚函数表初始化后开始构造<code>Base</code>的成员，示例中由于是空的所以跳过。再执行<code>Base</code>构造函数的函数体，函数体里调用了<code>f</code>。<strong>以上都属于<code>Base</code>的构造，完成后才会继续<code>Child</code>独有部分的构造</strong>。首先会构造虚函数表，把<code>f</code>指向<code>Child::f</code>。然后是初始化成员，示例中为空所以跳过。最后执行<code>Child</code>构造函数函数体，示例中是空的。</p>\n<p>所以，我们看到，这里调用<code>f</code>的时机，是在<code>Base</code>构造的过程中。<code>f</code>由于是虚函数，因此会通过虚函数表来访问，但又因为此时虚函数表里指向的就是<code>Base::f</code>，所以会调用到<code>Base</code>类的<code>f</code>。</p>\n<p>同理，如果在析构函数中调用虚函数的话，同样会失去多态性。原则就是<strong>哪个类里调用的，实际就会调用哪个类的实现</strong>。</p>\n<h1><a id=\"_198\"></a>经典二义性问题</h1>\n<p>C++中存在3个非常经典的二义性问题，并且他们的默认含义都是反直觉的。</p>\n<h3><a id=\"_200\"></a>临时对象传参时的二义性</h3>\n<p>请看下面的代码：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">explicit</span> <span class=\"token function\">Data</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Test <span class=\"token operator\">&amp;</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Data <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这句是什么含义？</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面这种类型的代码确实有时会一不留神就写出来。我们愿意是想创建一个<code>Data</code>类型的对象叫做<code>data</code>，构造参数是一个<code>Test</code>类型，这里我们直接创建了一个临时对象作为构造参数。</p>\n<p>但如果你真的这样写的话，会得到一个warning，并且<code>data</code>这个对象并没有创建成功。为什么呢？因为编译期把它误以为是函数声明了。这里首先需要了解一个语法糖：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token function\">d</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 等价于</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>C++中允许参数为“函数类型”，又因为函数并不是一种存储类型，因此这种语法会当做“函数指针类型”来处理。所以说当函数参数是一个函数的时候，本质上是让传一个函数指针进去。</p>\n<p>与此同时，C++也支持了“函数取地址”和“解函数指针”的操作。函数取地址后仍然是函数指针，解函数指针后仍然是函数指针：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> f<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数类型转化为函数指针（C语言只支持这种写法）</span>\n  <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数类型取地址还是函数指针类型</span>\n  <span class=\"token function\">p2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数指针直接调用相当于函数调用</span>\n  <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数指针解指针后仍然是函数指针</span>\n  <span class=\"token keyword\">auto</span> p3 <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 同上，p3仍然是void (*)()类型</span>\n  <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 逐渐离谱，但确实是合法的</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>再回到一开始的例子，假如我们要声明一个函数名为<code>data</code>，返回值是<code>Data</code>类型，参数是一个函数类型，一个返回值为<code>Test</code>，空参类型的函数。那么就是：</p>\n<pre><code class=\"prism language-cpp\">Data <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 或者是</span>\nData <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token function\">Test</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>第一种写法正好和我们刚才想表示“定义<code>Data</code>类型的对象名为<code>data</code>，参数是一个<code>Test</code>类型的临时对象”给撞脸了。引发了二义性。</p>\n<p>解决方法也很简单，我们知道表示“值”的时候，套一层或者多层括号是不影响“值”的意义的：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 下面都等价</span>\na<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>那么表示“函数调用”时，传值也是可以套多层括号的：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>但是当你表示函数声明的时候，你就不能套多层括号了：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数声明</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR，错误语法</span>\n</code></pre>\n<p>所以，第一种解决方法就是，套一层括号，那么就只能解释为“函数调用”而不是“函数声明”了：</p>\n<pre><code class=\"prism language-cpp\">Data <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义对象data，不会出现二义性</span>\n</code></pre>\n<p>第二种方法就是不要用小括号表示构造参数，而是换成大括号：</p>\n<pre><code class=\"prism language-cpp\">Data data<span class=\"token punctuation\">{<!-- --></span>Test<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 大括号表示构造参数列表，不能表示函数类型</span>\n</code></pre>\n<p>在要不就不要用临时对象，改用普通变量：</p>\n<pre><code class=\"prism language-cpp\">Test t<span class=\"token punctuation\">;</span>\nData data<span class=\"token punctuation\">{<!-- --></span>t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"_276\"></a>模板参数嵌套时的二义性</h3>\n<p>当两个模板参数套在一起的时候，两个<code>&gt;</code>会碰在一起：</p>\n<pre><code class=\"prism language-cpp\">std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;&gt;</span> ve<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里出现了一个&gt;&gt;</span>\n</code></pre>\n<p>而这和参数中的右移运算给撞脸了：</p>\n<pre><code class=\"prism language-cpp\">std<span class=\"token double-colon punctuation\">::</span>array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token operator\">&gt;&gt;</span> <span class=\"token number\">5</span><span class=\"token operator\">&gt;</span> arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里也出现了一个&gt;&gt;</span>\n</code></pre>\n<p>在C++11以前，<code>&gt;&gt;</code>会优先识别为右移符号，因此对于模板嵌套，就必须加空格：</p>\n<pre><code class=\"prism language-cpp\">std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token operator\">&gt;</span> ve<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 加空格避免歧义</span>\n</code></pre>\n<p>但可能是因为模板参数右移的情况远远少过模板嵌套的情况，因此在C++11开始，把这种默认情况改了过来，遇见<code>&gt;&gt;</code>会识别为模板嵌套：</p>\n<pre><code class=\"prism language-cpp\">std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;&gt;</span> ve<span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n</code></pre>\n<p>但相对的，如果要进行右移运算的话，就会识别错误，解决方法是加括号</p>\n<pre><code class=\"prism language-cpp\">std<span class=\"token double-colon punctuation\">::</span>array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token operator\">&gt;&gt;</span> <span class=\"token number\">5</span><span class=\"token operator\">&gt;</span> arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR</span>\nstd<span class=\"token double-colon punctuation\">::</span>array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&gt;&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&gt;</span> arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK，要通过加小括号避免歧义</span>\n</code></pre>\n<h3><a id=\"_298\"></a>模板中类型定义和静态变量二义性</h3>\n<p>直接上代码：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  \tT<span class=\"token double-colon punctuation\">::</span>abc <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">T1</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> abc<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">T2</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">using</span> abc <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Test<span class=\"token operator\">&lt;</span>T1<span class=\"token operator\">&gt;</span> t1<span class=\"token punctuation\">;</span>\n  Test<span class=\"token operator\">&lt;</span>T2<span class=\"token operator\">&gt;</span> t2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Test</code>是一个模板类，里面取了参数<code>T</code>的成员<code>abc</code>。对于<code>T1</code>的实例化来说，<code>T1::abc</code>是一个整型变量，所以<code>T::abc *p</code>相当于两个变量相乘，<code>*</code>会理解为“乘法”。</p>\n<p>而对于<code>T2</code>来说，<code>T2::abc</code>是一个类型重命名，那么<code>T::abc *p</code>相当于定义一个<code>int</code>类型的指针，<code>*</code>会理解为指针类型。</p>\n<p>所以，对于模板<code>Test</code>来说，由于<code>T</code>还没有实例化，所以不能确定<code>T::abc</code>到底是静态变量还是类型重命名。因此会出现二义性。</p>\n<p>解决方式是用<code>typename</code>关键字，强制表名这里<code>T::abc</code>是一个类型：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token double-colon punctuation\">::</span>abc <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 一定表示指针定义</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>typename</code>关键字大家应该并不陌生，但一般都是在模板参数中见到的。其实在C++11以前，模板参数中表示“类型”参数的关键字是<code>class</code>，但用这个关键字会对人产生误导，其实这里不一定非要传类类型，传基本类型也是OK的，因此C++11的时候让<code>typename</code>可以承担这个责任，因为它更能表示“类型名称”这种含义。但其实在此之前<code>typename</code>仅仅是为了解决上面二义性问题的。</p>\n<p>另外值得说明的一点是，C++17以前，模板参数是模板的情况时仍然只能用<code>class</code>：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 要求参数要传一个模板类型，其含有两个类型参数</span>\n<span class=\"token comment\">// C++14及以前版本这里必须用class</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Temp</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">R</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">T1</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Test<span class=\"token operator\">&lt;</span>T1<span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 模板参数是模板的情况实例化</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>C++17开始才允许这个<code>class</code>替换为<code>typename</code>：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// C++17后可以用typename</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">Temp</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>第七篇（也是完结篇）已脱稿，请看<a href=\"https://blog.csdn.net/fl2011sx/article/details/126499619\">C++的缺陷和思考（七）</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-24 18:47:00", "summary": "本文继续来介绍的缺陷和笔者的一些思考。先序文章请看的缺陷和思考五的缺陷和思考四的缺陷和思考三的缺陷和思考二的缺陷和思考一模板的全特化先跑个小题，模板的模正确发音应该是，原本是工程上的术语，生产一种工件"}