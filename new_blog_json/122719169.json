{"blogid": "122719169", "writerAge": "码龄4年", "writerBlogNum": "49", "writerCollect": "116", "writerComment": "14", "writerFan": "51", "writerGrade": "3级", "writerIntegral": "796", "writerName": "司军礼", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122719169.jpg", "writerRankTotal": "72931", "writerRankWeekly": "68989", "writerThumb": "51", "writerVisitNum": "58591", "blog_read_count": "3493", "blog_time": "已于 2022-01-27 18:13:25 修改", "blog_title": "Protobuf 在Unity中的使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"Protobuf_0\"></a>什么是Protobuf</h1>\n<blockquote>\n<p>Google官方描述的大致意思为：</p>\n<ol><li>protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</li><li>灵活 高效的序列化数据结构的方法，比json和xml高效，并拥有强大的可拓展性以及良好的兼容性</li></ol>\n</blockquote>\n<p>因其更小的体积和更快的解析速度，所以Protobuf多用于网络数据交换。在说使用之前首先我们应该先把需要用到的资源下载下来并进行必要的配置</p>\n<h1><a id=\"ProtobufProtoc_7\"></a>Protobuf和Protoc的下载</h1>\n<p><code>Protobuf和Protoc下载链接</code>：https://github.com/protocolbuffers/protobuf/releases</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5ab2480850214b798dd3e7fdead2ea2a.png\"/></p>\n<h2><a id=\"ProtobufDll_11\"></a>Protobuf编译成Dll文件</h2>\n<p>用VS打开：<code>protobuf-3.19.3/csharp/src/Google.Protobuf.sln</code></p>\n<p>如果有输出如下错误，那就是因为vs使用的dotnet core sdk版本过高和proto工程里使用的sdk版本不一致导致的。可以打开<code>视图/终端</code>在命令行里通过dotnet --version 查看当前系统使用的dotnet core sdk版本，然后修改 proto 工程根目录的 global.json 文件中 sdk 版本号来解决。<br/> <code>Detailed Information: Unable to locate the .NET Core SDK. Check that it is installed and that the version specified in global.json (if any) matches the installed version.</code></p>\n<p>右键选中 Google.Protobuf 执行生成，即可生成 Google.Protobuf.dll 文件。生成的 dll 文件位于 bin/Debug 目录下。默认是生成 .Net 4.5的 dll，放在 net45 目录下。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\753369624be14a138a84abf3d6ed5c8c.png\"/><br/> 将net45目录下的所有文件拷贝到Unity工程中的Plugins文件夹下。</p>\n<h2><a id=\"Protoc_21\"></a>Protoc的使用</h2>\n<blockquote>\n<p>Protoc主要是用来将proto脚本转化为c# 脚本的。</p>\n</blockquote>\n<p>下载Protobuf-Unity插件放入Unity工程<br/> <code>Protobuf-Unity下载链接</code>：https://github.com/5argon/protobuf-unity<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d9cd00fd4b6b47d5bca4f6b6fee6a592.png\"/><br/> Unity工程打开<code>Editor/Preferences/Protobuf</code>并将下载的Protoc路径填入Path to protoc中<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\39843f7381804ed78a05cafebf88268d.png\"/>这个插件可以遍历Unity工程目录下的所有proto文件，并生成对应的c#文件。</p>\n<h1><a id=\"_29\"></a>使用</h1>\n<p><strong><code>Proto语言指南</code>：https://developers.google.com/protocol-buffers/docs/proto3</strong><br/> 首先手写一个proto格式的脚本，假设脚本名字叫ProtoTest.proto,并将这个proto脚本放入Unity工程中，proto脚本如下：</p>\n<pre><code>syntax = \"proto3\";\n\nmessage SJL {\n  string name = 1;\n  int32 age = 2;\n  int32 height = 3;\n}\n</code></pre>\n<p>Unity工程打开<code>Editor/Preferences/Protobuf</code>点击Force Compilation会在ProtoTest.proto文件所属的文件夹下自动生成一个ProtoTest.cs脚本，这个脚本就是由proto文件转化来的。</p>\n<p>写一个测试脚本来测试序列化和反序列化，如下：</p>\n<pre><code>using Google.Protobuf;\nusing System.IO;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class Demo : MonoBehaviour\n{\n    public string fileName = \"sjl.txt\";\n    private string dirPath = Application.streamingAssetsPath + \"/\";\n    private string filePath;\n    public Button WriteBtn;\n    public Button ReadBtn;\n\n    void Start()\n    {\n        if (!Directory.Exists(dirPath))\n        {\n            Directory.CreateDirectory(dirPath);\n#if UNITY_EDITOR\n            UnityEditor.AssetDatabase.Refresh();\n#endif\n        }\n\n        filePath = dirPath + fileName;\n        WriteBtn.onClick.AddListener(WriteTo);\n        ReadBtn.onClick.AddListener(ReadFrom);\n    }\n\n    /// &lt;summary&gt;\n    /// 序列化对象并保存到本地\n    /// &lt;/summary&gt;\n    public void WriteTo()\n    {\n        SJL sr = new SJL()\n        {\n            Name = \"sjl\",\n            Age = 26,\n            Height = 176\n        };\n\n        using (FileStream fs = File.OpenWrite(filePath))\n        {\n            byte[] bytes = sr.ToByteArray();\n            fs.Write(bytes, 0, bytes.Length);\n        }\n#if UNITY_EDITOR\n        UnityEditor.AssetDatabase.Refresh();\n#endif\n    }\n\n    /// &lt;summary&gt;\n    /// 反序列化文件\n    /// &lt;/summary&gt;\n    public void ReadFrom()\n    {\n        using (Stream stream = File.OpenRead(filePath))\n        {\n            SJL sjl = SJL.Parser.ParseFrom(stream);\n            Debug.LogFormat(\"Name:{0} Age:{1} Height:{2}\", sjl.Name, sjl.Age, sjl.Height);\n        }\n    }\n}\n\n</code></pre>\n<p>测试结果如下：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\544098c739eb4e6ba9c1e02691c8f2bf.png\"/></p>\n<p><a href=\"https://download.csdn.net/download/weixin_42498461/78145237\">Demo 下载</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-01-27 18:13:25", "summary": "什么是官方描述的大致意思为：是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于数据通信协议、数据存储等。灵活高效的序列化数据结构的方法，比和高效，并拥有强大的可拓展性以及良好的兼容性因其"}