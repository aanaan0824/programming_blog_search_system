{"blogid": "124794126", "writerAge": "码龄2年", "writerBlogNum": "121", "writerCollect": "64", "writerComment": "9", "writerFan": "12", "writerGrade": "4级", "writerIntegral": "1246", "writerName": "前端开发小陈", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124794126.jpg", "writerRankTotal": "17004", "writerRankWeekly": "8768", "writerThumb": "18", "writerVisitNum": "32073", "blog_read_count": "3996", "blog_time": "于 2022-05-16 10:05:19 发布", "blog_title": "【实战分享】js生成word(docx)，以及将word转成pdf解决方案分享", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>本文将记录如何用<code>js</code>生成<code>word</code>文件，并在<code>node服务器</code>端将<code>word</code>转换成<code>pdf</code>。记录的代码均是在真实业务场景中<strong>使用成功</strong>的代码，没有记录中间踩坑的过程。想直接抄答案的家人们可以跳转到<code>1.2 程序编写</code>部分，最终效果图可在<code>1.2 程序编写</code>部分中<code>4. 效果展示</code>模块查看。</p>\n<p>如果有更好的解决方案，也欢迎大家在评论区讨论、分享~</p>\n<p>本文demo存放地址：<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FChicKo1108%2Fdocxtemplater-demo\" title=\"https://github.com/ChicKo1108/docxtemplater-demo\">github.com/ChicKo1108/…</a></p>\n<h1><a id=\"DocxTemplaterjsword_6\"></a>一、DocxTemplater：使用js生成word</h1>\n<blockquote>\n<p>老铁们，话不多说，先上链接：<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fdocxtemplater.com%2F\" title=\"https://docxtemplater.com/\">Docxtemplater | Word, Powerpoint, Excel generation using templates in your application | docxtemplater</a></p>\n</blockquote>\n<p><code>DocxTemplater</code>是一个基于<code>模板</code>生成最终文件的插件，它通过一个简单的<code>{tag}</code>语法将预设的数据填入模板<code>Word</code>或者<code>Powerpoint</code>中，帮助开发者快速生成最终文件。</p>\n<p>由于<code>DocxTemplater</code>是基于<code>{tag}</code>变量替换，得到最终的文件，因此文件的<strong>样式是非常可控的</strong>。在开发过程中，设计师只需要出一版最终的成品word，开发者将内容替换成对应的<code>{tag}</code>即可（再也不用被设计师追着还原设计稿了！）。</p>\n<p><code>DocxTemplater</code>是一个收费的库，但是它拥有<strong>免费的开源版本</strong>，对于我所涉及的业务，使用免费版本完全可以解决。</p>\n<p>开源版包括的功能包括：</p>\n<ul><li><code>{tag}</code>替换</li><li>条件判断</li><li>循环</li><li>图片渲染</li></ul>\n<p>除免费版外，它还拥有<code>pro plan(950€ per\\year)</code>、<code>Entreprise plan(24500€ per\\year)</code>，具体功能大家可以前往官网查看。<sub>（但是白嫖的永远是最香的！）</sub></p>\n<p>由于我的业务只涉及生成word和pdf，所以本文只介绍word的相关内容，如果需要处理ppt，大家可前往官网自行学习。</p>\n<h2><a id=\"11__28\"></a>1.1 模板语法</h2>\n<p>在了解模板语法之前，我们需要先创建一个<code>tempalte.docx</code>模板文件。</p>\n<h3><a id=\"_33\"></a>变量替换</h3>\n<p>变量使用<code>{key}</code>标签，在<code>tempalte.docx</code>文件中输入以下模板：</p>\n<pre><code>Hello, my name is {name}. \n</code></pre>\n<p>然后准备以下数据：</p>\n<pre><code>let data = {\n    name: \"千万\",\n} \n</code></pre>\n<p>最终我们生成的docx文件将会是：</p>\n<pre><code>Hello, my name is 千万. \n</code></pre>\n<h3><a id=\"_55\"></a>条件判断</h3>\n<p>条件判断使用<code>{#key}</code>开始，使用<code>{/key}</code>结束，最简单的用法是使用<code>Boolean</code>类型数据进行填充。</p>\n<pre><code>Hello, my name is {name}.\n{#hasAge}I'm {age} years old.{/hasAge}\n{#hasWeight}My weight is {weight}.{/hasWeight} \n</code></pre>\n<p>然后准备以下数据：</p>\n<pre><code>let data = {\n    name: \"千万\",\n    hasAge: true,\n    age: 23,\n    hasWeight: false,\n} \n</code></pre>\n<p>最终我们生成的docx文件将会是：</p>\n<pre><code>Hello, my name is 千万.\nI'm 23 years old. \n</code></pre>\n<p>除了<code>Boolean</code>类型的数据以外，我们也可以填充其他类型：</p>\n<table><thead><tr><th>type</th><th>是否显示模块</th></tr></thead><tbody><tr><td>false / 空数组</td><td>不显示</td></tr><tr><td>非空数组</td><td>显示，且将循环渲染内部元素</td></tr><tr><td>对象</td><td>显示，且使用对象内部变量替换{tag}</td></tr><tr><td>其他真值</td><td>显示</td></tr></tbody></table>\n<p>如果变量填充了<code>数组</code>，其实就是我们下面要介绍的<code>循环</code>语法，在下面一小节中再进行介绍。</p>\n<p>在这里简单说一下填充<code>对象</code>的情况：</p>\n<p>准备word模板如下：</p>\n<pre><code>总价格：{price}\n{#product} ${productName}: ${price} {/product} \n</code></pre>\n<p>准备数据如下：</p>\n<pre><code>let data = {\n    price: 159,\n    product: {\n        productName: 'pencel',\n        price: 1.2\n    }\n} \n</code></pre>\n<p>最终我们生成的docx文件将会是：</p>\n<pre><code>总价格：159\npencel：$1.2 \n</code></pre>\n<h3><a id=\"_122\"></a>循环</h3>\n<p><code>循环</code>的标志与<code>条件判断</code>相同，但对应的变量应使用<code>Array</code>来填充。</p>\n<pre><code>{#examScoreList}\n    {exam}: {score}\n{/examScoreList} \n</code></pre>\n<p>然后我们填充以下数据：</p>\n<pre><code>let data = {\n    examScoreList: [\n        { exam: 数学, score: 60 },\n        { exam: 语文, score: 50 },\n        { exam: 英语, score: 40 },\n    ],\n} \n</code></pre>\n<p>最终我们生成的docx文件将会是：</p>\n<pre><code> 数学： 60\n    语文： 50\n    英语： 40 \n</code></pre>\n<h4><a id=\"_152\"></a>表格循环</h4>\n<p>值得注意的是，循环不仅仅可以循环一段普通文字，我们也可以对<code>表格</code>进行循环，包括：循环行和循环整个表。如果想要循环渲染多个表格，只需要在表格外面使用<code>循环</code>语法即可，不在此处过多赘述。下面展示循环渲染一个表中的行的写法：</p>\n<p><img alt=\"image.png\" src=\"..\\..\\static\\image\\81f9ebbf54e5a2f0f24bda5ee076847e.png\"/></p>\n<p>上图中可以看到，我在表格的第二行中使用了<code>循环</code>语法进行填写，这样我们最终生成的文档中，表头和尾就不会被循环，第二行将会被多次渲染，结果如下：</p>\n<p><img alt=\"image.png\" src=\"..\\..\\static\\image\\2bb75aabed89ab92bc7f8981f8617602.png\"/></p>\n<h3><a id=\"_162\"></a>图片</h3>\n<p>图片使用<code>{%image}</code>进行标注即可，对于图片的数据传入需要特殊处理，后面的部分会进行介绍。</p>\n<h3><a id=\"_166\"></a>总结</h3>\n<p>根据以上语法，我们就可以准备对应的word模板文件了，大部分场景下应该都可以满足。在准备模板的时候，固定的文案和样式直接保留在文档中即可，包括页眉、页脚，各个段落的行距、间距，文字的字体、大小等。其他需要根据真实数据渲染的值，就用标签标注上。准备好模板文件以后，就可以开始脚本函数的编写了。</p>\n<p>PS: 要善用表格进行排版布局！</p>\n<h2><a id=\"12__172\"></a>1.2 程序编写</h2>\n<h3><a id=\"_175\"></a>安装所需库</h3>\n<pre><code>npm install docxtemplater\nnpm install docxtemplater-image-module-free // 图片模块，没有图片需求可以不装\nnpm install pizzip // 处理模板文件用到，且只能使用该库 \n</code></pre>\n<h3><a id=\"_183\"></a>客户端生成</h3>\n<h4><a id=\"1_binaryString_185\"></a>1. 获取模板文件的<code>binaryString</code></h4>\n<pre><code>function getFileBinaryString(templateFile) { // templateFile是File对象\n  return new Promise((resolve, reject) =&gt; {\n    const reader = new FileReader();\n    reader.onload = (e) =&gt; {\n      resolve(e.target.result);\n    }\n    reader.onerror = reject;\n    reader.readAsBinaryString(templateFile);\n  });\n} \n</code></pre>\n<p>这里使用到了<code>FileReader</code>类，用于将模板文件转换为<code>binaryString</code>，需要注意浏览器的兼容性。</p>\n<p>如果对兼容性有要求，可以是使用<code>pizzip/utils</code>中提供的方法<code>getBinaryContent</code>，但是此库对ts兼容性比较差，因此我在实际代码中使用了<code>FileReader</code>。</p>\n<pre><code>import PizZipUtils from \"pizzip/utils/index.js\";\n\nfunction loadFile(url, callback) { PizZipUtils.getBinaryContent(url, callback); } \n</code></pre>\n<h4><a id=\"2__210\"></a>2. 生成最终文件（无需图片）</h4>\n<pre><code>// generate-doxc.js\n\nimport PizZip from 'pizzip';\nimport DocxTemplater from 'docxtemplater';\n\nfunction getFileBinaryString(templateFile) {\n  return new Promise((resolve, reject) =&gt; {\n    const reader = new FileReader();\n    reader.onload = (e) =&gt; {\n      resolve(e.target.result);\n    }\n    reader.onerror = reject;\n    reader.readAsBinaryString(templateFile);\n  });\n}\n\nexport async function generateDocxFile(template, fileData) {\n  return new Promise((resolve, reject) =&gt; {\n    getFileBinaryString(template)\n      .then(templateData =&gt; {\n        const zip = new PizZip(templateData);\n        const doc = new DocxTemplater()\n          .loadZip(zip)\n          .render(fileData); // fileData是我们需要定义好，传给docxtempale的数据。\n        const out = doc.getZip().generate({\n          type: 'blob',\n          mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        });\n        resolve(out);\n      })\n      .catch(reject);\n  });\n} \n</code></pre>\n<h4><a id=\"3__248\"></a>3. 准备数据，生成最终文件</h4>\n<p>接下来我们准备一个<code>&lt;input type=\"file\" /&gt;</code>的文件输入框（你也可以使用网络请求，或者<strong>任何方式</strong>拿到文件，只要最终获得二进制数据就可以），用来获取模板文件。同时准备好相应的数据，来对模板进行填充。</p>\n<pre><code>// App.jsx\n\nimport { saveAs } from 'file-saver';\nimport { generateDocxFile } from './utils/generate-docx';\n\nconst fileData = {\n  intro: '国际劳动节，又称五一国际劳动节、劳动节、国际示威游行日，是纪念工人和劳工运动的斗争和成果的日子。国际劳动节是一项由国际劳工运动所推动的节日，全世界劳工和工人阶级在一般会在五朔节（5月1日）举行的庆祝节日，而美国和加拿大在9月第一个星期一举行。是世界上80多个国家的劳动节。',\n  activities: [\n    {\n      name: '阿尔及利亚',\n      activity: '在阿尔及利亚，5月1日是公共假日，以庆祝劳动节。'\n    },\n    {\n      name: '安哥拉',\n      activity: '5月1日在安哥拉被承认为公共假日，称为劳动节。'\n    },\n    {\n      name: '埃及',\n      activity: '在埃及，5月1日被称为劳动节，是一个带薪的公共假期。在传统上，埃及总统会主持正式的五一节庆祝活动。'\n    },\n    {\n      name: '加纳',\n      activity: '5月1日是加纳的一个节日，属于庆祝全国所有工人。工会和劳工协会以游行的形式来庆祝劳动节。加纳也会举行阅兵式，通常由工会大会秘书长和各地区的区域秘书致辞。来自不同工作地点的工人通过条幅和衣着表明他们的公司。'\n    }\n  ]\n}\n\nfunction App() {\n  const handleFileChange = async (e) =&gt; {\n    const file = e.target.files[0];\n    const out = await generateDocxFile(file, fileData);\n    saveAs(out, `${new Date().getTime()}.docx`);\n  }\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;input type=\"file\" onChange={handleFileChange} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App; \n</code></pre>\n<h4><a id=\"4__297\"></a>4. 效果展示</h4>\n<p>模板文件如下：</p>\n<p><img alt=\"模板文件.png\" src=\"..\\..\\static\\image\\e7287e507801d12ba2d3e7e2c9a8473b.png\"/></p>\n<p>生成结果如下：</p>\n<p><img alt=\"结果1.png\" src=\"..\\..\\static\\image\\da4980b31602f83d3ceff705ff8127b5.png\"/></p>\n<h4><a id=\"5__307\"></a>5. 图片处理</h4>\n<p>如果需要在模板中使用图片，我们需要安装<code>docxtemplater-image-module-free</code>模块。</p>\n<p>引入了此模块后，需要在加载模板文件后，载入image模块，然后异步填入数据。</p>\n<pre><code>// generate-docx.js\n\n// 将图片处理为base64，给模板使用\nfunction convertImgToBase64(url, outputFormat) { \n  return new Promise((resolve, reject) =&gt; {\n    let canvas = document.createElement(\n      'CANVAS',\n    );\n    const ctx = canvas.getContext('2d'),\n      img = new Image();\n    img.crossOrigin = 'Anonymous';\n    img.onload = function () {\n      canvas.height = img.height;\n      canvas.width = img.width;\n      ctx.drawImage(img, 0, 0);\n      var dataURL = canvas.toDataURL(outputFormat || 'image/png');\n      canvas = null;\n      resolve(dataURL);\n    };\n    img.onerror = function (e) {\n      reject(e);\n    };\n    img.src = url;\n  });\n}\n\nconst imageOpts = { // 图片的配置\n  centered: false,\n  getImage: function (tagValue, tagName) { // 将图片转成base64\n    return new Promise((resolve) =&gt; {\n      if (typeof tagValue === 'string' &amp;&amp; base64Regex.test(tagValue)) {\n        return resolve(tagValue);\n      } else {\n        convertImgToBase64(tagValue).then((base64) =&gt; {\n          return resolve(base64Parser(base64));\n        });\n      }\n    });\n  },\n  // 设置图片宽高，可以根据tagName为每一张图片设置不同宽高\n  getSize: function (img, tagValue, tagName) {\n    // img是图片Buffer，tagValue是图片初始值，tagName是图片在模板中定义的标签key值\n    return [150, 150]; // [宽, 高]\n  }\n};\n\nexport async function generateDocxFile(template, fileData) {\n  return new Promise((resolve, reject) =&gt; {\n    getFileBinaryString(template)\n      .then(templateData =&gt; {\n        const zip = new PizZip(templateData);\n        const doc = new DocxTemplater()\n          .loadZip(zip)\n          .attachModule(new ImageModule(imageOpts)) // 载入模块\n          .compile();\n        // 异步填充数据\n        doc.resolveData(fileData)\n          .then(() =&gt; {\n            doc.render();\n            const out = doc.getZip().generate({\n              type: 'blob',\n              mimeType:\n                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            });\n            docxLists.push({ file: out, fileName });\n            resolve();\n          });\n      })\n      .catch(reject);\n  });\n} \n</code></pre>\n<p>对于有图片的文档生成，需要异步载入数据，且图片数据需要处理为base64，上述代码给出了处理图片的一种解决方案，如果大家有更高效的方法也可以自行使用。</p>\n<h3><a id=\"node_389\"></a>node服务器端生成</h3>\n<p>该库同样支持在<code>node</code>中使用，其思想与在浏览器端基本一致，在node端可以直接使用<code>buffer</code>，下面贴出官方给出的代码示例。</p>\n<pre><code>const PizZip = require(\"pizzip\"); \nconst Docxtemplater = require(\"docxtemplater\"); \nconst fs = require(\"fs\");\nconst path = require(\"path\"); // Load the docx file as binary content\n\nconst content = fs.readFileSync( path.resolve(__dirname, \"input.docx\"), \"binary\" );\nconst zip = new PizZip(content);\nconst doc = new Docxtemplater(zip,\n{\n    paragraphLoop: true,\n    linebreaks: true,\n}); // Render the document (Replace {first_name} by John, {last_name} by Doe, ...)\n\ndoc.render({\n    first_name: \"John\",\n    last_name: \"Doe\",\n    phone: \"0652455478\",\n    description: \"New Website\",\n});\n\nconst buf = doc.getZip().generate({\n    type: \"nodebuffer\",\n    // compression: DEFLATE adds a compression step.\n    // For a 50MB output document, expect 500ms additional CPU time \n    compression: \"DEFLATE\",\n});\n\n// buf is a nodejs Buffer, you can either write it to a file or res.send it with express for example.\nfs.writeFileSync(path.resolve(__dirname, \"output.docx\"), buf); \n</code></pre>\n<h2><a id=\"13__425\"></a>1.3 总结</h2>\n<p><code>docxTemplater</code>是一个通过模板文件生成word的库，它能最大程度的保证最终生成的word的样式的完整和还原。代码搭建好后，对于类似的业务，开发者们只需要编写更多的<code>模板文件</code>，并且把精力集中在对<code>数据</code>的处理上即可。</p>\n<p>配合<code>e-charts</code>或其他图表库，也可以让我们实现报表文件的生成。</p>\n<p>此外，对于<code>pizzip</code>这个库，它本身是对<code>jszip</code>库的一个升级，拥有对zip文件的操作能力，可以直接解压或者生成zip包，我们可以直接通过此库对批量生成的文件进行打包处理，打包主要用的api如下：</p>\n<pre><code>const zip = new pizZip();\nzip.file(fileName, fileBuffer); // 生成的文件名 以及 文件的 arrayBuffer\nzip.generate({ type: 'blob' }), `documents.zip`); // 生成zip文件 \n</code></pre>\n<h1><a id=\"libre_officewordpdf_440\"></a>二、使用libre office将word转换成pdf</h1>\n<p>在进行此部分业务时，原本想在前端把所有的工作都做好，但是没有找到在客户端就直接转换的方法。因此，此部分在服务器端进行解决。</p>\n<p>首先需要在机器上安装<code>libre office</code>软件，具体方法可以自行搜索。</p>\n<p>安装好后，项目中安装<code>libreoffice-convert</code>库，这个库对<code>libre office</code>的转换方法进行了封装，直接调用其中方法就好：</p>\n<pre><code>const path = require('path');\nconst fs = require('fs');\nconst libre = require('libreoffice-convert');\n\nasync function docx2pdf(docxBuf, outputPath) {\n  libre.convert(docxBuf, '.pdf', undefined, (err, outputBuf) =&gt; {\n      if (err) {\n        console.log(`Error converting file: ${err}`);\n      }\n      fs.writeFileSync(outputPath, outputBuf);\n   });\n}\n\nconst inputBuf = fs.readFileSync(path.join(__dirname, 'sample.docx'));\nlet outputPath = path.join(__dirname, 'sample.pdf');\n\ndocx2pdf(inputBuf, outputPath); \n</code></pre>\n<p>如果是zip文件，同样可以安装<code>jsZip</code>或者<code>pizZip</code>进行解压、打包等处理。这里更推荐使用<code>jsZip</code>，因为文档更加丰富，且对ts支持更好。</p>\n<h1><a id=\"_471\"></a>三、结束语</h1>\n<p>这是我第二次遇到此类业务，所以本着<strong>学习、记录、分享</strong>的心态，将内容分享到平台上。在开发过程中遇到了很多“坑”，并没有在本文中记录。本文主要还是以记录最终成功的代码为主，把内容分享给其他有同样需求的家人们。毕竟轮子已经这么完善了，当然要好好利用啦！</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-16 10:05:19", "summary": "本文将记录如何用生成文件，并在服务器端将转换成。记录的代码均是在真实业务场景中使用成功的代码，没有记录中间踩坑的过程。想直接抄答案的家人们可以跳转到程序编写部分，最终效果图可在程序编写部分中效果展示模"}