{"blogid": "126149483", "writerAge": "码龄2年", "writerBlogNum": "93", "writerCollect": "5031", "writerComment": "5454", "writerFan": "4922", "writerGrade": "7级", "writerIntegral": "13521", "writerName": "一名不会打字的程序员", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126149483.jpg", "writerRankTotal": "786", "writerRankWeekly": "73", "writerThumb": "5255", "writerVisitNum": "78827", "blog_read_count": "890", "blog_time": "已于 2022-08-06 07:54:02 修改", "blog_title": "面向对象之【探索C++】硬核 | 造轮子的快乐源泉【引用篇】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/f7f5e8f696074d79bb7c7cfaab2ea5d2.gif#pic_center\"/></p>\n<blockquote>\n<p>🐧<strong>主页详情</strong>：<a href=\"https://blog.csdn.net/weixin_51568389?spm=1011.2435.3001.5343\">Choice~的个人主页</a><br/> 📢<strong>作者简介</strong>：🏅物联网领域创作者🏅 and 🏅阿里专家博主🏅 and 🏅华为云享专家🏅<br/> ✍️<strong>人生格言</strong>：最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。<br/> 🧑‍💻<strong>人生目标</strong>：做一名合格的程序员，做完成的梦：实现财富自由。<br/> 🚩<strong>技术方向</strong>：NULL<br/> 🀄如果觉得博主的文章还不错的话，请三连支持一下博主哦<br/> 💬给大家介绍一个我一直在用的求职刷题收割offe👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_choice_c\">点击进入网站</a><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/82d71920140c4d00bed64d597eb44a93.gif#pic_center\"/></p>\n</blockquote>\n<blockquote>\n<p>🏫<strong>系列专栏</strong>(<strong>免费</strong>)：<br/> 1️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11830402.html\">C语言进阶</a><br/> 2️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11816257.html\">数据结构与算法(C语言版)</a><br/> 3️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11846393.html\">Linux宝典</a><br/> 4️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11913272.html\">C++从入门到精通</a><br/> 5️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11849487.html?spm=1001.2014.3001.5482\">C++从入门到实战</a><br/> 6️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11865484.html\">JavaScript从入门到精通</a><br/> 7️⃣<a href=\"https://blog.csdn.net/weixin_51568389/category_11855792.html\">101算法JavaScript描述</a><br/> 8️⃣<a href=\"https://blog.csdn.net/weixin_51568389/category_11919872.html\">微信小程序零基础开发</a><br/> 9️⃣<a href=\"https://blog.csdn.net/weixin_51568389/category_11908469.html?spm=1001.2014.3001.5482\">牛客网刷题笔记</a><br/> 🔟<a href=\"https://blog.csdn.net/weixin_51568389/category_11950200.html\">计算机行业知识(补充)</a></p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_24\">一：引用的基础语法以及注意事项</a></li><li><ul><li><a href=\"#1_26\">1.引用基本语法</a></li><li><a href=\"#2_79\">2.引用必须初始化</a></li><li><a href=\"#3_96\">3.对数组建立引用</a></li></ul>\n</li><li><a href=\"#_134\">二：函数中的引用</a></li><li><ul><li><a href=\"#1_138\">1.值传递</a></li><li><a href=\"#2_181\">2.地址传递</a></li><li><a href=\"#3__209\">3. 引用传递</a></li></ul>\n</li><li><a href=\"#_243\">三：引用的注意事项</a></li><li><ul><li><a href=\"#1_245\">1.引用必须引一块合法的内存空间</a></li><li><a href=\"#2_261\">2.不要返回局部变量的引用</a></li><li><a href=\"#3_323\">3.函数调用可为左值，函数返回值需引用</a></li></ul>\n</li><li><a href=\"#_347\">四：引用的本质</a></li><li><a href=\"#__374\">五 ：指针的引用</a></li><li><ul><li><a href=\"#1_393\">1.指针的指针开辟空间：</a></li><li><a href=\"#2_413\">2.利用指针的引用开辟空间</a></li></ul>\n</li><li><a href=\"#_438\">六：常量引用</a></li><li><ul><li><a href=\"#const_477\">const引用使用场景</a></li></ul>\n</li><li><a href=\"#_496\">重点回顾</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_24\"></a>一：引用的基础语法以及注意事项</h1>\n<h2><a id=\"1_26\"></a>1.引用基本语法</h2>\n<blockquote>\n<p>**引用是c++对c的重要扩充。**在c/c++中指针的作用基本都是一样的，但是c++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是c++的发明。</p>\n</blockquote>\n<ul><li>变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)</li><li>程序中通过变量来申请并命名内存空间</li><li>通过变量的名字可以使用存储空间</li></ul>\n<p>基本语法：</p>\n<pre><code>Type&amp; ref = val;\n</code></pre>\n<p>注意事项：</p>\n<ul><li>&amp;在此不是求地址运算，而是起标识作用。</li><li>类型标识符是指目标变量的类型</li><li>必须在声明引用变量时进行初始化。</li><li>引用初始化之后不能改变。</li><li>不能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li><li><strong>可以建立对数组的引用。</strong></li></ul>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\n//1.引用基本语法 Type &amp;别名 = 原名\nvoid test01()\n{\n\tint a = 10;\n\tint &amp;b = a;\n\n\tb = 20;\n\tcout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;\n}\n\nint main()\n{\n\n\ttest01();\n\n\treturn 0;\n}\n</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"image-20220803162145166\" src=\"..\\..\\static\\image\\8af13179ec30f9841a3c85dcddeceae0.png\"/></p>\n<p><img alt=\"image-20220803160150121\" src=\"..\\..\\static\\image\\87668c82ee4714fb41dcc8840d85a8e0.png\"/></p>\n<h2><a id=\"2_79\"></a>2.引用必须初始化</h2>\n<p><img alt=\"image-20220803162412025\" src=\"..\\..\\static\\image\\e8e4b7695a4c3f255282e400ff96375e.png\"/></p>\n<pre><code class=\"prism language-c++\">//2.引用必须初始化\nvoid test02()\n{\n\n\tint a = 10;//必须初始化\n\tint &amp;b = a;//引用初始哈后不可以进行修改了\n\tint c = 20;\n\n\tb = c;//赋值！！！\n}\n</code></pre>\n<h2><a id=\"3_96\"></a>3.对数组建立引用</h2>\n<p><img alt=\"image-20220803163558933\" src=\"..\\..\\static\\image\\6d21e76c749a8bf5c6a2d5b4066f3658.png\"/></p>\n<pre><code class=\"prism language-c++\">//3.数组起别名\nvoid test03()\n{\n\tint arr[10];\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tarr[i] = i;\n\n\t}\n\t//数组起别名\n\tint(&amp;pArr)[10] = arr;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tcout &lt;&lt; pArr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n</code></pre>\n<p>第二种数组起别名：</p>\n<pre><code class=\"prism language-c++\">\t//第二种方式 起别名\n\ttypedef int(ARRAYREF)[10];//一个具有10个元素的int类型的数组\n\tARRAYREF &amp; pArr2 = arr;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tcout &lt;&lt;pArr2[i] &lt;&lt; \" \";\n\t}\n</code></pre>\n<p>运行结果一样的：<img alt=\"image-20220803170942998\" src=\"..\\..\\static\\image\\24b25e10ea859def2704c574f497c373.png\"/></p>\n<h1><a id=\"_134\"></a>二：函数中的引用</h1>\n<p>交换两个变量的值</p>\n<h2><a id=\"1_138\"></a>1.值传递</h2>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n//值传递\nvoid swap(int a, int b)\n{\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\tcout &lt;&lt; \"swap::a=\" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"swap::b=\" &lt;&lt; b &lt;&lt; endl;\n}\n\nvoid test01()\n{\n\tint a = 3;\n\tint b = 5;\n\tswap(a, b);//值传递\n\tcout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; endl;\n}\n  \nint main()\n{\n\ttest01();\n\n\treturn 0;\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"prism language-c++\">swap::a=5\nswap::b=3\na=3\nb=5\n</code></pre>\n<p>原因是函数传递的是形参，一份实参的临时拷贝，当函数结束，swap的数据就消失了</p>\n<h2><a id=\"2_181\"></a>2.地址传递</h2>\n<p>然后我们用指针的方式交换两个变量的值：</p>\n<pre><code class=\"prism language-c++\">void swap(int *a, int *b)\n{\n\tint tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n\tcout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; endl;\n}\n\n\nvoid test02()\n{\n\tint a = 3;\n\tint b = 5;\n\tswap(&amp;a, &amp;b);//地址传递\n\tcout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; endl;\n\n}\n</code></pre>\n<p><img alt=\"image-20220803174457342\" src=\"..\\..\\static\\image\\8a917a7f72524ff4f7eff0054938bb10.png\"/></p>\n<h2><a id=\"3__209\"></a>3. 引用传递</h2>\n<p><strong>&amp;引用</strong>传递类似于传地址，这就是c++的特性，引用这块，就不用再使用二级指针了；需要用引用表达二级指针<code>*&amp;a</code></p>\n<pre><code class=\"prism language-c++\">void swap3(int &amp;a, int &amp;b)\n{\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n}\n  \nvoid test03()\n{\n\tint a = 3;\n\tint b = 5;\n\tswap(a, b);\n\tcout &lt;&lt; \"引用传递的a=\" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"引用传递的b=\" &lt;&lt; b &lt;&lt; endl;\n}\n</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"image-20220803174929477\" src=\"..\\..\\static\\image\\2e44d5ca6340dc4a5fb5780a27c13256.png\"/></p>\n<p>通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单：</p>\n<ol><li> <p>函数调用时传递的实参不必加“&amp;”符</p> </li><li> <p>在被调函数中不必在参数前加“*”符</p> </li></ol>\n<p>引用作为其它变量的别名而存在，因此在一些场合可以代替指针。C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。</p>\n<h1><a id=\"_243\"></a>三：引用的注意事项</h1>\n<h2><a id=\"1_245\"></a>1.引用必须引一块合法的内存空间</h2>\n<pre><code class=\"prism language-c++\">void test04()\n{\n    //错误\n\tint &amp;a = 10;//引用必须是一块合法的空间\n}\n</code></pre>\n<p><img alt=\"image-20220803175413496\" src=\"..\\..\\static\\image\\72010c3f0500279a8b0c4c9174fc0e48.png\"/></p>\n<p>后期我们可以用const给他强制初始化一块空间<code>const int &amp;a = 10;</code></p>\n<h2><a id=\"2_261\"></a>2.不要返回局部变量的引用</h2>\n<pre><code class=\"prism language-c++\">int&amp; doWork()\n{\n\tint a = 10;\n\treturn a;\n}\nvoid test04()\n{\n\t//error\n\t//int &amp;a = 10;//引用必须是一块合法的空间\n\n\tint &amp;ret = doWork();\n\tcout &lt;&lt; \"ret=\"&lt;&lt;ret &lt;&lt; endl;\n\n}\n</code></pre>\n<p>我们看一下结果：</p>\n<p><img alt=\"image-20220803180226435\" src=\"..\\..\\static\\image\\0bfc5296fbc53c115618a71fbdbc56cd.png\"/></p>\n<p>我们试试用多个输出看看：</p>\n<pre><code class=\"prism language-c++\">\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n</code></pre>\n<p><img alt=\"image-20220803180358441\" src=\"..\\..\\static\\image\\1df1040411254059f46755d8b4903674.png\"/></p>\n<p>这是因为：<strong>第一次输出10编译器做了优化</strong>，编译器做的好事；当我们第一次输出10的时候，函数doWork会被销毁，再次调用的时候就找不到了，就会出现乱码，所以<em>不要返回局部变量引用</em></p>\n<p>我们用<code>static</code>修饰为静态变量</p>\n<pre><code class=\"prism language-c++\">int&amp; doWork2()\n{\n\t//用静态变量试试\n\tstatic int a = 10;\n\treturn a;\n\n}\nvoid test05()\n{\n\n\tint &amp;ret = doWork2();\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n}\n</code></pre>\n<p><img alt=\"image-20220803181133560\" src=\"..\\..\\static\\image\\e7d73e25a2f780fe3d92f211e14a03dd.png\"/></p>\n<h2><a id=\"3_323\"></a>3.函数调用可为左值，函数返回值需引用</h2>\n<pre><code class=\"prism language-c++\">int&amp; doWork2()\n{\n\t//用静态变量试试\n\tstatic int a = 10;\n\treturn a;\n\n}\nvoid test05()\n{\n\n\tint &amp;ret = doWork2();\n\n\t//如果函数的返回值是引用，那么这个函数调用可以作为左值\n\n\tdoWork2() = 1000;//相当于写了a=1000;\n\tcout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl;\n}\n</code></pre>\n<p><img alt=\"image-20220803181917713\" src=\"..\\..\\static\\image\\58874bc342fadc006d3a6ee1edaa4277.png\"/></p>\n<h1><a id=\"_347\"></a>四：引用的本质</h1>\n<p><strong>引用的本质在c++内部实现是一个指针常量.</strong></p>\n<pre><code class=\"prism language-c++\">Type&amp; ref = val; // Type* const ref = &amp;val;\n</code></pre>\n<p>c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。</p>\n<pre><code class=\"prism language-c++\">//发现是引用，转换为 int* const ref = &amp;a;\nvoid testFunc(int&amp; ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n\tint&amp; aRef = a; //自动转换为 int* const aRef = &amp;a;这也能说明引用为什么必须初始化\n\taRef = 20; //内部发现aRef是引用，自动帮我们转换为: *aRef = 20;\n\tcout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"aRef:\" &lt;&lt; aRef &lt;&lt; endl;\n\ttestFunc(a);\n\treturn EXIT_SUCCESS;\n}\n\n</code></pre>\n<h1><a id=\"__374\"></a>五 ：指针的引用</h1>\n<p>在c语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样:</p>\n<pre><code class=\"prism language-c++\">void fun(int**);\n</code></pre>\n<p>给指针变量取一个别名。</p>\n<pre><code class=\"prism language-c++\">Type* pointer = NULL;  \nType*&amp; = pointer;\n</code></pre>\n<p>T<code>ype* pointer = NULL; Type*&amp; = pointer;</code></p>\n<h2><a id=\"1_393\"></a>1.指针的指针开辟空间：</h2>\n<pre><code class=\"prism language-c++\">void allocatMeMory(Person **p)//**p具体的Person对象  *p对象的指针 p指针的指针\n{\n\t*p =(Person*)malloc(sizeof(Person));\n\t(*p)-&gt;m_Age = 100;\n\n}\nvoid test01()\n{\n\tPerson *p = NULL;\n\tallocatMeMory(&amp;p);\n\tcout &lt;&lt; \"p的年龄：\" &lt;&lt; p-&gt;m_Age &lt;&lt; endl;\n\n}\n</code></pre>\n<p><u>**p具体的Person对象 *p对象的指针 p指针的指针</u></p>\n<h2><a id=\"2_413\"></a>2.利用指针的引用开辟空间</h2>\n<pre><code class=\"prism language-c++\">//指针引用\nvoid allocatMemoryByRef(Person * &amp;p)//使用引用取别名\n{\n\tp = (Person*)malloc(sizeof(Person));\n\tp-&gt;m_Age = 1000;\n\n}\nvoid test02()\n{\n\tPerson *p = NULL;\n\tallocatMemoryByRef(p);\n\tcout &lt;&lt; \"p的年龄：\" &lt;&lt; p-&gt;m_Age &lt;&lt; endl;\n\n}\n</code></pre>\n<p><img alt=\"image-20220803184029840\" src=\"..\\..\\static\\image\\a5a8a8a1c78c695e4dbee7cbd54c69a2.png\"/></p>\n<p>对于c++中的定义那个，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。</p>\n<h1><a id=\"_438\"></a>六：常量引用</h1>\n<p>常量引用的定义格式:</p>\n<pre><code class=\"prism language-c++\">const Type&amp; ref = val;\n</code></pre>\n<p>常量引用注意：</p>\n<ul><li>n字面量不能赋给引用，但是可以赋给const引用</li><li>const修饰的引用，不能修改。</li></ul>\n<pre><code class=\"prism language-c++\">void test01()\n{\n\n\t//int &amp;ref = 10;//引用了不合法的内存，不可以\n\n\tconst int &amp;ref = 10;//加入const后，编译器处理方式为：int tmp=10;const int &amp;ref=tmp;\n\n}\n</code></pre>\n<p>产生一个临时变量tmp:<code>int tmp=10;const int &amp;ref=tmp;</code></p>\n<p>尝试修改常量的值：</p>\n<p><img alt=\"image-20220803184536761\" src=\"..\\..\\static\\image\\ef079bed073398af4caa80387418f0a5.png\"/></p>\n<p>通过加入下面的代码修改ref值（不建议）</p>\n<pre><code class=\"prism language-c++\">int *p = (int*)&amp;ref;\n\t*p = 1000;\n</code></pre>\n<p><img alt=\"image-20220803184814419\" src=\"..\\..\\static\\image\\a98ee30e9e799d7768bc769803778082.png\"/></p>\n<h2><a id=\"const_477\"></a>const引用使用场景</h2>\n<blockquote>\n<p>常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。</p>\n<p>将函数的形参定义为常量引用的好处:</p>\n<p>Ø 引用不产生新的变量，减少形参与实参传递时的开销。</p>\n<p>Ø 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。</p>\n<p>如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。</p>\n</blockquote>\n<pre><code class=\"prism language-c++\">//const int&amp; param防止函数中意外修改数据\nvoid ShowVal(const int&amp; param){\n\tcout &lt;&lt; \"param:\" &lt;&lt; param &lt;&lt; endl;\n}\n</code></pre>\n<h1><a id=\"_496\"></a>重点回顾</h1>\n<blockquote>\n<p>6 引用基本语法</p>\n<p>6.1.1 用途起别名</p>\n<p>6.1.2 Type &amp;别名 = 原名</p>\n<p>6.1.3 引用必须初始化</p>\n<p>6.1.4 一旦初始化后 不能修­­改</p>\n<p>6.1.5 对数组建立引用</p>\n<p>6.2 参数3种传递方式</p>\n<p>6.2.1 值传递</p>\n<p>6.2.2 地址传递</p>\n<p>6.2.3 引用传递</p>\n<p>6.3 注意事项，不要返回局部变量的引用</p>\n<p>6.4 如果函数返回值是引用，那么函数的调用可以作为左值</p>\n<p>6.5 引用的本质 就是一个指针常量</p>\n<p>7 指针的引用</p>\n<p>7.1 用一级指针引用 可以代替二级指针</p>\n<p>8 常量引用</p>\n<p>8.1 使用场景 修饰形参为只读</p>\n<p>8.2 const int &amp;a = 10;会分配内存</p>\n</blockquote>\n<p>上一篇<a href=\"http://t.csdn.cn/tld20\">【C++】VS【C】之 const 大战（揭开常量的秘密）</a></p>\n<p>首篇<a href=\"http://t.csdn.cn/BPmlc\">面向对象之【探索C++】硬核 | 造轮子的快乐源泉</a></p>\n<ul><li>如果对大家有帮助，请三连支持一下！</li><li>有问题欢迎评论区留言，及时帮大家解决！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\24abe592dae640c08fe984da749d08ae.jpeg\"/></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 1, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-08-06 07:54:02", "summary": "在这里插入图片描述主页详情：的个人主页作者简介：物联网领域创作者阿里专家博主华为云享专家人生格言：最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。人生目标：做一名合格的程序员，做完成的梦："}