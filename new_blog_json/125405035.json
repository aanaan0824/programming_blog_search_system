{"blogid": "125405035", "writerAge": "码龄1年", "writerBlogNum": "65", "writerCollect": "29", "writerComment": "8", "writerFan": "423", "writerGrade": "3级", "writerIntegral": "670", "writerName": "鋮_拉姆", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125405035.jpg", "writerRankTotal": "42020", "writerRankWeekly": "13002", "writerThumb": "1", "writerVisitNum": "39741", "blog_read_count": "861", "blog_time": "于 2022-06-22 11:13:54 发布", "blog_title": "C++ 容器 详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"STL%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#STL%EF%BC%9A\">STL：</a></p>\n<p id=\"vector%E5%AE%B9%E5%99%A8%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#vector%E5%AE%B9%E5%99%A8%EF%BC%9A\">vector容器：</a></p>\n<p id=\"string%E5%AE%B9%E5%99%A8%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#string%E5%AE%B9%E5%99%A8%EF%BC%9A\">string容器：</a></p>\n<p id=\"deque%E5%AE%B9%E5%99%A8%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#deque%E5%AE%B9%E5%99%A8%EF%BC%9A\">deque容器：</a></p>\n<p id=\"stack%E5%AE%B9%E5%99%A8%EF%BC%9A(%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA)-toc\" style=\"margin-left:0px;\"><a href=\"#stack%E5%AE%B9%E5%99%A8%EF%BC%9A%28%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%29\">stack容器：(先进后出)</a></p>\n<p id=\"queue%E5%AE%B9%E5%99%A8%EF%BC%9A%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#queue%E5%AE%B9%E5%99%A8%EF%BC%9A%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89\">queue容器：（先进先出）</a></p>\n<p id=\"list%E5%AE%B9%E5%99%A8%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#list%E5%AE%B9%E5%99%A8%EF%BC%9A\">list容器：</a></p>\n<p id=\"set%2Fmultiset%E5%AE%B9%E5%99%A8%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#set%2Fmultiset%E5%AE%B9%E5%99%A8%EF%BC%9A\">set/multiset容器：</a></p>\n<p id=\"pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A\">pair对组创建：</a></p>\n<p id=\"map%E5%AE%B9%E5%99%A8%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#map%E5%AE%B9%E5%99%A8%EF%BC%9A\">map容器：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"STL%EF%BC%9A\">STL：</h1>\n<p>STL，即标准模板库，用着感觉和python差不多。</p>\n<p>STL 六大组件：容器（序例式和关联式） 算法（质变和非质变） 迭代器 仿函数 适配器 空间配置器。首先，我们来看以下Vector容器：</p>\n<h1 id=\"vector%E5%AE%B9%E5%99%A8%EF%BC%9A\">vector容器：</h1>\n<p>不同之处是数组是静态空间，而vector可以动态扩展。</p>\n<p>迭代器：随机访问迭代器</p>\n<pre><code class=\"language-cpp\">vector.begin()指向第一个\nvector.end()指向最后一个元素的后面一个\nvector.rbegin()指向倒数第一个元素\nvector.rend()指向第一个元素的前一个</code></pre>\n<p><br/> 容器嵌套:</p>\n<pre><code class=\"language-cpp\">vector&lt;vector&lt;int&gt;&gt;</code></pre>\n<p><br/> 构造：</p>\n<pre><code class=\"language-cpp\">vector&lt;int&gt;v1;\nvector&lt;int&gt;v2(v1.begin(),v1.end())\nvector&lt;int&gt;v3(10,100)</code></pre>\n<p><br/> 赋值：</p>\n<pre><code class=\"language-cpp\">直接等号赋值\nvector.assign(10,100)\nvector.assign(begin,end)</code></pre>\n<p><br/> 容量和大小：</p>\n<pre><code class=\"language-cpp\">empty()\ncapacity()\nsize()\nresize(num)\nresize(num,elem)elem为填充元素</code></pre>\n<p><br/> 插入和删除：</p>\n<pre><code class=\"language-cpp\">push_back() 尾部添加元素\npop_back()删除尾部元素\ninsert(迭代器pose，elem)\ninsert(迭代器pose，n,elem)插入n个\nerase(迭代器pose)删除索引位置\nerase（v.begin(),v.end()）区间删除\nclear()清空</code></pre>\n<p><br/> 数据存取：</p>\n<pre><code>at(int dex)返回索引为idx的元素\noperator[]返回索引为idx的元素，如v[idx]\nfront()返回容器中第一个数据元素\nback()返回容器中最后一个数据元素</code></pre>\n<p><br/> 互换容器：</p>\n<pre><code>swap(v)</code></pre>\n<p><br/> 实际用途：收缩占用空间 vector&lt;int&gt;(v).swap(v),创建匿名对象进行互换，达到收缩空间的效果<br/> 预留空间：<br/>  </p>\n<pre><code>reserve(len) 容器预留len个元素长度，不进行初始化，不可访问，而resize（）则被初始化为0</code></pre>\n<h1 id=\"string%E5%AE%B9%E5%99%A8%EF%BC%9A\">string容器：</h1>\n<p>string拼接函数：</p>\n<pre><code>\nstring.append(str,n)截取前n个元素进行拼接\nstring.append(str,start,n)可以选择从第n个截取</code></pre>\n<p><br/> string查找和替换：</p>\n<pre><code>string.find(str)返回查找子字符串中第一个元素的索引，没有返回-1\nstring.rfind(str)区别在于rfind从右往左查\nstring.replace(start,n,str)从start开始的n个字符替换为str</code></pre>\n<p><br/> 字符串比较（ASCII码值逐个比较）：</p>\n<pre><code>string.compare(str)大于返回1，等于返回0，小于返回-1</code></pre>\n<p><br/> 字符串存取：</p>\n<pre><code>string[i],string.at(i)可以修改或访问第i个元素</code></pre>\n<p><br/> 字符串插入和删除：</p>\n<pre><code>string.insert(n,str) str.erase(i,n)删除从i开始的n个字符</code></pre>\n<p><br/> 求子串操作：<br/>  </p>\n<pre><code>string.substr(start,n)</code></pre>\n<h1 id=\"deque%E5%AE%B9%E5%99%A8%EF%BC%9A\">deque容器：</h1>\n<p>构造：</p>\n<pre><code>deque&lt;int&gt;d1;\ndeque&lt;int&gt;d2(d1.begin(),d1.end());\ndeque&lt;int&gt;d3(10,100);\ndeque&lt;int&gt;d4(d3);</code></pre>\n<p><br/> 赋值操作：</p>\n<pre><code>deque&lt;int&gt;d2=d1;\ndeque&lt;int&gt;d3.assign(d1.begin(),d1.end());\ndeque&lt;int&gt;d4.assign(10,100)</code></pre>\n<p><br/> 大小操作：</p>\n<pre><code>deque.empty()\ndeque.size()\ndeque.resize(size)\ndeque.resize(size,elem)</code></pre>\n<p><br/> 插入和删除;</p>\n<pre><code>deque.push_back()尾插\ndeque.push_front()头插\ndeque.pop_back()尾删\ndeque.pop_front()头删\ndeque.erase(迭代器pose)\ndeque.insert(deque.begin(),elem)\ndeque.insert(deque.begin(),num,elem)\ndeque.insert(deque.begin(),d2.begin(),d2.end())\ndeque.erase（deque.begin(),deque.end()）\ndeque.clear()清空</code></pre>\n<p><br/> 数据存取：</p>\n<pre><code>at(int dex)返回索引为idx的元素\noperator[]返回索引为idx的元素，如deque[idx]\nfront()返回容器中第一个数据元素\nback()返回容器中最后一个数据元素</code></pre>\n<p><br/> 排序：<br/>  </p>\n<pre><code>sort(iterator begin,iterator end)默认升序，对于支持随即访问迭代器的容器，都可以直接使用该算法进行排序</code></pre>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n#include&lt;deque&gt;\nusing namespace std;\nvoid printdeq(const deque&lt;int &gt;&amp;d)\n{\n    for (deque&lt;int&gt;::const_iterator it=d.begin();it&lt;d.end();it++)\n    {\n        cout&lt;&lt;*it&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n}\nvoid test()\n{\n    deque&lt;int&gt;d;\n    d.push_back(1);\n    d.push_back(3);\n    d.push_back(2);\n    sort(d.begin(),d.end());\n    printdeq(d);\n\n}\n\n\nint main()\n{\n    test();\n}\n</code></pre>\n<p> </p>\n<h1 id=\"stack%E5%AE%B9%E5%99%A8%EF%BC%9A(%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA)\">stack容器：(先进后出)</h1>\n<p>构造：</p>\n<pre><code>stack&lt;int&gt;s;</code></pre>\n<p><br/> 插入和删除：<br/>  </p>\n<pre><code>stack.push()插入\nstack.pop()删除\nstack.empty()判断是否为空\nstack.size()大小\ns.top()栈顶元素</code></pre>\n<h1 id=\"queue%E5%AE%B9%E5%99%A8%EF%BC%9A%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89\">queue容器：（先进先出）</h1>\n<pre><code>queue.push()插入\nqueue.pop()删除\nqueue.empty()判断是否为空\nqueue.size()大小\nqueue.front()队头元素\nqueue.back()队尾元素</code></pre>\n<p> </p>\n<h1 id=\"list%E5%AE%B9%E5%99%A8%EF%BC%9A\">list容器：</h1>\n<p>链表由一个个结点（数据域+指针域）构成，与数组相比可以快速添加或者和删除元素，但是遍历速度没有数组快，而且占用空间比数组要大。STL链表是双向循环链表。<br/> 迭代器属于双向迭代器，不支持随机访问，而且进行插入和删除操作时，原有迭代器不会失效。<br/> 构造函数：</p>\n<pre><code>list&lt;int&gt;l1;\nlist&lt;int&gt;l2(l1.begin(),l1.end())\nlist&lt;int&gt;l3(num,elem)\nlist&lt;int&gt;l4(l3)</code></pre>\n<p><br/> 赋值和交换：</p>\n<pre><code>list.assign(beg,end)\nlist.assign(num,elem)\n=赋值，如l1=l2\nl1.swap(l2)交换</code></pre>\n<p><br/> 大小操作：</p>\n<pre><code>list.size()\nlist.empty()\nlist.resize(size)\nlist.resize(size,elem)</code></pre>\n<p><br/> 插入和删除：</p>\n<pre><code>push_back(elem)尾插\npop_back()尾删\npush_front(elem)头插\npop_front()头删\ninsert(pose,elem) pose(迭代器)处插入元素\ninsert(pose,n,elem)插入n个元素\ninsert(pose,beg,end)区间插入，从pose开始\nclear()清空\nerase(pose)删除pose处的元素\nerase(beg,end)删除区间元素\nremove(elem)移除elem元素</code></pre>\n<p><br/> 数据存取：<br/>  </p>\n<pre><code>list.front()返回首元素\nlist.back()返回尾部元素\n反转和排序：\nlist.reverse()反转\nlist.sort()排序,默认升序,若需要降序，则需要加仿函数</code></pre>\n<pre><code class=\"language-cpp\">//list降序升序排列\n#include &lt;iostream&gt;\n#include &lt;list&gt;\nusing namespace std;\n\nvoid printlist(list&lt;int&gt;&amp;l)\n{\n    for(list&lt;int&gt;::iterator it=l.begin();it!=l.end();it++)\n    {\n        cout&lt;&lt;*it&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n}\nbool compare(int val1,int val2)\n{\n    return val1&gt;val2;\n}\nvoid test()\n{\n    list&lt;int&gt;l;\n\n        l.push_back(40);\n        l.push_back(60);\n        l.push_back(430);\n        l.push_back(0);\n        l.push_back(5);\n        l.push_back(4);\n        cout&lt;&lt;\"排序前： \"&lt;&lt;endl;\n        printlist(l);\n        l.sort();\n        cout&lt;&lt;\"升序排列： \"&lt;&lt;endl;\n        printlist(l);\n        cout&lt;&lt;\"降序排列： \"&lt;&lt;endl;\n        l.sort(compare);\n        printlist(l);\n}\n\nint main()\n{\n    test();\n    return 0;\n}</code></pre>\n<p> </p>\n<pre><code class=\"language-cpp\">//自定义类型排序\n#include&lt;iostream&gt;\n#include &lt;list&gt;\nusing namespace std;\nclass Person\n{\n    public:\n    string name;\n    int age;\n    int height;\n    Person(string na,int a,int b)\n    {\n        name=na;\n        age=a;\n        height=b;\n    }\n};\nvoid setperson(list&lt;Person&gt;&amp;l)\n{\n    Person p1(\"A\",17,175);\n    Person p2(\"B\",18,172);\n    Person p3(\"C\",17,175);\n    Person p4(\"D\",18,168);\n    Person p5(\"E\",17,170);\n    l.push_back(p1);\n    l.push_back(p2);\n    l.push_back(p3);\n    l.push_back(p4);\n    l.push_back(p5);\n}\nbool mycompare(Person p1,Person p2)\n{\n    if(p1.age==p2.age)\n    {\n        return p1.height&lt;p2.height;\n    }\n    else\n    return p1.age&lt;p2.age;\n}\nvoid printperson(list&lt;Person&gt;l)\n{\n    for(list&lt;Person&gt;::iterator it=l.begin();it!=l.end();it++)\n    {\n        cout&lt;&lt;\"姓名： \"&lt;&lt;it-&gt;name&lt;&lt;\"  age: \"&lt;&lt;(*it).age&lt;&lt;\"  height: \"&lt;&lt;it-&gt;height&lt;&lt;endl;\n    }\n}\nint main()\n{\n\n    list&lt;Person&gt;l;\n    setperson(l);\n    cout&lt;&lt;\"排序前:\"&lt;&lt;endl;\n    printperson(l);\n    l.sort(mycompare);\n    cout&lt;&lt;\"排序后:\"&lt;&lt;endl;\n    printperson(l);\n\n    return 0;\n}</code></pre>\n<p> </p>\n<h1 id=\"set%2Fmultiset%E5%AE%B9%E5%99%A8%EF%BC%9A\">set/multiset容器：</h1>\n<p>所有元素在插入时自动被排序，属于关联式容器，底层结构为二叉树<br/> set与multiset区别：set不允许有重复元素，而multiset可以<br/> 构造和赋值：</p>\n<pre><code>set&lt;int&gt;s1\nset&lt;int&gt;s2(s1)\n=赋值\n插入：只有insert方式\nset.insert(elem)注意：若要是插入后元素是降序排列，则要使用仿函数作为排列规则</code></pre>\n<p><br/> 大小和交换：</p>\n<pre><code>set.size()\nset.empty()\nset.swap(l)</code></pre>\n<p><br/> 插入和删除：</p>\n<pre><code>set.insert(elem)\nset.clear()\nset.erase(pos)\nset.erase(betg,end)\nset.erase(elem)</code></pre>\n<p><br/> 查找和统计：<br/>  </p>\n<pre><code>set.find(key)返回该元素的迭代器，若不存在，则fanhuiset.end()\nset.count(key)</code></pre>\n<pre><code class=\"language-cpp\">//利用仿函数指定创建时的排序规则\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;set&gt;\nusing namespace std;\nclass Person\n{\npublic:\nstring name;\nint age;\nPerson(string a,int b)\n{\n    this-&gt;name=a;\n    this-&gt;age=b;\n};\n};\n\nclass mycompare\n{\npublic:\n   bool  operator()(const Person &amp;p1,const Person &amp;p2)\n    {\n        return p1.age&gt;p2.age;\n    }\n\n};\n\nvoid printperson(set&lt;Person,mycompare&gt;s)\n{\n    for(set&lt;Person,mycompare&gt;::iterator it=s.begin();it!=s.end();it++)\n    {\n        cout&lt;&lt;it-&gt;name&lt;&lt;\"  \"&lt;&lt;(*it).age&lt;&lt;endl;\n    }\n}\n\nvoid setperson()\n{\n    Person p1(\"A\",13);\n    Person p2(\"B\",12);\n    Person p3(\"C\",16);\n    Person p4(\"D\",10);\n    set&lt;Person,mycompare&gt;s;\n    cout&lt;&lt;\"降序插入\"&lt;&lt;endl;\n    s.insert(p1);\n    s.insert(p2);\n    s.insert(p3);\n    s.insert(p4);\n    printperson(s);\n}\n\nint main()\n{\n    set&lt;Person&gt;p;\n    setperson();\n    return 0;\n}</code></pre>\n<p> </p>\n<h1 id=\"pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A\">pair对组创建：</h1>\n<pre><code>使用时不需要包含头文件\npair&lt;type,type&gt; p(val1,val2)\npair&lt;type,type&gt; p=make_pair(val1,val2)\n获取：p.first p.second</code></pre>\n<h1 id=\"map%E5%AE%B9%E5%99%A8%EF%BC%9A\">map容器：</h1>\n<p>1.map中所有元素都是pair<br/> 2.pair中第一个元素时键值key，起到索引作用，第二个元素为实值value<br/> 3.所有元素会根据键值自动排序<br/> 4.属于关联式容器，底层用二叉树实现<br/> map和multimap区别：<br/> 1.map允许有重复key值元素<br/> 2.multimap允许容器中有重复key值元素<br/> 构造和赋值：</p>\n<pre><code>map&lt;int,int&gt;m1;\nmap&lt;int,int&gt;m2(m1);\nmap&lt;int,int&gt;m3;m3=m2;</code></pre>\n<p><br/> 大小和交换：</p>\n<pre><code>map.size()\nm.empty()\nm.swap(m1)</code></pre>\n<p><br/> 插入和删除：</p>\n<pre><code>m.insert(elem)\nm.clear()\nm.erase(pose)\nm.erase(beg,end)\nm.erase(key)</code></pre>\n<p><br/> 查找和统计：</p>\n<pre><code>m.find(key)\nm.count(key)</code></pre>\n<p><br/> 排序：可以利用仿函数指定排序规则</p>\n<p></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;map&gt;\nusing namespace std;\n\nclass Mycompare\n{\n    public:\n    bool operator()(int v1,int v2)\n    {\n        return v1&gt;v2;\n    }\n};\nvoid print1(map&lt;int,int&gt;&amp;m)\n{\n    for(map&lt;int,int&gt;::iterator it=m.begin();it!=m.end();it++)\n    {\n        cout&lt;&lt;\"key=\"&lt;&lt;it-&gt;first&lt;&lt;\"value=\"&lt;&lt;it-&gt;second&lt;&lt;endl;\n    }\n    cout&lt;&lt;endl;\n}\nvoid test01()\n{\n    map&lt;int,int&gt;m;\n    m.insert(make_pair(1,10));\n    m.insert(make_pair(3,30));\n    m.insert(make_pair(2,20));\n    cout&lt;&lt;\"升序\"&lt;&lt;endl;\n    print1(m);\n}\nvoid print2(map&lt;int,int,Mycompare&gt;&amp;m)\n{\n    for(map&lt;int,int,Mycompare&gt;::iterator it=m.begin();it!=m.end();it++)\n    {\n        cout&lt;&lt;\"key=\"&lt;&lt;it-&gt;first&lt;&lt;\"value=\"&lt;&lt;it-&gt;second&lt;&lt;endl;\n    }\n    cout&lt;&lt;endl;\n}\nvoid test02()\n{\n    map&lt;int,int,Mycompare&gt;m1;\n    m1.insert(make_pair(1,10));\n    m1.insert(make_pair(3,30));\n    m1.insert(make_pair(2,20));\n    cout&lt;&lt;\"降序\"&lt;&lt;endl;\n    print2(m1);\n}\nint main()\n{\n    test01();\n    test02();\n    return 0;\n}</code></pre>\n<p> 本文代码被本人不小心删除了大量例程，所以很多部分没有代码，若有不懂的小伙伴，欢迎讨论。</p>\n</div>\n</div>", "first_tag": "Python", "cpp": 1, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-22 11:13:54", "summary": "目录：容器：容器：容器：容器：先进后出容器：先进先出容器：容器：对组创建：容器：：，即标准模板库，用着感觉和差不多。六大组件：容器序例式和关联式算法质变和非质变迭代器仿函数适配器空间配置器。首先，我们"}