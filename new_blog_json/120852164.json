{"blogid": "120852164", "writerAge": "码龄4年", "writerBlogNum": "57", "writerCollect": "100", "writerComment": "10", "writerFan": "137", "writerGrade": "3级", "writerIntegral": "682", "writerName": "此生不悔入海贼", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120852164.jpg", "writerRankTotal": "26718", "writerRankWeekly": "21810", "writerThumb": "37", "writerVisitNum": "36146", "blog_read_count": "2057", "blog_time": "于 2021-10-19 19:23:09 发布", "blog_title": "C# 抽象类（abstract）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><strong>C#抽象类</strong>：</h1>\n<p>C#抽象类是特殊的类，只是不能被实例化；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。</p>\n<p><code>abstract</code> 修饰符指示被修改内容的实现已丢失或不完整。 abstract 修饰符可用于类、方法、属性、索引和事件。 在类声明中使用 <code>abstract</code> 修饰符来指示某个类仅用作其他类的基类，而不用于自行进行实例化。 标记为抽象的成员必须由派生自抽象类的非抽象类来实现。</p>\n<hr/>\n<h1><a id=\"_6\"></a><br/><br/> 抽象方法：</h1>\n<p>用abstract修饰的方法，称为抽象方法。</p>\n<blockquote>\n<p>访问修饰符  abstract  方法返回值类型  方法名(参数列表);</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>public abstract void Practice(); </p>\n</blockquote>\n<p> 抽象方法是一种特殊的虚方法，它只起声明作用，所以只加一个“;”号，一定不能带实现部分。</p>\n<p><strong>需要注意的是，抽象方法必须定义在抽象类中。</strong></p>\n<hr/>\n<h1><a id=\"_16\"></a><br/><br/> 抽象类：</h1>\n<p>定义抽象类时，若使用 abstract 修饰类，将其放到 class 关键字的前面，语法形式如下：</p>\n<blockquote>\n<p>访问修饰符  abstract class  类名<br/> {<!-- --><br/>     //类成员<br/> }</p>\n</blockquote>\n<p>其中“abstract”关键字也可以放到访问修饰符的前面。<br/><br/> 在抽象类中可以定义抽象方法，也可以定义非抽象方法。<br/><br/> 通常抽象类会被其他类继承，并重写其中的抽象方法或者虚方法。</p>\n<p><strong>抽象类具有以下功能：</strong> </p>\n<ul><li> <p>抽象类不能实例化。</p> </li><li> <p>抽象类可能包含抽象方法和访问器。</p> </li><li> <p>无法使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/sealed\" title=\"sealed\">sealed</a> 修饰符来修改抽象类，因为两个修饰符的含义相反。 <code>sealed</code> 修饰符阻止类被继承，而 <code>abstract</code> 修饰符要求类被继承。</p> </li><li> <p>派生自抽象类的非抽象类，必须包含全部已继承的抽象方法和访问器的实际实现。</p> </li></ul>\n<p>在方法或属性声明中使用 <code>abstract</code> 修饰符，以指示该方法或属性不包含实现。</p>\n<p>抽象方法具有以下功能：</p>\n<ul><li> <p>抽象方法是隐式的虚拟方法。</p> </li><li> <p>只有抽象类中才允许抽象方法声明。</p> </li><li> <p>由于抽象方法声明不提供实际的实现，因此没有方法主体；方法声明仅以分号结尾，且签名后没有大括号 ({ })。例如：</p> </li></ul>\n<blockquote>\n<p> public abstract void MyMethod();</p>\n</blockquote>\n<ul><li> <p>实现由方法override 提供，它是非抽象类的成员。</p> </li><li> <p>在抽象方法声明中使用 <span style=\"color:#fe2c24;\">static  </span>或 <span style=\"color:#fe2c24;\">virtual </span>修饰符是错误的。</p> </li></ul>\n<p>除了声明和调用语法方面不同外，抽象属性的行为与抽象方法相似。</p>\n<ul><li> <p>在静态属性上使用 <span style=\"color:#fe2c24;\"><code>abstract</code> </span>修饰符是错误的。</p> </li><li> <p>通过包含使用  <span style=\"color:#fe2c24;\">override</span> 修饰符的属性声明，可在派生类中重写抽象继承属性。</p> </li></ul>\n<p>用简单的话来说抽象类的功能就是：<span style=\"color:#ff9900;\">我是师傅（抽象类），你要是跟了（继承）师傅，你就必须得会干什么（实际实现）</span></p>\n<p>例如：<span style=\"color:#ff9900;\">老子会打人，那你也必须会打人，但你是轻轻的打，还是狠狠的打，你自己决定，但你必须得会打人。</span></p>\n<p><strong><span style=\"color:#0d0016;\">实例：</span></strong></p>\n<p>类 <code>DerivedClass</code> 派生自抽象类 <code>BaseClass</code>。 抽象类包含抽象方法 <code>AbstractMethod</code>，以及两个抽象属性 <code>X</code> 和 <code>Y</code>。</p>\n<pre><code class=\"language-cs\">abstract class BaseClass   // Abstract class\n{\n    protected int _x = 100;\n    protected int _y = 150;\n    public abstract void AbstractMethod();   // Abstract method\n    public abstract int X    { get; }\n    public abstract int Y    { get; }\n}\n\nclass DerivedClass : BaseClass\n{\n    public override void AbstractMethod()\n    {\n        _x++;\n        _y++;\n    }\n\n    public override int X   // overriding property\n    {\n        get\n        {\n            return _x + 10;\n        }\n    }\n\n    public override int Y   // overriding property\n    {\n        get\n        {\n            return _y + 10;\n        }\n    }\n\n    static void Main()\n    {\n        var o = new DerivedClass();\n        o.AbstractMethod();\n        Console.WriteLine($\"x = {o.X}, y = {o.Y}\");\n    }\n}\n// Output: x = 111, y = 161</code></pre>\n<p></p>\n<hr/>\n<h1>总结：</h1>\n<p>1，抽象类说明：</p>\n<p>①.抽象类中如果有抽象方法，那么被继承的具体类一定要实现抽象类中得所有抽象方法。<br/> ②.当然，如果是抽象类B继承抽象类A，那么抽象类B可以实现基类A中的抽象方法，可以不实现A中得抽象方法</p>\n<p>2，类（抽象类）的多态</p>\n<blockquote>\n<p>abstract class A<br/> {<!-- --><br/> public abstract void AFunction ();<br/> }<br/> abstract class B : A<br/> {<!-- --><br/> public abstract void BFunction ();<br/> }</p>\n</blockquote>\n<blockquote>\n<p>class C : B<br/> {<!-- --><br/> public override void AFunction()<br/>   {<!-- --><br/>     Console.WriteLine (\"AFucntion.\");<br/>   }<br/> public override void BFunction()<br/>   {<!-- --><br/>     Console.WriteLine (\"BFunction.\");<br/>   }<br/> } </p>\n</blockquote>\n<p>3，总结：</p>\n<p>1.抽象方法只作声明，而不包含实现，抽象方法旨在继承后实现，所以不能用private修饰。<br/> 2.抽象类不能被直接实例化。<br/> 3. 抽象类可以没有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类。<br/> 4.如果抽象类的派生类不是抽象类，那么必须重写抽象类的所有抽象方法。 </p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-10-19 19:23:09", "summary": "抽象类：抽象类是特殊的类，只是不能被实例化；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象"}