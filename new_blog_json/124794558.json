{"blogid": "124794558", "writerAge": "码龄9年", "writerBlogNum": "116", "writerCollect": "177", "writerComment": "113", "writerFan": "25", "writerGrade": "4级", "writerIntegral": "1248", "writerName": "故里2130", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124794558.jpg", "writerRankTotal": "16110", "writerRankWeekly": "6433", "writerThumb": "37", "writerVisitNum": "76211", "blog_read_count": "1351", "blog_time": "于 2022-05-16 22:46:51 发布", "blog_title": "C#把dll打包到exe", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>把其他类库生成的dll，和现在的exe打包在一起，发给别人的时候，就发一个exe即可。</p>\n<p>一共二种方法</p>\n<p>第一种</p>\n<p>1.建立一个类库项目</p>\n<p>代码</p>\n<p><img alt=\"\" height=\"272\" src=\"..\\..\\static\\image\\7a12e9382f0249a29b6ca4b725b90776.png\" width=\"400\"/></p>\n<p>生成dll</p>\n<p><img alt=\"\" height=\"28\" src=\"..\\..\\static\\image\\0a37c3160b1e4190bb151828a59bdcbe.png\" width=\"209\"/></p>\n<p>2.建立一个winform项目</p>\n<p><img alt=\"\" height=\"496\" src=\"..\\..\\static\\image\\0133b18ce11849138a66fda84a5b5903.png\" width=\"833\"/></p>\n<p>3.在项目中把dll引用里面去</p>\n<p><img alt=\"\" height=\"204\" src=\"..\\..\\static\\image\\ed20719f136042c9a4744b3e91ca1a9e.png\" width=\"302\"/></p>\n<p>4.把dll直接复制到项目的根目录中</p>\n<p><img alt=\"\" height=\"418\" src=\"..\\..\\static\\image\\d7efb4b902184543bd9c2bbfb62632e0.png\" width=\"306\"/></p>\n<p>并且修改下面2项 </p>\n<p><img alt=\"\" height=\"108\" src=\"..\\..\\static\\image\\d365e0d175b84e36a00b0a4f38933815.png\" width=\"549\"/></p>\n<p></p>\n<p>5.回到项目的界面上，在按钮中增加ClassLibrary1.dll的方法</p>\n<p><img alt=\"\" height=\"117\" src=\"..\\..\\static\\image\\bfb1e36d5dd5434f9ed20b25522b8511.png\" width=\"510\"/></p>\n<p>6.在启动的地方加上代码</p>\n<p><img alt=\"\" height=\"425\" src=\"..\\..\\static\\image\\3ddfc2b934fa4e22bbc03ae427c051f2.png\" width=\"805\"/></p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApp2\n{\n    static class Program\n    {\n        /// &lt;summary&gt;\n        /// 应用程序的主入口点。\n        /// &lt;/summary&gt;\n        [STAThread]\n        static void Main()\n        {\n\n            AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =&gt;\n            {\n                //WindowsFormsApp2 这个是主程序的命名空间\n                string resourceName = \"WindowsFormsApp2.\" + new AssemblyName(args.Name).Name + \".dll\";\n                using (var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))\n                {\n                    Byte[] assemblyData = new Byte[stream.Length];\n                    stream.Read(assemblyData, 0, assemblyData.Length);\n                    return Assembly.Load(assemblyData);\n                }\n            };\n\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());\n        }\n    }\n}\n</code></pre>\n<p>7.点击生成，此时把exe发到任何电脑都是可以的。效果如下。</p>\n<p><img alt=\"\" height=\"518\" src=\"..\\..\\static\\image\\bbf551373b2a4ad09d0769b951252ac8.png\" width=\"1155\"/></p>\n<p></p>\n<p> 拓展1</p>\n<p>WPF需要这样</p>\n<p><img alt=\"\" height=\"243\" src=\"..\\..\\static\\image\\ae2cbec7d41646e2b16cb18132135a62.png\" width=\"732\"/></p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Data;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Windows;\n\nnamespace WpfApp1\n{\n    /// &lt;summary&gt;\n    /// App.xaml 的交互逻辑\n    /// &lt;/summary&gt;\n    public partial class App : Application\n    {\n        protected override void OnStartup(StartupEventArgs e)\n        {\n            AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =&gt;\n            {\n                //WpfApp1 这个是主程序的命名空间\n                string resourceName = \"WpfApp1.\" + new AssemblyName(args.Name).Name + \".dll\";\n                using (var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))\n                {\n                    Byte[] assemblyData = new Byte[stream.Length];\n                    stream.Read(assemblyData, 0, assemblyData.Length);\n                    return Assembly.Load(assemblyData);\n                }\n            };\n        }\n    }\n\n\n}\n</code></pre>\n<p>拓展2</p>\n<p> 如果大量的dll，需要建立一个文件夹，把dll都放进去 ,把dll全选设置成资源</p>\n<p><img alt=\"\" height=\"64\" src=\"..\\..\\static\\image\\68a3798a742c44ecaf1d0023597d4a68.png\" width=\"362\"/></p>\n<p>在路径中一定要加上文件夹的名字</p>\n<p><img alt=\"\" height=\"173\" src=\"..\\..\\static\\image\\c260463d9aa94067a43ec5a8b2934312.png\" width=\"1176\"/></p>\n<p>第二种</p>\n<p>1.建立一个项目，再建立一个文件夹，把dll放进去</p>\n<p><img alt=\"\" height=\"437\" src=\"..\\..\\static\\image\\3b92393965174aaf8ca2a765b88a2291.png\" width=\"297\"/></p>\n<p>2.对文件夹下面的dll进行设置</p>\n<p><img alt=\"\" height=\"114\" src=\"..\\..\\static\\image\\032fe57993994c3d9ae0b6a3fdee5b37.png\" width=\"379\"/> </p>\n<p> 3.对引用下面的dll，复制本地改成FALSE</p>\n<p><img alt=\"\" height=\"167\" src=\"..\\..\\static\\image\\3535c0f68e064095ab901892b6e34f92.png\" width=\"362\"/></p>\n<p> 4.创建一个类</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApp5\n{\n    public static class LoadResoureDll\n    {\n        /// &lt;summary&gt; 已加载DLL\n        /// &lt;/summary&gt;\n        private static Dictionary&lt;string, Assembly&gt; LoadedDlls = new Dictionary&lt;string, Assembly&gt;();\n        /// &lt;summary&gt; 已处理程序集\n        /// &lt;/summary&gt;\n        private static Dictionary&lt;string, object&gt; Assemblies = new Dictionary&lt;string, object&gt;();\n        /// &lt;summary&gt; 在对程序集解释失败时触发\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;AppDomain&lt;/param&gt;\n        /// &lt;param name=\"args\"&gt;事件参数&lt;/param&gt;\n        private static Assembly AssemblyResolve(object sender, ResolveEventArgs args)\n        {\n            try\n            {\n                //程序集\n                Assembly ass;\n                //获取加载失败的程序集的全名\n                var assName = new AssemblyName(args.Name).FullName;\n                //判断Dlls集合中是否有已加载的同名程序集\n                if (LoadedDlls.TryGetValue(assName, out ass) &amp;&amp; ass != null)\n                {\n                    LoadedDlls[assName] = null;//如果有则置空并返回\n                    return ass;\n                }\n                else\n                {\n                    return ass;//dev的dll 这里有问题，可以绕过\n                    throw new DllNotFoundException(assName);//否则抛出加载失败的异常\n                }\n            }\n            catch (System.Exception ex)\n            {\n                MessageBox.Show(\"error1:\\n位置：AssemblyResolve()！\\n描述：\" + ex.Message);\n                return null;\n            }\n        }\n\n        /// &lt;summary&gt; 注册资源中的dll\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"pattern\"&gt;*表示连续的未知字符,_表示单个未知字符,如*.dll&lt;/param&gt;\n        public static void RegistDLL(string pattern = \"*.dll\")\n        {\n            System.IO.Directory.GetFiles(\"\", \"\");\n            //获取调用者的程序集\n            var ass = new StackTrace(0).GetFrame(1).GetMethod().Module.Assembly;\n            //判断程序集是否已经处理\n            if (Assemblies.ContainsKey(ass.FullName))\n            {\n                return;\n            }\n            //程序集加入已处理集合\n            Assemblies.Add(ass.FullName, null);\n            //绑定程序集加载失败事件(这里我测试了,就算重复绑也是没关系的)\n            AppDomain.CurrentDomain.AssemblyResolve += AssemblyResolve;\n            //获取所有资源文件文件名\n            var res = ass.GetManifestResourceNames();\n            var regex = new Regex(\"^\" + pattern.Replace(\".\", \"\\\\.\").Replace(\"*\", \".*\").Replace(\"_\", \".\") + \"$\", RegexOptions.IgnoreCase);\n            foreach (var r in res)\n            {\n                //如果是dll,则加载\n                if (regex.IsMatch(r))\n                {\n                    try\n                    {\n                        var s = ass.GetManifestResourceStream(r);\n                        var bts = new byte[s.Length];\n                        s.Read(bts, 0, (int)s.Length);\n                        var da = Assembly.Load(bts);\n                        //判断是否已经加载\n                        if (LoadedDlls.ContainsKey(da.FullName))\n                        {\n                            continue;\n                        }\n                        LoadedDlls[da.FullName] = da;\n                    }\n                    catch (Exception ex)\n                    {\n                        MessageBox.Show(\"error2:加载dll失败\\n位置：RegistDLL()！\\n描述：\" + ex.Message);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>5.在程序的入口处调用</p>\n<p><img alt=\"\" height=\"177\" src=\"..\\..\\static\\image\\4abe17b668a9496abfe52f503aac6e6b.png\" width=\"536\"/> </p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApp5\n{\n    static class Program\n    {\n        /// &lt;summary&gt;\n        /// 应用程序的主入口点。\n        /// &lt;/summary&gt;\n        [STAThread]\n        static void Main()\n        {\n            LoadResoureDll.RegistDLL();\n\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());\n        }\n    }\n}\n</code></pre>\n<p>6.最终会生成一个独立的exe文件。</p>\n<p><img alt=\"\" height=\"217\" src=\"..\\..\\static\\image\\d0447f763d4c4c54989ef4c40310a75f.png\" width=\"437\"/> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-16 22:46:51", "summary": "把其他类库生成的，和现在的打包在一起，发给别人的时候，就发一个即可。一共二种方法第一种建立一个类库项目代码生成建立一个项目在项目中把引用里面去把直接复制到项目的根目录中并且修改下面项回到项目的界面上，"}