{"blogid": "125244657", "writerAge": "码龄1年", "writerBlogNum": "378", "writerCollect": "294", "writerComment": "23", "writerFan": "9130", "writerGrade": "5级", "writerIntegral": "3986", "writerName": "喵喵喵更多", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125244657.jpg", "writerRankTotal": "4781", "writerRankWeekly": "875", "writerThumb": "87", "writerVisitNum": "245174", "blog_read_count": "3523", "blog_time": "于 2022-06-12 13:36:20 发布", "blog_title": "spring如何解决循环依赖", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_2\"></a>文章目录</h3>\n<ul><li><a href=\"#1_16\">1、什么是循环依赖？</a></li><li><a href=\"#2_27\">2、怎么检测循环依赖</a></li><li><a href=\"#3Spring_29\">3、Spring怎么解决循环依赖</a></li><li><a href=\"#4N_149\">4、循环依赖的N种场景</a></li><li>\n<ul><li><a href=\"#31setter_153\">3.1、单例的setter注入</a></li><li><a href=\"#32setter_235\">3.2、多例的setter注入</a></li><li><a href=\"#33_273\">3.3、构造器注入</a></li><li><a href=\"#34setter_299\">3.4、单例的代理对象setter注入</a></li><li><a href=\"#35DependsOn_361\">3.5、DependsOn循环依赖</a></li></ul> </li><li><a href=\"#5_388\">5、出现循环依赖如何解决？</a></li><li>\n<ul><li><a href=\"#51_391\">5.1、生成代理对象产生的循环依赖</a></li><li><a href=\"#52DependsOn_397\">5.2、DependsOn循环依赖</a></li><li><a href=\"#53_400\">5.3、多例循环依赖</a></li><li><a href=\"#53_403\">5.3、构造器循环依赖</a></li></ul> </li></ul>\n<hr/>\n<p>这里我们主要分析Spring bean的循环依赖，以及Spring的解决方式。 通过这种解决方式，我们可以应用在我们实际开发项目中。</p>\n<p>1、什么是循环依赖？<br/> 2、怎么检测循环依赖<br/> 3、循环依赖的N种场景<br/> 3、Spring怎么解决循环依赖<br/> 4、Spring对于循环依赖无法解决的场景<br/> 5、Spring解决循环依赖的方式我们能够学到什么？</p>\n<hr/>\n<p><code>以下基于spring5.0.x版本源码进行分析</code></p>\n<h1><a id=\"1_34\"></a>1、什么是循环依赖？</h1>\n<p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：<br/> <img alt=\"循环依赖示例\" src=\"..\\..\\static\\image\\bcb2559806ff4f289eae797c1fea7414.png\"/></p>\n<p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p>\n<p>Spring中循环依赖场景主要有以下两种：<br/> （1）field属性的循环依赖<br/> （2）构造器的循环依赖<br/> （3）DependsOn循环依赖</p>\n<h1><a id=\"2_47\"></a>2、怎么检测循环依赖</h1>\n<p>检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p>\n<h1><a id=\"3Spring_52\"></a>3、Spring怎么解决循环依赖</h1>\n<p>Spring解决循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p>\n<p>Spring的单例对象的初始化主要分为三步：</p>\n<ol><li><strong>实例化</strong>：其实也就是调用对象的构造方法实例化对象</li><li><strong>注入</strong>：填充属性，这一步主要是对bean的依赖属性进行填充</li><li><strong>初始化</strong>：属性注入后，执行自定义初始化</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\68f70687282d4d42bc1fa88d02c5cb1a.png\"/><br/> 从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。</p>\n<p>那么我们要解决循环引用也应该从bean初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p>\n<p>首先我们看源码，三级缓存主要指：</p>\n<pre><code>\t/** Cache of singleton objects: bean name --&gt; bean instance */\n\tprivate final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);\n\n\t/** Cache of singleton factories: bean name --&gt; ObjectFactory */\n\tprivate final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);\n\n\t/** Cache of early singleton objects: bean name --&gt; bean instance */\n\tprivate final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);\n</code></pre>\n<p>这三级缓存分别指：<br/> singletonObjects：单例对象的cache<br/> singletonFactories ： 单例对象工厂的cache<br/> earlySingletonObjects ：提前暴光的单例对象的Cache</p>\n<p>我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就是：</p>\n<pre><code>\tprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\tif (singletonObject == null &amp;&amp; allowEarlyReference) {\n\t\t\t\t\tObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n</code></pre>\n<p>上面的代码需要解释两个参数：</p>\n<ul><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</li><li>isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)</li></ul>\n<p>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：<br/> 从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p>\n<pre><code>\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t// 从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。\n\tthis.singletonFactories.remove(beanName);\n</code></pre>\n<p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p>\n<pre><code>@FunctionalInterface\npublic interface ObjectFactory&lt;T&gt; {\n\n\t/**\n\t * Return an instance (possibly shared or independent)\n\t * of the object managed by this factory.\n\t * @return the resulting instance\n\t * @throws BeansException in case of creation errors\n\t */\n\tT getObject() throws BeansException;\n}\n</code></pre>\n<p>调用createBeanInstance实例化后，<strong>如果bean是单例，且允许从singletonFactories获取bean，并且当前bean正在创建中</strong>，那么就把beanName放入三级缓存(singletonFactories)中:<br/> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>\n<pre><code>// Eagerly cache singletons to be able to resolve circular references\n// even when triggered by lifecycle interfaces like BeanFactoryAware.\nboolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n\t\tisSingletonCurrentlyInCreation(beanName));\nif (earlySingletonExposure) {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\"' to allow for resolving potential circular references\");\n\t}\n\taddSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n}\n\nprotected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\n\tAssert.notNull(singletonFactory, \"Singleton factory must not be null\");\n\tsynchronized (this.singletonObjects) {\n\t\tif (!this.singletonObjects.containsKey(beanName)) {\n\t\t\tthis.singletonFactories.put(beanName, singletonFactory);\n\t\t\tthis.earlySingletonObjects.remove(beanName);\n\t\t\tthis.registeredSingletons.add(beanName);\n\t\t}\n\t}\n}\n</code></pre>\n<p>这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>\n<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5849447f62fa464fb06bc4ba759ddd89.png\"/><br/> spring初始化bean的过程如下：<br/> 1&gt;首先尝试从一级缓存中获取serviceA实例，发现不存在并且serviceA不在创建过程中；<br/> 2&gt;serviceA完成了初始化的第一步（实例化：调用createBeanInstance方法，即调用默认构造方法实例化）；<br/> 3&gt;将自己(serviceA)提前曝光到singletonFactories中;<br/> 4&gt;此时进行初始化的第二步（注入属性serviceB），发现自己依赖对象serviceB，此时就尝试去get(B)，发现B还没有被实create，所以走create流程;<br/> 5&gt;serviceB完成了初始化的第一步（实例化：调用createBeanInstance方法，即调用默认构造方法实例化）；<br/> 6&gt;将自己(serviceB)提前曝光到singletonFactories中;<br/> 7&gt;此时进行初始化的第二步（注入属性serviceA）;<br/> 8&gt;于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀);<br/> 9&gt;B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中；<br/> 10&gt;此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中;</p>\n<p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>\n<h1><a id=\"4N_179\"></a>4、循环依赖的N种场景</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\96864fcfce354e13a1c797c36a44a900.png\"/><br/> <code>这里主要讲解spring是如何解决单例setter注入时的循环依赖问题，其他四种循环依赖场景后文再一一分析讲解</code></p>\n<h2><a id=\"31setter_185\"></a>3.1、单例的setter注入</h2>\n<p>这种注入方式应该是spring用的最多的，代码如下：</p>\n<pre><code>@Service\npublic class ServiceA {\n\n\t@Autowired\n\tprivate ServiceB serviceB;\n}\n\n@Service\npublic class ServiceB {\n\n\t@Autowired\n\tprivate ServiceA serviceA;\n}\n</code></pre>\n<p>spring内部有三级缓存：</p>\n<ul><li>singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例</li><li>earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例</li><li>singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。</li></ul>\n<p>下面用一张图告诉你，spring是如何解决循环依赖的：<br/> 图1<br/> <img alt=\"图1\" src=\"..\\..\\static\\image\\5849447f62fa464fb06bc4ba759ddd89.png\"/><br/> 上面(3、Spring怎么解决循环依赖)中已经讲解过spring解决单例循环依赖的过程，这里细心的朋友可能会发现在这种场景中第二级缓存(<strong>earlySingletonObjects</strong>)作用不大。<br/> <strong>那么问题来了，为什么要用第二级缓存呢？</strong><br/> 试想一下，如果出现以下这种情况，我们要如何处理？</p>\n<pre><code>@Service\npublic class ServiceA {\n\n\t@Autowired\n\tprivate ServiceB serviceB;\n\t\n\t@Autowired\n\tprivate ServiceB serviceC;\n}\n\n@Service\npublic class ServiceB {\n\n\t@Autowired\n\tprivate ServiceA serviceA;\n}\n\n@Service\npublic class ServiceC {\n\n\t@Autowired\n\tprivate ServiceA serviceA;\n}\n</code></pre>\n<p>serviceA依赖于serviceB和serviceC，而serviceB依赖于serviceA，同时serviceC也依赖于serviceA。按照上图的流程可以把serviceA注入到serviceB，并且sServiceA的实例是从第三级缓存中获取的。假设不用第二级缓存，serviceA注入到serviceC的流程如图：<br/> 图2<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\476a16e827f54235bab8aaf9872aa29b.png\"/><br/> serviceA注入到serviceC又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是ObjectFactory对象。说白了，两次从三级缓存中获取都是ObjectFactory对象，而通过它创建的实例对象每次可能都不一样的。这样不是有问题？</p>\n<p>为了解决这个问题，spring引入的第二级缓存。上面图1其实serviceA对象的实例已经被添加到第二级缓存中了，而在serviceA注入到TestService3时，只用从第二级缓存中获取该对象即可。<br/> 图3<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\337952fffd35479697b0bab2e4dfd802.png\"/><br/> 还有个问题，第三级缓存中为什么要添加ObjectFactory对象，直接保存实例对象不行吗？<br/> 答：不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的。<br/> 针对这种场景spring是怎么做的呢？<br/> 答案就在AbstractAutowireCapableBeanFactory类doCreateBean方法的这段代码中：</p>\n<pre><code>// Eagerly cache singletons to be able to resolve circular references\n// even when triggered by lifecycle interfaces like BeanFactoryAware.\nboolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n\t\tisSingletonCurrentlyInCreation(beanName));\nif (earlySingletonExposure) {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\"' to allow for resolving potential circular references\");\n\t}\n\taddSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n}\n</code></pre>\n<p>它定义了一个匿名内部类，通过getEarlyBeanReference方法获取代理对象，其实底层是通过AbstractAutoProxyCreator类的getEarlyBeanReference生成代理对象。</p>\n<h2><a id=\"32setter_271\"></a>3.2、多例的setter注入</h2>\n<p>这种注入方法偶然会有，具体代码如下：</p>\n<pre><code>@Service\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class ServiceA {\n\n\t@Autowired\n\tprivate ServiceB serviceB;\n}\n\n@Service\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class ServiceB {\n\n\t@Autowired\n\tprivate ServiceA serviceA;\n}\n</code></pre>\n<p>可能你会认为这种情况spring容器启动会报错，其实是不会，为什么呢？其实在AbstractApplicationContext类的refresh方法中告诉了我们答案，它会调用finishBeanFactoryInitialization方法，该方法的作用是为了spring容器启动的时候提前初始化一些bean。该方法的内部又调用了beanFactory.preInstantiateSingletons()方法：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\adabb66401424236b921d17c03f697a9.png\"/><br/> 红框的地方明显能够看出：非抽象、单例 并且非懒加载的类才能被提前初始bean。而多例即SCOPE_PROTOTYPE类型的类，非单例，不会被提前初始化bean，所以程序能够正常启动。如何让它提前初始化bean呢？只需要再定义一个单例的类，在它里面注入serviceA:</p>\n<pre><code>@Service\npublic class ServiceC {\n\n    @Autowired\n    private ServiceA serviceA;\n}\n</code></pre>\n<p>重新启动程序，执行结果：</p>\n<blockquote>\n<p>Requested bean is currently in creation: Is there an unresolvable circular reference</p>\n</blockquote>\n<p>果然出现了循环依赖。</p>\n<p>注意：这种循环依赖问题是无法解决的，因为它没有用缓存，每次都会生成一个新对象。</p>\n<h2><a id=\"33_313\"></a>3.3、构造器注入</h2>\n<p>这种注入方式现在其实用的已经非常少了，但是我们还是有必要了解一下，看看如下代码：</p>\n<pre><code>@Service\npublic class ServiceA {\n\n\tpublic ServiceA(ServiceB serviceB) {\n\t}\n}\n\n@Service\npublic class ServiceB {\n\n\tpublic ServiceB(ServiceA serviceA) {\n\t}\n}\n</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>Requested bean is currently in creation: Is there an unresolvable circular reference</p>\n</blockquote>\n<p>出现了循环依赖，为什么呢？<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\55477a608f224b3a9aa21a4a7fd6d579.png\"/><br/> 从图中的流程看出构造器注入没能添加到三级缓存，也没有使用缓存，所以也无法解决循环依赖问题。</p>\n<h2><a id=\"34setter_341\"></a>3.4、单例的代理对象setter注入</h2>\n<p>这种注入方式其实也比较常用，比如平时使用：@Async注解的场景，会通过AOP自动生成代理对象。</p>\n<pre><code>@Service\n@EnableAsync\npublic class ServiceA {\n\n\t@Autowired\n\tprivate ServiceB serviceB;\n\n\t@Async\n\tpublic void test1() {\n\t\tSystem.out.println(\"async\");\n\t}\n}\n\n@Service\npublic class ServiceB {\n\n\t@Autowired\n\tprivate ServiceA serviceA;\n}\n</code></pre>\n<p>程序启动会报错，出现了循环依赖：</p>\n<blockquote>\n<p>org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name ‘serviceA’: Bean with name ‘serviceA’ has been injected into other beans [serviceB] in its raw version as part of a circular reference</p>\n</blockquote>\n<p>为什么会循环依赖呢？答案就在下面这张图中：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4c0023814af84b85842809dc15cbb8b7.png\"/><br/> 说白了，bean初始化完成之后，后面还有一步去检查：第二级缓存是否存在， 代理对象和原始对象是否相等。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a078cac4d9854bfb8af63fab0d64d86b.png\"/><br/> 到此发现第二级缓存存在并且代理对象和原始对象是不相等，因此抛出上面异常。</p>\n<p>如果这时候把ServiceA改个名字，改成：ServiceC，其他的都不变。</p>\n<pre><code>@Service\npublic class ServiceB {\n\n\t@Autowired\n\tprivate ServiceC serviceC;\n}\n\n@Service\n@EnableAsync\npublic class ServiceC {\n\n\t@Autowired\n\tprivate ServiceB serviceB;\n\n\t@Async\n\tpublic void test1() {\n\t\tSystem.out.println(\"async\");\n\t}\n}\n</code></pre>\n<p>再重新启动一下程序，成功了，没有报错了!!!<br/> 这又是为什么？<br/> 这就要从spring的bean加载顺序说起了，默认情况下，spring是按照文件完整路径递归查找的，按路径+文件名排序，排在前面的先加载。所以ServiceA比ServiceB先加载，而改了文件名称之后，ServiceB比ServiceC先加载。为什么ServiceB比ServiceC先加载就没问题呢？答案在下面这张图中：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c9b4df4e1f27438fbf1a8d98a3c546a4.png\"/><br/> 这种情况ServiceC第二级缓存是空的，不需要跟原始对象判断，所以不会抛出循环依赖。</p>\n<h2><a id=\"35DependsOn_407\"></a>3.5、DependsOn循环依赖</h2>\n<p>还有一种有些特殊的场景，比如我们需要在实例化Bean serviceA之前，先实例化Bean serviceB，这个时候就可以使用@DependsOn注解。</p>\n<pre><code>@Service\n@DependsOn(\"serviceB\")\npublic class ServiceA {\n\t\n}\n\n@Service\n@DependsOn(\"serviceA\")\npublic class ServiceB {\n\t\n}\n</code></pre>\n<p>程序启动之后，执行结果：</p>\n<blockquote>\n<p>Circular depends-on relationship between ‘serviceB’ and ‘serviceA’</p>\n</blockquote>\n<p>这个例子中本来如果ServiceA和ServiceB都没有加@DependsOn注解是没问题的，反而加了这个注解会出现循环依赖问题。</p>\n<p>这又是为什么？</p>\n<p>答案在AbstractBeanFactory类的doGetBean方法的这段代码中：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\783c694faf2243fc81513e33649c9d81.png\"/><br/> 初始化bean前，它会检查dependsOn的实例有没有循环依赖，如果有循环依赖则抛异常。</p>\n<h1><a id=\"5_437\"></a>5、出现循环依赖如何解决？</h1>\n<p>项目中如果出现循环依赖问题，说明是spring默认无法解决的循环依赖，要看项目的打印日志，属于哪种循环依赖。目前包含下面几种情况：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9963935e69444a8a995217640c48052b.png\"/></p>\n<h2><a id=\"51_443\"></a>5.1、生成代理对象产生的循环依赖</h2>\n<p>生成代理对象产生的循环依赖这类循环依赖问题解决方法很多，主要有：<br/> 1、使用@Lazy注解，延迟加载<br/> 2、使用@DependsOn注解，指定加载先后关系<br/> 3、修改文件名称，改变循环依赖类的加载顺序</p>\n<h2><a id=\"52DependsOn_451\"></a>5.2、DependsOn循环依赖</h2>\n<p>使用@DependsOn产生的循环依赖这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。</p>\n<h2><a id=\"53_456\"></a>5.3、多例循环依赖</h2>\n<p>多例循环依赖这类循环依赖问题可以通过把bean改成单例的解决。</p>\n<h2><a id=\"53_461\"></a>5.3、构造器循环依赖</h2>\n<p>构造器循环依赖这类循环依赖问题可以通过使用@Lazy注解解决。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-06-12 13:36:20", "summary": "文章目录、什么是循环依赖？、怎么检测循环依赖、怎么解决循环依赖、循环依赖的种场景、单例的注入、多例的注入、构造器注入、单例的代理对象注入、循环依赖、出现循环依赖如何解决？、生成代理对象产生的循环依赖、"}