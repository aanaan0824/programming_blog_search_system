{"blogid": "126438936", "writerAge": "码龄158天", "writerBlogNum": "22", "writerCollect": "214", "writerComment": "306", "writerFan": "127", "writerGrade": "4级", "writerIntegral": "1244", "writerName": "Node_Hao", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126438936.jpg", "writerRankTotal": "15734", "writerRankWeekly": "658", "writerThumb": "308", "writerVisitNum": "9849", "blog_read_count": "1345", "blog_time": "于 2022-08-23 10:29:55 发布", "blog_title": "[Java]剖析异常处理机制与常见面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/f4f5247f4fd340b6826e71744afda345.gif\"/></p>\n<p></p>\n<blockquote>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\cb2be72a3c2b4b59b1128abf613b8abe.png\" width=\"16\"/><span style=\"background-color:#ff9900;\">专栏简介 :java语法</span></p>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\4366a93aaa3142b5a0f16c7a2200339b.png\" width=\"16\"/><span style=\"background-color:#38d8f0;\">创作目标:从不一样的角度,用通俗易懂的方式,总结归纳java语法知识.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"..\\..\\static\\image\\52a3437a932f4621b25533c330f7c6cb.png\" width=\"15\"/><span style=\"background-color:#a2e043;\">希望在提升自己的同时,帮助他人,与大家一起共同进步,互相成长.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"..\\..\\static\\image\\14aa2f0648ae44a299b8f9832af57d2c.png\" width=\"15\"/><span style=\"background-color:#fbd4d0;\">学历代表过去,能力代表现在,学习能力代表未来!</span></p>\n</blockquote>\n<hr/>\n<blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:80px;\"></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80.%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">一.异常的概念与体系结构</a></p>\n<p id=\"1.1%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5\">1.1异常的概念</a></p>\n<p id=\"%C2%A01.2%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01.2%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%C2%A0\"> 1.2异常的体系结构 </a></p>\n<p id=\"1.3%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB\">1.3异常的分类</a></p>\n<p id=\"%E4%BA%8C.%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86\">二.异常的处理</a></p>\n<p id=\"%C2%A02.1%20throws-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.1%20throws\"> 2.1 throws</a></p>\n<p id=\"%C2%A02.2%20try_catch-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.2%20try_catch\"> 2.2 try_catch</a></p>\n<p id=\"%C2%A02.3%C2%A0%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.3%C2%A0%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B\"> 2.3 防御式编程</a></p>\n<p id=\"1.LBYL%3ALook%20Before%20You%20Leap.%E5%9C%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E5%B0%B1%E5%81%9A%E5%85%85%E5%88%86%E7%9A%84%E6%A3%80%E6%9F%A5%2C%E5%8D%B3%3A%E4%BA%8B%E5%89%8D%E9%98%B2%E5%BE%A1%E5%9E%8B-toc\" style=\"margin-left:80px;\"><a href=\"#1.LBYL%3ALook%20Before%20You%20Leap.%E5%9C%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E5%B0%B1%E5%81%9A%E5%85%85%E5%88%86%E7%9A%84%E6%A3%80%E6%9F%A5%2C%E5%8D%B3%3A%E4%BA%8B%E5%89%8D%E9%98%B2%E5%BE%A1%E5%9E%8B\">1.LBYL:Look Before You Leap.在操作之前就做充分的检查,即:事前防御型</a></p>\n<p id=\"2.EAFP%3AIt%20is%20Easier%20to%20Ask%20Forgiveness%20than%20Permission.%E4%BA%8B%E5%90%8E%E8%AE%A4%E9%94%99%E6%AF%94%E4%BA%8B%E5%89%8D%E7%94%B3%E8%AF%B7%E6%9B%B4%E5%AE%B9%E6%98%93.%E5%8D%B3%3A%E4%BA%8B%E5%90%8E%E8%AE%A4%E9%94%99%E5%9E%8B.-toc\" style=\"margin-left:80px;\"><a href=\"#2.EAFP%3AIt%20is%20Easier%20to%20Ask%20Forgiveness%20than%20Permission.%E4%BA%8B%E5%90%8E%E8%AE%A4%E9%94%99%E6%AF%94%E4%BA%8B%E5%89%8D%E7%94%B3%E8%AF%B7%E6%9B%B4%E5%AE%B9%E6%98%93.%E5%8D%B3%3A%E4%BA%8B%E5%90%8E%E8%AE%A4%E9%94%99%E5%9E%8B.\">2.EAFP:It is Easier to Ask Forgiveness than Permission.事后认错比事前申请更容易.即:事后认错型.</a></p>\n<p id=\"%C2%A02.4%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20try_catch-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.4%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20try_catch\"> 2.4 深入理解 try_catch</a></p>\n<p id=\"%C2%A02.5%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.5%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95\"> 2.5异常中的两个重要方法</a></p>\n<p id=\"%C2%A02.6finally%E5%AD%90%E5%8F%A5-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.6finally%E5%AD%90%E5%8F%A5\"> 2.6finally子句</a></p>\n<p id=\"2.6.1finally%E8%AF%AD%E5%8F%A5%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#2.6.1finally%E8%AF%AD%E5%8F%A5%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B\">2.6.1finally语句通常使用在什么情况下</a></p>\n<p id=\"2.6.2%C2%A0try%E4%B8%8Efinally%E8%BF%9E%E7%94%A8%E6%B2%A1%E6%9C%89catch-toc\" style=\"margin-left:80px;\"><a href=\"#2.6.2%C2%A0try%E4%B8%8Efinally%E8%BF%9E%E7%94%A8%E6%B2%A1%E6%9C%89catch\">2.6.2 try与finally连用没有catch</a></p>\n<p id=\"2.6.3%C2%A0finally%20%E5%AD%90%E5%8F%A5%E5%A4%B1%E6%95%88.-toc\" style=\"margin-left:80px;\"><a href=\"#2.6.3%C2%A0finally%20%E5%AD%90%E5%8F%A5%E5%A4%B1%E6%95%88.\">2.6.3 finally 子句失效.</a></p>\n<p id=\"%C2%A02.7%20final%20finally%20finalize%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.7%20final%20finally%20finalize%20%E7%9A%84%E5%8C%BA%E5%88%AB\"> 2.7 final finally finalize 的区别</a></p>\n<p id=\"%C2%A02.9%C2%A0%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.9%C2%A0%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98\"> 2.9 常见面试题</a></p>\n<p id=\"1.try_catch_finally%E4%B8%AD%E5%A6%82%E6%9E%9Ccatch%E4%B8%ADreturn%E4%BA%86%2Cfinally%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%3F-toc\" style=\"margin-left:80px;\"><a href=\"#1.try_catch_finally%E4%B8%AD%E5%A6%82%E6%9E%9Ccatch%E4%B8%ADreturn%E4%BA%86%2Cfinally%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%3F\">1.try_catch_finally中如果catch中return了,finally还会执行吗?</a></p>\n<p id=\"2.Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc\" style=\"margin-left:80px;\"><a href=\"#2.Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F\">2.Error和Exception的区别是什么?</a></p>\n<p id=\"3.JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%3F-toc\" style=\"margin-left:80px;\"><a href=\"#3.JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%3F\">3.JVM是如何处理异常的?</a></p>\n<p id=\"4.throw%E4%B8%8Ethrows%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F-toc\" style=\"margin-left:80px;\"><a href=\"#4.throw%E4%B8%8Ethrows%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F\">4.throw与throws的区别是什么?</a></p>\n<p id=\"5.%E8%AF%B4%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C---%E5%87%BA%E8%87%AA%3C%3Cjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%3E%3E-toc\" style=\"margin-left:80px;\"><a href=\"#5.%E8%AF%B4%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C---%E5%87%BA%E8%87%AA%3C%3Cjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%3E%3E\">5.说出下面代码的执行结果---出自&lt;&gt;编程思想&gt;</a></p>\n<p id=\"6.finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8return%E5%90%97%3F-toc\" style=\"margin-left:80px;\"><a href=\"#6.finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8return%E5%90%97%3F\">6.finally语句块中可以使用return吗?</a></p>\n<p id=\"%E4%B8%89.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\">三.自定义异常</a></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n</blockquote>\n<div>\n<h3></h3>\n</div>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_7\"></a>前言</h1>\n<blockquote>\n<p><img alt=\"\" height=\"17\" src=\"..\\..\\static\\image\\90b3cd601f904d688c1e2d56fa78947c.png\" width=\"17\"/><span style=\"background-color:#fbd4d0;\">异常</span>是java知识体系中较为零散的知识点,日常学习中总是遇到一点学习一点,很难形成自己的<span style=\"background-color:#ff9900;\">知识体系</span>,鉴于以上原因博主系统的整理了<span style=\"background-color:#fbd4d0;\">异常</span>的知识点希望可以帮到你!</p>\n</blockquote>\n<hr/>\n<h1 id=\"%E4%B8%80.%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">一.异常的概念与体系结构</h1>\n<h2 id=\"1.1%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5\">1.1异常的概念</h2>\n<blockquote>\n<p>        <span style=\"background-color:#fbd4d0;\">异常</span>是一个十分广泛的概念,不仅仅存在于程序的运行过程中,例如:日常生活中我们去滑雪场滑雪,当我们脚踩滑雪板遇到雪坡,高高跃起时稍有不慎落地就会有摔倒的危险,当我们在空中的瞬间<span style=\"background-color:#ffd900;\">大脑就会向身体抛异常</span>.<span style=\"background-color:#fbd4d0;\">大脑</span>: <span style=\"color:#38d8f0;\">哥们!一定要小心啊!不然你就要摔倒了!</span><span style=\"background-color:#fbd4d0;\"> 身体</span>:<span style=\"color:#38d8f0;\">收到!谢谢提醒!</span>(<span style=\"background-color:#ffd900;\">并作出相应反应</span>).设想如果大脑不向身体抛异常,我们就这么傻傻的落下去,必定会摔的很惨!</p>\n</blockquote>\n<p><img alt=\"\" height=\"889\" src=\"..\\..\\static\\image\\905696a7d04e4f90843995b8ad9f48da.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"324\" src=\"..\\..\\static\\image\\78046e4593ad4cc185f0e0fbf35f835a.png\" width=\"1200\"/> </p>\n<hr/>\n<p> </p>\n<blockquote>\n<p>        而思维缜密追求完美的程序员在日常开发中,即使绞尽脑汁把程序写的尽善尽美,也难免会出错.<span style=\"background-color:#a2e043;\">有时通过代码很难去控制,</span>比如<span style=\"background-color:#fbd4d0;\">数据格式不对</span>,<span style=\"background-color:#fbd4d0;\">数组越界</span>,<span style=\"background-color:#fbd4d0;\">算数异常</span>.....因此java把程序运行过程中出现的不正常行为称为<span style=\"background-color:#a2e043;\">异常,</span>例如我们在写代码时经常遇到的:</p>\n</blockquote>\n<p>1.算数异常</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        System.out.println(10/0);\n    }\nException in thread \"main\" java.lang.ArithmeticException</code></pre>\n<p>2.数组越界异常</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n       int[]arr = {1,2,3};\n       arr[100] = 10;\n    }\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException</code></pre>\n<p>3.空指针异常 </p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n       int[]arr = null;\n        System.out.println(arr.length);\n    }\nException in thread \"main\" java.lang.NullPointerException</code></pre>\n<blockquote>\n<p>从上述例子可以看出:</p>\n<ul><li>java中<span style=\"background-color:#a2e043;\">不同类型</span>的<span style=\"background-color:#fbd4d0;\">异常</span>,都有其所对应的<span style=\"background-color:#fbd4d0;\">类</span>. </li><li>异常的作用:增强程序的<span style=\"background-color:#ff9900;\">健壮性.</span></li></ul>\n</blockquote>\n<p><img alt=\"\" height=\"1020\" src=\"..\\..\\static\\image\\8420f94554ec4881bb78cf9177d662c3.png\" width=\"1200\"/> </p>\n<hr/>\n<p> </p>\n<h2 id=\"%C2%A01.2%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%C2%A0\"> 1.2异常的体系结构 </h2>\n<p>异常的种类繁多,为了对不同种类的异常进行更好的分类管理,java内部维护了一个异常的体系结构.</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\70cb7d1f1cce4ab6b8048e55eb3ff008.jpeg\"/></p>\n<p></p>\n<p></p>\n<hr/>\n<h2 id=\"1.3%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB\">1.3异常的分类</h2>\n<blockquote>\n<p>        由上文可知每一个异常都对应一个类,因此异常的发生就是<span style=\"background-color:#fbd4d0;\">new异常对象</span>,所以异常都是在<span style=\"background-color:#fbd4d0;\">运行阶段</span>发生的,因为只有在运行阶段才能new对象,</p>\n</blockquote>\n<p><strong>       1.编译时异常</strong></p>\n<blockquote>\n<p>         要求程序员在<span style=\"background-color:#a2e043;\">编写程序阶段</span>必须对这些异常进行处理,如果不处理<span style=\"background-color:#a2e043;\">编译器会报错</span>,因此得名<span style=\"background-color:#fbd4d0;\">编译期异常</span>,也称<span style=\"background-color:#fbd4d0;\">受查时期异常</span>.(Checked Execption)</p>\n</blockquote>\n<p>       <strong> 2.运行时异常</strong></p>\n<blockquote>\n<p>         程序员在编写程序阶段可以预处理也可以不管,称为<span style=\"background-color:#a2e043;\">运行时期异常</span>,也称<span style=\"background-color:#fbd4d0;\">非受查时期异常</span>.(UnChecked Execption)</p>\n</blockquote>\n<blockquote>\n<p><span style=\"background-color:#ff9900;\">注意:编译时异常与运行时异常的区别:</span></p>\n<ul><li><span style=\"background-color:#fbd4d0;\">编译时异常</span>并不意外着异常发生在编译时期,只是提醒程序员在<span style=\"background-color:#a2e043;\">编写程序的时期必须预先对这种异常进行处理</span>,如果不处理就会<span style=\"background-color:#ff9900;\">报错,</span>因为<span style=\"background-color:#fbd4d0;\">编译时异常发生概率比较高</span></li><li><span style=\"background-color:#fbd4d0;\">运行时期异常</span>指程序以通过编译得到<span style=\"background-color:#a2e043;\">class文件</span>了,再由<span style=\"background-color:#a2e043;\">JVM</span>执行过程中出现的错误.<span style=\"background-color:#fbd4d0;\">运行时异常发生概率比较低.</span></li></ul>\n</blockquote>\n<p>eg1:<span style=\"background-color:#fbd4d0;\">运行时异常</span></p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        System.out.println(100/0);\n        //这里的hello world既没有输出也没有执行.\n        System.out.println(\"hello world\");\n    }</code></pre>\n<p>当程序执行到<span style=\"color:#fe2c24;\"> </span><span style=\"color:#ed7976;\"><span style=\"background-color:#fef2f0;\">System.out.println(100/0);</span></span></p>\n<p>此处发生了<strong><code><span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">ArithmeticException</span></span>异常,底层会<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">new</span></span>一个ArithmeticException<span style=\"background-color:#a2e043;\">异常</span>对象然后<span style=\"background-color:#ff9900;\">抛出</span>.</code></strong></p>\n<p>由于(100/0)是在<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">main</span></span>方法中调用的,所以异常会抛给main方法,但main方法不会理睬,只能交给<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">JVM</span></span>以最粗暴的方式解决,那就是终止程序.</p>\n<p>所以此时<span style=\"color:#ed7976;\"><span style=\"background-color:#fef2f0;\">System.out.println(\"hello world\");</span></span>并不会执行.</p>\n<blockquote>\n<p>注意:</p>\n<p><strong><code><span style=\"background-color:#fbd4d0;\">ArithmeticException</span>继承自<span style=\"background-color:#fbd4d0;\">RuntimeException</span></code></strong>属于运行时异常,程序预处理阶段<span style=\"background-color:#a2e043;\">不需要</span>对这种异常进行处理.</p>\n</blockquote>\n<p>eg2:<span style=\"background-color:#fbd4d0;\">编译时异常 </span></p>\n<pre><code class=\"language-java\">class Teacher implements Cloneable{\n    private String name;\n    private int age;\n\n    //想让该类支持深拷贝,重写Object类的clone()方法即可.\n    \n    @Override\n    protected Object clone()  {\n        return super.clone();\n    }\n}\n    /** \n     * 编译时报错\n     * Unhandled exception: 未报告的异常错误java.lang.CloneNotSupportedException; 必须对其进行捕获或声明以便抛出\n     */</code></pre>\n<p>这段异常表示<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">clone()</span></span>方法在执行过程中可能会出现<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">CloneNotSupportedException</span></span>异常.</p>\n<p>叫做<span style=\"background-color:#a2e043;\">克隆不支持异常</span>,这个异常的直接父类是<span style=\"background-color:#fbd4d0;\">Exception</span>,所以CloneNotSupportedException属于<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">编译时异常</span></span>.</p>\n<p>解决方式一.<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">throws</span></span>上报给方法调用者(推卸责任,调用者知道)也叫Ducks</p>\n<pre><code class=\"language-java\">class Teacher implements Cloneable {\n    private String name;\n    private int age;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}</code></pre>\n<p>解决方式二.<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">try-catch</span></span>捕捉处理(调用者不知道)</p>\n<pre><code class=\"language-java\">class Teacher implements Cloneable {\n    private String name = \"zhangsan\";\n    private int age = 38;\n    \n    @Override\n    protected Object clone(){\n        try {\n            return super.clone();\n\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return null;\n    }\n}</code></pre>\n<p></p>\n<hr/>\n<p></p>\n<h1 id=\"%E4%BA%8C.%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86\"><strong>二.异常的处理</strong></h1>\n<h2 id=\"%C2%A02.1%20throws\"> 2.1 throws</h2>\n<p> 在方法的声明上使用<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">throws关键字</span></span>抛出,谁调用这个方法就由谁来解决这个异常,由方法的调用者来解决.</p>\n<p>这种处理异常的方式叫<span style=\"background-color:#fbd4d0;\">上报</span>也叫<span style=\"background-color:#fbd4d0;\">潜水</span>(Duck)</p>\n<h2 id=\"%C2%A02.2%20try_catch\"> 2.2 try_catch</h2>\n<p> 这个异常不会上报,自己把异常处理了.异常到此为止了.</p>\n<blockquote>\n<p>注意:</p>\n<ul><li>只要异常没捕捉,采用上报的方式让JVM知道,此方法的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">后续代码不会执行</span></span>.</li><li>try语句块中某行代码出现异常,该行<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">后面的代码不会执行</span></span>.</li><li>try_catch语句块<span style=\"background-color:#a2e043;\">捕获异常后</span>,后续代码会执行.</li></ul>\n</blockquote>\n<p>eg: </p>\n<pre><code class=\"language-java\">public static void FileTest()throws FileNotFoundException {\n        System.out.println(\"打开文件\");\n        FileMyData();//该方法可能有异常\n\n        //以上代码出现异常这里将无法执行\n        System.out.println(\"关闭文件\");\n    }</code></pre>\n<pre><code class=\"language-java\">public static void FileTest(){\n        try{\n            FileMyData();\n            System.out.println(\"打开文件\");\n            }catch(FileNotFoundException e){\n                     System.out.println(\"打开文件失败\");\n                     System.out.println(e);//以程序语言输出异常\n            }\n            System.out.println(\"关闭文件\");//会执行\n    }</code></pre>\n<blockquote>\n<p>注意:</p>\n<ul><li>一般由<span style=\"background-color:#fbd4d0;\">main()</span>函数调用的方法不建议<span style=\"background-color:#a2e043;\">throws</span>,因为一但发生异常直接交给JVM,<span style=\"background-color:#fbd4d0;\">JVM</span>只能终止程序.</li><li>一般建议<span style=\"background-color:#fbd4d0;\">main()</span>函数中的异常用try_catch捕捉.</li></ul>\n</blockquote>\n<hr/>\n<pre><code class=\"language-java\">try {\n    \n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n}</code></pre>\n<p> 注意:<span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#fbd4d0;\">e</span></strong></span>引用中保存的是<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">new</span></span>出来的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">异常对象的地址</span></span>.</p>\n<hr/>\n<blockquote>\n<p> 因此以后开发过程中要抛异常(<span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#fef2f0;\">throw</span></strong></span>)还是捕获(<span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#fef2f0;\">try_catch</span></strong></span>),视开发者的具体情况而定.</p>\n</blockquote>\n<h2 id=\"%C2%A02.3%C2%A0%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B\"> 2.3 防御式编程</h2>\n<blockquote>\n<p>         出现错误的代码再正常不过,及时的发现并解决问题才是好的程序员,因此<span style=\"background-color:#a2e043;\">出现错误并及时</span>的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">通知</span></span>程序员才是最关键的,以下提供两种通知方式:</p>\n</blockquote>\n<p>以我们常见的游戏王者荣耀举例,游戏的每一个环节所对应的方法都有可能出错,所以我们每一个环节都要注意.</p>\n<h3 id=\"1.LBYL%3ALook%20Before%20You%20Leap.%E5%9C%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E5%B0%B1%E5%81%9A%E5%85%85%E5%88%86%E7%9A%84%E6%A3%80%E6%9F%A5%2C%E5%8D%B3%3A%E4%BA%8B%E5%89%8D%E9%98%B2%E5%BE%A1%E5%9E%8B\">1.<span style=\"background-color:#a2e043;\">LBYL</span>:Look Before You Leap.在操作之前就做充分的检查,即:<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">事前防御型</span></span></h3>\n<pre><code class=\"language-java\">boolean ret = false;\nret = 登陆游戏();\nif (!ret) {\n处理登陆游戏错误;\nreturn;\n} r\net = 开始匹配();\nif (!ret) {\n处理匹配错误;\nreturn;\n} r\net = 游戏确认();\nif (!ret) {\n处理游戏确认错误;\nreturn;\n} r\net = 选择英雄();\nif (!ret) {\n处理选择英雄错误;\nreturn;\n........</code></pre>\n<p>缺点:该方法的正常代码和错误代码混在一起,整体代码显得非常凌乱.</p>\n<h3 id=\"2.EAFP%3AIt%20is%20Easier%20to%20Ask%20Forgiveness%20than%20Permission.%E4%BA%8B%E5%90%8E%E8%AE%A4%E9%94%99%E6%AF%94%E4%BA%8B%E5%89%8D%E7%94%B3%E8%AF%B7%E6%9B%B4%E5%AE%B9%E6%98%93.%E5%8D%B3%3A%E4%BA%8B%E5%90%8E%E8%AE%A4%E9%94%99%E5%9E%8B.\">2.<span style=\"background-color:#a2e043;\">EAFP</span>:It is Easier to Ask Forgiveness than Permission.事后认错比事前申请更容易.即:<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">事后认错</span><span style=\"background-color:#fbd4d0;\">型.</span></span></h3>\n<pre><code class=\"language-java\">try {\n登陆游戏();\n开始匹配();\n游戏确认();\n选择英雄();\n载入游戏画面();\n...\n} catch (登陆游戏异常) {\n处理登陆游戏异常;\n} catch (开始匹配异常) {\n处理开始匹配异常;\n} catch (游戏确认异常) {\n处理游戏确认异常;\n} catch (选择英雄异常) {\n处理选择英雄异常;\n} catch (载入游戏画面异常) {\n处理载入游戏画面异常;\n}\n......\n\n</code></pre>\n<p>优点:正常流程与错误流程分开程序员更关注正常流程.代码清晰明了. </p>\n<hr/>\n<h2 id=\"%C2%A02.4%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20try_catch\"> 2.4 深入理解 try_catch</h2>\n<blockquote>\n<ol><li>catch后面的小括号类型可以是<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">具体的异常类型</span></span>也可以说异常的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">父类的类型</span></span>,为了方便后续调试一般建议写<span style=\"background-color:#d4e9d5;\">具体的异常类型</span>.</li><li>catch可以写<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">多个</span></span>,为了方便后续的调试,建议一个一个<span style=\"background-color:#d4e9d5;\">精确</span>的处理.</li><li>catch写多个时异常类型从<span style=\"background-color:#edf6e8;\">上到下</span>必须遵循<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">从小到大</span></span>,如果第一个异常类型非常大后续catch将不再捕获.</li><li>自JDK1.8之后,一个catch中可以用<span style=\"background-color:#fef2f0;\"> </span><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">| 分割</span></span>来捕获多个异常.</li></ol>\n</blockquote>\n<pre><code class=\"language-java\"> public static void main(String[] args) {\n        try {\n            FileInputStream fileInputStream = new FileInputStream(\"D:\\\\data\\1.txt\");\n        }catch (FileNotFoundException e){\n            System.out.println(\"该文件不存在\");\n        }\n        //等价于\n        try {\n            FileInputStream fileInputStream = new FileInputStream(\"D:\\\\data\\1.txt\");\n        }catch (Exception e){//多态原理:Exception e = new FileNotFoundException\n            System.out.println(\"该文件不存在\");\n        }\n    }</code></pre>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        try {\n            FileInputStream fileInputStream = new FileInputStream(\"D:\\\\data\\1.txt\");\n        }catch (IOException m){\n            System.out.println(\"读取文件不存在\");\n        }catch (FileNotFoundException e){\n            System.out.println(\"该文件不存在\");\n        }\n        //异常:Exception 'java.io.FileNotFoundException' has already been caught</code></pre>\n<blockquote>\n<p>由于IOException为FileNotFoundException的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">父类</span></span>,如果IOException写在前面,那么FileNotFoundException将无法执行导致编译<span style=\"background-color:#d4e9d5;\">无法通过</span>.</p>\n</blockquote>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        try {\n            FileInputStream fileInputStream = new FileInputStream(\"D:\\\\data\\1.txt\");\n            System.out.println(100/0);\n        }catch (IOException |ArithmeticException |NullPointerException e){\n            System.out.println(\"读取文件不存在,算数异常,空指针异常\");\n        }</code></pre>\n<hr/>\n<h2 id=\"%C2%A02.5%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95\"> 2.5异常中的两个重要方法</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法名</td><td>作用</td></tr><tr><td>String <span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">getMessage()</span></span></td><td>返回异常的详细消息字符串</td></tr><tr><td>void <span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">printStackTrack()</span></span></td><td>追踪堆栈异常信息(采用异步线程)</td></tr></tbody></table>\n<h2 id=\"%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91\"> <img alt=\"\" height=\"440\" src=\"..\\..\\static\\image\\6794f6a006d0496287a64d9514b0bc6d.png\" width=\"1200\"/></h2>\n<hr/>\n<h2 id=\"%C2%A02.6finally%E5%AD%90%E5%8F%A5\"> 2.6finally子句</h2>\n<h3 id=\"2.6.1finally%E8%AF%AD%E5%8F%A5%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B\">2.6.1finally语句通常使用在什么情况下</h3>\n<blockquote>\n<ul><li>有些资源在<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">打开</span></span>的情况下发生了异常,那么关闭资源的操作就无法执行,所以finally通常使用在资源的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">释放或关闭.</span></span></li><li>有些try语句块有多个catch,如果每个catch中都有相同的语句,那么为了使代码更简洁,可以统一存放在finally语句中.(除了异常的对象,<span style=\"background-color:#d4e9d5;\">异常的对象只能在catch语句中使用</span>)</li></ul>\n</blockquote>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        FileInputStream fis = null;\n        //声明到try的作用域之外,才能被finally执行\n        try {\n            fis = new FileInputStream(\"D:\\\\data\\1.txt\");\n            String s = null;\n            System.out.println(\"helloworld\");\n        }catch (FileNotFoundException e){\n            e.printStackTrace();\n\n        }\n        finally {\n            if (fis!=null){//避免空指针异常\n                try {//close()可能有异常\n                    fis.close();\n                }catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }</code></pre>\n<hr/>\n<h3 id=\"2.6.2%C2%A0try%E4%B8%8Efinally%E8%BF%9E%E7%94%A8%E6%B2%A1%E6%9C%89catch\">2.6.2 try与finally连用没有catch</h3>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        try {\n            System.out.println(\"hello world\");\n            return;\n        }finally {\n            System.out.println(\"finally执行了\");\n        }\n}</code></pre>\n<blockquote>\n<p>以上代码执行顺序:</p>\n<ol><li>先执行try..</li><li> 再执行finally.</li><li>.最后return.</li></ol>\n</blockquote>\n<p>注意: try和finally都不能单独使用必须联合使用.finally语句块中的代码一定执行.</p>\n<hr/>\n<h3 id=\"2.6.3%C2%A0finally%20%E5%AD%90%E5%8F%A5%E5%A4%B1%E6%95%88.\">2.6.3 finally 子句失效.</h3>\n<p>只有<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">System.exit(0)</span></span>,和断电可以使finally子句失效.</p>\n<pre><code class=\"language-java\"> public static void main(String[] args) {\n        try {\n            System.out.println(\"hello world\");\n            System.exit(0);//程序直接结束运行\n        }finally {\n            System.out.println(\"finally执行了\");\n        }\n}</code></pre>\n<hr/>\n<h2 id=\"%C2%A02.7%20final%20finally%20finalize%20%E7%9A%84%E5%8C%BA%E5%88%AB\"> 2.7 final finally finalize 的区别</h2>\n<ul><li>final关键字</li></ul>\n<ol><li>final修饰的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">类</span></span>无法被<strong>继承</strong></li><li>final修饰的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">方法</span></span>无法被<strong>重写</strong></li><li>final修饰的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">变量</span></span>无法被<strong>重新赋值</strong></li><li>final修饰的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">引用类型</span></span>不能<strong>修改</strong></li></ol>\n<ul><li>finally关键字</li></ul>\n<ol><li>finally语句块<strong>必须被执行</strong></li><li>finally必须和<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">try</span></span><strong>联合使用</strong></li></ol>\n<ul><li>finalize标识符</li></ul>\n<ol><li>是一个<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">Object</span></span>类中的<strong>方法名</strong></li><li>这个方法是垃圾回收器<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">GC</span></span>负责调用的</li></ol>\n<hr/>\n<h2 id=\"%C2%A02.9%C2%A0%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98\"> 2.9 常见面试题</h2>\n<h3 id=\"1.try_catch_finally%E4%B8%AD%E5%A6%82%E6%9E%9Ccatch%E4%B8%ADreturn%E4%BA%86%2Cfinally%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%3F\">1.try_catch_finally中如果catch中return了,finally还会执行吗?</h3>\n<p>答:会执行,且在return<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">之前</span></span>执行</p>\n<pre><code class=\"language-java\">public static int test3(int i){\n        try{\n            System.out.println(i/0);\n            i = 20;\n        }catch (ArithmeticException e){\n            i = 30;\n            return i;\n            /**\n             * 此时 return 30;已经形成返回路径,返回路径一但形成就不会被修改,\n             * 对应return来讲i相等与一个常量30.当程序准备return时发现还有finally\n             * 没有执行,会先去执行finally子句中的代码.但此时return已不会被修改.\n             */\n        }finally {\n            i = 40;\n        }\n        return i;\n    }</code></pre>\n<hr/>\n<p></p>\n<h3 id=\"2.Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F\">2.Error和Exception的区别是什么?</h3>\n<blockquote>\n<ul><li>Error 类型的错误通常为<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">虚拟机错误</span></span>,如:<span style=\"background-color:#d4e9d5;\">系统崩溃</span>,<span style=\"background-color:#d4e9d5;\">内存不足</span>,<span style=\"background-color:#d4e9d5;\">栈溢出等</span>,编译器不会对这类错误进行检测,JAVA应用也不会对这类错误进行捕获,一但发生程序就会<span style=\"background-color:#fe2c24;\">终止</span>,仅靠应用程序本身无法恢复.</li><li>Exception 类型的错误可以在应用程序中<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">捕获并处理</span></span>,处理后应用程序就能恢复正常.</li></ul>\n</blockquote>\n<hr/>\n<p></p>\n<h3 id=\"3.JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%3F\">3.JVM是如何处理异常的?</h3>\n<blockquote>\n<ul><li>一个方法中如果发生异常,这个方法会<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">new</span></span>一个异常对象并转交给JVM,该异常对象包含<span style=\"background-color:#d4e9d5;\">异常名称,异常描述</span>以及<span style=\"background-color:#d4e9d5;\">异常发生时程序状态</span>,创建异常对象并交给JVM对象的过程称为抛出异常,可能经过一系列的方法调用才进入抛出异常的方法,这一系列方法调用的有序列表称为<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">调用栈</span></span>.</li><li>JVM会顺着<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">调用栈</span></span>去查找是否有需要处理异常的代码.如果有,JVM会把发生的异常传递给它,如果没有,JVM会将异常交给<span style=\"background-color:#d4e9d5;\">默认的异常处理器</span>(为JVM内部的一部分),默认异常处理器会打印异常信息并终止程序.</li></ul>\n</blockquote>\n<hr/>\n<p></p>\n<h3 id=\"4.throw%E4%B8%8Ethrows%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3F\">4.throw与throws的区别是什么?</h3>\n<blockquote>\n<ul><li>throw 关键字用在<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">方法内部</span></span>,只能用来抛出一种异常,抛出一个代码块或方法的异常,受查异常和非受查异常都能被抛出.</li><li>throws 关键字用在<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">方法声明上</span></span>,可以抛出多个异常,用来表示该方法可能抛出的异常列表,调用该方法的方法中必须包含可处理异常的代码,否则该方法签名中也要用throws声明相关的异常.</li></ul>\n</blockquote>\n<hr/>\n<p></p>\n<h3 id=\"5.%E8%AF%B4%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C---%E5%87%BA%E8%87%AA%3C%3Cjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%3E%3E\">5.说出下面代码的执行结果---出自&lt;&lt;java编程思想&gt;&gt;</h3>\n<pre><code class=\"language-java\">class Annoyance extends Exception{\n\n}\nclass Sneeze extends Annoyance{\n\n}\nclass Human{\n    public static void main(String[] args)throws Exception {\n            try {\n                try {\n                    throw new Sneeze();\n                }catch (Annoyance a){//多态的思想:父类捕获子类异常\n                    //相当于 Annoyance a = new Sneeze();\n                    System.out.println(\"Caught Annoyance\");\n                    throw a;\n                }\n            }catch (Sneeze s){//子类捕获子类异常一定成功\n                System.out.println(\"Caught Sneeze\");\n                return;//先执行finally子句再return\n            }finally {\n                System.out.println(\"hello world\");\n            }\n        }\n    }\n输出结果:Caught Annoyance\n        Caught Sneeze\n        hello world</code></pre>\n<hr/>\n<p></p>\n<h3 id=\"6.finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8return%E5%90%97%3F\">6.finally语句块中可以使用return吗?</h3>\n<p>答:可以但不建议,因为可能<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">影响</span></span>catch中return的内容.</p>\n<pre><code class=\"language-java\">public static int test3(int i){\n        try{\n            System.out.println(i/0);\n            i = 20;\n        }catch (ArithmeticException e){\n            i = 30;\n            return i;\n        }finally {\n            i = 40;\n            return i;//此时返回路径又变了,由于程序只能执行一个return所以直接返回40.\n        }\n    }\n    public static void main(String[] args) {\n        int i = 10;\n        test3(i);\n}</code></pre>\n<hr/>\n<h1 id=\"%E4%B8%89.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\">三.自定义异常</h1>\n<blockquote>\n<p>        在实际开发中会面临各种各样的问题,JDK内置的异常肯定是不够用的,这是就需要我们自定义异常,习惯上定义一个异常需要两个构造函数,一个<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">无参</span></span>构造函数,一个有<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">详细信息</span></span>的构造函数(<span style=\"background-color:#d4e9d5;\">Throwable中的toString()方法会打印这些信息调试时非常有用</span>)</p>\n</blockquote>\n<p>自定义异常创建步骤:</p>\n<ol><li>第一步:编写一个类<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">继承</span></span>Exception或者RuntimeException</li><li>第二步:提供两个构造方法,一个<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">无参</span></span>的,一个带有<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">String参数</span></span>的.</li></ol>\n<pre><code class=\"language-java\">class FileDamage extends Exception{//自定义异常:文件损坏异常\n    public FileDamage() {\n        super();\n    }\n\n    public FileDamage(String message, Throwable cause) {\n        super(message, cause);\n    }\n}</code></pre>\n<h1><a id=\"pandas_16\"></a></h1>\n<hr/>\n<h1 id=\"%E6%80%BB%E7%BB%93\"><a id=\"_45\"></a>总结</h1>\n<blockquote>\n<p>        综上所述,当你抛出异常并捕获异常时由很多的情况需要考虑,尤其是在业务需求庞大的项目里,大部分异常都是为了改善代码的可读性和健壮性.了解异常的基本逻辑在后续的学习中才能有跟深入的理解.<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">码字不易,您的支持是我创作的不懈动力!</span></span></p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\afdf2893c41d48b7884dfe25a80cab2b.jpeg\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-23 10:29:55", "summary": "专栏简介语法创作目标从不一样的角度用通俗易懂的方式总结归纳语法知识希望在提升自己的同时帮助他人与大家一起共同进步互相成长学历代表过去能力代表现在学习能力代表未来目录前言一异常的概念与体系结构异常的概念"}