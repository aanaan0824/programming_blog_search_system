{"blogid": "126743624", "writerAge": "码龄92天", "writerBlogNum": "732", "writerCollect": "892", "writerComment": "83", "writerFan": "982", "writerGrade": "6级", "writerIntegral": "7859", "writerName": "肥肥技术宅", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743624.jpg", "writerRankTotal": "2032", "writerRankWeekly": "367", "writerThumb": "151", "writerVisitNum": "119135", "blog_read_count": "16", "blog_time": "已于 2022-09-07 13:14:43 修改", "blog_title": "Spring中毒太深，离开Spring我连最基本的CRUD都不会写了...", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2><strong>前言</strong></h2>\n<p>随着 <code>Spring</code> 的崛起以及其功能的完善，现在可能绝大部分项目的开发都是使用 <code>Spring（全家桶）</code> 来进行开发，<code>Spring</code>也确实和其名字一样，是开发者的春天，<code>Spring</code> 解放了程序员的双手，而等到 <code>SpringBoot</code>出来之后配置文件大大减少，更是进一步解放了程序员的双手，但是也正是因为<code>Spring</code>家族产品的强大，使得我们习惯了面向 <code>Spring</code> 开发，那么假如有一天没有了 <code>Spring</code>，是不是感觉心里一空，可能一下子连最基本的接口都不会写了，尤其是没有接触过<code>Servlet</code>编程的朋友。因为加入没有了 <code>Spring</code> 等框架，那么我们就需要利用最原生的 <code>Servlet</code> 来自己实现接口路径的映射，对象也需要自己进行管理。</p>\n<h3><strong>Spring 能帮我们做什么</strong></h3>\n<p><code>Spring</code> 是为解决企业级应用开发的复杂性而设计的一款框架，<code>Spring</code> 的设计理念就是：简化开发。</p>\n<p>在 <code>Spring</code> 框架中，一切对象都是 <code>bean</code>，所以其通过面向 <code>bean</code> 编程（BOP），结合其核心思想依赖注入（DI）和面向切面(（AOP）编程，<code>Spring</code> 实现了其伟大的简化开发的设计理念。</p>\n<h3><strong>控制反转（IOC）</strong></h3>\n<p><code>IOC</code> 全称为：Inversion of Control。控制反转的基本概念是：不用创建对象，但是需要描述创建对象的方式。</p>\n<p>简单的说我们本来在代码中创建一个对象是通过 <code>new</code> 关键字，而使用了 <code>Spring</code> 之后，我们不在需要自己去 <code>new</code> 一个对象了，而是直接通过容器里面去取出来，再将其自动注入到我们需要的对象之中，即：依赖注入。</p>\n<p>也就说创建对象的控制权不在我们程序员手上了，全部交由 <code>Spring</code> 进行管理，程序要只需要注入就可以了，所以才称之为控制反转。</p>\n<h3><strong>依赖注入（DI）</strong></h3>\n<p>依赖注入（Dependency Injection，DI）就是 <code>Spring</code> 为了实现控制反转的一种实现方式，所有有时候我们也将控制反转直接称之为依赖注入。</p>\n<h3><strong>面向切面编程（AOP）</strong></h3>\n<p><code>AOP</code> 全称为：Aspect Oriented Programming。<code>AOP</code>是一种编程思想，其核心构造是方面（切面），即将那些影响多个类的公共行为封装到可重用的模块中，而使原本的模块内只需关注自身的个性化行为。</p>\n<p><code>AOP</code> 编程的常用场景有：Authentication（权限认证）、Auto Caching（自动缓存处理）、Error Handling（统一错误处理）、Debugging（调试信息输出）、Logging（日志记录）、Transactions（事务处理）等。</p>\n<h3><strong>利用 Spring 来完成 Hello World</strong></h3>\n<p>最原生的 <code>Spring</code> 需要较多的配置文件，而 <code>SpringBoot</code> 省略了许多配置，相比较于原始的 <code>Spring</code> 又简化了不少，在这里我们就以 <code>SpringBoot</code> 为例来完成一个简单的接口开发。</p>\n<ul><li> <p>1、新建一个 <code>maven</code> 项目，<code>pom</code> 文件中引入依赖（省略了少部分属性）：</p> </li></ul>\n<pre><code>&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.4.0&lt;/version&gt;\n    &lt;relativePath/&gt;\n&lt;/parent&gt;\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<ul><li> <p>2、新建一个 <code>HelloController</code> 类：</p> </li></ul>\n<pre><code>package com.lonely.wolf.note.springboot.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/hello\")\npublic class HelloController {\n    @GetMapping(\"/demo\")\n    public String helloWorld(String name){\n        return \"Hello：\" + name;\n    }\n}\n</code></pre>\n<ul><li> <p>3、最后新建一个 <code>SpringBoot</code> 启动类：</p> </li></ul>\n<pre><code>package com.lonely.wolf.note.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication(scanBasePackages = \"com.lonely.wolf.note.springboot\")\nclass MySpringBootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MySpringBootApplication.class, args);\n    }\n}\n</code></pre>\n<ul><li> <p>4、现在就可以输入测试路径：<code>http://localhost:8080/hello/demo?name=双子孤狼</code> 进行测试，正常输出：<code>Hello：双子孤狼</code>。</p> </li></ul>\n<p>我们可以看到，利用 <code>SpringBoot</code> 来完成一个简单的应用开发非常简单，可以不需要任何配置完成一个简单的应用，这是因为 <code>SpringBoot</code> 内部已经做好了约定（约定优于配置思想），包括容器 <code>Tomcat</code> 都被默认集成，所以我们不需要任何配置文件就可以完成一个简单的 <code>demo</code> 应用。</p>\n<h2><strong>假如没有了 Spring</strong></h2>\n<p>通过上面的例子我们可以发现，利用 <code>Spring</code> 来完成一个 <code>Hello World</code> 非常简单，但是假如没有了 <code>Spring</code>，我们又该如何完成这样的一个 <code>Hello World</code> 接口呢？</p>\n<h3>基于 Servlet 开发</h3>\n<p>在还没有框架之前，编程式基于原始的 <code>Servlet</code> 进行开发，下面我们就基于原生的 <code>Servlet</code> 来完成一个简单的接口调用。</p>\n<ul><li> <p>1、<code>pom</code> 文件引入依赖，需要注意的是，<code>package</code> 属性要设置成 <code>war</code> 包，为了节省篇幅，这里没有列出 <code>pom</code> 完整的信息：</p> </li></ul>\n<pre><code>&lt;packaging&gt;war&lt;/packaging&gt; \n&lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;2.4&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n            &lt;version&gt;3.7&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.72&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<ul><li> <p>2、在 <code>src/main</code> 下面新建文件夹 <code>webapp/WEB-INF</code>，然后在 <code>WEB-INF</code> 下面新建一个 <code>web.xml</code> 文件：</p> </li></ul>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:javaee=\"http://java.sun.com/xml/ns/javaee\"\n xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\n version=\"2.4\"&gt;\n &lt;display-name&gt;Lonely Wolf Web Application&lt;/display-name&gt;\n &lt;servlet&gt;\n  &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;\n  &lt;servlet-class&gt;com.lonely.wolf.mini.spring.servlet.HelloServlet&lt;/servlet-class&gt;\n &lt;/servlet&gt;\n &lt;servlet-mapping&gt;\n  &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;\n  &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;\n &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre>\n<p>这里面定义了 <code>selvlet</code> 和 <code>servlet-mapping</code> 两个标签，这两个标签必须一一对应，上面的标签定义了 <code>servlet</code> 的位置，而下面的 <code>servlet-mapping</code> 文件定义了路径的映射，这两个标签通过 <code>servlet-name</code> 标签对应。</p>\n<ul><li> <p>3、新建一个 <code>HelloServlet</code> 类继承 <code>HttpServlet</code>：</p> </li></ul>\n<pre><code>package com.lonely.wolf.mini.spring.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * 原始Servlet接口编写，一般需要实现GET和POST方法，其他方法可以视具体情况选择性继承\n */\npublic class HelloServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request,response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        response.getWriter().write(\"Hello：\" + request.getParameter(\"name\"));\n    }\n}\n</code></pre>\n<ul><li> <p>4、执行 <code>maven</code> 打包命令，确认成功打包成 <code>war</code> 包：</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f589a0f387453092d033fca688a6ae11.png\"/></p>\n<ul><li> <p>5、<code>RUN--&gt;Edit Configurations</code>，然后点击左上角的 <code>+</code> 号，新建一个 <code>Tomcat Server</code>，如果是第一次配置，默认没有 <code>Tomcat Server</code> 选项，需要点击底部的 <code>xx more items...</code>：</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\8d1f95e61661a5a642ecc290a6187a5f.png\"/></p>\n<ul><li> <p>6、点击右边的 <code>Deployment</code>，然后按照下图依次点击，最后在弹框内找到上面打包好的 <code>war</code> 包文件：</p> </li></ul>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\92fab9ee2e6cd92797a9db0b70713ded.png\"/></p>\n<p></p>\n<ul><li> <p>7、选中之后，需要注意的是，下面 <code>Application Context</code> 默认会带上 <code>war</code> 包名，为了方便，我们需要把它删掉，即不用上下文路径，只保留一个根路径 <code>/</code> （当然上下文也可以保留，但是每次请求都要带上这一部分）， 再选择 <code>Apply</code>，点击 <code>OK</code>，即可完成部署：</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\bfd609562bea22423fb9a6c21e805e0a.png\"/></p>\n<ul><li> <p>8、最后我们在浏览器输入请求路径<code>http://localhost:8080/hello?name=双子孤狼</code>，即可得到返回：<code>Hello：双子孤狼</code>。</p> </li></ul>\n<p>上面我们就完成了一个简单的 基于<code>Servlet</code> 的接口开发，可以看到，配置非常麻烦，每增加一个 <code>Servlet</code> 都需要增加对应的配置，所以才会有许多框架的出现来帮我们简化开发，比如原来很流行的 <code>Struts2</code> 框架，当然现在除了一些比较老的项目，一般我们都很少使用，而更多的是选择 <code>Spring</code> 框架来进行开发。</p>\n<h3>模仿Spring</h3>\n<p><code>Spring</code> 的源码体系非常庞大，大部分人对其源码都敬而远之。确实，<code>Spring</code> 毕竟经过了这么多年的迭代，功能丰富，项目庞大，不是一下子就能看懂的。虽然 <code>Spring</code> 难以理解，但是其最核心的思想仍然是我们上面介绍的几点，接下来就基于 <code>Spring</code> 最核心的部分来模拟，自己动手实现一个超级迷你版本的 <code>Spring</code>（此版本并不包含 <code>AOP</code> 功能）。</p>\n<ul><li> <p>1、<code>pom</code> 依赖和上面保持不变，然后 <code>web.xml</code> 作如下改变，这里会拦截所有的接口 <code>/*</code>，然后多配置了一个参数，这个参数其实也是为了更形象的模拟 <code>Spring</code>：</p> </li></ul>\n<pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;myDispatcherServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;com.lonely.wolf.mini.spring.v1.MyDispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;defaultConfig&lt;/param-name&gt;\n        &lt;param-value&gt;application.properties&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;myDispatcherServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n<ul><li> <p>2、在 <code>respurces</code> 下面新建一个配置文件 <code>application.properties</code>，用来定义扫描的基本路径：</p> </li></ul>\n<pre><code>basePackages=com.lonely.wolf.mini.spring\n</code></pre>\n<ul><li> <p>3、创建一些相关的注解类：</p> </li></ul>\n<pre><code>package com.lonely.wolf.mini.spring.annotation;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WolfAutowired {\n    String value() default \"\";\n}\npackage com.lonely.wolf.mini.spring.annotation;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WolfController {\n    String value() default \"\";\n}\npackage com.lonely.wolf.mini.spring.annotation;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WolfGetMapping {\n    String value() default \"\";\n}\npackage com.lonely.wolf.mini.spring.annotation;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WolfRequestParam {\n    String value() default \"\";\n}\npackage com.lonely.wolf.mini.spring.annotation;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WolfService {\n    String value() default \"\";\n}\n</code></pre>\n<ul><li> <p>4、这个时候最核心的逻辑就是 <code>MyDispatcherServlet</code> 类了：</p> </li></ul>\n<pre><code>package com.lonely.wolf.mini.spring.v1;\n\nimport com.lonely.wolf.mini.spring.annotation.*;\nimport com.lonely.wolf.mini.spring.v1.config.MyConfig;\nimport org.apache.commons.lang3.StringUtils;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.util.*;\n\npublic class MyDispatcherServlet extends HttpServlet {\n    private MyConfig myConfig = new MyConfig();\n    private List&lt;String&gt; classNameList = new ArrayList&lt;String&gt;();\n\n    private Map&lt;String,Object&gt; iocContainerMap = new HashMap&lt;&gt;();\n    private Map&lt;String,HandlerMapping&gt; handlerMappingMap = new HashMap&lt;&gt;();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request,response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            this.doDispatch(request, response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception{\n        String requestUrl = this.formatUrl(request.getRequestURI());\n        HandlerMapping handlerMapping = handlerMappingMap.get(requestUrl);\n        if (null == handlerMapping){\n            response.getWriter().write(\"404 Not Found\");\n            return;\n        }\n\n        //获取方法中的参数类型\n        Class&lt;?&gt;[] paramTypeArr = handlerMapping.getMethod().getParameterTypes();\n        Object[] paramArr = new Object[paramTypeArr.length];\n\n        for (int i=0;i&lt;paramTypeArr.length;i++){\n            Class&lt;?&gt; clazz = paramTypeArr[i];\n            //参数只考虑三种类型，其他不考虑\n            if (clazz == HttpServletRequest.class){\n                paramArr[i] = request;\n            }else if (clazz == HttpServletResponse.class){\n                paramArr[i] = response;\n            } else if (clazz == String.class){\n                Map&lt;Integer,String&gt; methodParam = handlerMapping.getMethodParams();\n                paramArr[i] = request.getParameter(methodParam.get(i));\n            }else{\n                System.out.println(\"暂不支持的参数类型\");\n            }\n        }\n        //反射调用controller方法\n        handlerMapping.getMethod().invoke(handlerMapping.getTarget(), paramArr);\n    }\n\n    private String formatUrl(String requestUrl) {\n        requestUrl = requestUrl.replaceAll(\"/+\",\"/\");\n        if (requestUrl.lastIndexOf(\"/\") == requestUrl.length() -1){\n            requestUrl = requestUrl.substring(0,requestUrl.length() -1);\n        }\n        return requestUrl;\n    }\n\n\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        //1.加载配置文件\n        try {\n            doLoadConfig(config.getInitParameter(\"defaultConfig\"));\n        } catch (Exception e) {\n            System.out.println(\"加载配置文件失败\");\n            return;\n        }\n\n        //2.根据获取到的扫描路径进行扫描\n        doScanPacakge(myConfig.getBasePackages());\n\n        //3.将扫描到的类进行初始化，并存放到IOC容器\n        doInitializedClass();\n\n        //4.依赖注入\n        doDependencyInjection();\n\n        System.out.println(\"DispatchServlet Init End...\" );\n    }\n\n\n    private void doDependencyInjection() {\n        if (iocContainerMap.size() == 0){\n            return;\n        }\n        //循环IOC容器中的类\n        Iterator&lt;Map.Entry&lt;String,Object&gt;&gt; iterator = iocContainerMap.entrySet().iterator();\n\n        while (iterator.hasNext()){\n            Map.Entry&lt;String,Object&gt; entry = iterator.next();\n            Class&lt;?&gt; clazz = entry.getValue().getClass();\n            Field[] fields = clazz.getDeclaredFields();\n\n            //属性注入\n            for (Field field : fields){\n                //如果属性有WolfAutowired注解则注入值（暂时不考虑其他注解）\n                if (field.isAnnotationPresent(WolfAutowired.class)){\n                    String value = toLowerFirstLetterCase(field.getType().getSimpleName());//默认bean的value为类名首字母小写\n                    if (field.getType().isAnnotationPresent(WolfService.class)){\n                        WolfService wolfService = field.getType().getAnnotation(WolfService.class);\n                        value = wolfService.value();\n                    }\n                    field.setAccessible(true);\n                    try {\n                        Object target = iocContainerMap.get(beanName);\n                        if (null == target){\n                            System.out.println(clazz.getName() + \"required bean:\" + beanName + \",but we not found it\");\n                        }\n                        field.set(entry.getValue(),iocContainerMap.get(beanName));//初始化对象，后面注入\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n\n            //初始化HanderMapping\n            String requestUrl = \"\";\n            //获取Controller类上的请求路径\n            if (clazz.isAnnotationPresent(WolfController.class)){\n                requestUrl = clazz.getAnnotation(WolfController.class).value();\n            }\n\n            //循环类中的方法，获取方法上的路径\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods){\n                //假设只有WolfGetMapping这一种注解\n                if(!method.isAnnotationPresent(WolfGetMapping.class)){\n                    continue;\n                }\n                WolfGetMapping wolfGetMapping = method.getDeclaredAnnotation(WolfGetMapping.class);\n                requestUrl = requestUrl + \"/\" + wolfGetMapping.value();//拼成完成的请求路径\n\n                //不考虑正则匹配路径/xx/* 的情况，只考虑完全匹配的情况\n                if (handlerMappingMap.containsKey(requestUrl)){\n                    System.out.println(\"重复路径\");\n                    continue;\n                }\n\n                Annotation[][] annotationArr = method.getParameterAnnotations();//获取方法中参数的注解\n\n                Map&lt;Integer,String&gt; methodParam = new HashMap&lt;&gt;();//存储参数的顺序和参数名\n                retryParam:\n                for (int i=0;i&lt;annotationArr.length;i++){\n                    for (Annotation annotation : annotationArr[i]){\n                        if (annotation instanceof WolfRequestParam){\n                            WolfRequestParam wolfRequestParam = (WolfRequestParam) annotation;\n                            methodParam.put(i,wolfRequestParam.value());//存储参数的位置和注解中定义的参数名\n                            continue retryParam;\n                        }\n                    }\n                }\n\n                requestUrl = this.formatUrl(requestUrl);//主要是防止路径多了/导致路径匹配不上\n                HandlerMapping handlerMapping = new HandlerMapping();\n                handlerMapping.setRequestUrl(requestUrl);//请求路径\n                handlerMapping.setMethod(method);//请求方法\n                handlerMapping.setTarget(entry.getValue());//请求方法所在controller对象\n                handlerMapping.setMethodParams(methodParam);//请求方法的参数信息\n                handlerMappingMap.put(requestUrl,handlerMapping);//存入hashmap\n            }\n        }\n    }\n\n\n    /**\n     * 初始化类，并放入容器iocContainerMap内\n     */\n    private void doInitializedClass() {\n        if (classNameList.isEmpty()){\n            return;\n        }\n        for (String className : classNameList){\n            if (StringUtils.isEmpty(className)){\n                continue;\n            }\n            Class clazz;\n            try {\n                clazz = Class.forName(className);//反射获取对象\n                if (clazz.isAnnotationPresent(WolfController.class)){\n                    String value = ((WolfController)clazz.getAnnotation(WolfController.class)).value();\n                    //如果直接指定了value则取value，否则取首字母小写类名作为key值存储类的实例对象\n                    iocContainerMap.put(StringUtils.isBlank(value) ? toLowerFirstLetterCase(clazz.getSimpleName()) : value,clazz.newInstance());\n                }else if(clazz.isAnnotationPresent(WolfService.class)){\n                    String value = ((WolfService)clazz.getAnnotation(WolfService.class)).value();\n                    iocContainerMap.put(StringUtils.isBlank(value) ? toLowerFirstLetterCase(clazz.getSimpleName()) : value,clazz.newInstance());\n                }else{\n                    System.out.println(\"不考虑其他注解的情况\");\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"初始化类失败，className为\" + className);\n            }\n        }\n\n    }\n\n    /**\n     * 将首字母转换为小写\n     * @param className\n     * @return\n     */\n    private String toLowerFirstLetterCase(String className) {\n        if (StringUtils.isBlank(className)){\n            return \"\";\n        }\n        String firstLetter = className.substring(0,1);\n        return firstLetter.toLowerCase() + className.substring(1);\n    }\n\n\n    /**\n     * 扫描包下所有文件获取全限定类名\n     * @param basePackages\n     */\n    private void doScanPacakge(String basePackages) {\n        if (StringUtils.isBlank(basePackages)){\n            return;\n        }\n        //把包名的.替换为/\n        String scanPath = \"/\" + basePackages.replaceAll(\"\\\\.\",\"/\");\n        URL url = this.getClass().getClassLoader().getResource(scanPath);//获取到当前包所在磁盘的全路径\n        File files = new File(url.getFile());//获取当前路径下所有文件\n        for (File file : files.listFiles()){//开始扫描路径下的所有文件\n            if (file.isDirectory()){//如果是文件夹则递归\n                doScanPacakge(basePackages + \".\" + file.getName());\n            }else{//如果是文件则添加到集合。因为上面是通过类加载器获取到的文件路径，所以实际上是class文件所在路径\n                classNameList.add(basePackages + \".\" + file.getName().replace(\".class\",\"\"));\n            }\n        }\n\n    }\n\n\n    /**\n     * 加载配置文件\n     * @param configPath - 配置文件所在路径\n     */\n    private void doLoadConfig(String configPath) {\n        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(configPath);\n        Properties properties = new Properties();\n        try {\n            properties.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"加载配置文件失败\");\n        }\n\n        properties.forEach((k, v) -&gt; {\n            try {\n                Field field = myConfig.getClass().getDeclaredField((String)k);\n                field.setAccessible(true);\n                field.set(myConfig,v);\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.out.println(\"初始化配置类失败\");\n                return;\n            }\n        });\n    }\n}\n</code></pre>\n<ul><li> <p>5、这个 <code>Servlet</code> 相比较于上面的 <code>HelloServlet</code> 多了一个 <code>init</code> 方法，这个方法中主要做了以下几件事情：</p> </li></ul>\n<p>（1）初始化配置文件，拿到配置文件中配置的参数信息（对应方法：<code>doLoadConfig</code>）。</p>\n<p>（2）拿到第 <code>1</code> 步加载出来的配置文件，获取到需要扫描的包路径，然后将包路径进行转换成实际的磁盘路径，并开始遍历磁盘路径下的所有 <code>class</code> 文件，最终经过转换之后得到扫描路径下的所有类的全限定类型，存储到全局变量 <code>classNameList</code> 中（对应方法：<code>doScanPacakge</code>）。</p>\n<p>（3）根据第 <code>2</code> 步中得到的全局变量 <code>classNameList</code> 中的类通过反射进行初始化（需要注意的是只会初始化加了指定注解的类）并将得到的对应关系存储到全局变量 <code>iocContainerMap</code> 中（即传说中的 <code>IOC</code> 容器），其中 <code>key</code> 值为注解中的 <code>value</code> 属性，如 <code>value</code> 属性为空，则默认取首字母小写的类名作为 <code>key</code> 值进行存储（对应方法：<code>doInitializedClass</code>）。</p>\n<p>（4）这一步比较关键，需要对 <code>IOC</code> 容器中的所有类的属性进行赋值并且需要对 <code>Controller</code> 中的请求路径进行映射存储，为了确保最后能顺利调用 <code>Controller</code> 中的方法，还需要将方法的参数进行存储 。对属性进行映射时只会对加了注解的属性进行映射，映射时会从 <code>IOC</code> 容器中取出第 <code>3</code> 步中已经初始化的实例对象进行赋值，最后将请求路径和 <code>Controller</code> 中方法的映射关系存入变量 <code>handlerMappingMap</code>，<code>key</code> 值为请求路径，<code>value</code> 为方法的相关信息 （对应方法：<code>doDependencyInjection</code>）。</p>\n<ul><li> <p>6、存储请求路径和方法的映射关系时，需要用到 <code>HandlerMapping</code> 类来进行存储：</p> </li></ul>\n<pre><code>package com.lonely.wolf.mini.spring.v1;\n\nimport java.lang.reflect.Method;\nimport java.util.Map;\n\n//省略了getter/setter方法\npublic class HandlerMapping {\n    private String requestUrl;\n    private Object target;//保存方法对应的实例\n    private Method method;//保存映射的方法\n    private Map&lt;Integer,String&gt; methodParams;//记录方法参数\n}\n</code></pre>\n<ul><li> <p>7、初始化完成之后，因为拦截了 <code>/*</code> ，所以调用任意接口都会进入 <code>MyDispatcherServlet</code> ，而且最终都会执行方法 <code>doDispatch</code>，执行这个方法时会拿到请求的路径，然后和全局变量 <code>handlerMappingMap</code> 进行匹配，匹配不上则返回 <code>404</code>，匹配的上则取出必要的参数进行赋值，最后通过反射调用到 <code>Controller</code> 中的相关方法。</p> </li><li> <p>8、新建一个 <code>HelloController</code> 和 <code>HelloService</code> 来进行测试：</p> </li></ul>\n<pre><code>package com.lonely.wolf.mini.spring.controller;\n\nimport com.lonely.wolf.mini.spring.annotation.WolfAutowired;\nimport com.lonely.wolf.mini.spring.annotation.WolfController;\nimport com.lonely.wolf.mini.spring.annotation.WolfGetMapping;\nimport com.lonely.wolf.mini.spring.annotation.WolfRequestParam;\nimport com.lonely.wolf.mini.spring.service.HelloService;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WolfController\npublic class HelloController {\n    @WolfAutowired\n    private HelloService helloService;\n\n    @WolfGetMapping(\"/hello\")\n    public void query(HttpServletRequest request,HttpServletResponse response, @WolfRequestParam(\"name\") String name) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        response.getWriter().write(\"Hello：\" + name);\n    }\n}\npackage com.lonely.wolf.mini.spring.service;\n\nimport com.lonely.wolf.mini.spring.annotation.WolfService;\n\n@WolfService(value = \"hello_service\")//为了演示能否正常取value属性\npublic class HelloService {\n}\n</code></pre>\n<ul><li> <p>9、输入测试路径：<code>http://localhost:8080hello?name=双子孤狼</code>， 进行测试发现可以正常输出：<code>Hello：双子孤狼</code>。</p> </li></ul>\n<p>上面这个例子只是一个简单的演示，通过这个例子只是希望在没有任何框架的情况下，我们也能知道如何完成一个简单的应用开发。例子中很多细节都没有进行处理，仅仅只是为了体验一下 <code>Spring</code> 的核心思想，并了解 <code>Spring</code> 到底帮助我们做了什么，实际上 <code>Spring</code> 能帮我们做的事情远比这个例子中多得多，<code>Spring</code> 体系庞大，设计优雅，经过了多年的迭代优化，是一款非常值得研究的框架。</p>\n<h2>总结</h2>\n<p>本文从介绍 <code>Spring</code> 核心功能开始入手，从如何利用 <code>Spring</code> 完成一个应用开发，讲述到假如没有 <code>Spring</code> 我们该如何基于 <code>Servlet</code> 进行开发，最后再通过一个简单的例子体验了 <code>Spring</code> 的核心思想。</p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 13:14:43", "summary": "前言随着的崛起以及其功能的完善，现在可能绝大部分项目的开发都是使用全家桶来进行开发，也确实和其名字一样，是开发者的春天，解放了程序员的双手，而等到出来之后配置文件大大减少，更是进一步解放了程序员的双手"}