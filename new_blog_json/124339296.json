{"blogid": "124339296", "writerAge": "码龄3年", "writerBlogNum": "6", "writerCollect": "43", "writerComment": "46", "writerFan": "23", "writerGrade": "2级", "writerIntegral": "155", "writerName": "小钱999", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124339296.jpg", "writerRankTotal": "114099", "writerRankWeekly": "694556", "writerThumb": "37", "writerVisitNum": "7334", "blog_read_count": "4519", "blog_time": "于 2022-04-22 12:07:11 发布", "blog_title": "实现JS深浅拷贝的五种方式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_1\"></a>一、堆栈、基本数据类型、引用数据类型</h3>\n<p>在了解深浅拷贝之前，我们需得对堆栈、基本数据类型、引用数据类型有基本的了解</p>\n<p>基本数据类型：number、string、boolean、null、undefined<br/> 引用数据类型：object、function、array</p>\n<p>栈内存是保存大小固定的数据，即保存基本数据类型。堆保存的大小不固定，可保存引用数据</p>\n<h3><a id=\"_9\"></a>二、深浅拷贝理解</h3>\n<p>浅拷贝：拷贝基本数据类型时，不受任何影响，当拷贝引用类型时，源对象也会被修改。</p>\n<p>深拷贝：深拷贝就是完完全全拷贝一份新的对象，它会在内存的堆区域重新开辟空间，修改拷贝对象就不会影响到源对象</p>\n<p>即深浅拷贝是针对于<code>引用数据类型</code></p>\n<p>比如下面我们常见的浅拷贝代码，源对象被修改往往不是我们需要的</p>\n<pre><code class=\"prism language-·\">let a = {\n   name : '张三',\n    age : '18'\n}\nlet b = a;\nb.name = '李四';\nconsole.log(a);\nconsole.log(b);\n\n</code></pre>\n<p>结果可见源数据发生了改变</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8ba13aa041c6446b9546b9ee3553d19a.png\"/></p>\n<h3><a id=\"_35\"></a>三、实现深拷贝的三种方式</h3>\n<h4><a id=\"1es6_36\"></a>1、es6的展开语法</h4>\n<pre><code class=\"prism language--\">let a = {\n   name : '张三',\n    age : '18'\n}\nlet b = {...a};\nb.name = '李四';\nconsole.log('a：',a);\nconsole.log('b：',b);\n</code></pre>\n<p>代码运行：<code>源数据不会发生改变</code></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5ab65018a40342f69fac68e378fb2325.png\"/></p>\n<h4><a id=\"2JSONparseJSONstringify_51\"></a>2、JSON.parse(JSON.stringify(待拷贝对象))</h4>\n<p>但此拷贝的<code>缺点</code>,即<strong>没法拷贝内部函数</strong></p>\n<pre><code class=\"prism language--\">let a = {\n    name : '张三',\n    age : '18',\n    like(){\n        console.log('喜欢唱歌、滑冰');\n    }\n}\nlet b =JSON.parse( JSON.stringify(a) );\nb.name = '李四';\nconsole.log('a：',a);\nconsole.log('b：',b);\n</code></pre>\n<p>结果：在b对象中<strong>未出现like函数</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f289c823610746efb2a159c3afb4efed.png\"/></p>\n<h4><a id=\"3JSArraysliceconcat_71\"></a>3、JS中拷贝Array的slice和concat方法【针对数组】</h4>\n<pre><code class=\"prism language--\">let origin = [1, 2, 3, 4];\nlet new_data = origin.slice()\nnew_data.push(5)\nconsole.log('origin：',origin);\nconsole.log('new_data：',new_data);\n</code></pre>\n<p>代码运行结果：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f208827b372f4836b724578d2d41a894.png\"/><br/> contact操作类似，在这里就不做过多的演示了。主要讲一下<strong>slice和concat方法的弊端，即只能深拷贝第一层，对于多层拷贝无效</strong></p>\n<pre><code class=\"prism language--\">let origin = [[1,1], 2, 3, 4];\nlet new_data = origin.slice()\n new_data[0].push(5)\n console.log('origin：',origin);\n console.log('new_data：',new_data);\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6a0b93b44e6f4d98ab0fb54712d98746.png\"/></p>\n<h4><a id=\"4jQuery__extend__true_94\"></a>4、jQuery 中的 $.extend (添加true就是深拷贝,不添加就是浅拷贝)</h4>\n<pre><code class=\"prism language--\">let origin = [[1,1], 2, 3, 4];\nlet new_data = []\n\n$.extend(true,new_data,origin)\n\nnew_data[0].push(5)\n\nconsole.log('origin：',origin);\nconsole.log('new_data：',new_data);\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0e78b5074df840daaefe9156ee046ab3.png\"/></p>\n<h4><a id=\"5_110\"></a>5、手写递归的方式来实现深拷贝</h4>\n<pre><code class=\"prism language--\">const origin = {\n   name : '张三',\n    age : '18',\n    like(){\n        console.log('喜欢唱歌、滑冰');\n    },\n    a : [[1,1], 2, 3, 4]\n}\n\n\nfunction extend(origin, deep){\n    // deep true  启动深拷贝\n    // false  浅拷贝\n    let obj = {}\n    // 数组对象\n    if(origin instanceof Array){\n        // true 数组  obj 就得是数组\n        obj = []\n    }\n    for(let key in origin){\n        let value = origin[key]\n        // 确定value是不是引用型，前提是deep 是true\n        obj[key] = (!!deep &amp;&amp; typeof value === \"object\" &amp;&amp; value !== null) ? extend(value, deep) : value\n    }\n    return obj\n}\n\n\nconst new_data = extend(origin, true)\n\nnew_data.a[0].push(6666)\nconsole.log(origin)\nconsole.log(new_data)\n</code></pre>\n<p>运行代码：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\108813595a474986b0c944222d010744.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-22 12:07:11", "summary": "一、堆栈、基本数据类型、引用数据类型在了解深浅拷贝之前，我们需得对堆栈、基本数据类型、引用数据类型有基本的了解基本数据类型：、、、、引用数据类型：、、栈内存是保存大小固定的数据，即保存基本数据类型。堆"}