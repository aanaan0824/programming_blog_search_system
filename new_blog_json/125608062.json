{"blogid": "125608062", "writerAge": "码龄5年", "writerBlogNum": "174", "writerCollect": "991", "writerComment": "163", "writerFan": "11339", "writerGrade": "6级", "writerIntegral": "6019", "writerName": "萧然CS", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125608062.jpg", "writerRankTotal": "3730", "writerRankWeekly": "1871", "writerThumb": "382", "writerVisitNum": "501018", "blog_read_count": "953", "blog_time": "已于 2022-07-06 15:24:54 修改", "blog_title": "【Unity】升级版·Excel数据解析，自动创建对应C#类，自动创建ScriptableObject生成类，自动序列化Asset文件", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>实现功能：</h1>\n<ul><li>自动创建继承ScriptableObject的C#数据类，每条Excel的数据，都有对应的字段的Get函数； </li></ul>\n<p><img alt=\"\" height=\"131\" src=\"..\\..\\static\\image\\8b417eefa2344eb6a27500870e43fee6.png\" width=\"295\"/> <img alt=\"\" height=\"230\" src=\"..\\..\\static\\image\\06fde7bb56c34ac6a4e3b4c910032b2b.png\" width=\"302\"/></p>\n<p></p>\n<ul><li>自动创建每个Excel的Asset生成类和生成函数，用于自动生成Asset文件</li></ul>\n<p><img alt=\"\" height=\"377\" src=\"..\\..\\static\\image\\4aa5aaa952a44e5b912075c70f5c8f61.png\" width=\"604\"/></p>\n<ul><li>使用Asset生成类自动序列化Excel数据到Asset文件，可直接在项目运行时加载使用</li></ul>\n<p><img alt=\"\" height=\"148\" src=\"..\\..\\static\\image\\9403ac53f3654648a2c362f173721b32.png\" width=\"456\"/></p>\n<p></p>\n<h1>实现原理：</h1>\n<h3>Excel配置格式：</h3>\n<ul><li>第1行对应特殊标记（可以设置有效性，指定要创建的文件）</li><li>第2行对应中文说明（作为第3行字段的注释）</li><li>第3行对应字段名称（自动创建的字段名称）</li><li>第4行对应字段类型（自动创建的字段类型，与字段名称一一对应）</li><li>第5行及以后对应字段值（所有数据，以行为单位解析、保存数据）</li><li>第一列固定字段为\"id\"，是代码中索引每行数据的Key</li></ul>\n<p><strong>Excel注释操作：</strong></p>\n<ul><li>字段名称行，每个字段单元格内容前加\"//\"，可以注释该字段，不会解析生成到C#类；</li><li>第一列的单元格内容前加\"//\"，可以注释一行数据，不会保存到Asset文件中；</li><li>注释可以用于添加说明行，或剔除指定无用数据。</li></ul>\n<p><img alt=\"\" height=\"142\" src=\"..\\..\\static\\image\\6feba95042e04ccfae134e7ac4de2310.png\" width=\"427\"/></p>\n<h3>生成的C#类格式：</h3>\n<p>行数据类，对应每一行数据：</p>\n<pre><code class=\"language-cs\">[Serializable]\npublic class TestConfigExcelItem : ExcelItemBase\n{\n\t/// &lt;summary&gt;\n\t/// 数据id\n\t/// &lt;/summary&gt;&gt;\n\tpublic int id;\n\t/// &lt;summary&gt;\n\t/// 字符串\n\t/// &lt;/summary&gt;&gt;\n\tpublic string testString;\n\t/// &lt;summary&gt;\n\t/// Int\n\t/// &lt;/summary&gt;&gt;\n\tpublic int testInt;\n\t/// &lt;summary&gt;\n\t/// Float\n\t/// &lt;/summary&gt;&gt;\n\tpublic float testFloat;\n}</code></pre>\n<p>完整数据类，包含所有行的数据、初始化函数、Get函数：</p>\n<pre><code class=\"language-cs\">public class TestConfigExcelData : ExcelDataBase&lt;TestConfigExcelItem&gt;\n{\n\tpublic TestConfigExcelItem[] items;\n\n\tpublic Dictionary&lt;int,TestConfigExcelItem&gt; itemDic = new Dictionary&lt;int,TestConfigExcelItem&gt;();\n\n\tpublic void Init()\n\t{\n\t\titemDic.Clear();\n\t\tif(items != null &amp;&amp; items.Length &gt; 0)\n\t\t{\n\t\t\tfor(int i = 0; i &lt; items.Length; i++)\n\t\t\t{\n\t\t\t\titemDic.Add(items[i].id, items[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic TestConfigExcelItem GetTestConfigExcelItem(int id)\n\t{\n\t\tif(itemDic.ContainsKey(id))\n\t\t\treturn itemDic[id];\n\t\telse\n\t\t\treturn null;\n\t}\n\t#region --- Get Method ---\n\n\tpublic string GetTestString(int id)\n\t{\n\t\tvar item = GetTestConfigExcelItem(id);\n\t\tif(item == null)\n\t\t\treturn default;\n\t\treturn item.testString;\n\t}\n\n\t// ··· ···\n\n\t#endregion\n}</code></pre>\n<h3>目前支持的数据结构：</h3>\n<table cellspacing=\"0\" style=\"width:459.75pt;\"><tbody><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">字符串</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testString</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">字符串数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testStringArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">字符串二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testStringArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Int</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testInt</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Int数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testIntArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Int二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testIntArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Float</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testFloat</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Float数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testFloatArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Float二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testFloatArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Bool</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testBool</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Bool数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testBoolArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Bool二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testBoolArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Enum|枚举名(或枚举值)</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testEnum</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Enum数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testEnumArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Enum二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">不支持</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Vector2</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testVector2</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Vector2数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testVector2Array</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Vector2二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testVector2Array2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Vector3</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testVector3</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Vector3数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testVector3Array</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Vector3二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testVector3Array2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Vector2Int</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testVector2Int</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Vector2Int数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testVector2IntArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Vector2Int二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testVector2IntArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Vector3Int</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testVector3Int</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Vector3Int数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testVector3IntArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Vector3Int二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testVector3IntArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Color</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testColor</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Color数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testColorArray</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Color二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testColorArray2</span></td></tr><tr><td style=\"text-align:left;vertical-align:middle;width:60.75pt;\"><span style=\"color:#000000;\">Color32</span></td><td style=\"text-align:left;vertical-align:middle;width:103.5pt;\"><span style=\"color:#000000;\">testColor32</span></td><td style=\"text-align:left;vertical-align:middle;width:68.25pt;\"><span style=\"color:#000000;\">Color32数组</span></td><td style=\"text-align:left;vertical-align:middle;width:63.75pt;\"><span style=\"color:#000000;\">testColor32Array</span></td><td style=\"text-align:left;vertical-align:middle;width:65.25pt;\"><span style=\"color:#000000;\">Color32二维数组</span></td><td style=\"text-align:left;vertical-align:middle;width:98.25pt;\"><span style=\"color:#000000;\">testColor32Array2</span></td></tr></tbody></table>\n<p>因为Unity不能序列化二维数组，这里改成一维数组+结构体的方式实现：</p>\n<pre><code class=\"language-cs\">[Serializable]\npublic struct StringArr\n{\n    public string[] array;\n}\n\n//二维数组表示方式： StringArr[]</code></pre>\n<h3>Asset数据文件：</h3>\n<p>在自动生成数据的C#类时，会同步生成Asset文件的创建类，用于自动创建Asset文件并序列化数据。</p>\n<p><img alt=\"\" height=\"147\" src=\"..\\..\\static\\image\\21312c3276b54df1a8fdfd9900ab6baa.png\" width=\"634\"/></p>\n<h3>优点：</h3>\n<ul><li>数据修改后只需要重新一键生成即可</li><li>每个Excel对应一个类，使用灵活，对Excel限制少</li><li>自动创建C#类，不需要对每个Excel手动写代码，每条数据对应字段，不需要拆箱装修</li><li>自动创建ScriptableObject的Asset文件，自动序列化数据，方便查看，可以手动修改调整，不需要每次改动都在Excel里操作</li><li>在游戏内直接读取Asset的ScriptableObject子类，不需要额外操作，业务层直接调取数据字段</li></ul>\n<p></p>\n<h1>使用方法：</h1>\n<ul><li>按照标准格式配置Excel</li><li>一键生成C#类、Asset文件</li><li>项目运行时加载Asset资源，调用Init初始化，Get函数获取对应字段值即可</li></ul>\n<p><img alt=\"\" height=\"211\" src=\"..\\..\\static\\image\\e1c0fddb05e54845ad641d4a02022758.png\" width=\"382\"/><img alt=\"\" height=\"208\" src=\"..\\..\\static\\image\\ab04c93656634a7fb9ea600388cd41e3.png\" width=\"282\"/></p>\n<p></p>\n<h1>完整代码：</h1>\n<h3>扩展Unity编辑器窗口：</h3>\n<pre><code class=\"language-cs\">using UnityEngine;\nusing UnityEditor;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class BuildExcelWindow : EditorWindow\n{\n    [MenuItem(\"MyTools/Excel Window\",priority = 100)]\n    public static void ShowReadExcelWindow()\n    {\n        BuildExcelWindow window = GetWindow&lt;BuildExcelWindow&gt;(true);\n        window.Show();\n        window.minSize = new Vector2(475,475);\n    }\n\n    //Excel读取路径，绝对路径，放在Assets同级路径\n    private static string excelReadAbsolutePath;\n\n    //自动生成C#类文件路径，绝对路径\n    private static string scriptSaveAbsolutePath;\n    private static string scriptSaveRelativePath;\n    //自动生成Asset文件路径，相对路径\n    private static string assetSaveRelativePath;\n\n    private List&lt;string&gt; fileNameList = new List&lt;string&gt;();\n    private List&lt;string&gt; filePathList = new List&lt;string&gt;();\n\n    private void Awake()\n    {\n        titleContent.text = \"Excel配置表读取\";\n\n        excelReadAbsolutePath = Application.dataPath.Replace(\"Assets\",\"Excel\");\n        scriptSaveAbsolutePath = Application.dataPath + CheckEditorPath(\"/Script/Excel/AutoCreateCSCode\");\n        scriptSaveRelativePath = CheckEditorPath(\"Assets/Script/Excel/AutoCreateCSCode\");\n        assetSaveRelativePath = CheckEditorPath(\"Assets/AssetData/Excel/AutoCreateAsset\");\n    }\n\n    private void OnEnable()\n    {\n        RefreshExcelFile();\n    }\n\n    private void OnDisable()\n    {\n        fileNameList.Clear();\n        filePathList.Clear();\n    }\n\n    private Vector2 scrollPosition = Vector2.zero;\n    private void OnGUI()\n    {\n        GUILayout.Space(10);\n\n        scrollPosition = GUILayout.BeginScrollView(scrollPosition,GUILayout.Width(position.width),GUILayout.Height(position.height));\n\n        //展示路径\n        GUILayout.BeginHorizontal(GUILayout.Height(20));\n        if(GUILayout.Button(\"Excel读取路径\",GUILayout.Width(100)))\n        {\n            EditorUtility.OpenWithDefaultApp(excelReadAbsolutePath);\n            Debug.Log(excelReadAbsolutePath);\n        }\n        if(GUILayout.Button(\"Script保存路径\",GUILayout.Width(100)))\n        {\n            SelectObject(scriptSaveRelativePath);\n        }\n        if(GUILayout.Button(\"Asset保存路径\",GUILayout.Width(100)))\n        {\n            SelectObject(assetSaveRelativePath);\n        }\n        GUILayout.EndHorizontal();\n\n        GUILayout.Space(5);\n\n        //Excel列表\n\n        GUILayout.Label(\"Excel列表：\");\n        for(int i = 0; i &lt; fileNameList.Count; i++)\n        {\n            GUILayout.BeginHorizontal(\"Box\",GUILayout.Height(40));\n\n            GUILayout.Label($\"{i}:\",\"Titlebar Foldout\",GUILayout.Width(30),GUILayout.Height(35));\n            GUILayout.Box(fileNameList[i],\"MeTransitionBlock\",GUILayout.MinWidth(200),GUILayout.Height(35));\n            GUILayout.Space(10);\n\n            //生成CS代码\n            if(GUILayout.Button(\"Create Script\",GUILayout.Width(100),GUILayout.Height(30)))\n            {\n                ExcelDataReader.ReadOneExcelToCode(filePathList[i],scriptSaveAbsolutePath);\n            }\n            //生成Asset文件\n            if(GUILayout.Button(\"Create Asset\",GUILayout.Width(100),GUILayout.Height(30)))\n            {\n                ExcelDataReader.CreateOneExcelAsset(filePathList[i],assetSaveRelativePath);\n            }\n\n            GUILayout.EndHorizontal();\n            GUILayout.Space(5);\n        }\n        GUILayout.Space(10);\n\n        //一键处理所有Excel\n\n        GUILayout.Label(\"一键操作：\");\n        GUILayout.BeginHorizontal(\"Box\",GUILayout.Height(40));\n\n        GUILayout.Label(\"all\",\"Titlebar Foldout\",GUILayout.Width(30),GUILayout.Height(35));\n        GUILayout.Box(\"All Excel\",\"MeTransitionBlock\",GUILayout.MinWidth(200),GUILayout.Height(35));\n        GUILayout.Space(10);\n\n        if(GUILayout.Button(\"Create Script\",GUILayout.Width(100),GUILayout.Height(30)))\n        {\n            ExcelDataReader.ReadAllExcelToCode(excelReadAbsolutePath,scriptSaveAbsolutePath);\n        }\n        if(GUILayout.Button(\"Create Asset\",GUILayout.Width(100),GUILayout.Height(30)))\n        {\n            ExcelDataReader.CreateAllExcelAsset(excelReadAbsolutePath,assetSaveRelativePath);\n        }\n        GUILayout.EndHorizontal();\n\n        //\n        GUILayout.Space(20);\n        //\n        GUILayout.EndScrollView();\n    }\n\n    //读取指定路径下的Excel文件名\n    private void RefreshExcelFile()\n    {\n        fileNameList.Clear();\n        filePathList.Clear();\n\n        if(!Directory.Exists(excelReadAbsolutePath))\n        {\n            Debug.LogError(\"无效路径：\" + excelReadAbsolutePath);\n            return;\n        }\n        string[] excelFileFullPaths = Directory.GetFiles(excelReadAbsolutePath,\"*.xlsx\");\n\n        if(excelFileFullPaths == null || excelFileFullPaths.Length == 0)\n        {\n            Debug.LogError(excelReadAbsolutePath + \"路径下没有找到Excel文件\");\n            return;\n        }\n\n        filePathList.AddRange(excelFileFullPaths);\n        for(int i = 0; i &lt; filePathList.Count; i++)\n        {\n            fileNameList.Add(Path.GetFileName(filePathList[i]));\n        }\n        Debug.Log(\"找到Excel文件：\" + fileNameList.Count + \"个\");\n    }\n\n    private void SelectObject(string targetPath)\n    {\n        Object targetObj = AssetDatabase.LoadAssetAtPath&lt;Object&gt;(targetPath);\n        EditorGUIUtility.PingObject(targetObj);\n        Selection.activeObject = targetObj;\n        Debug.Log(targetPath);\n    }\n\n    private static string CheckEditorPath(string path)\n    {\n#if UNITY_EDITOR_WIN\n        return path.Replace(\"/\",\"\\\\\");\n#elif UNITY_EDITOR_OSX\n        return path.Replace(\"\\\\\",\"/\");\n#else\n        return path;\n#endif\n    }\n}</code></pre>\n<h3>Excel数据读取类： </h3>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.IO;\nusing Excel;\nusing System.Reflection;\nusing System;\nusing System.Linq;\n\npublic class ExcelDataReader\n{\n    //Excel第1行对应特殊标记\n    private const int specialSignRow = 0;\n    //Excel第2行对应中文说明\n    private const int excelNodeRow = 1;\n    //Excel第3行对应字段名称\n    private const int excelNameRow = 2;\n    //Excel第4行对应字段类型\n    private const int excelTypeRow = 3;\n    //Excel第5行及以后对应字段值\n    private const int excelDataRow = 4;\n\n    //标记注释行/列\n    private const string annotationSign = \"//\";\n\n    #region --- Read Excel ---\n\n    //创建Excel对应的C#类\n    public static void ReadAllExcelToCode(string allExcelPath,string codeSavePath)\n    {\n        //读取所有Excel文件\n        //指定目录中与指定的搜索模式和选项匹配的文件的完整名称（包含路径）的数组；如果未找到任何文件，则为空数组。\n        string[] excelFileFullPaths = Directory.GetFiles(allExcelPath,\"*.xlsx\");\n        if(excelFileFullPaths == null || excelFileFullPaths.Length == 0)\n        {\n            Debug.Log(\"Excel file count == 0\");\n            return;\n        }\n        //遍历所有Excel，创建C#类\n        for(int i = 0; i &lt; excelFileFullPaths.Length; i++)\n        {\n            ReadOneExcelToCode(excelFileFullPaths[i],codeSavePath);\n        }\n    }\n\n    //创建Excel对应的C#类\n    public static void ReadOneExcelToCode(string excelFullPath,string codeSavePath)\n    {\n        //解析Excel获取中间数据\n        ExcelMediumData excelMediumData = CreateClassCodeByExcelPath(excelFullPath);\n        if(excelMediumData == null)\n        {\n            Debug.LogError($\"读取Excel失败 : {excelFullPath}\");\n            return;\n        }\n        if(!excelMediumData.isValid)\n        {\n            Debug.LogError($\"读取Excel失败，Excel标记失效 : {excelMediumData.excelName}\");\n            return;\n        }\n\n        if(!excelMediumData.isCreateCSharp &amp;&amp; !excelMediumData.isCreateAssignment)\n        {\n            Debug.LogError($\"读取Excel失败，Excel不允许生成CSCode : {excelMediumData.excelName}\");\n            return;\n        }\n\n        //根据数据生成C#脚本\n        string classCodeStr = ExcelCodeCreater.CreateCodeStrByExcelData(excelMediumData);\n        if(string.IsNullOrEmpty(classCodeStr))\n        {\n            Debug.LogError($\"解析Excel失败 : {excelMediumData.excelName}\");\n            return;\n        }\n\n        //检查导出路径\n        if(!Directory.Exists(codeSavePath))\n            Directory.CreateDirectory(codeSavePath);\n        //类名\n        string codeFileName = excelMediumData.excelName + \"ExcelData\";\n        //写文件，生成CS类文件\n        StreamWriter sw = new StreamWriter($\"{codeSavePath}/{codeFileName}.cs\");\n        sw.WriteLine(classCodeStr);\n        sw.Close();\n        //\n        UnityEditor.AssetDatabase.SaveAssets();\n        UnityEditor.AssetDatabase.Refresh();\n        //\n        Debug.Log($\"生成Excel的CS成功 : {excelMediumData.excelName}\");\n    }\n\n    #endregion\n\n    #region --- Create Asset ---\n\n    //创建Excel对应的Asset数据文件\n    public static void CreateAllExcelAsset(string allExcelPath,string assetSavePath)\n    {\n        //读取所有Excel文件\n        //指定目录中与指定的搜索模式和选项匹配的文件的完整名称（包含路径）的数组；如果未找到任何文件，则为空数组。\n        string[] excelFileFullPaths = Directory.GetFiles(allExcelPath,\"*.xlsx\");\n        if(excelFileFullPaths == null || excelFileFullPaths.Length == 0)\n        {\n            Debug.Log(\"Excel file count == 0\");\n            return;\n        }\n        //遍历所有Excel，创建Asset\n        for(int i = 0; i &lt; excelFileFullPaths.Length; i++)\n        {\n            CreateOneExcelAsset(excelFileFullPaths[i],assetSavePath);\n        }\n    }\n\n    //创建Excel对应的Asset数据文件\n    public static void CreateOneExcelAsset(string excelFullPath,string assetSavePath)\n    {\n        //解析Excel获取中间数据\n        ExcelMediumData excelMediumData = CreateClassCodeByExcelPath(excelFullPath);\n        if(excelMediumData == null)\n        {\n            Debug.LogError($\"读取Excel失败 : {excelFullPath}\");\n            return;\n        }\n        if(!excelMediumData.isValid)\n        {\n            Debug.LogError($\"读取Excel失败，Excel标记失效 : {excelMediumData.excelName}\");\n            return;\n        }\n\n        if(!excelMediumData.isCreateAsset)\n        {\n            Debug.LogError($\"读取Excel失败，Excel不允许生成Asset : {excelMediumData.excelName}\");\n            return;\n        }\n\n        获取当前程序集\n        //Assembly assembly = Assembly.GetExecutingAssembly();\n        创建类的实例，返回为 object 类型，需要强制类型转换，assembly.CreateInstance(\"类的完全限定名（即包括命名空间）\");\n        //object class0bj = assembly.CreateInstance(excelMediumData.excelName + \"Assignment\",true);\n\n        //必须遍历所有程序集来获得类型。当前在Assembly-CSharp-Editor中，目标类型在Assembly-CSharp中，不同程序将无法获取类型\n        Type assignmentType = null;\n        string assetAssignmentName = excelMediumData.excelName + \"AssetAssignment\";\n        foreach(var asm in AppDomain.CurrentDomain.GetAssemblies())\n        {\n            //查找目标类型\n            Type tempType = asm.GetType(assetAssignmentName);\n            if(tempType != null)\n            {\n                assignmentType = tempType;\n                break;\n            }\n        }\n        if(assignmentType == null)\n        {\n            Debug.LogError($\"创界Asset失败，未找到Asset生成类 : {excelMediumData.excelName}\");\n            return;\n        }\n\n        //反射获取方法\n        MethodInfo methodInfo = assignmentType.GetMethod(\"CreateAsset\");\n        if(methodInfo == null)\n        {\n            if(assignmentType == null)\n            {\n                Debug.LogError($\"创界Asset失败，未找到Asset创建函数 : {excelMediumData.excelName}\");\n                return;\n            }\n        }\n\n        methodInfo.Invoke(null,new object[] { excelMediumData,assetSavePath });\n        //创建Asset文件成功\n        Debug.Log($\"生成Excel的Asset成功 : {excelMediumData.excelName}\");\n    }\n\n    #endregion\n\n    #region --- private ---\n\n    //解析Excel，创建中间数据\n    private static ExcelMediumData CreateClassCodeByExcelPath(string excelFileFullPath)\n    {\n        if(string.IsNullOrEmpty(excelFileFullPath))\n            return null;\n\n        excelFileFullPath = excelFileFullPath.Replace(\"\\\\\",\"/\");\n        //读取Excel\n        FileStream stream = File.Open(excelFileFullPath,FileMode.Open,FileAccess.Read);\n        if(stream == null)\n            return null;\n        //解析Excel\n        IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(stream);\n        //无效Excel\n        if(excelReader == null || !excelReader.IsValid)\n        {\n            Debug.Log(\"Invalid excel ： \" + excelFileFullPath);\n            return null;\n        }\n\n        Debug.Log(\"开始解析Excel : \" + excelReader.Name);\n\n        //记录Excel数据\n        ExcelMediumData excelMediumData = new ExcelMediumData();\n\n        //Excel名字\n        excelMediumData.excelName = excelReader.Name;\n\n        //当前遍历的行\n        int curRowIndex = 0;\n        //开始读取，按行遍历\n        while(excelReader.Read())\n        {\n            //这一行没有读取到数据，视为无效行数据\n            if(excelReader.FieldCount &lt;= 0)\n            {\n                curRowIndex++;\n                continue;\n            }\n            //读取每一行的完整数据\n            string[] datas = new string[excelReader.FieldCount];\n            for(int j = 0; j &lt; excelReader.FieldCount; ++j)\n            {\n                //可以直接读取指定类型数据，不过只支持有限数据类型，这里统一读取string，然后再数据转化\n                //excelReader.GetInt32(j); excelReader.GetFloat(j);\n\n                //读取每一个单元格数据\n                datas[j] = excelReader.GetString(j);\n            }\n\n            switch(curRowIndex)\n            {\n                case specialSignRow:\n                    //特殊标记行\n                    string specialSignStr = datas[0];\n                    if(specialSignStr.Length &gt;= 4)\n                    {\n                        excelMediumData.isValid = specialSignStr[0] == 'T';\n                        excelMediumData.isCreateCSharp = specialSignStr[1] == 'T';\n                        excelMediumData.isCreateAssignment = specialSignStr[2] == 'T';\n                        excelMediumData.isCreateAsset = specialSignStr[3] == 'T';\n                    }\n                    else\n                    {\n                        Debug.LogError(\"未解析到特殊标记\");\n                    }\n                    break;\n                case excelNodeRow:\n                    //数据注释行\n                    excelMediumData.propertyNodeArray = datas;\n                    break;\n                case excelNameRow:\n                    //数据名称行\n                    excelMediumData.propertyNameArray = datas;\n                    //注释列号\n                    for(int i = 0; i &lt; datas.Length; i++)\n                    {\n                        if(string.IsNullOrEmpty(datas[i]) || datas[i].StartsWith(annotationSign))\n                            excelMediumData.annotationColList.Add(i);\n                    }\n                    break;\n                case excelTypeRow:\n                    //数据类型行\n                    excelMediumData.propertyTypeArray = datas;\n                    break;\n                default:\n                    //数据内容行\n                    excelMediumData.allRowItemList.Add(datas);\n                    //注释行号\n                    if(string.IsNullOrEmpty(datas[0]) || datas[0].StartsWith(annotationSign))\n                        excelMediumData.annotationRowList.Add(excelMediumData.allRowItemList.Count - 1);\n                    break;\n            }\n            //\n            curRowIndex++;\n        }\n\n        if(CheckExcelMediumData(ref excelMediumData))\n        {\n            Debug.Log(\"读取Excel成功\");\n            return excelMediumData;\n        }\n        else\n        {\n            Debug.LogError(\"读取Excel失败\");\n            return null;\n        }\n    }\n\n    //校验Excel数据\n    private static bool CheckExcelMediumData(ref ExcelMediumData mediumData)\n    {\n        if(mediumData == null)\n            return false;\n\n        //检查数据有效性\n\n        if(!mediumData.isValid)\n        {\n            Debug.LogError(\"Excel被标记无效\");\n            return false;\n        }\n\n        if(string.IsNullOrEmpty(mediumData.excelName))\n        {\n            Debug.LogError(\"Excel名字为空\");\n            return false;\n        }\n\n        if(mediumData.propertyNameArray == null || mediumData.propertyNameArray.Length == 0)\n        {\n            Debug.LogError(\"未解析到数据名称\");\n            return false;\n        }\n        if(mediumData.propertyTypeArray == null || mediumData.propertyTypeArray.Length == 0)\n        {\n            Debug.LogError(\"未解析到数据类型\");\n            return false;\n        }\n        if(mediumData.propertyNameArray.Length != mediumData.propertyTypeArray.Length)\n        {\n            Debug.LogError(\"数据名称与数据类型数量不一致\");\n            return false;\n        }\n        if(mediumData.allRowItemList.Count == 0)\n        {\n            Debug.LogError(\"数据内容为空\");\n            return false;\n        }\n\n        if(mediumData.propertyNameArray[0] != \"id\")\n        {\n            Debug.LogError(\"第一个字段必须是id字段\");\n            return false;\n        }\n\n        return true;\n    }\n\n    #endregion\n\n}</code></pre>\n<h3>C#代码生成类：</h3>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Text;\nusing System.Linq;\nusing System;\n\npublic class ExcelCodeCreater\n{\n\n    //创建代码，生成数据C#类\n    public static string CreateCodeStrByExcelData(ExcelMediumData excelMediumData)\n    {\n        if(excelMediumData == null)\n            return null;\n\n        //行数据类名\n        string itemClassName = excelMediumData.excelName + \"ExcelItem\";\n        //整体数据类名\n        string dataClassName = excelMediumData.excelName + \"ExcelData\";\n\n        //开始生成类\n        StringBuilder classSource = new StringBuilder();\n        classSource.AppendLine(\"/*Auto Create, Don't Edit !!!*/\");\n        classSource.AppendLine();\n        //添加引用\n        classSource.AppendLine(\"using UnityEngine;\");\n        classSource.AppendLine(\"using System.Collections.Generic;\");\n        classSource.AppendLine(\"using System;\");\n        classSource.AppendLine(\"using System.IO;\");\n        classSource.AppendLine();\n        //生成CSharp数据类\n        if(excelMediumData.isCreateCSharp)\n        {\n            //生成行数据类，记录每行数据\n            classSource.AppendLine(CreateExcelRowItemClass(itemClassName,excelMediumData));\n            classSource.AppendLine();\n            //生成整体数据类，记录整个Excel的所有行数据\n            classSource.AppendLine(CreateExcelAllDataClass(dataClassName,itemClassName,excelMediumData));\n            classSource.AppendLine();\n        }\n        //生成Asset创建类\n        if(excelMediumData.isCreateAssignment)\n        {\n            //生成Asset操作类，用于自动创建Excel对应的Asset文件并赋值\n            classSource.AppendLine(CreateExcelAssetClass(excelMediumData));\n            classSource.AppendLine();\n        }\n        //\n        return classSource.ToString();\n    }\n\n    //----------\n\n    //生成行数据类\n    private static string CreateExcelRowItemClass(string itemClassName,ExcelMediumData excelMediumData)\n    {\n        //生成Excel行数据类\n        StringBuilder classSource = new StringBuilder();\n        //类名\n        classSource.AppendLine(\"[Serializable]\");\n        classSource.AppendLine($\"public class {itemClassName} : ExcelItemBase\");\n        classSource.AppendLine(\"{\");\n        //声明所有字段\n        for(int i = 0; i &lt; excelMediumData.propertyNameArray.Length; i++)\n        {\n            //跳过注释字段\n            if(excelMediumData.annotationColList.Contains(i))\n                continue;\n\n            //添加注释\n            if(i &lt; excelMediumData.propertyNodeArray.Length)\n            {\n                string propertyNode = excelMediumData.propertyNodeArray[i];\n                if(!string.IsNullOrEmpty(propertyNode))\n                {\n                    classSource.AppendLine(\"\\t/// &lt;summary&gt;\");\n                    classSource.AppendLine($\"\\t/// {propertyNode}\");\n                    classSource.AppendLine(\"\\t/// &lt;/summary&gt;&gt;\");\n                }\n            }\n\n            //声明行数据类的字段\n            string propertyName = excelMediumData.propertyNameArray[i];\n            string propertyType = excelMediumData.propertyTypeArray[i];\n            string typeStr = GetPropertyType(propertyType);\n            classSource.AppendLine($\"\\tpublic {typeStr} {propertyName};\");\n        }\n        classSource.AppendLine(\"}\");\n        return classSource.ToString();\n    }\n\n    //----------\n\n    //生成整体数据类\n    private static string CreateExcelAllDataClass(string dataClassName,string itemClassName,ExcelMediumData excelMediumData)\n    {\n        StringBuilder classSource = new StringBuilder();\n        //类名\n        classSource.AppendLine($\"public class {dataClassName} : ExcelDataBase&lt;{itemClassName}&gt;\");\n        classSource.AppendLine(\"{\");\n        //声明字段，行数据类数组\n        classSource.AppendLine($\"\\tpublic {itemClassName}[] items;\");\n        classSource.AppendLine();\n        //id字段类型\n        string idTypeStr = GetPropertyType(excelMediumData.propertyTypeArray[0]);\n        //声明字典\n        classSource.AppendLine($\"\\tpublic Dictionary&lt;{idTypeStr},{itemClassName}&gt; itemDic = new Dictionary&lt;{idTypeStr},{itemClassName}&gt;();\");\n        classSource.AppendLine();\n        //字段初始化方法\n        classSource.AppendLine(\"\\tpublic void Init()\");\n        classSource.AppendLine(\"\\t{\");\n        classSource.AppendLine(\"\\t\\titemDic.Clear();\");\n        classSource.AppendLine(\"\\t\\tif(items != null &amp;&amp; items.Length &gt; 0)\");\n        classSource.AppendLine(\"\\t\\t{\");\n        classSource.AppendLine(\"\\t\\t\\tfor(int i = 0; i &lt; items.Length; i++)\");\n        classSource.AppendLine(\"\\t\\t\\t{\");\n        classSource.AppendLine(\"\\t\\t\\t\\titemDic.Add(items[i].id, items[i]);\");\n        classSource.AppendLine(\"\\t\\t\\t}\");\n        classSource.AppendLine(\"\\t\\t}\");\n        classSource.AppendLine(\"\\t}\");\n        classSource.AppendLine();\n        //字典获取方法\n        classSource.AppendLine($\"\\tpublic {itemClassName} Get{itemClassName}({idTypeStr} id)\");\n        classSource.AppendLine(\"\\t{\");\n        classSource.AppendLine(\"\\t\\tif(itemDic.ContainsKey(id))\");\n        classSource.AppendLine(\"\\t\\t\\treturn itemDic[id];\");\n        classSource.AppendLine(\"\\t\\telse\");\n        classSource.AppendLine(\"\\t\\t\\treturn null;\");\n        classSource.AppendLine(\"\\t}\");\n\n        //每个字段Get函数\n        classSource.AppendLine(\"\\t#region --- Get Method ---\");\n        classSource.AppendLine();\n\n        for(int i = 1; i &lt; excelMediumData.propertyNameArray.Length; i++)\n        {\n            if(excelMediumData.annotationColList.Contains(i))\n                continue;\n            string propertyName = excelMediumData.propertyNameArray[i];\n            string propertyType = excelMediumData.propertyTypeArray[i];\n            //每个字段Get函数\n            classSource.AppendLine(CreateCodePropertyMethod(itemClassName,idTypeStr,propertyName,propertyType));\n        }\n        classSource.AppendLine(\"\\t#endregion\");\n        classSource.AppendLine(\"}\");\n        return classSource.ToString();\n    }\n\n    //生成数据字段对应Get方法\n    private static string CreateCodePropertyMethod(string itemClassName,string idTypeStr,string propertyName,string propertyType)\n    {\n        StringBuilder methodBuilder = new StringBuilder();\n        string itemNameStr = propertyName.FirstOrDefault().ToString().ToUpper() + propertyName.Substring(1);\n        string itemTypeStr = GetPropertyType(propertyType);\n        //字段Get函数\n        methodBuilder.AppendLine($\"\\tpublic {itemTypeStr} Get{itemNameStr}({idTypeStr} id)\");\n        methodBuilder.AppendLine(\"\\t{\");\n        methodBuilder.AppendLine($\"\\t\\tvar item = Get{itemClassName}(id);\");\n        methodBuilder.AppendLine(\"\\t\\tif(item == null)\");\n        methodBuilder.AppendLine(\"\\t\\t\\treturn default;\");\n        methodBuilder.AppendLine($\"\\t\\treturn item.{propertyName};\");\n        methodBuilder.AppendLine(\"\\t}\");\n        //如果是一维数组\n        if(propertyType.Contains(\"[]\"))\n        {\n            //typeStr:int[]或IntArr[] ,返回值:int或IntArr\n            //string itemTypeStr1d = GetPropertyType(propertyType.Replace(\"[]\",\"\"));\n            string itemTypeStr1d = itemTypeStr.Replace(\"[]\",\"\");\n            methodBuilder.AppendLine($\"\\tpublic {itemTypeStr1d} Get{itemNameStr}({idTypeStr} id, int index)\");\n            methodBuilder.AppendLine(\"\\t{\");\n            methodBuilder.AppendLine($\"\\t\\tvar item0 = Get{itemClassName} (id);\");\n            methodBuilder.AppendLine(\"\\t\\tif(item0 == null)\");\n            methodBuilder.AppendLine(\"\\t\\t\\treturn default;\");\n            methodBuilder.AppendLine($\"\\t\\tvar item1 = item0.{propertyName};\");\n            methodBuilder.AppendLine(\"\\t\\tif(item1 == null || index &lt; 0 || index &gt;= item1.Length)\");\n            methodBuilder.AppendLine(\"\\t\\t\\treturn default;\");\n            methodBuilder.AppendLine(\"\\t\\treturn item1[index];\");\n            methodBuilder.AppendLine(\"\\t}\");\n        }\n        //如果是二维数组\n        if(propertyType.Contains(\"[][]\"))\n        {\n            //propertyType:int[][], 返回值:int\n            string itemTypeStr1d = GetPropertyType(propertyType.Replace(\"[][]\",\"\"));\n            methodBuilder.AppendLine($\"\\tpublic {itemTypeStr1d} Get{itemNameStr}({idTypeStr} id, int index1, int index2)\");\n            methodBuilder.AppendLine(\"\\t{\");\n            methodBuilder.AppendLine($\"\\t\\tvar item0 = Get{itemClassName}(id);\");\n            methodBuilder.AppendLine(\"\\t\\tif(item0 == null)\");\n            methodBuilder.AppendLine(\"\\t\\t\\treturn default;\");\n            methodBuilder.AppendLine($\"\\t\\tvar item1 = item0.{propertyName};\");\n            methodBuilder.AppendLine(\"\\t\\tif(item1 == null || index1 &lt; 0 || index1 &gt;= item1.Length)\");\n            methodBuilder.AppendLine(\"\\t\\t\\treturn default;\");\n            methodBuilder.AppendLine(\"\\t\\tvar item2 = item1[index1];\");\n            methodBuilder.AppendLine(\"\\t\\tif(item2.array == null || index2 &lt; 0 || index2 &gt;= item2.array.Length)\");\n            methodBuilder.AppendLine(\"\\t\\t\\treturn default;\");\n            methodBuilder.AppendLine(\"\\t\\treturn item2.array[index2];\");\n            methodBuilder.AppendLine(\"\\t}\");\n        }\n        //\n        return methodBuilder.ToString();\n    }\n\n    //----------\n\n    //生成Asset创建类\n    private static string CreateExcelAssetClass(ExcelMediumData excelMediumData)\n    {\n        string itemClassName = excelMediumData.excelName + \"ExcelItem\";\n        string dataClassName = excelMediumData.excelName + \"ExcelData\";\n        string assignmentClassName = excelMediumData.excelName + \"AssetAssignment\";\n\n        StringBuilder classSource = new StringBuilder();\n        classSource.AppendLine(\"#if UNITY_EDITOR\");\n        //类名\n        classSource.AppendLine($\"public class {assignmentClassName}\");\n        classSource.AppendLine(\"{\");\n        //方法名\n        classSource.AppendLine(\"\\tpublic static bool CreateAsset(ExcelMediumData excelMediumData, string excelAssetPath)\");\n        //方法体，若有需要可加入try/catch\n        classSource.AppendLine(\"\\t{\");\n        classSource.AppendLine(\"\\t\\tvar allRowItemDicList = excelMediumData.GetAllRowItemDicList();\");\n        classSource.AppendLine(\"\\t\\tif(allRowItemDicList == null || allRowItemDicList.Count == 0)\");\n        classSource.AppendLine(\"\\t\\t\\treturn false;\");\n        classSource.AppendLine();\n        classSource.AppendLine(\"\\t\\tint rowCount = allRowItemDicList.Count;\");\n        classSource.AppendLine($\"\\t\\t{dataClassName} excelDataAsset = ScriptableObject.CreateInstance&lt;{dataClassName}&gt;();\");\n        classSource.AppendLine($\"\\t\\texcelDataAsset.items = new {itemClassName}[rowCount];\");\n        classSource.AppendLine();\n        classSource.AppendLine(\"\\t\\tfor(int i = 0; i &lt; rowCount; i++)\");\n        classSource.AppendLine(\"\\t\\t{\");\n        classSource.AppendLine(\"\\t\\t\\tvar itemRowDic = allRowItemDicList[i];\");\n        classSource.AppendLine($\"\\t\\t\\texcelDataAsset.items[i] = new {itemClassName}();\");\n\n        for(int i = 0; i &lt; excelMediumData.propertyNameArray.Length; i++)\n        {\n            if(excelMediumData.annotationColList.Contains(i))\n                continue;\n            string propertyName = excelMediumData.propertyNameArray[i];\n            string propertyType = excelMediumData.propertyTypeArray[i];\n            classSource.Append($\"\\t\\t\\texcelDataAsset.items[i].{propertyName} = \");\n            classSource.Append(AssignmentCodeProperty(propertyName,propertyType));\n            classSource.AppendLine(\";\");\n        }\n        classSource.AppendLine(\"\\t\\t}\");\n        classSource.AppendLine(\"\\t\\tif(!Directory.Exists(excelAssetPath))\");\n        classSource.AppendLine(\"\\t\\t\\tDirectory.CreateDirectory(excelAssetPath);\");\n        classSource.AppendLine($\"\\t\\tstring fullPath = Path.Combine(excelAssetPath,typeof({dataClassName}).Name) + \\\".asset\\\";\");\n        classSource.AppendLine(\"\\t\\tUnityEditor.AssetDatabase.DeleteAsset(fullPath);\");\n        classSource.AppendLine(\"\\t\\tUnityEditor.AssetDatabase.CreateAsset(excelDataAsset,fullPath);\");\n        classSource.AppendLine(\"\\t\\tUnityEditor.AssetDatabase.Refresh();\");\n        classSource.AppendLine(\"\\t\\treturn true;\");\n        classSource.AppendLine(\"\\t}\");\n        //          \n        classSource.AppendLine(\"}\");\n        classSource.AppendLine(\"#endif\");\n        return classSource.ToString();\n    }\n\n    //声明Asset操作类字段\n    private static string AssignmentCodeProperty(string propertyName,string propertyType)\n    {\n        string stringValue = $\"itemRowDic[\\\"{propertyName}\\\"]\";\n        string typeStr = GetPropertyType(propertyType);\n        switch(typeStr)\n        {\n            //字段\n            case \"int\":\n                return \"StringUtility.StringToInt(\" + stringValue + \")\";\n            case \"float\":\n                return \"StringUtility.StringToFloat(\" + stringValue + \")\";\n            case \"bool\":\n                return \"StringUtility.StringToBool(\" + stringValue + \")\";\n            case \"Vector2\":\n                return \"StringUtility.StringToVector2(\" + stringValue + \")\";\n            case \"Vector3\":\n                return \"StringUtility.StringToVector3(\" + stringValue + \")\";\n            case \"Vector2Int\":\n                return \"StringUtility.StringToVector2Int(\" + stringValue + \")\";\n            case \"Vector3Int\":\n                return \"StringUtility.StringToVector3Int(\" + stringValue + \")\";\n            case \"Color\":\n                return \"StringUtility.StringToColor(\" + stringValue + \")\";\n            case \"Color32\":\n                return \"StringUtility.StringToColor32(\" + stringValue + \")\";\n            case \"string\":\n                return stringValue;\n            //一维\n            case \"int[]\":\n                return \"StringUtility.StringToIntArray(\" + stringValue + \")\";\n            case \"float[]\":\n                return \"StringUtility.StringToFloatArray(\" + stringValue + \")\";\n            case \"bool[]\":\n                return \"StringUtility.StringToBoolArray(\" + stringValue + \")\";\n            case \"Vector2[]\":\n                return \"StringUtility.StringToVector2Array(\" + stringValue + \")\";\n            case \"Vector3[]\":\n                return \"StringUtility.StringToVector3Array(\" + stringValue + \")\";\n            case \"Vector2Int[]\":\n                return \"StringUtility.StringToVector2IntArray(\" + stringValue + \")\";\n            case \"Vector3Int[]\":\n                return \"StringUtility.StringToVector3IntArray(\" + stringValue + \")\";\n            case \"Color[]\":\n                return \"StringUtility.StringToColorArray(\" + stringValue + \")\";\n            case \"Color32[]\":\n                return \"StringUtility.StringToColor32Array(\" + stringValue + \")\";\n            case \"string[]\":\n                return \"StringUtility.StringToStringArray(\" + stringValue + \")\";\n            //二维\n            case \"IntArr[]\":\n                return \"StringUtility.StringToIntArray2D(\" + stringValue + \")\";\n            case \"FloatArr[]\":\n                return \"StringUtility.StringToFloatArray2D(\" + stringValue + \")\";\n            case \"BoolArr[]\":\n                return \"StringUtility.StringToBoolArray2D(\" + stringValue + \")\";\n            case \"Vector2Arr[]\":\n                return \"StringUtility.StringToVector2Array2D(\" + stringValue + \")\";\n            case \"Vector3Arr[]\":\n                return \"StringUtility.StringToVector3Array2D(\" + stringValue + \")\";\n            case \"Vector2IntArr[]\":\n                return \"StringUtility.StringToVector2IntArray2D(\" + stringValue + \")\";\n            case \"Vector3IntArr[]\":\n                return \"StringUtility.StringToVector3IntArray2D(\" + stringValue + \")\";\n            case \"ColorArr[]\":\n                return \"StringUtility.StringToColorArray2D(\" + stringValue + \")\";\n            case \"Color32Arr[]\":\n                return \"StringUtility.StringToColor32Array2D(\" + stringValue + \")\";\n            case \"StringArr[]\":\n                return \"StringUtility.StringToStringArray2D(\" + stringValue + \")\";\n            default:\n                //枚举\n                if(propertyType.StartsWith(\"enum\"))\n                {\n                    string enumType = propertyType.Split('|').FirstOrDefault();\n                    string enumName = propertyType.Split('|').LastOrDefault();\n                    if(enumType == \"enum\")\n                        return \"StringUtility.StringToEnum&lt;\" + enumName + \"&gt;(\" + stringValue + \")\";\n                    else if(enumType == \"enum[]\")\n                        return \"StringUtility.StringToEnumArray&lt;\" + enumName + \"&gt;(\" + stringValue + \")\";\n                    else if(enumType == \"enum[][]\")\n                        return \"StringUtility.StringToEnumArray2D&lt;\" + enumName + \"&gt;(\" + stringValue + \")\";\n                }\n                return stringValue;\n        }\n    }\n\n    //判断字段类型\n    private static string GetPropertyType(string propertyType)\n    {\n        string lowerType = propertyType.ToLower();\n        switch(lowerType)\n        {\n            case \"int\":\n                return \"int\";\n            case \"int[]\":\n                return \"int[]\";\n            case \"int[][]\":\n                return \"IntArr[]\";\n            case \"float\":\n                return \"float\";\n            case \"float[]\":\n                return \"float[]\";\n            case \"float[][]\":\n                return \"FloatArr[]\";\n            case \"bool\":\n                return \"bool\";\n            case \"bool[]\":\n                return \"bool[]\";\n            case \"bool[][]\":\n                return \"BoolArr[]\";\n            case \"string\":\n                return \"string\";\n            case \"string[]\":\n                return \"string[]\";\n            case \"string[][]\":\n                return \"StringArr[]\";\n\n            case \"vector2\":\n                return \"Vector2\";\n            case \"vector2[]\":\n                return \"Vector2[]\";\n            case \"vector2[][]\":\n                return \"Vector2Arr[]\";\n            case \"vector2int\":\n                return \"Vector2Int\";\n            case \"vector2int[]\":\n                return \"Vector2Int[]\";\n            case \"vector2int[][]\":\n                return \"Vector2IntArr[]\";\n\n            case \"vector3\":\n                return \"Vector3\";\n            case \"vector3[]\":\n                return \"Vector3[]\";\n            case \"vector3[][]\":\n                return \"Vector3Arr[]\";\n            case \"vector3int\":\n                return \"Vector3Int\";\n            case \"vector3int[]\":\n                return \"Vector3Int[]\";\n            case \"vector3int[][]\":\n                return \"Vector3IntArr[]\";\n\n            case \"color\":\n                return \"Color\";\n            case \"color[]\":\n                return \"Color[]\";\n            case \"color[][]\":\n                return \"ColorArr[]\";\n            case \"color32\":\n                return \"Color32\";\n            case \"color32[]\":\n                return \"Color32[]\";\n            case \"color32[][]\":\n                return \"Color32Arr[]\";\n\n            default:\n                if(propertyType.StartsWith(\"enum\"))\n                {\n                    string enumType = propertyType.Split('|').FirstOrDefault();\n                    string enumName = propertyType.Split('|').LastOrDefault();\n                    switch(enumType)\n                    {\n                        case \"enum\":\n                            return enumName;\n                        case \"enum[]\":\n                            return $\"{enumName}[]\";\n                        case \"enum[][]\":\n                            return $\"EnumArr&lt;{enumName}&gt;[]\";\n                        default:\n                            break;\n                    }\n                }\n                return \"string\";\n        }\n    }\n\n}\n</code></pre>\n<h3> Excel数据中间类：</h3>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n//Excel中间数据\npublic class ExcelMediumData\n{\n    //Excel名字\n    public string excelName;\n\n    //Excel是否有效\n    public bool isValid = false;\n    //是否生成CSharp数据类\n    public bool isCreateCSharp = false;\n    //是否生成Asset创建类\n    public bool isCreateAssignment = false;\n    //是否生成Asset文件\n    public bool isCreateAsset = false;\n\n    //数据注释\n    public string[] propertyNodeArray = null;\n    //数据名称\n    public string[] propertyNameArray = null;\n    //数据类型\n    public string[] propertyTypeArray = null;\n    //List&lt;每行数据内容&gt;\n    public List&lt;string[]&gt; allRowItemList = new List&lt;string[]&gt;();\n\n    //注释行号\n    public List&lt;int&gt; annotationRowList = new List&lt;int&gt;();\n    //注释列号\n    public List&lt;int&gt; annotationColList = new List&lt;int&gt;();\n\n    //List&lt;每行数据&gt;，List&lt;Dictionary&lt;单元格字段名称, 单元格字段值&gt;&gt;\n    public List&lt;Dictionary&lt;string,string&gt;&gt; GetAllRowItemDicList()\n    {\n        if(propertyNameArray == null || propertyNameArray.Length == 0)\n            return null;\n        if(allRowItemList.Count == 0)\n            return null;\n\n        List&lt;Dictionary&lt;string,string&gt;&gt; allRowItemDicList = new List&lt;Dictionary&lt;string,string&gt;&gt;(allRowItemList.Count);\n\n        for(int i = 0; i &lt; allRowItemList.Count; i++)\n        {\n            string[] rowArray = allRowItemList[i];\n            //跳过空数据\n            if(rowArray == null || rowArray.Length == 0)\n                continue;\n            //跳过注释数据\n            if(annotationRowList.Contains(i))\n                continue;\n\n            //每行数据，对应字段名称和字段值\n            Dictionary&lt;string,string&gt; rowDic = new Dictionary&lt;string,string&gt;();\n            for(int j = 0; j &lt; propertyNameArray.Length; j++)\n            {\n                //跳过注释字段\n                if(annotationColList.Contains(j))\n                    continue;\n\n                string propertyName = propertyNameArray[j];\n                string propertyValue = j &lt; rowArray.Length ? rowArray[j] : null;\n                rowDic[propertyName] = propertyValue;\n            }\n            allRowItemDicList.Add(rowDic);\n        }\n        return allRowItemDicList;\n    }\n\n}\n</code></pre>\n<h3>Excel数据基类、扩展类：</h3>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Linq;\nusing System;\n\npublic class ExcelDataBase&lt;T&gt; : ScriptableObject where T : ExcelItemBase\n{\n\n}\n\npublic class ExcelItemBase\n{\n\n}\n\n\n[Serializable]\npublic struct StringArr\n{\n    public string[] array;\n}\n[Serializable]\npublic struct IntArr\n{\n    public int[] array;\n}\n[Serializable]\npublic struct FloatArr\n{\n    public float[] array;\n}\n[Serializable]\npublic struct BoolArr\n{\n    public bool[] array;\n}\n\n[Serializable]\npublic struct Vector2Arr\n{\n    public Vector2[] array;\n}\n[Serializable]\npublic struct Vector3Arr\n{\n    public Vector3[] array;\n}\n[Serializable]\npublic struct Vector2IntArr\n{\n    public Vector2Int[] array;\n}\n[Serializable]\npublic struct Vector3IntArr\n{\n    public Vector3Int[] array;\n}\n[Serializable]\npublic struct ColorArr\n{\n    public Color[] array;\n}\n[Serializable]\npublic struct Color32Arr\n{\n    public Color32[] array;\n}\n\n不支持泛型枚举序列化\n//[Serializable]\n//public struct EnumArr&lt;T&gt; where T : Enum\n//{\n//    public T[] array;\n//}\n\n</code></pre>\n<h3>字符串工具类：</h3>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Text.RegularExpressions;\nusing System;\nusing System.Text;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\npublic static class StringUtility\n{\n\n    #region --- AddColor ---\n\n    public static string AddColor(object obj,Color color)\n    {\n        return AddColor(obj,color);\n    }\n    public static string AddColor(this string str,Color color)\n    {\n        //把颜色转换为16进制字符串，添加到富文本\n        return string.Format(\"&lt;color=#{0}&gt;{1}&lt;/color&gt;\",ColorUtility.ToHtmlStringRGBA(color),str);\n    }\n    public static string AddColor(string str1,string str2,Color color)\n    {\n        return AddColor(str1 + str2,color);\n    }\n    public static string AddColor(string str1,string str2,string str3,Color color)\n    {\n        return AddColor(str1 + str2 + str3,color);\n    }\n\n    #endregion\n\n    #region --- string length ---\n\n    /// &lt;summary&gt;\n    /// 化简字符串长度\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"targetStr\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"targetLength\"&gt;目标长度，英文字符==1，中文字符==2&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static string AbbrevStringWithinLength(string targetStr,int targetLength,string abbrevPostfix)\n    {\n        //C#实际统计：一个中文字符长度==1，英文字符长度==1\n        //UI显示要求：一个中文字符长度==2，英文字符长度==1\n\n        //校验参数\n        if(string.IsNullOrEmpty(targetStr) || targetLength &lt;= 0)\n            return targetStr;\n        //字符串长度 * 2 &lt;= 目标长度，即使是全中文也在长度范围内\n        if(targetStr.Length * 2 &lt;= targetLength)\n            return targetStr;\n        //遍历字符\n        char[] chars = targetStr.ToCharArray();\n        int curLen = 0;\n        for(int i = 0; i &lt; chars.Length; i++)\n        {\n            //累加字符串长度\n            if(chars[i] &gt;= 0x4e00 &amp;&amp; chars[i] &lt;= 0x9fbb)\n                curLen += 2;\n            else\n                curLen += 1;\n\n            //如果当前位置累计长度超过目标长度，取0~i-1，即Substring(0,i)\n            if(curLen &gt; targetLength)\n                return targetStr.Substring(0,i) + abbrevPostfix;\n        }\n        return targetStr;\n    }\n\n    #endregion\n\n    #region --- String To Array ---\n\n    //string\n\n    public static byte StringToByte(string valueStr)\n    {\n        byte value;\n        if(byte.TryParse(valueStr,out value))\n            return value;\n        else\n            return 0;\n    }\n\n    public static string[] StringToStringArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        return valueStr.Split(splitSign);\n    }\n\n    public static StringArr[] StringToStringArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        StringArr[] arrArr = new StringArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new StringArr()\n            {\n                array = strArr1[i].Split(splitSign2)\n            };\n\n        }\n        return arrArr;\n    }\n\n    //int\n\n    public static int StringToInt(string valueStr)\n    {\n        int value;\n        if(int.TryParse(valueStr,out value))\n            return value;\n        else\n            return 0;\n    }\n\n    public static int[] StringToIntArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] valueArr = valueStr.Split(splitSign);\n        if(valueArr == null || valueArr.Length == 0)\n            return null;\n\n        int[] intArr = new int[valueArr.Length];\n        for(int i = 0; i &lt; valueArr.Length; i++)\n        {\n            intArr[i] = StringToInt(valueArr[i]);\n        }\n        return intArr;\n    }\n\n    public static IntArr[] StringToIntArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        IntArr[] arrArr = new IntArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new IntArr()\n            {\n                array = StringToIntArray(strArr1[i],splitSign2)\n            };\n\n        }\n        return arrArr;\n    }\n\n    //float\n\n    public static float StringToFloat(string valueStr)\n    {\n        float value;\n        if(float.TryParse(valueStr,out value))\n            return value;\n        else\n            return 0;\n    }\n\n    public static float[] StringToFloatArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] valueArr = valueStr.Split(splitSign);\n        if(valueArr == null || valueArr.Length == 0)\n            return null;\n\n        float[] floatArr = new float[valueArr.Length];\n        for(int i = 0; i &lt; valueArr.Length; i++)\n        {\n            floatArr[i] = StringToFloat(valueArr[i]);\n        }\n        return floatArr;\n    }\n\n    public static FloatArr[] StringToFloatArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        FloatArr[] arrArr = new FloatArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new FloatArr()\n            {\n                array = StringToFloatArray(strArr1[i],splitSign2)\n            };\n\n        }\n        return arrArr;\n    }\n\n    //bool\n\n    public static bool StringToBool(string valueStr)\n    {\n        bool value;\n        if(bool.TryParse(valueStr,out value))\n            return value;\n        else\n            return false;\n    }\n\n    public static bool[] StringToBoolArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] valueArr = valueStr.Split(splitSign);\n        if(valueArr == null || valueArr.Length == 0)\n            return null;\n\n        bool[] boolArr = new bool[valueArr.Length];\n        for(int i = 0; i &lt; valueArr.Length; i++)\n        {\n            boolArr[i] = StringToBool(valueArr[i]);\n        }\n        return boolArr;\n    }\n\n    public static BoolArr[] StringToBoolArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        BoolArr[] arrArr = new BoolArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new BoolArr()\n            {\n                array = StringToBoolArray(strArr1[i],splitSign2)\n            };\n\n        }\n        return arrArr;\n    }\n\n    //enum\n\n    public static T StringToEnum&lt;T&gt;(string valueStr) where T : Enum\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return (T)default;\n\n        //先校验字符串是否为枚举值\n        int intValue;\n        if(int.TryParse(valueStr,out intValue))\n        {\n            if(Enum.IsDefined(typeof(T),intValue))\n                return (T)Enum.ToObject(typeof(T),intValue);\n        }\n        //如果不是枚举值，当做枚举名处理\n        try\n        {\n            T t = (T)Enum.Parse(typeof(T),valueStr);\n            if(Enum.IsDefined(typeof(T),t))\n                return t;\n        }\n        catch(Exception e)\n        {\n            Debug.LogError(e);\n        }\n        Debug.LogError(string.Format(\"解析枚举错误 {0} : {1}\",typeof(T),valueStr));\n        return (T)default;\n    }\n\n    public static T[] StringToEnumArray&lt;T&gt;(string valueStr,char splitSign = '|') where T : Enum\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] valueArr = valueStr.Split(splitSign);\n        if(valueArr == null || valueArr.Length == 0)\n            return null;\n\n        T[] enumArr = new T[valueArr.Length];\n        for(int i = 0; i &lt; valueArr.Length; i++)\n        {\n            enumArr[i] = StringToEnum&lt;T&gt;(valueArr[i]);\n        }\n        return enumArr;\n    }\n\n    不支持泛型枚举序列化\n    //public static EnumArr&lt;T&gt;[] StringToEnumArray2D&lt;T&gt;(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|') where T : Enum\n    //{\n    //    if(string.IsNullOrEmpty(valueStr))\n    //        return null;\n    //    string[] strArr1 = valueStr.Split(splitSign1);\n    //    if(strArr1.Length == 0)\n    //        return null;\n\n    //    EnumArr&lt;T&gt;[] arrArr = new EnumArr&lt;T&gt;[strArr1.Length];\n    //    for(int i = 0; i &lt; strArr1.Length; i++)\n    //    {\n    //        arrArr[i] = new EnumArr&lt;T&gt;()\n    //        {\n    //            array = StringToEnumArray&lt;T&gt;(strArr1[i],splitSign2)\n    //        };\n\n    //    }\n    //    return arrArr;\n    //}\n\n    //vector2\n\n    public static Vector2 StringToVector2(string valueStr,char splitSign = ',')\n    {\n        Vector2 value = Vector2.zero;\n        if(!string.IsNullOrEmpty(valueStr))\n        {\n            string[] stringArray = valueStr.Split(splitSign);\n            if(stringArray != null &amp;&amp; stringArray.Length &gt;= 2)\n            {\n                value.x = StringToFloat(stringArray[0]);\n                value.y = StringToFloat(stringArray[1]);\n                return value;\n            }\n        }\n        Debug.LogWarning(\"String to Vector2 error\");\n        return value;\n    }\n\n    public static Vector2[] StringToVector2Array(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray == null || stringArray.Length == 0)\n            return null;\n\n        Vector2[] vector2s = new Vector2[stringArray.Length];\n        for(int i = 0; i &lt; stringArray.Length; i++)\n        {\n            vector2s[i] = StringToVector2(stringArray[i]);\n        }\n        return vector2s;\n    }\n\n    public static Vector2Arr[] StringToVector2Array2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        Vector2Arr[] arrArr = new Vector2Arr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new Vector2Arr()\n            {\n                array = StringToVector2Array(strArr1[i],splitSign2)\n            };\n        }\n        return arrArr;\n    }\n\n    //vector3\n\n    public static Vector3 StringToVector3(string valueStr,char splitSign = ',')\n    {\n        Vector3 value = Vector3.zero;\n        if(!string.IsNullOrEmpty(valueStr))\n        {\n            string[] stringArray = valueStr.Split(splitSign);\n            if(stringArray.Length &gt;= 3)\n            {\n                value.x = StringToFloat(stringArray[0]);\n                value.y = StringToFloat(stringArray[1]);\n                value.z = StringToFloat(stringArray[2]);\n                return value;\n            }\n        }\n        Debug.LogWarning(\"String to Vector3 error\");\n        return value;\n    }\n\n    public static Vector3[] StringToVector3Array(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray == null || stringArray.Length == 0)\n            return null;\n\n        Vector3[] vector3s = new Vector3[stringArray.Length];\n        for(int i = 0; i &lt; stringArray.Length; i++)\n        {\n            vector3s[i] = StringToVector3(stringArray[i]);\n        }\n        return vector3s;\n    }\n\n    public static Vector3Arr[] StringToVector3Array2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        Vector3Arr[] arrArr = new Vector3Arr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new Vector3Arr()\n            {\n                array = StringToVector3Array(strArr1[i],splitSign2)\n            };\n        }\n        return arrArr;\n    }\n\n    //vector2Int\n\n    public static Vector2Int StringToVector2Int(string valueStr,char splitSign = ',')\n    {\n        Vector2Int value = Vector2Int.zero;\n        if(!string.IsNullOrEmpty(valueStr))\n        {\n            string[] stringArray = valueStr.Split(splitSign);\n            if(stringArray != null &amp;&amp; stringArray.Length &gt;= 2)\n            {\n                value.x = StringToInt(stringArray[0]);\n                value.y = StringToInt(stringArray[1]);\n                return value;\n            }\n        }\n        Debug.LogWarning(\"String to Vector2Int error\");\n        return value;\n    }\n\n    public static Vector2Int[] StringToVector2IntArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray == null || stringArray.Length == 0)\n            return null;\n\n        Vector2Int[] vector2Ints = new Vector2Int[stringArray.Length];\n        for(int i = 0; i &lt; stringArray.Length; i++)\n        {\n            vector2Ints[i] = StringToVector2Int(stringArray[i]);\n        }\n        return vector2Ints;\n    }\n\n    public static Vector2IntArr[] StringToVector2IntArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        Vector2IntArr[] arrArr = new Vector2IntArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new Vector2IntArr()\n            {\n                array = StringToVector2IntArray(strArr1[i],splitSign2)\n            };\n        }\n        return arrArr;\n    }\n\n    //vector3Int\n\n    public static Vector3Int StringToVector3Int(string valueStr,char splitSign = ',')\n    {\n        Vector3Int value = Vector3Int.zero;\n        if(!string.IsNullOrEmpty(valueStr))\n        {\n            string[] stringArray = valueStr.Split(splitSign);\n            if(stringArray.Length &gt;= 3)\n            {\n                value.x = StringToInt(stringArray[0]);\n                value.y = StringToInt(stringArray[1]);\n                value.z = StringToInt(stringArray[2]);\n                return value;\n            }\n        }\n        Debug.LogWarning(\"String to Vector3 error\");\n        return value;\n    }\n\n    public static Vector3Int[] StringToVector3IntArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray == null || stringArray.Length == 0)\n            return null;\n\n        Vector3Int[] vector3Ints = new Vector3Int[stringArray.Length];\n        for(int i = 0; i &lt; stringArray.Length; i++)\n        {\n            vector3Ints[i] = StringToVector3Int(stringArray[i]);\n        }\n        return vector3Ints;\n    }\n\n    public static Vector3IntArr[] StringToVector3IntArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        Vector3IntArr[] arrArr = new Vector3IntArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new Vector3IntArr()\n            {\n                array = StringToVector3IntArray(strArr1[i],splitSign2)\n            };\n        }\n        return arrArr;\n    }\n\n    //color\n\n    public static Color StringToColor(string valueStr,char splitSign = ',')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return Color.white;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray.Length &lt; 3)\n            return Color.white;\n\n        Color color = new Color()\n        {\n            r = StringToFloat(stringArray[0]),\n            g = StringToFloat(stringArray[1]),\n            b = StringToFloat(stringArray[2]),\n            a = stringArray.Length &lt; 4 ? 1 : StringToFloat(stringArray[3])\n        };\n        return color;\n    }\n    public static Color32 StringToColor32(string valueStr,char splitSign = ',')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return Color.white;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray.Length &lt; 3)\n            return Color.white;\n\n        Color32 color = new Color32()\n        {\n            r = StringToByte(stringArray[0]),\n            g = StringToByte(stringArray[1]),\n            b = StringToByte(stringArray[2]),\n            a = stringArray.Length &lt; 4 ? (byte)1 : StringToByte(stringArray[3])\n        };\n        return color;\n    }\n\n    public static Color[] StringToColorArray(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray == null || stringArray.Length == 0)\n            return null;\n\n        Color[] colors = new Color[stringArray.Length];\n        for(int i = 0; i &lt; stringArray.Length; i++)\n        {\n            colors[i] = StringToColor(stringArray[i]);\n        }\n        return colors;\n    }\n\n    public static Color32[] StringToColor32Array(string valueStr,char splitSign = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n\n        string[] stringArray = valueStr.Split(splitSign);\n        if(stringArray == null || stringArray.Length == 0)\n            return null;\n\n        Color32[] colors = new Color32[stringArray.Length];\n        for(int i = 0; i &lt; stringArray.Length; i++)\n        {\n            colors[i] = StringToColor32(stringArray[i]);\n        }\n        return colors;\n    }\n\n    public static ColorArr[] StringToColorArray2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        ColorArr[] arrArr = new ColorArr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new ColorArr()\n            {\n                array = StringToColorArray(strArr1[i],splitSign2)\n            };\n        }\n        return arrArr;\n    }\n    public static Color32Arr[] StringToColor32Array2D(string valueStr,char splitSign1 = '&amp;',char splitSign2 = '|')\n    {\n        if(string.IsNullOrEmpty(valueStr))\n            return null;\n        string[] strArr1 = valueStr.Split(splitSign1);\n        if(strArr1.Length == 0)\n            return null;\n\n        Color32Arr[] arrArr = new Color32Arr[strArr1.Length];\n        for(int i = 0; i &lt; strArr1.Length; i++)\n        {\n            arrArr[i] = new Color32Arr()\n            {\n                array = StringToColor32Array(strArr1[i],splitSign2)\n            };\n        }\n        return arrArr;\n    }\n\n    #endregion\n\n    #region MyRegion\n\n    public static string GetRandomString(int length)\n    {\n        StringBuilder builder = new StringBuilder();\n        string abc = \"abcdefghijklmnopqrstuvwxyzo0123456789QWERTYUIOPASDFGHJKLZXCCVBMN\";\n        for(int i = 0; i &lt; length; i++)\n        {\n            builder.Append(abc[UnityEngine.Random.Range(0,abc.Length - 1)]);\n        }\n        return builder.ToString();\n    }\n\n    public static string Join&lt;T&gt;(T[] arr,string join = \",\")\n    {\n        if(arr == null || arr.Length == 0)\n            return null;\n\n        StringBuilder builder = new StringBuilder();\n        for(int i = 0; i &lt; arr.Length; i++)\n        {\n            builder.Append(arr[i]);\n            if(i &lt; arr.Length - 1)\n                builder.Append(join);\n        }\n        return builder.ToString();\n    }\n\n    /// &lt;summary&gt;\n    /// 中文逗号转英文逗号\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"input\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static string ToDBC(string input)\n    {\n        char[] c = input.ToCharArray();\n        for(int i = 0; i &lt; c.Length; i++)\n        {\n            if(c[i] == 12288)\n            {\n                c[i] = (char)32;\n                continue;\n            }\n            if(c[i] &gt; 65280 &amp;&amp; c[i] &lt; 65375)\n                c[i] = (char)(c[i] - 65248);\n        }\n        return new string(c);\n    }\n\n    /// &lt;summary&gt;\n    /// 字符转 ascii 码 \n    /// &lt;/summary&gt;\n    /// &lt;param name=\"character\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static int Asc(string character)\n    {\n        if(character.Length == 1)\n        {\n            System.Text.ASCIIEncoding asciiEncoding = new System.Text.ASCIIEncoding();\n            int intAsciiCode = (int)asciiEncoding.GetBytes(character)[0];\n            return (intAsciiCode);\n        }\n        Debug.LogError(\"Character is not valid.\");\n        return -1;\n    }\n\n    /// &lt;summary&gt;\n    /// ascii码转字符\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"asciiCode\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static string Chr(int asciiCode)\n    {\n        if(asciiCode &gt;= 0 &amp;&amp; asciiCode &lt;= 255)\n        {\n            System.Text.ASCIIEncoding asciiEncoding = new System.Text.ASCIIEncoding();\n            byte[] byteArray = new byte[] { (byte)asciiCode };\n            string strCharacter = asciiEncoding.GetString(byteArray);\n            return (strCharacter);\n        }\n        Debug.LogError(\"ASCII Code is not valid.\");\n        return string.Empty;\n    }\n\n    /// &lt;summary&gt;\n    /// 过滤掉表情符号\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;The emoji.&lt;/returns&gt;\n    /// &lt;param name=\"str\"&gt;String.&lt;/param&gt;\n    public static string FilterEmoji(string str)\n    {\n        List&lt;string&gt; patten = new List&lt;string&gt;() { @\"\\p{Cs}\",@\"\\p{Co}\",@\"\\p{Cn}\",@\"[\\u2702-\\u27B0]\" };\n        for(int i = 0; i &lt; patten.Count; i++)\n        {\n            str = Regex.Replace(str,patten[i],\"\");//屏蔽emoji   \n        }\n        return str;\n    }\n\n    /// &lt;summary&gt;\n    /// 过滤掉表情符号\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;The emoji.&lt;/returns&gt;\n    /// &lt;param name=\"str\"&gt;String.&lt;/param&gt;\n    public static bool IsFilterEmoji(string str)\n    {\n        bool bEmoji = false;\n        List&lt;string&gt; patten = new List&lt;string&gt;() { @\"\\p{Cs}\",@\"\\p{Co}\",@\"\\p{Cn}\",@\"[\\u2702-\\u27B0]\" };\n        for(int i = 0; i &lt; patten.Count; i++)\n        {\n            bEmoji = Regex.IsMatch(str,patten[i]);\n            if(bEmoji)\n            {\n                break;\n            }\n        }\n        return bEmoji;\n    }\n\n    #endregion\n\n    #region StringObjectDictionaryExtensions\n\n    /// &lt;summary&gt;\n    /// 针对字典中包含以下键值进行结构：mctid0=xxx;mccount0=1,mctid1=kn2,mccount=2。将其前缀去掉，数字后缀变为键，如{后缀,(去掉前后缀的键,值)}，注意后缀可能是空字符串即没有后缀\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"dic\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"prefix\"&gt;前缀，可以是空引用或空字符串，都表示没有前缀。&lt;/param&gt;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static IEnumerable&lt;IGrouping&lt;string,(string, object)&gt;&gt; GetValuesWithoutPrefix(this IReadOnlyDictionary&lt;string,object&gt; dic,string prefix = null)\n    {\n        //prefix ??= string.Empty;\n        prefix = prefix ?? string.Empty;\n\n        var coll = from tmp in dic.Where(c =&gt; c.Key.StartsWith(prefix)) //仅针对指定前缀的键值\n                   let p3 = tmp.Key.Get3Segment(prefix)\n                   group (p3.Item2, tmp.Value) by p3.Item3;\n        return coll;\n    }\n\n    /// &lt;summary&gt;\n    /// 分解字符串为三段，前缀，词根，数字后缀(字符串形式)。\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"str\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"prefix\"&gt;前缀，可以是空引用或空字符串，都表示没有前缀。&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static (string, string, string) Get3Segment(this string str,string prefix = null)\n    {\n        //prefix ??= string.Empty;\n        prefix = prefix ?? string.Empty;\n\n        //最后十进制数字尾串的长度\n        int suffixLen = Enumerable.Reverse(str).TakeWhile(c =&gt; char.IsDigit(c)).Count();\n        //获取十进制数字后缀\n        //string suufix = str[^suffixLen..];     //^suffixLen：倒序下标；suffixLen..：从指定位置开始直到末尾\n        string suufix = str.Substring(str.Length - suffixLen);\n\n        //return (prefix, str[prefix.Length..^suufix.Length], suufix);\n        string middle = str.Substring(prefix.Length,str.Length - prefix.Length - suufix.Length);\n        return (prefix, middle, suufix);\n    }\n\n    #endregion\n\n}\n</code></pre>\n<h1>Demo链接：</h1>\n<p><a class=\"has-card\" href=\"https://download.csdn.net/download/qq_39108767/85913988\" title=\"【Unity】升级版·Excel数据解析，自动创建C#类，自动创建ScriptableObject生成类，自动序列化Asset-Unity3D文档类资源-CSDN下载\"><span class=\"link-card-box\"><span class=\"link-title\">【Unity】升级版·Excel数据解析，自动创建C#类，自动创建ScriptableObject生成类，自动序列化Asset-Unity3D文档类资源-CSDN下载</span><span class=\"link-desc\">Excel数据解析，自动创建对应C#类，自动创建ScriptableObject生成类，自动序列化A更多下载资源、学习资料请访问CSDN下载频道.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://download.csdn.net/download/qq_39108767/85913988</span></span></a></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-06 15:24:54", "summary": "实现功能：自动创建继承的数据类，每条的数据，都有对应的字段的函数；自动创建每个的生成类和生成函数，用于自动生成文件使用生成类自动序列化数据到文件，可直接在项目运行时加载使用实现原理：配置格式：第行对应"}