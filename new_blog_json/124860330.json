{"blogid": "124860330", "writerAge": "码龄4年", "writerBlogNum": "4", "writerCollect": "18", "writerComment": "4", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "45", "writerName": "leonsxd", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124860330.jpg", "writerRankTotal": "163071", "writerRankWeekly": "1067711", "writerThumb": "3", "writerVisitNum": "2881", "blog_read_count": "1571", "blog_time": "已于 2022-05-26 17:28:04 修改", "blog_title": "2021年PHP-Laravel面试题问卷题 答案记录", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"1_PHP_0\"></a>1. PHP的哪些语言特征，在合适的场景可以显著减少程序的内存开销？</h2>\n<ul><li>Generator</li><li>Trait</li><li>Type hint</li><li>SPL</li></ul>\n<p><strong>解析</strong>：</p>\n<p><strong>Generator</strong> 生成器具体详解可以参考：<br/> <a href=\"https://blog.51cto.com/chinalx1/2089327\">https://blog.51cto.com/chinalx1/2089327</a><br/> 如果不考虑用Generator来实现协程，那么<strong>Generator的一个最大的作用就是为含有大量数据的集合（当前这些数据集是规则的，就像range所返回的那些数据）的遍历节省空间</strong>。<br/> <strong>Trait</strong> 详细了解参考<a href=\"https://blog.csdn.net/lemony521/article/details/78322652\">https://blog.csdn.net/lemony521/article/details/78322652</a><br/> 是一种代码复用技术，为PHP的单继承限制提供了一套灵活的代码复用机制。<br/> <strong>Type hint</strong> 类型提示<br/> 从PHP5开始，我们可以使用类型提示来指定定义函数时，函数接收的参数类型。如果在定义函数时，指定了参数的类型，那么当我们调用函数时，如果实参的类型与指定的类型不符，那么PHP会产生一个致命级别的错误(Catchable fatal error)。<br/> <strong>SPL</strong> PHP标准库<br/> SPL，PHP 标准库（Standard PHP Library） ，从 PHP 5.0 起内置的组件和接口，并且从 PHP5.3 已逐渐的成熟。SPL 其实在所有的 PHP5 开发环境中被内置，同时无需任何设置。</p>\n<h2><a id=\"2_PHP_18\"></a>2. 对于PHP的自动加载描述正确的是</h2>\n<ul><li>自动加载函数只支持按Class / Interface / Trait 名加载，不能按 function名加载</li><li>Composer的自动加载是通过 __autoload 函数实现的</li><li>在文件顶部 use 的时候会载入对应的类</li><li>现在大多数类库都遵循PSR0 规范</li></ul>\n<p><strong>解析：</strong></p>\n<p><strong>自动加载</strong>的主要实现方式 __autoload 与 SPL 标准库提供的spl_autoload_register 函数两种，目前主流多是后一种。<br/> 两种方式的详解介绍可以参考:<br/> <a href=\"https://www.jb51.net/article/166979.htm\">https://www.jb51.net/article/166979.htm</a><br/> <a href=\"https://www.jb51.net/article/31279.htm\">https://www.jb51.net/article/31279.htm</a><br/> <strong>spl_autoload_register 函数用法就是装载自定义的加载函数，所以自动加载函数能按function名加载。</strong><br/> <strong>Composer的自动加载是通过 __autoload 函数实现的</strong><br/> <strong>在文件顶部 use 的时候会载入对应的类</strong><br/> 这里并不是，只用在具体调用类时才会加载类，lazy loading的意思。<br/> 可以参考:<br/> <a href=\"https://blog.csdn.net/weixin_39610956/article/details/115148899\">https://blog.csdn.net/weixin_39610956/article/details/115148899</a><br/> <strong>现在大多数类库都遵循PSR0 规范</strong><br/> PSR0实际是对实现自动加载的一种规范标准，PSR4是对PSR0的一些补充，<strong>简单说目前大多项目都会使用autoload自动加载机制，那么遵循PSR0规范也是必然的</strong>。</p>\n<h2><a id=\"3__Trait__39\"></a>3. 对于 Trait 描述正确的是</h2>\n<ul><li>子类中引入的 Trait 里的方法会覆盖父类的方法</li><li>在Trait中不可以调用引用类里的方法</li><li>一个类无法同时引入两个包含相同方法的 Trait</li><li>可以用来减少重复代码</li></ul>\n<p><strong>解析：</strong></p>\n<p>关于Trait 的介绍在第一题中有链接可以阅读学习下。<br/> <strong>子类中引入的 Trait 里的方法会覆盖父类的方法</strong><br/> 这是正确的，Trait的优先级：自身方法&gt;trait的方法&gt;继承的方法<br/> <strong>在Trait中不可以调用引用类里的方法</strong><br/> <strong>这是错误的！</strong><br/> 代码如下：</p>\n<pre><code class=\"prism language-php\"><span class=\"token keyword\">trait</span> <span class=\"token class-name-definition class-name\">HelloWorld</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">function</span> <span class=\"token function-definition function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">echo</span> <span class=\"token string single-quoted-string\">'hello'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">function</span> <span class=\"token function-definition function\">traitDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">echo</span> <span class=\"token string single-quoted-string\">'this trait'</span><span class=\"token punctuation\">;</span>\n        <span class=\"token variable\">$this</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">TestTrait</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">use</span> <span class=\"token package\">HelloWorld</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">function</span> <span class=\"token function-definition function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">echo</span> <span class=\"token string single-quoted-string\">'demo'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token variable\">$obj</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TestTrait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$obj</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">traitDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 会输出 this trait demo</span>\n</code></pre>\n<p><strong>一个类无法同时引入两个包含相同方法的 Trait</strong><br/> <strong>这是错误的！</strong><br/> Trait 可以引入多个, 多个trait中存在同名方法时, 需要指定使用哪个方法，可用 insteadof 指定使用哪个方法替代同名方法或者是 as 取别名<br/> Trait 的使用小细节可以参考:<br/> <a href=\"https://blog.csdn.net/xiantianga6883/article/details/118576345\">https://blog.csdn.net/xiantianga6883/article/details/118576345</a><br/> <strong>可以用来减少重复代码</strong> 这是Trait的主要目的，提供了灵活的代码复用机制。</p>\n<h2><a id=\"4__Composer__83\"></a>4. 下列对 Composer 描述正确的是</h2>\n<ul><li>一般情况下应该把 PHPUnit 包放在 require 段</li><li>composer.json 不仅可以指定依赖的 PHP 库，还能指定依赖的 PHP 扩展</li><li>Library 类型的项目，需要把 composer.lock 文件提交到版本库中</li><li>拿到一个 Project 类型的项目时，需要通过 composer update 来安装对应的依赖包</li></ul>\n<p><strong>解析：</strong></p>\n<p><strong>一般情况下应该把 PHPUnit 包放在 require 段</strong><br/> <strong>这是错误的！</strong></p>\n<blockquote>\n<p>需要运行在应用中或者库中的包都应该被定义在 require (例如： Symfony, Doctrine, Twig, Guzzle, …)中。如果你正在创建一个库， 注意将什么内容定义为 require。因为这个部分的 每个依赖项同时也是使用了该库的应用的依赖。<br/> 开发应用程序(或库)所需的包应该定义在require-dev (例如：PHPUnit, PHP_CodeSniffer, PHPStan)中</p>\n</blockquote>\n<p><strong>composer.json 不仅可以指定依赖的 PHP 库，还能指定依赖的 PHP 扩展</strong><br/> 这是可以的。</p>\n<blockquote>\n<p>“require”: {<!-- --><br/> “php”:“&gt;=7.0.0”,<br/> “ext-mbstring”: “*”,<br/> “ext-pdo_mysql”: “*”,<br/> },</p>\n</blockquote>\n<p><strong>Library 类型的项目，需要把 composer.lock 文件提交到版本库中</strong><br/> <strong>这是错误的！</strong></p>\n<blockquote>\n<p>开发应用程序要提交 composer.lock 文件到 git 版本库中<br/> 开发库要把 composer.lock 文件添加到 .gitignore 文件中</p>\n</blockquote>\n<p><strong>拿到一个 Project 类型的项目时，需要通过 composer update 来安装对应的依赖包</strong><br/> <strong>这是错误的！</strong><br/> 根据这个选项，如果是刚拿到项目时为了安装项目所需的依赖包不推荐使用update，使用install 即可。<br/> update的时候，composer会根据composer.json去拉取符合条件的最新版本的依赖。然后他会把所拉取到的依赖放入vendor目录下，并且把所有拉取的依赖的精确版本号写入composer.lock文件中，等于项目的依赖包都更新了，而如果没有做兼容性测试会使整个项目变得不稳定。<br/> 如果本地有一份composer.lock时，composer install会去读取你的composer.lock而非composer.json，并且以此为标准去下载依赖。否则，同composer update<br/> 关于composer require/ update/ install 的使用区别及场景可以参考：<a href=\"https://blog.csdn.net/wulove52/article/details/78392663\">https://blog.csdn.net/wulove52/article/details/78392663</a></p>\n<h2><a id=\"5__JWT__117\"></a>5. 下列对 JWT 的描述正确的是</h2>\n<ul><li>有两个部分组成，分别是荷载(payload)和校验段</li><li>Token不变的情况下，过期后不可以续期</li><li>可以不设置过期时间</li><li>经常被用于传输加密的数据</li></ul>\n<p><strong>解析：</strong></p>\n<p><strong>有两个部分组成，分别是荷载(payload)和校验段</strong><br/> <strong>这是错误的！</strong></p>\n<blockquote>\n<p>JWT 的数据结构<br/> HEADER.PAYLOAD.SIGNATURE<br/> 中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的。<br/> Header（头部）<br/> Payload（负载）<br/> Signature（签名）</p>\n</blockquote>\n<p><strong>Token不变的情况下，过期后不可以续期<br/> 可以不设置过期时间<br/> 经常被用于传输加密的数据</strong><br/> 这三个选项，作者没有找到具体资料说明正确与否，不过通过网上一些示例资料理解。说下作者的看法读者自行理解下。<br/> 参考<a href=\"https://www.jianshu.com/p/0ac579e1384c\">https://www.jianshu.com/p/0ac579e1384c</a> 可以不设置过期时间生成token。<br/> Token不变的情况下，既然会过期那么一定是有过期时间字段参与生成的，这时续期第二次生成的第三部分Signature会不同，也就<strong>达不到Token不变完成续期，如果参与生成的字段只有sub对象的话，那么是可以的（测试示例使用的HMAC算法）</strong>。</p>\n<blockquote>\n<p>以下是 JSON Web 令牌有用的一些场景：<br/> 授权：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，从而允许用户访问该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小并且能够在不同的域中轻松使用。<br/> 信息交换：JSON Web 令牌是在各方之间安全传输信息的好方法。因为可以对 JWT 进行签名（例如，使用公钥/私钥对），所以您可以确定发件人就是他们所说的那个人。此外，由于使用标头和有效负载计算签名，您还可以验证内容没有被篡改。</p>\n</blockquote>\n<p>可以用于信息交换传输数据，但是JWT建议放置在请求的头信息的Authorization 字段中，但是受限请求头的大小这点需要注意</p>\n<blockquote>\n<p>请注意，如果您通过 HTTP 标头发送 JWT 令牌，则应尽量防止它们变得太大。某些服务器不接受超过 8 KB 的标头。如果您试图在 JWT 令牌中嵌入太多信息，例如通过包含所有用户的权限，您可能需要替代解决方案，例如Auth0 Fine-Grained Authorization。</p>\n</blockquote>\n<p>具体参考链接:<br/> <a href=\"https://www.jb51.net/article/230891.htm\">https://www.jb51.net/article/230891.htm</a><br/> <a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a><br/> <a href=\"https://www.jianshu.com/p/9f94d2c3f625\">https://www.jianshu.com/p/9f94d2c3f625</a></p>\n<h2><a id=\"6__Semantic_Version_155\"></a>6. 如果一个包遵循 Semantic Version，下列哪些版本升级大概率不会出问题：</h2>\n<ul><li>1.0.0 -&gt; 1.0.1</li><li>1.0.0 -&gt; 1.1.0</li><li>1.0.0 -&gt; 1.1.1</li><li>1.0.0 -&gt; 2.0.0</li></ul>\n<p><strong>解析:</strong></p>\n<p><strong>语义化版本管理(Semantic Versioning)</strong> 详细介绍参考:<br/> <a href=\"https://blog.csdn.net/ternence_hsu/article/details/105404660\">https://blog.csdn.net/ternence_hsu/article/details/105404660</a><br/> <strong>1.0.0 -&gt; 1.0.1<br/> 1.0.0 -&gt; 1.1.0<br/> 1.0.0 -&gt; 1.1.1</strong><br/> 修订版本号向下兼容的问题内容修正、次要版本号向下兼容的功能性新增。这两类的升级大概率不会出问题<br/> <strong>1.0.0 -&gt; 2.0.0</strong><br/> 主版本号升级，不兼容的 API 修改。这里相较上面三个版本升级，出问题的概率会大些</p>\n<h2><a id=\"7__RESTful__172\"></a>7. 按照 RESTful 的规范，修改文章的展示隐藏应该使用哪一种路由</h2>\n<ul><li>Post / article/{id}/hidden</li><li>Put /article/{id}</li><li>Patch /article/{id}</li><li>Put / article/{id}/hidden</li></ul>\n<p><strong>解析：</strong></p>\n<p>Restful 风格详细了解参考：<a href=\"https://blog.csdn.net/zhoupenghui168/article/details/122884260\">https://blog.csdn.net/zhoupenghui168/article/details/122884260</a><br/> <strong>Put / article/{id}/hidden</strong><br/> 严格意义来说应该只有这一个选项符合题意，但是 Patch 请求方式代表更新文章的部分属性，也可以设计为修改文章的展示隐藏，但由于游览器兼容问题一般都推荐使用Put。</p>\n<h2><a id=\"8_SQL_185\"></a>8. 通常使用过滤特殊字符的方式来避免SQL注入</h2>\n<ul><li>正确</li><li>错误</li></ul>\n<p><strong>解析:</strong></p>\n<p>正确，防止SQL注入的有效方法之一就是过滤特殊字符。<br/> 参考链接：<a href=\"https://blog.csdn.net/qq_44159028/article/details/114325805\">https://blog.csdn.net/qq_44159028/article/details/114325805</a></p>\n<h2><a id=\"9_PDO__prepare__SQL__194\"></a>9.只要项目中使用 PDO 的 prepare 就能完全避免 SQL 注入</h2>\n<ul><li>正确</li><li>错误</li></ul>\n<p><strong>解析:</strong></p>\n<p>正确，在使用参数化查询的情况下，数据库服务器不会将参数的内容视为 SQL 语句的一部分来进行处理，而是在数据库完成 SQL 语句的编译之后，才套用参数运行。因此就算参数中含有破坏性的指令，也不会被数据库所运行。<br/> 关于sql注入相关知识详细了解参考:<a href=\"https://blog.csdn.net/qq_44159028/article/details/114325805\">https://blog.csdn.net/qq_44159028/article/details/114325805</a></p>\n<h2><a id=\"10CSRF__203\"></a>10.CSRF 攻击是因为没有对用户输入进行转义导致的</h2>\n<ul><li>正确</li><li>错误</li></ul>\n<p><strong>解析:</strong></p>\n<p>错误，这里因为对用户输入没有进行转义可能导致的是XSS攻击，关于CSRF是什么参考:<a href=\"https://blog.csdn.net/weixin_40482816/article/details/114301717\">https://blog.csdn.net/weixin_40482816/article/details/114301717</a></p>\n<h2><a id=\"11__Authentication_Header_API_LocalStorage__Token__CSRF__211\"></a>11. 使用 Authentication Header 认证的API，用 LocalStorage 存储 Token 的项目不可能出现 CSRF 漏洞</h2>\n<ul><li>正确</li><li>错误</li></ul>\n<p><strong>解析:</strong></p>\n<p>作者认为是正确的，参考链接:<br/> <a href=\"https://tech.meituan.com/2018/10/11/fe-security-csrf.html\">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a><br/> 但又不绝对，如果自己本身的站点存在xss漏洞，泄漏了token 那么一样会造成CSRF冒用攻击</p>\n<h2><a id=\"12__XSS__221\"></a>12. 为了避免 XSS 攻击，需要在写入数据库前对其转义，从数据库读取后反转义</h2>\n<ul><li>正确</li><li>错误</li></ul>\n<p><strong>解析:</strong></p>\n<p>作者认为是正确的，不过这是一种粗略的说法，因为XSS攻击分多钟类型转义的工作也可能是前端也可能是前后端共同转义。<br/> 关于XSS详细了解参考:<br/> <a href=\"https://tech.meituan.com/2018/09/27/fe-security.html\">https://tech.meituan.com/2018/09/27/fe-security.html</a></p>\n<h2><a id=\"13__231\"></a>13. 允许来自跨域的请求，可以在哪层面设置</h2>\n<ul><li>浏览器JS</li><li>Nginx</li><li>PHP</li><li>Redis</li></ul>\n<p><strong>解析：</strong></p>\n<p><strong>浏览器JS</strong> 使用JSONP、CORS策略、iframe等操作都可以实现跨域请求(CORS需要后端配合配置)<br/> <strong>Nginx</strong> 直接配置允许跨越域名或者反向代理接口都可以实现跨域请求</p>\n<h2><a id=\"14_OAuth__AccessToken__AccessToken_242\"></a>14. OAuth 的 AccessToken 过期后只能让用户重新发起授权申请来获得新的 AccessToken</h2>\n<ul><li>正确</li><li>错误</li></ul>\n<p><strong>解析：</strong></p>\n<p>错误，可以使用逻辑判断直接重制Token的过期时间，实现续签。但是不够安全，如果Token被窃取可能导致这个Token一直可用，<br/> <strong>使用刷新令牌Refresh Token</strong>：认证通过后，颁发访问令牌和刷新令牌，刷新令牌客户端自己保存，当访问令牌过期时，使用刷新令牌再申请一个新的访问令牌，这样就避免了一些安全问题。</p>\n<h2><a id=\"15__Laravel__251\"></a>15. 下列对 Laravel 的描述正确的是</h2>\n<ul><li>在业务代码中应该通过 env() 函数读取 .env 文件中的值</li><li>路由模型绑定 （Route Model Binding）是中间件实现的</li><li>Laravel 的 Session 使用的是 PHP 原生的 Session</li><li>按关联关系筛选数据可以用 with 或者 whereHas</li></ul>\n<p><strong>解析:</strong></p>\n<p><strong>在业务代码中应该通过 env() 函数读取 .env 文件中的值</strong></p>\n<p>可以这么做，但是不提倡。<br/> env() 函数可以获取.env 环境变量配置。但是官方文档中提倡仅在配置文件中使用env()函数，在业务代码中可以通过 App facade 的 environment 函数获取。<br/> 具体原因可以参考:<br/> <a href=\"https://learnku.com/docs/laravel/9.x/configuration/12201#environment-configuration\">https://learnku.com/docs/laravel/9.x/configuration/12201#environment-configuration</a></p>\n<p><strong>路由模型绑定 （Route Model Binding）是中间件实现的</strong></p>\n<p>这里作者并没有找到确切的结论，但是根据各种文档学习路由模型绑定、中间件时，觉得这是两个东西，路由模型绑定通俗的来说就是把路由跟你的model进行显式或者隐式的绑定，当请求匹配这个路由时会自动解析参数利用model去查询获取数据返回而已。<br/> 关于laravel的路由模型绑定可以参考:<br/> <a href=\"http://laravel.p2hp.com/cndocs/9.x/routing#route-model-binding\">http://laravel.p2hp.com/cndocs/9.x/routing#route-model-binding</a><br/> <a href=\"https://www.cnblogs.com/sgm4231/p/10283374.html\">https://www.cnblogs.com/sgm4231/p/10283374.html</a></p>\n<p>关于中间件引用文档的介绍：</p>\n<blockquote>\n<p>中间件提供了一种方便的机制来检查和过滤进入应用程序的 HTTP 请求。 例如，Laravel 包含一个中间件，用于验证您的应用程序的用户是否经过身份验证。 如果用户未通过身份验证，中间件会将用户重定向到应用程序的登录屏幕。 但是，如果用户通过了身份验证，中间件将允许请求进一步进入应用程序。</p>\n</blockquote>\n<p>常见的中间用法就是在路由解析匹配前去做一些验证操作，如果满足了验证才会进行路由解析逻辑，否则直接禁止请求。<br/> 通过上述的两个东西的介绍，作者认为更像是前后关系而不是上下关系。<strong>至于路由模型绑定是否是中间件实现的暂不做结论</strong></p>\n<p><strong>Laravel 的 Session 使用的是 PHP 原生的 Session</strong><br/> 这是错误的<br/> Laravel 的Session <strong>并没有</strong>使用PHP原生的Session<br/> 作者这里使用了laravel9 在本地启动后，访问welcome页面session情况可以看下图，本地环境7.2已经暂将PHP Session 文件的路径指定到同一目录下方便做对比。另外使用了两个浏览器生成不同的会话查看区别。<br/> 另外如果在laravel中你没有使用 原生的 session_start()函数，是不会生成PHP Session 文件的。<br/> <img alt=\"谷歌浏览器启动一个laravel应用 浏览器存储情况\" src=\"..\\..\\static\\image\\458d6eaec21e4290ba6adc3af6db3eec.png\"/><br/> <img alt=\"本地session文件\" src=\"..\\..\\static\\image\\302845544d1a409384167b1fb39f8778.png\"/><br/> 关于 PHP Session 机制介绍参考：<br/> <a href=\"https://blog.csdn.net/weixin_34873655/article/details/116228070\">https://blog.csdn.net/weixin_34873655/article/details/116228070</a><br/> 关于laravel 的 Session 介绍参考文档：<br/> <a href=\"http://laravel.p2hp.com/cndocs/9.x/session\">http://laravel.p2hp.com/cndocs/9.x/session</a><br/> 关于laravel 的 Session 中间件实现原理可以参考：<br/> <a href=\"http://www.wjhsh.net/cjjjj-p-10606484.html\">http://www.wjhsh.net/cjjjj-p-10606484.html</a></p>\n<p><strong>按关联关系筛选数据可以用 with 或者 whereHas</strong><br/> 这是可以的。<br/> 文档用法介绍:<br/> <a href=\"http://laravel.p2hp.com/cndocs/9.x/eloquent-relationships#scroll-nav__1\">http://laravel.p2hp.com/cndocs/9.x/eloquent-relationships#scroll-nav__1</a><br/> <a href=\"https://www.jb51.net/article/172117.htm\">https://www.jb51.net/article/172117.htm</a></p>\n<h2><a id=\"16__develop__299\"></a>16. 你正在开发中的分支和 develop 分支出现冲突时</h2>\n<ul><li>冲突的出现是团队协作不好，需要组长协调好团队之间的工作</li><li>通常是团队中水平较低的开发人员导致的，需要帮助他们提高Git水平</li><li>出现冲突时需要和相关的开发人员确认解决方案</li><li>在自己的分支上执行 rebase 命令以减少未来的冲突</li><li>目前还没有遇到过</li></ul>\n<p><strong>解析：</strong><br/> 关于git 团队协作问题，作者认为这几项都没有问题。重点应该是考察rebase命令的含义。关于 rebase 的介绍可以参考:<br/> <a href=\"https://blog.csdn.net/weixin_42310154/article/details/119004977\">https://blog.csdn.net/weixin_42310154/article/details/119004977</a></p>\n<h2><a id=\"17_Git_flow_release__310\"></a>17. Git flow 中，release 分支可以从以下哪些分支开出</h2>\n<ul><li>master</li><li>develop</li><li>feature</li><li>bugfix</li><li>release</li></ul>\n<p><strong>解析：</strong></p>\n<p>只能从 develop 分支开出。<br/> 关于 git flow 流程可以参考:<br/> <a href=\"https://blog.csdn.net/fd2025/article/details/124336480\">https://blog.csdn.net/fd2025/article/details/124336480</a><br/> <a href=\"https://blog.csdn.net/m0_57479969/article/details/121564116?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121564116-blog-124336480.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121564116-blog-124336480.pc_relevant_antiscanv2&amp;utm_relevant_index=1\">一文读懂git flow 分支管理</a></p>\n<h2><a id=\"18__PHP__325\"></a>18. 你在 PHP 工程中使用过以下哪些工具？</h2>\n<ul><li>PHPUnit</li><li>PHP-CS-Fixer</li><li>PHPStan</li></ul>\n<p><strong>解析：</strong></p>\n<p><strong>PHPUnit 是一个面向程序员的 PHP 测试框架。它是用于单元测试框架的 xUnit 架构的一个实例。</strong><br/> Github地址:<br/> <a href=\"https://github.com/sebastianbergmann/phpunit\">https://github.com/sebastianbergmann/phpunit</a><br/> 官方文档链接:<br/> <a href=\"https://phpunit.readthedocs.io/zh_CN/latest/installation.html\">https://phpunit.readthedocs.io/zh_CN/latest/installation.html</a><br/> laravel开箱即用 Unit 文档链接:<br/> <a href=\"http://laravel.p2hp.com/cndocs/9.x/testing\">http://laravel.p2hp.com/cndocs/9.x/testing</a></p>\n<p><strong>PHP-CS-Fixer 是个代码格式化工具，格式化的标准是 PSR-1、PSR-2 以及一些 symfony 的标准。</strong><br/> Github地址:<br/> <a href=\"https://github.com/FriendsOfPHP/PHP-CS-Fixer\">https://github.com/FriendsOfPHP/PHP-CS-Fixer</a><br/> 一些安装使用教程及介绍：<br/> <a href=\"https://www.php.cn/php-weizijiaocheng-110741.html\">https://www.php.cn/php-weizijiaocheng-110741.html</a><br/> <a href=\"https://learnku.com/laravel/t/547/use-php-cs-fixer-to-automatically-standardize-your-php-code\">https://learnku.com/laravel/t/547/use-php-cs-fixer-to-automatically-standardize-your-php-code</a><br/> <a href=\"https://www.jianshu.com/p/5377905de931\">https://www.jianshu.com/p/5377905de931</a></p>\n<p><strong>PHPStan PHP 静态代码分析工具</strong><br/> 无需编写测试即可发现代码中的错误<br/> 官网地址:<br/> <a href=\"https://phpstan.org/\">https://phpstan.org/</a><br/> 工具介绍文章:<br/> <a href=\"https://phpstan.org/blog/find-bugs-in-your-code-without-writing-tests\">https://phpstan.org/blog/find-bugs-in-your-code-without-writing-tests</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 1, "time": "2022-05-26 17:28:04", "summary": "的哪些语言特征，在合适的场景可以显著减少程序的内存开销？解析：生成器具体详解可以参考：如果不考虑用来实现协程，那么的一个最大的作用就是为含有大量数据的集合当前这些数据集是规则的，就像所返回的那些数据的"}