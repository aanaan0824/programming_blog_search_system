{"blogid": "126681657", "writerAge": "码龄7年", "writerBlogNum": "46", "writerCollect": "108", "writerComment": "64", "writerFan": "86", "writerGrade": "4级", "writerIntegral": "1244", "writerName": "Zeke Luo", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126681657.jpg", "writerRankTotal": "15732", "writerRankWeekly": "11565", "writerThumb": "83", "writerVisitNum": "231295", "blog_read_count": "499", "blog_time": "已于 2022-09-04 03:00:04 修改", "blog_title": "智能合约--如何实现可升级的智能合约", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一. 什么是智能合约</h1>\n<p>智能合约通俗点说就是写在区块链上面的代码，代码里面编写着严谨完善的规则，一旦某个用户满足了合约里面的规则条件，就会触发里面的代码，执行某个方法。</p>\n<p> </p>\n<h2> 二. 为什么要使智能合约达到可升级</h2>\n<p>智能合约的特点之一就是部署到链上之后不能修改，这一机制使得合约的交互方都可以信任合约。但也带来了一系列的问题，并且如果已部署的合约发现漏洞，也是无法修复的。假如发现了bug，致命性的，必须修复，那如何处理？ 就是使用合约达到可升级优化才能满足需求</p>\n<p> </p>\n<h2>三. 升级合约的机制原理</h2>\n<ol><li>  什么是合约升级</li></ol>\n<p>使已经部署上链的合约做到可优化可更改，例如链上的业务逻辑代码和状态变量达到可增删改的功能.</p>\n<p>   2.  合约升级的实现机制原理</p>\n<p> 目前实现的方式根据存储区分有各种各样的模式，但是都离不开一个最底层的机制，就是使用delegatecall的特性去实现可升级的合约，达到合约可持续优化更改的效果.</p>\n<h3>delegatecall 介绍</h3>\n<h3>目前调用合约的方式主要有三种</h3>\n<ul><li>call</li><li>delegateCall</li><li>staticCall</li></ul>\n<blockquote>\n<p><strong>共同点</strong>：都是去调用执行目标合约地址的方法</p>\n<p><strong>区别</strong>：delegateCall的执行环境和call和staticCall相反，正因为这样所以可利用这种特性实现可升级，在用户层面上无感知。</p>\n</blockquote>\n<p>具体的delegateCall的介绍可以看我另外一篇文章</p>\n<p><a href=\"https://blog.csdn.net/qq_33842966/article/details/125349272?spm=1001.2014.3001.5501\" title=\"Solidity--call、delegatecall 和 callcode 的区别_Zeke Luo的博客-CSDN博客\">Solidity--call、delegatecall 和 callcode 的区别_Zeke Luo的博客-CSDN博客</a></p>\n<p> </p>\n<h2>四. 实现可升级的ERC20合约</h2>\n<p>代码概述</p>\n<ul><li>编写InitializedProxy代理合约，此合约主要作用是转发和存储数据.</li></ul>\n<p>继承openzeppelin的StorageSlotUpgradeable合约，用于插槽工具类。</p>\n<pre><code>// SPDX-License-Identifier: GPL-3.0\nimport \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\";\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n\ncontract InitializedProxy {\n    // address of logic contract\n    // slot bytes32(uint256(keccak256('EIP1967.PROXY.CONFTI.IMPLEMENTATION')) - 1)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x5f62ce3c9aebd463c7a36ab1b244d2bb94f07a2c13889b3b687940ebc467b9b3;\n\n    // ======== Constructor =========\n    constructor(\n        address logic,\n        bytes memory initializationCalldata\n    ) { \n        require(logic != address(0),\"Proxy :: Wrong proxy contract address\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = logic;\n        // Delegatecall into the logic contract, supplying initialization calldata\n        (bool _ok, bytes memory returnData) =\n            logic.delegatecall(initializationCalldata);\n        // Revert if delegatecall to implementation reverts\n        require(_ok, string(returnData));\n    }\n     \n\n    // ======== Fallback =========\n    fallback() external payable {\n        address _impl = StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n\n    // ======== Receive ===\n     receive() external payable {} // solhint-disable-line no-empty-blocks\n\n       function upgradeVersion(address newAddress_) public{ \n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newAddress_;\n    }\n}\n</code></pre>\n<p>1.constructor构造函数拥有初始化数据，并且保存指向的业务逻辑合约</p>\n<p>2.fallback转发接收所有业务逻辑合约的方法，</p>\n<p>3.upgradVersion 用于升级的方法</p>\n<blockquote>\n<p>替换指定插槽的旧逻辑合约地址，更换新的逻辑合约</p>\n</blockquote>\n<ul><li>实现自己的业务逻辑合约（可升级的erc20）</li></ul>\n<pre><code>import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\ncontract logicA  is ERC20Upgradeable{\n    \n    function initialize(string memory tokenName_ ,string memory symbol_) initializer external {\n        __ERC20_init(tokenName_, symbol_);\n    }\n    \n    function mint(address account,uint256 amount)  external  {\n        if(account != address(0) &amp;&amp; amount &gt; 0){\n            _mint(account,amount);\n        }\n    }\n\n    function burn(address account,uint256 amount)  external  {\n        if(account != address(0) &amp;&amp; amount &gt; 0){\n            _burn(account,amount);\n        }\n    } \n  \n}\n</code></pre>\n<ul><li>部署工厂合约</li></ul>\n<p>此合约的主要作用是，创建可升级的逻辑合约，并且管理升级等.</p>\n<pre><code>contract  testtFactory{\n    \n    address public logicProxy;\n    \n    function createProxy(address logiAddress_,string memory tokenName_,string memory symbol_) public {\n            bytes memory _initializationCalldata = abi.encodeWithSignature(\n            \"initialize(string,string)\",\n            tokenName_,\n            symbol_\n        );\n         logicProxy = address (new InitializedProxy(logiAddress_,_initializationCalldata));\n    }\n        \n    function updateLogicProxy(address updataTemplate_) public { \n\n        (bool _ok, bytes memory returnData) = logicProxy.call(abi.encodeWithSignature(\n            \"upgradeVersion(address)\",\n             updataTemplate_\n        ));\n\n        require(_ok, string(returnData));\n    } \n\n}\n</code></pre>\n<blockquote>\n<p>createProxy  : 生成可升级的代理合约</p>\n<p>updateLogicProxy :  升级合约</p>\n</blockquote>\n<ul><li>部署V2合约也就是升级之后的合约</li></ul>\n<pre><code>contract logicA2 is ERC20Upgradeable{\n    \n    function mint(address account,uint256 amount)  external  {\n        require (amount &lt;= 10 ,\"must be &lt;= 10\" );  \n        if(account != address(0) &amp;&amp; amount &gt; 0){\n            _mint(account,amount);\n        }\n    }\n\n    function burn(address account,uint256 amount)  external  {\n        if(account != address(0) &amp;&amp; amount &gt; 0){\n            _burn(account,amount);\n        }\n    } \n  \n}\n</code></pre>\n<blockquote>\n<p>此合约修改了mint的金额必须需要小于等于10，用于升级之后的逻辑检验。</p>\n</blockquote>\n<h2> </h2>\n<h2>五. 以上代码的使用逻辑介绍</h2>\n<p>以remix做案例使用：</p>\n<p>一.部署业务逻辑合约（可升级erc20合约）</p>\n<p><img alt=\"7b2d9257688e4bd99cf252e64456a0cc.png\" src=\"..\\..\\static\\image\\7b2d9257688e4bd99cf252e64456a0cc.png\"/>第二步.部署工厂合约 </p>\n<p><img alt=\"e0b0b45f7eb34fef91b8a16110056722.png\" src=\"..\\..\\static\\image\\e0b0b45f7eb34fef91b8a16110056722.png\"/></p>\n<p>第三步调用工厂合约创建可升级的erc20Token合约</p>\n<p>调用createProxy传入第一步创建的可升级erc20合约地址</p>\n<p>创建成功之后，点击logicProxy查看生成之后的代理地址</p>\n<p><img alt=\"3f1b788ee44b423994f987f59fe162f0.png\" src=\"..\\..\\static\\image\\3f1b788ee44b423994f987f59fe162f0.png\"/></p>\n<p> </p>\n<p>然后调用at方法，并且选择相应的逻辑合约即可调用.（at使用方式和原理可自行查看）</p>\n<p> </p>\n<p>第四步 升级当前的erc20合约</p>\n<p>打开工厂合约调用updateLogicProxy传入新合约的地址，即可完成升级. </p>\n<p>（用户无感升级）</p>\n<p> </p>\n<h3>五. 升级逻辑</h3>\n<p><img alt=\"56c87094b0c44b8cb0c293a7a19deae1.png\" src=\"..\\..\\static\\image\\56c87094b0c44b8cb0c293a7a19deae1.png\"/></p>\n<p> </p>\n<h3><strong>⚠️ 升级注意事项</strong></h3>\n<p>1.插槽的冲突风险</p>\n<p>2.升级之后继承关系</p>\n<hr/>\n<h1>总结</h1>\n<p>合约升级风险会比较大，尽量严谨，并且升级要做到只增不减不修改.</p>\n<p>以上就是今天要讲的内容，本文仅仅简单介绍了delegateCall的升级使用，关于安全方面还是需要自行根据业务去加限制，如有其他不正确的欢迎指出，或者DM</p>\n<p> </p>\n<p> </p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-04 03:00:04", "summary": "一什么是智能合约智能合约通俗点说就是写在区块链上面的代码，代码里面编写着严谨完善的规则，一旦某个用户满足了合约里面的规则条件，就会触发里面的代码，执行某个方法。二为什么要使智能合约达到可升级智能合约的"}