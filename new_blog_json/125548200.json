{"blogid": "125548200", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "1920", "writerComment": "1947", "writerFan": "4628", "writerGrade": "6级", "writerIntegral": "5857", "writerName": "爱吃豆的土豆", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125548200.jpg", "writerRankTotal": "2569", "writerRankWeekly": "69", "writerThumb": "1903", "writerVisitNum": "45224", "blog_read_count": "2418", "blog_time": "于 2022-07-01 21:17:59 发布", "blog_title": "微服务【Ribbon负载均衡&源码解析&饥饿加载】第2章", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<blockquote>\n<ul><li><strong>💂 个人主页:</strong> <a href=\"https://blog.csdn.net/m0_64550837?type=blog\" title=\"爱吃豆的土豆\">爱吃豆的土豆</a></li><li><strong>🤟 版权:</strong> 本文由【爱吃豆的土豆】原创、在CSDN首发、需要转载请联系博主</li><li>💬 如果文章对你有帮助、<strong>欢迎关注、点赞、收藏(一键三连)和订阅专栏哦</strong></li><li> <p>🏆<strong>人必有所执，方能有所成！</strong></p> </li><li> <p>🐋希望大家多多支持😘一起进步呀！</p> </li></ul>\n</blockquote>\n<p id=\"1%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#1%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86\">1，负载均衡原理</a></p>\n<p id=\"1.1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86\">1.1：负载均衡原理</a></p>\n<p id=\"1.2%EF%BC%9A%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%EF%BC%9A%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA\">1.2：源码跟踪</a></p>\n<p id=\"1%EF%BC%89LoadBalancerIntercepor-toc\" style=\"margin-left:80px;\"><a href=\"#1%EF%BC%89LoadBalancerIntercepor\">1）LoadBalancerIntercepor</a></p>\n<p id=\"2%EF%BC%89LoadBalancerClient-toc\" style=\"margin-left:80px;\"><a href=\"#2%EF%BC%89LoadBalancerClient\">2）LoadBalancerClient</a></p>\n<p id=\"3%EF%BC%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5IRule-toc\" style=\"margin-left:80px;\"><a href=\"#3%EF%BC%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5IRule\">3）负载均衡策略IRule</a></p>\n<p id=\"4%EF%BC%89%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:80px;\"><a href=\"#4%EF%BC%89%E6%80%BB%E7%BB%93\">4）总结</a></p>\n<p id=\"1.3%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\">1.3：负载均衡策略</a></p>\n<p id=\"1.3.1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5-toc\" style=\"margin-left:80px;\"><a href=\"#1.3.1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\">1.3.1：负载均衡策略</a></p>\n<p id=\"1.3.2%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5-toc\" style=\"margin-left:80px;\"><a href=\"#1.3.2%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\">1.3.2：自定义负载均衡策略</a></p>\n<p id=\"1.4%EF%BC%9A%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#1.4%EF%BC%9A%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD\">1.4：饥饿加载</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86\">1，负载均衡原理</h1>\n<h2 id=\"1.1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86\">1.1：负载均衡原理</h2>\n<p>SpringCloud底层其实是利用了一个名为<strong><span style=\"background-color:#ffd900;\">Ribbon的组件，来实现负载均衡功能的</span></strong>。</p>\n<p><strong><span style=\"background-color:#ffd900;\">负载均衡流程图：</span></strong></p>\n<p><img alt=\"\" height=\"477\" src=\"..\\..\\static\\image\\8e2018208373448d94da914f26985dff.png\" width=\"1200\"/></p>\n<p>那么我们发出的请求明明是<a href=\"http://userservice/user/1\" title=\"http://userservice/user/1\">http://userservice/user/1</a>，怎么变成了<a href=\"http://localhost:8081\" title=\"http://localhost:8081\">http://localhost:8081</a>的呢？</p>\n<p><span style=\"color:#fe2c24;\">具体Ribbon什么时候拦截下来的请求？什么时候从注册中心拉取下来的？什么时候做的负载均衡呢？</span>下面我们进入<strong><span style=\"color:#fe2c24;\">idea中分析源码</span></strong></p>\n<p><strong>1.2：源码跟踪</strong></p>\n<p><span style=\"color:#4f4f4f;\"><strong>首先看到restTemplate被LoadBalanced进行标记，意思就是说</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>通过</strong><strong>restTemplate发起的请求会被LoadBalanced进行处理拦截</strong></span></p>\n<p><img alt=\"\" height=\"438\" src=\"..\\..\\static\\image\\4b63ff2744864aecba0336fccdf2fd96.png\" width=\"790\"/></p>\n<p><strong><span style=\"color:#fe2c24;\">那么这个拦截的动作在底层中是通过谁进行完成的呢？就是：</span></strong>LoadBalancerInterceptor</p>\n<h3 id=\"1%EF%BC%89LoadBalancerIntercepor\">1）LoadBalancerInterceptor</h3>\n<p>首先在编辑器中Ctrl+Shift+N搜索 <span style=\"color:#fe2c24;\"><strong>LoadBalancerInterceptor</strong></span> 该实现类</p>\n<p><img alt=\"\" height=\"202\" src=\"..\\..\\static\\image\\518c366632574fb2bb7c5c5f1adcae97.png\" width=\"770\"/></p>\n<p> 点进去查看一下源码：<span style=\"color:#fe2c24;\"><strong>该实现类实现了ClientHttpRequestInterceptor接口，那么这个接口是干嘛的呢？</strong></span></p>\n<p><img alt=\"\" height=\"245\" src=\"..\\..\\static\\image\\e72bb1d44883472b978bb363ab7ec9e4.png\" width=\"1007\"/></p>\n<p>  该接口是客户端请求拦截器，那么<span style=\"color:#4f4f4f;\"><strong>restTemplate不就是一个发Http请求的客户端嘛！被拦截</strong></span><img alt=\"\" height=\"763\" src=\"..\\..\\static\\image\\8be6311ccbe64268b3b6a7d1e129fd27.png\" width=\"926\"/></p>\n<p> <span style=\"color:#fe2c24;\"><strong>既然实现类实现了ClientHttpRequestInterceptor接口，也实现了接口中的intercept方法，下面看一下这个方法具体在干嘛！（打个断点演示一下，图片放大更清楚）</strong></span></p>\n<p><img alt=\"\" height=\"275\" src=\"..\\..\\static\\image\\9cc42b59f4334563aba31db84196c052.png\" width=\"1200\"/></p>\n<p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p>\n<p></p>\n<ul><li> <p><code>request.getURI()</code>：<span style=\"color:#fe2c24;\"><strong>获取请求uri</strong></span>，本例中就是http://service-provide/echo/love</p> </li><li> <p><code>originalUri.getHost()</code>：<span style=\"color:#fe2c24;\"><strong>获取uri路径的主机名</strong></span>，其实就是服务id，service-provide</p> </li><li> <p><code>this.loadBalancer.execute()</code>：<span style=\"color:#fe2c24;\"><strong>处理服务id，和用户请求</strong></span>。</p> </li></ul>\n<p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。  </p>\n<h3 id=\"2%EF%BC%89LoadBalancerClient\">2）LoadBalancerClient</h3>\n<p><span style=\"color:#fe2c24;\"><strong>继续跟入execute方法：</strong></span></p>\n<p><img alt=\"\" height=\"429\" src=\"..\\..\\static\\image\\5ff3665b67534e13908bda4b5d25cc94.png\" width=\"933\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 跟入到此接口中：</strong></span></p>\n<p><img alt=\"\" height=\"417\" src=\"..\\..\\static\\image\\2b043c6c29b74486b961e72b6e4f4d47.png\" width=\"690\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 跟入到接口的实现类中：</strong></span></p>\n<p><img alt=\"\" height=\"488\" src=\"..\\..\\static\\image\\a8575bf99ed84e448da7731994205267.png\" width=\"990\"/></p>\n<h2> 总结：</h2>\n<h2><span style=\"color:#fe2c24;\">跟踪到execute方法中，将参数服务Id传递进来交给Load Balancer函数进行处理，</span></h2>\n<h2>返回出：<span style=\"color:#fe2c24;\">动态服务列表负载均衡器。</span></h2>\n<h2>这个负载均衡器是干嘛的？</h2>\n<h2><span style=\"color:#fe2c24;\"><strong>通过服务Id获取到服务注册中心的服务列表，现在这一步已经把服务拉取到了</strong></span>。</h2>\n<p><img alt=\"\" height=\"104\" src=\"..\\..\\static\\image\\159913383f3d42ecae035b280d9f8da4.png\" width=\"445\"/>  </p>\n<h2><strong><span style=\"background-color:#ffd900;\">下一步进行负载均衡</span></strong></h2>\n<h3 id=\"3%EF%BC%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5IRule\">3）负载均衡策略IRule</h3>\n<p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p>\n<p><img alt=\"\" height=\"355\" src=\"..\\..\\static\\image\\ab337ec75325451f8a8d77b3d8befa6f.png\" width=\"1005\"/></p>\n<p> 我们继续跟入：</p>\n<p><img alt=\"\" height=\"409\" src=\"..\\..\\static\\image\\fbde223a2c3941ccbd3226c5b0f654dc.png\" width=\"724\"/></p>\n<p>继续跟踪源码chooseServer方法，发现这么一段代码：  </p>\n<p><img alt=\"\" height=\"464\" src=\"..\\..\\static\\image\\7477859eba2d49b586574366280533cf.png\" width=\"939\"/></p>\n<p> 我们看看这个rule是谁：</p>\n<p><img alt=\"\" height=\"293\" src=\"..\\..\\static\\image\\7e4a0df3a123455881ec7f731cab2659.png\" width=\"853\"/></p>\n<p> 对象是<span style=\"color:#fe2c24;\"><strong>IRule对象</strong></span>，我们知道I是接口，Rule是规则，那么就是<span style=\"color:#fe2c24;\"><strong>规则接口</strong></span>，那接口有实现类，咱们<span style=\"color:#fe2c24;\"><strong>Ctrl+H查看一下继承树</strong></span></p>\n<p><img alt=\"\" height=\"332\" src=\"..\\..\\static\\image\\323b3e85d52748748988e21f828a6229.png\" width=\"695\"/></p>\n<p><img alt=\"\" height=\"369\" src=\"..\\..\\static\\image\\9bf1735177e04333b6c5c75159ddf05a.png\" width=\"848\"/> <span style=\"color:#fe2c24;\"><strong>到这里，整个负载均衡的流程我们就清楚了。</strong></span></p>\n<h3 id=\"4%EF%BC%89%E6%80%BB%E7%BB%93\">4）总结</h3>\n<p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p>\n<p><img alt=\"\" height=\"736\" src=\"..\\..\\static\\image\\36d3977ac83a4530b91143834c0a9aa7.png\" width=\"1200\"/></p>\n<p>基本流程如下：</p>\n<ul><li> <p>拦截我们的RestTemplate请求<a href=\"http://localhost:8071/fangwen/love\" title=\"http://localhost:8071/fangwen/love\">http://localhost:8071/fangwen/love</a></p> </li><li> <p>RibbonLoadBalancerClient会从请求url中获取服务名称</p> </li><li> <p>DynamicServerListLoadBalancer根据user-service到nacos拉取服务列表</p> </li><li> <p>nacos返回列表</p> </li><li> <p>IRule利用内置负载均衡规则，从列表中选择一个，</p> </li><li> <p>RibbonLoadBalancerClient修改请求地址，发起真实请求</p> </li></ul>\n<h2 id=\"1.3%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\">1.3：负载均衡策略</h2>\n<h3 id=\"1.3.1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\">1.3.1：负载均衡策略</h3>\n<p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p>\n<p><img alt=\"\" height=\"416\" src=\"..\\..\\static\\image\\db76c4f17505408fbd93e6ff6643a472.png\" width=\"1144\"/></p>\n<p>不同规则的含义如下：</p>\n<p><img alt=\"\" height=\"448\" src=\"..\\..\\static\\image\\fe639a3f5df2419bb6f0bf5fab0154e7.png\" width=\"1154\"/></p>\n<p>默认的实现就是<span style=\"color:#fe2c24;\"><strong>ZoneAvoidanceRule，是一种轮询方案  </strong></span></p>\n<h3 id=\"1.3.2%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\">1.3.2：自定义负载均衡策略</h3>\n<p>通过定义IRule实现可以修改负载均衡规则，有<strong>两种方式</strong>：</p>\n<ol><li> <p><span style=\"color:#fe2c24;\"><strong>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</strong></span></p> </li></ol>\n<pre><code class=\"language-java\">@Bean\npublic IRule randomRule(){\n    return new RandomRule();\n}</code></pre>\n<p>     2. 配置文件方式：<span style=\"color:#fe2c24;\"><strong>在application.yml文件中，添加新的配置也可以修改规则：</strong></span></p>\n<pre><code>userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </code></pre>\n<blockquote>\n<p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p>\n</blockquote>\n<h2 id=\"1.4%EF%BC%9A%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD\">1.4：饥饿加载</h2>\n<p><strong><span style=\"background-color:#ff9900;\">Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</span></strong></p>\n<p>什么意思呢？（访问监测一下）</p>\n<p>第一次请求：请求耗时如此之长</p>\n<p><img alt=\"\" height=\"586\" src=\"..\\..\\static\\image\\9f277d206b124db6adbf0aa3efca90f9.png\" width=\"1200\"/></p>\n<p> 第二次请求：请求耗时很短</p>\n<p><img alt=\"\" height=\"584\" src=\"..\\..\\static\\image\\7d8ddd9e9d334751b5b69b15af483d13.png\" width=\"1200\"/></p>\n<p><strong><span style=\"background-color:#ffd900;\"> 为什么会有这种变化呢？</span></strong></p>\n<p>当然导致请求耗时过长的因素有很多，在这里最重要的一个因素是<span style=\"background-color:#ffd900;\">Ribbon采用了懒加载。</span></p>\n<p><span style=\"background-color:#ffd900;\">那么何为懒加载？</span></p>\n<p><strong><span style=\"background-color:#ffd900;\">即第一次访问时才会去创建LoadBalanceClient，去服务注册中心拉取服务，导致时间加载过长。</span></strong></p>\n<p><strong><span style=\"background-color:#ffd900;\">为了解决第一次访问才创建LoadBalanceClient导致耗时过长，可以采用饥饿加载。</span></strong></p>\n<p><span style=\"background-color:#ffd900;\">何为饥饿加载？</span></p>\n<p><strong><span style=\"background-color:#ffd900;\">饥饿加载则会在项目启动时进行创建，降低第一次访问的耗时，通过下面配置yml文件开启饥饿加载：</span></strong></p>\n<blockquote>\n<p>ribbon:<br/>   eager-load:<br/>     enabled: true   # 开启饥饿加载<br/>     clients: userservice   # 指定对userservice这个服务饥饿加载</p>\n</blockquote>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-01 21:17:59", "summary": "目录个人主页爱吃豆的土豆爱吃豆的土豆版权本文由爱吃豆的土豆原创、在首发、需要转载请联系博主如果文章对你有帮助、欢迎关注、点赞、收藏一键三连和订阅专栏哦人必有所执，方能有所成！希望大家多多支持一起进步呀"}