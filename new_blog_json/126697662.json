{"blogid": "126697662", "writerAge": "码龄12年", "writerBlogNum": "467", "writerCollect": "183", "writerComment": "43", "writerFan": "152", "writerGrade": "5级", "writerIntegral": "3749", "writerName": "一线码农", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126697662.jpg", "writerRankTotal": "5565", "writerRankWeekly": "7928", "writerThumb": "61", "writerVisitNum": "208109", "blog_read_count": "277", "blog_time": "于 2022-09-05 08:23:12 发布", "blog_title": "如何在 C# 程序中注入恶意 DLL?", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_1\"></a>一：背景</h2>\n<p>前段时间在训练营上课的时候就有朋友提到一个问题，为什么 Windbg 附加到 C# 程序后，程序就处于中断状态了？它到底是如何实现的？ 其实简而言之就是线程的远程注入，这一篇就展开说一下。</p>\n<h3><a id=\"_5\"></a>二：实现原理</h3>\n<h3><a id=\"1__7\"></a>1. 基本思路</h3>\n<p>WinDbg 在附加进程的时候，会注入一个线程到 <code>C# 进程</code> 中，注入成功后，会执行一个 <code>DbgBreakPoint()</code> 函数，其实就是 <code>int 3</code> ，这时候 CPU 就会执行 3 号中断函数，将当前进程的所有线程进行暂停，文字不好理解的话，画一个图大概就是这样。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\c63b5b8c7bd6cee6bd9027864b22c83f.png\"/></p>\n<p>口说无凭，接下来用上一个简单案例演示一下。</p>\n<h3><a id=\"2__16\"></a>2. 案例演示</h3>\n<p>首先写一个简单的 C# 程序，不断的输出时间和标号，代码如下：</p>\n<pre><code class=\"prism language-C#\">\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i &lt; 10000; i++)\n            {\n                Console.WriteLine($\"{DateTime.Now},i={i}\");\n                Thread.Sleep(1000);\n            }\n        }\n    }\n\n</code></pre>\n<p>把程序跑起来后，使用 WinDbg 附加，你可以发现 Command 自动切换到了 <code>8</code> 号线程，通过 k 命令可以看到最上面是一个 int 3 中断，截图如下：</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\83ffd45724c76c4f6c841f68b15c7af0.png\"/></p>\n<p>这里就有一个想法了，既然 WinDbg 可以注入，为何我的程序就注入不得呢？ 既然我的程序可以注入，那就可以做一些我想做的事情。</p>\n<h3><a id=\"3__42\"></a>3. 自定义注入</h3>\n<p>有了自定义注入的想法，接下来的实现步骤大概是这样的。</p>\n<ol><li> <p>注入一个线程到 C# 程序中。</p> </li><li> <p>让程序加载一个 dll 文件。</p> </li><li> <p>在 dll 中做一些我想做的业务逻辑。</p> </li></ol>\n<p>接下来新建一个 C++ 的动态链接库，在 DLLMain 入口函数的 <code>DLL_PROCESS_ATTACH</code> 事件中写一个 printf 函数，如果在 C# 程序中输出来了，就算成功注入了，参考代码如下：</p>\n<pre><code class=\"prism language-C++\">\n#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n\tDWORD  ul_reason_for_call,\n\tLPVOID lpReserved\n)\n{\n\tswitch (ul_reason_for_call)\n\t{\n\tcase DLL_PROCESS_ATTACH:\n\t\tprintf(\" 总部，总部，我已经成功打入内部！ ul_reason_for_call=%d\\n \", ul_reason_for_call);\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\n</code></pre>\n<p>要被加载的 <code>MyInject.dll</code> 已经构建完毕，接下来就用 Win32 API 的 <code>CreateRemoteThread()</code> 实现远程注入，但注入之前需要做三件事情。</p>\n<ol><li> <p>获取 C# 程序的 进程句柄。</p> </li><li> <p>在 C# 进程中申请一块内存空间，存放加载的 path 路径。</p> </li><li> <p>调用 LoadLibraryW 函数在 C# 进程中实现 dll 加载。</p> </li></ol>\n<p>过程有了，新建一个 C++ 控制台程序 <code>ConsoleApplication1.exe</code>， 整体的参考代码如下：</p>\n<pre><code class=\"prism language-C#\">\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;Tlhelp32.h&gt;\n\nDWORD GetPid(const WCHAR* szName)\n{\n\tHANDLE hprocessSnap = NULL;\n\n\tPROCESSENTRY32 pe32 = { 0 };\n\n\thprocessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n\tpe32.dwSize = sizeof(PROCESSENTRY32);\n\n\tif (Process32First(hprocessSnap, &amp;pe32))\n\t{\n\t\tdo {\n\t\t\tif (!wcscmp(szName, pe32.szExeFile)) {\n\t\t\t\treturn (int)pe32.th32ProcessID;\n\t\t\t}\n\t\t} while (Process32Next(hprocessSnap, &amp;pe32));\n\t}\n\telse\n\t{\n\t\tCloseHandle(hprocessSnap);\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tconst wchar_t* path = L\"D:\\\\net6\\\\ConsoleApp1\\\\x64\\\\Debug\\\\MyInject.dll\"; //要注入的dll文件地址\n\n\t//1. 获取进程ID\n\tDWORD  procID = GetPid(L\"ConsoleApp4.exe\");\n\n\t//2. 获取进程句柄\n\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\n\n\t//3. 在目标进程中开辟一块空间\n\tLPVOID pRemoteAdress = VirtualAllocEx(hProcess, NULL, wcslen(path) * 2, MEM_COMMIT, PAGE_READWRITE);\n\n\t//4. 将 path 写入到这块空间中\n\tBOOL bRet = WriteProcessMemory(hProcess, pRemoteAdress, path, wcslen(path) * 2, NULL);\n\n\t//5. 让目标线程调用 LoadLibraryW 加载我们注入的 dll\n\tHMODULE hModule = GetModuleHandle(L\"kernel32.dll\");\n\tLPTHREAD_START_ROUTINE dwLoadAddr = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, \"LoadLibraryW\");\n\tHANDLE hThread = CreateRemoteThread(\n\t\thProcess,\n\t\tNULL,\n\t\t0,\n\t\t(LPTHREAD_START_ROUTINE)dwLoadAddr,\n\t\tpRemoteAdress,\n\t\tNULL,\n\t\tNULL\n\t);\n\n\t//6. 函数执行完后，释放这块空间。\n\tWaitForSingleObject(hThread, -1);\n\tVirtualFreeEx(hProcess, pRemoteAdress, 1, MEM_DECOMMIT);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n</code></pre>\n<p>万事具备，接下来我们将 <code>ConsoleApplication1.exe</code> 启动，可以成功观察到 ConsoleApp4.exe 上已经注入成功的输出，截图如下：</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\6b8610686d1339942e1816f0e26d6b98.png\"/></p>\n<h2><a id=\"_165\"></a>三：总结</h2>\n<p>这就是对 WinDbg 实现注入拦截的一个衍生知识，整体思路还是很明朗的，当然有注入，就有反注入，比如下面两条策略。</p>\n<ol><li> <p>设置进程的保护属性。</p> </li><li> <p>屏蔽 或者 混淆 Win32 的 LoadLibraryW 函数。</p> </li></ol>\n<p>等等各种反注入策略，当然这不是我所关心的，毕竟我只专注 <strong>.NET高级调试</strong> ！😄😄😄</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C#", "cpp": 1, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 08:23:12", "summary": "一：背景前段时间在训练营上课的时候就有朋友提到一个问题，为什么附加到程序后，程序就处于中断状态了？它到底是如何实现的？其实简而言之就是线程的远程注入，这一篇就展开说一下。二：实现原理基本思路在附加进程"}