{"blogid": "126743356", "writerAge": "码龄24天", "writerBlogNum": "51", "writerCollect": "0", "writerComment": "1", "writerFan": "14", "writerGrade": "3级", "writerIntegral": "510", "writerName": "web15687102624", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743356.jpg", "writerRankTotal": "40215", "writerRankWeekly": "12444", "writerThumb": "0", "writerVisitNum": "2599", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:49:33 发布", "blog_title": "JVM 执行引擎部分 (编译器、解释器)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"JVM__2\"></a>JVM 执行引擎</h1>\n<p>本文参考《尚硅谷宋红康JVM全套教程（详解java虚拟机）》和《深入理解Java虚拟机》整理，仅供学习和参考使用。</p>\n<h2><a id=\"_7\"></a>概述</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\babfa75c0f9942dcaca6cfa0b2d66041.png\"/></p>\n<ul><li>执行引擎是JVM的核心部分之一</li><li>这一部分包含了解释器，JIT(Just In Time) 编译器，以及垃圾回收器</li><li>如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li><li>执行引擎不但要对前端编译器编译生成的字节码文件进行解释和编译，还会实际执行方法的功能。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c0b6b8ebb38d44df9dde7fba270abbf6.png\"/></p>\n<h2><a id=\"Java_19\"></a>Java代码执行引擎的工作过程</h2>\n<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤:</p>\n<p>橙色的部分是编译生成字节码的过程，由前端编译器(也就是javac命令) 来完成工作，此时并不涉及到jvm。</p>\n<p>而绿色和蓝色是JVM的工作范围，分别是解释，编译。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4f21c81844384b10840344f86fb0389e.png\"/></p>\n<p><strong>java代码的编译由源代码编译器进行编译生成字节码文件：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7617896d54754361ae5c363aeae0936b.png\"/></p>\n<p><strong>而java字节码的执行由JVM执行引擎来完成：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\46fb8a2e4cbd426a83fc03b2c8ee0d8a.png\"/></p>\n<h3><a id=\"_37\"></a>解释器与编译器</h3>\n<ul><li>Java被称为半解释半编译型语言。这是因为Java虚拟机中包含了解释器和编译器。并不是所有的Java虚拟机都采用解释器与编译器并存的运行架构，但目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器。</li><li><strong>解释器与编译器两者各有优势</strong>： 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编译执行来提升效率。</li><li><strong>HotSpot虚拟机中内置了两个（或三个）即时编译器</strong>，其中有两个编译器存在已久，分别被称为“客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和 C2编译器（部分资料和JDK源码中C2也叫Opto编译器），第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。</li></ul>\n<h4><a id=\"_43\"></a>编译和解释的区别</h4>\n<p>编译（Compile）的过程是把整个源程序代码翻译成另外一种代码，翻译后的代码等待被执行或者被优化等等，发生在运行之前，产物是另一份代码。</p>\n<p>解释（Interpret）的过程是把源程序代码一行一行的读懂，然后一行一行的执行，发生在运行时，产物是运行结果。</p>\n<p>编译会将源程序编译成目标代码，并且会将目标代码保存下来(以便重复利用)，翻译和执行是分开的。而解释会逐条解释目标代码，翻译与执行一气呵成，不会生成可以储存的目标代码。</p>\n<h4><a id=\"_51\"></a>解释器</h4>\n<ul><li>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</li><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul>\n<h4><a id=\"JIT_Just_In_Time___60\"></a>JIT (Just In Time 即时) 编译器</h4>\n<ul><li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</li><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li></ul>\n<h5><a id=\"_66\"></a>热点代码及探测方式</h5>\n<ul><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”<strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出</strong>深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为<strong>OSR (On StackReplacement)编译。</strong></li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</strong>\n<ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul> </li></ul>\n<h5><a id=\"_77\"></a>方法调用计数器</h5>\n<ul><li>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li><li>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 来人为设定。</li><li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本 \n  <ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。 \n    <ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2e1a9608668640a69883f69aa1049d10.png\"/></li></ul> </li></ul> </li></ul>\n<h5><a id=\"_88\"></a>热度衰减</h5>\n<ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</li></ul>\n<h5><a id=\"_94\"></a>回边计数器</h5>\n<p>==它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。==显然，建立回边计数器统计的目的就是为了触发OSR编译。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2b98e8d9357d4d7a931c85c8ab221ee2.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 1, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:49:33", "summary": "执行引擎本文参考《尚硅谷宋红康全套教程详解虚拟机》和《深入理解虚拟机》整理，仅供学习和参考使用。概述在这里插入图片描述执行引擎是的核心部分之一这一部分包含了解释器，编译器，以及垃圾回收器如果想要让一个"}