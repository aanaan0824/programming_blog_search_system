{"blogid": "126727119", "writerAge": "码龄5年", "writerBlogNum": "430", "writerCollect": "83543", "writerComment": "10790", "writerFan": "264489", "writerGrade": "9级", "writerIntegral": "51466", "writerName": "哪 吒", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126727119.jpg", "writerRankTotal": "47", "writerRankWeekly": "2", "writerThumb": "22537", "writerVisitNum": "3862804", "blog_read_count": "482", "blog_time": "已于 2022-09-07 13:50:11 修改", "blog_title": "猿创征文 | 深入理解高并发编程 ~ 开篇", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>目录</h3>\n<ul><li><ul><li><a href=\"#_1\">一、进程与线程</a></li><li><a href=\"#_13\">二、线程组与线程池</a></li><li><ul><li><a href=\"#1_14\">1、线程组</a></li><li><a href=\"#2_39\">2、线程组和线程池有啥区别？</a></li></ul>\n</li><li><a href=\"#_45\">三、用户线程与守护线程</a></li><li><a href=\"#_73\">四、并行与并发</a></li><li><a href=\"#_86\">五、悲观锁与乐观锁</a></li><li><ul><li><a href=\"#1_87\">1、悲观锁</a></li><li><a href=\"#2_96\">2、乐观锁</a></li></ul>\n</li><li><a href=\"#CAS_103\">六、CAS</a></li><li><ul><li><a href=\"#1CAS_104\">1、什么是CAS？</a></li><li><a href=\"#2CAS_111\">2、CAS带来的问题</a></li></ul>\n</li><li><a href=\"#_134\">七、那些年学过的锁</a></li><li><ul><li><a href=\"#1_135\">1、公平锁与非公平锁</a></li><li><a href=\"#2_138\">2、独占锁与共享锁</a></li><li><a href=\"#3_142\">3、可重入锁与不可重入锁</a></li></ul>\n</li><li><a href=\"#_146\">八、死锁、活锁、饿死</a></li><li><ul><li><a href=\"#1_147\">1、死锁</a></li><li><a href=\"#24_150\">2、产生死锁的4个必要条件</a></li><li><a href=\"#3_156\">3、饥饿</a></li><li><a href=\"#4_159\">4、产生饥饿的主要原因</a></li><li><a href=\"#5_163\">5、如何避免饥饿</a></li><li><a href=\"#6_168\">6、活锁</a></li><li><a href=\"#7_172\">7、如何避免活锁</a></li></ul>\n</li><li><a href=\"#_176\">九、多线程锁的升级原理是什么？</a></li><li><ul><li><a href=\"#1_182\">1、无锁</a></li><li><a href=\"#2_188\">2、偏向锁</a></li><li><a href=\"#3_196\">3、轻量级锁</a></li><li><a href=\"#4_206\">4、重量级锁</a></li><li><a href=\"#5_212\">5、锁状态对比</a></li><li><a href=\"#6_221\">6、锁消除</a></li></ul>\n</li><li><a href=\"#Java_225\">十、Java多线程思维导图</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h2><a id=\"_1\"></a>一、进程与线程</h2>\n<p>程序本身是静态的，是众多代码的组合产物，代码保存在文件中。如果程序要运行，则需要将程序加载到内存中，通过编译器将其编译成计算机能够理解的方式运行。<br/> 如果想启动一个Java程序，先要创建一个JVM进程。<br/> 进程是操作系统进行资源分配的最小单位，在一个进程中可以创建多个线程。多个线程各自拥有独立的局部变量、线程堆栈和程序计数器，能够访问共享的资源。</p>\n<blockquote>\n<ol><li>进程是操作系统分配资源的最小单位，线程是CPU调度的最小单位；</li><li>一个进程中可以包含多个线程；</li><li>进程与进程之间是相对独立的，进程中的线程之间并不完全独立，可以共享进程中的堆内存、方法区内存、系统资源等；</li><li>进程上下文的切换要比线程的上下文切换慢很多；</li><li>某个进程发生异常，不会对其它进程造成影响，但，某个线程发生异常，可能会对此进程中的其它线程造成影响；</li></ol>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3115f1d4f9b14f04ade0496bf135b41c.png\"/></p>\n<h2><a id=\"_13\"></a>二、线程组与线程池</h2>\n<h3><a id=\"1_14\"></a>1、线程组</h3>\n<p>线程组可以管理多个线程，顾名思义，线程组，就是把功能相似的线程放到一个组里，方便管理。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>guor<span class=\"token punctuation\">.</span>test</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadGroupTest</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// 创建线程组</span>\n        <span class=\"token class-name\">ThreadGroup</span> threadGroup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadGroup</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"nezha\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>threadGroup<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-&gt;</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">// 线程组名称</span>\n            <span class=\"token class-name\">String</span> groupName <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getThreadGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 线程名称</span>\n            <span class=\"token class-name\">String</span> threadName <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"groupName -- \"</span><span class=\"token operator\">+</span>groupName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//groupName -- nezha</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"threadName -- \"</span><span class=\"token operator\">+</span>threadName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//threadName -- thread</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"thread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"2_39\"></a>2、线程组和线程池有啥区别？</h3>\n<ol><li>线程组中的线程可以跨线程修改数据，而线程组和线程组之间不可以跨线程修改数据；</li><li>线程池就是创建一定数量的线程，批量处理任务，当前任务执行完毕后，线程又可以去执行其它任务，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li>线程池可以有效的管理线程的数量，避免线程的无限制创建，线程是很耗费系统资源的，动不动就会产生OOM，并且会造成cpu过度切换，也有强大的拓展功能，比如延时定时线程池。</li></ol>\n<h2><a id=\"_45\"></a>三、用户线程与守护线程</h2>\n<p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 。</p>\n<p>用户线程是最常见的线程，比如通过main方法启动，就会创建一个用户线程。</p>\n<p>Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。</p>\n<p>JVM中的垃圾回收、JIT编译器线程就是最常见的守护线程。</p>\n<p>只要有一个用户线程在运行，守护线程就会一直运行。只有所有的用户线程都结束的时候，守护线程才会退出。</p>\n<p>编写代码时，也可以通过<code>thread.setDaemon(true)</code>指定线程为守护线程。</p>\n<pre><code class=\"prism language-java\"><span class=\"token class-name\">Thread</span> daemonTread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n  <span class=\"token comment\">// 设定 daemonThread 为 守护线程，默认false</span>\n daemonThread<span class=\"token punctuation\">.</span><span class=\"token function\">setDaemon</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n <span class=\"token comment\">// 验证当前线程是否为守护线程，返回 true 则为守护线程</span>\n daemonThread<span class=\"token punctuation\">.</span><span class=\"token function\">isDaemon</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>守护线程的注意事项：</p>\n<ol><li><code>thread.setDaemon(true)</code>要在<code>thread.start()</code>之前设置，否则会抛出<code>IllegalThreadStateException</code>异常。你不能把正在运行的线程设置为守护线程；</li><li>在守护线程中产生的新线程也是守护线程；</li><li>读写操作或者计算逻辑不可以设置为守护线程；</li></ol>\n<h2><a id=\"_73\"></a>四、并行与并发</h2>\n<p>并行指当多核CPU中的一个CPU执行一个线程时，其它CPU能够同时执行另一个线程，两个线程之间不会抢占CPU资源，可以同时运行。</p>\n<p>并发指在一段时间内CPU处理多个线程，这些线程会抢占CPU资源，CPU资源根据时间片周期在多个线程之间来回切换，多个线程在一段时间内同时运行，而在同一时刻不是同时运行的。</p>\n<p>并行和并发的区别？</p>\n<ol><li>并行指多个线程在一段时间的每个时刻都同时运行，并发指多个线程在一段时间内同时运行（不是同一时刻，一段时间内交叉执行）</li><li>并行的多个线程不会抢占系统资源，并发的多个线程会抢占系统资源；</li><li>并行是多CPU的产物，单核CPU中只有并发，没有并行；</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3387163e178b4d739c1e4dde69049da3.png\"/></p>\n<h2><a id=\"_86\"></a>五、悲观锁与乐观锁</h2>\n<h3><a id=\"1_87\"></a>1、悲观锁</h3>\n<p>悲观锁在一个线程进行加锁操作后使得该对象变为该线程的独有对象，其它的线程都会被悲观锁阻拦在外，无法操作。</p>\n<p>悲观锁的缺陷：</p>\n<ol><li>一个线程获得悲观锁后其它线程必须阻塞。</li><li>线程切换时要不停的释放锁和获取锁，开销巨大。</li><li>当一个低优先级的线程获得悲观锁后，高优先级的线程必须等待，导致线程优先级倒置，synchronized锁是一种典型的悲观锁。</li></ol>\n<h3><a id=\"2_96\"></a>2、乐观锁</h3>\n<p>乐观锁认为对一个对象的操作不会引发冲突，所以每次操作都不进行加锁，只是在最后提交更改时验证是否发生冲突，如果冲突则再试一遍直到成功为止，这个尝试的过程被称为自旋。乐观锁其实并没有加锁，但乐观锁也引入了诸如ABA、自旋次数过多等问题。</p>\n<p>乐观锁一般会采用版本号机制，先读取数据的版本号，在写数据时比较版本号是否一致，如果一致，则更新数据，否则再次读取版本号，直到版本号一致。</p>\n<p>Java中的乐观锁都是基于CAS自旋实现的。</p>\n<h2><a id=\"CAS_103\"></a>六、CAS</h2>\n<h3><a id=\"1CAS_104\"></a>1、什么是CAS？</h3>\n<p>Compare And Swap。</p>\n<p>CAS(V, A, B) ，内存值V，期待值A, 修改值B（V 是否等于 A， 等于执行， 不等于将B赋给V）</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bee317a3195a491988a3c7b7406840ba.png\"/></p>\n<h3><a id=\"2CAS_111\"></a>2、CAS带来的问题</h3>\n<p>（1）ABA问题</p>\n<p>CAS操作的流程为：</p>\n<ol><li>读取原值。</li><li>通过原子操作比较和替换。</li><li>虽然比较和替换是原子性的，但是读取原值和比较替换这两步不是原子性的，期间原值可能被其它线程修改。</li></ol>\n<p>ABA问题有些时候对系统不会产生问题，但是有些时候却也是致命的。</p>\n<p>ABA问题的解决方法是对该变量增加一个版本号，每次修改都会更新其版本号。JUC包中提供了一个类AtomicStampedReference，这个类中维护了一个版本号，每次对值的修改都会改动版本号。</p>\n<p>（2）自旋次数过多</p>\n<p>CAS操作在不成功时会重新读取内存值并自旋尝试，当系统的并发量非常高时即每次读取新值之后该值又被改动，导致CAS操作失败并不断的自旋重试，此时使用CAS并不能提高效率，反而会因为自旋次数过多还不如直接加锁进行操作的效率高。</p>\n<p>（3）只能保证一个变量的原子性</p>\n<p>当对一个变量操作时，CAS可以保证原子性，但同时操作多个变量时CAS就无能为力了。</p>\n<p>可以封装成对象，再对对象进行CAS操作，或者直接加锁。</p>\n<h2><a id=\"_134\"></a>七、那些年学过的锁</h2>\n<h3><a id=\"1_135\"></a>1、公平锁与非公平锁</h3>\n<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul>\n<h3><a id=\"2_138\"></a>2、独占锁与共享锁</h3>\n<ul><li>独占锁：当多个线程则争抢锁的过程中，无论是读操作还是写操作，只能有一个线程获取到锁，其他线程阻塞等待。</li><li>共享锁：允许多个线程同时获取共享资源，采取的是乐观锁的机制，共享锁限制写写操作、读写操作，但不会限制读读操作。</li></ul>\n<h3><a id=\"3_142\"></a>3、可重入锁与不可重入锁</h3>\n<ul><li>可重入锁：一个线程可以多次占用同一个锁，但是解锁时，需要执行相同次数的解锁操作；</li><li>不可重入锁：一个线程不能多次占用同一个锁；</li></ul>\n<h2><a id=\"_146\"></a>八、死锁、活锁、饿死</h2>\n<h3><a id=\"1_147\"></a>1、死锁</h3>\n<p>多个线程互相持有对方需要的资源，导致多个线程相互等待，无法继续执行后续任务。</p>\n<h3><a id=\"24_150\"></a>2、产生死锁的4个必要条件</h3>\n<ol><li>互斥条件：指进程对所分配到的资源进行排它性使用，在一段时间内某资源只由一个进程占用，如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程被释放；</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不可剥夺：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>循环等待：一个等待一个，产生了一个闭环。</li></ol>\n<h3><a id=\"3_156\"></a>3、饥饿</h3>\n<p>饥饿指的是线程由于无法获取需要的资源而无法继续执行。</p>\n<h3><a id=\"4_159\"></a>4、产生饥饿的主要原因</h3>\n<ol><li>高优先级的线程不断抢占资源，低优先级的线程抢不到；</li><li>某个线程一直不释放资源，导致其他线程无法获取资源；</li></ol>\n<h3><a id=\"5_163\"></a>5、如何避免饥饿</h3>\n<ol><li>使用公平锁分配资源；</li><li>为程序分配足够的系统资源；</li><li>避免持有锁的线程长时间占用锁；</li></ol>\n<h3><a id=\"6_168\"></a>6、活锁</h3>\n<p>活锁指的是多个线程同时抢占同一个资源时，都主动将资源让给其他线程使用，导致这个资源在多个线程之间来回切换，导致线程因无法获取相应资源而无法继续执行的现象。</p>\n<h3><a id=\"7_172\"></a>7、如何避免活锁</h3>\n<p>可以让多个线程随机等待一段时间后再次抢占资源，这样会大大减少线程抢占资源的冲突次数，有效避免活锁的产生。</p>\n<h2><a id=\"_176\"></a>九、多线程锁的升级原理是什么？</h2>\n<p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁、重量级锁。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d6e67d2472ee4a3d9f664c284a8226fc.png\"/></p>\n<p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。但是锁的升级是单向的，只能升级不能降级。</p>\n<h3><a id=\"1_182\"></a>1、无锁</h3>\n<p>没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其它修改失败的线程会不断重试直到修改成功。</p>\n<p>无锁总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，CAS是无锁技术的关键。</p>\n<h3><a id=\"2_188\"></a>2、偏向锁</h3>\n<p>对象的代码一直被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。</p>\n<p>偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停偏向锁的线程，然后判断锁对象是否处于被锁定状态，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁。</p>\n<p>如果线程处于活动状态，升级为轻量级锁的状态</p>\n<h3><a id=\"3_196\"></a>3、轻量级锁</h3>\n<p>轻量级锁是指当锁是偏向锁的时候，被第二个线程B访问，此时偏向锁就会升级为轻量级锁，线程B会通过自旋的形式尝试获取锁，线程不会阻塞，从er提升性能。</p>\n<p>当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定次数时，轻量级锁便会升级为重量级锁，当一个线程已持有锁，另一个线程在自旋，而此时第三个线程来访时，轻量级锁也会升级为重量级锁。</p>\n<p>注：自旋是什么？</p>\n<p>自旋（spinlock）是指当一个线程获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>\n<h3><a id=\"4_206\"></a>4、重量级锁</h3>\n<p>指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p>\n<p>重量级锁通过对象内部的监听器（monitor）实现，而其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</p>\n<h3><a id=\"5_212\"></a>5、锁状态对比</h3>\n<table><thead><tr><th></th><th>偏向锁</th><th>轻量级锁</th><th>重量级锁</th></tr></thead><tbody><tr><td>使用场景</td><td>只有一个线程进入同步块</td><td>虽然很多线程，但没有冲突，线程进入时间错开因而并未争抢锁</td><td>发生了锁争抢的情况，多条线程进入同步块争用锁</td></tr><tr><td>本质</td><td>取消同步操作</td><td>CAS操作代替互斥同步</td><td>互斥同步</td></tr><tr><td>优点</td><td>不阻塞，执行效率高（只有第一次获取偏向锁时需要CAS操作，后面只是比对ThreadId）</td><td>不会阻塞</td><td>不会空耗CPU</td></tr><tr><td>缺点</td><td>适用场景太局限。若竞争产生，会有额外的偏向锁撤销的消耗</td><td>长时间获取不到锁空耗CPU</td><td>阻塞，上下文切换，重量级操作，消耗操作系统资源</td></tr></tbody></table>\n<h3><a id=\"6_221\"></a>6、锁消除</h3>\n<p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，别切不会被其它线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>\n<h2><a id=\"Java_225\"></a>十、Java多线程思维导图</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3ae257f5a2ec490ea81e30391bca3234.png\"/></p>\n<p>哪吒精品系列文章：</p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/120098618\">Java学习路线总结，搬砖工逆袭Java架构师</a></p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/119299329\">10万字208道Java经典面试题总结(附答案)</a></p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/126542005\">SQL性能优化的21个小技巧</a></p>\n<p><a href=\"https://blog.csdn.net/guorui_java/category_11276743.html\">Java基础教程系列</a></p>\n<p><a href=\"https://blog.csdn.net/guorui_java/category_9710627.html\">Spring Boot 进阶实战</a><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a42db6d30d1e4049864f9aa7a27e1369.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-09-07 13:50:11", "summary": "目录一、进程与线程二、线程组与线程池、线程组、线程组和线程池有啥区别？三、用户线程与守护线程四、并行与并发五、悲观锁与乐观锁、悲观锁、乐观锁六、、什么是？、带来的问题七、那些年学过的锁、公平锁与非公平"}