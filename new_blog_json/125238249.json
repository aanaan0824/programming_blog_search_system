{"blogid": "125238249", "writerAge": "码龄4年", "writerBlogNum": "183", "writerCollect": "25717", "writerComment": "931", "writerFan": "22793", "writerGrade": "7级", "writerIntegral": "10896", "writerName": "ha_lydms", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125238249.jpg", "writerRankTotal": "1566", "writerRankWeekly": "443", "writerThumb": "3648", "writerVisitNum": "739436", "blog_read_count": "3094", "blog_time": "于 2022-06-11 20:52:59 发布", "blog_title": "Arthas使用教程(8大分类)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#_3\">一、简介</a></li><li><ul><li><a href=\"#1_4\">1、简介</a></li><li><a href=\"#2_28\">2、项目所在位置</a></li></ul>\n</li><li><a href=\"#Arthas_44\">二、安装Arthas</a></li><li><ul><li><a href=\"#1Arthas_46\">1、安装Arthas</a></li><li><a href=\"#2Arthas_65\">2、卸载Arthas</a></li><li><a href=\"#3_74\">3、首次启动。</a></li></ul>\n</li><li><a href=\"#_80\">三、核心监视功能</a></li><li><ul><li><a href=\"#1monitor_84\">1、`monitor`：监控方法的执行情况</a></li><li><a href=\"#2watch_122\">2、`watch`：检测函数返回值</a></li><li><a href=\"#3trace_211\">3、`trace`：根据路径追踪，并记录消耗时间</a></li><li><a href=\"#4stack_281\">4、`stack`：输出当前方法被调用的调用路径</a></li><li><a href=\"#5tt_320\">5、`tt`：时间隧道，记录多个请求</a></li><li><ul><li><a href=\"#51_tt_409\">5.1 `tt`对重载的支持</a></li><li><a href=\"#52_tt_437\">5.2 `tt`发起重新请求</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_453\">四、项目中使用</a></li><li><ul><li><a href=\"#91_trace_457\">9.1 `trace`：查询最耗时应用</a></li><li><a href=\"#92_jad_473\">9.2 `jad`：反编译耗时代码</a></li><li><a href=\"#93_trace_483\">9.3 `trace`：查询最耗时应用</a></li><li><a href=\"#94_watch_491\">9.4 `watch`：捕获耗时应用入参、返回值</a></li></ul>\n</li><li><a href=\"#_510\">五、基础命令</a></li><li><ul><li><a href=\"#1helpArthas_529\">1、`help`：显示`Arthas`命令介绍</a></li><li><a href=\"#2cat_535\">2、`cat`：显示文件下，文本内容</a></li><li><a href=\"#3grep__543\">3、`grep`： 管道命令</a></li><li><a href=\"#4pwd_565\">4、`pwd`：打印当前的工作目录</a></li><li><a href=\"#5session_571\">5、`session`：查看当前会话的信息</a></li><li><a href=\"#6reset_577\">6、`reset`：重置增强后类</a></li><li><a href=\"#7versionArthas_589\">7、`version`：查看当前`Arthas`版本</a></li><li><a href=\"#8history_595\">8、`history`：查看历史命令</a></li><li><a href=\"#9quitArthas_599\">9、`quit`：退出`Arthas`客户端</a></li><li><a href=\"#10stop_Arthas__623\">10、`stop`：关闭 Arthas 服务端</a></li><li><a href=\"#11keymapArthas_629\">11、`keymap`：查看`Arthas`快捷键</a></li></ul>\n</li><li><a href=\"#Jvm_666\">六、Jvm相关命令</a></li><li><ul><li><a href=\"#1dashboard_679\">1、`dashboard`：实时数据面板</a></li><li><a href=\"#2Thread_703\">2、`Thread`：线程相关堆栈信息</a></li><li><a href=\"#3jvm_750\">3、`jvm`</a></li><li><a href=\"#4sysprop_769\">4、`sysprop`：查看/修改属性</a></li><li><a href=\"#5sysenvJVM_783\">5、`sysenv`：查看JVM环境属性</a></li><li><a href=\"#6vmpotionJVM_796\">6、`vmpotion`：查看JVM中选项</a></li><li><a href=\"#7getstatic_815\">7、`getstatic`：获取静态成员变量</a></li><li><a href=\"#8ognlognl_832\">8、`ognl`：执行ognl表达式</a></li></ul>\n</li><li><a href=\"#classclassLoader_865\">七、类和类加载器(class/classLoader)</a></li><li><ul><li><a href=\"#1sc_875\">1、`sc`：查看类信息</a></li><li><a href=\"#2sm_904\">2、`sm`：查看已加载方法信息</a></li><li><a href=\"#_921\"></a></li><li><a href=\"#3jadmcredefine_934\">3、编译与反编译`jad`、`mc`、`redefine`</a></li><li><ul><li><a href=\"#31_jad_942\">3.1 `jad`：反编译已加载类源码</a></li><li><a href=\"#32_mcJava_974\">3.2 `mc`：编译Java代码</a></li><li><a href=\"#33_redefineclass_991\">3.3 `redefine`：加载外部`.class`文件</a></li></ul>\n</li><li><a href=\"#4dump_1025\">4、`dump`：保存已加载字节码文件到本地</a></li><li><a href=\"#5classloader_1058\">5、`classloader`：获取类加载器的信息</a></li></ul>\n</li><li><a href=\"#option_1141\">八、`option`全局选项</a></li><li><a href=\"#profiler_1178\">九、`profiler`火焰图</a></li><li><a href=\"#_1256\">十、相关文件</a></li><li><ul><li><a href=\"#1_1258\">1、配套资料</a></li><li><a href=\"#2Xmind_1266\">2、Xmind整理资料</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<h2><a id=\"_3\"></a>一、简介</h2>\n<h3><a id=\"1_4\"></a>1、简介</h3>\n<p><img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\cee78313e0634bf88b6e97fe4592baf6.png\"/></p>\n<p><a href=\"https://github.com/alibaba/arthas\">GitHub地址</a></p>\n<pre><code>https://github.com/alibaba/arthas\n</code></pre>\n<p><a href=\"http://arthas.gitee.io/\">码云地址</a></p>\n<pre><code>http://arthas.gitee.io/\n</code></pre>\n<p><code>Arthas</code> 是<code>Alibaba</code>开源的Java诊断工具，深受开发者喜爱。<br/> 当你遇到以下类似问题而束手无策时， Arthas 可以帮助你解决：</p>\n<ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 <code>Exception</code>？</li><li>我改的代码为什么没有执行到？难道是我没 <code>commit</code>？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到<code>JVM</code>的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ol>\n<p><code>Arthas</code> 支持JDK 6+，支持<code>Linux/Mac/Winodws</code>，采用命令行交互模式，同时提供丰富的 Tab 自动补<br/> 全功能，进一步方便进行问题的定位和诊断。</p>\n<h3><a id=\"2_28\"></a>2、项目所在位置</h3>\n<table><thead><tr><th>所在目录</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td></td><td>dump</td><td>将已加载类的字节码文件保存到特定的目录中</td></tr><tr><td></td><td>classloader</td><td>获取类加载器的信息</td></tr><tr><td></td><td>monitor</td><td>监控指定类中方法的执行情况</td></tr><tr><td></td><td>watch</td><td>观察到指定方法的调用情况</td></tr><tr><td></td><td>trace</td><td>对方法内部调用路径进行追踪，并输出方法路径上每个节点上耗时</td></tr><tr><td></td><td>stack</td><td>输出当前方法被调用的路径</td></tr><tr><td></td><td>tt</td><td>记录指定方法每次调用的入参和返回信息</td></tr><tr><td></td><td>options</td><td>全局开关</td></tr><tr><td></td><td>profiler</td><td>生成火焰图</td></tr></tbody></table>\n<h2><a id=\"Arthas_44\"></a>二、安装Arthas</h2>\n<h3><a id=\"1Arthas_46\"></a>1、安装Arthas</h3>\n<ol><li>下载<code>arthas-boot.jar</code></li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">wget</span> https://arthas.aliyun.com/arthas-boot.jar<span class=\"token punctuation\">;</span>\njava -jar arthas-boot.jar\n</code></pre>\n<p>选择进程</p>\n<pre><code>1\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\63d3ecf11f5d41418b5eaca681065b07.png\"/>\n<h3><a id=\"2Arthas_65\"></a>2、卸载Arthas</h3>\n<p>因为文件是绿色版本，直接删除安装目录既可</p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">rm</span> -rf ./arthas\t\t\t<span class=\"token comment\">#\t隐藏目录</span>\n<span class=\"token function\">rm</span> -rf logs/\t\t\t<span class=\"token comment\">#\t日志目录</span>\n</code></pre>\n<h3><a id=\"3_74\"></a>3、首次启动。</h3>\n<blockquote>\n<p>首先要启动jar包，然后才能启动Arthas。</p>\n</blockquote>\n<h2><a id=\"_80\"></a>三、核心监视功能</h2>\n<h3><a id=\"1monitor_84\"></a>1、<code>monitor</code>：监控方法的执行情况</h3>\n<blockquote>\n<p>监控指定类中方法的执行情况<br/> 用来监视一个时间段中指定方法的执行次数，成功次数，失败次数，耗时等这些信息</p>\n</blockquote>\n<p><strong>参数说明</strong></p>\n<p>方法拥有一个命名参数 <code>[c:]</code>，意思是统计周期（cycle of output），拥有一个整型的参数值</p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[c:]</code></td><td>统计周期，默认值为120秒</td></tr></tbody></table>\n<p>监控<code>demo.MathGame</code>类，并且每5S更新一次状态。</p>\n<pre><code class=\"prism language-bash\">monitor demo.MathGame primeFactors -c <span class=\"token number\">5</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ab86881394c9456aaf170a70e2902750.png\"/></p>\n<p><strong>监控的维度说明</strong></p>\n<table><thead><tr><th>监控项</th><th>说明</th></tr></thead><tbody><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>class</td><td>Java类</td></tr><tr><td>method</td><td>方法（构造方法、普通方法）</td></tr><tr><td>total</td><td>调用次数</td></tr><tr><td>success</td><td>成功次数</td></tr><tr><td>fail</td><td>失败次数</td></tr><tr><td>rt</td><td>平均耗时</td></tr><tr><td>fail-rate</td><td>失败率</td></tr></tbody></table>\n<h3><a id=\"2watch_122\"></a>2、<code>watch</code>：检测函数返回值</h3>\n<blockquote>\n<p>方法执行数据观测，让你能方便的观察到指定方法的调用情况。</p>\n<p>能观察到的范围为：<code>返回值</code>、<code>抛出异常</code>、<code>入参</code>，通过编写OGNL 表达式进行对应变量的查看。</p>\n</blockquote>\n<p><strong>参数说明：</strong></p>\n<p>watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象</p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>express</em></td><td>观察表达式</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[b]</td><td>在<strong>方法调用之前</strong>观察<code>before</code></td></tr><tr><td>[e]</td><td>在<strong>方法异常之后</strong>观察 <code>exception</code></td></tr><tr><td>[s]</td><td>在<strong>方法返回之后</strong>观察 <code>success</code></td></tr><tr><td>[f]</td><td>在<strong>方法结束之后</strong>(正常返回和异常返回)观察 <code>finish</code></td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td>[x:]</td><td>指定输出结果的属性遍历深度，默认为 1</td></tr></tbody></table>\n<p>这里重点要说明的是观察表达式，观察表达式的构成主要由ognl 表达式组成，所以你可以这样写<code>\"{params,returnObj}\"</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p>\n<p><strong>特别说明</strong></p>\n<ul><li>watch 命令定义了4个观察事件点，即 <code>-b</code> 方法调用前，<code>-e</code> 方法异常后，<code>-s</code> 方法返回后，<code>-f</code> 方法结束后</li><li>4个观察事件点 <code>-b</code>、<code>-e</code>、<code>-s</code> 默认关闭，<code>-f</code> 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</li><li>这里要注意<code>方法入参</code>和<code>方法出参</code>的区别，有可能在中间被修改导致前后不一致，除了 <code>-b</code> 事件点 <code>params</code> 代表方法入参外，其余事件都代表方法出参</li><li>当使用 <code>-b</code> 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在</li></ul>\n<p>通过<code>watch</code>命令可以查看函数的参数/返回值/异常信息。</p>\n<p><strong>案例：</strong></p>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\">#\t查看方法执行的返回值</span>\n<span class=\"token function\">watch</span> demo.MathGame primeFactors returnObj\n<span class=\"token comment\">#\t观察demo.MathGame类中primeFactors方法出参和返回值，结果属性遍历深度为2。</span>\n<span class=\"token comment\">#\tparams：表示所有参数数组(因为不确定是几个参数)。</span>\n<span class=\"token comment\">#\treturnObject：表示返回值</span>\n<span class=\"token function\">watch</span> demo.MathGame primeFactors <span class=\"token string\">\"{params,returnObj}\"</span> -x <span class=\"token number\">2</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b5c832da1f2648b5b7af82018ed45df1.png\"/>\n<p>查看执行前参数：</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># -b 方法执行前的参数</span>\n<span class=\"token function\">watch</span> demo.MathGame primeFactors <span class=\"token string\">\"{params,returnObj}\"</span> -x <span class=\"token number\">2</span> -b\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5e5bbe56ed144dcb9f2cf93942eed61e.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t查看方法中的属性</span>\n<span class=\"token function\">watch</span> demo.MathGame primeFactors <span class=\"token string\">\"{target}\"</span> -x <span class=\"token number\">2</span> -b\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b8f6ae8274104d968e7a782a4eafbbbd.png\"/>\n<p>查看某一属性的值</p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">watch</span> demo.MathGame primeFactors <span class=\"token string\">\"{target.illegalArgumentCount}\"</span> -x <span class=\"token number\">2</span> -b\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\32ae9ef68ea74b11bc25fdc032d8860d.png\"/>\n<p>检测方法在执行前<code>-b</code>、执行后<code>-s</code>的入参<code>params</code>、属性<code>target</code>和返回值<code>returnObj</code></p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">watch</span> demo.MathGame primeFactors <span class=\"token string\">\"{params,target,returnObj}\"</span> -x <span class=\"token number\">2</span> -b -s -n <span class=\"token number\">2</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7fa4a549c96a48c2b7cc16b719fcb75e.png\"/>\n<p>输入参数小于0的情况：</p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">watch</span> demo.MathGame primeFactors <span class=\"token string\">\"{params[0],target}\"</span> <span class=\"token string\">\"params[0]&lt;0\"</span>\n</code></pre>\n<p><img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\f5159dab71674a959f9c3718ea72691f.png\"/></p>\n<h3><a id=\"3trace_211\"></a>3、<code>trace</code>：根据路径追踪，并记录消耗时间</h3>\n<blockquote>\n<p>对方法内部调用路径进行追踪，并输出方法路径上的每个节点上耗时。</p>\n</blockquote>\n<p>简介：</p>\n<blockquote>\n<p><code>trace</code> 命令能主动搜索 <code>class-pattern</code>／<code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p>\n<p>观察表达式的构成主要由ognl 表达式组成，所以你可以这样写<code>\"{params,returnObj}\"</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p>\n<p>很多时候我们只想看到某个方法的rt大于某个时间之后的trace结果，现在Arthas可以按照方法执行的耗时来进行过滤了，例如<code>trace *StringUtils isBlank '#cost&gt;100'</code>表示当执行时间超过100ms的时候，才会输出trace的结果。</p>\n<p>watch/stack/trace这个三个命令都支持<code>#cost</code>耗时条件过滤。</p>\n</blockquote>\n<p><strong>参数说明：</strong></p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式，使用OGNL表达式</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认是通配符匹配</td></tr><tr><td><code>[n:]</code></td><td>设置命令执行次数</td></tr><tr><td><code>#cost</code></td><td>方法执行耗时，单位是毫秒</td></tr></tbody></table>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>class-pattern</td><td>类名表达式匹配</td></tr><tr><td>method-pattern</td><td>方法名表达式匹配</td></tr><tr><td>condition-express</td><td>条件表达式</td></tr><tr><td>#cost</td><td>过滤条件，只追踪满足的耗时方法</td></tr></tbody></table>\n<p><strong>案例：</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\ttrace函数指定类的指定方法</span>\ntrace demo.MathGame run\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6795466459024e71b04b60a40051973c.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t执行1次后退出</span>\ntrace demo.MathGame run -n <span class=\"token number\">1</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f49fe1aeaf8640379271c3cd3b318772.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t默认情况下，trace不会包含jdk里的函数调用，如果希望trace jdk里的函数。</span>\n<span class=\"token comment\">#\t需要显式设置--skipJDKMethod false。</span>\ntrace --skipJDKMethod <span class=\"token boolean\">false</span> demo.MathGame run\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ee7a9ea88f164553b4f188481a9383e5.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t据调用耗时过滤，trace大于0.5ms的调用路径</span>\ntrace demo.MathGame run <span class=\"token string\">'#cost &gt; .5'</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4342028edfdf42108336104beb967f69.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t可以用正则表匹配路径上的多个类和函数，一定程度上达到多层trace的效果。</span>\ntrace -E com.test.ClassA<span class=\"token operator\">|</span>org.test.ClassB method1<span class=\"token operator\">|</span>method2<span class=\"token operator\">|</span>method3\n</code></pre>\n<h3><a id=\"4stack_281\"></a>4、<code>stack</code>：输出当前方法被调用的调用路径</h3>\n<blockquote>\n<p>输出当前方法被调用的调用路径</p>\n<p>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。</p>\n</blockquote>\n<p><strong>参数说明</strong></p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式，OGNL</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[n:]</code></td><td>执行次数限制</td></tr></tbody></table>\n<p><strong>案例：</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t获取primeFactors的调用路径</span>\nstack demo.MathGame primeFactors\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\28d17bccec4844dfb4fec2c149b821fa.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t条件表达式来过滤，第0个参数的值小于0，-n表示获取2次</span>\nstack demo.MathGame primeFactors <span class=\"token string\">'params[0]&lt;0'</span> -n <span class=\"token number\">2</span>\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\77200b3c4bf24e9cb8aea68fcada90a4.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t据执行时间来过滤，耗时大于0.5毫秒</span>\nstack demo.MathGame primeFactors <span class=\"token string\">'#cost&gt;0.5'</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2ca3001126b94869b1b579ff5d2af9f6.png\"/>\n<h3><a id=\"5tt_320\"></a>5、<code>tt</code>：时间隧道，记录多个请求</h3>\n<blockquote>\n<p>time-tunnel 时间隧道。</p>\n<p>记录下指定方法每次调用的入参和返回信息，并能对这些不同时间下调用的信息进行观测</p>\n</blockquote>\n<p><strong>简介：</strong></p>\n<blockquote>\n<p><code>watch</code> 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。</p>\n<p>这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。</p>\n<p>于是乎，TimeTunnel 命令就诞生了。</p>\n<p>作用：记录指定方法每次调用的入参和返回值，并后期还可以对这些信息进行观测</p>\n</blockquote>\n<p><strong>参数解析：</strong></p>\n<table><thead><tr><th>tt的参数</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>记录某个方法在一个时间段中的调用</td></tr><tr><td>-l</td><td>显示所有已经记录的列表</td></tr><tr><td>-n 次数</td><td>只记录多少次</td></tr><tr><td>-s 表达式</td><td>搜索表达式</td></tr><tr><td>-i 索引号</td><td>查看指定索引号的详细调用信息</td></tr><tr><td>-p</td><td>重新调用：指定的索引号时间碎片</td></tr></tbody></table>\n<ul><li> <p><code>-t</code></p> <p>tt 命令有很多个主参数，<code>-t</code> 就是其中之一。这个参数表明希望记录下类 <code>*Test</code> 的 <code>print</code> 方法的每次执行情况。</p> </li><li> <p><code>-n 3</code></p> <p>当你执行一个调用量不高的方法时可能你还能有足够的时间用 <code>CTRL+C</code> 中断 tt 命令记录的过程，但如果遇到调用量非常大的方法，瞬间就能将你的 JVM 内存撑爆。</p> <p>此时你可以通过 <code>-n</code> 参数指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断tt命令的记录过程，避免人工操作无法停止的情况。</p> </li></ul>\n<p><strong>案例：</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t最基本的使用来说，就是记录下当前方法的每次调用环境现场。</span>\ntt -t demo.MathGame primeFactors\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\93e068a0cad54ab3afc2ac04a59dae85.png\"/>\n<p>字段说明：</p>\n<table><thead><tr><th>表格字段</th><th>字段解释</th></tr></thead><tbody><tr><td>INDEX</td><td>时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。</td></tr><tr><td>TIMESTAMP</td><td>方法执行的本机时间，记录了这个时间片段所发生的本机时间</td></tr><tr><td>COST(ms)</td><td>方法执行的耗时</td></tr><tr><td>IS-RET</td><td>方法是否以正常返回的形式结束</td></tr><tr><td>IS-EXP</td><td>方法是否以抛异常的形式结束</td></tr><tr><td>OBJECT</td><td>执行对象的<code>hashCode()</code>，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体</td></tr><tr><td>CLASS</td><td>执行的类名</td></tr><tr><td>METHOD</td><td>执行的方法名</td></tr></tbody></table>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t对现有记录进行检索</span>\ntt -l\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\ebd6456b968a43e6aa3367bf82caf0f6.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t需要筛选出 `primeFactors` 方法的调用信息</span>\ntt -s <span class=\"token string\">'method.name==\"primeFactors\"'</span>\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\52d1acddcaf74985817874e75a693ddb.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t查看某条记录详细信息</span>\ntt -i <span class=\"token number\">1002</span>\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\4b9d133b0a5b4ebcbba27638a01820b7.png\"/>\n<h4><a id=\"51_tt_409\"></a>5.1 <code>tt</code>对重载的支持</h4>\n<p>不知道大家是否有在使用过程中遇到以下困惑</p>\n<ul><li>Arthas 似乎很难区分出重载的方法</li><li>我只需要观察特定参数，但是 tt 却全部都给我记录了下来</li></ul>\n<p>条件表达式也是用 <code>OGNL</code> 来编写，核心的判断对象依然是 <code>Advice</code> 对象。除了 <code>tt</code> 命令之外，<code>watch</code>、<code>trace</code>、<code>stack</code> 命令也都支持条件表达式。</p>\n<ul><li>解决方法重载</li></ul>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t指定入参的长度=1</span>\ntt -t *Test print params.length<span class=\"token operator\">==</span><span class=\"token number\">1</span>`\n</code></pre>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t指定入参的类型</span>\ntt -t *Test print 'params<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> instanceof Integer\n</code></pre>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t指定固定的入参值</span>\ntt -t *Test print params<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>.mobile<span class=\"token operator\">==</span>\"13989838402\n</code></pre>\n<h4><a id=\"52_tt_437\"></a>5.2 <code>tt</code>发起重新请求</h4>\n<p><code>tt</code> 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 <code>INDEX</code> 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 <code>-p</code> 参数。通过 <code>--replay-times</code> 指定 调用次数，通过 <code>--replay-interval</code> 指定多次调用间隔(单位ms, 默认1000ms)。</p>\n<pre><code class=\"prism language-shell\">tt -i <span class=\"token number\">1002</span> -p\n<span class=\"token comment\">#\t再重新调用3次</span>\ntt -i <span class=\"token number\">1002</span> -p --replay-interval <span class=\"token number\">3</span>\n<span class=\"token comment\">#\t再重新调用3次,并且间隔2S</span>\ntt -i <span class=\"token number\">1008</span> -p --replay-times <span class=\"token number\">3</span> --replay-interval <span class=\"token number\">2000</span>\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\a4b4f195e19f4794bbbee871f6aaf526.png\"/>\n<h2><a id=\"_453\"></a>四、项目中使用</h2>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9e01ec43d0a042a6b7e9fadf49612b33.png\"/>\n<h3><a id=\"91_trace_457\"></a>9.1 <code>trace</code>：查询最耗时应用</h3>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t在浏览器上进行登录操作，检查最耗时的方法</span>\ntrace *.DispatcherServlet *\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\c66067fb47434095a775e8a8de65d9e6.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t可以分步trace，请求最终是被DispatcherServlet#doDispatch()处理了</span>\ntrace *.FrameworkServlet doService\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\bb19637f480f4f9b855f5505a93e1ac2.png\"/>\n<h3><a id=\"92_jad_473\"></a>9.2 <code>jad</code>：反编译耗时代码</h3>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\ttrace结果里把调用的行号打印出来了，我们可以直接在IDE里查看代码（也可以用jad命令反编译）</span>\njad --source-only *.DispatcherServlet doDispatch\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\5589256b967a4fa68a4dc469e84eeeff.png\"/>\n<h3><a id=\"93_trace_483\"></a>9.3 <code>trace</code>：查询最耗时应用</h3>\n<pre><code>watch *.DispatcherServlet getHandler 'returnObj'\n查看返回的结果，得到使用到了2个控制器的方法\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\143991d8729a49018b1f778dcf5ab58f.png\"/>\n<h3><a id=\"94_watch_491\"></a>9.4 <code>watch</code>：捕获耗时应用入参、返回值</h3>\n<pre><code>watch com.itheima.controller.* * {params,returnObj} -x 2\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\0322e5f7007b4a798038ecf126dda73c.png\"/>\n<p><strong>结论</strong></p>\n<p>通过trace, jad, watch最后得到这个操作由2个控制器来处理，分别是：</p>\n<pre><code>com.itheima.controller.UserController.login()\ncom.itheima.controller.StudentController.findAll()\n</code></pre>\n<h2><a id=\"_510\"></a>五、基础命令</h2>\n<table><thead><tr><th></th><th>基础命令</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>help</td><td>显示所有arthas命令，每个命令都可以使用-h的参数，显示它的参数信息</td></tr><tr><td>2</td><td>cat</td><td>显示文本文件内容</td></tr><tr><td>3</td><td>grep</td><td>对内容进行过滤，只显示关心的行</td></tr><tr><td>4</td><td>pwd</td><td>显示当前的工作路径</td></tr><tr><td>5</td><td>session</td><td>显示当前连接的会话ID</td></tr><tr><td>6</td><td>reset</td><td>重置arthas增强的类</td></tr><tr><td>7</td><td>version</td><td>显示当前arthas的版本号</td></tr><tr><td>8</td><td>history</td><td>查看历史命令</td></tr><tr><td></td><td>cls</td><td>清除屏幕</td></tr><tr><td>9</td><td>quit</td><td>退出当前的会话</td></tr><tr><td>10</td><td>stop</td><td>结束arthas服务器，退出所有的会话</td></tr><tr><td>11</td><td>keymap</td><td>显示所有的快捷键</td></tr></tbody></table>\n<h3><a id=\"1helpArthas_529\"></a>1、<code>help</code>：显示<code>Arthas</code>命令介绍</h3>\n<blockquote>\n<p>显示<code>Arthas</code>命令介绍</p>\n</blockquote>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\48af4280ee5f40d69ddbdb8a0eff24cc.png\"/>\n<h3><a id=\"2cat_535\"></a>2、<code>cat</code>：显示文件下，文本内容</h3>\n<blockquote>\n<p>显示文件下，文本内容。</p>\n<p>如果没有写路径，则显示当前目录下的文件</p>\n</blockquote>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\91d1b0fdceb04814ae22c743a2c803e4.png\"/>\n<h3><a id=\"3grep__543\"></a>3、<code>grep</code>： 管道命令</h3>\n<blockquote>\n<p>管道命令，过滤与Java相关</p>\n</blockquote>\n<p>参数</p>\n<table><thead><tr><th>参数列表</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>显示行号</td></tr><tr><td>-i</td><td>忽略大小写查找</td></tr><tr><td>-m 行数</td><td>最大显示行数，要与查询字符串一起使用</td></tr><tr><td>-e “正则表达式”</td><td>使用正则表达式查找</td></tr></tbody></table>\n<p>案例：</p>\n<pre><code class=\"prism language-shell\">sysprop <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token string\">\"java\"</span>\t<span class=\"token comment\">#\t只显示包含java字符串的行系统属性</span>\nsysprop <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token string\">\"java\"</span> -n \t<span class=\"token comment\"># 显示行号</span>\nsysprop <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token string\">\"java\"</span> -n -m10\t<span class=\"token comment\">#\t显示行号，只显示10行</span>\nthread <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> -e <span class=\"token string\">\"o+\"</span>\t<span class=\"token comment\">#\t使用正则表达式，显示包含2个o字符的线程信息</span>\n</code></pre>\n<h3><a id=\"4pwd_565\"></a>4、<code>pwd</code>：打印当前的工作目录</h3>\n<blockquote>\n<p>打印当前的工作目录</p>\n<p>pwd: Print Work Directory 打印当前工作目录</p>\n</blockquote>\n<h3><a id=\"5session_571\"></a>5、<code>session</code>：查看当前会话的信息</h3>\n<blockquote>\n<p>查看当前会话的信息。</p>\n</blockquote>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\8a7f183fee874229952fef577d463786.png\"/>\n<h3><a id=\"6reset_577\"></a>6、<code>reset</code>：重置增强后类</h3>\n<blockquote>\n<p>重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类。</p>\n</blockquote>\n<pre><code class=\"prism language-shell\">reset Test\t<span class=\"token comment\">#\t还原指定类</span>\nreset *List\t<span class=\"token comment\">#\t还原所有以List结尾的类</span>\nreset\t\t<span class=\"token comment\">#\t还原所有的类</span>\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\bafbf67526724922af2293e5092938ce.png\"/>\n<h3><a id=\"7versionArthas_589\"></a>7、<code>version</code>：查看当前<code>Arthas</code>版本</h3>\n<blockquote>\n<p>查看当前<code>Arthas</code>版本</p>\n</blockquote>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cc04734a2b1e4fa5916dda97a80597ec.png\"/>\n<h3><a id=\"8history_595\"></a>8、<code>history</code>：查看历史命令</h3>\n<blockquote>\n<p>查看历史命令</p>\n</blockquote>\n<h3><a id=\"9quitArthas_599\"></a>9、<code>quit</code>：退出<code>Arthas</code>客户端</h3>\n<blockquote>\n<p>退出当前<code>Arthas</code>客户端，其它客户端不受影响。</p>\n<p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p>\n</blockquote>\n<pre><code class=\"prism language-bash\"><span class=\"token builtin class-name\">exit</span>\n</code></pre>\n<p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p>\n<pre><code class=\"prism language-bash\">java -jar arthas-boot.jar\n</code></pre>\n<p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p>\n<p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p>\n<pre><code class=\"prism language-bash\">stop\n</code></pre>\n<h3><a id=\"10stop_Arthas__623\"></a>10、<code>stop</code>：关闭 Arthas 服务端</h3>\n<blockquote>\n<p>关闭 Arthas 服务端，所有 Arthas 客户端全部退出</p>\n</blockquote>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fd0706e6c5c64ef094449a72c12dae67.png\"/>\n<h3><a id=\"11keymapArthas_629\"></a>11、<code>keymap</code>：查看<code>Arthas</code>快捷键</h3>\n<blockquote>\n<p><code>Arthas</code>快捷键</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7bdb8a11af014c8181010b60ea5481e1.png\"/></p>\n<p><strong>Arthas 命令行快捷键</strong></p>\n<table><thead><tr><th>快捷键说明</th><th>命令说明</th></tr></thead><tbody><tr><td>ctrl + a</td><td>跳到行首</td></tr><tr><td>ctrl + e</td><td>跳到行尾</td></tr><tr><td>ctrl + f</td><td>向前移动一个单词</td></tr><tr><td>ctrl + b</td><td>向后移动一个单词</td></tr><tr><td>键盘左方向键</td><td>光标向前移动一个字符</td></tr><tr><td>键盘右方向键</td><td>光标向后移动一个字符</td></tr><tr><td>键盘下方向键</td><td>下翻显示下一个命令</td></tr><tr><td>键盘上方向键</td><td>上翻显示上一个命令</td></tr><tr><td>ctrl + h</td><td>向后删除一个字符</td></tr><tr><td>ctrl + shift + /</td><td>向后删除一个字符</td></tr><tr><td>ctrl + u</td><td>撤销上一个命令，相当于清空当前行</td></tr><tr><td>ctrl + d</td><td>删除当前光标所在字符</td></tr><tr><td>ctrl + k</td><td>删除当前光标到行尾的所有字符</td></tr><tr><td>ctrl + i</td><td>自动补全，相当于敲<code>TAB</code></td></tr><tr><td>ctrl + j</td><td>结束当前行，相当于敲回车</td></tr><tr><td>ctrl + m</td><td>结束当前行，相当于敲回车</td></tr></tbody></table>\n<ul><li>任何时候 <code>tab</code> 键，会根据当前的输入给出提示</li><li>命令后敲 <code>-</code> 或 <code>--</code> ，然后按 <code>tab</code> 键，可以展示出此命令具体的选项</li></ul>\n<p><strong>后台异步命令相关快捷键</strong></p>\n<ul><li>ctrl + c: 终止当前命令</li><li>ctrl + z: 挂起当前命令，后续可以 bg/fg 重新支持此命令，或 kill 掉</li><li>ctrl + a: 回到行首</li><li>ctrl + e: 回到行尾</li></ul>\n<h2><a id=\"Jvm_666\"></a>六、Jvm相关命令</h2>\n<table><thead><tr><th>jvm相关命令</th><th>说明</th></tr></thead><tbody><tr><td>dashboard</td><td>仪表板，可以显示：线程，内存，堆栈，GC，Runtime等信息</td></tr><tr><td>thread</td><td>显示线程信息</td></tr><tr><td>jvm</td><td>与JVM相关的信息</td></tr><tr><td>sysprop</td><td>显示系统属性信息，也可以修改某个属性</td></tr><tr><td>sysenv</td><td>查看JVM环境变量的值</td></tr><tr><td>vmoption</td><td>查看JVM中选项，可以修改</td></tr><tr><td>getstatic</td><td>获取静态成员变量</td></tr><tr><td>ognl</td><td>执行一条ognl表达式，对象图导航语言</td></tr></tbody></table>\n<h3><a id=\"1dashboard_679\"></a>1、<code>dashboard</code>：实时数据面板</h3>\n<blockquote>\n<p>查看当前系统的实时数据面板。</p>\n</blockquote>\n<pre><code class=\"prism language-bash\">dashboard\n</code></pre>\n<p>输入 <code>q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令</p>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3041522a015e4ad1afc916cfb071a3f9.png\"/>\n<p>数据说明：</p>\n<ul><li><code>ID</code>：Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应</li><li><code>NAME</code>：线程名</li><li><code>GROUP</code>：线程组名</li><li><code>PRIORITY</code>：线程优先级, 1~10之间的数字，越大表示优先级越高</li><li><code>STATE</code>：线程的状态</li><li><code>CPU%</code>：线程消耗的cpu占比，采样100ms，将所有线程在这100ms内的cpu使用量求和，再算出每个线程的cpu使用占比。</li><li><code>TIME</code>：线程运行总时间，数据格式为<code>分：秒</code></li><li><code>INTERRUPTED</code>：线程当前的中断位状态</li><li><code>DAEMON</code>：是否是daemon线程</li></ul>\n<h3><a id=\"2Thread_703\"></a>2、<code>Thread</code>：线程相关堆栈信息</h3>\n<blockquote>\n<p>线程相关堆栈信息。</p>\n</blockquote>\n<p>参数说明</p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>数字</td><td>线程id</td></tr><tr><td>[n:]</td><td>指定最忙的前N个线程并打印堆栈</td></tr><tr><td>[b]</td><td>找出当前阻塞其他线程的线程</td></tr><tr><td>[i &lt;value&gt;]</td><td>指定cpu占比统计的采样间隔，单位为毫秒</td></tr></tbody></table>\n<p>Arthas支持管道，可以用 <code>thread 1 | grep 'main('</code> 查找到<code>main class</code>。</p>\n<pre><code class=\"prism language-bash\">thread <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">'main('</span>\n</code></pre>\n<pre><code class=\"prism language-shell\">thread\t\t\t\t<span class=\"token comment\">#\t显示所有线程的信息</span>\nthread <span class=\"token number\">1</span>\t\t\t<span class=\"token comment\">#\t显示1号线程的运行堆栈</span>\nthread -b\t\t\t<span class=\"token comment\">#\t查看阻塞的线程信息</span>\nthread -n <span class=\"token number\">3</span>\t\t\t<span class=\"token comment\">#\t查看最忙的3个线程，并打印堆栈</span>\nthread -i <span class=\"token number\">1000</span> -n <span class=\"token number\">3</span>\t<span class=\"token comment\">#\t指定采样时间间隔，每过1000毫秒采样，显示最占时间的3个线程</span>\n</code></pre>\n<pre><code class=\"prism language-shell\">查看处于等待状态的线程（WAITING、BLOCKED）\nthread --state WAITING\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\72e881fb897e4efa8541e177fd939422.png\"/>\n<p><strong>死锁线程查看</strong></p>\n<pre><code class=\"prism language-shell\">thread\t\t<span class=\"token comment\"># 查看线程状态</span>\nthread -b\t<span class=\"token comment\">#\t查看阻塞的线程信息</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\67553935276b4608a105bf092816ba3e.png\"/>\n<h3><a id=\"3jvm_750\"></a>3、<code>jvm</code></h3>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0df65819312848c5b4a3dab9b2fb9586.png\"/>\n<p><strong>THREAD相关</strong></p>\n<ul><li><code>COUNT</code>：JVM当前活跃的线程数</li><li><code>DAEMON-COUNT</code>： JVM当前活跃的守护线程数</li><li><code>PEAK-COUNT</code>：从JVM启动开始曾经活着的最大线程数</li><li><code>STARTED-COUNT</code>：从JVM启动开始总共启动过的线程次数</li><li><code>DEADLOCK-COUNT</code>：JVM当前死锁的线程数</li></ul>\n<p><strong>文件描述符相关</strong></p>\n<ul><li><code>MAX-FILE-DESCRIPTOR-COUNT</code>：JVM进程最大可以打开的文件描述符数</li><li><code>OPEN-FILE-DESCRIPTOR-COUNT</code>：JVM当前打开的文件描述符数</li></ul>\n<h3><a id=\"4sysprop_769\"></a>4、<code>sysprop</code>：查看/修改属性</h3>\n<pre><code class=\"prism language-shell\">sysprop\t\t\t\t\t\t<span class=\"token comment\">#\t查看所有属性</span>\nsysprop java.version\t\t<span class=\"token comment\">#\t查看单个属性，支持通过tab补全</span>\n</code></pre>\n<p>修改某个属性</p>\n<pre><code class=\"prism language-shell\">sysprop user.country\nuser.country<span class=\"token operator\">=</span>US\n</code></pre>\n<h3><a id=\"5sysenvJVM_783\"></a>5、<code>sysenv</code>：查看JVM环境属性</h3>\n<blockquote>\n<p>查看当前JVM的环境属性(<code>System Environment Variables</code>)</p>\n</blockquote>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 查看所有环境变量</span>\nsysenv\n<span class=\"token comment\"># 查看单个环境变量</span>\nsysenv <span class=\"token environment constant\">USER</span>\n</code></pre>\n<h3><a id=\"6vmpotionJVM_796\"></a>6、<code>vmpotion</code>：查看JVM中选项</h3>\n<blockquote>\n<p>查看JVM中选项，可以修改</p>\n</blockquote>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t查看所有的选项</span>\nvmoption\n<span class=\"token comment\">#\t查看指定的选项</span>\nvmoption PrintGCDetails\n<span class=\"token comment\">#\t更新指定的选项</span>\nvmoption PrintGCDetails <span class=\"token boolean\">true</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\727c6d748461490cada56c595aad209d.png\"/>\n<p>更新某一个值</p>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\353be06dd824486d84831b0ec3f67c3a.png\"/>\n<h3><a id=\"7getstatic_815\"></a>7、<code>getstatic</code>：获取静态成员变量</h3>\n<blockquote>\n<p>获取静态成员变量</p>\n</blockquote>\n<p>实例：</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t语法</span>\ngetstatic 类名 属性名\n<span class=\"token comment\">#\t显示demo.MathGame类中静态属性random</span>\ngetstatic demo.MathGame random\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9c985d2219d24683899f7e8de9875b55.png\"/>\n<h3><a id=\"8ognlognl_832\"></a>8、<code>ognl</code>：执行ognl表达式</h3>\n<blockquote>\n<p>执行ognl表达式，这是从3.0.5版本新增的功能。</p>\n</blockquote>\n<p>参数说明</p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>express</em></td><td>执行的表达式</td></tr><tr><td><code>[c:]</code></td><td>执行表达式的 ClassLoader 的 hashcode，默认值是SystemClassLoader</td></tr><tr><td>[x]</td><td>结果对象的展开层次，默认值1</td></tr></tbody></table>\n<p>举例：<br/> 调用静态函数</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t获取系统变量中值，并且打印(只会打印有返回值函数)</span>\nognl <span class=\"token string\">'@java.lang.System@out.println(\"hello\")'</span>\n</code></pre>\n<p>获取静态类的静态字段</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t获取代码中的运行返回值</span>\nognl <span class=\"token string\">'@demo.MathGame@random'</span>\n</code></pre>\n<p>执行多行表达式，赋值给临时变量，返回一个List</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t计算value1、value2值，并存在List集合中</span>\nognl <span class=\"token string\">'#value1=@System@getProperty(\"java.home\"), #value2=@System@getProperty(\"java.runtime.name\"), {#value1, #value2}'</span>\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b742f3780d56429a9fd24eeb70c30982.png\"/>\n<h2><a id=\"classclassLoader_865\"></a>七、类和类加载器(class/classLoader)</h2>\n<table><thead><tr><th>类，类加载相关的命令</th><th>说明</th></tr></thead><tbody><tr><td>sc</td><td>Search Class 查看运行中的类信息</td></tr><tr><td>sm</td><td>Search Method 查看类中方法的信息</td></tr><tr><td>jad</td><td>反编译字节码为源代码</td></tr><tr><td>mc</td><td>Memory Compile 将源代码编译成字节码</td></tr><tr><td>redefine</td><td>将编译好的字节码文件加载到jvm中运行</td></tr></tbody></table>\n<h3><a id=\"1sc_875\"></a>1、<code>sc</code>：查看类信息</h3>\n<blockquote>\n<p>查看类的信息(sc: Search Class)</p>\n<p>查看JVM已加载的类信息，“Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息</p>\n<p>sc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开<code>options disable-sub-class true</code>开关。</p>\n</blockquote>\n<p>参数说明：</p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配，支持全限定名，如com.taobao.test.AAA，也支持com/taobao/test/AAA这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把<code>/</code>替换为<code>.</code>啦。</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[d]</td><td>输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。 如果一个类被多个ClassLoader所加载，则会出现多次</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td>[f]</td><td>输出当前类的成员变量信息（需要配合参数-d一起使用）</td></tr></tbody></table>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t模糊搜索，demo包下所有的类</span>\nsc demo.*\n<span class=\"token comment\">#\t打印类的详细信息</span>\nsc -d demo.MathGame\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2da1523ee53c4d99b6f6a22988bba308.png\"/>\n<h3><a id=\"2sm_904\"></a>2、<code>sm</code>：查看已加载方法信息</h3>\n<blockquote>\n<p>查看已加载方法信息(“Search-Method” )</p>\n<p>查看已加载类的方法信息“Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。</p>\n<p><code>sm</code> 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。</p>\n</blockquote>\n<p>参数配置</p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[d]</td><td>展示每个方法的详细信息</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table>\n<h3><a id=\"_921\"></a></h3>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t显示String类加载的方法</span>\nsm java.lang.String\n<span class=\"token comment\"># \t查看方法信息</span>\nsm demo.MathGame\n<span class=\"token comment\"># \t查看方法信息(详细信息-d)</span>\nsm -d demo.MathGame\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c42671aa98444e4abaa20c883e57be1d.png\"/>\n<h3><a id=\"3jadmcredefine_934\"></a>3、编译与反编译<code>jad</code>、<code>mc</code>、<code>redefine</code></h3>\n<table><thead><tr><th>类相关的命令</th><th>说明</th></tr></thead><tbody><tr><td>jad</td><td>反编译字节码文件得到java的源代码</td></tr><tr><td>mc</td><td>在内存中将源代码编译成字节码</td></tr><tr><td>redefine</td><td>将字节码文件重新加载到内存中执行</td></tr></tbody></table>\n<h4><a id=\"31_jad_942\"></a>3.1 <code>jad</code>：反编译已加载类源码</h4>\n<blockquote>\n<p>反编译指定已加载类源码</p>\n<p><code>jad</code> 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；</p>\n<p>在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</p>\n<p>当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解</p>\n</blockquote>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t反编译MathGame方法</span>\njad demo.MathGame\n<span class=\"token comment\">#\t反编绎时只显示源代码(排除ClassLoader信息)。</span>\n<span class=\"token comment\">#\t默认情况下，反编译结果里会带有ClassLoader信息，通过--source-only选项，可以只打印源代码。方便和mc/redefine命令结合使用。</span>\njad --source-only demo.MathGame\n<span class=\"token comment\">#\t反编译到指定文件中</span>\njad --source-only demo.MathGame <span class=\"token operator\">&gt;</span> Hello.java\n<span class=\"token comment\">#\t只反编译mathGame类型中main方法</span>\njad demo.MathGame main\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\533fb84203f34731b773a362b790e356.png\"/>\n<h4><a id=\"32_mcJava_974\"></a>3.2 <code>mc</code>：编译Java代码</h4>\n<blockquote>\n<p>内存编译</p>\n<p>Memory Compiler/内存编译器，编译<code>.java</code>文件生成<code>.class</code></p>\n</blockquote>\n<p>案例：</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t在内存中编译Hello.java为Hello.class</span>\n<span class=\"token function\">mc</span> /root/Hello.java\n<span class=\"token comment\">#\t可以通过-d命令指定输出目录</span>\n<span class=\"token function\">mc</span> -d /root/bbb /root/Hello.java\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4a0ea8d3541240068925378cf600e7cb.png\"/>\n<h4><a id=\"33_redefineclass_991\"></a>3.3 <code>redefine</code>：加载外部<code>.class</code>文件</h4>\n<blockquote>\n<p>加载外部的<code>.class</code>文件，redefine到JVM里</p>\n<p>注意， redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field）。<br/> <code>reset</code>命令对<code>redefine</code>的类无效。如果想重置，需要<code>redefine</code>原始的字节码。<br/> <code>redefine</code>命令和<code>jad</code>/<code>watch</code>/<code>trace</code>/<code>monitor</code>/<code>tt</code>等命令会冲突。执行完<code>redefine</code>之后，如果再执行上面提到的命令，则会把<code>redefine</code>的字节码重置。</p>\n</blockquote>\n<p><strong>redefine的限制</strong></p>\n<ul><li>不允许新增加field/method</li><li>正在跑的函数，没有退出不能生效，比如下面新增加的<code>System.out.println</code>，只有<code>run()</code>函数里的会生效。</li></ul>\n<p><strong>使用步骤：</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t1. 使用jad反编译demo.MathGame输出到/root/MathGame.java</span>\njad --source-only demo.MathGame <span class=\"token operator\">&gt;</span> /root/MathGame.java\n</code></pre>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t2.按上面的代码编辑完毕以后，使用mc内存中对新的代码编译</span>\n<span class=\"token function\">mc</span> /root/MathGame.java -d /root\n</code></pre>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t3.使用redefine命令加载新的字节码</span>\nredefine /root/demo/MathGame.class\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\54e3f01a05ba4f9f95ba66d7a050a7de.png\"/>\n<h3><a id=\"4dump_1025\"></a>4、<code>dump</code>：保存已加载字节码文件到本地</h3>\n<blockquote>\n<p>将已加载类的字节码文件保存在特定目录:<code>logs/arthas/classdump</code></p>\n<p>不同的类加载器放在不同的目录下。</p>\n<p>dump作用：将正在JVM中运行的程序的字节码文件提取出来，保存在logs相应的目录下</p>\n</blockquote>\n<p><strong>参数：</strong></p>\n<table><thead><tr><th>数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><code>[c:]</code></td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t把String类的字节码文件保存到~/logs/arthas/classdump/目录下</span>\ndump java.lang.String\n<span class=\"token comment\">#\t把demo包下所有的类的字节码文件保存到~/logs/arthas/classdump/目录下</span>\ndump demo.*\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7934dfa05caf47399770faa14fc30dd7.png\"/>\n<h3><a id=\"5classloader_1058\"></a>5、<code>classloader</code>：获取类加载器的信息</h3>\n<blockquote>\n<p>获取类加载器的信息</p>\n</blockquote>\n<p><strong>作用：</strong></p>\n<ol><li> <p><code>classloader</code> 命令将 JVM 中所有的classloader的信息统计出来，并可以展示继承树，urls等。</p> </li><li> <p>可以让指定的classloader去getResources，打印出所有查找到的resources的url。对于<code>ResourceNotFoundException</code>异常比较有用。</p> </li></ol>\n<p><strong>参数说明</strong></p>\n<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>[l]</td><td>按类加载实例进行统计</td></tr><tr><td>[t]</td><td>打印所有ClassLoader的继承树</td></tr><tr><td>[a]</td><td>列出所有ClassLoader加载的类，请谨慎使用</td></tr><tr><td><code>[c:]</code></td><td>ClassLoader的hashcode</td></tr><tr><td><code>[c: r:]</code></td><td>用ClassLoader去查找resource</td></tr><tr><td><code>[c: load:]</code></td><td>用ClassLoader去加载指定的类</td></tr></tbody></table>\n<p><strong>案例：</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t默认按类加载器的类型查看统计信息</span>\nclassloader\n</code></pre>\n<img alt=\"img\" src=\"..\\..\\static\\image\\051929200ce342bfa3cac3433a6bc154.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t按类加载器的实例查看统计信息，可以看到类加载的hashCode</span>\nclassloader -l\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\16a1196a097b48b28ab3e06072ac82cc.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t查看ClassLoader的继承树</span>\nclassloader -t\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\bbb97bec674a463f994a5edba6d88a42.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t通过类加载器的hash，查看此类加载器实际所在的位置</span>\nclassloader -c 680f2737\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\9826c9cdd2bf4995aad11da50931382e.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t使用ClassLoader去查找指定资源resource所在的位置</span>\nclassloader -c 680f2737 -r META-INF/MANIFEST.MF\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\9742a4124f4049c8ab283652ee4e98ac.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t使用ClassLoader去查找类的class文件所在的位置</span>\nclassloader -c 680f2737 -r java/lang/String.class\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\065c29de05e645849686ae035d4050e4.png\"/>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t使用ClassLoader去加载类</span>\nclassloader -c 70dea4e --load java.lang.String\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\2e546a76b4cb4126ab98ba02f94c8862.png\"/>\n<p><strong>classloader命令主要作用有哪些？</strong></p>\n<ol><li>显示所有类加载器的信息</li><li>获取某个类加载器所在的jar包</li><li>获取某个资源在哪个jar包中</li><li>加载某个类</li></ol>\n<h2><a id=\"option_1141\"></a>八、<code>option</code>全局选项</h2>\n<blockquote>\n<p>：查看或设置arthas全局环境变量</p>\n</blockquote>\n<table><thead><tr><th>名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>unsafe</td><td>false</td><td>是否支持对系统级别的类进行增强，打开该开关可能导致把JVM搞挂，请慎重选择！</td></tr><tr><td>dump</td><td>false</td><td>是否支持被增强了的类dump到外部文件中，如果打开开关，class文件会被dump到<code>/${application dir}/arthas-class-dump/</code>目录下，具体位置详见控制台输出</td></tr><tr><td>batch-re-transform</td><td>true</td><td>是否支持批量对匹配到的类执行retransform操作</td></tr><tr><td>json-format</td><td>false</td><td>是否支持json化的输出</td></tr><tr><td>disable-sub-class</td><td>false</td><td>是否禁用子类匹配，默认在匹配目标类的时候会默认匹配到其子类，如果想精确匹配，可以关闭此开关</td></tr><tr><td>debug-for-asm</td><td>false</td><td>打印ASM相关的调试信息</td></tr><tr><td>save-result</td><td>false</td><td>是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到<code>~/logs/arthas-cache/result.log</code>中</td></tr><tr><td>job-timeout</td><td>1d</td><td>异步后台任务的默认超时时间，超过这个时间，任务自动停止；比如设置 1d, 2h, 3m, 25s，分别代表天、小时、分、秒</td></tr><tr><td>print-parent-fields</td><td>true</td><td>是否打印在parent class里的filed</td></tr></tbody></table>\n<p>查看所有<code>options</code>值</p>\n<pre><code class=\"prism language-shell\">options\n</code></pre>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\0f92ccd5a8a54827a669e115a24f30ec.png\"/>\n<p>查询/更新单个option值</p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#\t查看默认值</span>\noptions save-result\n<span class=\"token comment\">#\t更新默认值</span>\noptions save-result <span class=\"token boolean\">true</span>\n<span class=\"token comment\">#\t查看更新后值</span>\noptions save-result\n</code></pre>\n<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\181730efc070418c86e01635c27812e6.png\"/>\n<h2><a id=\"profiler_1178\"></a>九、<code>profiler</code>火焰图</h2>\n<blockquote>\n<p><code>profiler</code> 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</p>\n</blockquote>\n<p><strong>常用命令</strong></p>\n<table><thead><tr><th>profiler</th><th>命令作用</th></tr></thead><tbody><tr><td>profiler start</td><td>启动profiler，默认情况下，生成cpu的火焰图</td></tr><tr><td>profiler list</td><td>显示所有支持的事件</td></tr><tr><td>profiler getSamples</td><td>获取已采集的sample的数量</td></tr><tr><td>profiler status</td><td>查看profiler的状态，运行的时间</td></tr><tr><td>profiler stop</td><td>停止profiler，生成火焰图的结果，指定输出目录和输出格式：svg或html</td></tr></tbody></table>\n<p><strong>启动<code>profiler</code></strong></p>\n<pre><code class=\"prism language-shell\">profiler start\n</code></pre>\n<blockquote>\n<p>默认情况下，生成的是cpu的火焰图，即event为<code>cpu</code>。可以用<code>--event</code>参数来指定。</p>\n</blockquote>\n<p><strong>显示支持的事件</strong></p>\n<pre><code class=\"prism language-shell\">profiler list\n</code></pre>\n<p><strong>获取已采集的<code>sample</code>的数量</strong></p>\n<pre><code class=\"prism language-shell\">profiler getSamples\n</code></pre>\n<p><strong>查看<code>profiler</code>状态</strong>(可以查看当前<code>profiler</code>在采样哪种<code>event</code>和采样时间。)</p>\n<pre><code class=\"prism language-shell\">profiler status\n</code></pre>\n<p><strong>停止<code>profiler</code>，并同步生成文件</strong>（默认在<code>工作目录</code>下的<code>arthas-output</code>目录。）</p>\n<pre><code class=\"prism language-shell\">$ profiler stop\nprofiler output file: /tmp/demo/arthas-output/20191125-135546.svg\n</code></pre>\n<p><strong>通过 <code>--file</code>参数来指定输出结果路径</strong></p>\n<pre><code># 指定生成的文件名以及路径\nprofiler stop --file /tmp/result.svg\n</code></pre>\n<p><strong>可以用<code>--format</code>指定生成格式</strong></p>\n<pre><code class=\"prism language-shell\">profiler stop --format html\n</code></pre>\n<p>生成的图</p>\n<img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\0433a00bc31f4ffdbacde423ab224758.png\"/>\n<p><strong>火焰图的含义</strong></p>\n<p>火焰图是基于 perf 结果产生的SVG 图片，用来展示 CPU 的调用栈。</p>\n<blockquote>\n<p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p>\n<p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p>\n<p><strong>火焰图就是看顶层的哪个函数占据的宽度最大。只要有\"平顶\"（plateaus），就表示该函数可能存在性能问题。</strong></p>\n<p>颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p>\n</blockquote>\n<h2><a id=\"_1256\"></a>十、相关文件</h2>\n<h3><a id=\"1_1258\"></a>1、配套资料</h3>\n<p><a href=\"https://download.csdn.net/download/weixin_44624117/85612648\">CSDN</a></p>\n<pre><code>https://download.csdn.net/download/weixin_44624117/85612648\n</code></pre>\n<h3><a id=\"2Xmind_1266\"></a>2、Xmind整理资料</h3>\n<p><a href=\"https://download.csdn.net/download/weixin_44624117/85612661\">Xmind</a></p>\n<pre><code>https://download.csdn.net/download/weixin_44624117/85612661\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-06-11 20:52:59", "summary": "文章目录一、简介、简介、项目所在位置二、安装、安装、卸载、首次启动。三、核心监视功能、：监控方法的执行情况、：检测函数返回值、：根据路径追踪，并记录消耗时间、：输出当前方法被调用的调用路径、：时间隧道"}