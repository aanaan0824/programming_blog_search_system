{"blogid": "126405605", "writerAge": "码龄1年", "writerBlogNum": "40", "writerCollect": "9", "writerComment": "10", "writerFan": "5", "writerGrade": "3级", "writerIntegral": "430", "writerName": "那只猫喝咖啡", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126405605.jpg", "writerRankTotal": "40228", "writerRankWeekly": "9000", "writerThumb": "20", "writerVisitNum": "9426", "blog_read_count": "902", "blog_time": "于 2022-09-04 21:23:08 发布", "blog_title": "浅谈Vue中render函数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" height=\"111\" src=\"..\\..\\static\\image\\39165c2a85bf4e3588a9dac02604c1e9.png\" width=\"511\"/></p>\n<p> 首先我们引入的vue并不是一个完整的，而是残缺版的vue(没有模板解析器)</p>\n<h3>那如何证明？</h3>\n<p><img alt=\"\" height=\"216\" src=\"..\\..\\static\\image\\35ec312c161a4b99ab39baaf9944d658.png\" width=\"522\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"44\" src=\"..\\..\\static\\image\\40e8e5a019ed419b88d91aec8f04160a.png\" width=\"656\"/></p>\n<p>翻译如下： </p>\n<p><img alt=\"\" height=\"75\" src=\"..\\..\\static\\image\\2ca3a048d8734d8da2fb1076128bd1c2.png\" width=\"606\"/></p>\n<p> <strong>大概意思是说功能不全，没有模板解析器</strong>。并且提供建议给你：<strong>1.使用render函数 2.引入带有模板解析器的vue(完整的vue)</strong>，那意思就是说vue并没有引入完整？为什么？</p>\n<p>    我们就需要去依赖的地方看看到底有没有完整引入。由于我们在引入的时候，地址直接写的就是vue，但是vue下还有很多路径</p>\n<p><img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\409b9f08dfa24aa58acaf627e0a0a824.png\" width=\"625\"/></p>\n<p> module的意思就是如果使用的es6的模块化引入方式，就使用   dist/vue.runtime.esm.js</p>\n<p>import的确是es6的引入方式。这里面就是残缺版的没有模板解析器的vue。</p>\n<h3>如何解决？</h3>\n<blockquote>\n<p>render(createElement){<!-- --></p>\n<p>        这个函数有返回值，需要return 并且这个参数createElement是一个函数，该函数可创建具体的节点//</p>\n<p>        return createElement('span','我是span')</p>\n<p>        }</p>\n</blockquote>\n<p>那他和正常的默认生成的还是有区别的，我们先看一下常规的render函数</p>\n<p><img alt=\"\" height=\"178\" src=\"..\\..\\static\\image\\a750fbed9ead448dbe7c7a1ca61041c3.png\" width=\"343\"/>仅仅只是一行render:h=&gt;h(App)</p>\n<p>我们可以根据上方代码写成箭头函数并简写形式(仅有一个参数去掉括号，return去掉改为一行)</p>\n<blockquote>\n<p>render:createElement =&gt; createElement('span','我是span')        </p>\n</blockquote>\n<p> 接下来将参数改成h或者任意字母就和上图相似了</p>\n<pre><code>render:h=&gt;h('span','我是span')</code></pre>\n<p>于是我们发现这样就显示出来了，如下图↓        ↓        ↓        ↓       </p>\n<p> <img alt=\"\" height=\"122\" src=\"..\\..\\static\\image\\5dec650e549a4f6a9cc777ed7bfbdfbd.png\" width=\"404\"/></p>\n<h3> 那我们为什么不采用报错提示中的第二种方式引入完整的vue呢？</h3>\n<p>vue是由两部分组成的，</p>\n<p>       <strong> 1：vue核心：包含生命周期，处理事件...</strong></p>\n<p><strong>        2.   模板解析器</strong></p>\n<p>如果合在一起，模板解析器体积占总体积的1/3，webpack在进行打包时会生成一个大的文件夹，本身模板解析器是不需要打包的，因为webpack已经将.vue文件变成了html,js,css，解析器就不再需要了。</p>\n<h3>问题来了，为什么我们创建了一个app节点而且不需要加值就可以显示出来内容呢？</h3>\n<p><img alt=\"\" height=\"234\" src=\"..\\..\\static\\image\\387c177ac42043629565b750142da675.png\" width=\"460\"/></p>\n<p> 为啥template放在组件里就可以被解析呢？？？这是因为有一个插件所解决的</p>\n<p><img alt=\"\" height=\"268\" src=\"..\\..\\static\\image\\4e738fc38d6e457093a77f1832316577.png\" width=\"645\"/></p>\n<h1> 总结：</h1>\n<p><span style=\"color:#1a439c;\">        vue.js和vue.runtime.xxx.js的区别</span></p>\n<p><span style=\"color:#1a439c;\">        （1）vue.js是完整版的Vue。包含：核心功能+模板解析器</span></p>\n<p><span style=\"color:#1a439c;\">        （2）vue.runtime.xxx.js是运行版的Vue，只包含核心功能</span></p>\n<p><span style=\"color:#1a439c;\">因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容</span></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-04 21:23:08", "summary": "首先我们引入的并不是一个完整的，而是残缺版的没有模板解析器那如何证明？翻译如下：大概意思是说功能不全，没有模板解析器。并且提供建议给你：使用函数引入带有模板解析器的完整的，那意思就是说并没有引入完整？"}