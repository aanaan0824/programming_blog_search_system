{"blogid": "126743169", "writerAge": "码龄24天", "writerBlogNum": "53", "writerCollect": "1", "writerComment": "0", "writerFan": "47", "writerGrade": "3级", "writerIntegral": "530", "writerName": "web13057963918", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743169.jpg", "writerRankTotal": "39094", "writerRankWeekly": "11322", "writerThumb": "0", "writerVisitNum": "2415", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:26:40 发布", "blog_title": "JVM - 程序计数器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_JVM_2\"></a># <code>JVM</code>程序计数器</h2>\n<blockquote>\n<p><code>JDK</code>版本：<code>1.8</code></p>\n</blockquote>\n<h3><a id=\"_1Program_Counter_Register__7\"></a># 1、程序计数器(<code>Program Counter Register</code> )</h3>\n<p><code>JVM</code>中的程序计数寄存器(<code>Program Counter Register</code>)中，<code>Register</code>的命名源于<code>CPU</code>的寄存器，寄存器存储指令相关的现场信息。<code>CPU</code>只有把数据装载到寄存器才能够运行。这里并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<code>JVM</code>中的<code>PC</code>寄存器是对物理<code>PC</code>寄存器的一种抽象模拟。</p>\n<p><img alt=\"pc寄存器\" src=\"..\\..\\static\\image\\f7c98db8811f40ff8e80303d37f48151.png\"/></p>\n<p><code>PC</code>寄存器用于存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令：</p>\n<p><img alt=\"pc寄存器工作流程图\" src=\"..\\..\\static\\image\\d949ce7b9a6a45e3bad016d3bea58d9d.png\"/></p>\n<ul><li> <p><code>PC</code>寄存器是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p> </li><li> <p>在<code>JVM</code>规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p> </li><li> <p>任何事件一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的<code>Java</code>方法的<code>JVM</code>指令地址，如果是在执行<code>native</code>方法，则是未指定值(<code>undefined</code>)。</p> </li><li> <p><code>PC</code>寄存器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p> </li><li> <p>字节码解释器工作时就是通过改变<code>PC</code>寄存器的值来选取下一条需要执行的字节码指令。</p> </li><li> <p><code>PC</code>寄存器是唯一一个在<code>Java</code>虚拟机规范中没有规定任何<code>OutOfMemeoryError</code>情况的区域。</p> </li></ul>\n<hr/>\n<h3><a id=\"_2PC_32\"></a># 2、<code>PC</code>寄存器代码举例</h3>\n<pre><code>public class ProgramCounterRegister {\n\n    public static void main(String[] args) {\n        int minus = minus();\n        System.out.println(\"minus = \" + minus);\n    }\n\n    private static int minus() {\n        int i = 3;\n        int j = 4;\n        return j - i;\n    }\n\n}\n</code></pre>\n<p>字节码文件：</p>\n<pre><code>0: iconst_3\n1: istore_1\n2: iconst_4\n3: istore_2\n4: iload_1\n5: iload_2\n6: isub\n7: ireturn\n</code></pre>\n<hr/>\n<h3><a id=\"_3PC_64\"></a># 3、<code>PC</code>寄存器的作用</h3>\n<p><img alt=\"线程与java执行引擎\" src=\"..\\..\\static\\image\\a82595911dfb4b67a481ab3e5e722821.png\"/></p>\n<p>在多线程的情况下，<code>CPU</code>需要不停的切换各个线程，当从<code>A</code>线程切换到<code>B</code>线程之后，<code>CPU</code>需要知道接着从哪里开始继续执行代码。</p>\n<p><code>JVM</code>的字节码解释器就是需要通过改变<code>PC</code>寄存器的值来明确下一条应该执行什么样的字节码指令。</p>\n<hr/>\n<h3><a id=\"_4PC_74\"></a># 4、<code>PC</code>寄存器为什么被设定为线程私有</h3>\n<p>所谓的多线程，其实<code>CPU</code>在一个时间点只能执行某一个线程的方法，也就是说<code>CPU</code>需要在多线程之间不停地做任务切换，这样必然会导致经常中断或恢复。为了能够准确地记录各个线程正在执行的当前字节码指令地址，<code>JVM</code>会为每个线程都分配一个<code>PC</code>寄存器，这样就能解决各个线程之间的独立计算，也不会出现线程之间互相干扰的情况。</p>\n<p>由于<code>CPU</code>时间片轮限制，众多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条字节码指令。这样也会导致中断或恢复，为了确保<code>CPU</code>在线程之间的切换分毫无差，<code>JVM</code>在每个线程创建之后，都会产生线程独有的<code>PC</code>计数器和栈帧，保证各个线程之间互不影响。</p>\n<hr/>\n<h3><a id=\"_5CPU_82\"></a># 5、<code>CPU</code>时间片</h3>\n<p><code>CPU</code>时间片：<code>CPU</code>分配给各个应用程序的执行时间，每个线程被分配一个时间段，称作它的时间片。</p>\n<p>在宏观上：开发者可以同时打开多个应用程序，每个程序互不影响，并行执行。</p>\n<p>在微观上：由于只有一个<code>CPU</code>，一次只能处理程序要求的一部分，如何公平分配<code>CPU</code>，此时就需要借助时间片，让每个程序轮流并行执行。</p>\n<p><img alt=\"cpu时间片\" src=\"..\\..\\static\\image\\9026ddb60c9c440a8f6ee4d6596305b6.png\"/></p>\n<p><a href=\"https://github.com/kapbc/Java-Kapcb\">GitHub源码地址</a>：<code>https://github.com/kapbc/Java-Kapcb/tree/master/src/main/java/com/kapcb/ccc/jvm</code></p>\n<blockquote>\n<p>备注：此文为笔者学习<code>JVM</code>的笔记，鉴于本人技术有限，文中难免出现一些错误，感谢大家批评指正。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:26:40", "summary": "程序计数器版本：、程序计数器中的程序计数寄存器中，的命名源于的寄存器，寄存器存储指令相关的现场信息。只有把数据装载到寄存器才能够运行。这里并非是广义上所指的物理寄存器，或许将其翻译为计数器或指令计数器"}