{"blogid": "126465798", "writerAge": "码龄5年", "writerBlogNum": "82", "writerCollect": "202", "writerComment": "12", "writerFan": "80", "writerGrade": "4级", "writerIntegral": "839", "writerName": "马达加斯加D", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126465798.jpg", "writerRankTotal": "21366", "writerRankWeekly": "1645", "writerThumb": "26", "writerVisitNum": "40254", "blog_read_count": "7263", "blog_time": "已于 2022-08-30 03:51:53 修改", "blog_title": "计算机网络 --- TCP与UDP协议", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>计算机网络 --- TCP与UDP协议</h3>\n<ul><li><a href=\"#UDP_1\">UDP协议</a></li><li><a href=\"#TCP_12\">TCP协议</a></li><li><a href=\"#TCP_44\">TCP建立连接的三次握手</a></li><li><a href=\"#TCP_56\">TCP连接释放的四次挥手</a></li><li><a href=\"#TCP___69\">TCP的可靠传输 -- 滑动窗口</a></li><li><a href=\"#TCP_111\">TCP的拥塞避免算法</a></li><li><a href=\"#TCPIPUDP_119\">如何理解TCP/IP协议是面向数据流的，而UDP协议是面向数据报</a></li><li><a href=\"#TCP__SYN_flood_127\">TCP的安全 --- SYN flood攻击</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"UDP_1\"></a>UDP协议</h1>\n<blockquote>\n<ul><li>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。</li><li>也就是当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据</li><li>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响</li></ul>\n</blockquote>\n<blockquote>\n<ul><li>UDP协议的Header包括四个字段： <strong>1. 源端口 2. 目的端口 3. 长度 4. 校验码</strong></li></ul>\n<blockquote>\n<ul><li>源端口: 可选字段，表示发送方进程的端口，接收方可根据此字段（不一定准确）发送信息</li><li>目的端口: 目的端口是数据接收方的端口号，它只在目标的IP地址下才有效</li><li>长度: 长度是协议头和数据报中数据长度的总和，表示整个数据报的大小</li><li>校验码: 校验码使用 IP 首部、UDP 首部和数据报中的数据进行计算，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题</li></ul>\n</blockquote>\n</blockquote>\n<h1><a id=\"TCP_12\"></a>TCP协议</h1>\n<blockquote>\n<ul><li>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议. TCP协议建立的是一种点到点的，一对一的可靠连接，与UDP相比以牺牲效率为代价换取高可靠性的服务</li><li>无差错, 不丢失，不重复， 数据有序</li><li>TCP是双工的协议，会话的双方都可以同时接收、发送数据</li><li>TCP可以接收来自多个应用程序的数据流，用端口号标识他们，然后把他们送给Internet层处理；同时TCP接收来自Internet层的数据包，用端口号区分他们，然后交给不同的应用程序。（UDP同理)</li><li>TCP 报文格式：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\335f9b998ec8499c87a51febf3db8d24.png\"/></li></ul>\n</blockquote>\n<p><strong>序号(seq)</strong></p>\n<blockquote>\n<ul><li>长度为四个字节 [0, 4294967295]</li><li>TCP数据是字节流，每个字节都有唯一的序号</li><li>起始序号在建立TCP连接的时候设置</li><li>序号表示本报文段数据的第一个字节的序号</li></ul>\n</blockquote>\n<p><strong>确认号 (ack)</strong></p>\n<blockquote>\n<ul><li>长度为四个字节 [0, 4294967295]</li><li>期待收到对方下一个报文的第一个数据字节序号</li><li><strong>也就是如果确认号= N, 则序号N-1为止的所有数据都已经正确收到</strong></li></ul>\n</blockquote>\n<p><strong>控制位</strong>: 总共六个比特位</p>\n<blockquote>\n<ul><li>URG: Urgent, URG = 1，表示紧急数据</li><li>ACK：Acknowledgment，确认位，ACK = 1时确认号才生效**</li><li>PSH：Push推送位，PSH=1，尽快地把数据交付给应用层</li><li>RST：Reset重置位，RST= 1，重新建立连接</li><li>SYN：Synchronization：同步位， SYN=1 表示这是一个连接请求报文**</li><li>FIN： Finish：终止位，FIN=1 表示释放连接**</li></ul>\n</blockquote>\n<p><strong>窗口</strong></p>\n<blockquote>\n<ul><li>长度为两个字节 [0, 65535]</li><li>窗口指明允许对方发送的数据量</li><li>因为数据缓冲空间有限, 不能无线缓存数据</li></ul>\n</blockquote>\n<h1><a id=\"TCP_44\"></a>TCP建立连接的三次握手</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b62fc0d359e541ee8f43a75f91bc6e68.jpeg\"/></p>\n<blockquote>\n<ul><li>第一次: SYN = 1, 请求连接，并告诉对方自己的序列号</li><li>第二次: SYN = 1, ACK=1，确认对方数据并告诉对方自己的数据序列号</li><li>第三次: ACK = 1, 确认了对方的数据并开始传输数据</li></ul>\n</blockquote>\n<p><strong>为什么不能是两次握手</strong></p>\n<blockquote>\n<ul><li>如下图, 如果发起方的第一次连接请求迟迟没有得到回应，则会发出第二个请求</li><li>如果是两次握手， 则会建立两个连接，造成资源浪费和错误</li><li>三次握手可以保证发起方忽略第二个应答<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b7bcda6f9d2d4fa8bcbabed825817621.png\"/></li></ul>\n</blockquote>\n<h1><a id=\"TCP_56\"></a>TCP连接释放的四次挥手</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\07a2a162845a431db0bea1b25f18b62a.png\"/></p>\n<blockquote>\n<ul><li>第一次：FIN=1，seq=u 主动请求中断连接</li><li>第二次：ACK=1， ack=u+1， 表示确认收到中断报文，并发出最后需要发送的数据</li><li>第三次：FIN=1，ACK=1，seq=w, ack = u+1,请求中断连接</li><li>第四次：ACK=1，seq=u+1，ack=w+1 确认中断连接</li></ul>\n</blockquote>\n<p><strong>TIME-WAIT状态</strong></p>\n<blockquote>\n<ul><li>TIME-WAIT状态发生在第四次挥手之后，主动发尚未完全关闭TCP连接，端口不可复用</li><li>TIME-WAIT状态一般持续2MSL(四分钟), MSL为Max Segment Lifetime，最长报文段寿命，一般为两分钟</li></ul>\n<blockquote>\n<ul><li>因为最后一个报文是不会收到确认的，所以为了确定报文一定到达对方，需要一个等待时间。在2MSL的时间内，如果对方没有收到，则会重新进行第三次挥手。</li><li>同时确保之前的所有报文已经过期</li></ul>\n</blockquote>\n</blockquote>\n<h1><a id=\"TCP___69\"></a>TCP的可靠传输 – 滑动窗口</h1>\n<blockquote>\n<ul><li>因为需要保证可靠性，所以TCP协议需要接收方对每个收到的包进行ACK确认，而接收方只有收到上一个包对应的ACK包，才能继续发送下一个包</li><li>但是这样效率就会非常低，传输N个包就需要等待N次应答时间，总的传输时间=N份传输时间+N份应答传输时间</li><li>而滑动窗口协议可以解决这个问题，达到批量传输</li></ul>\n</blockquote>\n<p><strong>发送窗口</strong></p>\n<blockquote>\n<ul><li>滑动窗口 分为 <strong>发送窗口</strong> 和 <strong>接收窗口</strong>. 客户端和服务器端 都有一个 发送窗口 和 接收窗口</li><li><strong>发送窗口实际存在于操作系统中，是一块缓冲区</strong>，用来存放当前需要发送的数据。本质是一个循环数组的实现。利用三个指针来维护相关的区域。</li><li>“发送窗口”的大小取决于对端通告的“接收窗口”</li><li>应用层发送数据，就是往缓冲区中写入数据。收到ACK后，就相当于从缓冲区中移除数据，不过并不会真正移除数据，只需要后移对应的指针就可以了</li><li>应用层会将数据写入到缓冲区中，当超过缓冲区的最大地址后，就循环利用头部，覆盖头部的数据<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4574b7e5d01b4252b163ef2f3d9c0c3d.png\"/></li><li>如果这个时候接收一个ack包为37，这个时候发送窗口会向右边移动5位，52-56会变成可用窗口</li><li>如果发送方发出了ack37的包，意思是下一个需要接收的包是37，也就是37之前的数据全部接收到，即使没有收到ack32-36<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2fa1147a3e96482bad02e52b54cd923a.png\"/></li></ul>\n</blockquote>\n<p><strong>滑动窗口如何处理丢包</strong></p>\n<blockquote>\n<ul><li>ACK丢包：</li><li>如下图，1001这个ACK丢了，但是2001ACK却已经发送给主机A，说明1-1000这个数据也顺利到达，1001ACK丢了无所谓，只要当前序号开始，就说明之前的数据已经正确传输到达主机B<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fb289f8a63214dd2aa426f9a766785ea.png\"/></li></ul>\n</blockquote>\n<p>数据包丢包</p>\n<blockquote>\n<ul><li>如下图1001-2000数据包丢了，而2001-3000,3001-4000都顺利到达</li><li>此时主机B反馈的ACK确认序号始终是1001，主机A如果发现主机B连续发送ACK都是1001，主机A就明白1001-2000这个数据丢包，就会重新传送</li><li>当主机B重新收到丢失的1001-2000数据后，直接返回ACK4001，因为2001-4000已经接受过（都在缓冲区等待），接下来ACK直接从4001开始。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9ccbad0503c047bbafced364ec8bc72c.png\"/></li></ul>\n</blockquote>\n<p><strong>TCP窗口的拥塞处理</strong></p>\n<blockquote>\n<ul><li>TCP首部中有一个窗口字段（接收窗口的大小），接受方和发送方通过这个字段，告诉对方一次能够发送多少数据</li><li>当服务器忙于处理从多个客户端接收的报文， 服务器很有可能因为清理缓存而变得缓慢，无法腾出空间接收新的数据，如果没有流控，则可能会造成丢包和数据损坏。</li><li>所以当接收窗口所设定的速率无法使服务器 正常处理数据时，接收方会调整接收窗口大小。通过减小返回给发送端的ACK报文的TCP头窗口大小值来实现</li></ul>\n</blockquote>\n<blockquote>\n<ul><li>下图中，服务器初始窗口大小为5000字节。客户端发送2000字节，之后又发送了2000字节，缓冲区中只有1000字节可用。服务器意识到缓冲区正在快速填满，它知道如果数据继续以此速率传输，很快会有报文丢失。为了防止报文丢失，服务器发送确认信息给客户端，更新窗口大小为1000字节。结果，客户端减少数据发送，服务器以可以接受的速率处理缓存内容，即保持数据流以稳定的速率传输。</li><li>调整窗口大小在两个方向都是可行的。当服务器能够更加快速的处理报文时，它会发送一个较大窗口的ACK报文<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c5cbf28c6dce4679a2d26a9afccedd2c.png\"/></li></ul>\n</blockquote>\n<blockquote>\n<ul><li>某些情况下，服务器无法再处理从客户端发送的数据。可能是由于内存不足，处理能力不够，或其他原因。这可能会造成数据被丢弃以及传输暂停，但接收窗口能够帮助减小负面影响。</li><li>当上述情况发生时，服务器会发送窗口为0的报文。当客户端接收到此报文时，它会暂停所有数据传输，但会保持与服务器的连接以传输探测（keep-alive）报文。探测报文在客户端以稳定间隙发送，以查看服务器接收窗口状态。一旦服务器能够再次处理数据，将会返回非零值窗口大小，传输会恢复。下图示例了零窗口通知过程。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ef8bd539deca4d928f98e5923ed29605.png\"/></li></ul>\n</blockquote>\n<h1><a id=\"TCP_111\"></a>TCP的拥塞避免算法</h1>\n<p>主要包括</p>\n<blockquote>\n<ul><li>慢启动算法</li><li>拥塞避免算法</li><li>快重传算法</li><li>快恢复算法</li><li><a href=\"https://zhuanlan.zhihu.com/p/102382380\">详解: TCP的拥塞避免算法</a></li></ul>\n</blockquote>\n<h1><a id=\"TCPIPUDP_119\"></a>如何理解TCP/IP协议是面向数据流的，而UDP协议是面向数据报</h1>\n<blockquote>\n<ul><li><strong>TCP的报文为 segment</strong>. TCP是把数据看成一连串字节流，当应用层传下来的报文（message）太长了，TCP是会把报文切片的，所以TCP的segment的意思是说：我的segment可能是报文（message）的某一段.</li><li>通过TCP连接给另一端发送数据，你只调用了一次write， 发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完.<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dc68e8bb58b547d29ef1295c4ed54b97.png\"/></li></ul>\n</blockquote>\n<blockquote>\n<ul><li><strong>UDP的报文是datagram</strong>. UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层. 而对接收方，接到后直接去除首部，交给上面的应用层就完成任务.</li><li>UDP的发送端调用了几次write，接收端必须用相同次数的read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和 报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃.</li></ul>\n</blockquote>\n<h1><a id=\"TCP__SYN_flood_127\"></a>TCP的安全 — SYN flood攻击</h1>\n<blockquote>\n<ul><li>这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，使被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式</li><li>利用TCP三次握手的缺陷, 对服务器发送伪造大量的假TCP连接请求, 此时服务器会回复ACK确认报文, 然后等待攻击方第三次握手, 而攻击方忽略ACK确认报文, 一直不回复. 服务器会一直重发直至超时. 这些伪造的SYN包将长时间占用未连接队列，其他客户的正常的SYN请求不能被接收，目标系统运行缓慢，造成网络拥堵</li></ul>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-30 03:51:53", "summary": "计算机网络与协议协议协议建立连接的三次握手连接释放的四次挥手的可靠传输滑动窗口的拥塞避免算法如何理解协议是面向数据流的，而协议是面向数据报的安全攻击协议是无连接通信协议，即在数据传输时，数据的发送端和"}