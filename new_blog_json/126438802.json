{"blogid": "126438802", "writerAge": "码龄2年", "writerBlogNum": "60", "writerCollect": "1848", "writerComment": "2532", "writerFan": "2345", "writerGrade": "6级", "writerIntegral": "6552", "writerName": "头发没有代码多", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126438802.jpg", "writerRankTotal": "2533", "writerRankWeekly": "93", "writerThumb": "2284", "writerVisitNum": "45540", "blog_read_count": "297", "blog_time": "于 2022-08-23 08:00:00 发布", "blog_title": "C++——关键字|命名空间|输入&输出|缺省参数|函数重载|引用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88C%2B%2B98%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88C%2B%2B98%EF%BC%89\">C++关键字（C++98）</a></p>\n<p id=\"%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"> 命名空间</a></p>\n<p id=\"%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89%C2%A0\">命名空间定义 </a></p>\n<p id=\"%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8\"> 命名空间使用</a></p>\n<p id=\"%C2%A0C%2B%2B%E8%BE%93%E5%85%A5%26%E8%BE%93%E5%87%BA-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0C%2B%2B%E8%BE%93%E5%85%A5%26%E8%BE%93%E5%87%BA\"> C++输入&amp;输出</a></p>\n<p id=\"%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\"> 缺省参数</a></p>\n<p id=\"%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB\">缺省参数分类</a></p>\n<p id=\"%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\"> 全缺省参数</a></p>\n<p id=\"%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%C2%A0\">半缺省参数 </a></p>\n<p id=\"%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BE%8B%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BE%8B%C2%A0\">缺省参数实例 </a></p>\n<p id=\"%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%C2%A0\">函数重载 </a></p>\n<p id=\"extern%20%E2%80%9CC%E2%80%9D-toc\" style=\"margin-left:40px;\"><a href=\"#extern%20%E2%80%9CC%E2%80%9D\">extern “C”</a></p>\n<p id=\"%E5%BC%95%E7%94%A8%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E7%94%A8%C2%A0\">引用 </a></p>\n<p id=\"%E5%B8%B8%E5%BC%95%E7%94%A8%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%B8%B8%E5%BC%95%E7%94%A8%C2%A0\">常引用 </a></p>\n<p id=\"1.%20%E5%81%9A%E5%8F%82%E6%95%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20%E5%81%9A%E5%8F%82%E6%95%B0%C2%A0\">1. 做参数 </a></p>\n<p id=\"%E4%BE%8B%E5%AD%90%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BE%8B%E5%AD%90%C2%A0\">例子 </a></p>\n<p id=\"%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0\">引用作为函数返回值 </a></p>\n<p id=\"%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%C2%A0\">指针和引用区别 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88C%2B%2B98%EF%BC%89\">C++关键字（C++98）</h1>\n<table><tbody><tr><td>asm</td><td>do</td><td>if</td><td>return</td><td>try</td><td>continue</td></tr><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typedef</td><td>for</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typeid</td><td>public</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>typename</td><td>throw</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>union</td><td>wchar_t</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>unsigned</td><td>default</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>using</td><td>friend</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>virtual</td><td>register</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>void</td><td>true</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>volatile</td><td>while</td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td></tr></tbody></table>\n<h1 id=\"%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"> 命名空间</h1>\n<h2 id=\"%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89%C2%A0\">命名空间定义 </h2>\n<blockquote>\n<p><img alt=\"\" height=\"528\" src=\"..\\..\\static\\image\\eec67d5f21634943968ade27dff4295a.png\" width=\"959\"/><br/>  </p>\n<p>C语言中定义一个变量可能会跟一些函数名发生冲突，C++中为了解决这个问题 提出了namespace这个概念</p>\n<p><img alt=\"\" height=\"333\" src=\"..\\..\\static\\image\\96b639cac34f4442836cb32067642d49.png\" width=\"489\"/></p>\n<p>用namesapce来定义一个域， 若要使用这个域内的变量，我们使用域名::变量名，说明变量出处即可使用</p>\n<p><img alt=\"\" height=\"391\" src=\"..\\..\\static\\image\\7861537ea7a841f0baa114e4ba7df9f2.png\" width=\"498\"/></p>\n<p> 如若不 说明变量出处则是一个随机值</p>\n<p><img alt=\"\" height=\"410\" src=\"..\\..\\static\\image\\0cf3c4867ea74ebd85980ff3920f3d45.png\" width=\"560\"/></p>\n<p><img alt=\"\" height=\"402\" src=\"..\\..\\static\\image\\c51f55ac1aa44b7bab4535b271eafd4c.png\" width=\"478\"/></p>\n<p>::叫作用域限定符,这样可访问全局变量a</p>\n<p><img alt=\"\" height=\"466\" src=\"..\\..\\static\\image\\b585e9b8c52141a1a4ebe356cfb4a39a.png\" width=\"555\"/></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\"><strong> 命名的空间内可定义变量，函数，结构体，使用的时候需要声明命名空间</strong></span></p>\n<pre><code class=\"language-cpp\">namespace zhangsan\n{\n       int rand = 10;\nint Add(int left, int right)\n{\n     return left + right;\n}\nstruct Node\n{\n     struct Node* next;\n     int val;\n};\n}</code></pre>\n<p><img alt=\"\" height=\"833\" src=\"..\\..\\static\\image\\1853bfcc67674cc3a5a69e36d92fe7cb.png\" width=\"1040\"/></p>\n<p><img alt=\"\" height=\"667\" src=\"..\\..\\static\\image\\3baa09b864534cf7a787c1903e31c7b9.png\" width=\"858\"/></p>\n<p></p>\n<p></p>\n<p><strong><span style=\"color:#fe2c24;\">命名空间可以嵌套</span></strong><br/>  </p>\n<pre><code class=\"language-cpp\">namespace N1\n{\n     int a;\n     int b;\n    int Add(int left, int right)\n  {\n    return left + right;\n  }\nnamespace N2\n {\n  int c;\n  int d;\n  int Sub(int left, int right)\n   {\n   return left - right;\n   }\n }\n}</code></pre>\n<p><img alt=\"\" height=\"572\" src=\"..\\..\\static\\image\\03342d56407c478694378d5eef8c23f7.png\" width=\"1011\"/></p>\n<p><img alt=\"\" height=\"779\" src=\"..\\..\\static\\image\\95a08721773044d39e8e42028e5848bf.png\" width=\"1149\"/></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\"><strong>同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中。<br/> 一个工程中的test.h和上面test.cpp中两个N1会被合并成一个</strong></span></p>\n<pre><code class=\"language-cpp\">namespace N1\n{\nint Mul(int left, int right)\n{\nreturn left * right;\n}\n}</code></pre>\n<p>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中<br/> 定义了域之后，在不同的域内，可以定义相同的变量名，如zhangsan域中有a，lisi域中也有a</p>\n<p><img alt=\"\" height=\"507\" src=\"..\\..\\static\\image\\212868bb2e684d0fb9b86a3650f02b9e.png\" width=\"509\"/></p>\n<p> 空间内的变量名可以跟命名空间相同</p>\n<p><img alt=\"\" height=\"589\" src=\"..\\..\\static\\image\\e6f407f4704f4dafab52eb0d4673f221.png\" width=\"1116\"/></p>\n<p>定义命名空间的时候记尽量避免冲突，但如果命名空间名称为rand就不行，因为rand是个库函数</p>\n<p><img alt=\"\" height=\"666\" src=\"..\\..\\static\\image\\0f742c3c999e425682c18cdf4d4b181b.png\" width=\"1080\"/></p>\n<p> <img alt=\"\" height=\"159\" src=\"..\\..\\static\\image\\2fa3661d894f41d2a6c5c26adb74048d.png\" width=\"845\"/></p>\n<p> 我们经常可以看到，std标准库被展开</p>\n<p><img alt=\"\" height=\"437\" src=\"..\\..\\static\\image\\663f061d2ea14a7283672d7515e6c5db.png\" width=\"734\"/></p>\n<p>这是因为在平时练习的时候比较方便，但是如果在项目中尽量不要写using namespace std，如果使用则会把std标准库暴露出来 </p>\n</blockquote>\n<h2 id=\"%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8\"> 命名空间使用</h2>\n<blockquote>\n<p>1. 加命名空间名称及作用域限定符</p>\n<p><img alt=\"\" height=\"372\" src=\"..\\..\\static\\image\\23c8573b28ff4519a816902c6a79bef5.png\" width=\"1024\"/></p>\n<p> 2.使用using将命名空间中某个成员引入</p>\n<p><img alt=\"\" height=\"474\" src=\"..\\..\\static\\image\\7b8361df0fad4d56926876a3b3bace54.png\" width=\"538\"/></p>\n<p> 3.使用using namespace命名空间名称引入</p>\n<p><img alt=\"\" height=\"499\" src=\"..\\..\\static\\image\\cbd1b5448b624c04b56f02f3998a62ed.png\" width=\"596\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%C2%A0C%2B%2B%E8%BE%93%E5%85%A5%26%E8%BE%93%E5%87%BA\"> C++输入&amp;输出</h1>\n<blockquote>\n<p> <img alt=\"\" height=\"355\" src=\"..\\..\\static\\image\\0a72122a40fe4688a9ade41ee4a73aa7.png\" width=\"1078\"/></p>\n<p> // std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中</p>\n<p>C++兼容C语言，也可使用printf，scanf</p>\n<p>说明：<br/> 1. 使用cout标准输出对象(控制台)和cin标准输入对象(键盘)时，必须包含&lt; iostream &gt;头文件以及按命名空间使用方法使用std。<br/> 2. cout和cin是全局的流对象，endl是特殊的C++符号，表示换行输出，他们都包含在包含&lt; iostream &gt;头文件中。<br/> 3.<span style=\"color:#0d0016;\"><strong> &lt;&lt;是流插入运算符，&gt;&gt;是流提取运算符。</strong></span><br/> 5. 实际上cout和cin分别是ostream和istream类型的对象，&gt;&gt;和&lt;&lt;也涉及运算符重载等知识<br/> 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用&lt;iostream&gt;+std的方式<br/><img alt=\"\" height=\"451\" src=\"..\\..\\static\\image\\f748a022c601436c9e7dd0e48bc7523f.png\" width=\"516\"/></p>\n<p> C++中，cout和cin可自动识别变量的类型，c语言中要用%d或%c，说明变量类型，而C++不用</p>\n<table><tbody><tr><td> <p>std命名空间的使用惯例：</p>\n<table><tbody><tr><td>std是C++标准库的命名空间，如何展开std使用更合理呢？</td></tr></tbody></table><p>1. 在日常练习中，建议直接using namespace std即可，这样就很方便。<br/> 2. using namespace std展开，标准库就全部暴露出来了，如果我们定义跟库重名的类型/对象/函数，就存在冲突问题。该问题在日常练习中很少出现，但是项目开发中代码较多、规模大，就很容易出现。所<br/> 以建议在项目开发中使用，像std::cout这样使用时指定命名空间 + using std::cout展开常用的库对象/类<br/> 型等方式。</p> </td></tr></tbody></table>\n</blockquote>\n<h1 id=\"%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\"> 缺省参数</h1>\n<blockquote>\n<p> 缺省参数是声明或定义函数时为函数的参数指定一个缺省值。在调用该函数时，如果没有指定实参则采用该<br/> 形参的缺省值，否则使用指定的实参。</p>\n<p><img alt=\"\" height=\"492\" src=\"..\\..\\static\\image\\745143ba9ba84dd2a43beec812720f67.png\" width=\"575\"/></p>\n<p> 没有传参时，使用参数的默认值，传参时，使用指定的实参</p>\n</blockquote>\n<h2 id=\"%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB\">缺省参数分类</h2>\n<p></p>\n<h3 id=\"%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\"> 全缺省参数</h3>\n<blockquote>\n<p> <img alt=\"\" height=\"603\" src=\"..\\..\\static\\image\\d5e5d9bdfe9e4daebc5ce7259ff5c8ae.png\" width=\"629\"/></p>\n<p> <img alt=\"\" height=\"521\" src=\"..\\..\\static\\image\\c7f44d95b24f45dfb84dec5bac07898c.png\" width=\"642\"/></p>\n<p>不能只传给b，要从左到右一次传，如果第一个没传，则不能传给后面的，第二个每传，就不能传给后面的 </p>\n</blockquote>\n<h3 id=\"%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%C2%A0\">半缺省参数 </h3>\n<blockquote>\n<p> <img alt=\"\" height=\"442\" src=\"..\\..\\static\\image\\0206c1a883e9455c93ae475e1dc66547.png\" width=\"933\"/></p>\n<p> <img alt=\"\" height=\"642\" src=\"..\\..\\static\\image\\9b89d26b6a5d4b46a19db0f21b469b76.png\" width=\"747\"/></p>\n<p> 半缺省的缺省也有规则：必须从右往左连续缺省</p>\n<p><img alt=\"\" height=\"795\" src=\"..\\..\\static\\image\\82d5bba40466487f9f4965d04e52abf2.png\" width=\"1033\"/></p>\n<p> <img alt=\"\" height=\"802\" src=\"..\\..\\static\\image\\d3ee4386200b421895f093f0274acaf9.png\" width=\"1192\"/></p>\n<p> <img alt=\"\" height=\"442\" src=\"..\\..\\static\\image\\a4ec1e3ae9cc4171b2d0b30b358c0b4f.png\" width=\"1087\"/></p>\n<p> 缺省值必须是常量或者全局变量</p>\n<p>1. 半缺省参数必须从右往左依次来给出，不能间隔着给<br/> 2. 缺省参数不能在函数声明和定义中同时出现<br/>  </p>\n</blockquote>\n<h3 id=\"%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BE%8B%C2%A0\">缺省参数实例 </h3>\n<blockquote>\n<p><img alt=\"\" height=\"442\" src=\"..\\..\\static\\image\\84f4d7f2036e48d199bc47d812a00d40.png\" width=\"837\"/></p>\n<p>应用于栈的初始化当中，可清楚的知道当扩容量是多少 ，就可以不用动态扩容，扩容有代价</p>\n</blockquote>\n<blockquote>\n<p>缺省参数不能同时在声明和定义位置中出现 ，会报错 </p>\n<p><img alt=\"\" height=\"925\" src=\"..\\..\\static\\image\\563d11d7d1d44819a771c311d25b894d.png\" width=\"1111\"/></p>\n<p>我们应该尽量在声明的时候进行缺省参数的应用，定义的时候尽量不要</p>\n<p><img alt=\"\" height=\"508\" src=\"..\\..\\static\\image\\e721f79129f7424ea3bbd2633e239d7e.png\" width=\"1200\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%C2%A0\">函数重载 </h1>\n<blockquote>\n<p> 函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型不同的问题。</p>\n<pre><code class=\"language-cpp\">// 1、参数类型不同\nint Add(int left, int right)\n{\ncout &lt;&lt; \"int Add(int left, int right)\" &lt;&lt; endl;\nreturn left + right;\n}\ndouble Add(double left, double right)\n{\ncout &lt;&lt; \"double Add(double left, double right)\" &lt;&lt; endl;\nreturn left + right;\n}</code></pre>\n<pre><code class=\"language-cpp\">// 2、参数个数不同\nvoid f()\n{\ncout &lt;&lt; \"f()\" &lt;&lt; endl;\n}\nvoid f(int a)\n{\ncout &lt;&lt; \"f(int a)\" &lt;&lt; endl;\n}</code></pre>\n<pre><code class=\"language-cpp\">// 3、参数类型顺序不同\nvoid f(int a, char b)\n{\ncout &lt;&lt; \"f(int a,char b)\" &lt;&lt; endl;\n}\nvoid f(char b, int a)\n{\ncout &lt;&lt; \"f(char b, int a)\" &lt;&lt; endl;\n}</code></pre>\n<p></p>\n</blockquote>\n<h2 id=\"extern%20%E2%80%9CC%E2%80%9D\">extern “C”</h2>\n<blockquote>\n<p>由于C和C++编译器对函数名字修饰规则的不同，在有些场景下可能就会出问题，比如：<br/> 1. C++中调用C语言实现的静态库或者动态库，反之亦然<br/> 2. 多人协同开发时，有些人擅长用C语言，有些人擅长用C++<br/> 在这种混合模式下开发，由于C和C++编译器对函数名字修饰规则不同，可能就会导致链接失败，在该种场景<br/> 下，就需要使用extern \"C\"。在函数前加extern \"C\"，意思是告诉编译器，将该函数按照C语言规则来编译。</p>\n</blockquote>\n<h1 id=\"%E5%BC%95%E7%94%A8%C2%A0\">引用 </h1>\n<blockquote>\n<p> 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它<br/> 引用的变量共用同一块内存空间。<br/> 比如：李逵，在家称为\"铁牛\"，江湖上人称\"黑旋风\"。</p>\n<p><img alt=\"\" height=\"259\" src=\"..\\..\\static\\image\\06a2277155164c10bbd8d1e66360fe42.png\" width=\"386\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 类型&amp; 引用变量名(对象名) = 引用实体；</strong></span></p>\n<p><img alt=\"\" height=\"414\" src=\"..\\..\\static\\image\\c49e10277fc04e9b831cf2b1e1d04d74.png\" width=\"909\"/></p>\n<p> 注意：引用类型必须和引用实体是同种类型的</p>\n<p>1. 引用在定义时<span style=\"color:#fe2c24;\"><strong>必须初始化</strong></span></p>\n<p><img alt=\"\" height=\"594\" src=\"..\\..\\static\\image\\d236945191a842d0a4684535014a0fe4.png\" width=\"585\"/><br/> 2. 一个变量可以有多个引用</p>\n<p><img alt=\"\" height=\"432\" src=\"..\\..\\static\\image\\8837bbada4894736a8859519e691afce.png\" width=\"964\"/><br/> 3. 引用一旦引用一个实体，再不能引用其他实体</p>\n<p> <img alt=\"\" height=\"264\" src=\"..\\..\\static\\image\\5550e4437ff242f7801acd34cc8e6d02.png\" width=\"1057\"/></p>\n<p>修改b的值后，a的值也会发生变化 </p>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%B8%B8%E5%BC%95%E7%94%A8%C2%A0\">常引用 </h2>\n<blockquote>\n<p><img alt=\"\" height=\"604\" src=\"..\\..\\static\\image\\6ef410b7cec143ada7741d4cc16b7434.png\" width=\"579\"/></p>\n<p>若直接对常量进行引用则会报错，这是因为 c是常量，只可读，而d是变量，可读也可写，int&amp; d=c会把c的权限放大，权限放大会报错</p>\n<p><img alt=\"\" height=\"395\" src=\"..\\..\\static\\image\\8dbbbf53a91e4d319665a7a9f3e2e7e8.png\" width=\"527\"/></p>\n<p>此时不会 报错，是因为发生了权限的缩小，权限缩小不会报错，放大会报错</p>\n<p><img alt=\"\" height=\"193\" src=\"..\\..\\static\\image\\7e995243c87440e5976b7cf6fc47acce.png\" width=\"396\"/></p>\n<p> <img alt=\"\" height=\"294\" src=\"..\\..\\static\\image\\4bbb2b2956c14e029dcbd83404891ae2.png\" width=\"398\"/></p>\n<p>double&amp; rdd=i，会报错是因为，rdd接收到的是临时变量，而临时变量具有常属性，常属性只可读，不能写，而i是变量，可读可写，rdd权限会被放大，所以报错</p>\n<p><span style=\"color:#fe2c24;\"><strong>类型转换不会改变原变量，中间都会产生一个临时变量</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>权限的放大和缩小，只针对引用和指针</strong></span></p>\n<p><img alt=\"\" height=\"262\" src=\"..\\..\\static\\image\\9b78e59833584330bb61b898d3f3f3f2.png\" width=\"422\"/></p>\n<p>对于a 发生了权限的放大，参数权限大</p>\n<p><img alt=\"\" height=\"232\" src=\"..\\..\\static\\image\\ba2e6631b00244acb89dbed14551ee6c.png\" width=\"348\"/></p>\n<p> </p>\n<p><img alt=\"\" height=\"283\" src=\"..\\..\\static\\image\\3ab9197fcb28464ea5d346f463c24261.png\" width=\"706\"/></p>\n<p> 如果使用引用传参，函数内如果不改变n，尽量用const引用传参</p>\n</blockquote>\n<h2 id=\"1.%20%E5%81%9A%E5%8F%82%E6%95%B0%C2%A0\">1. 做参数 </h2>\n<blockquote>\n<p> <img alt=\"\" height=\"487\" src=\"..\\..\\static\\image\\48c0d1b450ca401ebbdfa6ff40584c76.png\" width=\"939\"/></p>\n<p>C语言中需要传地址，C++采用引用即可对原参数进行改变</p>\n</blockquote>\n<h3 id=\"%E4%BE%8B%E5%AD%90%C2%A0\">例子 </h3>\n<blockquote>\n<p> <img alt=\"\" height=\"369\" src=\"..\\..\\static\\image\\41d6b49f516c4eca97f855d223da9e20.png\" width=\"500\"/></p>\n<p>线性表在插入数据时可采用，引用</p>\n<p>单链表二级指针写法</p>\n<p> <img alt=\"\" height=\"234\" src=\"..\\..\\static\\image\\26c1ce091f68469d92ea5f79554cf260.png\" width=\"514\"/></p>\n<p> <img alt=\"\" height=\"301\" src=\"..\\..\\static\\image\\faa6c9e7b5c84372a93910175001b135.png\" width=\"465\"/></p>\n<p> <img alt=\"\" height=\"349\" src=\"..\\..\\static\\image\\0267c469ca97489a9d50346274c7189a.png\" width=\"450\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0\">引用作为函数返回值 </h2>\n<blockquote>\n<p><img alt=\"\" height=\"622\" src=\"..\\..\\static\\image\\caa8df6f45e14c5d8e0c0ff5eb8b9541.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">struct A { int a[10000]; };\n\nvoid TestFunc1(A aa) {}\nvoid TestFunc2(A&amp; aa) {}\n\nvoid TestRefAndValue()\n{\n\tA a;\n\t// 以值作为函数参数\n\tsize_t begin1 = clock();\n\tfor (size_t i = 0; i &lt; 10000; ++i)\n\t\tTestFunc1(a);\n\tsize_t end1 = clock();\n\n\t// 以引用作为函数参数\n\tsize_t begin2 = clock();\n\tfor (size_t i = 0; i &lt; 10000; ++i)\n\t\tTestFunc2(a);\n\tsize_t end2 = clock();\n\n\t// 分别计算两个函数运行结束后的时间\n\tcout &lt;&lt; \"TestFunc1(A)-time:\" &lt;&lt; end1 - begin1 &lt;&lt; endl;\n\tcout &lt;&lt; \"TestFunc2(A&amp;)-time:\" &lt;&lt; end2 - begin2 &lt;&lt; endl;\n}\nint main()\n{\n\tTestRefAndValue();\n\treturn 0;\n}</code></pre>\n<p>函数返回值</p>\n<p><img alt=\"\" height=\"454\" src=\"..\\..\\static\\image\\829b086ecd1c4d1bab8d13ea4b029a0d.png\" width=\"854\"/></p>\n<p>n在返回的时候先拷贝到方框，然后再返回，返回后那块空间还给操作系统，这里有越界</p>\n<p> <img alt=\"\" height=\"585\" src=\"..\\..\\static\\image\\34fecff642274af7a7203dd34d36567f.png\" width=\"1048\"/></p>\n<p> 但如果返回值是引用的，则也要临时拷贝一份，引用值，实际就是tmp和n共用一个空间，</p>\n<p><img alt=\"\" height=\"567\" src=\"..\\..\\static\\image\\3802ca81c80048bbb7fc02ba42e4d1c4.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"543\" src=\"..\\..\\static\\image\\11265aafd6f6425c96c1fa9126a2baeb.png\" width=\"736\"/></p>\n<p>再在使用静态变量时，可以用引用返回</p>\n<p>用引用返回修改顺序表的修改</p>\n<pre><code class=\"language-cpp\">typedef struct Seqlist\n{\n\tint* a;\n\tint size;\n\tint capacity;\n}SL;\nvoid SLInit(SL&amp; s, int capacity = 4)\n{\n\ts.a = (int*)malloc(sizeof(int) * capacity);\n\ts.size = 0;\n\ts.capacity = capacity;\n}\nvoid SLPushBack(SL&amp; s, int x)\n{\n\ts.a[s.size++] = x;\n}\n//修改顺序表数据的函数\nint&amp; SLAt(SL&amp; s, int pos)\n{\n\tassert(pos &gt;= 0 &amp;&amp; pos &lt;= s.size);\n\treturn s.a[pos];\n}\nint main()\n{\n\tSL sl;\n\tSLInit(sl);\n\tSLPushBack(sl, 1);\n\tSLPushBack(sl, 2);\n\tSLPushBack(sl, 3);\n\tSLPushBack(sl, 4);\n\n\tfor (int i = 0; i &lt; sl.size; ++i)\n\t{\n\t\tcout &lt;&lt; SLAt(sl, i) &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tSLAt(sl, 0)++;\n\n\tfor (int i = 0; i &lt; sl.size; ++i)\n\t{\n\t\tcout &lt;&lt; SLAt(sl, i) &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tSLAt(sl, 0) = 10;\n\n\tfor (int i = 0; i &lt; sl.size; ++i)\n\t{\n\t\tcout &lt;&lt; SLAt(sl, i) &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\n\treturn 0;\n}</code></pre>\n<p></p>\n<p> <img alt=\"\" height=\"639\" src=\"..\\..\\static\\image\\fb59c0c11b044916bab81f340e5506e2.png\" width=\"1147\"/></p>\n<p>引用做返回值</p>\n<p><img alt=\"\" height=\"501\" src=\"..\\..\\static\\image\\eb62d90bc16141e1b5b87c151c979051.png\" width=\"1166\"/></p>\n<p> 由于结构体里面的数组时动态开辟的，这块空间在堆上，即使SLAt函数栈帧销毁也不会，因为这段空间在堆上面</p>\n<p>引用使用场景：</p>\n<p>1.做参数--a.输出型参数 b.大对象传参，提高效率（上面算时间那个）</p>\n<p>2.做返回值--a.输出型返回对象，调用者可以修改返回对象b.减少拷贝，提高效率</p>\n</blockquote>\n<h2 id=\"%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%C2%A0\">指针和引用区别 </h2>\n<blockquote>\n<p> 1. 引用概念上定义一个变量的别名，指针存储一个变量地址。<br/> 2. 引用在定义时必须初始化，指针没有要求<br/> 3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型<br/> 实体<br/> 4. 没有NULL引用，但有NULL指针<br/> 5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占<br/> 4个字节)<br/> 6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小<br/> 7. 有多级指针，但是没有多级引用<br/> 8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理<br/> 9. 引用比指针使用起来相对更安全</p>\n<p><img alt=\"\" height=\"127\" src=\"..\\..\\static\\image\\6412fd2f56ed4c49be5f54a7fa464796.png\" width=\"365\"/></p>\n<p> 如在链表中，struct ListNode * next 不能改为引用</p>\n<p>指针更强大，更危险，更复杂，引用局限一些，更安全，更简单</p>\n<p>从语法的角度而言，引用没有开空间，指针开了4或8字节空间</p>\n<p><img alt=\"\" height=\"448\" src=\"..\\..\\static\\image\\6ec752107c454157a8e46c02f7aa8ce0.png\" width=\"661\"/></p>\n<p> </p>\n<p>在底层原理</p>\n<p><img alt=\"\" height=\"245\" src=\"..\\..\\static\\image\\c25e5f53fe694cc1bebe96f84322e748.png\" width=\"483\"/></p>\n<p>mov dword ptr [a],0Ah 定义了一个变量a，把0A（10）赋值给a</p>\n<p>lea eax,[a] 把a的地址取出来，放到eax</p>\n<p>mov dword ptr [ra],eax 把a的地址放到ra的变量里面</p>\n<p>mov dword ptr [eax],14h 把14h(20)赋值过去给eax</p>\n<p></p>\n<p><img alt=\"\" height=\"217\" src=\"..\\..\\static\\image\\985f790427264d038ef1247a4a99f843.png\" width=\"563\"/> </p>\n<p> lea eax,[a] 把a的地址放到eax种</p>\n<p>dword ptr [pa],eax 把eax放到pa变量里面去</p>\n<p>mov eax,dword ptr [pa] 把pa的地址放到eax</p>\n<p>mov dword ptr [eax],14h 把14h放到eax中[]是解引用</p>\n<p><strong><span style=\"color:#fe2c24;\">从底层实现的角度，引用底层使用指针实现的</span></strong></p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-23 08:00:00", "summary": "目录关键字命名空间命名空间定义命名空间使用输入输出缺省参数缺省参数分类全缺省参数半缺省参数缺省参数实例函数重载引用常引用做参数例子引用作为函数返回值指针和引用区别关键字命名空间命名空间定义语言中定义一"}