{"blogid": "120395859", "writerAge": "码龄2年", "writerBlogNum": "26", "writerCollect": "302", "writerComment": "416", "writerFan": "1704", "writerGrade": "4级", "writerIntegral": "1251", "writerName": "Mr、Jerry", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120395859.jpg", "writerRankTotal": "1052204", "writerRankWeekly": "214205", "writerThumb": "562", "writerVisitNum": "13690", "blog_read_count": "1310", "blog_time": "于 2021-09-21 13:05:49 发布", "blog_title": "C语言深层理解：函数中栈帧的创建与销毁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atelier-sulphurpool-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\47d3465e564a42ddab45c4d3bae31a02.png\"/></p>\n<p></p>\n<div class=\"toc\">\n<h3>C语言深层理解：函数中栈帧的创建与销毁</h3>\n<ul><li><a href=\"#_7\">引言</a></li><li><ul><li><a href=\"#_10\">&gt;引言问题一</a></li><li><a href=\"#_14\">&gt;引言问题二</a></li><li><a href=\"#_18\">&gt;引言问题三</a></li></ul>\n</li><li><a href=\"#_31\">一、栈的简单认识</a></li><li><ul><li><a href=\"#11_32\">1.1内存的简单了解</a></li><li><a href=\"#12_40\">1.2栈的简单了解</a></li><li><ul><li><a href=\"#121_41\">1.2.1栈的定义</a></li><li><a href=\"#122_44\">1.2.2栈的结构</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_56\">二、寄存器与简单的汇编指令</a></li><li><ul><li><a href=\"#21_57\">2.1寄存器的定义</a></li><li><a href=\"#22_81\">2.2寄存器的分类</a></li><li><a href=\"#23_98\">2.3简单的汇编指令</a></li></ul>\n</li><li><a href=\"#_115\">三、栈帧的创建于销毁</a></li><li><ul><li><a href=\"#31_148\">3.1调试——调用堆栈</a></li><li><a href=\"#32_160\">3.2调试——调用反汇编语言</a></li><li><a href=\"#33main_173\">3.3调试——分析main函数的反汇编语言</a></li><li><ul><li><a href=\"#_256\">&gt;引言问题一的解决</a></li></ul>\n</li><li><a href=\"#34Add_275\">3.4调试——分析Add函数的反汇编语言（上）</a></li><li><a href=\"#35Add_302\">3.5调试——分析Add函数的反汇编语言（下）</a></li><li><ul><li><a href=\"#_345\">&gt;引言问题二的解决</a></li><li><a href=\"#_354\">&gt;引言问题三的解决</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_424\">总结</a></li></ul>\n</div>\n<p></p>\n<hr color=\"#000000\" size='1\"'/>\n<h1><a id=\"_7\"></a>引言</h1>\n<p>我们在学习C语言的过程中，一定会经历过或者思考过下面的问题：</p>\n<h2><a id=\"_10\"></a>&gt;引言问题一</h2>\n<p><strong>①当我们C语言中进行printf操作时，有时会出现\"烫烫烫\"的字眼，那么为什么会出现\"烫烫烫\"这样的字眼呢？</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2adb92014bd949319dac0c274cc0240e.png\"/></p>\n<h2><a id=\"_14\"></a>&gt;引言问题二</h2>\n<p><strong>②我们在学习与使用函数时，当我们进行函数的值传递时，我们被告知当被调函数中，形参的改变，并不会改变传参变量（实参）的数据内容，那么为什么不会改变传递的参数的内容呢？</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\26f120981f7b4bf7bb183303f0412b77.png\"/></p>\n<h2><a id=\"_18\"></a>&gt;引言问题三</h2>\n<p><strong>③我们在第二个问题中，还会被告知，当进行参数值传递时，在被调函数中，其实那些参数的值是实参的一份令时拷贝的数据，那么为什么是临时拷贝的数据呢？</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0e38dee394b946dfa9938105d182b4ce.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><font color=\"#999AAA\">下面我们就来彻底理解这些情况的真实原因与过程。</font></p>\n<h1><a id=\"_31\"></a>一、栈的简单认识</h1>\n<h2><a id=\"11_32\"></a>1.1内存的简单了解</h2>\n<p>我们在初期学习C语言时，会学到各种变量，有的是可变变量，有的是不可修改的常量，又会接触到一些栈，堆的概念，下面的图例，是为了我们便于我们了解函数栈帧的创建与销毁的简单内存图解：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6c028c497b63491288896ebb0628116e.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"12_40\"></a>1.2栈的简单了解</h2>\n<h3><a id=\"121_41\"></a>1.2.1栈的定义</h3>\n<p><strong><mark>定义：栈是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。</mark></strong></p>\n<h3><a id=\"122_44\"></a>1.2.2栈的结构</h3>\n<p>①进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则<br/> ②压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。<br/> ③出栈：栈的删除操作叫做出栈。出数据也在栈顶。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0acb1e76cf0a48fb982c9a0797d2b1e0.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\accb7fcd27384c5a899880e64f8a93a7.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<h1><a id=\"_56\"></a>二、寄存器与简单的汇编指令</h1>\n<h2><a id=\"21_57\"></a>2.1寄存器的定义</h2>\n<p>①定义：<font color=\"#999AAA\">寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，存器有累加器(ACC)。<br/> 寄存器的基本单元是 D触发器，<br/> 按照其用途分为基本寄存器和移位寄存器<br/> 基本寄存器是由 D触发器组成，在 CP 脉冲作用下，每个 D触发器能够寄存一位二进制码。在 D=0 时，寄存器储存为 0，在 D=1 时，寄存器储存为 1。在低电平为 0、高电平为 1 时，需将信号源与 D 间连接一反相器，这样就可以完成对数据的储存。<br/> 需要强调的是，目前大型数字系统都是基于时钟运作的，其中寄存器一般是在时钟的边缘被触发的，基于电平触发的已较少使用。（通常说的CPU的频率就是指数字集成电路的时钟频率）<br/> 移位寄存器按照移位方向可以分为单向移位寄存器和双向移位寄存器。单向移位寄存器是由多个 D 触发器串接而成,在串口 Di 输入需要储存的数据，触发器 FF0 就能够储存当前需要储存数据，在 CP 发出一次时钟控制脉冲时，串口 Di 同时输入第二个需要储存是的数据，而第一个数据则储存到触发器 FF1 中。双向移位寄存器按图中方式排列，调换连接端顺序，可以控制寄存器向左移位，增加控制电路可以使寄存器右移，这样构成双向移位寄存器。</font></p>\n<p>②特点：<font color=\"#999AAA\"><br/> 寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点：<br/> a、寄存器位于CPU内部，数量很少，仅十四个<br/> b、寄存器所能存储的数据不一定是8bit，有一些寄存器可以存储16bit数据，对于386/486处理器中的一些寄存器则能存储32bit数据<br/> c、每个内部寄存器都有一个名字，而没有类似存储器的地址编号。</font></p>\n<p><strong>③用途：</strong><br/> 1．可将寄存器内的数据执行算术及逻辑运算<br/> <mark><strong>2．存于寄存器内的地址可用来指向内存的某个位置，即寻址</strong></mark><br/> 3．可以用来读写数据到电脑的周边设备。</p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"22_81\"></a>2.2寄存器的分类</h2>\n<table><thead><tr><th>寄存器</th><th>用途</th></tr></thead><tbody><tr><td>eax</td><td>累加寄存器，相对于其他寄存器，在运算方面比较常用</td></tr><tr><td>ebx</td><td>基地址寄存器，作为内存偏移指针使用</td></tr><tr><td>edi</td><td>在内存操作指令中作为“目的地址”使用</td></tr><tr><td>esi</td><td>在内存操作指令中作为“源地址指针”使用</td></tr><tr><td>ecx</td><td>计数器，用于特定的技术</td></tr><tr><td>edx</td><td>作为EAX的溢出寄存器，（除法产生的余数）</td></tr><tr><td>esp</td><td>指针的寄存器，用于堆栈操作。<strong><mark>被形象地称为栈顶指针</mark></strong>，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。</td></tr><tr><td>ebp</td><td>基址指针，<mark><strong>指栈的栈底指针</strong></mark></td></tr></tbody></table>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"23_98\"></a>2.3简单的汇编指令</h2>\n<table><thead><tr><th>汇编指令</th><th>对应操作</th></tr></thead><tbody><tr><td>push</td><td>压栈</td></tr><tr><td>pop</td><td>出栈</td></tr><tr><td>move</td><td><strong>move A，B 将A移动到当前B的位置</strong></td></tr><tr><td>call</td><td>将程序的执行交给其他代码段(即函数的调用)</td></tr><tr><td>lea</td><td>加载有效地址</td></tr><tr><td>ret</td><td>子程序返回指令</td></tr><tr><td>sub</td><td>减法操作</td></tr><tr><td>add</td><td>加法操作</td></tr></tbody></table>\n<hr color=\"#000000\" size='1\"'/>\n<h1><a id=\"_115\"></a>三、栈帧的创建于销毁</h1>\n<p>经过上面关于栈与寄存器的简单解释，我们开始本文章的重点，对函数中的栈帧的创建与销毁的理解</p>\n<p>为了方便我们理解，我们用下面的代码进行讲解:</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> z <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\tz <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> z<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\tc <span class=\"token operator\">=</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><font color=\"#999AAA\">这里我们使用后的VS2013编译器进行讲解，当我们使用不同的编译器去执行代码与进行理解时，会有一些偏差</font></p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"31_148\"></a>3.1调试——调用堆栈</h2>\n<p>①我们首先按F10进行调试，进入调试之后，我们按照下面的操作，调用堆栈窗口：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9103f644681b4de5a9bebe818e454148.png\"/>②当我们进入堆栈窗口之后，我们在程序中anF10进行程序，当程序进行结束之后，我们的堆栈窗口出现下图：<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\55b4d26f16dc4cc8a2270eb1ffb32e0d.png\"/>上图的内容是告诉我们：<br/> <mark><strong>main函数在VS2013中任然是被调函数，main函数首先被_tmainCRTSartup()函数调用，而_tmainCRTSartup()函数被mainCRTSartup函数调用；</strong></mark></p>\n<p>③根据上述内容，我们可以得出关于当前程序的栈帧简图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5ca909cce9714c019ae3416f8b81de9c.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"32_160\"></a>3.2调试——调用反汇编语言</h2>\n<p>①现在我们为了深入了解我们的栈帧是如何创建与销毁的过程，我们按照下图步骤进行操作：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\55e95683278347448ff9c25379c3285b.png\"/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4e8bae43be5649bb9beffc8b17f0ee5f.png\"/>此时我们获取了程序的反汇编语言，通过反汇编语言，我们才能够深入了解程序的进行过程与栈帧的创建与销毁过程，也正是通过对反汇编的分析，我们才能够解决我们引言中的问题；</p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"33main_173\"></a>3.3调试——分析main函数的反汇编语言</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a1343a35b5714e9dbf53ce969d8b56f2.png\"/><strong>①</strong>这里我们在进行对main函数的反汇编语言进行分析前，我们先对补充一些内容的讲解：</p>\n<p><strong>a、在函数的栈帧中，ebp和esp这两个寄存器是存放地址的，也是这两个地址用来维护函数的栈帧；</strong></p>\n<p><strong>b、在esp和ebp这两个寄存器中，esp寄存器存放的是函数的栈顶地址，也就是栈顶指针；ebp寄存器存放的是函数的栈底地址，也就是栈底指针；</strong></p>\n<p><font color=\"#999AAA\">举例（如图）：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9418854a659e464c96690358722e88ba.png\"/></font></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>②</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ac46b560f4b44ed2a8fb3f2d55b837b7.png\"/></p>\n<p><mark><strong>压栈操作：将ebp移动到当前栈的栈底的位置，然后esp指针会自动上移，指向压栈进入栈的ebp</strong></mark></p>\n<p><mark><strong>也就是将t_mainSRTSartup函数的ebp的值存放到栈顶，占用一个内存空间；</strong></mark></p>\n<p><font color=\"#999AAA\">举例（如图）：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\18cc5491f0fb46acbcbeca65e2815c05.png\"/></font></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>③</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7af48b52e74949d08b46332147b3affd.png\"/><mark><strong>将ebp指针指向当前esp指针指向的位置</strong></mark></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ee3beb59a6fe47d9985414f0e355729e.png\"/></p>\n<p>通过监视窗口，从地址进行观察，可以确定，ebp指向了esp指向的位置，此时两个指针的地址值相同<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\30441e65e44b46349a7f628c038be44a.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>④</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8953e91757644e278cee976488e973ea.png\"/><br/> <mark><strong>将esp的值减少0E4h（也就是将esp指针上移）</strong></mark></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\68b26170a5214948b60389b29078279b.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑤</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d0bb96c951464b36b117927799f061d0.png\"/><br/> <mark><strong>实现步骤同上，从栈顶压入三个元素，分别为ebx、esi、edi（我们暂时不用理会这三个寄存器）</strong></mark></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b80ab714e4634ba29c31249c3da47eef.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑥</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c86f81cd4756485f880a53e7bef1bd81.png\"/>我们勾选<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\44e7ce2fbdf34a5e92fdb83d6a8bb2a5.png\"/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\28762c3fa4d0440ab30ffc0fbe15f4c8.png\"/><mark><strong>lea（load effective address）加载有效地址，将ebp-0E4h这个地址上存储的内容加载到edi中</strong></mark></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑦</strong>我们对main函数的反汇编语言进行分析：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\98c3528947a643b4bd4845fb4fd9947e.png\"/><mark><strong>mov操作，将\"39h\"存储到ecx中；将\"0CCCCCCCCh\"存储到eax中</strong></mark></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑧</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ab404f4e9aed4c6d8da566afb4a68fd3.png\"/><mark><strong>从edi开始，向下39h个内存空间的数据全部转化为0CCCCCCCCh</strong></mark><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ae7314f57edb4a23812059382c352fb3.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8c4d12d627c34e4d8a39bf85d6cb9cf2.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<h3><a id=\"_256\"></a>&gt;引言问题一的解决</h3>\n<p><strong>引言问题的解决：</strong></p>\n<p><mark><strong>在这里我们回顾初学C语言时，我们当时创建一个变量，却没有对其赋值时，或者在打印字符串时，没有找到’\\0’时，我们却将其打印，得到结果中含有\"烫烫烫\"的字样，这种情况的出现，其实就是打印的初始化值\"0CCCCCCCCh\"</strong></mark></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑨</strong>我们对main函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b58739c8bafe447ba21e72003c6ee9f1.png\"/><br/> <mark><strong>mov操作的执行，将\"14h\"存储到ebp-8的位置、将\"0Ah\"存储到ebp-4h的位置、将\"0\"存储到ebp-20h的位置</strong></mark><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\442c48e1bab4492196203623d292f944.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"34Add_275\"></a>3.4调试——分析Add函数的反汇编语言（上）</h2>\n<p><strong>①</strong>我们对Add函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20e091dc2c274c4db61f05752e470bad.png\"/><mark><strong>将ebp-14h位置上的值移动到eax的位置上，即将ebp-14h位置上的值传递给eax；<br/> 压栈操作，将eax从栈顶压入；<br/> 将将ebp-8位置上的值移动到ecx的位置上，即将ebp-8位置上的值传递给ecx；<br/> 压栈操作，将ecx从栈顶压入；</strong></mark></p>\n<p><mark><strong>同时这里操作，也是我们Add函数传参的操作</strong></mark></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\10865366aea347339fb9d2376ea631f8.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>②</strong>我们对Add函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a85186cf7c444c1e9e3b14f8c67e6282.png\"/><br/> <mark><strong>call操作的执行，我们会压栈压入call指令的下一条指令的地址</strong></mark><br/> <strong>这一步执行的原因，是当我们Add函数执行完之后， 我们返回结束时，要继续执行我们的下一条指令，所以我们进行记录我们Add函数的下一条指令的地址</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a580a4cff6614b22989d0e87ddc1afeb.png\"/></p>\n<p><font color=\"#999AAA\">我们在这里按F11进入Add函数，显示如下：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\731f6120467f4e7bb685af6a0e7e0fea.png\"/></font></p>\n<hr color=\"#000000\" size='1\"'/>\n<h2><a id=\"35Add_302\"></a>3.5调试——分析Add函数的反汇编语言（下）</h2>\n<p>我们对Add函数的反汇编语言进行分析：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\08634b15eb2c42c683e89f309866a052.png\"/><br/> <mark><strong>当我们进入Add函数之后，我们发现Add函数和main函数步骤相同，需要先为Add函数进行初始化，ebp、esp的函数栈帧维护等，也就是需要创建Add函数所需要的栈帧，数据类型初始化。</strong></mark></p>\n<p><strong>①压栈，压入ebp，其中这个ebp就是当前main函数的ebp</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\767daa6d413d451ca9a27b49a84a287e.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>②mov操作，将esp的值传递给ebp，那么ebp就指向当前的esp指向的位置</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7645c8a381dd4792aa183079bd530710.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>③sub操作，将esp减去0CCh，使esp指针上移；push操作，压栈压入ebx、esi、edi三个元素</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\afb88b65565b4a7fa99c40449279d85e.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>④lea、mov、mov、rep stos的执行步骤与main函数的初始化步骤相同</strong></p>\n<p>这时，我们对代码的内容近一步分析<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fbc5aa3a8e8144b9b9872f56c141a5b9.png\"/><br/> <strong>这里的两个地址，我们通过图解分析，可以得出，之前的ecx、eax就是实现我们的传参步骤，分别为形参a’，b’；</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\985e063d11f341fc9ecbc8138576fa03.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑤此时，我们将ebp+8位置的值传递给eax，此时eax = 20；然后再将ebp+0Ch位置的值添加到eax中，此时eax = 30；再然后，将eax的值传递到ebp-8的位置；</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5b8f7aa7d8a046f488176e56b140bf9d.png\"/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d154fbdab30940e1a5a1f60206b6a66e.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<h3><a id=\"_345\"></a>&gt;引言问题二的解决</h3>\n<p><strong>引言问题的解决：</strong></p>\n<p><mark><strong>形参是实参的一份临时拷贝，当我们在还没有在main函数中执行到Add（）函数时，我们已将b，a的数值压栈进入栈中，而这两个压栈进入栈中的数据，就是b、a的一份临时拷贝，当我们执行到Add函数时，我们就找回了之前压栈存储的b、a的值，所以我们说形参是实参的一份临时拷贝</strong></mark></p>\n<hr color=\"#000000\" size='1\"'/>\n<h3><a id=\"_354\"></a>&gt;引言问题三的解决</h3>\n<p><mark><strong>当我们在函数中改变这份临时拷贝的数值时，对我们原本的实参并不会改变，因为函数中改变的只是实参的一份临时拷贝，所以我们说值传递的形参改变，并不会改变实参</strong></mark></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑥将ebp-8的值传递给eax中</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\692c9964f03e47248729219ce5c1f3aa.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑦pop操作，将栈顶元素弹走；这三行代码的执行效果为，依次将栈顶的元素弹到edi寄存器中、esi寄存器中，ebx寄存器中</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7445a02c51ee47bdbae2dc6f33d46831.png\"/></p>\n<p>此时的栈顶情况如图：<br/> 即将edi元素弹回，存储到edi寄存器中，esi、ebx同理。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cde6191f18794e10883879c47e600fe6.png\"/>执行三次pop操作之后<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4b474dea0fa54152a7fdbff4e15351b4.png\"/><br/> 此时，我们的Add函数的任务已经执行结束，获得的return值也已经存储到eax中，那么这个时候，Add函数的函数栈帧就没有存在的必要了，我们需要对这一段空间进行回收</p>\n<hr color=\"#000000\" size='1\"'/>\n<p>⑧<strong>让esp指针指向ebp的位置</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a486f647d7ac43368fc1480e1f848508.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8efe416177f84c6aa95eb52874e725ed.png\"/></p>\n<hr color=\"#000000\" size='1\"'/>\n<p><strong>⑨将当前栈顶的元素弹出，弹到ebp寄存器中</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\93de495f58074cef9529415a3904a733.png\"/>而当前的栈顶元素存储的内容就是main函数的ebp，那么效果就相当于<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9905a2a1ea2a4e0a8e276f3d1e9a6751.png\"/>此时，Add函数的栈帧已经收回，我们又回到了main函数的栈帧中</p>\n<hr color=\"#000000\" size='1\"'/>\n<p><mark><strong>⑩前面的过程经历之后，我们的call指令就已经执行完毕，但我们任然需要继续call函数之后的步骤，而此时ret操作的执行，就是让我们从call指令执行完之后，返回到我们之前存储的call指令的下一个指令地址的地方。继续执行call指之后的指令。</strong></mark><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2c03cd198e3d4c25bea15f7bdf8ca311.png\"/></p>\n<p>现在我们又回到了call指令之后<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a8b95b9e814a4a00a288208217594a23.png\"/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\560280e7e1dd4477b65f5c22372e8cf1.png\"/><strong>此时main函数指针中的形参20、10就没有用处了，那么我们就要将这两个空间进行回收</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a99dd5ebc24f4a659ed4b56461f3a1b2.png\"/><br/> 将\"esp\"+8，即就是将esp指针下移八个字节<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9266b340688d450ca0423ee2176236b1.png\"/>此时，也就是形参销毁的真实时刻</p>\n<p>将eax的值传递给ebp-20h中<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\11e66ba828364af8a2db8ffa782ebe00.png\"/>我们回顾main函数中的栈帧<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d97bb558e0b34fd99a1597296ed28194.png\"/>那么将eax的值传递给ebp-20h中，则<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\97348dab696d412b919935217bd55501.png\"/><br/> <mark><strong>这里我们可以得出，当我们调用返回函数时，返回值都是先存放到寄存器中，然后当我们真的返回到调用函数中时，再从寄存器中读取这个返回值</strong></mark></p>\n<p>到此，余下的部分关于main函数的栈帧空间的销毁与Add函数相同，就不在此叙述了，执行的步骤与前面分析内容形似。</p>\n<hr color=\"#000000\" size='1\"'/>\n<h1><a id=\"_424\"></a>总结</h1>\n<p>以上就是我对函数中栈帧的创建与销毁的个人理解</p>\n<p>上述内容如果有错误的地方，还麻烦各位大佬指教【膜拜各位了】【膜拜各位了】<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\00bad86b68c84da0b78f47bb27e33d1b.jpg\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-09-21 13:05:49", "summary": "在这里插入图片描述语言深层理解：函数中栈帧的创建与销毁引言引言问题一引言问题二引言问题三一、栈的简单认识内存的简单了解栈的简单了解栈的定义栈的结构二、寄存器与简单的汇编指令寄存器的定义寄存器的分类简单"}