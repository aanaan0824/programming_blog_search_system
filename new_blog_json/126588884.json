{"blogid": "126588884", "writerAge": "码龄3年", "writerBlogNum": "90", "writerCollect": "280", "writerComment": "34", "writerFan": "22", "writerGrade": "5级", "writerIntegral": "1708", "writerName": "a1161105403", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126588884.jpg", "writerRankTotal": "12424", "writerRankWeekly": "15035", "writerThumb": "85", "writerVisitNum": "119282", "blog_read_count": "558", "blog_time": "于 2022-08-29 17:19:35 发布", "blog_title": "2022前端vue面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>这里边是比较常见的vue面试题</strong></p>\n<h4><a id=\"1vuerouter_2\"></a>1.[vue-router是怎么传递参数的？</h4>\n<p>(1)通过在router.js文件中配置path的地方动态传递参数 eg: path: ‘/detail/:id’<br/> (2).在router-link标签中传递参数</p>\n<p>&lt;router-link :to={<!-- --><br/> params: {<!-- --><br/> x: 1<br/> }<br/> } /&gt;<br/> 获取：this.$route.params.id</p>\n<h4><a id=\"2vifvfor_14\"></a>2.v-if和v-for一起使用的弊端以及解决办法</h4>\n<p>v-for的优先级比v-if高，导致每循环一次就会去v-if一次，而v-if是通过创建和销毁dom元素来控制元素的显示与隐藏，所以就会不停的去创建和销毁元素，造成页面卡顿，性能下降。</p>\n<p>解决办法：</p>\n<p>1.在v-for的外层包裹一个标签来使用v-if</p>\n<p>2将需要的判断在computed里处理，然后在放到v-for里</p>\n<h4><a id=\"3beforeDestroyed_24\"></a>3.beforeDestroyed里面一般进行什么操作</h4>\n<p>beforedestoryed是组件销毁之前执行的一个生命周期，在这个生命周期里，我们可以进行回调函数或定时器的清除，数据初始化等</p>\n<h4><a id=\"4vue_28\"></a>4.vue组件传值方式</h4>\n<ol><li>props</li><li>event bus</li><li>$emit</li><li>vuex</li><li>storage</li><li>provide/inject(优点是不用层层传递了)</li></ol>\n<p><strong>1.事件总线：</strong></p>\n<p>通过其中一个<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        e\n       \n       \n        m\n       \n       \n        i\n       \n       \n        t\n       \n       \n        发另一个\n       \n      \n      \n       emit发另一个\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">mi</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">发另一个</span></span></span></span></span>on接收的方式 实现组件传值，main.js中挂载一下</p>\n<pre><code>Vue.prototype.$bus=new Vue() //$bus挂在同一个实例\n</code></pre>\n<p>其中一个页面$emit</p>\n<pre><code>//确保dom已经渲染完成\nthis.$nextTick(()=&gt;{\nthis.$bus.$emit('my',\"给父组件传值\")\n})\n</code></pre>\n<p>另一个页面$on</p>\n<pre><code>mounted(){\n//vue渲染顺序，先渲染父组件---&gt;渲染子组件\nthis.$bus.$on('my',params=&gt;{\nconsolo.log(params)\n})\n}\n</code></pre>\n<p><strong>2.provide和inject特性</strong></p>\n<p>在vue2.2.0 中新增provide和inject属性</p>\n<p>使用的方式很简单：<br/> 父组件通过provide提供数据，其他组价可以使用inject注入数据</p>\n<p><strong>注意</strong></p>\n<p>不推荐直接用于应用程序代码中。一般使用的场景是自定义组件库的时候，底层组件之间需要通信的时候使用。</p>\n<blockquote>\n<p>provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</p>\n</blockquote>\n<p><strong>格式</strong></p>\n<p>provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。</p>\n<p>inject 选项应该是：</p>\n<p>一个字符串数组<br/> 或 一个对象，对象的 key 是本地的绑定名（自定义的一个名字），value 是：<br/> 在provide传过来的值(字符串或 Symbol)，或</p>\n<p>一个对象，该对象的：<br/> from 属性是provide传过来的 (字符串或 Symbol)<br/> default 属性是降级情况下使用的 value</p>\n<p><strong>例子：</strong></p>\n<p>父组件</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;HelloWorld&lt;/h1&gt;\n    &lt;One&gt;&lt;/One&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport One from \"./One\";\nexport default {\n  components: { One },\n  // provide: {\n  //   form: \"这是父组件的provide\"\n  // }\n  provide() {\n    return {\n      form: \"这是父组件的provide\"\n    };\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<p>子组件1：</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;childOne组件&lt;/h2&gt;\n    {<!-- -->{demo}}\n    &lt;Two&gt;&lt;/Two&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Two from \"./Two.vue\";\nexport default {\n  name: \"One\",\n  // inject: [\"form\"],\n  inject: {\n    form: {\n      default: () =&gt; ({})\n    }\n  },\n  data() {\n    return {\n      demo: this.form\n    };\n  },\n  components: {\n    Two\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<p>子组件2：</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;childtwo组件&lt;/h2&gt;\n    {<!-- -->{demo}}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: \"Two\",\n  // inject: [\"form\"],\n  inject: {\n    for: {\n      default: () =&gt; ({})\n    }\n  },\n  data() {\n    return {\n      demo: this.form\n      // demo: \"childTwo\"\n    };\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<h4><a id=\"5vue_182\"></a>5.vue中父组件如何获取子组件的属性和方法</h4>\n<p>在子组件上定义ref属性来获取子组件的属性和方法</p>\n<p>代码：</p>\n<pre><code>// 这里是父组件\n&lt;templete&gt;\n\t&lt;child ref=\"child\"/&gt;\n&lt;/templete&gt;\n&lt;script&gt;\nmethod: {\n\tgetChild () {\n\t\tthis.$refs.child.属性名（方法名）\n\t}\n}\n&lt;/script&gt;\n</code></pre>\n<h4><a id=\"6watchcomputed_204\"></a>6.watch和computed的区别</h4>\n<p>watch：监听数据变化，并执行一个回调函数</p>\n<p>computed：对已有的数据进行加工，具有缓存功能，只有数据发生改时，才会重新计算</p>\n<h4><a id=\"7vue_210\"></a>7.vue父组件和子组件生命周期的顺序</h4>\n<p>1.渲染过程顺序：<br/> 父组件beforeCreate() -&gt; 父组件created() -&gt; 父组件beforeMount() -&gt; 子组件beforeCreate() -&gt;子组件created() -&gt; 子组件beforeMount() -&gt; 子组件mounted() -&gt; 父组件mounted()<br/> 2.更新过程顺序：<br/> 父组件更新过程：<br/> 父组件beforeUpdate() -&gt; 父组件updated()<br/> 子组件更新过程：<br/> 父组件beforeUpdate() -&gt; 子组件beforeUpdate() -&gt; 子组件updated() -&gt; 父组件updated()<br/> 3.销毁过程<br/> 父组件beforeDestroy() -&gt; 子组件beforeDestroy() -&gt; 子组件destroyed() -&gt; 父组件destroyed()</p>\n<h4><a id=\"8vue_222\"></a>8.vue中父组件能监听到子组件的生命周期吗</h4>\n<p>能，通过@hook:进行监听代码如下：</p>\n<pre><code>// 这里是父组件\n&lt;template&gt;\n\t&lt;child\n\t@hook:mounted=\"getChildMounted\"\n\t/&gt;\n&lt;/template&gt;\n&lt;script&gt;\nmethod: {\n\tgetChildMounted () {\n\t\t// 这里可以获取到子组件mounted的信息\n\t}\n}\n&lt;/script&gt;\n\n</code></pre>\n<h4><a id=\"9vue_243\"></a>9.vue中的事件修饰符主要有哪些？分别是什么作用？</h4>\n<p>.stop: 阻止事件冒泡<br/> .native: 绑定原生事件<br/> .once: 事件只执行一次<br/> .self:将事件绑定在自身身上，相当于阻止事件冒泡<br/> .prevent: 阻止默认事件<br/> .caption: 用于事件捕获</p>\n<h4><a id=\"10keepalive_252\"></a>10.介绍下什么是keep-alive</h4>\n<p>keep-alive：组件缓存，只会执行一次，不会被销毁。被keep-alive包裹的组件，有activated和deactivated方法。</p>\n<p><strong>prop:</strong></p>\n<ul><li>include: 字符串或正则表达式。匹配的组件会被缓存。</li><li>exclude: 字符串或正则表达式。匹配的组件都不会被缓存。</li></ul>\n<h4><a id=\"11watchpop_261\"></a>11.watch能监听到数组的pop行为吗</h4>\n<p>下面两种情况下无法监听</p>\n<ol><li>利用索引直接设置数组项时，例如arr[indexofitem]=newValue</li><li>修改数组的长度时，例如arr.length=newLength</li></ol>\n<h4><a id=\"12watch_268\"></a>12.watch如何实现深度监听</h4>\n<pre><code>watch: {\n\tobj: {\n\t\thandler: function(val) {\n\t\t},\n\t\tdeep: true // 深度监听\n\t}\n}\n</code></pre>\n<h4><a id=\"13vue_280\"></a>13.vue中如何解决页面不重新渲染问题?</h4>\n<p>(1)修改对象属性后,页面未重新渲染:</p>\n<pre><code> this.$set(对象名称, '属性名', '属性值')\n</code></pre>\n<p>(2)使用this.$forceUpdate()方法可重新渲染页面</p>\n<h4><a id=\"14vuex_290\"></a>14.什么是vuex？</h4>\n<p>vuex是全局状态管理工具，它有以下几个核心部分组成：</p>\n<p>state:存储数据；</p>\n<p>mutations:更新数据的方法；</p>\n<p>actions:调用mutations方法，更新state数据；</p>\n<p>getters:对state中的数据进行预处理；</p>\n<p>Module： store 分割成<strong>模块</strong></p>\n<h4><a id=\"15MVVM_304\"></a>15.对于MVVM的理解？</h4>\n<p>M（数据层） V（视图层） VM（view-model）视图模型层）用来连接（数据层）（视图层）</p>\n<h4><a id=\"16vue_308\"></a>16.vue的生命周期？</h4>\n<p>beforeCreate: 进行数据和方法的初始化；</p>\n<p>created: 已经完成数据和方法的初始化；</p>\n<p>beforeMount: 开始渲染dom</p>\n<p>mounted:可以渲染dom</p>\n<p>beforeUpdate: data中的数据即将被更新；</p>\n<p>updated: data中的数据更新完毕；</p>\n<p>beforeDestroy: 实例即将销毁；</p>\n<p>destroyed:实例已被销毁；</p>\n<h4><a id=\"17vuedatareturn_326\"></a>17.vue创建组件的时候data中为什么会被return出一个对象？</h4>\n<p>防止组件与组件之间变量的局部污染</p>\n<h4><a id=\"18vue_330\"></a>18.vue路由的几种模式？</h4>\n<p>两种：</p>\n<p>1.hash（默认）</p>\n<p>2.history</p>\n<p>通过model属性切换路由模式</p>\n<h4><a id=\"19_340\"></a>19.什么是路由懒加载</h4>\n<p>通过异步的方式来加载对应的路由组件，提高页面的加载速度</p>\n<h4><a id=\"20vue_344\"></a>20.vue中有哪些内置组件？</h4>\n<ol><li>transtion</li><li>transition-group</li><li>keep-alive</li><li>slot</li><li>component</li></ol>\n<h4><a id=\"21SPA_352\"></a>21.什么是SPA？</h4>\n<p>SPA是单页面应用程序，vue react angular 都是,整个项目只有一个页面</p>\n<h4><a id=\"22vuerouter___356\"></a>22.vue-router有哪几种导航钩子（ 导航守卫 ）</h4>\n<ol><li> <p>全局守卫：<br/> beforeEach((to, from, next) =&gt; {调用next来resolve这个钩子} ),</p> <p>afterEach((to, from) =&gt; {} )</p> <p>beforeResolve((to, from, next) =&gt; {} ),</p> </li><li> <p>路由独享守卫：<br/> beforeEnter((to, from, next) =&gt; {} ),</p> </li><li> <p>组件内部守卫：<br/> beforeRouteEnter((to, from, next) =&gt; {next可以传回调，回调里面可以用vm访问实例} ), 内部没有this，因为路由还没confirm<br/> beforeRouteUpdate((to, from, next) =&gt; {})，可以拿到this<br/> beforeRouteLeave((to, from, next) =&gt; {})</p> <p>他们执行顺序：全局》路由》组件</p> </li></ol>\n<h4><a id=\"23vuerouter404_375\"></a>23.vue-router怎么配置404页面？</h4>\n<pre><code>{\n// 会匹配所有路径\n// 含有通配符的路由应该放在最后\npath: '*',\nname: '404',\ncomponent: () =&gt; import('../views/404.vue')\n}\n</code></pre>\n<h4><a id=\"24__387\"></a>24. 切换路由时自动或提示保存草稿功能，如何实现？</h4>\n<pre><code>beforeRouteLeave (to, from, next) {\n  if(用户已经输入信息){\n    //出现弹窗提醒保存草稿，或者自动后台为其保存   \n  }else{\n    next(true);//用户离开\n  }\n}\n</code></pre>\n<h4><a id=\"25vueclies6es7_399\"></a>25.vue-cli生成的项目可以使用es6、es7的语法吗？为什么？</h4>\n<p>vue-cli 配置了babel,webpack打包时会将高级语法转为ES5，所以上线的时候没有问题。但是脚手架只是配置了一些默认常见的用法，像装饰器还需另做配置。 （可以根据babel官网配置一些尚在草案中的语法）</p>\n<h4><a id=\"26DOM_403\"></a>26.什么是虚拟DOM？</h4>\n<p>使用JS来模拟DOM树结构</p>\n<p>由于每次查询DOM都会遍历整颗DOM树，相当消耗计算资源。</p>\n<p>通过JS以对象嵌套的方式表示DOM树，每次DOM的更改就变成了JS对象属性的修改，这样就会减少性能的开销。</p>\n<h4><a id=\"27nextTick_411\"></a>27.$nextTick有什么作用？</h4>\n<p>处理数据动态变化后，dom还未及时更新的问题。$nextTick就可以获取到数据更新后最新的dom变化</p>\n<h4><a id=\"28vue_415\"></a>28.怎么捕获组件vue的错误信息？</h4>\n<p><strong>1.errorCaptured</strong></p>\n<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：</p>\n<p>1.错误对象</p>\n<p>2.发生错误的组件实例</p>\n<p>3.包含错误来源信息的字符串。</p>\n<p>此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>\n<p>注意：只能在父组件中处理子组件的错误，没法直接在Vue的主实例中使用它。</p>\n<pre><code>   errorCaptured(err,vm,info) {\n    console.log(`cat EC: ${err.toString()}\\ninfo: ${info}`); \n     return false;\n  }\n</code></pre>\n<p><strong>2.errorHandler</strong></p>\n<pre><code>Vue.config.errorHandler = function(err, vm, info) {\n  console.log(`Error: ${err.toString()}\\nInfo: ${info}`);\n}\nerr：error对象\nvm：Vue应用本身\ninfo：是一个Vue特有的字符串\n在一个页面你可以有多个Vue应用。这个error handler作用到所有的应用。\n</code></pre>\n<h4><a id=\"29vue_450\"></a>29.为什么vue使用异步更新组件？</h4>\n<p>批量更新，收集当前的改动一次性更新，节省diff开销</p>\n<h4><a id=\"30vue_454\"></a>30.vue如何优化首页的加载速度？</h4>\n<p>1.路由、图片懒加载</p>\n<p>2.DNS预解析dns-prefetch</p>\n<p>3.CDN分发</p>\n<p>4.按需加载三方资源</p>\n<p>5.webpack开启gzip压缩</p>\n<h4><a id=\"31_name_466\"></a>31.<strong>组件中写 name选项有哪些好处及作用？</strong></h4>\n<p>1.可以通过名字找到对应的组件 （ 递归组件 ）</p>\n<p>2.可以通过name属性实现缓存功能 (keep-alive)</p>\n<p>3.可以通过name来识别组件 （跨级组件通信时非常重要）</p>\n<h4><a id=\"32Vue_474\"></a>32.你都做过哪些Vue的性能优化？</h4>\n<p><strong>1.编码阶段</strong></p>\n<ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理；</li><li>SPA 页面采用keep-alive缓存组件；</li><li>在更多的情况下，使用v-if替代v-show；</li><li>key保证唯一；</li><li>使用路由懒加载、异步组件；</li><li>防抖、节流；</li><li>第三方模块按需导入；</li><li>长列表滚动到可视区域动态加载；</li><li>图片懒加载；</li></ul>\n<p><strong>2.用户体验：</strong></p>\n<ul><li>骨架屏；</li><li>PWA；</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul>\n<p><strong>3.SEO优化</strong></p>\n<ul><li>预渲染；</li><li>服务端渲染SSR；</li></ul>\n<p><strong>4.打包优化</strong></p>\n<ul><li>压缩代码；</li><li>Tree Shaking/Scope Hoisting；</li><li>使用cdn加载第三方模块；</li><li>多线程打包happypack；</li><li>splitChunks抽离公共文件；</li><li>sourceMap优化；</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-29 17:19:35", "summary": "这里边是比较常见的面试题是怎么传递参数的？通过在文件中配置的地方动态传递参数在标签中传递参数获取：和一起使用的弊端以及解决办法的优先级比高，导致每循环一次就会去一次，而是通过创建和销毁元素来控制元素的"}