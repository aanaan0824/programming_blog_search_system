{"blogid": "122143855", "writerAge": "码龄12年", "writerBlogNum": "101", "writerCollect": "161", "writerComment": "9", "writerFan": "3378", "writerGrade": "4级", "writerIntegral": "1066", "writerName": "无熵~", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122143855.jpg", "writerRankTotal": "21247", "writerRankWeekly": "3007", "writerThumb": "28", "writerVisitNum": "89727", "blog_read_count": "6663", "blog_time": "已于 2022-06-08 20:40:52 修改", "blog_title": "C# 图片操作(图片读取，保存，转换，传输)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p> <strong>JPG PNG GIF BMP图片格式的区别</strong>:</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td>类型</td><td>优点</td><td>缺点</td><td>应用场景</td><td>相同图片大小比较</td></tr><tr><td>BMP</td><td><a href=\"https://www.baidu.com/s?wd=%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao\" title=\"无损压缩\">无损压缩</a>，图质最好</td><td>文件太大，不利于<a href=\"https://www.baidu.com/s?wd=%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao\" title=\"网络传输\">网络传输</a></td><td></td><td>152K</td></tr><tr><td>GIF</td><td>动画存储格式</td><td>最多256色，画质差</td><td></td><td>53K</td></tr><tr><td>PNG</td><td>可保存透明背景的图片</td><td>画质中等</td><td></td><td>202K</td></tr><tr><td>JPG</td><td>文件小，利于<a href=\"https://www.baidu.com/s?wd=%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao\" title=\"网络传输\">网络传输</a></td><td>画质损失</td><td>车牌识别</td><td>84K</td></tr></tbody></table>\n<p><strong> 图片代码操作</strong>:</p>\n<p> 根据图片的相对路径 获取Image对象:</p>\n<pre><code>      /// &lt;summary&gt;\n        /// 根据图片的相对路径 获取Image对象\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"imgPath\"&gt;图片的相对路径(如:@\"/images/star.png\")&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static Image GetImage(string imgPath)\n        {\n            if (File.Exists(imgPath))\n            {\n                Image im = new Image();\n                im.Source = GetBitmapImage(imgPath);\n                return im;\n            }\n            else\n                return null;\n        }</code></pre>\n<p> 根据图片的相对路径 返回 BitmapImage对象的实例化:</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 根据图片的相对路径 返回 BitmapImage对象的实例化\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"imgPath\"&gt;图片的相对路径(如:@\"/images/star.png\")&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static BitmapImage GetBitmapImage(string imgPath)\n        {\n            try\n            {\n                if (!imgPath.StartsWith(\"/\"))\n                {\n                    imgPath = \"/\" + imgPath;\n                }\n                return new BitmapImage(new Uri(\"Pack://application:,,,\" + imgPath));\n            }\n            catch\n            {\n                return null;\n            }\n        }</code></pre>\n<p> 根据图片的相对路径 获取ImageBrush对象:</p>\n<pre><code>      /// &lt;summary&gt;\n      /// 根据图片的相对路径 获取ImageBrush对象 (此对象资源可以直接用于绑定控件的Background属性)\n      /// &lt;/summary&gt;\n      /// &lt;param name=\"imgPath\"&gt;图片的相对路径(如:@\"/images/star.png\")&lt;/param&gt;\n      /// &lt;returns&gt;&lt;/returns&gt;\n        public static ImageBrush GetImageBrush(string imgPath)\n        {\n            if (File.Exists(imgPath))\n            {\n                ImageBrush ib = new ImageBrush();\n                ib.ImageSource = GetBitmapImage(imgPath);\n                return ib;\n            }\n            else\n                return null;\n        }</code></pre>\n<p>在Path中读取图片byte[]:</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 根据图片的路径解析成图片资源\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"filePath\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static byte[] BitmapImageToByteArray(String filePath)\n        {\n\n            byte[] byteArray = null ;\n            if(File.Exists(filePath))\n                byteArray = File.ReadAllBytes(filePath);\n            return byteArray;\n        }</code></pre>\n<p>byte[]转BitmapImage：</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 解析字节数组成图片\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"byteArray\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static BitmapImage ByteArrayToBitmapImage(byte[] byteArray)\n        {\n            BitmapImage bmp = null;\n            try\n            {\n                bmp = new BitmapImage();\n                bmp.BeginInit();\n                bmp.StreamSource = new MemoryStream(byteArray);\n                bmp.EndInit();\n            }\n            catch\n            {\n                bmp = null;\n            }\n            return bmp;\n        }</code></pre>\n<p>BitmapImage转byte[]：</p>\n<pre><code>\n        /// &lt;summary&gt;\n        /// 图片数据解析成字节流数组(用于存储到数据库)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"bmp\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static byte[] BitmapImageToByteArray(BitmapImage bmp)\n        {\n            byte[] byteArray = null;\n            try\n            {\n                Stream sMarket = bmp.StreamSource;\n                if (sMarket != null &amp;&amp; sMarket.Length &gt; 0)\n                {\n                    sMarket.Position = 0;\n                    using (BinaryReader br = new BinaryReader(sMarket))\n                    {\n                        byteArray = br.ReadBytes((int)sMarket.Length);\n                    }\n                }\n            }\n            catch\n            {\n            }\n            return byteArray;\n        }</code></pre>\n<p>将Bitmap对象转换成bitmapImage对象:</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 将Bitmap对象转换成bitmapImage对象\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"bitmap\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public BitmapImage ConvertBitmapToBitmapImage(Bitmap bitmap)\n        {\n            MemoryStream stream = new MemoryStream();\n            bitmap.Save(stream, ImageFormat.Bmp);\n            BitmapImage image = new BitmapImage();\n            image.BeginInit();\n            image.StreamSource = stream;\n            image.EndInit();\n            return image;\n        }</code></pre>\n<p>将bitmapImage对象转换成Bitmap对象:</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 将bitmapImage对象转换成Bitmap对象\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"bitmapImage\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static System.Drawing.Bitmap BitmapImageToBitmap(BitmapImage bitmapImage)\n        {\n            using (System.IO.MemoryStream outStream = new System.IO.MemoryStream())\n            {\n                BitmapEncoder enc = new BmpBitmapEncoder();\n                enc.Frames.Add(BitmapFrame.Create(bitmapImage));\n                enc.Save(outStream);\n                System.Drawing.Bitmap bitmap = new System.Drawing.Bitmap(outStream);\n                return bitmap;\n            }\n        }</code></pre>\n<p>bitmap转换成ImageSource:</p>\n<pre><code>        [DllImport(\"gdi32.dll\", SetLastError = true)]\n        private static extern bool DeleteObject(IntPtr hObject);\n        /// &lt;summary&gt;\n        /// 从bitmap转换成ImageSource\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"icon\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static ImageSource ChangeBitmapToImageSource(Bitmap bitmap)\n        {\n            IntPtr hBitmap = bitmap.GetHbitmap();\n            ImageSource wpfBitmap = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(\n                hBitmap,\n                IntPtr.Zero,\n                Int32Rect.Empty,\n                BitmapSizeOptions.FromEmptyOptions());\n            if (!DeleteObject(hBitmap))//记得要进行内存释放。否则会有内存不足的报错。\n            {\n                throw new System.ComponentModel.Win32Exception();\n            }\n            return wpfBitmap;\n        }</code></pre>\n<p>从Bitmap转换成BitmapSource:</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 从Bitmap转换成BitmapSource\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"bmp\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static BitmapSource ChangeBitmapToBitmapSource(Bitmap bmp)\n        {\n            BitmapSource returnSource;\n            try\n            {\n                returnSource = Imaging.CreateBitmapSourceFromHBitmap(bmp.GetHbitmap(), IntPtr.Zero, Int32Rect.Empty, BitmapSizeOptions.FromEmptyOptions());\n            }\n            catch\n            {\n                returnSource = null;\n            }\n            return returnSource;\n        }</code></pre>\n<p> 从Icon到ImageSource的转换:</p>\n<pre><code>        /// &lt;summary&gt;\n        /// 从Icon到ImageSource的转换\n        /// &lt;/summary&gt;\n        public ImageSource ChangeIconToImageSource(Icon icon)\n        {\n            ImageSource imageSource = System.Windows.Interop.Imaging.CreateBitmapSourceFromHIcon(\n            icon.Handle,\n            Int32Rect.Empty,\n            BitmapSizeOptions.FromEmptyOptions());\n            return imageSource;\n        }</code></pre>\n<p>Stream保存图片:</p>\n<pre><code>FileStream fs = new FileStream(\"A.jpg\", FileMode.Create, FileAccess.ReadWrite);\nStream MyStream = new MemoryStream((byte[])imageBytes); //取出的byte[]数组\nint read = 0;\nbyte[] Mybyte = new byte[1024];\ndo\n{\n      read = MyStream.Read(Mybyte,0,1024);\n      fs.Write(Mybyte,0,read);\n} while (read &gt; 0);\nMyStream.Flush();\nMyStream.Close();\nfs.Flush();\nfs.Close();\n</code></pre>\n<p>图片通过CGI获取保存到本地快照:</p>\n<pre><code>        public string Address = \"url address\";\n        public void SavefromWeb()\n        {\n            FileStream fs = new FileStream(\"D:\\\\Image.jpg\",FileMode.Create,FileAccess.ReadWrite);\n            HttpWebRequest MyHttpWebRequest = null;\n            HttpWebResponse MyHttpWebResponse = null;\n            Stream MyStream = null;\n            try\n            {\n                MyHttpWebRequest = (HttpWebRequest)HttpWebRequest.Create(Address);\n                MyHttpWebResponse = (HttpWebResponse)MyHttpWebRequest.GetResponse();\n                MyStream = MyHttpWebResponse.GetResponseStream();\n            }\n            catch(Exception)\n            {\n            }\n            int read = 0;\n            byte[] Mybyte=new byte[1024];\n            do\n            {\n                read = MyStream.Read(Mybyte,0,1024);\n                fs.Write(Mybyte,0,read);\n            }while(read&gt;0);\n            MyStream.Flush();\n            MyStream.Close();\n            MyHttpWebResponse.Close();\n            fs.Flush();\n            fs.Close();\n        }</code></pre>\n<p>参考:<a href=\"https://www.cnblogs.com/lanymy/archive/2012/07/06/2579692.html\" title=\"wpf 图片操作类 ImageBrush  BitmapImage - ﹎蓝言觅ぷ雨 - 博客园\">wpf 图片操作类 ImageBrush BitmapImage - ﹎蓝言觅ぷ雨 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/Probably/p/4605151.html\" title=\"WPF（1）---图片的获取与存储 - Probably - 博客园\">WPF（1）---图片的获取与存储 - Probably - 博客园</a></p>\n<p><a href=\"https://blog.csdn.net/aidem_brown/article/details/81389417\" title=\"JPG PNG GIF BMP图片格式的区别_Wanda  &amp;&amp;  Aidem -CSDN博客_bmp jpg png 区别\">JPG PNG GIF BMP图片格式的区别_Wanda &amp;&amp; Aidem -CSDN博客_bmp jpg png 区别</a></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-08 20:40:52", "summary": "图片格式的区别类型优点缺点应用场景相同图片大小比较无损压缩无损压缩，图质最好文件太大，不利于网络传输网络传输动画存储格式最多色，画质差可保存透明背景的图片画质中等文件小，利于网络传输网络传输画质损失车"}