{"blogid": "126545495", "writerAge": "码龄7年", "writerBlogNum": "81", "writerCollect": "158", "writerComment": "76", "writerFan": "188", "writerGrade": "5级", "writerIntegral": "2266", "writerName": "qq_540616979", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126545495.jpg", "writerRankTotal": "9662", "writerRankWeekly": "44863", "writerThumb": "105", "writerVisitNum": "698501", "blog_read_count": "1682", "blog_time": "已于 2022-08-27 15:27:56 修改", "blog_title": "PHP微服务 hyperf+nacos使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"PHP_hyperfnacos_0\"></a>PHP微服务 hyperf+nacos使用</h2>\n<p><strong>这里简单说下微服务,及架构方面东西</strong><br/> 1:微服务对php +fpm 模式意义不是很大,原因就是php+fpm 天生支持模块拆分,热更新,如果只是性能上的考虑,那php+fpm 还是比较耗cpu的,这样用微服务就不如单体+多库的方案,即一个项目拆分多个数据库,不同业务调用对应的库即可</p>\n<p>2:微服务可不可以直接调用http 接口?<br/> 答案是可以的,都是自己公司内部的项目,并且项目不是说特别大,完全可以直接通过接口,这里注意几个点:<br/> a:保证这些接口通过内网调用,毕竟走外网时间是比较长的<br/> b:Http接口默认为同步调用,当需要同时调用多个服务时,考虑接口时间问题<br/> c:定义好规范,写好文档</p>\n<p>3:微服务的服务治理方式<br/> a:现在流行的都是统一服务治理中心(nacos/zookeeper)及 统一配置管理服务;<br/> 优点就是: 统一管理,动态增减,及时上下线<br/> 缺点是: 多个服务集中到了一起,容易形成瓶颈压力,多一层服务增加了系统的复杂性,在性能测试时需要考虑服务中心的压力<br/> b:服务自治模式,即每个服务提供统一的对外域名,由服务内部自己负载均衡实现减压,这样可以省去服务治理这一层,也不需要服务一直ping 治理中心;<br/> 缺点就是新增服务得手动添加到负载均衡器里</p>\n<p>这里主要记录使用统一治理中心(nacos) 跟hyerf 搭建微服务的过程及注意点</p>\n<h2><a id=\"nacos__18\"></a>nacos 安装</h2>\n<p>官网链接:https://nacos.io/zh-cn/docs/quick-start.html<br/> 建议 直接下载<a href=\"https://github.com/alibaba/nacos/releases\">nacos编译包</a>解压后,开箱即用,这里注意配置,<strong>官方建议最低 2c 4g 太低可能导致启动失败</strong></p>\n<pre><code>unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz\n  cd nacos/bin\n</code></pre>\n<p>启动建议先用单机模式</p>\n<pre><code>启动命令(standalone代表着单机模式运行，非集群模式):\n\nsh startup.sh -m standalone\n</code></pre>\n<p><strong>管理后台连接,默认账号 nacos 密码nacos</strong><br/> http://host:8848/nacos/<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1e86160051e4ecbb892e64b4c602627.jpeg\"/></p>\n<p><strong>注意端口是否有放开,生产环境建议端口白名单方式,因为更新删除服务是不需要账号密码的,外网很容易被人攻击</strong></p>\n<p><strong>PS:nacos 服务默认会健康检测,30s内没有心跳会默认删除,所以自己后台创建的 可能过一会就不见了,不要大惊小怪,还有通过api服务,创建要注意对应的命名空间,命名空间一定要在服务端先创建好,不然直接添加是不会在后端显示的,不熟悉的以为是bug</strong></p>\n<h2><a id=\"Hyperf__43\"></a>Hyperf 使用(下面流程都是参照官方文档,这里说明下注意点)</h2>\n<p>官网:https://hyperf.wiki/2.2</p>\n<p><strong>一:根据文档安装好 swoole,跟Hyperf框架</strong></p>\n<p><strong>二:配置rpc 个服务 主要下面2个文档里</strong><br/> 1:https://hyperf.wiki/2.2/#/zh-cn/json-rpc<br/> 2:https://hyperf.wiki/2.2/#/zh-cn/service-register</p>\n<p><strong>这里主要说下注意的</strong><br/> <strong>1:rpc</strong> 服务注解需要加上publishTo=“nacos” 才会同步到到nacos</p>\n<pre><code>&lt;?php\n/**\n * 测试微服务提供者\n * Created by PhpStorm.\n * User: 05\n * Date: 2022/8/10\n * Time: 10:06\n */\n\nnamespace App\\JsonRpc;\n\nuse Hyperf\\RpcServer\\Annotation\\RpcService;\n/**\n* 注意，如希望通过服务中心来管理服务，需在注解内增加 publishTo 属性\n * @RpcService(name=\"CaculatorService\", protocol=\"jsonrpc-http\", server=\"jsonrpc-http\",publishTo=\"nacos\")\n */\nclass CaculatorService extends DefaultService\n{\n\n    /**\n     * @param int $a\n     * @param int $b\n     * @return int\n     */\n    public function add(array $pms)\n    {\n\n        return $pms['a']+$pms['b']+10;\n    }\n\n\n    public function get(array $pms)\n    {\n        return parent::get($pms); // TODO: Change the autogenerated stub\n    }\n\n\n}\n</code></pre>\n<p><strong>2:配置config/autoload/services.php 的 namespace_id 需要提前在nacos 后台新增命名空间,获取对应的id,随便填写一个链接上nacos 也不会在nacos后台显示的</strong></p>\n<p><strong>3:作为消费者端使用nacos的话 在config/autoload/services.php 也是要配置服务驱动相关配置drivers (服务提供端可以不配置consumers),不然获取不到服务</strong><br/> 配置如下</p>\n<pre><code>return [\n    'enable' =&gt; [\n        // 开启服务发现\n        'discovery' =&gt; true,\n        // 开启服务注册\n        'register' =&gt; true,\n    ],\n    // 服务消费者相关配置\n    //服务消费者\n    'consumers' =&gt; [\n        [\n            // 对应消费者类的 $serviceName\n            'name' =&gt; 'CaculatorService',\n            // 这个消费者要从哪个服务中心获取节点信息，如不配置则不会从服务中心获取节点信息\n            'registry' =&gt; [\n                'protocol' =&gt; 'nacos',\n                'address' =&gt; 'http://127.0.0.1:8848',\n            ],\n            // 如果没有指定上面的 registry 配置，即为直接对指定的节点进行消费，通过下面的 nodes 参数来配置服务提供者的节点信息\n//            'nodes' =&gt; [\n//                ['host' =&gt; '127.0.0.1', 'port' =&gt; 9513],\n//            ],\n        ],\n        [\n            // 对应消费者类的 $serviceName\n            'name' =&gt; 'DefaultService',\n            // 这个消费者要从哪个服务中心获取节点信息，如不配置则不会从服务中心获取节点信息\n            'registry' =&gt; [\n                'protocol' =&gt; 'nacos',\n                'address' =&gt; 'http://127.0.0.1:8848',\n            ],\n            // 如果没有指定上面的 registry 配置，即为直接对指定的节点进行消费，通过下面的 nodes 参数来配置服务提供者的节点信息\n//            'nodes' =&gt; [\n//                ['host' =&gt; '127.0.0.1', 'port' =&gt; 9513],\n//            ],\n        ]\n    ],\n    // 服务提供者相关配置\n    'providers' =&gt; [],\n    // 服务驱动相关配置\n    'drivers' =&gt; [\n//        'consul' =&gt; [\n//\n//        ],\n        'nacos' =&gt; [\n            // nacos server url like https://nacos.hyperf.io, Priority is higher than host:port\n            // 'url' =&gt; '',\n            // The nacos host info\n            'host' =&gt; '127.0.0.1',\n            'port' =&gt; 8848,\n            // The nacos account info\n            'username' =&gt; 'nacos',//可以不用配置\n            'password' =&gt; '',//似乎可以不用密码\n            'guzzle' =&gt; [\n                'config' =&gt; null,\n            ],\n            'group_name' =&gt; 'api',\n            'namespace_id' =&gt; '950fdb39-edeb-4978-8ab6-3cf742732449',//这个要从nacos 后台获取\n            'heartbeat' =&gt; 5,\n            'ephemeral' =&gt; false, // 是否注册临时实例\n        ],\n    ],\n];\n</code></pre>\n<p>链接成功后<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bc9411234597488bb92c4a6c08e6d413.jpeg\"/><br/> <strong>使用&amp;优化:</strong><br/> 按照官方的使用方式是<br/> 服务提供者Service写好对应类 通过注解 RpcService 对外提供服务<br/> 服务消费者Consumer 需要写对应的类跟方法,之后才能调用<br/> 这里就会有个问题,如果一个服务被很多项目调用,那提供者每添加一个服务 其他的消费者都要对应添加一个服务类或者修改对应的方法,这个对消费者非常不友好,服务多了需要浪费大量的时间互相同步</p>\n<p><strong>简单优化</strong><br/> 消费端提供默认消费者 DefaultConsumer ,生成唯一get 方法 通过传入方法名跟参数调用对应的服务,这样服务端新增一个服务时 消费者端就不在需要写对应的消费类,但这里要求服务接收的参数就只有一个数组,通过数组约定里面的参数(<strong>这里还是要生成对应的消费端类继承DefaultConsumer,将$serviceName 默认好,Hyperf 通过容器绑定了对象,初始化就会获取此属性,没法更改,如果自己new DefaultConsumer 会造成内存泄露,随着访问量上升cpu 跟内存很快就爆满…</strong>)<br/> 代码如下<br/> DefaultConsumer</p>\n<pre><code>&lt;?php\n/**\n * Created by PhpStorm.\n * User: 05\n * Date: 2021/11/25\n * Time: 15:00\n */\n\nnamespace App\\JsonRpc;\n\n\nuse Hyperf\\Rpc\\Protocol;\nuse Hyperf\\Rpc\\ProtocolManager;\nuse Hyperf\\RpcClient\\AbstractServiceClient;\nuse Hyperf\\RpcClient\\Client;\nuse Hyperf\\Utils\\ApplicationContext;\nuse Psr\\Container\\ContainerInterface;\nuse function Swoole\\Coroutine\\Http\\get;\n\nclass DefaultConsumer extends AbstractServiceClient\n{\n\n    /**\n     * 定义对应服务提供者的服务名称\n     * @var string\n     */\n    protected $serviceName = 'DefaultService';\n\n\n    /**\n     * 定义对应服务提供者的服务协议\n     * @var string\n     */\n    protected $protocol = 'jsonrpc-http';\n\n\n\n    public function get(string $method, array $parms)\n    {\n        return $this-&gt;__request($method, ['pms'=&gt;$parms]);\n    }\n\n\n}\n</code></pre>\n<p>CalculatorServiceConsumer</p>\n<pre><code>&lt;?php\n/**\n * Created by PhpStorm.\n * User: 05\n * Date: 2021/11/25\n * Time: 15:00\n */\n\nnamespace App\\JsonRpc;\n\n\n\nclass CalculatorServiceConsumer extends DefaultConsumer\n{\n\n    /**\n     * 只需要改这个属性,方法实现可以不要,直接通过参数传递\n     * @var string\n     */\n    protected $serviceName = 'CaculatorService';\n\n\n}\n</code></pre>\n<h2><a id=\"_251\"></a>测试</h2>\n<p><strong>消费者代码</strong></p>\n<pre><code>&lt;?php\n\ndeclare(strict_types=1);\n/**\n * This file is part of Hyperf.\n *\n * @link     https://www.hyperf.io\n * @document https://hyperf.wiki\n * @contact  group@hyperf.io\n * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE\n */\nnamespace App\\Controller;\n\nuse App\\JsonRpc\\DefaultConsumer;\nuse function EasyWeChat\\Kernel\\Support\\get_server_ip;\nuse Hyperf\\HttpServer\\Annotation\\AutoController;\n\n/**\n * @AutoController();需要引入对应的文件\n * */\n    class IndexController extends BaseController\n{\n\n\n       public function rpc_test(){\n       //这里不要自己new 实例,不然内存泄露...\n         $cus=   ApplicationContext::getContainer()-&gt;get(CalculatorServiceConsumer::class);\n         $d= $cus-&gt;get(\"add\",['a'=&gt;1,'b'=&gt;2]);\n        return [\n            '本机ip' =&gt; get_server_ip(),\n            'message' =&gt; \"微服务调用结果=$d\",\n        ];\n    }\n}\n\n</code></pre>\n<p><strong>服务提供者代码</strong></p>\n<pre><code>&lt;?php\n/**\n * 测试微服务提供者\n * Created by PhpStorm.\n * User: 05\n * Date: 2022/8/10\n * Time: 10:06\n */\n\nnamespace App\\JsonRpc;\n\nuse Hyperf\\RpcServer\\Annotation\\RpcService;\n/**\n * @RpcService(name=\"CaculatorService\", protocol=\"jsonrpc-http\", server=\"jsonrpc-http\",publishTo=\"nacos\")\n */\nclass CaculatorService extends DefaultService\n{\n\n    /**\n     * @param int $a\n     * @param int $b\n     * @return int\n     */\n    public function add(array $pms)\n    {\n\n        return \"远端调用结果:\".(($pms['a']+$pms['b'])*10);//这里是远端特意乘以10\n    }\n\n\n\n\n}\n</code></pre>\n<p><strong>结果</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7220c1d33c1749c2841b20afbd781504.jpeg\"/></p>\n<p><strong>注册中心下线服务后,再调用就不可用了</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f3ee983162b04a80a3809e8ddd8a304e.jpeg\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c98361c4c1204e47a371d431e5626965.jpeg\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2022-08-27 15:27:56", "summary": "微服务使用这里简单说下微服务及架构方面东西微服务对模式意义不是很大原因就是天生支持模块拆分热更新如果只是性能上的考虑那还是比较耗的这样用微服务就不如单体多库的方案即一个项目拆分多个数据库不同业务调用对"}