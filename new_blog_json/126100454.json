{"blogid": "126100454", "writerAge": "码龄1年", "writerBlogNum": "112", "writerCollect": "2666", "writerComment": "3494", "writerFan": "14959", "writerGrade": "7级", "writerIntegral": "9325", "writerName": "原来45", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126100454.jpg", "writerRankTotal": "1471", "writerRankWeekly": "1231", "writerThumb": "3622", "writerVisitNum": "118162", "blog_read_count": "473", "blog_time": "已于 2022-08-06 12:24:20 修改", "blog_title": "STL——list", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%20vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20vector%E7%9A%84%E4%BB%8B%E7%BB%8D\">list的介绍</a></p>\n<p id=\"list%E7%9A%84%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:40px;\"><a href=\"#list%E7%9A%84%E6%9E%84%E9%80%A0\">list的构造</a></p>\n<p id=\"list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8\">list iterator的使用</a></p>\n<p id=\"list%20capacity-toc\" style=\"margin-left:40px;\"><a href=\"#list%20capacity\">list capacity</a></p>\n<p id=\"list%20element%20access-toc\" style=\"margin-left:40px;\"><a href=\"#list%20element%20access\">list element access</a></p>\n<p id=\"list%20modififiers-toc\" style=\"margin-left:40px;\"><a href=\"#list%20modififiers\">list modififiers</a></p>\n<p id=\"list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc\" style=\"margin-left:40px;\"><a href=\"#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88\">list的迭代器失效</a></p>\n<p id=\"%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8\">关于迭代器</a></p>\n<p id=\"list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">list的模拟实现</a></p>\n<p id=\"main.cpp-toc\" style=\"margin-left:40px;\"><a href=\"#main.cpp\">main.cpp</a></p>\n<p id=\"List.h-toc\" style=\"margin-left:40px;\"><a href=\"#List.h\">List.h</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<blockquote>\n<p><strong><span style=\"color:#fe2c24;\">C语言总结</span><a href=\"https://blog.csdn.net/weixin_62700590/article/details/122200337\" title=\"在这\">在这</a></strong><strong><span style=\"color:#fe2c24;\">常见八大排序</span><a href=\"https://blog.csdn.net/weixin_62700590/article/details/124291850\" title=\"在这\">在这</a></strong></p>\n<p><span style=\"color:#956fe7;\"><strong>作者和朋友建立的社区：</strong></span><a href=\"https://bbs.csdn.net/forums/FKBZM\" title=\"非科班转码社区-CSDN社区云\">非科班转码社区-CSDN社区云</a>💖💛💙</p>\n<p><span style=\"color:#ff9900;\"><strong>期待hxd的支持哈🎉 🎉 🎉</strong></span></p>\n<p><strong><span style=\"color:#fe2c24;\">最后是打鸡血环节：</span><span style=\"color:#4da8ee;\">你只管努力，剩下的交给天意</span></strong><span style=\"color:#4da8ee;\">🚀 🚀 🚀  </span></p>\n</blockquote>\n<h1 id=\"1.%20vector%E7%9A%84%E4%BB%8B%E7%BB%8D\">list的介绍</h1>\n<blockquote>\n<p><a href=\"https://cplusplus.com/reference/list/list/?kw=list\" title=\"list - C++ Reference (cplusplus.com)\">list - C++ Reference (cplusplus.com)</a></p>\n<p><img alt=\"\" height=\"718\" src=\"..\\..\\static\\image\\7fbfdb7177fa48c2bc98b8383a1dcd37.png\" width=\"1200\"/></p>\n<p> <span style=\"color:#777777;\">1. list是可以在常数范围内在<strong>任意位置</strong>进行插入和删除的序列式容器，并且该容器可以<strong>前后双向迭代。 </strong></span></p>\n<div>\n<span style=\"color:#777777;\">2. list</span>\n<span style=\"color:#777777;\">的<strong>底层</strong>是<strong>带头双向循环链表</strong>结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">3. list</span>\n<span style=\"color:#777777;\">与</span>\n<span style=\"color:#777777;\">forward_list</span>\n<span style=\"color:#777777;\">非常相似：最主要的不同在于</span>\n<span style=\"color:#777777;\">forward_list</span>\n<span style=\"color:#777777;\">是单链表，只能朝前迭代，已让其更简单高效。 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">4. </span>\n<span style=\"color:#777777;\">与其他的序列式容器相比</span>\n<span style=\"color:#777777;\">(array</span>\n<span style=\"color:#777777;\">，</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">，</span>\n<span style=\"color:#777777;\">deque)</span>\n<span style=\"color:#777777;\">，</span>\n<span style=\"color:#777777;\">list</span>\n<span style=\"color:#777777;\">通常在任意位置进行插入、移除元素的执行效率更好。 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">5. </span>\n<span style=\"color:#777777;\">与其他序列式容器相比，</span>\n<span style=\"color:#777777;\">list</span>\n<span style=\"color:#777777;\">和</span>\n<span style=\"color:#777777;\">forward_list</span>\n<span style=\"color:#777777;\"><strong>最大的缺陷是不支持任意位置的随机访问</strong>，比如：要访问</span>\n<span style=\"color:#777777;\">list的第6</span>\n<span style=\"color:#777777;\">个元素，必须从已知的位置</span>\n<span style=\"color:#777777;\">(</span>\n<span style=\"color:#777777;\">比如头部或者尾部</span>\n<span style=\"color:#777777;\">)</span>\n<span style=\"color:#777777;\">迭代到该位置，在这段位置上迭代需要线性的时间 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">另外，</span>\n<span style=\"color:#777777;\">list</span>\n<span style=\"color:#777777;\">还需要一些额外的空间，以保存每个节点的相关联信息</span>\n<span style=\"color:#777777;\">(</span>\n<span style=\"color:#777777;\">对于存储类型较小元素的大</span>\n<span style=\"color:#777777;\">list</span>\n<span style=\"color:#777777;\">来说这可能是一个重要的因素)</span>\n</div>\n<div></div>\n<div>\n  早在C语言章节就已经实现过了带头双向循环链表了，但是这次C++不同的是迭代器类的实现，与以往有较大区别，注意理解\n </div>\n</blockquote>\n<h2 id=\"list%E7%9A%84%E6%9E%84%E9%80%A0\"><span style=\"color:#777777;\"><strong>list</strong></span><span style=\"color:#777777;\"><strong>的构造 </strong></span></h2>\n<blockquote>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>构造函数（ </strong></span>\n<span style=\"color:#4183c4;\"><strong>(constructor)</strong></span>\n<span style=\"color:#777777;\"><strong>）</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>接口说明 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>list (size_type n, const value_type&amp; val = value_type()) </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>构造的</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中包含</strong></span>\n<span style=\"color:#777777;\"><strong>n</strong></span>\n<span style=\"color:#777777;\"><strong>个值为</strong></span>\n<span style=\"color:#777777;\"><strong>val</strong></span>\n<span style=\"color:#777777;\"><strong>的元素 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>list() </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>构造空的</strong></span>\n<span style=\"color:#777777;\"><strong>list </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>list (const list&amp; x)</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>拷贝构造函数</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>list (InputIterator fifirst, InputIterator last)</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>用</strong></span>\n<span style=\"color:#777777;\"><strong>[fifirst, last)</strong></span>\n<span style=\"color:#777777;\"><strong>区间中的元素构造</strong></span>\n<span style=\"color:#777777;\"><strong>list </strong></span>\n</div> </td></tr></tbody></table>\n<p> 其实学到这里了这什么函数是用来干什么的应该是一看就会了，但是考虑到文章的完整性和一些小白，就还是“冗余”得把这些函数及解释写了出来</p>\n</blockquote>\n<h2 id=\"list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8\"><span style=\"color:#777777;\"><strong>list iterator</strong></span><span style=\"color:#777777;\"><strong>的使用 </strong></span></h2>\n<blockquote>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>函数声明</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>接口说明</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>begin</strong></span>\n<span style=\"color:#777777;\"> + </span>\n</div>\n<div>\n<span style=\"color:#4183c4;\"><strong>end </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>返回第一个元素的迭代器</strong></span>\n<span style=\"color:#777777;\">+</span>\n<span style=\"color:#777777;\"><strong>返回最后一个元素下一个位置的迭代器</strong></span>\n</div>\n<div>\n<span style=\"color:#777777;\"><strong>                                end（）就是头的位置</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>rbegin</strong></span>\n<span style=\"color:#777777;\"> + </span>\n</div>\n<div>\n<span style=\"color:#4183c4;\"><strong>rend </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>返回第一个元素的</strong></span>\n<span style=\"color:#777777;\"><strong>reverse_iterator,</strong></span>\n<span style=\"color:#777777;\"><strong>即</strong></span>\n<span style=\"color:#777777;\"><strong>end</strong></span>\n<span style=\"color:#777777;\"><strong>位置</strong></span>\n<span style=\"color:#777777;\">，</span>\n<span style=\"color:#777777;\"><strong>返回最后一个元素下一个位置的 </strong></span>\n<span style=\"color:#777777;\"><strong>reverse_iterator,</strong></span>\n<span style=\"color:#777777;\"><strong>即</strong></span>\n<span style=\"color:#777777;\"><strong>begin</strong></span>\n<span style=\"color:#777777;\"><strong>位置 </strong></span>\n</div> </td></tr></tbody></table>\n<p>PS:</p>\n<div>\n<span style=\"color:#777777;\">1. </span>\n<span style=\"color:#777777;\"><strong>begin</strong></span>\n<span style=\"color:#777777;\"><strong>与</strong></span>\n<span style=\"color:#777777;\"><strong>end</strong></span>\n<span style=\"color:#777777;\"><strong>为正向迭代器，对迭代器执行</strong></span>\n<span style=\"color:#777777;\"><strong>++</strong></span>\n<span style=\"color:#777777;\"><strong>操作，迭代器向后移动 </strong></span>\n</div>\n<div>\n<span style=\"color:#777777;\">2. </span>\n<span style=\"color:#777777;\"><strong>rbegin(end)</strong></span>\n<span style=\"color:#777777;\"><strong>与</strong></span>\n<span style=\"color:#777777;\"><strong>rend(begin)</strong></span>\n<span style=\"color:#777777;\"><strong>为反向迭代器，对迭代器执行</strong></span>\n<span style=\"color:#777777;\"><strong>++</strong></span>\n<span style=\"color:#777777;\"><strong>操作，迭代器向前移动</strong></span>\n</div>\n</blockquote>\n<h2 id=\"list%20capacity\"><span style=\"color:#777777;\"><strong>list capacity </strong></span></h2>\n<div></div>\n<blockquote>\n<div>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>函数声明 </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>接口说明</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>empty </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>检测</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>是否为空，是返回</strong></span>\n<span style=\"color:#777777;\"><strong>true</strong></span>\n<span style=\"color:#777777;\"><strong>，否则返回</strong></span>\n<span style=\"color:#777777;\"><strong>false </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>size </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>返回</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中有效节点的个数</strong></span>\n</div> </td></tr></tbody></table>\n</div>\n</blockquote>\n<h2 id=\"list%20element%20access\"><span style=\"color:#777777;\"><strong>list element access</strong></span></h2>\n<div></div>\n<blockquote>\n<div>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>函数声明</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>接口说明</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>front </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>返回</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>的第一个节点中值的引用</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>back </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>返回</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>的最后一个节点中值的引用</strong></span>\n</div> </td></tr></tbody></table>\n</div>\n</blockquote>\n<h2 id=\"list%20modififiers\"><span style=\"color:#777777;\"><strong>list modififiers</strong></span></h2>\n<div></div>\n<blockquote>\n<div>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>\n<div>\n<span style=\"color:#777777;\"><strong>函数声明</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>接口说明 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>push_front </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>在</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>首元素前插入值为</strong></span>\n<span style=\"color:#777777;\"><strong>val</strong></span>\n<span style=\"color:#777777;\"><strong>的元素 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>pop_front </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>删除</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中第一个元素 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>push_back </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>在</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>尾部插入值为</strong></span>\n<span style=\"color:#777777;\"><strong>val</strong></span>\n<span style=\"color:#777777;\"><strong>的元素 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>pop_back</strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>删除</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中最后一个元素 </strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>insert </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>在</strong></span>\n<span style=\"color:#777777;\"><strong>list position </strong></span>\n<span style=\"color:#777777;\"><strong>位置中插入值为</strong></span>\n<span style=\"color:#777777;\"><strong>val</strong></span>\n<span style=\"color:#777777;\"><strong>的元素</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>erase </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>删除</strong></span>\n<span style=\"color:#777777;\"><strong>list position</strong></span>\n<span style=\"color:#777777;\"><strong>位置的元素</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>swap </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>交换两个</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中的元素</strong></span>\n</div> </td></tr><tr><td>\n<div>\n<span style=\"color:#4183c4;\"><strong>clear </strong></span>\n</div> </td><td>\n<div>\n<span style=\"color:#777777;\"><strong>清空</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中的有效元素</strong></span>\n</div> </td></tr></tbody></table>\n</div>\n</blockquote>\n<h2 id=\"list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88\"><span style=\"color:#777777;\"><strong>list</strong></span><span style=\"color:#777777;\"><strong>的迭代器失效</strong></span></h2>\n<div></div>\n<blockquote>\n<div>\n<div>\n<span style=\"color:#777777;\"><strong>迭代器失效即迭代器所指向的节点的无效，即该节</strong></span>\n<span style=\"color:#777777;\"><strong>点被删除了</strong></span>\n<span style=\"color:#777777;\">。因为</span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>的底层结构为带头结点的双向循环链表</strong></span>\n<span style=\"color:#777777;\">，因此</span>\n<span style=\"color:#777777;\"><strong>在</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>中进行插入时是不会导致</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\"><strong>的迭代</strong></span>\n<span style=\"color:#777777;\"><strong>器失效的，只有在删除时才会失效，并且失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响</strong></span>\n<span style=\"color:#777777;\">。</span>\n</div>\n</div>\n</blockquote>\n<h1 id=\"%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8\">关于迭代器</h1>\n<blockquote>\n<div>\n<span style=\"color:#777777;\"><strong>迭代器是对原生态指针</strong></span>\n<span style=\"color:#777777;\"><strong>(</strong></span>\n<span style=\"color:#777777;\"><strong>节点指针</strong></span>\n<span style=\"color:#777777;\"><strong>)</strong></span>\n<span style=\"color:#777777;\"><strong>进行封装</strong></span>\n</div>\n<div>\n<span style=\"color:#777777;\"><strong>迭</strong></span>\n<span style=\"color:#777777;\"><strong>代</strong></span>\n<span style=\"color:#777777;\"><strong>器</strong></span>\n<span style=\"color:#777777;\"><strong>失</strong></span>\n<span style=\"color:#777777;\"><strong>效</strong></span>\n</div>\n<div>\n<div>\n<span style=\"color:#777777;\"><strong>插入元素不会导致迭代器失效， </strong></span>\n<span style=\"color:#777777;\"><strong>删除元素时，只会导致当前迭代</strong></span>\n<span style=\"color:#777777;\"><strong>器失效，其他迭代器不受影响</strong></span>\n</div>\n</div>\n</blockquote>\n<h1 id=\"list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\"><span style=\"color:#333333;\"><strong>list</strong></span><span style=\"color:#333333;\"><strong>的模拟实现 </strong></span></h1>\n<div></div>\n<h2 id=\"main.cpp\">main.cpp</h2>\n<div>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS 1\n\n#include\"List.h\"\n\nint main()\n{\n\tmy_list&lt;int&gt; l;\n\tl.insert(l.begin(), 1);\n\tl.insert(l.end(), 2);\n\tl.insert(l.end(), 2);\n\tl.insert(l.end(), 2);\n\tl.insert(l.end(), 7);\n\tl.insert(l.end(), 5);\n\tl.push_back(100);\n\tl.push_back(150);\n\tl.push_back(11);\n\tl.push_front(33);\n\tl.push_front(66);\n\tmy_list&lt;int&gt;::iterator it = l.begin();\n\twhile (it != l.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; endl;\n\n\tl.pop_back();\n\tl.pop_back();\n\tl.pop_front();\n\tl.pop_front();\n\tit = l.begin();\n\n\tit = l.begin();\n\twhile (it != l.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; endl;\n\n\tit = l.begin();\n\twhile (it != l.end())\n\t{\n\t\tif (*it % 2 == 0)\n\t\t{\n\t\t\tit = l.erase(it);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit++;\n\t\t}\n\t}\n\n\tit = l.begin();\n\twhile (it != l.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; endl;\n\n\tmy_list&lt;int&gt; l2(l);\n\tit = l2.begin();\n\twhile (it != l2.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; endl;\n\n\tit = l.begin();\n\tmy_list&lt;int&gt;::iterator it2 = --it;\n\n\tcout &lt;&lt; *it &lt;&lt; endl;\n\tcout &lt;&lt; *it2 &lt;&lt; endl;\n\t//cout &lt;&lt; l.front() &lt;&lt; endl;\n\t//cout &lt;&lt; l.back() &lt;&lt; endl;\n\n\t//cout &lt;&lt;  *(l.begin()--) &lt;&lt; endl;\n\t//cout &lt;&lt; *(--l.begin()) &lt;&lt; endl;\n\t//cout &lt;&lt; *(l.begin()++) &lt;&lt; endl;\n\t//cout &lt;&lt; *(++l.begin()) &lt;&lt; endl;\n}\n\n</code></pre>\n</div>\n<h2 id=\"List.h\">List.h</h2>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;assert.h&gt;\n\nusing std::cout;\nusing std::endl;\n\n// List的节点类\ntemplate&lt;class T&gt;\nstruct ListNode\n{\n    ListNode(const T&amp; val = T())\n        :_pPre(nullptr),\n        _pNext(nullptr),\n        _val(val)\n    {}\n    ListNode&lt;T&gt;* _pPre;\n    ListNode&lt;T&gt;* _pNext;\n    T _val;\n};\n\n//List的迭代器类\ntemplate&lt;class T, class Ref, class Ptr&gt;\nstruct  ListIterator\n{\n    typedef ListNode&lt;T&gt;* PNode;\n    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;\n\n    //给reverse_iterator 用 ，这样反向迭代器类就可以不用传后面两个参数了\n    typedef  T&amp; Ref;\n    typedef  T* Ptr;\n\n    ListIterator(PNode pNode = nullptr)\n        :_pNode(pNode)\n    {}\n    //it1(it2)\n    ListIterator(const Self&amp; l)\n    {\n        _pNode = l._pNode;\n    }\n    //模板参数  Ref    Ptr 的作用   ，返回 const和非const对象(由传参决定)\n    //(其实就是两个类了，同一个类模板，参数不同，会实例化出不同类型的对象)\n    Ref operator*()\n    {\n        return _pNode-&gt;_val;\n    }\n    Ptr operator-&gt;()             //注意返回值                            \n    {\n        //return &amp;(operator*());\n        return &amp;_pNode-&gt;_val;\n    }\n    Self&amp; operator++()\n    {\n        _pNode = _pNode-&gt;_pNext;\n        return*this;\n    }\n    Self operator++(int)\n    {\n        Self tmp(*this);\n        _pNode = _pNode-&gt;_pNext;\n        return tmp;\n    }\n    Self&amp; operator--()\n    {\n        _pNode = _pNode-&gt;_pPre;\n        return *this;\n    }\n    Self&amp; operator--(int)\n    {\n        Self tmp = *this;\n        _pNode = _pNode-&gt;_pPre;\n        return tmp;\n    }\n    bool operator!=(const Self&amp; l)\n    {\n        return !(operator==(l));\n    }\n    bool operator==(const Self&amp; l)\n    {\n        return _pNode == l._pNode;\n    }\n    PNode _pNode;\n};\n\n//List的反向迭代器类\ntemplate&lt;class ListIterator&gt;\nstruct  ReverseIterator\n{\n    typedef typename ListIterator::Ref Ref;\n    typedef typename ListIterator::Ptr Ptr;\n    typedef ReverseIterator&lt;ListIterator&gt; Self;\n\n    ReverseIterator(ListIterator it)\n        :_it(it)\n    {}\n    //it1(it2)\n    ReverseIterator(const Self&amp; l)\n    {\n        _it = l._it;\n    }\n\n    Ref operator*()\n    {\n        ListIterator temp(_it);\n        --temp;\n        return *temp;\n    }\n    Ptr operator-&gt;()             //注意返回值                            \n    {\n        return &amp;(operator*());\n    }\n    Self&amp; operator++()\n    {\n        --_it;\n        return *this;\n    }\n    Self operator++(int)\n    {\n        Self temp(*this);\n        --_it;\n        return temp;\n    }\n    Self&amp; operator--()\n    {\n        ++_it;\n        return *this;\n    }\n    Self&amp; operator--(int)\n    {\n        Self temp(*this);\n        ++_it;\n        return temp;\n    }\n    bool operator!=(const Self&amp; l)\n    {\n        return _it != l._it;\n    }\n    bool operator==(const Self&amp; l)\n    {\n        return _it == l._it;\n    }\n    ListIterator _it;\n};\n\n//list类\ntemplate&lt;class T&gt;\nclass my_list\n{\n    typedef ListNode&lt;T&gt; Node;\n    typedef Node* PNode;\npublic:\n    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;\n    //只有后面两个加上const是因为只有这里是控制const迭代器不能修改的地方\n    typedef ListIterator&lt;T, const T&amp;, const T&amp;&gt; const_iterator;\n\n    typedef ReverseIterator&lt;iterator&gt; reverse_itrator;\n    typedef ReverseIterator&lt;const_iterator&gt; const_reverse_itrator;\npublic:\n    ///\n    // List的构造\n    my_list()\n    {\n        CreateHead();\n    }\n    my_list(int n, const T&amp; value = T())\n    {\n        CreateHead();\n        for (int i = 0; i &lt; n; i++)\n        {\n            push_back(value);\n        }\n    }\n    template &lt;class Iterator&gt;\n    my_list(Iterator first, Iterator last)\n    {\n        CreateHead();\n        while (first != last)\n        {\n            push_back(*first);\n            first++;\n        }\n    }\n    //lt1(lt2)                 lt2\n    my_list(const my_list&lt;T&gt;&amp; l)\n    {\n        CreateHead();\n        my_list&lt;T&gt; tmp(l.begin(), l.end());\n        this-&gt;swap(tmp);\n    }\n    my_list&lt;T&gt;&amp; operator=(my_list&lt;T&gt; l)\n    {\n        this-&gt;swap(l);\n        return *this;\n    }\n    ~my_list()\n    {\n        clear();\n        delete _pHead;\n        _pHead = nullptr;\n    }\n    ///\n    // List Iterator\n    iterator begin()\n    {\n        return iterator(_pHead-&gt;_pNext);\n    }\n    iterator end()\n    {\n        return iterator(_pHead);\n    }\n    const_iterator begin()const\n    {\n        return const_iterator(_pHead-&gt;_pNext);\n    }\n    const_iterator end()const\n    {\n        return const_iterator(_pHead);\n    }\n\n    // List Reversez_Iterator\n    reverse_itrator rbegin()\n    {\n        return reverse_itrator(iterator);\n    }\n    reverse_itrator rend()\n    {\n        return reverse_itrator(iterator);\n    }\n    const_reverse_itrator crbegin()const\n    {\n        return const_reverse_itrator(const_iterator);\n    }\n    const_reverse_itrator crend()const\n    {\n        return const_reverse_itrator(const_iterator);\n    }\n\n    ///\n    // List Capacity\n    size_t size()const\n    {\n        size_t sz = 0;\n        iterator it = begin();\n        while (it != end())\n        {\n            sz++;\n            it++;\n        }\n        return sz;\n    }\n    bool empty()const\n    {\n        return size() == 0;\n    }\n    \n    // List Access\n    T&amp; front()\n    {\n        return _pHead-&gt;_pNext-&gt;_val;\n    }\n    const T&amp; front()const\n    {\n        return _pHead-&gt;_pNext-&gt;_val;\n    }\n    T&amp; back()\n    {\n        return _pHead-&gt;_pPre-&gt;_val;\n    }\n    const T&amp; back()const\n    {\n        return _pHead-&gt;_pPre-&gt;_val;\n    }\n    \n    // List Modify\n    void push_back(const T&amp; val) { insert(end(), val); }\n    void pop_back() { erase(--end()); }\n    void push_front(const T&amp; val) { insert(begin(), val); }\n    void pop_front() { erase(begin()); }\n    // 在pos位置前插入值为val的节点\n    iterator insert(iterator pos, const T&amp; val)\n    {\n        //    prev  new  cur \n        Node* newnode = new Node(val);\n        Node* cur = pos._pNode;\n        Node* prev = cur-&gt;_pPre;\n\n        prev-&gt;_pNext = newnode;\n        newnode-&gt;_pPre = prev;\n        newnode-&gt;_pNext = cur;\n        cur-&gt;_pPre = newnode;\n\n        //返回新插入的位置\n        return iterator(newnode);\n    }\n    // 删除pos位置的节点，返回该节点的下一个位置\n    iterator erase(iterator pos)\n    {\n        assert(pos != end());\n\n        Node* cur = pos._pNode;\n        Node* prev = cur-&gt;_pPre;\n        Node* next = cur-&gt;_pNext;\n\n        prev-&gt;_pNext = next;\n        next-&gt;_pPre = prev;\n        delete cur;\n        //匿名对象\n        return iterator(next);\n    }\n    void clear()\n    {\n        iterator it = begin();\n        while (it != end())\n        {\n            it = erase(it);\n            it++;\n        }\n    }\n    void swap(my_list&lt;T&gt;&amp; l)\n    {\n        std::swap(_pHead, l._pHead);\n    }\nprivate:\n    void CreateHead()\n    {\n        _pHead = new Node();\n        _pHead-&gt;_pPre = _pHead;\n        _pHead-&gt;_pNext = _pHead;\n    }\n    PNode _pHead;\n};</code></pre>\n<blockquote>\n<p><span style=\"color:#956fe7;\">最后的最后，创作不易，希望读者三连支持💖</span></p>\n<p><span style=\"color:#956fe7;\">赠人玫瑰，手有余香💖</span></p>\n</blockquote>\n</div>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-06 12:24:20", "summary": "目录的介绍的构造的使用的迭代器失效关于迭代器的模拟实现语言总结在这在这常见八大排序在这在这作者和朋友建立的社区：非科班转码社区社区云非科班转码社区社区云期待的支持哈最后是打鸡血环节：你只管努力，剩下的"}