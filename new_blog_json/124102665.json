{"blogid": "124102665", "writerAge": "码龄175天", "writerBlogNum": "32", "writerCollect": "56", "writerComment": "0", "writerFan": "3", "writerGrade": "2级", "writerIntegral": "334", "writerName": "Java指南修炼", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124102665.jpg", "writerRankTotal": "56862", "writerRankWeekly": "120571", "writerThumb": "4", "writerVisitNum": "18866", "blog_read_count": "8036", "blog_time": "已于 2022-04-11 16:38:09 修改", "blog_title": "微服务之间相互调用的三种最常见方式（含源码）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p> 相信大家平时开发的时候没少碰见，在微服务架构中需要调用很多服务才能完成一项功能。这时候，如何互相调用就变成微服务架构中的一个关键问题。在这里我介绍三个常用的方法</p>\n<p></p>\n<h2><strong>一、RestTemplate方式</strong></h2>\n<pre><code class=\"language-java\">@Bean\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }</code></pre>\n<p>服务的消费者（order）调用服务的提供者（Goods）</p>\n<pre><code class=\"language-java\">@Autowired\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/createOrder/{gid}/{number}\")\n    public Order order(@PathVariable(\"gid\") Integer id,@PathVariable(\"number\") Integer number){\n        log.info(\"用户开始下单,调用商品系统，查询{}号商品信息\",id);\n        Goods goods = restTemplate.getForObject(\"http://localhost:9002/goods/getGoods/\" + id, Goods.class);\n        log.info(\"商品信息查询完毕：\"+ JSON.toJSONString(goods));\n\n        log.info(\"开始下单：\");\n        Order order = new Order();\n        order.setUid(1);\n        order.setUname(\"测试用户\");\n        order.setGid(goods.getId());\n        order.setGname(goods.getGoodsName());\n        order.setNumber(number);\n\n        orderService.createOrder(order);\n        log.info(\"下单成功\");\n        return order;\n    }</code></pre>\n<p>通过上面的方式我们解决了微服务之间的相互调用，但是存在硬编码的问题，如果服务提供者的地址发生变化，就需要手工修改代码；如果有多个服务提供者，无法实现服务的负载均衡；如果服务增多，人工调用会变得更加的复杂。</p>\n<p>这个时候就会需要服务治理，服务治理是微服务架构最核心的问题，用于实现各个微服务的自动化注册与发现。在这里选择Nacos。</p>\n<p></p>\n<h2><strong>二、引入Nacos注册中心</strong></h2>\n<p>1.在服务的提供者与消费者的pom文件中引入依赖</p>\n<pre><code class=\"language-java\">&lt;!--nacos客户端--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n        &lt;/dependency&gt;</code></pre>\n<p>2.在application.yml中添加配置</p>\n<pre><code class=\"language-java\">spring:\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 192.168.206.151:8848</code></pre>\n<p>3.在对应的微服务上添加</p>\n<pre><code class=\"language-java\">@EnableDiscoveryClient</code></pre>\n<p>4.代码</p>\n<pre><code class=\"language-java\">   @Autowired\n    private RestTemplate restTemplate;\n   @Autowired\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/createOrder2/{gid}/{number}\")\n    public Order order2(@PathVariable(\"gid\") Integer id,@PathVariable(\"number\") Integer number){\n        log.info(\"用户开始下单,调用商品系统，查询{}号商品信息\",id);\n        //从nacos中获取服务地址\n        ServiceInstance service = discoveryClient.getInstances(\"goods-service\").get(0);\n        String url = service.getHost() + \":\" + service.getPort();\n        //通过restTemplate调用\n        Goods goods = restTemplate.getForObject(\"http://\"+url+\"/goods/getGoods/\" + id, Goods.class);\n        log.info(\"商品信息查询完毕：\"+ JSON.toJSONString(goods));\n\n        log.info(\"开始下单：\");\n        Order order = new Order();\n        order.setUid(1);\n        order.setUname(\"测试用户\");\n        order.setGid(goods.getId());\n        order.setGname(goods.getGoodsName());\n        order.setNumber(number);\n\n        orderService.createOrder(order);\n        log.info(\"下单成功\");\n        return order;\n    }</code></pre>\n<p>注：DiscoveryClient是专门负责服务注册和发现的，我们可以通过它获取到注册到注册中心的所有服务</p>\n<p></p>\n<h2><strong>三、Fegin实现服务调用</strong></h2>\n<p>Feign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。</p>\n<p>Nacos很好的兼容了Feign， Feign默认集成了 Ribbon， 所以在Nacos下使用Fegin默认就实现了负载均衡的效果。</p>\n<p>在服务消费者上进行以下操作：</p>\n<p>1.添加依赖</p>\n<pre><code class=\"language-java\">&lt;!--fegin组件--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>2.在启动类上添加注解</p>\n<pre><code class=\"language-java\">@EnableFeignClients</code></pre>\n<p>3.新建client包，并创建接口(把服务提供者controller对应的方法名复制过来，注意路径要完整。</p>\n<pre><code class=\"language-java\">@FeignClient(\"goods-service\")\npublic interface GoodsService {\n\n    @RequestMapping(\"/goods/getGoods/{id}\")\n    public Goods goods(@PathVariable(\"id\") Integer id);\n}</code></pre>\n<p>4.代码</p>\n<pre><code class=\"language-java\">@Autowired\n    private GoodsService goodsService;\n\n    @GetMapping(\"/createOrder3/{gid}/{number}\")\n    public Order order3(@PathVariable(\"gid\") Integer id,@PathVariable(\"number\") Integer number){\n        log.info(\"用户开始下单,调用商品系统，查询{}号商品信息\",id);\n\n        //通过feign调用商品微服务\n        Goods goods = goodsService.goods(id);\n        log.info(\"商品信息查询完毕：\"+ JSON.toJSONString(goods));\n\n        log.info(\"开始下单：\");\n        Order order = new Order();\n        order.setUid(1);\n        order.setUname(\"测试用户\");\n        order.setGid(goods.getId());\n        order.setGname(goods.getGoodsName());\n        order.setNumber(number);\n\n        orderService.createOrder(order);\n        log.info(\"下单成功\");\n        return order;\n    }</code></pre>\n<p>好了，先介绍到这里，想要以上demo的可以加微信领取，另外还有一份《Java最新2022版面试题及解答-阿里内部资料(266页)》可以免费送给大家。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"279\" src=\"..\\..\\static\\image\\2f039679c9844ebaaa66628ba1f773fc.png\" width=\"561\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-11 16:38:09", "summary": "相信大家平时开发的时候没少碰见，在微服务架构中需要调用很多服务才能完成一项功能。这时候，如何互相调用就变成微服务架构中的一个关键问题。在这里我介绍三个常用的方法一、方式服务的消费者调用服务的提供者用户"}