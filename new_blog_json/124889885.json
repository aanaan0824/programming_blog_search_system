{"blogid": "124889885", "writerAge": "码龄161天", "writerBlogNum": "54", "writerCollect": "2352", "writerComment": "2792", "writerFan": "2523", "writerGrade": "6级", "writerIntegral": "7306", "writerName": "锡兰_CC", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124889885.jpg", "writerRankTotal": "2027", "writerRankWeekly": "113", "writerThumb": "2544", "writerVisitNum": "40144", "blog_read_count": "922", "blog_time": "已于 2022-05-25 08:57:51 修改", "blog_title": "【开卷数据结构 】稀疏矩阵", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"main-toc\"><strong>目录</strong></h1>\n<p id=\"%F0%9F%8C%BA203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8C%BA203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0\">🌺稀疏矩阵</a></p>\n<p id=\"%F0%9F%8D%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">🍁矩阵与稀疏矩阵的定义</a></p>\n<p id=\"%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE\">🌺稀疏矩阵的转置</a></p>\n<p id=\"%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF\">🍁详细思路</a></p>\n<p id=\"%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%B8%80%E3%80%90%E8%BF%AD%E4%BB%A3%E3%80%91-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%B8%80%E3%80%90%E8%BF%AD%E4%BB%A3%E3%80%91\">🍀思路一</a></p>\n<p id=\"%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%BA%8C-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%BA%8C\">🍀思路二</a></p>\n<p id=\"%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95\">🌺稀疏矩阵的乘法</a></p>\n<p id=\"%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF\">🍁详细思路</a></p>\n<p class=\"img-center\"><img alt=\"94536690f848438fab30aa17191a6ea2.png\" src=\"..\\..\\static\\image\\94536690f848438fab30aa17191a6ea2.png\"/></p>\n<h1 id=\"%F0%9F%8C%BA203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0\">🌺稀疏矩阵</h1>\n<blockquote>\n<h2 id=\"%F0%9F%8D%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span style=\"background-color:#f9eda6;\">🍁矩阵与稀疏矩阵的定义</span></h2>\n<hr/>\n<p><span style=\"color:#38d8f0;\"><strong>Q：什么是矩阵</strong></span></p>\n<p></p>\n<p><span style=\"color:#ff9900;\"><strong>A：</strong></span>数学上，一个<span style=\"color:#956fe7;\">矩阵</span>由 m 行 n 列的元素组成，是一个 m 行，n 列的表，m 和 n 是矩阵的<span style=\"color:#956fe7;\">维度</span>。一般地，写作 mxn（读作“m乘n”）来指明一个 m 行 n 列矩阵。矩阵的元素个数总计为 mn 个。<span style=\"color:#be191c;\">如果 m 等于 n ，矩阵为方阵</span>。</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"336\" src=\"..\\..\\static\\image\\8c5cfd90afc34440abc8f68e6e7698cc.png\" width=\"624\"/></p>\n<p><span style=\"color:#be191c;\">一般情况下，矩阵的标准存储方式是一个二维数组 a[MAX_ROWS][MAX_COLS] </span>。利用这种存储方式，可以通过 a[i][j] ，通过行下标，列下标快速找到任意元素的存储位置。</p>\n<hr/>\n<p><span style=\"color:#38d8f0;\"><strong>Q：什么是稀疏矩阵</strong></span></p>\n<p></p>\n<p><span style=\"color:#ff9900;\"><strong>A：</strong></span>一个矩阵的绝大部分都为零元素，我们把这种矩阵称为稀疏矩阵。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"319\" src=\"..\\..\\static\\image\\619d511b3f3e4fcc8750a7b1f2bd1c3e.png\" width=\"442\"/></p>\n<p><span style=\"color:#956fe7;\"><strong> </strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>如图：</strong></span>矩阵中只有 2/15 是非零元素，这就是一个标准的稀疏矩阵</p>\n<hr/>\n<p><span style=\"color:#38d8f0;\"><strong>Q：二维数组储存矩阵的缺点</strong></span></p>\n<p></p>\n<p><span style=\"color:#ff9900;\"><strong>A：</strong></span>如果一个矩阵中包含很多零元素（是稀疏矩阵），就会浪费大量的存储空间。<span style=\"color:#be191c;\">因此，稀疏矩阵的存储表示只需存储非零元素。</span></p>\n<hr/>\n<p><span style=\"color:#38d8f0;\"><strong>Q：稀疏矩阵的存储方式</strong></span></p>\n<p></p>\n<p><span style=\"color:#ff9900;\"><strong>A：</strong></span>通过对矩阵的分析，我们发现使用三元组 &lt;row,col,value&gt; 能够唯一的刻画矩阵的任意一个元素。<span style=\"color:#be191c;\">这意味者可以使用三元数组来存储表示稀疏矩阵。</span></p>\n<p><strong>💬 代码演示</strong></p>\n<pre><code class=\"language-cpp\">#define MAX_TERMS 101\t//定义最大长度 \ntypedef struct{\n\tint col;\n\tint row;\n\tint xalue;\n}term;\nterm a[MAX_TERMS];\n</code></pre>\n<p>我们可以用 a[0].row 表示行的数目，用 a[0].col 表示列的数目，用 a[0].value 表示非零元素的总数。其他位置 row 域存放行下标， col 域存放列下标，value 域存放元素值。<span style=\"color:#be191c;\">三元组按照行的顺序排序，并且在同一行内按照列的顺序排序。</span></p>\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><caption>\n   稀疏矩阵存储为三元组\n  </caption><thead><tr><th></th><th>行</th><th>列</th><th>值</th></tr></thead><tbody><tr><td>a[0]</td><td>5</td><td>6</td><td>4</td></tr><tr><td>a[1]</td><td>0</td><td>0</td><td>15</td></tr><tr><td>a[2]</td><td>1</td><td>1</td><td>11</td></tr><tr><td>a[3]</td><td>2</td><td>3</td><td>6</td></tr><tr><td>a[4]</td><td>4</td><td>0</td><td>9</td></tr></tbody></table>\n<p></p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"94536690f848438fab30aa17191a6ea2.png\" src=\"..\\..\\static\\image\\94536690f848438fab30aa17191a6ea2.png\"/></p>\n<h1 id=\"%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE\">🌺稀疏矩阵的转置</h1>\n<blockquote>\n<h2 id=\"%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF\"><span style=\"background-color:#f9eda6;\">🍁详细思路</span></h2>\n<p>为了转置一个矩阵，必须交换它的行和列。也就是说，原矩阵的任意元素 a[i][j] 应该成为其转置矩阵的元素 b[j][i]</p>\n<hr/>\n<h3 id=\"%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%B8%80%E3%80%90%E8%BF%AD%E4%BB%A3%E3%80%91\"><span style=\"background-color:#c7e6ea;\">🍀思路一</span></h3>\n<p>依次循环每一列，找到每一列的所有元素并把他们储存在转置矩阵的对应的行上。</p>\n<pre><code class=\"language-cpp\">//伪代码\nfor 对于 j 列的所有元素\n    把元素&lt;i，j，value&gt;放置在元素&lt;j，i，value&gt;中</code></pre>\n<p><strong>💬 代码演示</strong></p>\n<pre><code class=\"language-cpp\">void transpose(term a[],term b[])\n//b是a的转置 \n{\n\tint n,i,j,currentb;\n\tn=a[0].value;\t\t\t//元素总数 \n\tb[0].row=a[0].col;\t\t//b的行数=a的列数\n\tb[0].co 1=a[0].row;\t    //b的列数=a的行数\n\tb[0].value =n;\n\tif(n&gt; 0) \n\t{// 非零矩阵 \n\t\tcurrentb=1;\n\t\tfor(i=0;i&lt;a[0].col;i++)\n\t\t//按a的列转置\n\t\t\tfor(j=1;j&lt;=n;j++)\n\t\t\t//找出当前列的所有元素\n\t\t\t\tif(a[j].col==i)\n\t\t\t\t{//元素是当前列的，加入b\n\t\t\t\t\tb[currentb]. row=a[j]. col;\n\t\t\t\t\tb[currentb]. col=a[j]. row;\n\t\t\t\t\tb[currentb]. value=a[j]. value;\n\t\t\t\t\tcurrentb++;\n\t\t\t\t}\n\t}\n}</code></pre>\n<hr/>\n<h3 id=\"%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%BA%8C\"><span style=\"background-color:#c7e6ea;\">🍀思路二</span></h3>\n<p><span style=\"color:#be191c;\">首先确定原矩阵中每一列的元素个数，这也就是其转置矩阵中每一行的元素个数</span>。于是就可以得到转置矩阵每行的起始位置，从而，<span style=\"color:#956fe7;\">可以将原矩阵的元素依次移到其转置矩阵中的恰当位置</span>。</p>\n<p><strong>💬 代码演示</strong></p>\n<pre><code class=\"language-cpp\">void fast transpose(term a[], term b[])\n{\n//将a的转置矩阵存放于b中 \n\tint row terms[MAX_COL], starting pos[MAX_COL]; \n\tint i,j, num_cols=a[0].col, num_terms=a[0].value;\n\tb[0].row=num_cols;b[0].col=a[0].row;\n\tb[0].value=num_terms;\n\tif(num_terms&gt;0){//非零矩阵\n\t\tfor(i=0;i&lt;num_cols;i++)\n\t\t\trow_terms[i]=0;\n\t\tfor(i=1;i&lt;=num_terms;i++)\n\t\t\trow_terms[a[i]. co]]++;\n\t\tstarting_pos[0]=1;\n\t\tfor(i=1;i&lt;num cols;i++)\n\t\t\tstarting_pos[i]=starting_pos[i-1]+row_terms[i-l];\n\t\tfor(i=1;i&lt;=num_terms;i++){\n\t\t\tj=starting_pos[a[i].col]++;\n\t\t\tb[j].row=a[i].col;b[j].col=a[i].row;\n\t\t\tb[j].value=a[i].value;\n\t\t}\n\t}\n}</code></pre>\n</blockquote>\n<p class=\"img-center\"><img alt=\"94536690f848438fab30aa17191a6ea2.png\" src=\"..\\..\\static\\image\\94536690f848438fab30aa17191a6ea2.png\"/></p>\n<h1 id=\"%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95\">🌺稀疏矩阵的乘法</h1>\n<blockquote>\n<p><span style=\"color:#38d8f0;\"><strong>Q：什么是矩阵乘法</strong></span></p>\n<p></p>\n<p><span style=\"color:#ff9900;\"><strong>A：</strong></span>设A为 mxp 的矩阵，B为 pxn 的矩阵，那么称 mxn 的矩阵D为矩阵A与B的乘积，记作D=AB，其中矩阵D中的第 i 行第 j 列元素可以表示为：</p>\n<p class=\"img-center\"><img alt=\"\" height=\"68\" src=\"..\\..\\static\\image\\21ffbc47a3f649f8a2ece920f8849b49.png\" width=\"568\"/></p>\n<p><strong><span style=\"color:#956fe7;\">注意：</span></strong>两个稀疏矩阵的乘积可能不再是稀疏矩阵</p>\n<hr/>\n<h2><span style=\"background-color:#f9eda6;\">🍁详细思路</span></h2>\n<hr/>\n<p><span style=\"color:#be191c;\">我们可以按照行的顺序计算D的元素</span>，把元素存放到正确的位置，这样就不用移动已计算出的元素的位置。一般情况下，必须遍历整个B才能得到第 j 列的所有元素。但是，<span style=\"color:#956fe7;\">我们可以先计算 B 的转置</span>，使列元素顺序相续排序，可以避免重复多次遍历整个 B 。</p>\n<p>对于找出的 A 的第 i 行和 B 的第 j 列的所有元素，做合并操作就能实现矩阵乘法。</p>\n<p><strong>💬 代码演示</strong></p>\n<pre><code class=\"language-cpp\">void storesum(term a[],int *totald,int row,int column,int *sum)\n{//如果 *sum！=0，它的行和列存储位置为 d 中的 *totald+1\n\tif(*sum)\n\t\tif(*tptald&lt;MAX_TERMS)\n\t\t{\n\t\t\td[++*totald].row=row;\n\t\t\td[*totald].col=column;\n\t\t\td[*totald].value=*sum;\n\t\t\t*sum=0;\n\t\t}\n\t\telse{\n\t\t\tfprintf(stderr,\"Numbers of terms in product exceeds %d\\n\",MAX_TERMS); \n\t\t\texit(1);\n\t\t}\n}\n\n\nvoid mmult(term a[], term b[], term d[])\n//将两个稀疏矩阵相乘 \n{\n\tint i,j,column,totalb=b[0].value,totald=0; \n\tint rows_a=a[0].row,cols_a=a[0].col;\n\ttotala=a[0].value;int cols_b=b[0].col;\n\tint row_begin=1, row=a[1].row, sum=0; \n\tint new_b[MAX-TERMS][3];\n\tif(cols_a!=b[0].row){\n\t\tfprintf(stderr,\"Incompatible matrices\\n\"); \n\t\texit(1);\n\t}\n\tfast_transpose(b.new_b);\n\t//设置边界条件\n\ta[totala+1].row=rows_a;\n\tnew_b[totalb+1].row=cols_b; \n\tnew_b[totalb+1].col=0;\n\tfor(i=1;i&lt;=totala;){\n\t\tcolumn=new_b[1].row; \n\t\tfor(j=1;j&lt;=totalb+1;){\n\t\t//将a的行乘以b的列\n\t\t\tif(a[i].row!=row){\n\t\t\t\tstoresum(d,&amp;totald,row,column,&amp;sum);\n\t\t\t\ti=row_begin;\n\t\t\t\tfor(;new_b[j].row==column;j++)\n\t\t\t\t\t;\n\t\t\t\tcolumn=new_b[j]. row;\n\t\t\t}\n\t\t\telse if(new_b[j].row!=column){\n\t\t\t\tstoresum(d,&amp;totald,row,column,&amp;sum); \n\t\t\t\ti=row_begin;\n\t\t\t\tcolumn=new_b[j].row;\n\t\t\t}\n\t\t\telse switch(COMPARE(a[i].col,new_b[j].col)){\n\t\t\t\tcase-1://转到a中的下一项\n\t\t\t\t\ti++;break;\n\t\t\t\tcase 0://添加项，转到a和b的下一项 \n\t\t\t\t\tsum+=(a[i++].value*new_b[j++].value); break;\n\t\t\t\tcase 1://来到b的下一项\n\t\t\t\t\tj++;\n\t\t\t}\n\t}// for j&lt;=totalb+1 结束循环 \n\tfor(;a[i].row==row;i++)\n\t\t;\n\trow_begin=i;row=a[i].row;\n\t}//for i&lt;=totala 结束循环 \n\td[0].row=rows_a;\n\td[0].col=cols_b;d[0].value=totald;\n}</code></pre>\n</blockquote>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-25 08:57:51", "summary": "目录稀疏矩阵矩阵与稀疏矩阵的定义稀疏矩阵的转置详细思路思路一思路二稀疏矩阵的乘法详细思路稀疏矩阵矩阵与稀疏矩阵的定义：什么是矩阵：数学上，一个矩阵由行列的元素组成，是一个行，列的表，和是矩阵的维度。一"}