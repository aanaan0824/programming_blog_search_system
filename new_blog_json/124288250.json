{"blogid": "124288250", "writerAge": "码龄10年", "writerBlogNum": "112", "writerCollect": "813", "writerComment": "152", "writerFan": "3841", "writerGrade": "5级", "writerIntegral": "2258", "writerName": "竹叶青lvye", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124288250.jpg", "writerRankTotal": "14221", "writerRankWeekly": "3221", "writerThumb": "149", "writerVisitNum": "231831", "blog_read_count": "9172", "blog_time": "已于 2022-05-15 18:16:29 修改", "blog_title": "OpenVINO使用介绍(一）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>接着前面系列博客继续实验，这篇来介绍OpenVINO（<span style=\"color:#fe2c24;\">Intel的</span>），主要还是参考官网资料，前面也说过好的东西，官网对其的介绍是很详尽的，我觉得此要比<a class=\"link-info\" href=\"https://blog.csdn.net/jiugeshao/article/details/123119995?spm=1001.2014.3001.5502\" title=\"Tensor RT\">Tensor RT</a>的的官网做的更好，示例sample也很多。官网参考链接如下：</p>\n<p><a class=\"has-card\" href=\"https://docs.openvino.ai/latest/get_started.html\" title=\"Get Started — OpenVINO™  documentation\"><span class=\"link-card-box\"><span class=\"link-title\">Get Started — OpenVINO™ documentation</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://docs.openvino.ai/latest/get_started.html</span></span></a><span style=\"color:#fe2c24;\">博主此时的电脑软件环境为</span><strong>：</strong></p>\n<p>Ubuntu 20.04</p>\n<p>python3.6.13 (Anaconda)</p>\n<p>cuda version: 11.2</p>\n<p>cudnn version: cudnn-11.2-linux-x64-v8.1.1.33</p>\n<p>对于不知道如何配置cuda和cudnn的同学，可参考博主<a class=\"link-info\" href=\"https://blog.csdn.net/jiugeshao/article/details/123119995?spm=1001.2014.3001.5501\" title=\"此前博客\">此前博客</a></p>\n<p></p>\n<p><strong>一.安装</strong></p>\n<p>1. 因为涉及到模型的转换及训练自己的数据集，博主这边安装<a class=\"link-info\" href=\"https://docs.openvino.ai/latest/openvino_docs_install_guides_install_dev_tools.html\" title=\"OpenVINO Development Tools\">OpenVINO Development Tools</a>，后续会在树莓派部署时，尝试下只安装<a class=\"link-info\" href=\"https://docs.openvino.ai/latest/openvino_docs_install_guides_install_runtime.html\" title=\"OpenVINO Runtime\">OpenVINO Runtime</a>，为了不影响之前博主系列博客中的环境配置（之前的也都是在虚拟环境中进行），这里创建了一个名为testOpenVINO的虚拟环境，关于Anaconda下创建虚拟环境的详情可见<a class=\"link-info\" href=\"https://blog.csdn.net/jiugeshao/article/details/116084611?spm=1001.2014.3001.5502\" title=\"之前博客\">之前博客</a></p>\n<pre><code>conda create -n testOpenVINO python=3.6\n</code></pre>\n<p>接下来update下pip</p>\n<p class=\"img-center\"><img alt=\"\" height=\"21\" src=\"..\\..\\static\\image\\c35ccdec111d44658953461c891523cf.png\" width=\"626\"/></p>\n<p></p>\n<p> 2. 执行下如下命令，博主最近前几篇<a class=\"link-info\" href=\"https://blog.csdn.net/jiugeshao/article/details/124145815?spm=1001.2014.3001.5502\" title=\"博客\">博客</a>中用的是tensorflow2.6.2，为了方便验证一些东西，这里框架就指定tensorflow2和onnx。参考官网上命令语句选择适合自己的框架。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"177\" src=\"..\\..\\static\\image\\5ca80168d485459fa95e60ea140054bc.png\" width=\"345\"/></p>\n<pre><code>pip install openvino-dev[tensorflow2,onnx]</code></pre>\n<p>完毕后，输入mo -h以验证</p>\n<p class=\"img-center\"><img alt=\"\" height=\"269\" src=\"..\\..\\static\\image\\ea4b2cc2077a45dba011977360689d84.png\" width=\"621\"/></p>\n<p> 完毕后，会发现<a class=\"link-info\" href=\"https://pypi.org/project/openvino-dev/\" title=\"网页\">网页</a>里提到的开发工具也都全部安装了，OpenVINO™ Runtime也同时安装了。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"617\" src=\"..\\..\\static\\image\\f73a4d5f15f74f378615994e563237e7.png\" width=\"546\"/></p>\n<p></p>\n<p></p>\n<p><strong>二.用model Optimizer转换tensorflow2模型</strong></p>\n<p><a href=\"https://docs.openvino.ai/latest/openvino_docs_MO_DG_prepare_model_convert_model_Convert_Model_From_TensorFlow.html#\" title=\"Converting a TensorFlow* Model — OpenVINO™  documentation\">Converting a TensorFlow* Model — OpenVINO™ documentation</a></p>\n<p> tensorflow的版本是2.5.2，可以直接将一个预训练模型以save_model方式保存</p>\n<pre><code class=\"language-python\">import tensorflow as tf\nimport numpy as np\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.applications import resnet50\n\nfrom tensorflow.keras.applications.resnet50 import preprocess_input, decode_predictions\nfrom PIL import Image\nimport time\n\nphysical_devices = tf.config.list_physical_devices('GPU')\ntf.config.experimental.set_memory_growth(physical_devices[0], True)\n\n#加载预训练模型\nmodel = resnet50.ResNet50(weights='imagenet')\n\n#save_model方式保存模型\ntf.saved_model.save(model, \"resnet/1/\")\n</code></pre>\n<p>运行后，可看到生成的模型</p>\n<p class=\"img-center\"><img alt=\"\" height=\"122\" src=\"..\\..\\static\\image\\455696cfe0514ba7bbd548a5e52ddc7b.png\" width=\"436\"/></p>\n<p> 执行如下命令即可完成模型的转换</p>\n<pre><code> mo --saved_model_dir 1</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"72\" src=\"..\\..\\static\\image\\ca4f81d4a392406ea83a7ef936a36c5e.png\" width=\"568\"/></p>\n<p></p>\n<p> 可看到，生成了3个文件</p>\n<p class=\"img-center\"><img alt=\"\" height=\"122\" src=\"..\\..\\static\\image\\c396e5861f6243ef879553b7dd0e6280.png\" width=\"530\"/></p>\n<p>如下是转化过程日志</p>\n<pre><code>Model Optimizer arguments:\nCommon parameters:\n\t- Path to the Input Model: \tNone\n\t- Path for generated IR: \t/home/sxhlvye/trial4/resnet/.\n\t- IR output name: \tsaved_model\n\t- Log level: \tERROR\n\t- Batch: \tNot specified, inherited from the model\n\t- Input layers: \tNot specified, inherited from the model\n\t- Output layers: \tNot specified, inherited from the model\n\t- Input shapes: \tNot specified, inherited from the model\n\t- Source layout: \tNot specified\n\t- Target layout: \tNot specified\n\t- Layout: \tNot specified\n\t- Mean values: \tNot specified\n\t- Scale values: \tNot specified\n\t- Scale factor: \tNot specified\n\t- Precision of IR: \tFP32\n\t- Enable fusing: \tTrue\n\t- User transformations: \tNot specified\n\t- Reverse input channels: \tFalse\n\t- Enable IR generation for fixed input shape: \tFalse\n\t- Use the transformations config file: \tNone\nAdvanced parameters:\n\t- Force the usage of legacy Frontend of Model Optimizer for model conversion into IR: \tFalse\n\t- Force the usage of new Frontend of Model Optimizer for model conversion into IR: \tFalse\nTensorFlow specific parameters:\n\t- Input model in text protobuf format: \tFalse\n\t- Path to model dump for TensorBoard: \tNone\n\t- List of shared libraries with TensorFlow custom layers implementation: \tNone\n\t- Update the configuration file with input/output node names: \tNone\n\t- Use configuration file used to generate the model with Object Detection API: \tNone\n\t- Use the config file: \tNone\nOpenVINO runtime found in: \t/home/sxhlvye/intel/openvino_2022/python/python3.6/openvino\nOpenVINO runtime version: \t2022.1.0-7019-cdb9bec7210-releases/2022/1\nModel Optimizer version: \t2022.1.0-7019-cdb9bec7210-releases/2022/1\n[ WARNING ]  \nDetected not satisfied dependencies:\n\tnetworkx: installed: 2.5.1, required: ~= 2.6\n\nPlease install required versions of components or run pip installation\npip install openvino-dev[tensorflow]\n[ WARNING ]  The model contains input(s) with partially defined shapes: name=\"input_1\" shape=\"[-1, 224, 224, 3]\". Starting from the 2022.1 release the Model Optimizer can generate an IR with partially defined input shapes (\"-1\" dimension in the TensorFlow model or dimension with string value in the ONNX model). Some of the OpenVINO plugins require model input shapes to be static, so you should call \"reshape\" method in the Inference Engine and specify static input shapes. For optimal performance, it is still recommended to update input shapes with fixed ones using \"--input\" or \"--input_shape\" command-line parameters.\n[ SUCCESS ] Generated IR version 11 model.\n[ SUCCESS ] XML file: /home/sxhlvye/trial4/resnet/saved_model.xml\n[ SUCCESS ] BIN file: /home/sxhlvye/trial4/resnet/saved_model.bin\n[ SUCCESS ] Total execution time: 27.96 seconds. \n[ SUCCESS ] Memory consumed: 2240 MB. \nIt's been a while, check for a new version of Intel(R) Distribution of OpenVINO(TM) toolkit here https://software.intel.com/content/www/us/en/develop/tools/openvino-toolkit/download.html?cid=other&amp;source=prod&amp;campid=ww_2022_bu_IOTG_OpenVINO-2022-1&amp;content=upg_all&amp;medium=organic or on the GitHub*\n[ INFO ] The model was converted to IR v11, the latest model format that corresponds to the source DL framework input/output format. While IR v11 is backwards compatible with OpenVINO Inference Engine API v1.0, please use API v2.0 (as of 2022.1) to take advantage of the latest improvements in IR v11.\nFind more information about API v2.0 and IR v11 at https://docs.openvino.ai\n</code></pre>\n<p></p>\n<p></p>\n<p><strong>三.使用OpenVINO在python环境下来完成推断</strong></p>\n<p><a href=\"https://docs.openvino.ai/latest/openvino_docs_OV_UG_Integrate_OV_with_your_application.html\" title=\"Integrate OpenVINO™ with Your Application — OpenVINO™  documentation\">Integrate OpenVINO™ with Your Application — OpenVINO™ documentation</a></p>\n<p>加载上面转换后的模型，去预测小猫图片</p>\n<p class=\"img-center\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\85eca0f25a3445d0b51265978173e6ff.png\" width=\"150\"/></p>\n<p> 代码如下：</p>\n<pre><code class=\"language-python\">import openvino.runtime as ov\nimport numpy as np\nimport time\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.applications import resnet50\n\nfrom tensorflow.keras.applications.resnet50 import preprocess_input, decode_predictions\nfrom PIL import Image\n\n\ncore = ov.Core()\ncompiled_model = core.compile_model(\"./resnet/saved_model.xml\", \"AUTO\")\ninfer_request = compiled_model.create_infer_request()\n\nimg = image.load_img('2008_002682.jpg', target_size=(224, 224))\nimg = image.img_to_array(img)\nimg = preprocess_input(img)\nimg = np.expand_dims(img, axis=0)\n\n# Create tensor from external memory\ninput_tensor = ov.Tensor(array=img, shared_memory=False)\ninfer_request.set_input_tensor(input_tensor)\n\nt_model = time.perf_counter()\ninfer_request.start_async()\ninfer_request.wait()\nprint(f'do inference cost:{time.perf_counter() - t_model:.8f}s')\n\n# Get output tensor for model with one output\noutput = infer_request.get_output_tensor()\noutput_buffer = output.data\n\n# output_buffer[] - accessing output tensor data\nprint(output_buffer.shape)\nprint('Predicted:', decode_predictions(output_buffer, top=5)[0])\n\n\nprint(\"ok\")</code></pre>\n<p> 运行结果如下：</p>\n<pre><code>/home/sxhlvye/anaconda3/envs/testOpenVINO/bin/python3.6 /home/sxhlvye/trial4/test_inference.py\n2022-04-20 12:54:36.780974: I tensorflow/stream_executor/platform/default/dso_loader.cc:53] Successfully opened dynamic library libcudart.so.11.0\ndo inference cost:0.02717873s\n(1, 1000)\nPredicted: [('n02123597', 'Siamese_cat', 0.16550684), ('n02108915', 'French_bulldog', 0.14137998), ('n04409515', 'tennis_ball', 0.08570903), ('n02095314', 'wire-haired_fox_terrier', 0.052046664), ('n02123045', 'tabby', 0.050695512)]\nok\n\nProcess finished with exit code 0\n</code></pre>\n<p>对比未转换前，在tensorflow框架下的<a class=\"link-info\" href=\"https://blog.csdn.net/jiugeshao/article/details/124145815?spm=1001.2014.3001.5502\" title=\"预测时间\">预测时间</a>，速度从0.18s提升到了0.027s。预测结果和直接在tensorflow框架下的结果保持一致的。</p>\n<p></p>\n<p></p>\n<p></p>\n<p><strong>四.c++环境下使用OpenVINO</strong></p>\n<p>如果想在c++里使用OpenVINO库，还需要如下的一些配置， 此页面上可以下载OpenVINO的Toolkit</p>\n<p><a class=\"has-card\" href=\"https://www.intel.com/content/www/us/en/developer/tools/openvino-toolkit/download.html\" title=\"Download Intel® Distribution of OpenVINO™ Toolkit\"><span class=\"link-card-box\"><span class=\"link-title\">Download Intel® Distribution of OpenVINO™ Toolkit</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://www.intel.com/content/www/us/en/developer/tools/openvino-toolkit/download.html</span></span></a>选择好符合自己的选项</p>\n<p class=\"img-center\"><img alt=\"\" height=\"568\" src=\"..\\..\\static\\image\\a400b1abf9c14f2187f4240f09cb0fe6.png\" width=\"492\"/></p>\n<p></p>\n<p> 博主的文件放在了此位置（结合自己的路径）</p>\n<p class=\"img-center\"><img alt=\"\" height=\"137\" src=\"..\\..\\static\\image\\d881f4f55a8148308605b15de9b59ee3.png\" width=\"543\"/></p>\n<p> 然后按照官网step-by-setp的进行安装即可</p>\n<p><a href=\"https://docs.openvino.ai/latest/openvino_docs_install_guides_installing_openvino_linux.html#doxid-openvino-docs-install-guides-installing-openvino-linux\" title=\"Install and Configure Intel® Distribution of OpenVINO™ Toolkit for Linux — OpenVINO™  documentation\">Install and Configure Intel® Distribution of OpenVINO™ Toolkit for Linux — OpenVINO™ documentation</a></p>\n<p class=\"img-center\"><img alt=\"\" height=\"107\" src=\"..\\..\\static\\image\\f73feb81abd04cbdaa6cd7ab2dc74749.png\" width=\"569\"/></p>\n<p> 如下界面上可以看到安装的目录</p>\n<p class=\"img-center\"><img alt=\"\" height=\"241\" src=\"..\\..\\static\\image\\a34e986f380347a7a691664538f7d5fb.png\" width=\"532\"/></p>\n<p> 完毕后会出现提示</p>\n<p class=\"img-center\"><img alt=\"\" height=\"145\" src=\"..\\..\\static\\image\\e71261e0e2ec4b888c304e55b182b307.png\" width=\"328\"/></p>\n<p>可看到OpenVINO的安装目录</p>\n<p class=\"img-center\"><img alt=\"\" height=\"95\" src=\"..\\..\\static\\image\\afff1ee1269e44aa83bd1409c5419769.png\" width=\"615\"/></p>\n<p> cd到目录下，再执行如下命令，安装依赖库。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"93\" src=\"..\\..\\static\\image\\96ad10d04d87472ab7323f010f32f717.png\" width=\"602\"/></p>\n<p> 再执行如下命令，安装opencl的驱动</p>\n<p class=\"img-center\"><img alt=\"\" height=\"29\" src=\"..\\..\\static\\image\\60e2ca7316b44af1ae23a484aabcf12f.png\" width=\"642\"/></p>\n<p> 安装成功后会出现如下信息：</p>\n<p class=\"img-center\"><img alt=\"\" height=\"140\" src=\"..\\..\\static\\image\\72ad05f5786a45f7852ea65a4be52457.png\" width=\"624\"/></p>\n<p></p>\n<p>接下来需要更新下环境变量，编辑./bashrc文件</p>\n<pre><code>sudo gedit ~/.bashrc</code></pre>\n<p>添加语句（结合自己的路径）</p>\n<pre><code>source /home/sxhlvye/intel/openvino_2022/setupvars.sh</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"66\" src=\"..\\..\\static\\image\\ba035a7a8a4e4dd3aea783bdd3d3af1a.png\" width=\"533\"/></p>\n<p>完毕后别忘了执行 source ~/.bashrc</p>\n<p>这样每次新建一个terminal的时候，关于openvino的变量都会自动添加进环境变量里，电脑上若有多版本的openvino，通过修改./bashrc中的setupvars.sh路径，就能方便完成切换了。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"45\" src=\"..\\..\\static\\image\\0f73fef30aa64b54b3a24ff21e50982b.png\" width=\"599\"/></p>\n<p> opencv这边，博主暂时不安装了，电脑上还保留着之前两篇博客中的opencv环境</p>\n<p><a href=\"https://blog.csdn.net/jiugeshao/article/details/123454004?spm=1001.2014.3001.5501\" title=\"TensorRT加速模型推断时间方法介绍（c++ pytorch模型）_竹叶青lvye的博客-CSDN博客\">TensorRT加速模型推断时间方法介绍（c++ pytorch模型）_竹叶青lvye的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/jiugeshao/article/details/120578698?spm=1001.2014.3001.5502\" title=\"Ubuntu下Qt Creator配置opencv_竹叶青lvye的博客-CSDN博客_ubuntu下qt配置opencv\">Ubuntu下Qt Creator配置opencv_竹叶青lvye的博客-CSDN博客_ubuntu下qt配置opencv</a></p>\n<p></p>\n<p></p>\n<p>有了以上环境后，博主在c++环境下加载上面<strong>第二步生成</strong>的openVINO runtime中间模型Intermediate Representation (IR)，这里还是用的QTCreator做的编译器。QTCreator纯c++代码的配置，也可以见博主<a class=\"link-info\" href=\"https://blog.csdn.net/jiugeshao/article/details/123454004?spm=1001.2014.3001.5502\" title=\"之前的博客\">之前的博客</a></p>\n<p>工程目录结构如下：</p>\n<p class=\"img-center\"><img alt=\"\" height=\"331\" src=\"..\\..\\static\\image\\1f82de11528345d78b49eff7ce1c0797.png\" width=\"542\"/></p>\n<p> main.cpp中的代码如下（不是官网的代码，自己手写），仅供参考：</p>\n<pre><code class=\"language-cpp\">#include &lt;openvino/openvino.hpp&gt;\n#include &lt;opencv2/core/core.hpp&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\n#include &lt;cstdlib&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include&lt;ctime&gt;\n\nusing namespace std;\nusing namespace cv;\n\n\nint main()\n{\n    ov::Core core;\n    ov::CompiledModel compiled_model = core.compile_model(\"/home/sxhlvye/trial4/resnet/saved_model.xml\", \"AUTO\");\n    ov::InferRequest infer_request = compiled_model.create_infer_request();    \n    auto input_port = compiled_model.input();\n    cout &lt;&lt; input_port.get_element_type() &lt;&lt; std::endl;\n\n    std::vector&lt;size_t&gt; size;\n    size.push_back(1);\n    size.push_back(224);\n    size.push_back(224);\n    size.push_back(3);\n    ov::Shape shape(size);\n\n     cv::Mat image = cv::imread(\"/home/sxhlvye/Trial1/Tensorrt/2008_002682.jpg\", cv::IMREAD_COLOR);\n     //cv::cvtColor(image, image, cv::COLOR_BGR2RGB);\n     cout &lt;&lt; image.channels() &lt;&lt; \",\" &lt;&lt; image.size().width &lt;&lt; \",\" &lt;&lt; image.size().height &lt;&lt; std::endl;\n\n     cv::Mat dst = cv::Mat::zeros(224, 224, CV_32FC3);\n     cv::resize(image, dst, dst.size());\n     cout &lt;&lt; dst.channels() &lt;&lt; \",\" &lt;&lt; dst.size().width &lt;&lt; \",\" &lt;&lt; dst.size().height &lt;&lt; std::endl;\n\n     const int channel = 3;\n     const int inputH = 244;\n     const int inputW = 244;\n     // Read a random digit file\n\n     std::vector&lt;float&gt; fileData(inputH * inputW * channel);\n\n     /*for (int c = 0; c &lt; channel; ++c)\n     {\n         for (int i = 0; i &lt; dst.rows; ++i)\n          {\n              cv::Vec3b *p1 = dst.ptr&lt;cv::Vec3b&gt;(i);\n              for (int j = 0; j &lt; dst.cols; ++j)\n              {\n                 fileData[c * dst.cols * dst.rows + i * dst.cols + j] = p1[j][c] / 255.0f;\n               }\n           }\n     }*/\n\n     for (int i = 0; i &lt; dst.rows; ++i)\n     {\n         cv::Vec3b *p1 = dst.ptr&lt;cv::Vec3b&gt;(i);\n         for (int j = 0; j &lt; dst.cols; ++j)\n         {\n            for(int c = 0; c &lt; 3; ++c)\n            {\n                fileData[i*dst.cols*3 + j*3 + c] = p1[j][c] / 255.0f;\n            }\n         }\n     }\n\n\n     ov::Tensor input_tensor(input_port.get_element_type(), shape, fileData.data());\n\n\n    infer_request.set_input_tensor(input_tensor);\n\n    clock_t startTime = clock();\n    infer_request.start_async();\n    infer_request.wait();\n    clock_t endTime = clock();\n    cout &lt;&lt; \"cost: \"&lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; \"s\" &lt;&lt; endl;\n\n    // Get output tensor by tensor name\n    auto output_tensor = infer_request.get_output_tensor();\n    int outputSize = output_tensor.get_size();\n    cout &lt;&lt; outputSize &lt;&lt; std::endl;\n\n    const float *output_temp = output_tensor.data&lt;const float&gt;();\n    float output[1000];\n    for(int i=0;i&lt;1000;i++)\n    {\n        output[i] = output_temp[i];\n    }\n\n    // Calculate Softmax\n  /*  float sum{0.0f};\n    for (int i = 0; i &lt; outputSize; i++)\n    {\n        output[i] = exp(output[i]);\n        sum += output[i];\n    }\n\n    for (int i = 0; i &lt; outputSize; i++)\n    {\n        output[i] /= sum;\n    }*/\n\n    vector&lt;float&gt; voutput(1000);\n    for (int i = 0; i &lt; outputSize; i++)\n    {\n        voutput[i] = output[i];\n    }\n\n    for(int i=0; i&lt;1000; i++)\n    {\n        for(int j= i+1; j&lt; 1000; j++)\n        {\n            if(output[i] &lt; output[j])\n            {\n                int temp;\n                temp = output[i];\n                output[i] = output[j];\n                output[j] = temp;\n            }\n        }\n    }\n\n    for(int i=0; i&lt;5;i++)\n    {\n        cout &lt;&lt; output[i] &lt;&lt; std::endl;\n    }\n\n    vector&lt;string&gt; labels;\n    string line;\n\n    ifstream readFile(\"/home/sxhlvye/Trial/yolov3-9.5.0/imagenet_classes.txt\");\n    while (getline(readFile,line))\n    {\n        //istringstream record(line);\n        //string label;\n       // record &gt;&gt; label;\n        //cout &lt;&lt; line &lt;&lt; std::endl;\n        labels.push_back(line);\n    }\n\n    vector&lt;int&gt; indexs(5);\n\n    for(int i=0; i&lt; 1000;i++)\n    {\n        if(voutput[i] == output[0])\n        {\n            indexs[0] = i;\n        }\n\n        if(voutput[i] == output[1])\n        {\n            indexs[1] = i;\n        }\n\n        if(voutput[i] == output[2])\n        {\n            indexs[2] = i;\n        }\n\n        if(voutput[i] == output[3])\n        {\n            indexs[3] = i;\n        }\n        if(voutput[i] == output[4])\n        {\n            indexs[4] = i;\n        }\n\n    }\n\n\n\n    cout &lt;&lt; \"top 5: \" &lt;&lt; std::endl;\n\n    cout &lt;&lt; labels[indexs[0]] &lt;&lt; \"---&gt;\" &lt;&lt; output[0] &lt;&lt; std::endl;\n\n    cout &lt;&lt; labels[indexs[1]] &lt;&lt; \"---&gt;\" &lt;&lt; output[1] &lt;&lt; std::endl;\n\n    cout &lt;&lt; labels[indexs[2]] &lt;&lt; \"---&gt;\" &lt;&lt; output[2] &lt;&lt; std::endl;\n\n    cout &lt;&lt; labels[indexs[3]] &lt;&lt; \"---&gt;\" &lt;&lt; output[3] &lt;&lt; std::endl;\n\n    cout &lt;&lt; labels[indexs[4]] &lt;&lt; \"---&gt;\" &lt;&lt; output[4] &lt;&lt; std::endl;\n\n\n    cout &lt;&lt; \"ok\" &lt;&lt; std::endl;\n\n   return 0;\n}\n</code></pre>\n<p>test8.pro工程配置文件的内容如下：</p>\n<pre><code>TEMPLATE = app\nCONFIG += console c++11\nCONFIG -= app_bundle\nCONFIG -= qt\n\nSOURCES += \\\n        main.cpp\n\n\nINCLUDEPATH += /usr/local/include \\\n               /usr/local/include/opencv \\\n               /usr/local/include/opencv2 \\\n               /home/sxhlvye/intel/openvino_2022/runtime/include \\\n               /home/sxhlvye/intel/openvino_2022/runtime/include/ie \\\n\nLIBS += /usr/local/lib/libopencv_highgui.so \\\n        /usr/local/lib/libopencv_core.so \\\n        /usr/local/lib/libopencv_imgproc.so \\\n        /usr/local/lib/libopencv_imgcodecs.so \\\n        /home/sxhlvye/intel/openvino_2022/runtime/lib/intel64/libopenvino.so \\\n        /home/sxhlvye/intel/openvino_2022/runtime/3rdparty/tbb/lib/libtbb.so.2 \\\n</code></pre>\n<p> 运行完毕后，在终端下运行生成的可执行文件，预测信息如下</p>\n<p class=\"img-center\"><img alt=\"\" height=\"327\" src=\"..\\..\\static\\image\\f809c11ac2d64b94867940a54edc9318.png\" width=\"627\"/></p>\n<p> <span style=\"color:#0d0016;\">这边一看，和上面<strong>第三步</strong>中python环境下的预测结果大相径庭，主要是图像预处理这块不一致。</span></p>\n<p></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\"> <strong>五. 做个小实验，改变python下图像预处理，使得其和c++保持一致，看结果是否一致</strong></span></p>\n<p>博主这边将第三步中python环境的图像预处理和c++下保持一致，也使用opencv库来做处理，修改后的代码如下：</p>\n<pre><code class=\"language-python\">import cv2\nimport openvino.runtime as ov\nimport numpy as np\nimport time\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.applications import resnet50\n\nfrom tensorflow.keras.applications.resnet50 import preprocess_input, decode_predictions\nfrom PIL import Image\n\n\ncore = ov.Core()\ncompiled_model = core.compile_model(\"./resnet/saved_model.xml\", \"AUTO\")\ninfer_request = compiled_model.create_infer_request()\n\n# img = image.load_img('2008_002682.jpg', target_size=(224, 224))\n# img = image.img_to_array(img)\n# img = preprocess_input(img)\nimg = cv2.imread('2008_002682.jpg')\nimg = cv2.resize(img,(224,224))\nimg_np = np.array(img, dtype=np.float32) / 255.\n\nimg_np = np.expand_dims(img_np, axis=0)\nprint(img_np.shape)\n\n# Create tensor from external memory\ninput_tensor = ov.Tensor(array=img_np, shared_memory=False)\ninfer_request.set_input_tensor(input_tensor)\n\nt_model = time.perf_counter()\ninfer_request.start_async()\ninfer_request.wait()\nprint(f'do inference cost:{time.perf_counter() - t_model:.8f}s')\n\n# Get output tensor for model with one output\noutput = infer_request.get_output_tensor()\noutput_buffer = output.data\n\n# output_buffer[] - accessing output tensor data\nprint(output_buffer.shape)\nprint('Predicted:', decode_predictions(output_buffer, top=5)[0])\n\n\nprint(\"ok\")</code></pre>\n<p> 预测结果如下：</p>\n<pre><code>/home/sxhlvye/anaconda3/envs/testOpenVINO/bin/python3.6 /home/sxhlvye/trial4/test_inference.py\n2022-04-21 07:59:02.427084: I tensorflow/stream_executor/platform/default/dso_loader.cc:53] Successfully opened dynamic library libcudart.so.11.0\n[E:] [BSL] found 0 ioexpander device\n[E:] [BSL] found 0 ioexpander device\n(1, 224, 224, 3)\ndo inference cost:0.02702089s\n(1, 1000)\nPredicted: [('n01930112', 'nematode', 0.13559894), ('n03041632', 'cleaver', 0.041396398), ('n03838899', 'oboe', 0.034457874), ('n02783161', 'ballpoint', 0.02541826), ('n04270147', 'spatula', 0.023189805)]\nok\n\nProcess finished with exit code 0\n</code></pre>\n<p>可以看到，预处理保持一致后，c++和python两边的结果就保持一致了。</p>\n<p></p>\n<p></p>\n<p><strong>官网上还有很多详细的资料，有时间会再细读，这边只是先跑下流程！</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>如何跑官网示例可以参考博主的博客</strong></span></p>\n<p><a href=\"https://blog.csdn.net/jiugeshao/article/details/124644257?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22124644257%22%2C%22source%22%3A%22jiugeshao%22%7D&amp;ctrtid=N41QH\" title=\"OpenVINO Sample及open_model_zoo例子使用介绍_竹叶青lvye的博客-CSDN博客\">OpenVINO Sample及open_model_zoo例子使用介绍_竹叶青lvye的博客-CSDN博客</a></p>\n<p></p>\n<p>官网上能看出，OpenVINO也是支持训练的，也有sample示例代码，但不够强大，后面主要还是用tensorflow、pytorch框架去训练模型，转换给OpenVINO来用</p>\n<p><a href=\"https://docs.openvino.ai/latest/workbench_docs_Workbench_DG_Measure_Accuracy_Object_detection.html\" title=\"Object Detection Model Tutorial — OpenVINO™  documentation\">Object Detection Model Tutorial — OpenVINO™ documentation</a></p>\n<p class=\"img-center\"><img alt=\"\" height=\"202\" src=\"..\\..\\static\\image\\725a4fd335a14c2a8eb7d57877e9e8aa.png\" width=\"481\"/></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\">备注：</span></p>\n<p>博主在PC Ubuntu上验证了只安装openVINO  Runtime (python环境下）</p>\n<p><a href=\"https://docs.openvino.ai/latest/openvino_docs_install_guides_installing_openvino_pip.html#\" title=\"Install Intel® Distribution of OpenVINO™ Toolkit from PyPI Repository — OpenVINO™  documentation\">Install Intel® Distribution of OpenVINO™ Toolkit from PyPI Repository — OpenVINO™ documentation</a></p>\n<p class=\"img-center\"><img alt=\"\" height=\"196\" src=\"..\\..\\static\\image\\2d4fdc11531b474381288f360e1785dc.png\" width=\"500\"/></p>\n<p> 按照From PyPI方式来安装，完毕后，跑下上面推断代码，能正常执行</p>\n<p class=\"img-center\"><img alt=\"\" height=\"296\" src=\"..\\..\\static\\image\\792362b0e1a642df89d89ead5ff3e21f.png\" width=\"434\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 1, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-15 18:16:29", "summary": "接着前面系列博客继续实验，这篇来介绍的，主要还是参考官网资料，前面也说过好的东西，官网对其的介绍是很详尽的，我觉得此要比的的官网做的更好，示例也很多。官网参考链接如下：博主此时的电脑软件环境为：对于不"}