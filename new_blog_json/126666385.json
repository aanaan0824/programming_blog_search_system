{"blogid": "126666385", "writerAge": "码龄2年", "writerBlogNum": "57", "writerCollect": "1165", "writerComment": "2166", "writerFan": "3571", "writerGrade": "6级", "writerIntegral": "8393", "writerName": "哎呀是小张啊", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126666385.jpg", "writerRankTotal": "1745", "writerRankWeekly": "177", "writerThumb": "2511", "writerVisitNum": "89998", "blog_read_count": "167", "blog_time": "于 2022-09-03 02:00:00 发布", "blog_title": "【javaEE初阶】多线程 _ 进阶篇 _ 死锁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>☕导航小助手☕</strong></p>\n<p id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-toc\" style=\"margin-left:0px;\"><strong>      🍚</strong><a href=\"#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%20%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF-toc\" style=\"margin-left:0px;\"><strong>            🍜</strong><a href=\"#%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%20%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF\">一、\"死锁\"出现的典型场景</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E4%BA%A7%E7%94%9F%20%22%E6%AD%BB%E9%94%81%22%20%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6-toc\" style=\"margin-left:0px;\"><strong>            🍔</strong><a href=\"#%E4%BA%8C%E3%80%81%E4%BA%A7%E7%94%9F%20%22%E6%AD%BB%E9%94%81%22%20%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\">二、产生 \"死锁\" 的必要条件</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%20%22%E6%AD%BB%E9%94%81%22%20%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%9E%E6%B3%95-toc\" style=\"margin-left:0px;\"><strong>            🥡</strong><a href=\"#%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%20%22%E6%AD%BB%E9%94%81%22%20%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%9E%E6%B3%95\">三、解决 \"死锁\" 问题的办法</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</h1>\n<p>死锁，是多线程中的一个比较典型的问题，是多线程代码中的常见 bug ~</p>\n<p>通俗的说，就是 在尝试加锁的时候，发现上次锁<strong>没有及时的释放</strong>（由于某些原因，或是是一些代码的 bug ），导致加锁没有加上 ~</p>\n<p>于是，就会出现了 \"死锁\" 问题 ~</p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%20%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF\">一、\"死锁\"出现的典型场景</h1>\n<p><span style=\"color:#956fe7;\"><strong>（一）一个线程一把锁（可重入锁），若是不可重复锁，凉！</strong></span></p>\n<p>一个线程一把锁，这个就是之前所介绍的 可重入锁 ~</p>\n<p>线程A 针对锁1 连续加锁两次，就构成了死锁 !</p>\n<blockquote>\n<p>第一次加锁 加锁成功，第二次加锁 就需要第一次的锁释放，于是就阻塞等待；</p>\n<p>但是，第一次加锁释放，就得依赖第二次加锁成功；</p>\n<p>于是，\"死锁\" 就出现了！！！</p>\n</blockquote>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（二）两个线程两把锁，相互获取对方锁，凉！</strong></span></p>\n<p>此时，不管是不是可重入锁，都会造成 \"死锁\" 问题 ！</p>\n<blockquote>\n<p>可以用一个例子来说明情况：</p>\n<p>假设 甲同学 和 乙同学 居住在一起了 ~</p>\n<p>甲同学 吃饺子喜欢蘸酱油，乙同学 吃饺子喜欢蘸醋，由于在一起了，生活习性都受到了彼此的影响，两位同学吃饺子的时候 喜欢都蘸上一点了 ~</p>\n<p>有一天，吃饺子的时候，甲同学拿起了酱油，乙同学拿起了醋 ~</p>\n<p>甲同学说：\"你把醋给我，我用完了都给你\"；乙同学说：\"你把酱油给我，我用完了就把醋给你\" ~</p>\n<p>此时，两者相持不下，这就造成了 \"死锁\" 问题 ~</p>\n<hr/>\n<p>此时，甲同学 和 乙同学 就可以看成是两个线程，酱油和醋 就可以看成是两把锁 ~</p>\n<p>线程1 获取到锁A，线程2 获取到锁B；</p>\n<p>线程1 尝试获取锁B（需要线程2 释放锁B） ，线程2 尝试获取到锁A（需要线程1 释放锁A）；</p>\n<p>在这种情况下，逻辑上就构成了循环，就构成了 \"死锁\" ~ </p>\n</blockquote>\n<p></p>\n<p><strong><span style=\"color:#956fe7;\">（三）多个线程多个锁，\"哲学家就餐问题\"，凉！</span></strong></p>\n<p>此时，这种情况和 第二种情况 类似，只是更复杂一点而已 ~</p>\n<p><strong>在多个线程多把锁的情况下，\"死锁\"问题 就是一个概率性的问题，但是也绝对不能忽视 ！！！</strong></p>\n<p>在谈到 \"多个线程多把锁\" 的时候，就会引出一个很经典的问题 —— \"<strong>哲学家就餐问题</strong>\" ！</p>\n<blockquote>\n<p><strong>故事背景：</strong></p>\n<p>有 5 个哲学家，相当于有 5 个线程，他们只会做两件事情：</p>\n<ol><li>思考人生（相当于是 线程休眠）</li><li>吃面条（相当于是 在CPU上运行）</li></ol>\n<p>由于多线程的调度是无序的，所以说 这几个哲学家 什么时候去思考人生，什么时候去吃面条，我们是不确定的 ~</p>\n<p>同时，正常情况下，应该会有 5 双筷子~</p>\n<p>但是，此时 在餐桌上 一共只有 5 根筷子，并且 这5 根筷子 分别在 两两哲学家 之间 ~</p>\n<p>并且，他们之间都不相互嫌弃，吃面条的时候要拿起 左右手两双筷子（这就导致相邻的哲学家需要等待） ~</p>\n<p>此处的筷子就视为 两把\"锁\"，只有这两把锁都获取到了，才可以吃面条 ~ </p>\n<p><img alt=\"\" height=\"662\" src=\"..\\..\\static\\image\\6813e47deddd4d879c1bd04c46bee1e5.png\" width=\"869\"/></p>\n</blockquote>\n<blockquote>\n<p><strong>出现 \"死锁\" 问题的情况：</strong></p>\n<p>假设 在同一时刻，所有的哲学家都想吃面条 ~</p>\n<p>他们同时伸出左手，拿起左边的筷子；然后又同时伸出右手，尝试去拿右边的筷子；此时，右手的筷子都拿不起来，因此都无法吃面 ~</p>\n<p>由于哲学家都非常固执，导致即使吃不到面条 也不会放下左手的筷子，这样的情况就会一直持续下去 ~</p>\n<p>于是，这就构成了死锁 ~</p>\n</blockquote>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E4%BA%A7%E7%94%9F%20%22%E6%AD%BB%E9%94%81%22%20%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\">二、产生 \"死锁\" 的必要条件</h1>\n<p><strong>鉴于 \"死锁\"问题，程序员大佬们 总结了 4 个 \"死锁\"产生的必要条件：</strong></p>\n<ol><li>互斥使用（线程1 拿到锁A，其他线程就无法获取到 A）</li><li>不可抢占（线程1 拿到锁A，其他线程只能阻塞等待，等到线程1 主动释放锁，而不是强行把锁抢走）</li><li>请求和保持（当线程1 拿到锁A 之后，就会一直持有这个获取到锁的状态，直到说主动释放锁） </li><li>循环等待（线程1 等待线程2，线程2 又尝试等待线程1）</li></ol>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%20%22%E6%AD%BB%E9%94%81%22%20%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%9E%E6%B3%95\">三、解决 \"死锁\" 问题的办法</h1>\n<p>根据 产生 \"死锁\" 的必要条件，我们可以知道，<strong>前三个必要条件 都是在描述锁的基本特点</strong>，在实际情况下 我们并不好直接去破坏 ~</p>\n<p>但是，<strong>第四个必要条件 却是和代码编写密切相关 </strong>~</p>\n<p>如果我们能够在编码上做出一些注意和约定，就可以打破 \"循环等待\"，避免死锁 ！！！</p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>打破 \"循环等待\" 的办法：</strong></span><br/><strong>针对多把锁，进行编号：1、2、3、4、......</strong></p>\n<p><strong>并且约定在获取多把锁的时候，要明确获取锁的顺序是 从小到大（或者 从大到小） 的顺序 ~</strong></p>\n<p><span style=\"color:#0d0016;\">如（此处以从小到大为例）：</span></p>\n<p><span style=\"color:#0d0016;\">线程要拿到 1、2 这两把锁，就先获取 1，再获取 2；</span></p>\n<p><span style=\"color:#0d0016;\">线程要拿到 2、4 这两把锁，就先获取 2，再获取 4 ~</span></p>\n<p><span style=\"color:#0d0016;\">只要所有的线程都遵循这个顺序，就不会出现 \"循环等待\"，就不会出现死锁 ！！！</span> </p>\n</blockquote>\n<p>我们可以把这个解决办法 带入到上面的 \"<strong>哲学家就餐问题</strong>\" 看看 ~</p>\n<p>约定：获取所得顺序是：从小到大 ~</p>\n<p><img alt=\"\" height=\"936\" src=\"..\\..\\static\\image\\e3eb8983f9f74a819199f576125c39a0.png\" width=\"1062\"/></p>\n<p><img alt=\"\" height=\"719\" src=\"..\\..\\static\\image\\6e9a7e944bd64e83bc5f8e405bc37a98.png\" width=\"1200\"/></p>\n<p>之后，最左边的哲学家 就可以得到两把锁了，于是就可以吃到面条了 ~</p>\n<p>等到 吃完面条之后，会释放 4、5两把筷子；然后 最上面的哲学家 也可以吃到面条了，......，就这样的话，顺时针旋转，依次 5 位哲学家都可以吃上面条了 ~</p>\n<p>谁最先吃到面条，谁最后吃到面条，一眼就可以看明白了 ~</p>\n<p>于是，\"循环等待\"就被打破了，死锁问题就被解决了 ~</p>\n<blockquote>\n<p>这种解决 \"死锁\"问题 的方法非常可靠，也非常的重要！！！</p>\n</blockquote>\n<p></p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p>好了，关于 \"死锁\" 的知识点就介绍到这里了 ~</p>\n<p>关于 多线程进阶篇的知识点 到这里也就完结撒花了 ~</p>\n<p>如果感觉这一篇博客对你有帮助的话，可以一键三连走一波，非常非常感谢啦 ~</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\94f470bcf6434d818234a645e7d36616.png\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-03 02:00:00", "summary": "导航小助手写在前面一、死锁出现的典型场景二、产生死锁的必要条件三、解决死锁问题的办法写在前面死锁，是多线程中的一个比较典型的问题，是多线程代码中的常见通俗的说，就是在尝试加锁的时候，发现上次锁没有及时"}