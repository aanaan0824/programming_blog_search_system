{"blogid": "124837409", "writerAge": "码龄4年", "writerBlogNum": "4", "writerCollect": "12", "writerComment": "2", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "80", "writerName": "涅凰", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124837409.jpg", "writerRankTotal": "139483", "writerRankWeekly": "440638", "writerThumb": "3", "writerVisitNum": "6657", "blog_read_count": "2308", "blog_time": "于 2022-05-18 10:50:24 发布", "blog_title": "SQL——游标", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>非原创---东拼西凑来的</p>\n<p>游标(cursor)是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。不像多数DBMS，MySQL游标只能用于存储过程(和函数)。</p>\n<p><span style=\"color:#fe2c24;\"><strong>简单的说，游标（CURSOR）的特殊性在于它可以用循环对返回值进行逐条编译，它具有只读性、不可跳跃性和迟钝性。</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>游标会吃更多的内存，减少可用的并发。</strong></span></p>\n</blockquote>\n<p>游标5个组成部分</p>\n<p>1、声明 2、打开 3、从游标中查找信息 4、关闭 5、释放</p>\n<p>在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句：</p>\n<pre><code>DECLARE 游标名 CURSOR\nFOR\nSELECT 语句 #此处必须是SELECT语句</code></pre>\n<p>一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来：</p>\n<pre><code>OPEN 游标名;</code></pre>\n<p>对于填有数据的游标，根据需要取出(检索)各行：</p>\n<pre><code>FETCH... FROM 游标名</code></pre>\n<p>FETCH指定检索什么数据，即所需的列，并指定检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行，以不重复读取同一行。</p>\n<p>在结束游标使用时，必须关闭游标：</p>\n<pre><code>CLOSE 游标名;</code></pre>\n<p>在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作。</p>\n<p></p>\n<h2>游标创建</h2>\n<p>游标用DECLARE语句创建。DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。</p>\n<pre><code>CREATE PROCEDURE 储存过程名()\nBEGIN\nDECLARE 游标名 CURSOR\nFOR\nSELECT...\nFROM...\nWHERE...\nEND</code></pre>\n<p>存储过程处理完成后，游标就“消失”了（因为它局限于存储过程之中）。</p>\n<p><strong>创建打开关闭游标举例</strong></p>\n<p>如前文所述，在定义游标之后，可以打开它：</p>\n<pre><code>declare cursor1（游标名） cursor for select XXX--声明游标 1\nopen XXXX--打开 2\nfetch next from XXX into XXX--将游标值赋给XXX   3\nwhile(@@fetch_status=0)--循环查找\nfetch next from XXX into XXX--同上\nclose cursor1--关闭游标   4\ndeallocate cursor1--解散游标   5\n​\nfetch_status\n0 FETCH 语句成功\n-1 FETCH 语句失败或此行不在结果集中\n-2 被提取的行不存在</code></pre>\n<p>CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。</p>\n<p>在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。</p>\n<p><strong>使用游标举例</strong></p>\n<p>在我们打开了游标后，如前文所述，可以用FETCH语句分别访问它的每一行：</p>\n<pre><code>alter PROCEDURE cursor_a_b_insert\n@aId int,\n@aName nchar(10)\nAS\n\ndeclare @id int\ndeclare @name varchar(50)\n\ndeclare cursor1 cursor for         --定义游标cursor1\nselect bid,bname from b where aid=@aId             --使用游标的对象(跟据需要填入select文)\nopen cursor1                       --打开游标\nfetch next from cursor1 into @id,@name  --将游标向下移1行，获取的数据放入之前定义的变量@id,@name中\nwhile @@fetch_status=0           --判断是否成功获取数据\nbegin\nupdate b set bname=@aName+'1' where bid=@id                           --进行相应处理(跟据需要填入SQL文)\nupdate a set aname=@aName where aid=@aId\nfetch next from cursor1 into @id,@name  --将游标向下移1行\nend\nclose cursor1                   --关闭游标\ndeallocate cursor1 \n\n\nexec cursor_a_b_insert 55,'王媛媛'\n\n\n\n\n\nalter proc cursor_pr_UpUser\n@NoteUserId int\nas\nbegin transaction\ndeclare @NLId int\ndeclare @NPLId int\n--创建用户所对应的日志游标cursorNLId，将日志id放入@NLId游标中\ndeclare cursorNLId cursor for select NoteLogId from NoteLogs where NUId=@NoteUserId\nopen cursorNLId\nfetch next from cursorNLId into @NLId\n\nwhile @@fetch_status=0 --判断是否成功获取数据\nbegin\n--创建日志所对应的评论游标cursorNPLId，将评论id放入@NPLId游标中\ndeclare cursorNPLId cursor for select NotePingLunId from NotePingLun where NLId=@NLId\nopen cursorNPLId\nfetch next from cursorNPLId into @NPLId\nwhile @@fetch_status=0\nbegin\n--根据评论游标@NPLId修改评论状态\nupdate dbo.NoteReply set NoteDel=0 where NoteReplyId=@NPLId\nfetch next from cursorNPLId into @NPLId\nend\n--当评论游标遍历完关闭\nclose cursorNPLId --关闭游标\ndeallocate cursorNPLId\n--根据日志游标@NPLId修改日志状态\nupdate dbo.NotePingLun set NoteDel=0 where NLId=@NLId\nfetch next from cursorNLId into @NLId\n\nend\n--关闭日志游标\nclose cursorNLId --关闭游标\ndeallocate cursorNLId\n--根据用户修改用户和日志状态\nupdate dbo.NoteUser set NoteDel=0 where NoteuserId=@NoteUserId\nupdate dbo.NoteLogs set NoteDel='qq' where NUId=@NoteUserId\nif @@error&lt;&gt;0 --如果有错误\nbegin\nprint '删除失败，回滚事务'\nrollback transaction --回滚\nend\nelse\nbegin\nprint '删除成功，提交事务'\ncommit transaction\nend\ngo\n\nexec cursor_pr_UpUser 1</code></pre>\n<p>其中FETCH语句自动从第一行开始检索当前行的order_num列，并存储到一个名为“乖巧的局部变量”的局部声明的变量中。</p>\n<p> </p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-05-18 10:50:24", "summary": "非原创东拼西凑来的游标是一个存储在服务器上的数据库查询，它不是一条语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚"}