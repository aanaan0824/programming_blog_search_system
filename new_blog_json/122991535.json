{"blogid": "122991535", "writerAge": "码龄2年", "writerBlogNum": "76", "writerCollect": "134", "writerComment": "34", "writerFan": "43", "writerGrade": "4级", "writerIntegral": "892", "writerName": "你吃香蕉吗？", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122991535.jpg", "writerRankTotal": "21302", "writerRankWeekly": "26458", "writerThumb": "86", "writerVisitNum": "169112", "blog_read_count": "5358", "blog_time": "已于 2022-02-20 21:50:32 修改", "blog_title": "Vue3和Vue2的区别", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E6%A6%82%E8%A7%88-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%A6%82%E8%A7%88\">概览</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7\">一、新特性</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%B7%AE%E5%BC%82-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%B7%AE%E5%BC%82\">二、差异</a></p>\n<p id=\"%E8%AF%A6%E6%83%85-toc\" style=\"margin-left:0px;\"><a href=\"#%E8%AF%A6%E6%83%85\">详情</a></p>\n<p id=\"%E4%B8%80%E3%80%81vue3%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%80%E3%80%81vue3%E6%96%B0%E7%89%B9%E6%80%A7\">一、vue3新特性</a></p>\n<p id=\"1%E3%80%81%E7%BB%84%E5%90%88%E5%BC%8FAPI---setup-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E7%BB%84%E5%90%88%E5%BC%8FAPI---setup\">1、组合式API---setup</a></p>\n<p id=\"2%E3%80%81ref%E5%88%9B%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81ref%E5%88%9B%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE\">2、ref创建响应式数据</a></p>\n<p id=\"3%E3%80%81Teleport---%E2%80%9C%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81Teleport---%E2%80%9C%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D\">3、Teleport---“传送门”</a></p>\n<p id=\"4%E3%80%81%E5%A4%9A%E6%A0%B9%E8%8A%82%E7%82%B9-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81%E5%A4%9A%E6%A0%B9%E8%8A%82%E7%82%B9\">4、多根节点</a></p>\n<p id=\"5%E3%80%81style%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#5%E3%80%81style%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F\">5、style中使用变量</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%8C%BA%E5%88%AB\">二、区别</a></p>\n<p id=\"1%E3%80%81v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\">1、v-if和v-for的优先级</a></p>\n<p id=\"2%E3%80%81.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6\">2、.sync修饰符</a></p>\n<p id=\"3%E3%80%81%E5%85%A8%E5%B1%80API-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81%E5%85%A8%E5%B1%80API\">3、全局API</a></p>\n<p id=\"4%E3%80%81Vue.prototype%20%E6%9B%BF%E6%8D%A2%E4%B8%BA%20config.globalProperties-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81Vue.prototype%20%E6%9B%BF%E6%8D%A2%E4%B8%BA%20config.globalProperties\">4、Vue.prototype 替换为 config.globalProperties</a></p>\n<p id=\"5%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc\" style=\"margin-left:80px;\"><a href=\"#5%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">5、生命周期</a></p>\n<p id=\"6%E3%80%81key%E5%9C%A8template%E5%92%8Cv-if%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#6%E3%80%81key%E5%9C%A8template%E5%92%8Cv-if%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8\">6、key在template和v-if上的使用</a></p>\n<p id=\"7%E3%80%81%24listeners%E8%A2%AB%E7%A7%BB%E9%99%A4-toc\" style=\"margin-left:80px;\"><a href=\"#7%E3%80%81%24listeners%E8%A2%AB%E7%A7%BB%E9%99%A4\">7、$listeners被移除</a></p>\n<p id=\"8%E3%80%81this-toc\" style=\"margin-left:80px;\"><a href=\"#8%E3%80%81this\">8、this</a></p>\n<p id=\"9%E3%80%81typescript%E6%94%AF%E6%8C%81-toc\" style=\"margin-left:80px;\"><a href=\"#9%E3%80%81typescript%E6%94%AF%E6%8C%81\">9、typescript支持</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>随着vue3在2022 年 2 月 7 日被提升为新的默认版本，这也将成为一个新的潮流，我们前端开发者也将在未来的工作中更多的使用vue3来搭建以及开发我们的项目。因此了解vue3和vue2的区别也就成为了一件至关重要的事情了。</p>\n<h1 id=\"%E6%A6%82%E8%A7%88\">概览</h1>\n<h3 id=\"%E4%B8%80%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7\">一、新特性</h3>\n<p>1、组合式API---setup</p>\n<p>2、ref创建响应式数据</p>\n<p>3、Teleport---“传送门”</p>\n<p>4、多根节点</p>\n<p>5、style中使用变量</p>\n<h3 id=\"%E4%BA%8C%E3%80%81%E5%B7%AE%E5%BC%82\">二、差异</h3>\n<p>1、v-if和v-for的优先级</p>\n<p>2、.sync修饰符</p>\n<p>3、全局API</p>\n<p>4、Vue.prototype 替换为 config.globalProperties</p>\n<p>5、生命周期</p>\n<p>6、key在template和v-if上的使用</p>\n<p>7、$listeners被移除</p>\n<p>8、this</p>\n<p>9、typescript支持</p>\n<p></p>\n<h1 id=\"%E8%AF%A6%E6%83%85\">详情</h1>\n<h2 id=\"%E4%B8%80%E3%80%81vue3%E6%96%B0%E7%89%B9%E6%80%A7\">一、vue3新特性</h2>\n<h3 id=\"1%E3%80%81%E7%BB%84%E5%90%88%E5%BC%8FAPI---setup\">1、组合式API---setup</h3>\n<ul><li>在vue2中：生命周期、methods、data等只能定义一次，并把相关的变量、方法等集中写在一处地方，这导致我们在代码编写及维护的过程中，不可避免的要反复横跳来查找对应的变量、方法等，这种碎片化的编码方式既不利于理解，也不利于维护</li><li>在vue3中：setup是一个接收 props 和 content 的函数，允许我们在其内部通过API的方式（如：onMounted(getUserRepositories) // 在 `mounted` 时调用 `getUserRepositories`）多次使用一个相同的生命周期等。</li></ul>\n<h3 id=\"2%E3%80%81ref%E5%88%9B%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE\">2、ref创建响应式数据</h3>\n<ul><li>在vue2中：响应式数据的创建必须是写在 data 中的，在vue内部通过Object.defineproperty() 方法 以及 重写Array的方法来达到数据响应式的目的，这种方式是“主动”的，无论此变量有没有改变都会在vue初始化时设置为响应式（效率差，支持性差：你经常会用到$set这个方法）</li><li>在vue3中：通过 ref 函数实现数据响应式（vue3中数据响应式的实现是通过proxy代理的方式，这种方式是“被动”的，只有当你去访问改变变量时，才会被处理为响应式数据，并且不需要对数组、对象等进行特殊处理，它是“一视同仁的”，还支持 Set 等较新的数据类型）</li></ul>\n<h3 id=\"3%E3%80%81Teleport---%E2%80%9C%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D\">3、Teleport---“传送门”</h3>\n<ul><li>允许我们将指定内容渲染在指定的html标签上</li></ul>\n<h3 id=\"4%E3%80%81%E5%A4%9A%E6%A0%B9%E8%8A%82%E7%82%B9\">4、多根节点</h3>\n<ul><li>在vue2中：一旦根节点有多个，vue会发出警告</li><li>在vue3中：支持多根节点（减少了DOM元素的嵌套层级）</li></ul>\n<h3 id=\"5%E3%80%81style%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F\">5、style中使用变量</h3>\n<ul><li> <pre><code class=\"language-html\">&lt;script setup&gt;\nconst theme = {\n  color: 'red'\n}\n&lt;/script&gt;\n&lt;template&gt;\n  &lt;p&gt;hello&lt;/p&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\np {\n  color: v-bind('theme.color');\n}\n&lt;/style&gt;</code></pre> </li></ul>\n<h2 id=\"%E4%BA%8C%E3%80%81%E5%8C%BA%E5%88%AB\">二、区别</h2>\n<h3 id=\"1%E3%80%81v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\">1、v-if和v-for的优先级</h3>\n<ul><li>在vue2中：当v-if和v-for同时使用时，v-for的优先级高于v-if（因此我们通常需要计算属性先对数据进行加工处理，以达到性能优化的目的）</li><li>在vue3中：当v-if和v-for同时使用时，v-if的优先级高于v-for</li></ul>\n<h3 id=\"2%E3%80%81.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6\">2、.sync修饰符</h3>\n<ul><li>vue2中：由于vue中是单向数据流，父子组件在传值时想要实现v-model的效果就要用到.sync修饰符来实现“双向绑定”</li><li>vue3中：对v-model进行了改造，不再需要 .sync 修饰符即可达到数据双向绑定的效果。在vue3中支持多个 v-model属性，默认使用 modelValue 作为 prop，update:modelValue作为事件，当多个v-model绑定时，书写为例：v-model:title=\"title\"，此时 title 作为prop，update:title 作为事件</li></ul>\n<h3 id=\"3%E3%80%81%E5%85%A8%E5%B1%80API\">3、全局API</h3>\n<ul><li>vue2中：有许多的全局API，如：Vue.directive、Vue.component、Vue.config、Vue.mixin等</li><li>vue3中：提供的是实例API，通过createApp创建vue实例，原来在Vue原型上的API都被挂载到了vue实例上，如：app.directive、app.component、app.config、app.mixin等</li></ul>\n<h3 id=\"4%E3%80%81Vue.prototype%20%E6%9B%BF%E6%8D%A2%E4%B8%BA%20config.globalProperties\">4、Vue.prototype 替换为 config.globalProperties</h3>\n<ul><li>vue2中：绑定全局的变量、方法等：Vue.prototype.$ajax = xxxx</li><li>vue3中：const app = createApp({}); app.config.globalProperties.$ajax = xxxx</li></ul>\n<h3 id=\"5%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">5、生命周期</h3>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>vue2</td><td>vue3</td></tr><tr><td> <p>beforeCreate</p> </td><td>setup()</td></tr><tr><td> <p>created</p> </td><td>setup()</td></tr><tr><td> <p>beforeMount</p> </td><td>onBeforeMount</td></tr><tr><td> <p>mounted</p> </td><td>onMounted</td></tr><tr><td> <p>beforeUpdate</p> </td><td>onBeforeUpdate</td></tr><tr><td> <p>updated      </p> </td><td>onUpdated</td></tr><tr><td> <p>beforeDestroy</p> </td><td>onBeforeUnmount</td></tr><tr><td>destroyed </td><td>onUnmounted</td></tr></tbody></table>\n<h3 id=\"6%E3%80%81key%E5%9C%A8template%E5%92%8Cv-if%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8\">6、key在template和v-if上的使用</h3>\n<ul><li>vue2中：在使用v-if、vi-else、v-else-if时，为了保证dom节点渲染的正确性，通常需要在对应的节点添加不同的key，以确保vue在进行虚拟dom对比时是准确的；vue2中template在v-for循环时是不能设置key的，否则会产生警告（需要给子节点设置key）。</li><li>vue3中：在使用v-if、vi-else、v-else-if时，不用提供唯一的key对dom节点进行区分，因为vue内部会自动生成唯一的key，如果你提供了key，那你就要保证它的唯一性；vue3中template在v-for循环时，key应该设置在template标签上</li></ul>\n<h3 id=\"7%E3%80%81%24listeners%E8%A2%AB%E7%A7%BB%E9%99%A4\">7、$listeners被移除</h3>\n<ul><li>vue2中：使用$attrs访问传递给组件的属性，使用$listeners访问传递给组件的事件（需要结合inheritAttrs:false）。</li><li>vue3中：虚拟dom中，事件监听器仅仅是以on为前缀的属性</li></ul>\n<h3 id=\"8%E3%80%81this\">8、this</h3>\n<ul><li>vue2中：无时无刻都要使用this</li><li>vue3中：因为setup函数的存在，所有的props、data等都不需要用this进行访问（vue3对vue2绝大多数是兼容的，如果你用了vue2相关的东西，那你还是需要像vue2一样书写）</li></ul>\n<h3 id=\"9%E3%80%81typescript%E6%94%AF%E6%8C%81\">9、typescript支持</h3>\n<ul><li>vue2中：默认是不支持typescript的。</li><li>vue3中：支持使用typescript，使用typescript在构建大型项目时，能够很好的提高项目开发的质量。</li></ul>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-02-20 21:50:32", "summary": "目录前言概览一、新特性二、差异详情一、新特性、组合式、创建响应式数据、传送门、多根节点、中使用变量二、区别、和的优先级、修饰符、全局、替换为、生命周期、在和上的使用、被移除、、支持前言随着在年月日被提"}