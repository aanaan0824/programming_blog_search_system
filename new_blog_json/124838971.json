{"blogid": "124838971", "writerAge": "码龄2年", "writerBlogNum": "48", "writerCollect": "2512", "writerComment": "4018", "writerFan": "8742", "writerGrade": "6级", "writerIntegral": "7335", "writerName": "小杰312", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124838971.jpg", "writerRankTotal": "3536", "writerRankWeekly": "8086", "writerThumb": "2664", "writerVisitNum": "112406", "blog_read_count": "1362", "blog_time": "已于 2022-05-26 21:19:07 修改", "blog_title": "MySQL索引的理解学习,面试不问索引原理就是事务原理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"MySQL%E6%89%A7%E8%A1%8CSQL%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B-toc\" style=\"margin-left:0px;\"><a href=\"#MySQL%E6%89%A7%E8%A1%8CSQL%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B\">MySQL执行SQL的整体流程</a></p>\n<p id=\"%E5%BC%95%E8%A8%80%2C%20MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0%E5%8E%9F%E5%9B%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E8%A8%80%2C%20MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0%E5%8E%9F%E5%9B%A0\">引言, MySQL索引底层学习原因</a></p>\n<p id=\"%E7%A3%81%E7%9B%98%E4%BB%8B%E7%BB%8D(%E7%90%86%E8%A7%A3%E7%A3%81%E7%9B%98IO)-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%A3%81%E7%9B%98%E4%BB%8B%E7%BB%8D%28%E7%90%86%E8%A7%A3%E7%A3%81%E7%9B%98IO%29\">磁盘介绍(理解磁盘IO)</a></p>\n<p id=\"%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84B%2B%E6%A0%91-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84B%2B%E6%A0%91\">索引底层数据结构B+树</a></p>\n<p id=\"B%2B%E6%A0%91(%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95)-toc\" style=\"margin-left:40px;\"><a href=\"#B%2B%E6%A0%91%28%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%29\">B+树(聚集索引)</a></p>\n<p id=\"B%2B%E6%A0%91(%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95)-toc\" style=\"margin-left:40px;\"><a href=\"#B%2B%E6%A0%91%28%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%29\">B+树(辅助索引)</a></p>\n<p id=\"%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8B%2B%E6%A0%91%E7%BB%93%E6%9E%84%2C%20%E4%B8%8D%E6%98%AFB%E6%A0%91%2C%20%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%2C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8B%2B%E6%A0%91%E7%BB%93%E6%9E%84%2C%20%E4%B8%8D%E6%98%AFB%E6%A0%91%2C%20%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%2C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F\">思考一下为何使用B+树结构, 不是B树, 不是平衡树二叉树,红黑树？</a></p>\n<p id=\"%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93\">索引总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"MySQL%E6%89%A7%E8%A1%8CSQL%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B\"><span style=\"color:#0d0016;\"><strong>MySQL执行SQL的整体流程</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>显示需要跟MYSQL Server 进行连接. 获取MySQL服务. 跟数据库进行交互.</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>connection Pool 连接池。提前创建多条连接通道. 新的连接请求到来就复用连接通道. </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>一条连接的建立对应一个线程的创建.  存在多线程并发操作数据库的问题.                  </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>--- 引出事务原理. 事务就是专门用来处理。  多连接并发时所产生的问题.</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>多线程 / 多连接同时对于 数据库进行写操作势必会产生什么?    脏数据  </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>咋处理的, 无非是  MVCC + mutex.  此处如果想要细致了解的, 可以看如下文章.</strong></span></p>\n<p><img alt=\"\" height=\"565\" src=\"..\\..\\static\\image\\5b4fec986c2f45e1972f288b1ceb1099.png\" width=\"852\"/><br/><a class=\"has-card\" href=\"https://blog.csdn.net/weixin_53695360/article/details/124026899?spm=1001.2014.3001.5502\" title=\"mysql事务的理解学习, 面试不问索引原理就是事务原理_小杰312的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">mysql事务的理解学习, 面试不问索引原理就是事务原理_小杰312的博客-CSDN博客</span><span class=\"link-desc\">mysql事务的理解学习, 面试不问索引原理就是事务原理</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/weixin_53695360/article/details/124026899?spm=1001.2014.3001.5502</span></span></a><span style=\"color:#0d0016;\"><strong>然后连接建立好之后就是对于客户端发过来的SQL语句进行解析优化.  查缓存. </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>缓存没有，交到存储引擎去查找, 去存储，去修改, 去插入, 去删除 （索引B+树）</strong></span></p>\n<p><span style=\"color:#fe2c24;\">很多大公司对于存储引擎的研究，研发岗都是特别重要核心的，所以对存储引擎感兴趣的可以去深究，算是一个很好的方向。大厂对此绝对有需求. 因为他实在太重要了，可以说是MySQL等数据库server的核心所在.</span></p>\n<h1 id=\"%E5%BC%95%E8%A8%80%2C%20MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0%E5%8E%9F%E5%9B%A0\"><span style=\"color:#0d0016;\"><strong>引言, MySQL索引底层学习原因</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>为何一定要理解索引的底层原理?  我会增删改查这些基本操作不就OK了嘛.</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>的确，对于以后的工作日常而言，增上改查对于我们普通的开发工程师来说是要不完的。</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>可是，</strong></span><span style=\"color:#fe2c24;\"><strong>面试的时候会问</strong></span><span style=\"color:#0d0016;\"><strong>。</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>而且对于我们服务器开发工程师而言，必须理解性能优化上的点点滴滴细节, 一定要从底层数据结构进行理解，因为总有一天我们可能成为更优秀的人, 成为架构师. 而且对于知识的理解点到位可以无形的根深你的记忆.</strong></span></p>\n<h1 id=\"%E7%A3%81%E7%9B%98%E4%BB%8B%E7%BB%8D(%E7%90%86%E8%A7%A3%E7%A3%81%E7%9B%98IO)\"><span style=\"color:#0d0016;\"><strong>磁盘介绍(理解磁盘IO)</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>我们常常在面试的时候回答使用B+树可以减少磁盘IO。索引的加入可以提高查询效率. 可以这些都过于浅显了. 我们甚至连磁盘是什么结构都不知道, 仅仅知道的是磁盘IO效率很低. 时间消耗很长. 远远大于内存IO</strong></span></p>\n<p><img alt=\"\" height=\"509\" src=\"..\\..\\static\\image\\fe85a44463a44730b48009c490cb4fec.png\" width=\"651\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>磁盘是由磁盘面, 磁道, 扇区, 读写磁头构成的.   </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>扇区的大小是512个字节. (现在有些改成了4k)， 很明显扇区就是用来存储的. 存储着数据库文件.</strong></span></p>\n<p><img alt=\"\" height=\"180\" src=\"..\\..\\static\\image\\e763deea6ea04ca09d440745779ed05c.png\" width=\"367\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>所以第一个问题来了? 我们查找数据库记录. 进行IO交互是直接按照扇区为单位进行交互吗?</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>NONONO.     是按照page进行一次IO交互的. </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>系统读取磁盘，page基本单位是 4KB 。</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>MySQL 进行IO的基本单位是 16KB 也就是 page = 16KB</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>为何page是更大了. 为何一次IO操作, IO交互是读取更多的数据到内存更好?</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>很明显， 一次读取的数据够多，就可以减少读取次数，也就可以减少IO交互次数，也就是读取磁盘的次数.</strong></span></p>\n<ul><li><span style=\"color:#0d0016;\"><strong>MySQL 中的数据文件，是以page为单位保存在磁盘当中的</strong></span></li><li><span style=\"color:#0d0016;\"><strong>MySQL 的 CURD 操作，都需要通过计算，找到对应的插入位置，或者找到对应要修改或者查询的数据。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>而只要涉及计算，就需要CPU参与，既然有CPU参与，就一定要能够先将数据移动到内存当中。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>所以在特定时间内，数据一定是磁盘中有，内存中也有。后续操作完内存数据之后，以特定的刷新策略，刷新到磁盘。而这时，就涉及到磁盘和内存的数据交互，也就是IO了。而此时IO的基本单位就是Page。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>为了更好的进行上面的操作， MySQL 服务器在内存中运行的时候，在服务器内部，就申请了被称为 Buffer Pool 的的大内存空间，来进行各种缓存。和磁盘数据进行IO交互</strong></span></li><li><span style=\"color:#0d0016;\"><strong>为何更高的效率，一定要尽可能的减少系统和磁盘IO的次数</strong></span></li></ul>\n<p><span style=\"color:#0d0016;\"><strong>于是现在出现了第一版最easy数据结构, 管理这些page:  你瞅瞅可以不.</strong></span></p>\n<p><img alt=\"\" height=\"451\" src=\"..\\..\\static\\image\\6a98202996164420b73cd8aef18553f1.png\" width=\"1200\"/></p>\n<p><span style=\"color:#0d0016;\"><strong> 知道是啥了吧。对对对就是它. 双向循环list。如下是更细节的图.</strong></span></p>\n<p><img alt=\"\" height=\"312\" src=\"..\\..\\static\\image\\d52f45ae97854384a57c42333d6b3389.png\" width=\"1031\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>上述这样的存储结构.  是用来存储记录的, 也就是存储数据的，在数据量很少的情况下.这样是没多大问题的</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>可是数据量达到一定程度的时候. 线性的查找每一页, IO交互的次数也会很多. 效率很低下.</strong></span></p>\n<p></p>\n<h1 id=\"%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84B%2B%E6%A0%91\"><span style=\"color:#0d0016;\"><strong>索引底层数据结构B+树</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>于是乎.  索引B+树这个结构出现了.  (为页添加目录的形式. 有点像. 上层页是下层页的目录.)</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>只有叶子结点会存储真正的记录信息. 上面的页都是存储的索引值 + 索引值对应的页的地址.</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>B+树的特征.   树宽大，但是高度低。 好处是啥?  查找页数少. 加载磁盘page到内存的磁盘IO次数少. 效率高. </strong></span></p>\n<p><img alt=\"\" height=\"586\" src=\"..\\..\\static\\image\\9c8c57443e864536aebe5a93cf47f6be.png\" width=\"834\"/></p>\n<h2 id=\"B%2B%E6%A0%91(%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95)\"><span style=\"color:#0d0016;\">B+树(聚集索引)</span></h2>\n<ol><li><span style=\"color:#0d0016;\"><strong>使用主键为key值构建B+树</strong></span></li><li><span style=\"color:#0d0016;\"><strong>除了叶子结点, 上面的所有结点都存储的是目录页. 只有叶子结点存储的是数据页.(实实在在的记录,行数据).</strong></span></li><li><span style=\"color:#0d0016;\"><strong>目录页只放各个下级Page的最小键值， 键值从左到右依次增大</strong></span></li><li><span style=\"color:#0d0016;\"><strong>最下面一层叶子结点. 采用双向链接. 构成双向循环链表.  why? </strong></span></li></ol>\n<h2 id=\"B%2B%E6%A0%91(%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95)\"><span style=\"color:#0d0016;\"><strong>B+树(辅助索引)</strong></span></h2>\n<ol><li><span style=\"color:#0d0016;\"><strong>辅助索引还是构成的B+树. 但是和上述不同的是. 辅助索引构成B+树的叶子结点中存储的不是行数据. 而是聚簇索引值 (主键值)， 然后通过这个主键值到聚簇索引B+树种去查询，操作</strong></span></li><li><span style=\"color:#0d0016;\"><strong>为什么要这样?  保证数据的一致性, 和保证全局仅存储一份数据.  </strong></span></li><li><span style=\"color:#0d0016;\"><strong>辅助索引也按照B+树结构组织起来, 是为了降低磁盘IO.  但是它的叶子结点中不是行数据，只有对应的主键，再回表到聚簇索引B+树中去查找操作.   (回表查询操作)</strong></span></li></ol>\n<h3 id=\"%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8B%2B%E6%A0%91%E7%BB%93%E6%9E%84%2C%20%E4%B8%8D%E6%98%AFB%E6%A0%91%2C%20%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%2C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F\"><span style=\"color:#0d0016;\"><strong>思考一下为何使用B+树结构, 不是B树, 不是平衡树二叉树,红黑树？</strong></span></h3>\n<p><span style=\"color:#0d0016;\"><strong>不采用红黑树 + AVL树原因在于树高的问题.  树高越高，进行的IO交互次数, 磁盘IO的次数越多.效率越低.</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>那为何使用B+树而不使用B树?</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>因为首先B树对比B+树. B+树是所有的数据全部分布在叶子结点上. 而B树不一样, 它是数据结点分布在整棵树. </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>所以弊端1出现了. B树的树高会高于B+树</strong></span></p>\n<ol><li><span style=\"color:#0d0016;\"><strong>非叶子节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>叶子节点相连，更便于进行范围查找</strong></span></li></ol>\n<h1 id=\"%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93\"><span style=\"color:#0d0016;\">索引总结</span></h1>\n<ol><li><span style=\"color:#0d0016;\"><strong>索引对应的底层数据结构是B+树.  数据存储在主键构成的聚簇索引B+树的叶子结点</strong></span></li><li><span style=\"color:#0d0016;\"><strong>使用索引B+树的优势在于提高查询效率. </strong></span></li><li><span style=\"color:#0d0016;\"><strong>索引尽量短小. B+树结点可以存储更多的  下层结点, 降低B+树树高.</strong></span></li><li><span style=\"color:#0d0016;\"><strong>查询频次较高且数据量大的表建立索引；索引选择使用频次较高，过滤效果好的列或者组合</strong></span></li><li><span style=\"color:#0d0016;\"><strong>尽量扩展索引，在现有索引的基础上，添加复合索引</strong></span></li><li><span style=\"color:#0d0016;\"><strong>不要 select * ； 尽量只列出需要的列字段</strong></span></li><li><span style=\"color:#0d0016;\"><strong>索引列，列尽量设置为非空</strong></span></li></ol>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-05-26 21:19:07", "summary": "目录执行的整体流程引言索引底层学习原因磁盘介绍理解磁盘索引底层数据结构树树聚集索引树辅助索引思考一下为何使用树结构不是树不是平衡树二叉树红黑树？索引总结执行的整体流程显示需要跟进行连接获取服务跟数据库"}