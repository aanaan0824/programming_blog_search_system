{"blogid": "123069837", "writerAge": "码龄2年", "writerBlogNum": "40", "writerCollect": "64", "writerComment": "2", "writerFan": "6", "writerGrade": "3级", "writerIntegral": "412", "writerName": "猪也是粉嘟嘟的", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123069837.jpg", "writerRankTotal": "92552", "writerRankWeekly": "363080", "writerThumb": "10", "writerVisitNum": "32189", "blog_read_count": "21858", "blog_time": "于 2022-02-24 09:26:13 发布", "blog_title": "vue2和vue3区别", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"1_vue2vue3_0\"></a>1. vue2和vue3双向数据绑定原理发生了改变</h1>\n<ol><li>vue2的双向数据绑定是利用了es5 的一个API Object.definepropert() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行处理。</li><li>相比与vue2，使用proxy API 优势有：defineProperty只能监听某个属性，不能对全对象进行监听；可以省去for in 、闭包等内容来提升效率（直接绑定整个对象即可）；可以监听数组，不用再去单独的对数组做特异性操作，vue3可以检测到数组内部数据的变化。</li></ol>\n<h1><a id=\"2Vue3Fragments_3\"></a>2.Vue3支持碎片（Fragments）</h1>\n<pre><code>就是说可以拥有多个跟节点。\n</code></pre>\n<h1><a id=\"3_Composition_API_5\"></a>3. Composition API</h1>\n<p>Vue2 与vue3 最大的区别是vue2使用选项类型api，对比vue3合成型api。旧得选项型api在代码里分割了不同得属性：data,computed,methods等；新得合成型api能让我们使用方法来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。</p>\n<h1><a id=\"4_data_7\"></a>4. 建立数据data</h1>\n<pre><code>vue2是把数据放入data中，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造得时候触发。使用一下三个步骤来简=建立反应性数据： 1. 从vue引入reactive；使用reactive() 方法来声明数据为响应性数据；3. 使用setup()方法来返回我们得响应性数据，从而template可以获取这些响应性数据。\n</code></pre>\n<h1><a id=\"5__9\"></a>5. 生命周期</h1>\n<pre><code>vue2     --------------- vue3\nbeforeCreate                         -&gt;   setup()\nCreated                                 -&gt;   setup()\nbeforeMount                          -&gt;   onBeforeMount\nmounted                                -&gt;    onMounted\nbeforeUpdate                        -&gt;    onBeforeUpdate\nupdated                                 -&gt;    onUpdated\nbeforeDestroyed                    -&gt;    onBeforeUnmount\ndestroyed                              -&gt;     onUnmounted\nactivated                                -&gt;     onActivated\ndeactivated                            -&gt;     onDeactivated\n</code></pre>\n<h1><a id=\"6_setup_24\"></a>6. 父子传参不同，setup()函数特性</h1>\n<ol><li>setup()函数接收两个参数：props、context(包含attrs、slots、emit)</li><li>setup函数是处于生命周期beforeCreated和created俩个钩子函数之前</li><li>执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）</li><li>与模板一起使用时，需要返回一个对象</li><li>因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。</li><li>父传子，用props,子传父用事件 Emitting Events。在vue2中，会调用this$emit然后传入事件名和对象；在vue3中得setup()中得第二个参数content对象中就有emit，那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。</li><li>在setup()内使用响应式数据时，需要通过 .value 获取</li></ol>\n<pre><code>import { ref } from 'vue'\nconst count = ref(0)\nconsole.log(count.value)\n</code></pre>\n<ol start=\"8\"><li>从setup() 中返回得对象上得property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加.value。</li><li>setup函数只能是同步的不能是异步的。</li></ol>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-02-24 09:26:13", "summary": "和双向数据绑定原理发生了改变的双向数据绑定是利用了的一个对数据进行劫持结合发布订阅模式来实现的。中使用了的对数据进行处理。相比与，使用优势有：只能监听某个属性，不能对全对象进行监听；可以省去、闭包等内"}