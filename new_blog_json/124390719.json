{"blogid": "124390719", "writerAge": "码龄2年", "writerBlogNum": "0", "writerCollect": "32", "writerComment": "2", "writerFan": "3", "writerGrade": "2级", "writerIntegral": "139", "writerName": "尊龍John lone", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124390719.jpg", "writerRankTotal": "97693", "writerRankWeekly": "258099", "writerThumb": "8", "writerVisitNum": "25934", "blog_read_count": "2136", "blog_time": "已于 2022-04-24 21:51:25 修改", "blog_title": "Unity观察者模式-委托事件delegate使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3><strong>观察者模式概念：</strong></h3>\n<p><span style=\"color:#000000;\"><strong>观察者模式</strong>是“设计模式”中的一种模式，也就做“发布-订阅模式”。 </span></p>\n<p><span style=\"color:#000000;\">和单例模式一样，都属于设计模式的范畴，设计模式是解决一类 </span></p>\n<p><span style=\"color:#000000;\">固定问题的代码套路。 </span></p>\n<p><span style=\"color:#000000;\">观察者模式Observer定义了一种一对多的依赖关系，让多个观察者对象 </span></p>\n<p><span style=\"color:#000000;\">同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者 </span></p>\n<p><span style=\"color:#000000;\">对象，使他们能够自动更新自己。</span></p>\n<p><span style=\"color:#000000;\">这样讲很模糊，我举个例子：</span></p>\n<p>我在B站追了一部番《鬼灭之刃》， “追番” 的这个动作，就相当于 “绑定” 委托方法；</p>\n<p><strong>被观察者---B站：</strong></p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n//定义委托方法类型.\npublic delegate void BLDelegage(string info);\n\n/// &lt;summary&gt;\n/// B站\n/// &lt;/summary&gt;\npublic class bilibiliDemo : MonoBehaviour\n{\n    //单例访问字段.\n    public static bilibiliDemo Instance;\n\n    //定义B站 追番按钮.\n    public event BLDelegage blDel;\n\n    private string info = \"您追的《鬼灭之刃》更新啦\";\n\n    /// &lt;summary&gt;\n    /// 单例化\n    /// &lt;/summary&gt;\n    private void Awake()\n    {\n        Instance = this;\n    }\n\n    private void Update()\n    {\n        //空格 模拟 追番按钮.\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            //发送消息给追番的用户.\n            blDel(info);\n        }\n    }\n}\n</code></pre>\n<p><strong>观察者---用户：</strong></p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n/// &lt;summary&gt;\n/// B站用户---我\n/// &lt;/summary&gt;\npublic class Me : MonoBehaviour\n{\n    void Start()\n    {\n        //Lambda表达式写法.可以不用，但起码要看得懂.\n        //bilibiliDemo.Instance.blDel += info =&gt; ZhuiFanInfo(info);\n\n        //匿名类写法.\n        bilibiliDemo.Instance.blDel += delegate (string info)\n        {\n            Debug.Log(gameObject.name + info);\n        };\n    }\n\n    /// &lt;summary&gt;\n    /// 接收B站追番消息\n    /// &lt;/summary&gt;\n    private void ZhuiFanInfo(string info)\n    {\n        Debug.Log(gameObject.name + info);\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"866\" src=\"..\\..\\static\\image\\62760d20b3624b4cbdf14ee2186da692.png\" width=\"1200\"/></p>\n<pre><code>    //观察者 将自身的方法 添加到 被观察者的事件中，\n    //当 被观察者使用时，将调用消息 发送给 观察者，通知观察者调用自身方法.\n\n    //我的理解：\n    //“总控制” 需要调用另一个脚本的 \"方法A\"，\n    //就创建一个委托事件，用于存储 另一个脚本的 \"方法A\".\n    //另一个脚本把 \"方法A\" 传递(绑定) 给“总控制”，方便“总控制”调用 \"方法A\".</code></pre>\n<p>其实这样的例子有很多，比如我最近做的一个项目有这样一个需求，</p>\n<p>当敌人死亡后，需要 通知 角色 调用自身的 “停止攻击”方法，</p>\n<p>如果用 获取对象身上的脚本，然后再调用对方的公开方法，这样就很麻烦，</p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n//定义委托类型.\npublic delegate void DeathTimeDelegate();\n\n/// &lt;summary&gt;\n/// 敌人\n/// &lt;/summary&gt;\npublic class Enemy : MonoBehaviour\n{\n    public static Enemy Instance;\n\n    /// &lt;summary&gt;\n    /// 定义委托方法\n    /// 告知对方本体已死亡\n    /// 调用对方的方法\n    /// &lt;/summary&gt;\n    public event DeathTimeDelegate DeathTimeDel;\n\n    private void Awake()\n    {\n        Instance = this;\n    }\n    \n    /// &lt;summary&gt;\n    /// 本体死亡\n    /// &lt;/summary&gt;\n    public void Die()\n    {\n        if (HP &lt;= 0)\n        {\n            DeathTimeDel();\n            Destroy(gameObject, 0.2f);\n            Debug.Log(transform.name + \"已死亡\");\n        }\n    }\n}</code></pre>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n/// &lt;summary&gt;\n/// 角色\n/// &lt;/summary&gt;\npublic class Player : Piece\n{\n    private void Awake()\n    {\n        //绑定到委托方法中.\n        Enemy.Instance.DoingThingsDel += () =&gt; StopAtk();\n    }\n\n    /// &lt;summary&gt;\n    /// 停止攻击\n    /// &lt;/summary&gt;\n    private void StopAtk()\n    {\n        Debug.Log(\"停止攻击\");\n    }\n}</code></pre>\n<p>又或者 子物体 调用 父物体的方法SendMessageUpwards(string parentName);</p>\n<p>用这个方法也可以，用委托也可以。</p>\n<p>如果想知道Lambda表达式的语法或者委托事件更详细的内容，可以看我上一篇帖：</p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_55532142/article/details/124389259?spm=1001.2014.3001.5502\" title=\"https://blog.csdn.net/weixin_55532142/article/details/124389259?spm=1001.2014.3001.5502\">https://blog.csdn.net/weixin_55532142/article/details/124389259?spm=1001.2014.3001.5502</a></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-24 21:51:25", "summary": "观察者模式概念：观察者模式是设计模式中的一种模式，也就做发布订阅模式。和单例模式一样，都属于设计模式的范畴，设计模式是解决一类固定问题的代码套路。观察者模式定义了一种一对多的依赖关系，让多个观察者对象"}