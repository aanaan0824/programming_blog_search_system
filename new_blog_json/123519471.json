{"blogid": "123519471", "writerAge": "码龄8年", "writerBlogNum": "76", "writerCollect": "205", "writerComment": "36", "writerFan": "643", "writerGrade": "4级", "writerIntegral": "1023", "writerName": "拂面清风三点水", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123519471.jpg", "writerRankTotal": "18819", "writerRankWeekly": "22204", "writerThumb": "82", "writerVisitNum": "108328", "blog_read_count": "4680", "blog_time": "于 2022-03-16 10:09:26 发布", "blog_title": "Unity中的UGUI源码解析之事件系统(4)-ExecuteEvents", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"UnityUGUI4ExecuteEvents_0\"></a>Unity中的UGUI源码解析之事件系统(4)-ExecuteEvents</h1>\n<p>今天介绍消息系统: <strong>ExecuteEvents</strong>.</p>\n<p>Unity实现的消息系统很简单, 一个静态类加一堆接口, 在处理事件时动态获取需要处理事件的对象, 几乎没有状态维护, 虽然每次处理事件都需要进行获取, 会损失一部分性能, 但是由于每个对象上的组件一般不会太多, 这个性能损失几乎可以忽略不计, 而带来的优势就是去除了大部分的状态管理, 极大的降低了维护和理解难度.</p>\n<h2><a id=\"EventInterfaces_6\"></a>EventInterfaces</h2>\n<p>Unity通过<strong>接口</strong>(Interface)定义时间, 所有继承了<strong>IEventSystemHandler</strong>这个接口的接口, 或者实现了这个接口的类可以被Unity看做是一种事件.</p>\n<p>在<strong>EventInterfaces</strong>定义了<strong>IEventSystemHandler</strong>和各种事件接口, 括号内是所属事件需要的事件数据类型:</p>\n<ul><li><code>public interface IEventSystemHandler(PointerEventData)</code>: 所有事件的祖先接口</li><li><code>public interface IPointerEnterHandler(PointerEventData)</code>: 进入事件, 也就是鼠标进入首次进入对象区域</li><li><code>public interface IPointerExitHandler(PointerEventData)</code>: 离开事件, 也就是鼠标进入首次离开对象区域</li><li><code>public interface IPointerDownHandler(PointerEventData)</code>: 按下事件</li><li><code>public interface IPointerUpHandler(PointerEventData)</code>: 抬起事件</li><li><code>public interface IPointerClickHandler(PointerEventData)</code>: 点击事件, 即短时间按下又抬起</li><li><code>public interface IInitializePotentialDragHandler(PointerEventData)</code>: 找到可拖动对象后, 真正开始拖动之前的事件, 整个拖动过程中只发送一次</li><li><code>public interface IBeginDragHandler(PointerEventData)</code>: 开始拖动事件, 整个拖动过程中只发送一次</li><li><code>public interface IDragHandler(PointerEventData)</code>: 拖动事件</li><li><code>public interface IEndDragHandler(PointerEventData)</code>: 停止拖动事件, 整个拖动过程中只发送一次</li><li><code>public interface IDropHandler(PointerEventData)</code>: 拖动并放开事件, 要求放开的时候鼠标还在所拖动的物体内部, 如果同时要处理点击事件(<code>IPointerClickHandler</code>)则无法触发此事件</li><li><code>public interface IScrollHandler(PointerEventData)</code>: 滚动事件</li><li><code>public interface IUpdateSelectedHandler(BaseEventData)</code>: 更新选中事件, 几乎每帧发送</li><li><code>public interface ISelectHandler(BaseEventData)</code>: 切换选中事件, 每次切换选中时向选中的对象发送</li><li><code>public interface IDeselectHandler(BaseEventData)</code>: 取消选中事件, 每次切换选中时向反选中的对象发送</li><li><code>public interface IMoveHandler(AxisEventData)</code>: 导航移动事件</li><li><code>public interface ISubmitHandler(BaseEventData)</code>: 导航提交事件</li><li><code>public interface ICancelHandler(BaseEventData)</code>: 导航取消事件</li></ul>\n<h2><a id=\"EventTrigger_31\"></a>EventTrigger</h2>\n<p>在之前的文章中提到过, 如果我们要接收特定事件, 处理继承或者实现事件接口外, 还可以通过<strong>EventTrigger</strong>来达到目的. 详情请参考事件系统的概述那篇文章.</p>\n<p>我们甚至可以结合两种方式一起使用, 比如下面的例子:</p>\n<pre><code class=\"prism language-c#\">using UnityEngine;\nusing UnityEngine.EventSystems;\n\npublic class EventTriggerTest : MonoBehaviour, IPointerClickHandler, IBeginDragHandler {\n    private void Start() {\n        var eventTrigger = GetComponent&lt;EventTrigger&gt;();\n        if (!eventTrigger) eventTrigger = gameObject.AddComponent&lt;EventTrigger&gt;();\n\n        var entry1 = new EventTrigger.Entry();\n        entry1.eventID = EventTriggerType.PointerClick;\n        entry1.callback.AddListener((eventData =&gt; {\n            var pointerEventData = eventData as PointerEventData;\n            Debug.LogError(\"----- PointerClick\");\n        }));\n        \n        var entry2 = new EventTrigger.Entry();\n        entry2.eventID = EventTriggerType.BeginDrag;\n        entry2.callback.AddListener((eventData =&gt; {\n            var pointerEventData = eventData as PointerEventData;\n            Debug.LogError(\"----- BeginDrag\");\n        }));\n        \n        eventTrigger.triggers.Add(entry1);\n        eventTrigger.triggers.Add(entry2);\n    }\n    public void OnPointerClick(PointerEventData eventData) {\n        Debug.LogError(\"##### PointerClick\");\n    }\n    public void OnBeginDrag(PointerEventData eventData) {\n        Debug.LogError(\"##### OnBeginDrag\");\n    }\n}\n\n//-----------------------------------\n// 输出\n// ##### OnBeginDrag\n// ----- BeginDrag\n// ##### PointerClick\n// ----- PointerClick\n</code></pre>\n<p>下面详细介绍<strong>EventTrigger</strong>的各个部分.</p>\n<h3><a id=\"EventTriggerType_81\"></a>EventTriggerType</h3>\n<p>在EventTriggerType中对应前面的各个接口, 定义了各种事件类型, 用来在各个模块之间传递和标识事件:</p>\n<pre><code class=\"prism language-c#\">public enum EventTriggerType\n{\n    PointerEnter = 0,\n    PointerExit = 1,\n    PointerDown = 2,\n    PointerUp = 3,\n    PointerClick = 4,\n    Drag = 5,\n    Drop = 6,\n    Scroll = 7,\n    UpdateSelected = 8,\n    Select = 9,\n    Deselect = 10,\n    Move = 11,\n    InitializePotentialDrag = 12,\n    BeginDrag = 13,\n    EndDrag = 14,\n    Submit = 15,\n    Cancel = 16\n}\n</code></pre>\n<h3><a id=\"EventTriggerTriggerEvent_108\"></a>EventTrigger.TriggerEvent</h3>\n<p>使用UnityEvent封装事件数据, 可通过<code>AddListener</code>添加事件处理回调.</p>\n<pre><code class=\"prism language-c#\">public class TriggerEvent : UnityEvent&lt;BaseEventData&gt; {}\n</code></pre>\n<h3><a id=\"EventTriggerEntry_116\"></a>EventTrigger.Entry</h3>\n<p>组合事件类型和事件处理回调.</p>\n<pre><code class=\"prism language-c#\">public class Entry\n{\n    public EventTriggerType eventID = EventTriggerType.PointerClick;\n    public TriggerEvent callback = new TriggerEvent();\n}\n</code></pre>\n<h3><a id=\"EventTrigger_128\"></a>EventTrigger</h3>\n<p><strong>EventTrigger</strong>本身是一个<strong>MonoBehavior</strong>, 没有继承于<strong>UIBehavior</strong>, 所以也可以用于非UI模块的消息处理.</p>\n<p><strong>EventTrigger</strong>本身很简单, 只是通过实现上面介绍的各种接口, 然后在触发各种事件时, 使用<strong>EventTrigger.Entry</strong>封装的类型确定回调, 进行事件处理.</p>\n<pre><code class=\"prism language-c#\">public class EventTrigger :\n        MonoBehaviour,\n        IPointerEnterHandler,\n        IPointerExitHandler,\n        IPointerDownHandler,\n        IPointerUpHandler,\n        IPointerClickHandler,\n        IInitializePotentialDragHandler,\n        IBeginDragHandler,\n        IDragHandler,\n        IEndDragHandler,\n        IDropHandler,\n        IScrollHandler,\n        IUpdateSelectedHandler,\n        ISelectHandler,\n        IDeselectHandler,\n        IMoveHandler,\n        ISubmitHandler,\n        ICancelHandler\n        {}\n</code></pre>\n<p><strong>EventTrigger</strong>相比业务类直接实现事件接口的方式来说, 极大的提高了代码的灵活性, 对同一个事件可以添加多个处理回调, 也可以动态删减处理回调等.</p>\n<p><strong>EventTrigger</strong>只有一个字段, 用于存储封装的入口, 每个入口抽象为一个委托(delegate), 也就是说<strong>EventTrigger</strong>本身不处理事件, 而只是委托处理: <code>private List&lt;Entry&gt; m_Delegates;</code> 这个委托容器在获取时懒加载创建.</p>\n<pre><code class=\"prism language-c#\">public List&lt;Entry&gt; triggers\n{\n    get\n    {\n        if (m_Delegates == null)\n            m_Delegates = new List&lt;Entry&gt;();\n        return m_Delegates;\n    }\n    set { m_Delegates = value; }\n}\n\nprivate void Execute(EventTriggerType id, BaseEventData eventData)\n{\n    for (int i = 0, imax = triggers.Count; i &lt; imax; ++i)\n    {\n        var ent = triggers[i];\n        if (ent.eventID == id &amp;&amp; ent.callback != null)\n            ent.callback.Invoke(eventData);\n    }\n}\n\npublic virtual void OnPointerEnter(PointerEventData eventData)\n{\n    Execute(EventTriggerType.PointerEnter, eventData);\n}\n\npublic virtual void OnPointerExit(PointerEventData eventData)\n{\n    Execute(EventTriggerType.PointerExit, eventData);\n}\n\n//.............\n</code></pre>\n<p>代码都大同小异, 这里只是摘取了部分代表性的代码.</p>\n<p>首先<code>OnPointerEnter</code>触发后, 调用<code>Execute</code>, 遍历所有的代理, 发现符合事件类型的代理则进行事件回调处理.</p>\n<p>当然, 我们也可以继承<strong>EventTrigger</strong>来对某些事件类型定制化我们自己的逻辑, 这也是Unity给我们的建议.</p>\n<h2><a id=\"ExecuteEvents_202\"></a>ExecuteEvents</h2>\n<p>事件系统通过<strong>ExecuteEvents</strong>来进行事件分发, 也就是说<strong>ExecuteEvents</strong>是<strong>消息系统</strong>. 虽然它的代码量和复杂度看上去有些\"配不上\"所谓的\"系统\"两个字.</p>\n<p><strong>ExecuteEvents</strong>本身是一个静态类, 划分为以下几个主要的部分.</p>\n<h3><a id=\"_208\"></a>提供委托封装事件处理函数</h3>\n<p>对上面提到的所有事件类型, 提供委托属性封装事件触发操作, 下面的代码也是摘取部分, 其它代码大同小异.</p>\n<pre><code class=\"prism language-c#\">public static class ExecuteEvents\n{\n    // 通过泛型声明委托函数, 封装处理器, 事件数据\n    public delegate void EventFunction&lt;T1&gt;(T1 handler, BaseEventData eventData);\n\n    // 转换事件数据类型\n    public static T ValidateEventData&lt;T&gt;(BaseEventData data) where T : class\n    {\n        if ((data as T) == null)\n            throw new ArgumentException(String.Format(\"Invalid type: {0} passed to event expecting {1}\", data.GetType(), typeof(T)));\n        return data as T;\n    }\n    \n    // 事件处理函数, 包含事件处理器, 事件处理回调, 事件数据\n    private static void Execute(IPointerEnterHandler handler, BaseEventData eventData)\n    {\n        handler.OnPointerEnter(ValidateEventData&lt;PointerEventData&gt;(eventData));\n    }\n\n    // 将事件处理函数转换为委托字段\n    private static readonly EventFunction&lt;IPointerEnterHandler&gt; s_PointerEnterHandler = Execute;\n\n    // 委托属性\n    public static EventFunction&lt;IPointerEnterHandler&gt; pointerEnterHandler\n    {\n        get { return s_PointerEnterHandler; }\n    }\n}\n</code></pre>\n<h3><a id=\"_243\"></a>从对象身上获取事件处理器</h3>\n<p>第二个大的部分就是消息系统的核心, 从对象身上获取事件处理器.</p>\n<p>大体思路就是收集对象身上所有有效的组件, 然后将这些组件作为事件处理器来处理特定事件.</p>\n<p>所谓有效组件就是实现了<strong>IEventSystemHandler</strong>接口, 并且能够处理指定事件(实现指定事件接口, 如<strong>IPointerClickHandler</strong>).</p>\n<p>同时还是可启用或者禁用的组件(<strong>Behaviour</strong>), Unity使用这个属性(<strong>isActiveAndEnabled</strong>)来标识该组件是否处理事件.</p>\n<p>所以在默认情况下, 只能通过禁用组件来忽略事件处理. 当然我们可以在消息系统分发之后, 通过二次处理来决定在业务层是否真正处理事件. Unity的实现不管这些, 只保证最基础的功能, 其它交给我们自己.</p>\n<pre><code class=\"prism language-c#\">// 判断组件是否有效\n// 组件必须事件特定事件接口\n// 组件必须处于可用状态\nprivate static bool ShouldSendToComponent&lt;T&gt;(Component component) where T : IEventSystemHandler\n{\n    var valid = component is T;\n    if (!valid)\n        return false;\n\n    var behaviour = component as Behaviour;\n    if (behaviour != null)\n        return behaviour.isActiveAndEnabled;\n    return true;\n}\n\n// 获取对象身上所有满足条件的事件处理器\nprivate static void GetEventList&lt;T&gt;(GameObject go, IList&lt;IEventSystemHandler&gt; results) where T : IEventSystemHandler\n{\n    // Debug.LogWarning(\"GetEventList&lt;\" + typeof(T).Name + \"&gt;\");\n    if (results == null)\n        throw new ArgumentException(\"Results array is null\", \"results\");\n\n    if (go == null || !go.activeInHierarchy)\n        return;\n\n    var components = ListPool&lt;Component&gt;.Get();\n    go.GetComponents(components);\n    for (var i = 0; i &lt; components.Count; i++)\n    {\n        if (!ShouldSendToComponent&lt;T&gt;(components[i]))\n            continue;\n\n        // Debug.Log(string.Format(\"{2} found! On {0}.{1}\", go, s_GetComponentsScratch[i].GetType(), typeof(T)));\n        results.Add(components[i] as IEventSystemHandler);\n    }\n    ListPool&lt;Component&gt;.Release(components);\n    // Debug.LogWarning(\"end GetEventList&lt;\" + typeof(T).Name + \"&gt;\");\n}\n</code></pre>\n<h3><a id=\"handler_296\"></a>从对象节点层级上获取第一个满足条件的事件处理器(handler)</h3>\n<pre><code class=\"prism language-c#\">// 处理器的对象池\nprivate static readonly ObjectPool&lt;List&lt;IEventSystemHandler&gt;&gt; s_HandlerListPool = new ObjectPool&lt;List&lt;IEventSystemHandler&gt;&gt;(null, l =&gt; l.Clear());\n\n\n// 判断指定对象是否可以可以处理特定事件\n// 通过对象身上是否存在满足条件的事件处理器\npublic static bool CanHandleEvent&lt;T&gt;(GameObject go) where T : IEventSystemHandler\n{\n    var internalHandlers = s_HandlerListPool.Get();\n    GetEventList&lt;T&gt;(go, internalHandlers);\n    var handlerCount = internalHandlers.Count;\n    s_HandlerListPool.Release(internalHandlers);\n    return handlerCount != 0;\n}\n\n// 从指定节点顺着父节点一直往上找, 一直找到一个可以处理特定事件的对象\npublic static GameObject GetEventHandler&lt;T&gt;(GameObject root) where T : IEventSystemHandler\n{\n    if (root == null)\n        return null;\n\n    Transform t = root.transform;\n    while (t != null)\n    {\n        if (CanHandleEvent&lt;T&gt;(t.gameObject))\n            return t.gameObject;\n        t = t.parent;\n    }\n    return null;\n}\n</code></pre>\n<p>因为几乎每帧都要获取handler, Unity使用对象池技术来降低性能损耗. 这个对象池在之前的文章中已经讲过了, 可以参考<a href=\"https://blog.csdn.net/woodengm/article/details/121956547\">这里</a>.</p>\n<h3><a id=\"_333\"></a>事件分发</h3>\n<pre><code class=\"prism language-c#\">// 向对象身上所有满足要求的处理指定事件的处理器发送事件\n// 使用对象池获取handler\npublic static bool Execute&lt;T&gt;(GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor) where T : IEventSystemHandler\n{\n    var internalHandlers = s_HandlerListPool.Get();\n    GetEventList&lt;T&gt;(target, internalHandlers);\n    //  if (s_InternalHandlers.Count &gt; 0)\n    //      Debug.Log(\"Executinng \" + typeof (T) + \" on \" + target);\n\n    for (var i = 0; i &lt; internalHandlers.Count; i++)\n    {\n        T arg;\n        try\n        {\n            arg = (T)internalHandlers[i];\n        }\n        catch (Exception e)\n        {\n            var temp = internalHandlers[i];\n            Debug.LogException(new Exception(string.Format(\"Type {0} expected {1} received.\", typeof(T).Name, temp.GetType().Name), e));\n            continue;\n        }\n\n        try\n        {\n            functor(arg, eventData);\n        }\n        catch (Exception e)\n        {\n            Debug.LogException(e);\n        }\n    }\n\n    var handlerCount = internalHandlers.Count;\n    s_HandlerListPool.Release(internalHandlers);\n    return handlerCount &gt; 0;\n}\n\nprivate static readonly List&lt;Transform&gt; s_InternalTransformList = new List&lt;Transform&gt;(30);\n\n// 收集对象和其所有父节点\nprivate static void GetEventChain(GameObject root, IList&lt;Transform&gt; eventChain)\n{\n    eventChain.Clear();\n    if (root == null)\n        return;\n\n    var t = root.transform;\n    while (t != null)\n    {\n        eventChain.Add(t);\n        t = t.parent;\n    }\n}\n\n// 向对象身上和所有父节点身上的所有满足要求的处理指定事件的处理器发送事件\npublic static GameObject ExecuteHierarchy&lt;T&gt;(GameObject root, BaseEventData eventData, EventFunction&lt;T&gt; callbackFunction) where T : IEventSystemHandler\n{\n    GetEventChain(root, s_InternalTransformList);\n\n    for (var i = 0; i &lt; s_InternalTransformList.Count; i++)\n    {\n        var transform = s_InternalTransformList[i];\n        if (Execute(transform.gameObject, eventData, callbackFunction))\n            return transform.gameObject;\n    }\n    return null;\n}\n</code></pre>\n<h3><a id=\"_406\"></a>使用</h3>\n<pre><code class=\"prism language-c#\">ExecuteEvents.Execute(gameObject, pointerData, ExecuteEvents.pointerEnterHandler);\nExecuteEvents.ExecuteHierarchy(gameObject, pointerEvent, ExecuteEvents.dropHandler);\n</code></pre>\n<p>有些事件只需要对象本身处理, 而另外一些事件需要对象的整个世系层级处理. 我们将在后面的输入模块分别介绍.</p>\n<h2><a id=\"_415\"></a>总结</h2>\n<p>今天介绍了事件系统中很重要的消息定义和消息系统部分, 我们对整个事件系统的了解又进入了新的层次.</p>\n<p>同时, 我这里不得不感慨一下, 看了这么多Unity的源码之后, 渐渐对Unity的设计哲学有了更深入的认识, 特别是C#层, 大部分设计都比较简洁, 这点值得我们学习.</p>\n<p>感觉Unity比较崇尚简洁和最大程度的开放(当然, 不开源是人家要恰饭, 可以理解), 他们基本上不会做保姆性质的功能, 尽可能简化框架代码, 把可定制化的部分交给客户.</p>\n<p>现在很多框架和业务耦合比较严重, 导致复用性不高, 难以推广. 在框架设计上还是需要多多下功夫才行. 当然我自己的框架也差不多有同样的问题, 所以需要不断学习借鉴进步啊. 希望大家一起共勉.</p>\n<p>好了, 今天就是这样, 希望对大家有所帮助.</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-16 10:09:26", "summary": "中的源码解析之事件系统今天介绍消息系统实现的消息系统很简单一个静态类加一堆接口在处理事件时动态获取需要处理事件的对象几乎没有状态维护虽然每次处理事件都需要进行获取会损失一部分性能但是由于每个对象上的组"}