{"blogid": "121914303", "writerAge": "码龄2年", "writerBlogNum": "21", "writerCollect": "342", "writerComment": "6", "writerFan": "13", "writerGrade": "2级", "writerIntegral": "259", "writerName": "English Chan", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121914303.jpg", "writerRankTotal": "236575", "writerRankWeekly": "492728", "writerThumb": "43", "writerVisitNum": "27191", "blog_read_count": "12296", "blog_time": "于 2021-12-15 13:31:43 发布", "blog_title": "ARIMA（p,d,q）模型原理及其实现 --------python", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2> 1.简介</h2>\n<p>ARIMA模型(Autoregressive Integrated Moving Average model)，差分整合移动平均自回归模型，又称整合移动平均自回归模型，时间序列预测分析方法之一。ARIMA(p,d,q)中，AR是\"自回归\"，p为自回归项数;MA为\"滑动平均\"，q为滑动平均项数，d为使之成为平稳序列所做的差分次数(阶数)。\"差分\"一词虽未出现在ARIMA的英文名称中，却是关键步骤。</p>\n<p><img alt=\"\" height=\"116\" src=\"..\\..\\static\\image\\814a1b63f0c94d88973c9619693d3cf9.png\" width=\"633\"/></p>\n<p></p>\n<h2>2.模型原理</h2>\n<p>在描述ARIMA模型，那么就离不开AR、MA、ARMA模型，下面先阐述这两个模型。</p>\n<h3>2.1 AR模型(自回归)</h3>\n<p>自回归只适用于预测与自身前期相关的现象，数学模型表达式如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\86305c5a05b844c8bc1596014a18a8d0.png\" width=\"352\"/></p>\n<p>其中<img alt=\"\" height=\"38\" src=\"..\\..\\static\\image\\bb43b299481c47759f19b4ca352deefd.png\" width=\"28\"/>是当前值，是常数项，<img alt=\"\" height=\"25\" src=\"..\\..\\static\\image\\e3401fd4fbb84aa68ed3c77d3ebf7528.png\" width=\"23\"/>是阶数，<img alt=\"\" height=\"33\" src=\"..\\..\\static\\image\\24e37eaf545142348d2072efcd792e68.png\" width=\"17\"/>是自相关系数，​​​​​<img alt=\"\" height=\"30\" src=\"..\\..\\static\\image\\c056c513017046b0b1484f17ad706b7b.png\" width=\"24\"/>是误差，同时<img alt=\"\" height=\"30\" src=\"..\\..\\static\\image\\7432d326a3a346959982b47734253db6.png\" width=\"24\"/></p>\n<p>要符合正态分布。 </p>\n<p></p>\n<p>该模型反映了在t时刻的目标值值与前t-1~p个目标值之前存在着一个线性关系，即：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"39\" src=\"..\\..\\static\\image\\7fd23af7ae684296b53c634874b0e07e.png\" width=\"287\"/></p>\n<h3> 2.2 MA模型（移动平均）</h3>\n<p> 移动平均模型关注的是自回归模型中的误差项的累加，数学模型表达式如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"95\" src=\"..\\..\\static\\image\\6e1c471140bd457fb32f804dfe378794.png\" width=\"370\"/></p>\n<p>该模型反映了在t时刻的目标值值与前t-1~p个误差值之前存在着一个线性关系，即：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"40\" src=\"..\\..\\static\\image\\87be18f3ff334325a926cafc9efbf073.png\" width=\"301\"/></p>\n<h3>2.3 ARMA模型（自回归移动平均）</h3>\n<p>该模型描述的是自回归与移动平均的结合，具体数学模型如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"104\" src=\"..\\..\\static\\image\\5dfce5e3ed284fafbe26211b58c394bb.png\" width=\"450\"/></p>\n<h3>2.4 ARIMA模型</h3>\n<p>基本原理：将数据通过差分转化为平稳数据，再将因变量仅对它的滞后值以及随机误差项的现值和滞后值进行回归所建立的模型。</p>\n<p>AR是自回归，p为自回归项；MA为移动平均，q为移动平均项数，d为时间序列成为平稳时所做的差分次数，一般做一阶差分，很少做二阶差分。</p>\n<h3>2.5 ACF</h3>\n<p>​​​ACF 是一个完整的自相关函数，可为我们提供具有滞后值的任何序列的自相关值。简单来说，它描述了该序列的当前值与其过去的值之间的相关程度。时间序列可以包含趋势，季节性，周期性和残差等成分。ACF在寻找相关性时会考虑所有这些成分</p>\n<h3>2.6 PACF</h3>\n<p>偏自相关函数PACF 只描述观测值<img alt=\"\" height=\"30\" src=\"..\\..\\static\\image\\8426b13c150a492ba97841f3badcbf0f.png\" width=\"22\"/>和其滞后项<img alt=\"\" height=\"30\" src=\"..\\..\\static\\image\\63b163d4ce944ee0b7d57d2647c08f8e.png\" width=\"35\"/>之间的直接关系，调整了其他较短滞后项<img alt=\"\" height=\"30\" src=\"..\\..\\static\\image\\f7406eba41904196852357e80e4a4d8d.png\" width=\"162\"/>的影响。</p>\n<h3>2.7 拖尾与截尾</h3>\n<p>截尾：在大于某个常数k后<strong>快速趋于0为k阶截尾 </strong></p>\n<p>拖尾：始终有非零取值，不会在k大于某个常数后就恒等于零(<strong>或在0附近随机波动</strong>)</p>\n<p> 例子：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\6c639f53e7aa12cca0563764a8a85be9.png\"/></p>\n<p><img alt=\"\" height=\"283\" src=\"..\\..\\static\\image\\84b8d2b76a634bbba421eb312c30e2cb.png\" width=\"638\"/></p>\n<h2>3.定阶（p,d,q)</h2>\n<h3>3.1 定d</h3>\n<p>因为AR（自回归）建立必须具有平稳性，所以在建立ARIMA模型也需要平稳性，使数据平稳性的方法可以讲数据进行差分处理，如一阶差分即t与t-1的差值，二阶差分为一阶差分基础上再进行一次差分，<strong>使数据平稳后的差分次数即为我们要定的参数d</strong>。</p>\n<p></p>\n<h3><strong>3.2 方法① 定p，q</strong><img alt=\"\" height=\"343\" src=\"..\\..\\static\\image\\901b8b460d0d432283e560bfd4b9c92d.png\" width=\"817\"/></h3>\n<ul><li>若PACFp阶段后<strong>截尾</strong>，则截尾的阶数即为模型所确定的参数p。</li><li>若ACFq阶段后<strong>截尾</strong>，则截尾的阶数即为模型所确定的参数q。</li></ul>\n<p>3.3 方法② 定p，q</p>\n<p>采用AIC或BIC原则，模型中AIC或BIC值越小，模型就越好。</p>\n<h2>4.假设检验</h2>\n<p>下面介绍在用python实现ARIMA模型使用到的假设检验。</p>\n<h3>4.1单位根检验（ADF）</h3>\n<p><strong>在建立ARIMA模型的前，要讲将数据平稳化</strong>，即需要对数据进行差分处理，一般进行一节差分即可，一般一节差分就可以通过检验，如果一阶不通过，就再进行一次差分，即二阶差分，但不是差分的次数越多越好，它可能会导致数据信息的损失。检验数据平不平稳，第一种方法可以通过直接观察差分后的折线图。第二种方法就是通过假设检验，即单位根检验：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"94\" src=\"..\\..\\static\\image\\b297c405788343cea07a93d8739b69e1.png\" width=\"227\"/></p>\n<p>注：这里没有详细描述检验原理，只是简单介绍其原假设与备择假设，感兴趣可查找相关资料。</p>\n<h3>4.2残差正态性检验</h3>\n<p>完成模型建立，需要对模型的残差进行正态性检验，python中scipy库中的stats类提供了一个 normaltest函数，用于检验数据是否符合正太性：</p>\n<p style=\"margin-left:.0001pt;text-align:center;\"><img alt=\"\" height=\"86\" src=\"..\\..\\static\\image\\441f1813ebb94983bae018a87c129ab0.png\" width=\"256\"/></p>\n<p style=\"margin-left:.0001pt;\">残差是否符合正态性不一定要用假设检验，也可以观察残差的qq图，当qq图的散点位于一条直线时候说明是符合正态分布，同时也可以绘制残差频数直方图，下面会介绍检验、qq图、频数直方图实现代码。</p>\n<h3> 4.3残差序列独立性检验</h3>\n<p>一个较好的ARIMA模型，残差序列之间是独立性的，检验德宾-沃森（Durbin-Watson）检验简称D-W检验，是目前检验自相关性最常用的方法，但它只适用于检验<strong>一阶自相关性</strong>。 先通过公式计算出DW值，再根据样本容量n和解释变量数目k查分布表，得到临界值dl和du，然后判断是否自相关，<strong>当DW值等于2左右时，模型不存在一阶自相关</strong>。</p>\n<p>注：这里没有详细描述检验原理，只是简单介绍检验判别方法，感兴趣可查找相关资料。</p>\n<h2>5.建模基本流程</h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"552\" src=\"..\\..\\static\\image\\dd0e36157a474c34864960c8b6e87a9a.png\" width=\"491\"/></p>\n<p></p>\n<h2>6.python实现ARIMA</h2>\n<p>这次建模所用到的库如下代码，若还没有安装，在cmd窗口输入 pip install 库名   即可安装。</p>\n<pre><code class=\"language-python\">import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport matplotlib\nimport seaborn as sns\nfrom  statsmodels.tsa.arima_model  import  ARIMA\nimport statsmodels as sm\nfrom scipy import stats </code></pre>\n<h3>6.1数据展示</h3>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"314\" src=\"..\\..\\static\\image\\dda4610eede14b2381f328b6fa303d4f.png\" width=\"190\"/></p>\n<p>这是笔者的数据，只要构造好这个dataframe数据类型就可以继续下面的步骤，<strong>该数据用变量data接受，下面的代码针对data变量都是针对这个数据集</strong>。</p>\n<h3>6.2缺失值处理</h3>\n<pre><code class=\"language-python\">data.info()</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"181\" src=\"..\\..\\static\\image\\85dcc31f4a7d490287678eee75cab178.png\" width=\"338\"/></p>\n<p>发现数据集存在缺失值，对于时间序列数据缺失值不能简单的使用全体数据均值、中位数、众数处理，最常用的方法有前后加权均值法、线性插值法、n最近邻均值法填充，本次采用n=2的n最近邻均值法填充，比如n取2，则用t-2,t-1，t+1,t+2时刻的平均值来填充缺失的t时刻的值，代码实现如下：</p>\n<pre><code class=\"language-python\">#找出有缺失值的行  data[[\"data\"]].isnull().T.any().values\ndef knm(df,n):\n    #找出缺失值的行\n    temp = df.isnull().T.any().values\n    temp_df = df.copy()\n    for i in range(len(temp)):\n        if temp[i] == True:\n            if i &lt; n-1:                  #前n个\n                 temp_df.loc[i,\"data\"] = df.loc[i:i+n,\"data\"].mean()  \n            elif i &gt; len(temp) - 1 -n:     #后n个\n                 temp_df.loc[i,\"data\"] = df.loc[i-n:i,\"data\"]\n            else:\n                 print(df.loc[i-n:i+n,\"data\"])\n                 temp_df.loc[i,\"data\"] = df.loc[i-n:i+n,\"data\"].mean()  \n                 print(i-n,i+n+1)\n    return temp_df\nnot_miss = knm(data[[\"data\"]],2)\ndata[\"data\"] = not_miss.values</code></pre>\n<h3><strong> 6.3数据可视化展示</strong></h3>\n<pre><code class=\"language-python\">plt.plot(data.iloc[:,1])\nplt.hist(data.iloc[:,1],bins=20)</code></pre>\n<p><img alt=\"\" height=\"232\" src=\"..\\..\\static\\image\\ed8366db25934ac1b967a6174731f18c.png\" width=\"332\"/><img alt=\"\" height=\"222\" src=\"..\\..\\static\\image\\909c7308b75942f5984e98eee8963574.png\" width=\"340\"/></p>\n<h3>6.4数据平稳化</h3>\n<pre><code class=\"language-python\">data[\"diff_1\"] = data[\"data\"].diff(1)  #一阶差分\ndata[\"diff_2\"] = data[\"data\"].diff(1)  #二阶差分\n\n#分别画出ACF(自相关)和PACF（偏自相关）图像\nfrom statsmodels.graphics.tsaplots import plot_acf\nfrom statsmodels.graphics.tsaplots import plot_pacf\n\ndef diff(df,col):\n    font = {\"size\":15,\n       \"family\":\"fangsong\"}\n    matplotlib.rc(\"font\",**font)\n    matplotlib.rcParams['axes.unicode_minus']=False\n    \n    df[\"diff_1\"] = df[col].diff(1)  #一阶差分\n    df[\"diff_2\"] = df[\"diff_1\"].diff(1)  #二阶差分\n    \n    #平稳数据折线图\n    plt.figure(figsize=(12,8))\n    plt.subplot(3,1,1)\n    plt.plot(df[col].values,label=\"源数据\")\n    plt.xlim(0,120)\n    plt.legend()\n    plt.subplot(3,1,2)\n    plt.plot(df[\"diff_1\"].values,c=\"darkgreen\",label=\"一阶差分\")\n    plt.plot([0,120],[0,0],\"--\",c = \"grey\")\n    plt.xlim(0,120)\n    plt.legend()\n    plt.subplot(3,1,3)\n    plt.plot(df[\"diff_2\"].values,c=\"tomato\",label=\"二阶差分\")\n    plt.plot([0,120],[0,0],\"--\",c = \"grey\")\n    plt.xlim(0,120)\n    plt.legend()\n    plt.show()\n    \n    #ACF PACF\n    print(\"-\"*50,\"未平稳数据ACF与PACF\",\"-\"*50)\n    fig = plt.figure(figsize=(12,8))\n    ax1 = fig.add_subplot(211)\n    fig = plot_acf(df[col], lags=40,ax = ax1)\n    ax2 = fig.add_subplot(212)\n    plot_pacf(df[col], lags=40,ax = ax2)\n    plt.show()\n    \n    #一阶差分后的ACF PACF\n    print(\"-\"*50,\"一阶差分数据ACF与PACF\",\"-\"*50)\n    fig = plt.figure(figsize=(12,8))\n    ax1 = fig.add_subplot(211)\n    fig = plot_acf(df[\"diff_1\"][1:].values, lags=40,ax = ax1)\n    ax2 = fig.add_subplot(212)\n    plot_pacf(df[\"diff_1\"][1:], lags=40,ax = ax2)\n    plt.show()\n    \ndiff(data,\"data\")</code></pre>\n<p><img alt=\"\" height=\"538\" src=\"..\\..\\static\\image\\555c3a8b5d0c436bb586cf0ca06cf289.png\" width=\"807\"/></p>\n<p><img alt=\"\" height=\"597\" src=\"..\\..\\static\\image\\b69b6b9bce1a4a3c80c311bbd98b954f.png\" width=\"828\"/></p>\n<p><img alt=\"\" height=\"598\" src=\"..\\..\\static\\image\\ee34cf584ec044598085f872ece18195.png\" width=\"825\"/></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">一阶自相关与偏相关图都呈现出拖尾现象，无法从这两图确定p与q。</p>\n<h3 style=\"margin-left:.0001pt;text-align:justify;\">6.5数据平稳性检验 单位根检验 </h3>\n<pre><code class=\"language-python\">#未差分平稳性检测（ADF检验、单位根检验）\nfrom  statsmodels.tsa.stattools  import  adfuller  as  ADF\nprint(u'原始序列的ADF检验结果为：',  ADF(data[\"data\"]))\n#返回值依次为adf、pvalue、usedlag、nobs、critical  values、icbest、regresults、resstore  p&lt;0.05时表示稳定</code></pre>\n<p><img alt=\"\" height=\"52\" src=\"..\\..\\static\\image\\c55f07df264c439d87f21b5123f34edf.png\" width=\"1111\"/></p>\n<pre><code class=\"language-python\">#一阶差分平稳性检测（ADF检验、单位根检验）\nfrom  statsmodels.tsa.stattools  import  adfuller  as  ADF\nprint(u'一阶差分序列的ADF检验结果为：',  ADF(data[\"diff_1\"][1:]))\n#返回值依次为adf、pvalue、usedlag、nobs、critical  values、icbest、regresults、resstore  p&lt;0.05时表示稳定</code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"56\" src=\"..\\..\\static\\image\\e771e7d259c14acdb1493a4c3bc097be.png\" width=\"1115\"/></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">一阶差分单位根检验p值&lt;0.05，原始序列p值&gt;0.05，于是ARIMA中的参数d定为1。</p>\n<h3 style=\"margin-left:.0001pt;text-align:justify;\">6.6根据bic/aic指标定p、q</h3>\n<pre><code class=\"language-python\">#定阶\n# pmax  =  int(len(df[\"失业率\"])/10)  #一般阶数不超过length/10\n# qmax  =  int(len(df[\"失业率\"])/10)  #一般阶数不超过length/10\npmax = 5\nqmax = 5\nbic_matrix  =  []  #bic矩阵\nfor  p  in  range(pmax+1):\n    tmp  =  []\n    for  q  in  range(qmax+1):  #存在部分报错，所以用try来跳过报错。\n        try:\n            tmp.append(ARIMA(data[\"data\"],order=(p,1,q)).fit().bic) \n        except:\n            tmp.append(None)\n    bic_matrix.append(tmp)\nbic_matrix  =  pd.DataFrame(bic_matrix)  #从中可以找出最小值\np,q  =  bic_matrix.stack().idxmin()  \n# #先用stack展平，然后用idxmin找出最小值位置。\nprint(u'BIC最小的p值和q值为：%s、%s'  %(p,q))</code></pre>\n<pre><code class=\"language-python\">#定阶\n# pmax  =  int(len(df[\"失业率\"])/10)  #一般阶数不超过length/10\n# qmax  =  int(len(df[\"失业率\"])/10)  #一般阶数不超过length/10\npmax = 5\nqmax = 5\naic_matrix  =  []  #bic矩阵\nfor  p  in  range(pmax+1):\n    tmp  =  []\n    for  q  in  range(qmax+1):  #存在部分报错，所以用try来跳过报错。\n        try:\n            tmp.append(ARIMA(data[\"data\"],order=(p,1,q)).fit().aic) \n        except:\n            tmp.append(None)\n    aic_matrix.append(tmp)\naic_matrix  =  pd.DataFrame(bic_matrix)  #从中可以找出最小值\np,q  =  bic_matrix.stack().idxmin()  \n# #先用stack展平，然后用idxmin找出最小值位置。\nprint(u'AIC最小的p值和q值为：%s、%s'  %(p,q))</code></pre>\n<p><img alt=\"\" height=\"43\" src=\"..\\..\\static\\image\\a1cfe52dc9684db7adf4ed1f031638c7.png\" width=\"223\"/><img alt=\"\" height=\"41\" src=\"..\\..\\static\\image\\b3eb802e4f20433da167693d2995c286.png\" width=\"235\"/></p>\n<p>根据aic/bic最小原则都筛选出p=5，q=3。</p>\n<h3>6.7模型拟合 AIRMA(5,1,3)</h3>\n<pre><code class=\"language-python\">arima513 = ARIMA(data[\"data\"],order=(5,1,3)).fit()\narima513.summary2()</code></pre>\n<p> <img alt=\"\" height=\"564\" src=\"..\\..\\static\\image\\69e6e70ea2b240c8898b2a0e1afae1b7.png\" width=\"491\"/></p>\n<p><img alt=\"\" height=\"278\" src=\"..\\..\\static\\image\\a802b7c44060465db7b3bd4eee8d3218.png\" width=\"356\"/></p>\n<h3>6.7模型检验</h3>\n<pre><code class=\"language-python\">resid=arima513.resid  #残差\nplt.figure(figsize=(12,8))\nplt.plot(resid)</code></pre>\n<p><img alt=\"\" height=\"533\" src=\"..\\..\\static\\image\\6ef19870e6b34ccf99726743c61ca3e1.png\" width=\"798\"/></p>\n<h3 id=\"1.残差正态性检验\">6.7.1残差正态性检验</h3>\n<pre><code class=\"language-python\">stats.normaltest(resid)#检验序列残差是否为正态分布    pvalue=0.00028625258929196876   &lt;  0.05  拒绝原假设 认为残差符合正太分布</code></pre>\n<p> <img alt=\"\" height=\"40\" src=\"..\\..\\static\\image\\64c28085ed9a4bc699cd3bf0c60488b5.png\" width=\"625\"/></p>\n<p>p&lt;0.05,接受备择假设，认为残差具有正态性</p>\n<pre><code class=\"language-python\">stats.probplot(resid, dist=\"norm\", plot=plt)\nplt.show()\nplt.hist(resid,bins=50)\nplt.show()</code></pre>\n<p> <img alt=\"\" height=\"234\" src=\"..\\..\\static\\image\\7344727931144eb79904b2828945c243.png\" width=\"326\"/><img alt=\"\" height=\"230\" src=\"..\\..\\static\\image\\9e4aba641c4a4433bdfe09f93d265c0f.png\" width=\"332\"/></p>\n<p>qq图散点基本在直线上，同时直方图也呈现正态性。</p>\n<h3>6.7.2残差序列自相关 （残差序列是否独立）</h3>\n<pre><code class=\"language-python\">from statsmodels.stats.stattools import durbin_watson\ndurbin_watson(arima513.resid.values)     ##DW检验：靠近2——正常；靠近0——正自相关；靠近4——负自相关</code></pre>\n<p><img alt=\"\" height=\"91\" src=\"..\\..\\static\\image\\4386cd66eb8145ef93d41319040804c1.png\" width=\"878\"/></p>\n<p> DW值非常靠近2，说明序列不具有相关性。</p>\n<h3>7.绘制原数据和预测数据对比图</h3>\n<pre><code class=\"language-python\"># 绘制原数据和预测数据对比图\narima513.plot_predict(dynamic=False)\nplt.show()</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"289\" src=\"..\\..\\static\\image\\d969be5f9e6b44348e65e79a1c1c041b.png\" width=\"418\"/></p>\n<p>通过观察预测值与实际值折线图，可以直观看出该模型拟合程度不怎么好，待优化</p>\n<p> </p>\n<p>​​</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-12-15 13:31:43", "summary": "简介模型，差分整合移动平均自回归模型，又称整合移动平均自回归模型，时间序列预测分析方法之一。中，是自回归，为自回归项数为滑动平均，为滑动平均项数，为使之成为平稳序列所做的差分次数阶数。差分一词虽未出现"}