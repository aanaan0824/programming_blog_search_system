{"blogid": "123591412", "writerAge": "码龄4年", "writerBlogNum": "34", "writerCollect": "259", "writerComment": "18", "writerFan": "2591", "writerGrade": "3级", "writerIntegral": "413", "writerName": "czy1219", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123591412.jpg", "writerRankTotal": "52589", "writerRankWeekly": "7581", "writerThumb": "56", "writerVisitNum": "61268", "blog_read_count": "14163", "blog_time": "已于 2022-03-19 11:38:10 修改", "blog_title": "C++new的几种用法详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>1、new operator</strong></p>\n<p>        new operator 指的就是new操作符，它分为两个阶段的操作：</p>\n<p>（1）调用::operator new 申请内存（相当于C语言的malloc）</p>\n<p>（2）调用类的构造函数</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nclass Fun{\npublic:\n    Fun(){ std::cout&lt;&lt;\"call constructor\"&lt;&lt;std::endl;}\n    ~Fun(){ std::cout&lt;&lt;\"call destructor\"&lt;&lt;std::endl;}\n};\n\nFun* ptr1 = new Fun;  \ndelete ptr1;\nptr1 = nullptr;\n\n// 输出结果\n// call constructor\n// call destructor</code></pre>\n<p>另外，需要注意的是new operator操作符是不能被重载的。</p>\n<p><strong>2、operator new</strong></p>\n<p>        operator new操作符单纯申请内存，并且是可以重载的函数。调用operator new申请内存，内存申请的大小为自定义类Fun的大小。使用operator new 和 operator delete并不会调用构造函数和析构函数，因为其仅仅具有申请内存的功能</p>\n<pre><code class=\"language-cpp\">Fun* ptr2 = (Fun*)::operator new(sizeof(Fun));\n::operator delete ptr2;\nptr2 = nullptr;\n\n// 加上::代表的是全局，因为operator可以重载\n// 此时编译器并不会输出call constructor和call destructor\n// 由此可以证明operator仅具有申请内存的功能</code></pre>\n<p><strong>（1）重载operator new 操作符：</strong></p>\n<pre><code class=\"language-cpp\">class Fun{\npublic:\n    Fun(){ std::cout&lt;&lt;\"call constructor\"&lt;&lt;std::endl;}\n    ~Fun(){ std::cout&lt;&lt;\"call destructor\"&lt;&lt;std::endl;}\n\n    void* operator new(size_t size)\n    {\n        std::cout&lt;&lt;\"operator new\"&lt;&lt;std::endl;\n        return ::operator new(size);\n    }\n    void operator delete(void* ptr)\n    {\n        std::cout&lt;&lt;\"operator delete\"&lt;&lt;std::endl;\n        ::operator delete(ptr);\n        ptr = nullptr;\n    }\n};  \n\nFun* ptr3 = new Fun;  \ndelete ptr3;\n\n// 此时输出的是：  \n// operator new\n// call constructor\n// call destructor\n// operator delete </code></pre>\n<p>由上述例子可以知道，Fun对象的构造与删除调用了重载的operator new和operator delete。</p>\n<p><strong>（2）operator new的另外一种重载版本：</strong></p>\n<pre><code class=\"language-cpp\">class Fun{\npublic:\n    Fun(){ std::cout&lt;&lt;\"call constructor\"&lt;&lt;std::endl;}\n    ~Fun(){ std::cout&lt;&lt;\"call destructor\"&lt;&lt;std::endl;}\n\n    void* operator new(size_t size)\n    {\n        std::cout&lt;&lt;\"operator new\"&lt;&lt;std::endl;\n        return ::operator new(size);\n    }\n    void* operator new(size_t size, std::string str)\n    {\n        std::cout&lt;&lt;\"operator new version 2: \"&lt;&lt;str&lt;&lt;std::endl;\n        return ::operator new(size);\n    }\n    void operator delete(void* ptr)\n    {\n        std::cout&lt;&lt;\"operator delete\"&lt;&lt;std::endl;\n        ::operator delete(ptr);\n        ptr = nullptr;\n    }\n};  \n\nFun* ptr4 = new(\"this is my func\") Fun;  \ndelete ptr4;\n\n// 此时输出的是：  \n// operator new version 2: this is my func\n// call constructor\n// call destructor\n// operator delete </code></pre>\n<p><strong>3、placement new</strong></p>\n<p>        placement new 又称为定位new运算符，它能够让程序员指定需要使用的位置。定位new运算符直接使用传递给它的地址，它不负责判断哪些内存单元已被使用，也不查找未使用的内存块。这将一些内存管理的负担交给了程序员。</p>\n<pre><code class=\"language-cpp\">char* buf[128]; // 创建一块内存池\nint* p1 = new(buf)int[10];\nfor(int i=0;i&lt;10;++i)\n    p1[i]=i+1;\n\nstd::cout&lt;&lt;\"buf的地址：\"&lt;&lt;(int*)buf&lt;&lt;std::endl;\nstd::cout&lt;&lt;\"p1数组的地址：\"&lt;&lt;p1&lt;&lt;std::endl;\n\nint* p2 = new(buf)int;\nstd::cout&lt;&lt;\"p2的地址：\"&lt;&lt;p2&lt;&lt;std::endl;\n\nint* p3 = new(buf+10*sizeof(int))int;\nstd::cout&lt;&lt;\"p3的地址：\"&lt;&lt;p3&lt;&lt;std::endl;\n\n/*\n    输出结果：\n    buf的地址：0x7ffe318d6d70\n    p1数组的地址：0x7ffe318d6d70\n    p2的地址：0x7ffe318d6d70\n    p3的地址：0x7ffe318d6eb0\n*/</code></pre>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-19 11:38:10", "summary": "、指的就是操作符，它分为两个阶段的操作：调用申请内存相当于语言的调用类的构造函数输出结果另外，需要注意的是操作符是不能被重载的。、操作符单纯申请内存，并且是可以重载的函数。调用申请内存，内存申请的大小"}