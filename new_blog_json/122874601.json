{"blogid": "122874601", "writerAge": "码龄7年", "writerBlogNum": "39", "writerCollect": "209", "writerComment": "36", "writerFan": "53", "writerGrade": "3级", "writerIntegral": "741", "writerName": "川穹冬菱草", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122874601.jpg", "writerRankTotal": "118323", "writerRankWeekly": "85086", "writerThumb": "37", "writerVisitNum": "51088", "blog_read_count": "4429", "blog_time": "已于 2022-02-11 10:54:35 修改", "blog_title": "C++ vector的大小（Size）和容量（Capacity）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>1 大小和容量</h2>\n<p>        vector优异效率的秘诀之一，就是分配出“较其容纳的元素”更多的内存。为了能够高效运用vector，你应该了解大小和容量之间的关系。</p>\n<p>        vector提供用以操作大小的函数有size()、empty()和max_size()。另一个与大小有关的函数是 capacity()，返回vector实际能够容纳的元素量。如果超越这个量，vector就有必要重新分配内部内存。</p>\n<h3>1.1 内存空间只会增长，不会减小</h3>\n<p>        vector在增加内部元素时会预留出更多的空间以容纳后面新加元素的存放，当现有容量不足以容纳新加元素时，会再分配出新的多出可容纳现有元素的空间。vector的实际容量不会随着内部元素的删除而减小。</p>\n<h3>1.2 reference、pointer和iterator失效</h3>\n<p>        即使删除元素，其reference、pointer和iterator也会继续有效，继续指向动作发生前的位置。然而安插动作却可能使reference、pointer和iterator失效。swap()和shrink_to_fit()也会使reference、pointer和iterator失效。</p>\n<h2></h2>\n<h2>2 缩减容量以符合元素个数</h2>\n<h3>2.1 shrink_to_fit()（C++11）</h3>\n<p>        可以缩减容量以符合当前的元素个数。但是这个请求不具强制力，具体缩减和优化情况取决于编译器。会使reference、pointer和iterator失效。</p>\n<h3>2.2 vector&lt;类型&gt;(temp_vector).swap(temp_vector)</h3>\n<p>        这种操作比较直接，但是也会使reference、pointer和iterator失效。</p>\n<p></p>\n<h2>3 释放vector的内存</h2>\n<h3>3.1 clear()后调用shrink_to_fit()，取决于编译器（可能释放不完全）</h3>\n<pre><code class=\"language-cpp\">temp_vector.clear();\ntemp_vector.shrink_to_fit();</code></pre>\n<h3>3.2 clear()后swap()<span style=\"color:#fe2c24;\">（推荐）</span></h3>\n<pre><code class=\"language-cpp\">temp_vector.clear();\nvector&lt;类型&gt;(temp_vector).swap(temp_vector);</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-02-11 10:54:35", "summary": "大小和容量优异效率的秘诀之一，就是分配出较其容纳的元素更多的内存。为了能够高效运用，你应该了解大小和容量之间的关系。提供用以操作大小的函数有、和。另一个与大小有关的函数是，返回实际能够容纳的元素量。如"}