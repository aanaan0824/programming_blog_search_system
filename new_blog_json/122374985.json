{"blogid": "122374985", "writerAge": "码龄9年", "writerBlogNum": "1073", "writerCollect": "813", "writerComment": "212", "writerFan": "8799", "writerGrade": "7级", "writerIntegral": "10921", "writerName": "Rust语言中文社区", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122374985.jpg", "writerRankTotal": "1209", "writerRankWeekly": "3826", "writerThumb": "431", "writerVisitNum": "619143", "blog_read_count": "1239", "blog_time": "于 2022-01-07 23:24:52 发布", "blog_title": "【Rust日报】2022-1-7 在 Rust 中为 RISC-V OS 实现自旋锁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div id=\"js_content\">\n<h4><strong>在 Rust 中为 RISC-V OS 实现自旋锁</strong></h4>\n<p>自旋锁是最基本的同步实现之一，也是实现操作系统时首先要考虑的组件之一。文章将简要回顾自旋锁的基础知识，如何在 Rust 中为自制操作系统实现它，以及它相对于 C 语言的优势。</p>\n<ul><li><p>https://vmm.dev/en/rust/spinlock.md</p></li></ul>\n<h4><strong>SNAFU 0.7 发布</strong></h4>\n<p>SNAFU 是一个库，可以在添加上下文的同时轻松地将底层错误分配到特定于域的错误中。可以类似这样处理错误：</p>\n<pre class=\"has\"><code class=\"language-go\">// We support struct errors ...\n#[derive(Debug, Snafu)]\n#[snafu(display(\"An error occurred for {username}\"))]\nstruct OneKindOfError { username: String }\n\n// ... enum errors ...\n#[derive(Debug, Snafu)]\nenum AnotherKindOfError {\n    #[snafu(display(\"Unable to finish situation one\"))]\n    SituationOne { source: OneKindOfError },\n\n    #[snafu(display(\"Unable to finish situation two for {user_id}\"))]\n    SituationTwo { source: OneKindOfError, user_id: u32 },\n}\n\n// ... and opaque errors, great for exposing as part of a public API.\n#[derive(Debug, Snafu)]\npub struct Error(AnotherKindOfError);</code></pre>\n<p>1 月 4 日 SNAFU 0.7 发布，更新了包括：使用结构和枚举的自定义错误类型，上下文选择器可以放在一个模块中等。</p>\n<ul><li><p>https://users.rust-lang.org/t/snafu-0-7-released/69766</p></li></ul>\n<h4><strong>将 Rust 的 std 移植到 rustix</strong></h4>\n<p>Rustix 是一个具有多个后端的系统调用包装库。它有一个原始的 Linux 系统调用后端，以及一个 libc 后端，其他后端正在开发中。Rustix 专为内存安全、I/O 安全和性能而设计。rustix 简化了与 C 整数类型大小相关的系统调用 API 中的一些小缺陷。举个例子：</p>\n<pre class=\"has\"><code class=\"language-go\">let len = cmp::min(buf.len(), &lt;wrlen_t&gt;::MAX as usize) as wrlen_t;\n   let ret = cvt(unsafe {\n       c::send(self.inner.as_raw(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n   })?;</code></pre>\n<p>将会变成</p>\n<pre class=\"has\"><code class=\"language-go\">let ret = rustix::net::send(&amp;self.inner, buf, SendFlags::NOSIGNAL)?;</code></pre>\n<p>这将重点放在send操作上，而没有unsafe、原始指针、wrlen_t类型和cvt错误处理的干扰。Rustix 还能够从 Rust 代码直接进行 Linux 系统调用。比如 origin 是一个 Rust 库，它能够启动和关闭进程和线程（类似于 crt1.o 和 libpthread）。有了这些，我们就有了在 Linux 上运行 Rust 程序所需的所有东西。</p>\n<ul><li><p>https://blog.sunfishcode.online/port-std-to-rustix/</p></li></ul>\n</div>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-01-07 23:24:52", "summary": "在中为实现自旋锁自旋锁是最基本的同步实现之一，也是实现操作系统时首先要考虑的组件之一。文章将简要回顾自旋锁的基础知识，如何在中为自制操作系统实现它，以及它相对于语言的优势。发布是一个库，可以在添加上下"}