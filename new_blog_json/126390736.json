{"blogid": "126390736", "writerAge": "码龄2年", "writerBlogNum": "93", "writerCollect": "5029", "writerComment": "5452", "writerFan": "4922", "writerGrade": "7级", "writerIntegral": "13517", "writerName": "一名不会打字的程序员", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126390736.jpg", "writerRankTotal": "786", "writerRankWeekly": "73", "writerThumb": "5253", "writerVisitNum": "78796", "blog_read_count": "740", "blog_time": "已于 2022-08-30 19:26:49 修改", "blog_title": "JavaScript算法描述【回溯算法】|括号生成|子集|电话号码的字母组合|全排列|单词搜索", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>🐧<strong>主页详情</strong>：<a href=\"https://blog.csdn.net/weixin_51568389?spm=1011.2435.3001.5343\">Choice~的个人主页</a><br/> 📢<strong>作者简介</strong>：🏅物联网领域创作者🏅 and 🏅阿里专家博主🏅 and 🏅华为云享专家🏅<br/> ✍️<strong>人生格言</strong>：最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。<br/> 🧑‍💻<strong>人生目标</strong>：成为一名合格的程序员，做未完成的梦：实现财富自由。<br/> 🚩<strong>技术方向</strong>：NULL<br/> 👻如果觉得博主的文章还不错的话，请三连支持一下博主哦<br/> 💬给大家介绍一个我一直在用的求职刷题收割offe👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_choice_js\">点击进入网站</a></p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_10\">回溯算法</a></li><li><ul><li><a href=\"#_34\">括号生成</a></li><li><ul><li><a href=\"#__54\">方法一 回溯法（实现一）</a></li><li><a href=\"#__109\">方法二 回溯法（实现二）</a></li></ul>\n</li><li><a href=\"#_163\">子集</a></li><li><ul><li><a href=\"#__186\">方法一 回溯算法</a></li><li><a href=\"#_188\">思路</a></li><li><a href=\"#_192\">详解</a></li><li><a href=\"#_200\">代码</a></li><li><a href=\"#_218\">复杂度分析</a></li><li><a href=\"#__228\">方法二 二进制表示法</a></li><li><a href=\"#_230\">思路</a></li></ul>\n</li><li><a href=\"#_280\">电话号码的字母组合</a></li><li><ul><li><a href=\"#__301\">方法一 挨个遍历</a></li><li><a href=\"#__361\">方法二 回溯</a></li></ul>\n</li><li><a href=\"#_417\">实现数组的全排列</a></li><li><ul><li><a href=\"#__439\">方法一 回溯法</a></li><li><a href=\"#__519\">方法二 插值排序法</a></li></ul>\n</li><li><a href=\"#_579\">单词搜索</a></li><li><ul><li><a href=\"#__602\">方法 回溯算法</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_10\"></a>回溯算法</h1>\n<p>回溯算法(back tracking)是一种类似尝试算法，按选优条件向前搜索，主要是在搜索尝试过程中寻找问题的解，以达到目标，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。换句话说，找到一条路往前走，能走就继续往前，不能走就算了，掉头换条路。相对于动态规划，这部分的内容相对于简单些。</p>\n<p>回溯的处理思想，和枚举搜索有点类似，通过枚举找到所有满足期望的值。为了有规律地枚举所有的解，可以把问题拆解为多个小问题。每个小问题，我们都会面对一个岔路口，选择一条发现此路不通的时，就往回走，走到另一个岔路口。</p>\n<p><img alt=\"image-20220817172722380\" src=\"..\\..\\static\\image\\90cffc2c66e3ee7162fe8a0ec4ce63cd.png\"/></p>\n<p>本章节分为 2 个部分，选取了比较经典的算法题，希望可以帮助到同学们学会解决回溯相关的算法题。</p>\n<ul><li>Part 1 \n  <ul><li>括号生成</li><li>子集</li><li>电话号码的字母组合</li></ul> </li><li>Part 2 \n  <ul><li>全排列</li><li>单词搜索</li></ul> </li></ul>\n<p>括号生成、子集和电话号码的字母组合</p>\n<h2><a id=\"_34\"></a>括号生成</h2>\n<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>\n<p><strong>示例</strong></p>\n<pre><code>例如，给出 n = 3，生成结果为：\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n</code></pre>\n<h3><a id=\"__54\"></a>方法一 回溯法（实现一）</h3>\n<p><strong>思路</strong></p>\n<p>我们知道，有且仅有两种情况，生成的括号序列不合法</p>\n<ul><li>我们不停的加左括号，其实如果左括号超过 n 的时候，它肯定不是合法序列了。因为合法序列一定是 n 个左括号和 n 个右括号。</li><li>如果添加括号的过程中，如果右括号的总数量大于左括号的总数量了，后边不论再添加什么，它都不可能是合法序列了。</li></ul>\n<p>基于上边的两点，我们只要避免它们，就可以保证我们生成的括号一定是合法的了。</p>\n<p><strong>详解</strong></p>\n<ol><li>采用回溯法，即把问题的解空间转化成了图或者树的结构表示，然后，使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</li><li>如果自定义的字符串长度足够且走到这里，那么就说明这个组合是合适的，我们把它保存。</li><li>否则，递归执行添加左括号，添加右括号的操作。</li><li>递归结束条件为结果字符串长度等于左右括号的总个数（2n），则返回最终结果。</li></ol>\n<p><strong>代码</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">/**\n * @param {number} n\n * @return {string[]}\n */</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">generateParenthesis</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> gen <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>str <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> r <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 如果自定义的字符串长度足够且走到这里，那么就说明这个组合是合适的</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      res<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 下面的逻辑：左括号必须出现在右括号的前面</span>\n    <span class=\"token comment\">// 只有在 l &gt;= n 的 时候，才不能添加左括号，其他都可添加</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${<!-- --></span>str<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">(</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 如果右括号没有左括号多，我们就可以添加一个右括号</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${<!-- --></span>str<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> r <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<p>我们的复杂度分析依赖于理解 generateParenthesis(n) 中有多少个元素。这个分析需要更多的背景来解释，但事实证明这是第 n 个卡塔兰数 \\dfrac{1}{n+1}\\binom{2n}{n}n+11(n2n)，这是由 \\dfrac{4^n}{n\\sqrt{n}} nn4n 渐近界定的。</p>\n<ul><li>时间复杂度：O(\\dfrac{4^n}{\\sqrt{n}})O(n4n)，在回溯过程中，每个有效序列最多需要 n 步。</li><li>空间复杂度：O(\\dfrac{4^n}{\\sqrt{n}})O(n4n)，如上所述，并使用 O(n)O(n) 的空间来存储序列。</li></ul>\n<h3><a id=\"__109\"></a>方法二 回溯法（实现二）</h3>\n<p><strong>思路</strong></p>\n<p>整体的实现思路也是回溯法，也是递归来实现该思路，唯一不同的是，递归的结束条件是左右括号都消费尽。</p>\n<p><strong>详解</strong></p>\n<ol><li>采用回溯法，即把问题的解空间转化成了图或者树的结构表示，然后，使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</li><li>首先，先从左括号开始填充。</li><li>然后，填充右括号，保证两类括号数目一致，平衡。</li><li>递归结束条件为左右括号均消费尽，则输出结果。</li></ol>\n<p><strong>代码</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">/**\n * @param {number} n\n * @return {number}\n */</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">generateParenthesis</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// left :左括号个数， right:右括号个数</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">helper</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">,</span> str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">===</span> max <span class=\"token operator\">&amp;&amp;</span> right <span class=\"token operator\">===</span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      res<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 先从左括号开始填充</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${<!-- --></span>str<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">(</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 保证两类括号数目一致</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&gt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${<!-- --></span>str<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<p>本方法也是使用回溯法，只是具体实现方式不同，因此，复杂度也是一样的。</p>\n<ul><li>时间复杂度：O(\\dfrac{4^n}{\\sqrt{n}})O(n4n)</li></ul>\n<p>在回溯过程中，每个有效序列最多需要 nn 步。</p>\n<ul><li>空间复杂度：O(\\dfrac{4^n}{\\sqrt{n}})O(n4n)</li></ul>\n<p>如上所述，并使用 O(n)O(n) 的空间来存储序列。</p>\n<h2><a id=\"_163\"></a>子集</h2>\n<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>\n<p>**说明：**解集不能包含重复的子集。</p>\n<pre><code>输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n</code></pre>\n<h3><a id=\"__186\"></a>方法一 回溯算法</h3>\n<h3><a id=\"_188\"></a>思路</h3>\n<p>设置初始二维数组[[]]，依次把每个数加入到数组中的每一个元素中，并保留原来的所有元素。</p>\n<h3><a id=\"_192\"></a>详解</h3>\n<ol><li>初始化二维数组来存储所有子集；</li><li>使用双层遍历，外层遍历 nums 数组，内层遍历二维数组，将每个元素与二维数组每项合并，并保留二维数组原有的元素</li><li>并将得到的新子集与二维数组元素合并，最后得到所有子集；</li></ol>\n<p>例如：输入 nums = [1, 2, 3] 初始化二维数组存储所有子集 result = [[]] 然后遍历 nums, 1 添加到[], 结果为 [[], [1]]; 2 添加到[], [1], 结果为 [[], [1], [2], [1, 2]]; 3 添加到[], [1], [2], [1, 2], 结果为 [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];</p>\n<h3><a id=\"_200\"></a>代码</h3>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">subsets</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">nums</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始化二维数组</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token keyword\">of</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">const</span> temp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> k <span class=\"token keyword\">of</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      temp<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 依次把每个元素添加到数组中</span>\n    <span class=\"token punctuation\">}</span>\n    result <span class=\"token operator\">=</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"_218\"></a>复杂度分析</h3>\n<ul><li>时间复杂度：O(2^n)O(2n)</li></ul>\n<p>根据上述算法，每次循环 result 数组的次数为 2^{(n - 1)}2(n−1)， 则计算总数为 1 + 2^1 + 2^2 + … + 2^{(n-1)}1+21+22+…+2(n−1)，根据等比数列计算公式得到循环总次数为 2^n - 12n−1，所以时间复杂度为 O(2^n)O(2n)。</p>\n<ul><li>空间复杂度：O(2^n)O(2n)</li></ul>\n<p>根据排列组合原理，子集包含一个数字的情况所耗费的存储空间为 C_n^1 * 1Cn1∗1 ，包含两个数字所耗费的存储空间为 C_n^2 * 2Cn2∗2 ，根据算法得出 共需要 C_n^0 + C_n^1 + 2 * C_n^2 + … + (n - 1) * C_n^{n - 1} + n * C_n^nCn0+Cn1+2∗Cn2+…+(n−1)∗Cnn−1+n∗Cnn 个存储空间，根据排列组合公式求和可得需要 n*2^{n-1} + 1n∗2n−1+1 个额外存储空间， 所以算法空间复杂度为 O(2^n)O(2n)。</p>\n<h3><a id=\"__228\"></a>方法二 二进制表示法</h3>\n<h3><a id=\"_230\"></a>思路</h3>\n<p>从数学角度看，求子集其实是一个排列组合问题，比如 nums = [1, 2, 3]，存在四种情况：</p>\n<ol><li>都不选，情况共有 C_3^0= 1C30=1种</li><li>只选 1 个数，情况共有 C_3^1 = 3C31=3种</li><li>选 2 个数，情况共有 C_3^2 = 3C32=3 种</li><li>全选，情况共有 C_3^3 = 1C33=1种</li></ol>\n<p>落到数组中的每个数字，都有两种可能，选与不选，我们用 1 标识选，用 0 标识不选。 则 [] 表示为 000，[1, 2, 3] 表示为 111，我们通过转化为二进制表示法，遍历 000 - 111 的所有组合，即可求出所有子集。</p>\n<p><strong>详解</strong></p>\n<ol><li>根据上述分析，我们得出加入数组为 nums，则针对每位存在选与不选两种情况，那么所有组合数为 2 ^ {length}2length 个。</li><li>针对每一种组合情况，我们可以取出该二进制表示法中的每一位，如 110，我们分别通过向右移位并和 1 求与，判断最低为的值为 0 或者 1。</li><li>如果得到结果为 1，那么表示该位表示的数字在原数组中被选中，存入暂存数组，一轮遍历后即可获得该组子集的数字组合。将所有子集数字组合一起存入结果数组，即求出所有子集。</li></ol>\n<p><strong>代码</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">subsets</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">nums</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// 子集的数量</span>\n  <span class=\"token keyword\">const</span> len <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> setNums <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> setNums<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> temp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 判断该二进制表示法中，每一个位是否存在</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&gt;&gt;</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token comment\">// 如果该位为 1，则存入组合数组</span>\n        temp<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul><li>时间复杂度：O(2^n)O(2n)</li></ul>\n<p>一共包含 2^n2n 个组合需要 n * 2^nn∗2n 次计算，所以时间复杂度为 O(2^n)O(2n)。</p>\n<ul><li>空间复杂度：O(2^n)O(2n)</li></ul>\n<h2><a id=\"_280\"></a>电话号码的字母组合</h2>\n<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<p><strong>示例</strong></p>\n<pre><code>输入：\"23\"\n\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\n</code></pre>\n<p><img alt=\"image-20220817172754224\" src=\"..\\..\\static\\image\\45031ccfafa3d686f530efb2658909b0.png\"/></p>\n<h3><a id=\"__301\"></a>方法一 挨个遍历</h3>\n<p><strong>思路</strong></p>\n<p>利用队列的先进先出的特点，把队列中的第一个元素拿出，再与后面的挨个拼接</p>\n<p>a, b, c --&gt; b, c, ad, ae, af --&gt; c, ad, ae, af, bd, be, bf -&gt; …</p>\n<p><strong>详解</strong></p>\n<ol><li>先在队列中插入一个空字符</li><li>取出队列中的第一个元素，与后一位数字对应的字符进行挨个拼接</li><li>重复第二步，直到结束</li></ol>\n<p><strong>代码</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">letterCombinations</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">digits</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">const</span> map <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token number\">2</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">3</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'e'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'f'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">4</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'g'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'h'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'i'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">5</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'j'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'k'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'l'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">6</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'m'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'n'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'o'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">7</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'q'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'r'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">8</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'t'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'u'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'v'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">9</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'w'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'z'</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>digits<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">''</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> digits<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">const</span> letters <span class=\"token operator\">=</span> map<span class=\"token punctuation\">[</span>digits<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> size <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">const</span> temp <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 取出第一个元素</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> letters<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${<!-- --></span>temp<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${<!-- --></span>letters<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 第一个元素与后一位数字对应的字符进行挨个拼接</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul><li> <p>时间复杂度： O(3^m * 4^n)O(3m∗4n)</p> <p>通过数组的 push 我们发现，循环的次数和最后数组的长度是一样的，然而数组的长度有和输入多个3个字母的数目、4个字母的数目有关，得出时间复杂度为 O(3^m * 4^n)O(3m∗4n)</p> <p>其中 mm 为3个字母的数目，nn 为4个字母的数目</p> </li><li> <p>空间复杂度： O(3^m * 4^n)O(3m∗4n)</p> <p>最后结果的长度和输入的数字有关，得出复杂度为 O(3^m * 4^n)O(3m∗4n)</p> </li></ul>\n<h3><a id=\"__361\"></a>方法二 回溯</h3>\n<p><strong>思路</strong></p>\n<p>这道题有点排列组合的味道，我们可以穷举所有的可能性，找到所有的可能性</p>\n<p><strong>详解</strong></p>\n<ol><li> <p>如果还有数字需要被输入，就继续遍历数字对应的字母进行组合 <code>prefix</code> + <code>letter</code></p> </li><li> <p>当发现没有数字输入时，说明已经走完了，得到结果</p> <p><strong>代码</strong></p> </li></ol>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">const</span> map <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token number\">2</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">3</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'e'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'f'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">4</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'g'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'h'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'i'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">5</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'j'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'k'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'l'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">6</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'m'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'n'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'o'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">7</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'q'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'r'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">8</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'t'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'u'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'v'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">9</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'w'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'z'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">letterCombinations</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">digits</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">backtrack</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">prefix<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 发现没有字母需要输入时，就可以返回了</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">const</span> digit <span class=\"token operator\">=</span> next<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> letters <span class=\"token operator\">=</span> map<span class=\"token punctuation\">[</span>digit<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取对应的各个字母</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> letters<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">backtrack</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">+</span> letters<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>digits<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">backtrack</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> digits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul><li>时间复杂度： O(3^m * 4^n)O(3m∗4n)</li><li>空间复杂度： O(3^m * 4^n)O(3m∗4n)</li></ul>\n<p>实现数组的全排列和单词搜索</p>\n<h2><a id=\"_417\"></a>实现数组的全排列</h2>\n<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\n<p><strong>示例</strong></p>\n<pre><code>给定 numbs = [1,2,3];\n\n返回\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n</code></pre>\n<h3><a id=\"__439\"></a>方法一 回溯法</h3>\n<p><strong>思路</strong></p>\n<p>回溯法通常是构造一颗生成树，生成树排列法的核心思想为： 遍历需要全排列的数组，不断选择元素，将不同的数字生成一颗树，如果数组中待选择的结点数为 0，则完成一种全排列。</p>\n<p><strong>详解</strong></p>\n<p>从上面的思路中，我们可以抽象出全排列函数的步骤：</p>\n<pre><code>1. 遍历需要全排列的数组，取出不同位置的数字，创建以对应位置数字为根节点的树。\n\n2. 遍历剩下的数组，选出一个数字，将该数字挂在生成的树上。\n\n3. 重复第二步操作直到剩余数字数组的长度为0，表明完成了全排列，将生成的树存入排序结果数组中。\n</code></pre>\n<p>举个例子：输入数组为 [1, 2, 3]，首先选择 1 为根节点，剩余数组为 [2, 3]，继续选择 2 作为下一个结点，剩余数组为 [ 3 ]，那么选择 3 为最后一个结点，那么 [1, 2, 3] 组成一种全排列情况。 我们回溯到第二步剩余数组，选择 3 为第二个结点，那么剩余数组为 [ 2 ]，选择后完成 [1, 3, 2] 这种全排列情况。后续依次固定 2，3 为根结点，列出所有可能。</p>\n<blockquote>\n<p>从上述内容中可以看出，生成初始树后就是一个 截取数组 -&gt; 设置节点，继续 截取节点 -&gt; 设置节点 的递归过程了。那么我们是否可以将第一步的操作合并到我们的递归函数中呢？</p>\n</blockquote>\n<p>既然我们递归的操作是截取数字，并将对应的数字与目标树结合。那么我们可以将第一步看为数字和空树结合。</p>\n<p>那么我们递归函数的参数就确定为：</p>\n<ul><li>剩余的数组</li><li>现有的顺序树</li></ul>\n<p>递归函数的逻辑也可以收敛为：</p>\n<ol><li>遍历需要全排列的数组，将不同位置的数字与目前树结合起来</li><li>重复该操作直到需要全排列的数组长度为 0，即表明完成了全排列。</li></ol>\n<p><strong>代码</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">permute</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">numbs</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">const</span> allSortResult <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置结果数组</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">recursion</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">restArr<span class=\"token punctuation\">,</span> tempResult</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> restArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token comment\">// 获取不同位置的数字</span>\n      <span class=\"token keyword\">const</span> insertNumb <span class=\"token operator\">=</span> restArr<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 将不同位置的数字与现有的顺序树相结合</span>\n      <span class=\"token keyword\">const</span> nextTempResult <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>tempResult<span class=\"token punctuation\">,</span> insertNumb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">/**\n       * 判断传入的数组长度\n       * 大于1:\n       * 继续递归，参数分别为：\n       *  1. 除去当前数字外的数组\n       *  2. 新生成的树\n       * 等于1(不会出现小于1的情况):\n       *  表明已经结合到了最后一个节点，将生成的顺序树推送到结果数组中\n       */</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>restArr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&gt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">recursion</span><span class=\"token punctuation\">(</span>\n          restArr<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resetNumb</span> <span class=\"token operator\">=&gt;</span> resetNumb <span class=\"token operator\">!==</span> insertNumb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          nextTempResult\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n        allSortResult<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>nextTempResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 调用递归方法，开始生成顺序树</span>\n  <span class=\"token function\">recursion</span><span class=\"token punctuation\">(</span>numbs<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 返回全排列结果</span>\n  <span class=\"token keyword\">return</span> allSortResult<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul><li>时间复杂度：O(n^2)O(n2)</li><li>空间复杂度：O(n^2)O(n2)</li></ul>\n<h3><a id=\"__519\"></a>方法二 插值排序法</h3>\n<p><strong>思路</strong></p>\n<p>插值排列法的核心思想为： 遍历需要全排列的数组，将不同位置的数字抽离出来，插入到剩余数组的不同位置，即可得到该数字与另一个数组的全排列结果。 将一个固定的数字，插入到另一个数组的全排列结果的不同位置， 遍历需要全排列的数组，将不同的数字连接到不同的树上 继续全排列剩下的数组与生成的树，当剩余数组长度为0时，表明完成了全排列。</p>\n<p><strong>详解</strong></p>\n<p>从上面的思路中，我们可以抽象出插值排序全排列方法的具体实现：</p>\n<blockquote>\n<p>首先处理特殊情况。如果传入排列的数组长度为1，直接返回该数组。否则进行下面的全排列方法</p>\n</blockquote>\n<pre><code>  1. 截取传入数组的第 1 位数字，将剩余数组传入获取全排列方法函数，获取剩余数字的全排列结果\n\n  2. 遍历剩余数字的全排列结果数组并取出各个结果\n\n  3. 使用循环将截取的数字插入到不同结果(数组)的不同位置，生成新的全排列结果并保存\n\n  4. 返回全排列结果数组\n</code></pre>\n<p><strong>代码</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">permute</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">numbs</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// 设定保存结果变量</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 如果长度为1，只有一种排列，直接返回</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numbs<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>numbs<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 长度大于1，获取除第一个数字外的数组的全排列结果</span>\n    <span class=\"token keyword\">const</span> allSortList <span class=\"token operator\">=</span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span>numbs<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 遍历剩余数字的全排列结果数组</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> sortIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> sortIndex <span class=\"token operator\">&lt;</span> allSortList<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> sortIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token comment\">// 取出不同的全排列结果</span>\n      <span class=\"token keyword\">const</span> currentSort <span class=\"token operator\">=</span> allSortList<span class=\"token punctuation\">[</span>sortIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 将第一个数字插入到不同的位置来生成新的结果，并保存</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;=</span> currentSort<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">const</span> tempSort <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>currentSort<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tempSort<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> numbs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>tempSort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 返回全排列结果数组</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析：</strong></p>\n<ul><li>时间复杂度：O(n^3)O(n3) 时间复杂度由全排列函数 permute 提供。单个全排列函数中存在两层循环嵌套，因此单次调用的时间复杂度为 O(n^2)O(n2) 当 numbs 长度为 nn 到 2 时调用全排列函数，即调用 (n-2)(n−2)次 n^2(n-2) = n^3 - 2n^2n2(n−2)=n3−2n2; 当 nn 趋近于无限大时，nn 可以忽略，因此时间复杂度为 O(n^3)O(n3)</li><li>空间复杂度：O(n^3)O(n3)， 在循环体内使用4个变量，空间复杂度为 O(4*n^3)O(4∗n3) ，当 nn 趋近于无限大，忽略系数，即为 O(n^3)O(n3)</li></ul>\n<h2><a id=\"_579\"></a>单词搜索</h2>\n<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n<p><strong>示例</strong></p>\n<pre><code>board =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\n给定 word = \"ABCCED\", 返回 `true`.\n给定 word = \"SEE\", 返回 `true`.\n给定 word = \"ABCB\", 返回 `false`.\n</code></pre>\n<h3><a id=\"__602\"></a>方法 回溯算法</h3>\n<p><strong>思路</strong></p>\n<p>题目给的要求水平相邻或垂直相邻的单元格，这与回溯的思想非常相似，简单来说，上下左右都去走一遍，发现不符合要求立即返回。</p>\n<p>以题目的示例为例子，从 A 开始，放四个方向试探，如果不匹配，立即换方向</p>\n<p><strong>详解</strong></p>\n<ol><li>从起点开始，枚举所有的可能性，递归搜索</li><li>如果当前字符串匹配，再考虑上下左右 4 个方向，当发现超出边界或者不匹配时，立即结束当前方向的搜索</li></ol>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">exist</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">board<span class=\"token punctuation\">,</span> word</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">const</span> m <span class=\"token operator\">=</span> board<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> n <span class=\"token operator\">=</span> board<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">wordSearch</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">wordSearch</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> k</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 超出边界或者不匹配时，返回 false</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> i <span class=\"token operator\">&gt;=</span> m <span class=\"token operator\">||</span> j <span class=\"token operator\">&gt;=</span> n <span class=\"token operator\">||</span> word<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 找到最后一个字符，返回 true，为递归的终止条件</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">===</span> word<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 先占位</span>\n    <span class=\"token keyword\">const</span> temp <span class=\"token operator\">=</span> board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'-'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 往四个方向递归搜索，有一个方向匹配就可以了</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">wordSearch</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n      <span class=\"token function\">wordSearch</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n      <span class=\"token function\">wordSearch</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n      <span class=\"token function\">wordSearch</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 四个方向搜索完了释放</span>\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul><li> <p>时间复杂度： O((m*n)^2)O((m∗n)2)</p> <p>mm 和 nn 分别是矩阵的行数和列数。 每个递归函数 <code>wordSearch</code> 的调用次数为 m * nm∗n，并且调用了4个递归函数，复杂度为 O(4 * m * n)O(4∗m∗n) 在 for 循环下，时间复杂度为 O(m * n)O(m∗n)。 因此总的时间复杂度为 O(4 (m * n)^2) = O((m*n)^2)O(4(m∗n)2)=O((m∗n)2)</p> </li><li> <p>空间复杂度： O(m*n)O(m∗n)</p> <p>每个递归函数的递归深度为 m * nm∗n*,* 空间复杂度为 O(m * n)O(m∗n)，一共调用了4个，因此总的复杂度为 O(4 * m * n) = O(m * n)O(4∗m∗n)=O(m∗n)</p> </li></ul>\n<p>👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_choice_js\">练习打卡</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-08-30 19:26:49", "summary": "主页详情：的个人主页作者简介：物联网领域创作者阿里专家博主华为云享专家人生格言：最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。人生目标：成为一名合格的程序员，做未完成的梦：实现财富自由。"}