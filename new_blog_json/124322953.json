{"blogid": "124322953", "writerAge": "码龄1年", "writerBlogNum": "772", "writerCollect": "1269", "writerComment": "1458", "writerFan": "984", "writerGrade": "7级", "writerIntegral": "9287", "writerName": "90后小伙追梦之路", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124322953.jpg", "writerRankTotal": "1573", "writerRankWeekly": "2105", "writerThumb": "296", "writerVisitNum": "230331", "blog_read_count": "4921", "blog_time": "于 2022-04-21 15:26:56 发布", "blog_title": "Java集合框架最全详解(看这篇就够了)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>Java集合体系框架</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\bbaef140797ccefa52c25fc1e8c76dda.png\"/></p>\n<p></p>\n<p><br/> Java集合类主要由两个根接口Collection和Map派生出来的。</p>\n<p><strong>Collection派生出了三个子接口：</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\4cfa805e289acf247134ea24a843e199.png\"/></p>\n<p></p>\n<p><strong>1)List</strong></p>\n<p>List代表了有序可重复集合，可直接根据元素的索引来访问</p>\n<p><strong>2)Set</strong></p>\n<p>Set代表无序不可重复集合，只能根据元素本身来访问</p>\n<p><strong>3)Queue</strong></p>\n<p>Queue是队列集合</p>\n<p><strong>Map接口派生：</strong></p>\n<p>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\104a0d4ea24a7601a85c430d11708855.png\"/></p>\n<p></p>\n<p>因此Java集合大致也可分成<strong>List、Set、Queue、Map四种接口体系</strong>。</p>\n<h1>Java集合List</h1>\n<p>List代表了有序可重复集合，可直接根据元素的索引来访问。</p>\n<p>List接口常用的实现类有：ArrayList、LinkedList、Vector。</p>\n<h1>List集合特点</h1>\n<ul><li>集合中的元素允许重复</li><li>集合中的元素是有顺序的，各元素插入的顺序就是各元素的顺序</li><li>集合中的元素可以通过索引来访问或者设置</li></ul>\n<h1>ArrayList</h1>\n<p>ArrayList是一个动态数组，也是我们最常用的集合，是List类的典型实现。</p>\n<p>它允许任何符合规则的元素插入甚至包括null，每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。</p>\n<p>随着容器中的元素不断增加，容器的大小也会随着增加，在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。</p>\n<p>所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p>\n<p>ArrayList擅长于随机访问，同时ArrayList是非同步的。</p>\n<h1>Vector</h1>\n<p>与ArrayList相似，但是Vector是同步的，它的操作与ArrayList几乎一样。</p>\n<h1>LinkedList</h1>\n<p>LinkedList是采用双向循环链表实现，LinkedList是List接口的另一个实现，除了可以根据索引访问集合元素外，LinkedList还实现了Deque接口，可以当作双端队列来使用，也就是说，既可以当作“栈”使用，又可以当作队列使用。</p>\n<h1>Java List总结</h1>\n<p><strong>1）ArrayList</strong><br/> 优点: 底层数据结构是数组，查询快，增删慢。<br/> 缺点: 线程不安全，效率高</p>\n<p><strong>2）Vector</strong><br/> 优点: 底层数据结构是数组，查询快，增删慢。<br/> 缺点: 线程安全，效率低</p>\n<p><strong>3）LinkedList</strong><br/> 优点: 底层数据结构是链表，查询慢，增删快。<br/> 缺点: 线程不安全，效率高</p>\n<h1>Java集合Set</h1>\n<p>Set扩展Collection接口,无序集合，不允许存放重复的元素。</p>\n<p>Set接口常用的实现类有：HashSet、LinkedHashSet、TreeSet</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\b4608d42538119ac773dca1a90dee7bc.png\"/></p>\n<p></p>\n<h1>HashSet</h1>\n<p><strong>HashSet是Set集合最常用实现类，是其经典实现。</strong></p>\n<p>HashSet底层数据结构采用哈希表实现，元素无序且唯一，线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。</p>\n<h1>LinkedHashSet</h1>\n<p>底层数据结构采用链表和哈希表共同实现，链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性。</p>\n<h1>TreeSet</h1>\n<p>底层数据结构采用二叉树来实现，元素唯一且已经排好序,唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。</p>\n<h1>Java Set总结</h1>\n<p><strong>1）HashSet</strong></p>\n<ul><li>底层其实是包装了一个HashMap实现的</li><li>底层数据结构是数组+链表 + 红黑树</li><li>具有比较好的读取和查找性能， 可以有null 值</li><li>通过equals和HashCode来判断两个元素是否相等</li><li>非线程安全</li></ul>\n<p><strong>2）LinkedHashSet</strong></p>\n<ul><li>继承HashSet，本质是LinkedHashMap实现</li><li>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</li><li>有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序</li><li>非线程安全，可以有null 值</li></ul>\n<p><strong>3）TreeSet</strong></p>\n<ul><li>是一种排序的Set集合，实现了SortedSet接口，底层是用TreeMap实现的，本质上是一个红黑树原理</li><li>排序分两种：自然排序（存储元素实现Comparable接口）和定制排序（创建TreeSet时，传递一个自己实现的Comparator对象）</li><li>正常情况下不能有null值，可以重写Comparable接口 局可以有null值了。</li></ul>\n<h1>Java集合Queue</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\4211caa20c204b1f7615364862f118f7.png\"/></p>\n<p></p>\n<p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p>\n<h1>PriorityQueue</h1>\n<p>PriorityQueue保存队列元素的顺序并不是按照加入的顺序，而是按照队列元素的大小进行排序的。<br/> PriorityQueue不允许插入null元素。</p>\n<h1>Deque</h1>\n<p>Deque接口是Queue接口的子接口，它代表一个双端队列,当程序中需要使用“栈”这种数据结构时，推荐使用ArrayDeque。</p>\n<h1>Java集合Map</h1>\n<p>Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f0a8994fe91d6187553736d0a6121639.png\"/></p>\n<p></p>\n<h1>1.HashMap</h1>\n<p>Map接口基于哈希表的实现，是使用频率最高的用于键值对处理的数据类型。</p>\n<p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，特点是访问速度快，遍历顺序不确定，线程不安全，最多允许一个key为null，允许多个value为null。</p>\n<p>可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap类。</p>\n<h1>2.Hashtable</h1>\n<p>Hashtable和HashMap从存储结构和实现来讲有很多相似之处，不同的是它承自Dictionary类，而且是线程安全的，另外Hashtable不允许key和value为null，并发性不如ConcurrentHashMap。</p>\n<p>Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>\n<h1>3.LinkedHashMap</h1>\n<p>LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现，它维护着一个双重链接列表，此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>\n<h1>4.TreeMap</h1>\n<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>\n<h1>5.Map总结</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\39c58e175efd2ba779280e8bd093902f.png\"/></p>\n<p></p>\n<p>更多架构技术干货，私信【<strong>架构</strong>】即可查看我<strong>原创的300期+BAT架构技术系列文章与1000+大厂面试题答案合集。</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\867fbc255e3c8373ce782336cc8e2bb0.png\"/></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-21 15:26:56", "summary": "集合体系框架集合类主要由两个根接口和派生出来的。派生出了三个子接口：代表了有序可重复集合，可直接根据元素的索引来访问代表无序不可重复集合，只能根据元素本身来访问是队列集合接口派生：代表的是存储对的集合"}