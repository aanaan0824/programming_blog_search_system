{"blogid": "124990454", "writerAge": "码龄8年", "writerBlogNum": "1", "writerCollect": "18", "writerComment": "0", "writerFan": "3", "writerGrade": "1级", "writerIntegral": "13", "writerName": "qq_20786701", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124990454.jpg", "writerRankTotal": "220006", "writerRankWeekly": "1189925", "writerThumb": "1", "writerVisitNum": "2494", "blog_read_count": "2368", "blog_time": "于 2022-05-26 19:21:25 发布", "blog_title": "Oracle 执行计划篇", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>----------- 内容详解 --------------</p>\n<p><strong>1.执行计划的常用列字段解释：</strong></p>\n<pre><code>基数（Rows）：Oracle估计的当前操作的返回结果集行数\n\n字节（Bytes）：执行该步骤后返回的字节数\n\n耗费（COST）、CPU耗费：Oracle估计的该步骤的执行成本，用于说明SQL执行的代价， 理论上越小越好\n\t\t\t\t\t（该值可能与实际有出入）\n\n时间（Time）：Oracle估计的当前操作所需的时间\n</code></pre>\n<p><strong>2.执行顺序：</strong></p>\n<pre><code>根据Operation缩进来判断，缩进最多的最先执行；（缩进相同时，最上面的最先执行）\n</code></pre>\n<p><strong>3.检索方式：</strong></p>\n<pre><code>1.TABLE ACCESS BY …  即描述的是该动作执行时表访问（或者说Oracle访问数据）的方式（非全部）:\n\t\n\ta.TABLE ACCESS FULL（全表扫描）:\n\t\t\tOracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 Where 限制条件；\n\t\t\t全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作，提升吞吐量；\n\t\t    使用建议：数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    b.ABLE ACCESS BY ROWID（通过ROWID的表存取）:\n\t\t\tROWID是由Oracle自动加在表中每行最后的一列伪列，既然是伪列，就说明表中并不会物理存储ROWID的值；\n\t\t\t你可以像使用其它列一样使用它，只是不能对该列的值进行增、删、改操作；\n\t\t\t一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。\n\t\t\t让我们再回到 TABLE ACCESS BY ROWID 来：行的ROWID指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法；\n\n\tc.TABLE ACCESS BY INDEX SCAN（索引扫描）:\n\t\t\t在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。\n\t\t\t所以索引扫描其实分为两步：\n\t\t\t\t\t\t\t\t\t\t\tⅠ：扫描索引得到对应的ROWID\n\t\t\t\t\t\t\t\t\t\t\tⅡ：通过ROWID定位到具体的行读取数据\n\t\t\t\t\t\t\t\t\t\t\t\n\td.TABLE ACCESS BY INDEX ROWID BATCHED: \n\t\tThe BATCHED access shown in Step 1 means that the database retrieves a few rowids from the index, \n\t\tand then attempts to access rows in block order to improve the clustering and reduce the number \n\t\tof times that the database must access a block.\n\n\t\t这句话的意思是说，该操作是数据库为了从索引中获取一些rowid，接着，试着按照块顺序存取块中的数据行，\n\t\t以便用来改善聚集效果和减少对一个数据块存取的次数。\n\t\t官方解释的意思就是这样，但怎么理解呢？之前，当我们通过索引获取的rowid回表获取相应数据行时，\n\t\t都是读一个rowid回表获取一次相应数据行，然后，再读一个rowid，再回表获取一次相应数据行。。。，\n\t\t这样一直读取完所有所需数据。当不同rowid对应的数据行存储在一个数据块中时，就可能会发生对\n\t\t同一表数据块的多次读取，当一个索引的聚集因子比较低时，这也是一个必然结果，从而浪费了系统\n\t\t资源。Oracle 12c中该新特性，通过对rowid对应的数据块号进行排序，然后回表读取相应数据行，\n\t\t从而避免了对同一表数据块的多次重复读取，从而改善了SQL语句的性能，降低了资源消耗。\n\t\t该特性通过隐藏参数“_optimizer_batch_table_access_by_rowid”控制，默认值为true，即为开启。\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n----------------索引扫描延伸-------------------\n\n索引扫描又分五种：\n\t\t\t\t(a)INDEX UNIQUE SCAN（索引唯一扫描）\n\t\t\t\t\t针对唯一性索引（UNIQUE INDEX）的扫描，每次至多只返回一条记录；\n\t\t\t\t\t表中某字段存在 UNIQUE、PRIMARY KEY 约束时，Oracle常实现唯一性扫描；\n\n\t\t\t\t(b)INDEX RANGE SCAN（索引范围扫描）\n\t\t\t\t\t使用一个索引存取多行数据；\n\t\t\t\t\t发生索引范围扫描的三种情况：\n\t\t\t\t\t在唯一索引列(unique索引)上使用了范围操作符（如：&gt;   &lt;   &lt;&gt;   &gt;=   &lt;=   between）\n\t\t\t\t\t在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）\n\t\t\t\t\t对非唯一索引列(非unique)上进行的任何查询 \n\n\t\t\t\t(c)INDEX FULL SCAN（索引全扫描）\n\t\t\t\t\t进行全索引扫描时，查询出的数据都必须从索引中可以直接得到\n\t\t\t\t\t（注意全索引扫描只有在CBO模式下才有效）\n\n                (d)INDEX FAST FULL SCAN（索引快速扫描）\n\t\t\t\t\t扫描索引中的所有的数据块，与 INDEX FULL SCAN 类似，但是一个显著的区别是它不对\n\t\t\t\t\t查询出的数据进行排序（即数据不是以排序顺序被返回）\n\n\t\t\t\t(e)INDEX SKIP SCAN（索引跳跃扫描）\n\t\t\t\t\tOracle 9i后提供，有时候复合索引的前导列（索引包含的第一列）没有在查询语句中出现，\n\t\t\t\t\toralce也会使用该复合索引，这时候就使用的INDEX SKIP SCAN;什么时候会触发\n\t\t\t\t\t INDEX SKIP SCAN 呢？\n\t\t\t\t\t前提条件：表有一个复合索引，且在查询时有除了前导列（索引中第一列）外的其他列作\n\t\t\t\t\t为条件，并且优化器模式为CBO时当Oracle发现前导列的唯一值个数很少时，会将每个唯\n\t\t\t\t\t一值都作为常规扫描的入口，在此基础上做一次查找，最后合并这些查询；\n\t\t\t\t\t例如：\n\t\t\t\t\t假设表emp有ename（雇员名称）、job（职位名）、sex（性别）三个字段，并且建立\n\t\t\t\t\t了如 create index idx_emp on emp (sex, ename, job) 的复合索引；因为性别只有 '男' \n\t\t\t\t\t和 '女' 两个值，所以为了提高索引的利用率，Oracle可将这个复合索引拆成 \n\t\t\t\t\t('男', ename, job)，('女', ename, job) 这两个复合索引；当查询 select * from emp where job = \n\t\t\t\t\t'Programmer' 时，该查询发出后：Oracle先进入sex为'男'的入口，这时候使用到了 ('男', ename, job) \n\t\t\t\t\t这条复合索引，查找 job = 'Programmer' 的条目；再进入sex为'女'的入口，这时候使用到了\n\t\t\t\t\t ('女', ename, job) 这条复合索引，查找 job = 'Programmer' 的条目；\n\t\t\t\t\t 最后合并查询到的来自两个入口的结果集。\n\n\n----------------分区表扫描方式-----------------------\nPARTITION RANGE ALL  \t\t扫描所有分区\nPARTITION RANGE ITERATOR\t扫描部分分区\nPARTITION RANGE SINGLE\t\t扫描单个分区\n</code></pre>\n<p><strong>4.表连接的几种方式：</strong><br/> 注：这里将首先存取的表称作 row source 1，将之后参与连接的表称作 row source 2</p>\n<pre><code>(1)SORT MERGE JOIN（排序-合并连接）\n\t假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id)\n\t\t内部连接过程：\n\t\ta) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序\n\t\tb) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序\n\t\tc) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接）\n\t\t\n\t\t延伸：\n\t\t\t如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提\n\t\t\t高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。故可以考虑在 a.id，b.id\n\t\t\t上建立索引让其能预先排好序。不过遗憾的是，由于返回的结果集中包括所有字段，所以通\n\t\t\t常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处\n\t\t\t理（如仅仅只查询有索引的列等）。\n\t\t\t排序-合并连接的表无驱动顺序，谁在前面都可以；\n\t\t\t排序-合并连接适用的连接条件有： &lt;   &lt;=   =   &gt;   &gt;= ，不适用的连接条件有： &lt;&gt;    like\n\n\n(2)NESTED LOOPS（嵌套循环）\n\t\tJOIN 关键字用于将两张表作连接，一次只能连接两张表，JOIN 操作的各步骤一般是串行的（在读取做连接的两张表的数据时可以并行读取）；\n\t\t\t\t\t表（row source）之间的连接顺序对于查询效率有很大的影响，对首先存取的表（驱动表）先应用某些限制条件（Where过滤条件）以得到一个较小的row source，可以使得连接效率提高。\n\n\t\t\t\t\t-------------------------延伸阅读：驱动表（Driving Table）与匹配表（Probed Table）-------------------------\n\t\t\t\t\t驱动表（Driving Table）：\n\t\t\t\t\t\t表连接时首先存取的表，又称外层表（Outer Table），这个概念用于 NESTED LOOPS（嵌套循环） 与 HASH JOIN（哈希连接）中；\n\t\t\t\t\t\t如果驱动表返回较多的行数据，则对所有的后续操作有负面影响，故一般选择小表（应用Where限制条件后返回较少行数的表）作为驱动表。\n\t\t\t\t\t匹配表（Probed Table）：\n\t\t\t\t\t\t又称为内层表（Inner Table），从驱动表获取一行具体数据后，会到该表中寻找符合连接条件的行。故该表一般为大表（应用Where限制条件后返回较多行数的表）。\n\t\t内部连接过程：\n\t\ta) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中\n\t\tb) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中\n\t\tc) 若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。\n\t\t   因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且\n\t\t   能高效访问 row source 2（如建立适当的索引）时，效率较高。\n\t\t\n\t\t延伸：\n\t\t嵌套循环的表有驱动顺序，注意选择合适的驱动表。嵌套循环连接有一个其他连接方式没有的好处是：\n\t\t可以先返回已经连接的行，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。\n\t\t应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在\n\t\t匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的\n\t\t非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接\n\t\t操作关联列上存在索引，连接效率也不会很高。\n\n(3)HASH JOIN（哈希连接）\n\t\t哈希连接只适用于等值连接（即连接条件为  =  ）\n\t\tHASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式；\n\t\t内部连接过程简述：\n\t\t\ta) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）\n\t\t\tb) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据\n\t\t\t\t\t\t\t\t\t\n\t----------------延伸阅读：Hash Table相关----------------\n\t来自Wiki的解释：In computing, a hash table (hash map) is a data structure used to implement an associative array, \n\ta structure that can map keys to values. A hash table uses a hash function to compute an index into an array of\n\t buckets or slots, from which the desired value can be found.散列（hash）技术：在记录的存储位置和记录具有的\n\t 关键字key之间建立一个对应关系 f ，使得输入key后，可以得到对应的存储位置 f(key)，这个对应关系 f 就是散列\n\t （哈希）函数；\n     采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间就是散列表（哈希表）；\n     不同的key经同一散列函数散列后得到的散列值理论上应该不同，但是实际中有可能相同，相同时即是发生了散列\n     （哈希）冲突，解决散列冲突的办法有很多，比如HashMap中就是用链地址法来解决哈希冲突；\n     哈希表是一种面向查找的数据结构，在输入给定值后查找给定值对应的记录在表中的位置以获取特定记录这个过程的\n     速度很快。\n\t\t\t\t\t\t\t\t\t\n\t--------------------------------------------------------\n\tHASH JOIN的三种模式：\n\t\t\ta.OPTIMAL HASH JOIN\n\t\t\tOPTIMAL 模式是从驱动表（也称Build Table）上获取的结果集比较小，可以把根据结果集构建的整个\n\t\t\tHash Table都建立在用户可以使用的内存区域里。\n\t\t\t连接过程简述：\n\t\t\t\t\tⅠ：首先对Build Table内各行数据的连接操作关联列使用Hash函数，把Build Table的结果集构建成内存中\n\t\t\t\t\t       的Hash Table。如图所示，可以把Hash Table看作内存中的一块大的方形区域，里面有很多的小格\n\t\t\t\t\t       子，Build Table里的数据就分散分布在这些小格子中，而这些小格子就是Hash Bucket（见上面Wiki的\n\t\t\t\t\t       定义）。\n\t\t\t\t\t       \n\t\t\t\t\tⅡ：开始读取匹配表（Probed Table）的数据，对其中每行数据的连接操作关联列都使用同上的Hash函\n\t\t\t\t\t       数，定位Build Table里使用Hash函数后具有相同值数据所在的Hash Bucket。\n\t\t\t\t\t       \n\t\t\t\t\tⅢ：定位到具体的Hash Bucket后，先检查Bucket里是否有数据，没有的话就马上丢掉匹配表\n\t\t\t\t\t      （Probed Table）的这一行。如果里面有数据，则继续检查里面的数据（驱动表的数据）是否和匹配表\t\t\n\t\t\t\t\t      的数据相匹配。\n\n\t\t\t\t\t\t\t\t\t\n\t\t    b.ONEPASS HASH JOIN\n\t\t\t从驱动表（也称Build Table）上获取的结果集较大，无法将根据结果集构建的Hash Table全部放入内存中时，\n\t\t\t会使用 ONEPASS 模式。\n\t\t\t连接过程简述：\n\t\t\t\t\tⅠ：对Build Table内各行数据的连接操作关联列使用Hash函数，根据Build Table的结果集构建Hash Table\n\t\t\t\t\t后，由于内存无法放下所有的Hash Table内容，将导致有的Hash Bucket放在内存里，有的Hash Bucket放\n\t\t\t\t\t在磁盘上，无论放在内存里还是磁盘里，Oracle都使用一个Bitmap结构来反映这些Hash Bucket的状态\n\t\t\t\t\t（包括其位置和是否有数据）。\n\t\t\t\t\t\n\t\t\t\t\tⅡ：读取匹配表数据并对每行的连接操作关联列使用同上的Hash函数，定位Bitmap上Build Table里使用\n\t\t\t\t\tHash函数后具有相同值数据所在的Bucket。如果该Bucket为空，则丢弃匹配表的这条数据。如果不为空，\n\t\t\t\t\t则需要看该Bucket是在内存里还是在磁盘上。 如果在内存中，就直接访问这个Bucket并检查其中的数据是\n\t\t\t\t\t否匹配，有匹配的话就返回这条查询结果。如果在磁盘上，就先把这条待匹配数据放到一边，将其先暂存\n\t\t\t\t\t在内存里，等以后积累了一定量的这样的待匹配数据后，再批量的把这些数据写入到磁盘上（上图中的 \n\t\t\t\t\tDump probe partitions to disk）。\n\t\t\t\t\t\n\t\t\t\t\tⅢ：当把匹配表完整的扫描了一遍后，可能已经返回了一部分匹配的数据了。接下来还有Hash Table中\n\t\t\t\t\t一部分在磁盘上的Hash Bucket数据以及匹配表中部分被写入到磁盘上的待匹配数据未处理，现在Oracle会\n\t\t\t\t\t把磁盘上的这两部分数据重新匹配一次，然后返回最终的查询结果。\n\n\t\t\tc.MULTIPASS HASH JOIN\n\t\t\t\t\t当内存特别小或者相对而言Hash Table的数据特别大时，会使用 MULTIPASS 模式。MULTIPASS会多次读\n\t\t\t\t\t取磁盘数据，应尽量避免使用该模式。\n\n\n(4)CARTESIAN PRODUCT（笛卡尔积）\n\t\t\t\t\t\t\n\t\t\t不做描述，尽量避免笛卡尔积的发生。\n</code></pre>\n<p>----------- 查看方式 ------------------<br/> （1）什么是执行计划<br/> SQL是一种傻瓜式语言，每一个条件就是一个需求，访问的顺序不同就形成了不同的执行计划。Oracle必须做出选择，一次只能有一种访问路径。执行计划是一条查询语句在Oracle中的执行过程或访问路径的描述。</p>\n<p>（2）执行计划的选择</p>\n<p>通常一条SQL有多个执行计划，那我们如何选择？那种执行开销更低，就意味着性能更好，速度更快，我们就选哪一种，这个过程叫做Oracle的解析过程，然后Oracle会把更好的执行计划放到SGA的Shared Pool里，后续再执行同样的SQL只需在Shared Pool里获取就行了，不需要再去分析。</p>\n<p>（3）执行计划选定依据</p>\n<p>根据统计信息来选择执行计划。</p>\n<p>（4）统计信息<br/> 什么是统计信息： 记录数、块数等，具体查看dba_tables / dba_indexes</p>\n<p>（5）动态采样</p>\n<p>Oracle正常情况下会在每天的某段时间收集统计信息，对于新建的表，Oracl如何收集统计信息？采用动态采样。<br/> set autotrace on<br/> set linesize 1000<br/> –执行SQL语句<br/> –会出现dynamic sampling used for this statement(level=2)关键</p>\n<p>(一)六种执行计划</p>\n<p>Oracle提供了6种执行计划获取方法，各种方法侧重点不同：</p>\n<p>选择时一般遵循以下规则：<br/> 1.如果sql执行很长时间才出结果或返回不了结果，用方法1：explain plan for<br/> 2.跟踪某条sql最简单的方法是方法1：explain plan for，其次是方法2：set autotrace on<br/> 3.如果相关察某个sql多个执行计划的情况，只能用方法4：dbms_xplan.display_cursor或方法6：awrsqrpt.sql<br/> 4.如果sql中含有函数，函数中有含有sql，即存在多层调用，想准确分析只能用方法5：10046追踪<br/> 5.想法看到真实的执行计划，不能用方法1：explain plan for和方法2：set autotrace on<br/> 6.想要获取表被访问的次数，只能用方法3：statistics_level = all</p>\n<p>获取方法 优点 缺点</p>\n<hr/>\n<p>[explain plan for] plsql按F5</p>\n<p>explain plan for select * from dual;</p>\n<p>select * from table(dbms_xplan.display());</p>\n<p>优点:<br/> 无需真正执行，快捷方便</p>\n<p>缺点:<br/> 1.没有输出相关统计信息，例如产生了多少逻辑读，多少次物理读，多少次递归调用的情况；<br/> 2.无法判断处理了多少行；<br/> 3.无法判断表执行了多少次</p>\n<hr/>\n<p>[set autotrace on]-sql*plus</p>\n<p>set autotrace on</p>\n<p>select * from dual;<br/> 优点:<br/> 1.可以输出运行时的相关统计信息（产生多少逻辑读、多少次递归调用、多少次物理读等）；</p>\n<p>2.虽然要等语句执行完才能输出执行计划，但是可以有traceonly开关来控制返回结果不打屏输出；</p>\n<p>缺点:<br/> 1.必须要等SQL语句执行完，才出结果；</p>\n<p>2.无法看到表被访问了多少次；</p>\n<hr/>\n<p>[statistics_level=all]</p>\n<p>alter session set statistics_level=all;</p>\n<p>select * from dual;</p>\n<p>select * from table(dbms_xplan.display_cursor(‘sql_id/hash_value’,null,‘allstats last’));</p>\n<p>优点:<br/> 1.可以清晰的从starts得出表被访问多少次；</p>\n<p>2.可以从E-Rows和A-Rows得到预测的行数和真实的行数，从而可以准确判断Oracle评估是否准确；</p>\n<p>3.虽然没有准确的输出运行时的相关统计信息，但是执行计划中的Buffers就是真实的逻辑读的数值；</p>\n<p>缺点:<br/> 1.必须要等执行完后才能输出结果；</p>\n<p>2.无法控制结果打屏输出，不像autotrace可以设置traceonly保证不输出结果；</p>\n<p>3.看不出递归调用，看不出物理读的数值</p>\n<hr/>\n<p>[dbms_xplan.display_cursor]</p>\n<p>select * from table( dbms_xplan.display_cursor(‘&amp;sql_id’) );</p>\n<p>优点:<br/> 1.知道sql_id即可得到执行计划，与explain plan for一样无需执行；</p>\n<p>2.可得到真实的执行计划</p>\n<p>缺点:<br/> 1.没有输出运行的统计相关信息；</p>\n<p>2.无法判断处理了多少行；</p>\n<p>3.无法判断表被访问了多少次；</p>\n<hr/>\n<p>[事件10046 trace]</p>\n<p>步骤1：alter session set events ‘10046 trace name context forever,level 12’; --开启追踪<br/> 步骤2：执行sql语句；<br/> 步骤3：alter session set events ‘10046 trace name context off’; --关闭追踪<br/> 步骤4：找到跟踪后产生的文件（开启10046前先用‘ls -lrt’看一下文件，执行结束后再看哪个是多出来的文件即可）<br/> 步骤5：tkprof trc文件 目标文件 sys=no sort=prsela,exeela,fchela --格式化命令</p>\n<p>优点:<br/> 1.可以看出sql语句对应的等待事件；</p>\n<p>2.如果函数中有sql调用，函数中有包含sql，将会被列出，无处遁形；</p>\n<p>3.可以方便的看处理的行数，产生的逻辑物理读；</p>\n<p>4.可以方便的看解析时间和执行时间；</p>\n<p>5.可以跟踪整个程序包</p>\n<p>缺点:<br/> 1.步骤繁琐；</p>\n<p>2.无法判断表被访问了多少次；</p>\n<p>3.执行计划中的谓词部分不能清晰的展现出来</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-05-26 19:21:25", "summary": "内容详解执行计划的常用列字段解释：基数：估计的当前操作的返回结果集行数字节：执行该步骤后返回的字节数耗费、耗费：估计的该步骤的执行成本，用于说明执行的代价，理论上越小越好该值可能与实际有出入时间：估计"}