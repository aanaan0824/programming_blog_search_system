{"blogid": "123826962", "writerAge": "码龄1年", "writerBlogNum": "63", "writerCollect": "1774", "writerComment": "406", "writerFan": "2776", "writerGrade": "4级", "writerIntegral": "1565", "writerName": "YR_T", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123826962.jpg", "writerRankTotal": "10886", "writerRankWeekly": "2227", "writerThumb": "523", "writerVisitNum": "142315", "blog_read_count": "2644", "blog_time": "已于 2022-03-30 10:22:40 修改", "blog_title": "c++桶排序(刚学也能看懂)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"> </p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%93%88%E5%96%BD%F0%9F%98%86\">哈喽😆</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E7%A9%BF%E6%A2%AD%E9%97%A8\">穿梭门</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%95%88%E6%9E%9C%F0%9F%A7%90\">效果🧐</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%F0%9F%92%A1\">桶排序是什么💡</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%F0%9F%A4%94%E5%86%8D%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4\">🤔再简单点说</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%F0%9F%91%80%E5%86%8D%E5%86%8D%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4\">👀再再简单点说</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E7%A1%AE%E5%AE%9A%E2%80%9C%E5%88%86%E6%A1%B6%E2%80%9D%E4%B8%AA%E6%95%B0%F0%9F%94%8D\">确定“分桶”个数🔍</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%F0%9F%98%90\">复杂度分析😐</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#c%2B%2B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">c++代码实现</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#python%E7%89%88%E4%BB%A3%E7%A0%81%28%E5%98%BF%E5%98%BF%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E5%90%A7%29\">python版代码(嘿嘿，没想到吧)</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%9C%80%E5%90%8E\">最后</a></p>\n<hr/>\n<p> </p>\n<h1>哈喽😆</h1>\n<p>这次来发一下桶排序，它的时间复杂度低，代码也不难</p>\n<h1>穿梭门</h1>\n<p><a href=\"https://blog.csdn.net/m0_64036070/article/details/123804075?utm_source=app&amp;app_version=5.3.0\" title=\"二分算法\">二分算法</a></p>\n<p><a href=\"https://blog.csdn.net/m0_64036070/article/details/123770678?utm_source=app&amp;app_version=5.3.0\" title=\"堆排序\">堆排序</a></p>\n<h1>效果🧐</h1>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\c18ee5d2e3d643e8b1a2c4703de5444c.png\"/></p>\n<p>就是排序</p>\n<p>所以说，还是比较简单滴 </p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\45c01775f2954648a65378d9ee1ddce7.png\"/></p>\n<h1>桶排序是什么💡</h1>\n<blockquote>\n<p>桶排序是计数排序的升级版，也是分治算法。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：<strong>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。简言之，将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</strong><br/> 怎么样，是不是很“简单”？                  </p>\n</blockquote>\n<p>还有这张一看就头疼的图</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\791166833ec54015845660c445e020c1.png\"/></p>\n<p> </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\734a8e7d1fa0465aa07d5e7242b0bc1c.png\"/>                       </p>\n<p> 🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔</p>\n<h1>🤔再简单点说</h1>\n<p>桶排序的基本思想是假设数据在[min,max]之间均匀分布，其中min、max分别指数据中的最小值和最大值。那么将区间[min,max]等分成n份，这n个区间便称为n个桶。将数据加入对应的桶中，然后每个桶内单独排序。由于桶之间有大小关系，因此可以从大到小(或从小到大)将桶中元素放入到数组中。</p>\n<h1>👀再再简单点说</h1>\n<p>简单说，你有一个数组1 , 3 , 7 , 77 ，100 ，234</p>\n<p>比如，</p>\n<p>你把一位数、两位数和三位数分到3个桶里，</p>\n<p>各自排完序再合到一起</p>\n<p>排序前：1 , 3 , 7 , 77 ，100 ，234</p>\n<p>一位数：1、7、3</p>\n<p>两位数：77</p>\n<p>三位数：100、234</p>\n<p>排序后：</p>\n<p>一位数：1、3、7</p>\n<p>两位数：77</p>\n<p>三位数：100、234</p>\n<p>合起来：1、3、7、77、100、234 </p>\n<h1>思路</h1>\n<p><strong>1.</strong><em>设置一个定量的数组当作空桶子。</em><br/><strong>2</strong>.<em>寻访序列，并且把项目一个一个放到对应的桶子去。</em><br/><strong>3.</strong><em>对每个非空的桶子进行排序。</em><br/><strong>4.</strong><em>从不是空的桶子里把项目再放回原来的序列中。</em></p>\n<h1>确定“分桶”个数🔍<br/>  </h1>\n<p>假如要对数组arr={ 2,0,1,6,8,10,5,99,87,333,2,0,1 }排序，假设需要桶的个数为bucketNum=std::ceil(size/3)，向上取整，反之桶个数不够映射时越界。</p>\n<h1>复杂度分析😐</h1>\n<p><br/> 桶排序实际上只需要遍历一遍所有的待排序元素，然后依次放入指定的位置，如果加上输出排序的时间，那么需要遍历所有的桶，时间复杂度为O(n+m)，其中n为待排序元素的个数，m为桶的个数，这时相当快的排序算法，但是，对于空间的小号来说太大了。当n越大，空间浪费就越大，所以，如果数据跨度过大，桶排序并不适用跨度范围大的排序。</p>\n<h1>c++代码实现</h1>\n<p>直接放代码，如果你报错了，就把前面的万能头文件改了</p>\n<p>c++版(devc++无报错无警告)</p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 打印数组\nvoid print_array(int *arr, int n) {\n    if(n==0){\n        printf(\"ERROR: Array length is ZERO\\n\");\n        return;\n    }\n    printf(\"%d\", arr[0]);\n    for (int i=1; i&lt;n; i++) \n        printf(\" %d\", arr[i]);\n    printf(\"\\n\");\n}\n\n\nint* sort_array(int *arr, int n) {\n    int i;\n\tint maxValue = arr[0];\n\tfor (i = 1; i &lt; n; i++) \n\t\tif (arr[i] &gt; maxValue)  // 输入数据的最大值\n\t\t\tmaxValue = arr[i]; \n\t\n\t// 设置10个桶，依次0，1，，，9\n\tconst int bucketCnt = 10;\n\tvector&lt;int&gt; buckets[bucketCnt];\n\t// 桶的大小bucketSize根据数组最大值确定：比如最大值99， 桶大小10\n\t// 最大值999，桶大小100\n\t// 根据最高位数字映射到相应的桶，映射函数为 arr[i]/bucketSize\n\tint bucketSize = 1;\n\twhile (maxValue) {\t\t//求最大尺寸 \n\t\tmaxValue /= 10;\n\t\tbucketSize *= 10;\n\t}\n\tbucketSize /= 10;\t\t//桶的个数 \n\t// 入桶\n\tfor (int i=0; i&lt;n; i++) {\n\t\tint idx = arr[i]/bucketSize;\t\t\t//放入对应的桶 \n\t\tbuckets[idx].push_back(arr[i]);\n\t\t// 对该桶使用插入排序(因为数据过少，插入排序即可)，维持该桶的有序性\n\t\tfor (int j=int(buckets[idx].size())-1; j&gt;0; j--) {\n\t\t\tif (buckets[idx][j]&lt;buckets[idx][j-1]) {\n\t\t\t\tswap(buckets[idx][j], buckets[idx][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t// 顺序访问桶，得到有序数组\n\tfor (int i=0, k=0; i&lt;bucketCnt; i++) {\n\t\tfor (int j=0; j&lt;int(buckets[i].size()); j++) {\n\t\t\tarr[k++] = buckets[i][j];\n\t\t}\n\t}\n\treturn arr;\n}\n\n\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    \n    int *arr;\n    arr = (int*)malloc(sizeof(int)*n);\n    \n    for (int i=0; i&lt;n; i++) scanf(\"%d\", &amp;arr[i]);\n    \n    arr = sort_array(arr, n);\n    \n    print_array(arr, n);\n    \n    system(\"pause\"); \n    return 0;\n}\n</code></pre>\n<h1>python版代码(嘿嘿，没想到吧)</h1>\n<pre><code class=\"language-python\">def bucketSort(nums):\n    # 选择一个最大的数\n    max_num = max(nums)\n    # 创建一个元素全是0的列表, 当做桶\n    bucket = [0]*(max_num+1)\n    # 把所有元素放入桶中, 即把对应元素个数加一\n    for i in nums:\n        bucket[i] += 1\n \n    # 存储排序好的元素\n    sort_nums = []\n    # 取出桶中的元素\n    for j in range(len(bucket)):\n        if bucket[j] != 0:\n            for y in range(bucket[j]):\n                sort_nums.append(j)\n \n    return sort_nums\n \nnums = [5,6,3,2,1,65,2,0,8,0]\nprint bucketSort(nums)\n \n\"\"\"\n[0, 0, 1, 2, 2, 3, 5, 6, 8, 65]\n\"\"\"</code></pre>\n<h1>最后</h1>\n<p>今天想给大家推荐一本书</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\b40e74529fe744c2949daaf0646b0dbf.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWVJfVA==,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\896a242d5dcb41e4ac662ad2f6a9c738.png\"/></p>\n<p> </p>\n<p> 互粉必回！   白白👋</p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n</div>\n</div>", "first_tag": "Python", "cpp": 1, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-30 10:22:40", "summary": "目录哈喽穿梭门效果桶排序是什么再简单点说再再简单点说思路确定分桶个数复杂度分析代码实现版代码嘿嘿，没想到吧最后哈喽这次来发一下桶排序，它的时间复杂度低，代码也不难穿梭门二分算法二分算法堆排序堆排序效果"}