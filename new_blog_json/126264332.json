{"blogid": "126264332", "writerAge": "码龄1年", "writerBlogNum": "324", "writerCollect": "1813", "writerComment": "1575", "writerFan": "4544", "writerGrade": "6级", "writerIntegral": "8460", "writerName": "十八岁讨厌编程", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126264332.jpg", "writerRankTotal": "1956", "writerRankWeekly": "29", "writerThumb": "1980", "writerVisitNum": "131355", "blog_read_count": "350", "blog_time": "于 2022-09-07 10:21:48 发布", "blog_title": "[SpringBoot系列]进阶配置", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_1\">临时属性设置</a></li><li><ul><li><a href=\"#_19\">属性加载优先级</a></li><li><a href=\"#_43\">开发环境中使用临时属性</a></li></ul>\n</li><li><a href=\"#_93\">配置文件分类</a></li><li><a href=\"#_130\">自定义配置文件</a></li><li><a href=\"#ConfigurationProperties_163\">@ConfigurationProperties</a></li><li><a href=\"#_277\">宽松绑定/松散绑定</a></li><li><a href=\"#_361\">常用计量单位绑定</a></li><li><a href=\"#_408\">校验</a></li><li><a href=\"#_468\">数据类型转换</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>临时属性设置</h1>\n<p>目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\469c404e241341f4b046b143b3b424be.png\"/><br/> SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p>\n<pre><code class=\"prism language-JAVA\">java –jar springboot.jar –-server.port=80\n</code></pre>\n<p>​ 上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个<code>-</code>号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，<mark>这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同</mark>。</p>\n<p>​ 如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p>\n<pre><code class=\"prism language-JAVA\">java –jar springboot.jar –-server.port=80 --logging.level.root=debug\n</code></pre>\n<h2><a id=\"_19\"></a>属性加载优先级</h2>\n<p>现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。</p>\n<blockquote>\n<p>地址：<a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html\">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e8c37cf56c1a4fac9dc3332e0657caa0.png\"/></p>\n<p>​ 我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。</p>\n<p>​ 比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。</p>\n<blockquote>\n<p>在yaml中配置了user.name属性值，然后读取出来的时候不是自己的配置值，这是因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。</p>\n</blockquote>\n<p><strong>总结</strong></p>\n<ol><li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li><li>临时属性添加方式：java –jar 工程名.jar –-属性名=值</li><li>多个临时属性之间使用空格分隔</li><li>临时属性必须是当前boot工程支持的属性，否则设置无效</li></ol>\n<h2><a id=\"_43\"></a>开发环境中使用临时属性</h2>\n<p>临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。</p>\n<p>打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6b7e7af11d494a60a201c091a35b14bd.png\"/></p>\n<blockquote>\n<p>这个东西在如下地方：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1afed231a6714c9bb9dda04e02651bdc.png\"/></p>\n</blockquote>\n<p>然后我们运行一下main方法验证结果：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5ec597b0b66849d282f335d8280a578c.png\"/><br/> 如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 原来是这样，通过这个args就可以获取到参数。我们可以验证一下：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\577eb850ee884ca7a5f24f6b530f8671.png\"/><br/> 运行之后结果：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3b23d4a8786f44d7bf447c8216793225.png\"/></p>\n<p>再来看我们的引导类是如何书写的</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SSMPApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，<strong>我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了</strong>。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SSMPApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>总结</strong></p>\n<ol><li>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</li></ol>\n<h1><a id=\"_93\"></a>配置文件分类</h1>\n<p>SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这里我们说说配置文件。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：</p>\n<ul><li>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</li><li>类路径下config目录下配置文件</li><li>程序包所在目录中配置文件</li><li>程序包所在目录中config目录下配置文件</li></ul>\n<p>好复杂，一个一个说。<mark>其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的</mark>。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，<mark>说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题</mark>。上面4个文件的加载优先顺序为</p>\n<ol><li>file ：config/application.yml <strong>【最高】</strong></li><li>file ：application.yml</li><li>classpath：config/application.yml</li><li>classpath：application.yml <strong>【最低】</strong></li></ol>\n<p>​那为什么设计这种多种呢？说一个最典型的应用吧。</p>\n<ul><li>场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。</li><li>场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li><li>场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li></ul>\n<p>​ 解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？</p>\n<p>​ 级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p>\n<p><strong>总结</strong></p>\n<ol><li> <p>配置文件分为4种</p>\n<ul><li>项目类路径配置文件：服务于开发人员本机开发与测试</li><li>项目类路径config目录中配置文件：服务于项目经理整体调控</li><li>工程路径配置文件：服务于运维人员配置涉密线上环境</li><li>工程路径config目录中配置文件：服务于运维经理整体调控</li></ul> </li><li> <p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p> </li></ol>\n<h1><a id=\"_130\"></a>自定义配置文件</h1>\n<p>​ 之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。</p>\n<p>​ 自定义配置文件方式有如下两种：</p>\n<p><strong>方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4a9ceba08b504759935ff2194768fb13.png\"/></p>\n<p><strong>方式二：使用临时属性设置配置文件路径，这个是全路径名</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4ef7deef8c254883b36b42c56d7a9570.png\"/></p>\n<p>​ 也可以设置加载多个配置文件</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ded3361c304d4a3ba2ff8b4efbd4b22a.png\"/></p>\n<p>​ 使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。</p>\n<p><font color=\"#f0f\"><b>温馨提示</b></font></p>\n<p>​ 我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在所说的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。<strong>这样做就是为了集中管理</strong>。</p>\n<p><strong>总结</strong></p>\n<ol><li>配置文件可以修改名称，通过启动参数设定</li><li>配置文件可以修改路径，通过启动参数设定</li><li>微服务开发中配置文件通过配置中心进行设置</li></ol>\n<h1><a id=\"ConfigurationProperties_163\"></a>@ConfigurationProperties</h1>\n<p>@ConfigurationProperties 注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性</p>\n<pre><code class=\"prism language-yml\"><span class=\"token key atrule\">servers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">ip-address</span><span class=\"token punctuation\">:</span> 192.168.0.1 \n  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2345</span>\n  <span class=\"token key atrule\">timeout</span><span class=\"token punctuation\">:</span> <span class=\"token number\">-1</span>\n</code></pre>\n<p>​ 然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@Data</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> ipAddress<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@Data</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"servers\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> ipAddress<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。</p>\n<p>​ 使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。</p>\n<p><strong>步骤①</strong>：使用@Bean注解定义第三方bean</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">DruidDataSource</span> <span class=\"token function\">datasource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">DruidDataSource</span> ds <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DruidDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ds<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>步骤②</strong>：在yml中定义要绑定的属性，注意datasource此时全小写</p>\n<pre><code class=\"prism language-yaml\"><span class=\"token key atrule\">datasource</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">driverClassName</span><span class=\"token punctuation\">:</span> com.mysql.jdbc.Driver\n</code></pre>\n<p><strong>步骤③</strong>：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"datasource\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">DruidDataSource</span> <span class=\"token function\">datasource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">DruidDataSource</span> ds <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DruidDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ds<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。</p>\n<p>​ 做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？</p>\n<p><strong>步骤①</strong>：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@SpringBootApplication</span>\n<span class=\"token annotation punctuation\">@EnableConfigurationProperties</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServerConfig</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Springboot13ConfigurationApplication</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>步骤②</strong>：在对应的类上直接使用@ConfigurationProperties进行属性绑定</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Data</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"servers\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> ipAddress<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。<strong>当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了</strong>。</p>\n<p>​ 最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\266e12a0b08c47edaa2e7c87f0b60ecb.png\"/></p>\n<p>​ 出现这个提示后只需要添加一个坐标此提醒就消失了</p>\n<pre><code class=\"prism language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-boot-configuration-processor<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre>\n<p><strong>总结</strong></p>\n<ol><li>使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性</li><li><strong>当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明</strong></li></ol>\n<h1><a id=\"_277\"></a>宽松绑定/松散绑定</h1>\n<p>在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：</p>\n<pre><code class=\"prism language-yaml\"><span class=\"token key atrule\">dataSource</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">driverClassName</span><span class=\"token punctuation\">:</span> com.mysql.jdbc.Driver\n</code></pre>\n<p>​ 此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"dataSource\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">DruidDataSource</span> <span class=\"token function\">datasource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">DruidDataSource</span> ds <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DruidDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ds<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的</p>\n<pre><code class=\"prism language-CMD\">Configuration property name 'dataSource' is not valid:\n\n    Invalid characters: 'S'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify 'dataSource' so that it conforms to the canonical names requirements.\n</code></pre>\n<p>​ 为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的松散绑定，也可以称为宽松绑定。</p>\n<p>​ 什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：</p>\n<p>​ 在ServerConfig中的ipAddress属性名</p>\n<pre><code class=\"prism language-JAVA\">@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n}\n</code></pre>\n<p>​ 可以与下面的配置属性名规则全兼容</p>\n<pre><code class=\"prism language-YML\">servers:\n  ipAddress: 192.168.0.2       # 驼峰模式\n  ip_address: 192.168.0.2      # 下划线模式\n  ip-address: 192.168.0.2      # 烤肉串模式\n  IP_ADDRESS: 192.168.0.2      # 常量模式\n</code></pre>\n<p>​ 也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。</p>\n<p>​ 到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息</p>\n<pre><code class=\"prism language-CMD\">Configuration property name 'dataSource' is not valid:\n\n    Invalid characters: 'S'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify 'dataSource' so that it conforms to the canonical names requirements.\n</code></pre>\n<p>​ 其中Reason描述了报错的原因，<strong>规范的（前缀）名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头</strong>。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。</p>\n<blockquote>\n<p>​ <mark>以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效</mark>。</p>\n</blockquote>\n<p><strong>总结</strong></p>\n<ol><li>@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上</li><li>@Value注解不支持松散绑定规则</li><li>绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符</li></ol>\n<h1><a id=\"_361\"></a>常用计量单位绑定</h1>\n<p>​ 在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。</p>\n<pre><code class=\"prism language-yml\"><span class=\"token key atrule\">servers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">ip-address</span><span class=\"token punctuation\">:</span> 192.168.0.1 \n  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2345</span>\n  <span class=\"token key atrule\">timeout</span><span class=\"token punctuation\">:</span> <span class=\"token number\">-1</span>\n</code></pre>\n<p>​ 但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？</p>\n<p>​ 除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@Data</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"servers\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token annotation punctuation\">@DurationUnit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ChronoUnit</span><span class=\"token punctuation\">.</span>HOURS<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Duration</span> serverTimeOut<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@DataSizeUnit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DataUnit</span><span class=\"token punctuation\">.</span>MEGABYTES<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">DataSize</span> dataSize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><strong>Duration</strong>：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）</p>\n<p><strong>DataSize</strong>：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）</p>\n<p>​ 使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。</p>\n<p>Druation常用单位如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6cb731e624654dbcb7d8426f9b778895.png\"/></p>\n<p>DataSize常用单位如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8fa87075bff342ebad86540fa0b81497.png\"/></p>\n<blockquote>\n<p><strong>在我们的yml等配置文件其实可以直接带单位</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4476b98053e04da88f90884b9e29fc58.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cddb0cf0063044b59147d9393bc3e524.png\"/></p>\n</blockquote>\n<h1><a id=\"_408\"></a>校验</h1>\n<p>目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a\"，这种数据肯定无法有效的绑定，还会引发错误。 SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤</p>\n<p><strong>步骤①</strong>：开启校验框架</p>\n<pre><code class=\"prism language-xml\"><span class=\"token comment\">&lt;!--1.导入JSR303规范--&gt;</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>javax.validation<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>validation-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token comment\">&lt;!--使用hibernate框架提供的校验器做实现--&gt;</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.hibernate.validator<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>hibernate-validator<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre>\n<p><strong>步骤②</strong>：在需要开启校验功能的类上使用注解@Validated开启校验功能</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@Data</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"servers\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//开启对当前bean的属性注入校验</span>\n<span class=\"token annotation punctuation\">@Validated</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>步骤③</strong>：对具体的字段设置校验规则</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@Data</span>\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"servers\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//开启对当前bean的属性注入校验</span>\n<span class=\"token annotation punctuation\">@Validated</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//设置具体的规则</span>\n    <span class=\"token annotation punctuation\">@Max</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token number\">8888</span><span class=\"token punctuation\">,</span>message <span class=\"token operator\">=</span> <span class=\"token string\">\"最大值不能超过8888\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@Min</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token number\">202</span><span class=\"token punctuation\">,</span>message <span class=\"token operator\">=</span> <span class=\"token string\">\"最小值不能低于202\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​ 通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。</p>\n<p>现在我们把port设为9999来试一下：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cd8b582d5d9748358eba94888ede29ca.png\"/><br/> 结果：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\40603ee6b1a64c0fa159658ab8467b0f.png\"/></p>\n<p><strong>总结</strong></p>\n<ol><li>开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式</li></ol>\n<h1><a id=\"_468\"></a>数据类型转换</h1>\n<p>如果我现在有一个密码0127，这在springboot的yml文件中是八进制的表达形式。所以，如果我们不加引号它会转换为八进制。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3c74955e958b495791de09fe80bc8fc0.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f4191a3b920a4788b45a46e9d02d261e.png\"/><br/> 我们在说属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，<strong>支持二进制，八进制，十六进制</strong>：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\334321ce475c4341b9b5e245e1bcc120.png\"/><br/> 而<strong>八进制数正好以0开头</strong>，这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先按照整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。</p>\n<p>所以今后我们要注意：</p>\n<ul><li>字符串标准书写加上引号包裹</li><li>遇到0开头的数据多注意</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-09-07 10:21:48", "summary": "文章目录临时属性设置属性加载优先级开发环境中使用临时属性配置文件分类自定义配置文件宽松绑定松散绑定常用计量单位绑定校验数据类型转换临时属性设置目前我们的程序包打好了，可以发布了。但是程序包打好以后，里"}