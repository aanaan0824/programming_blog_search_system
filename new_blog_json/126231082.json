{"blogid": "126231082", "writerAge": "码龄1年", "writerBlogNum": "21", "writerCollect": "129", "writerComment": "66", "writerFan": "706", "writerGrade": "3级", "writerIntegral": "416", "writerName": "晋升阁", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126231082.jpg", "writerRankTotal": "36641", "writerRankWeekly": "2658", "writerThumb": "136", "writerVisitNum": "489316", "blog_read_count": "25000", "blog_time": "已于 2022-09-04 01:00:08 修改", "blog_title": "python写的 自定义连点器 的开发全过程（抢票、信息轰炸等、游戏连招等）——思路及解析【内附完整源码】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><span style=\"color:#4da8ee;\">前些天留意到我妈一直在预约四价疫苗都约不上，就想着写个程序来模拟人的操作去点击，判断疫苗是否被抢完，无限循环去刷新这个页面，一旦疫苗可预约就立马抢下来选择时间接种人。当预约成功后就语音循环播报：已经抢到，赶紧过来看一下。</span></p>\n<p>基于以上的想法和需求，我花了半小时编辑了以下代码，并在一小时内成功预约。</p>\n<pre><code class=\"language-python\">import pyautogui\nfrom ctypes import *  # 获取屏幕上某个坐标的颜色\nfrom time import sleep\nimport time\n\nstart = time.time()\ndef get_color(x, y):\n    gdi32 = windll.gdi32\n    user32 = windll.user32\n    hdc = user32.GetDC(None)  # 获取颜色值\n    pixel = gdi32.GetPixel(hdc, x, y)  # 提取RGB值\n    r = pixel &amp; 0x0000ff\n    g = (pixel &amp; 0x00ff00) &gt;&gt; 8\n    b = pixel &gt;&gt; 16\n    return [r, g, b]\nprint(get_color(297,454))\nwhile True:\n    if get_color(240 , 255) == [60,211,180] or get_color(247,255) == [60,211,180] or get_color(253,255) == [60,211,180] or get_color(260,255) == [60,211,180] or get_color(270,255) == [60,211,180] or get_color(280,255) == [60,211,180] or get_color(290 ,255) == [60,211,180] or get_color(300 ,255) == [60,211,180] or get_color(310,255) == [60,211,180] or get_color(320, 255) == [60,211,180]:\n        pyautogui.click(310,255)#点进去抢\n        sleep(0.5)\n        pyautogui.click(467,262)#选择预约时间\n        while True:\n            if get_color(297,454) == [0,142,255]:\n                break\n            else:\n                sleep(0.3)\n        sleep(0.5)\n        pyautogui.click(498,454)#点击下午\n        sleep(0.5)\n        pyautogui.click(467,520)#选择时间\n        sleep(0.5)\n        pyautogui.click(470,899)#点选好了\n        sleep(0.5)\n        pyautogui.click(470, 899)#点立即预约\n        #sleep()\n        break\n    else:\n        pyautogui.click(123,60)\n        sleep(0.8)#刷新\nprint('总耗时：'.format(time.time()-start))\nprint(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))\nwhile 1:\n    import pyttsx3\n    engine = pyttsx3.init()\n    engine.say('我抢到了!快来看一下')\n    engine.runAndWait()\n    sleep(1)</code></pre>\n<p>实现思路大致流程图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"369\" src=\"..\\..\\static\\image\\efefcd33905f4f679da92ce617d8bc19.jpeg\" width=\"262\"/></p>\n<p><span style=\"color:#fe2c24;\">可以看到逻辑非常简单即可实现我想要的功能，不过即使是这样，我也花了差不多半小时的时间来编写代码。于是我就在想，要是以后我要开发抢票、技能连招啊、信息轰炸朋友啊等等的功能，是不是也要这么多时间呢，那我能不能自己造轮子来快速帮助我开发我想要的脚本呢。</span></p>\n<p style=\"text-align:center;\"><strong>至此，此章的内容正式开始了。</strong></p>\n<p style=\"text-align:center;\">我将一步一步带着读者来开发这个快速开发自定义连点器的程序（有一点点拗口）</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%3A-toc\" style=\"margin-left:0px;\"><strong><a href=\"#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%3A\">整体思路:</a></strong></p>\n<p id=\"%E6%89%80%E6%9C%89%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:0px;\"><strong><a href=\"#%E6%89%80%E6%9C%89%E5%8A%9F%E8%83%BD\">所有功能</a></strong></p>\n<p id=\"%E7%AE%80%E5%8D%95%E6%BC%94%E7%A4%BA-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E7%AE%80%E5%8D%95%E6%BC%94%E7%A4%BA\">简单演示</a></strong></p>\n<p id=\"%E7%82%B9%E5%87%BB%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E7%82%B9%E5%87%BB%E5%8A%9F%E8%83%BD\">点击功能</a></strong></p>\n<p id=\"%C2%A0%E7%82%B9%E5%87%BB%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0%E7%82%B9%E5%87%BB%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"> 点击功能代码如下：</a></strong></p>\n<p id=\"%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A\">执行时的逻辑：</a></strong></p>\n<p id=\"%E5%BB%B6%E6%97%B6%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E5%BB%B6%E6%97%B6%E5%8A%9F%E8%83%BD\">延时功能</a></strong></p>\n<p id=\"%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A%C2%A0-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A%C2%A0\">执行时的逻辑： </a></strong></p>\n<p id=\"%E8%BF%9E%E7%82%B9%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E8%BF%9E%E7%82%B9%E5%8A%9F%E8%83%BD\">连点功能</a></strong></p>\n<p id=\"%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A\">执行时的逻辑：</a></strong></p>\n<p id=\"%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD\">存储功能</a></strong></p>\n<p id=\"%E8%AF%BB%E5%8F%96%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E8%AF%BB%E5%8F%96%E5%8A%9F%E8%83%BD\">读取功能</a></strong></p>\n<p id=\"%E5%AD%98%E5%82%A8%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E3%80%90%E5%8D%87%E7%BA%A7%E7%89%88%E3%80%91%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E5%AD%98%E5%82%A8%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E3%80%90%E5%8D%87%E7%BA%A7%E7%89%88%E3%80%91%EF%BC%9A\">存储导入功能【升级版】</a></strong></p>\n<p id=\"%E5%AF%BC%E5%85%A5%EF%BC%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%AF%BC%E5%85%A5%EF%BC%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A\">导入（功能实现）</a></strong></p>\n<p id=\"%E5%AF%BC%E5%85%A5%EF%BC%88%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%89%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%AF%BC%E5%85%A5%EF%BC%88%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%89%EF%BC%9A\">导入（逻辑代码）</a></strong></p>\n<p id=\"%E5%AD%98%E5%82%A8%EF%BC%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%AD%98%E5%82%A8%EF%BC%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A\">存储（功能实现）</a></strong></p>\n<p id=\"%E5%AD%98%E5%82%A8%EF%BC%88%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%89%20%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%AD%98%E5%82%A8%EF%BC%88%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%89%20%EF%BC%9A\">存储（逻辑代码） </a></strong></p>\n<p id=\"%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%EF%BC%9A%C2%A0-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%EF%BC%9A%C2%A0\">拖拽功能</a></strong></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A\">功能实现</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A%C2%A0-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A%C2%A0\">逻辑代码：</a></strong></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A\">功能实现</a></strong></p>\n<p id=\"%C2%A0%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\"> 逻辑代码</a></strong></p>\n<p id=\"%E5%8F%B3%E5%87%BB%E3%80%81%E4%B8%AD%E5%87%BB%E3%80%81%E5%8F%8C%E5%87%BB%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E5%8F%B3%E5%87%BB%E3%80%81%E4%B8%AD%E5%87%BB%E3%80%81%E5%8F%8C%E5%87%BB%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\">右击、中击、双击功能的实现</a></strong></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A\">功能实现</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">逻辑代码</a></strong></p>\n<p id=\"%E6%8C%89%E9%94%AE%E5%8A%9F%E8%83%BD%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E6%8C%89%E9%94%AE%E5%8A%9F%E8%83%BD%EF%BC%9A\">按键功能</a></strong></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A\">功能实现</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">逻辑代码</a></strong></p>\n<p id=\"%E6%BB%9A%E5%8A%A8%E6%BB%9A%E8%BD%AE%E5%8A%9F%E8%83%BD%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E6%BB%9A%E5%8A%A8%E6%BB%9A%E8%BD%AE%E5%8A%9F%E8%83%BD%EF%BC%9A\">滚动滚轮功能</a></strong></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A\">功能实现</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">逻辑代码</a></strong></p>\n<p id=\"%E6%9F%A5%E7%9C%8B%E5%8A%9F%E8%83%BD%EF%BC%9A%C2%A0-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E6%9F%A5%E7%9C%8B%E5%8A%9F%E8%83%BD%EF%BC%9A%C2%A0\">查看功能</a></strong></p>\n<p id=\"%C2%A0%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%C2%A0%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD%EF%BC%9A\"> 执行功能</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E6%9D%BF%E5%9D%97%EF%BC%9A-toc\" style=\"margin-left:0px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E6%9D%BF%E5%9D%97%EF%BC%9A\">逻辑判断功能板块</a></strong></p>\n<p id=\"%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD\">判断功能</a></strong></p>\n<p id=\"%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">判断功能的逻辑代码</a></strong></p>\n<p id=\"%C2%A0%E9%80%BB%E8%BE%91%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:40px;\"><strong><a href=\"#%C2%A0%E9%80%BB%E8%BE%91%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\"> 逻辑执行功能的实现</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E5%9D%97%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E5%9D%97%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\">逻辑块存储功能的实现</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E5%9D%97%E5%AD%98%E5%82%A8%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E5%9D%97%E5%AD%98%E5%82%A8%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">逻辑块存储逻辑代码</a></strong></p>\n<p id=\"%E9%80%BB%E8%BE%91%E5%9D%97%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%E9%80%BB%E8%BE%91%E5%9D%97%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0\">逻辑块导入功能的实现</a></strong></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:0px;\"><strong><a href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span style=\"color:#956fe7;\">完整代码</span></a></strong></p>\n<hr/>\n<h1 id=\"%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%3A\">整体思路:</h1>\n<p><span style=\"color:#fe2c24;\">一般需要的功能有：点击、延时、连点、拖拽。一般这四个功能就能完成绝大多数的简单的辅助脚本开发了，但我想做得稍微高级一点，功能多一点，就想另外开发：循环、判断、模拟按键、文本输入、存储操作、读取操作的功能。</span></p>\n<p><strong>那么我们就要朝着我们想要实现的九大功能来开发：循环、点击、延时、连点、拖拽、判断、模拟按键、文本输入、存储操作、读取操作。</strong></p>\n<p><span style=\"color:#ff9900;\">首先就是希望我的每一步操作都会被程序记录下来并执行，我们可以定义一个列表来存储每一个操作，列表中的每一个元素就是每一步的操作，然后遍历这个列表来读取并执行每一个操作就可以将一整个操作全部执行。</span></p>\n<p><span style=\"color:#ff9900;\">当我的每一步操作都输入完毕后，我都希望程序能自动帮我把程序存储下来方便我下一次使用，这样下次使用就不用再编译多一次了。</span></p>\n<p><span style=\"color:#ff9900;\">每一个列表的第0项就是需要操作的功能，第0项之后都是各种参数。</span></p>\n<h1 id=\"%E6%89%80%E6%9C%89%E5%8A%9F%E8%83%BD\"><span style=\"color:#0d0016;\">所有功能</span></h1>\n<h2 id=\"%E7%AE%80%E5%8D%95%E6%BC%94%E7%A4%BA\"><span style=\"color:#0d0016;\">简单演示</span></h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\f8d09feac34848f6b3040add6fc832a4.jpeg\"/></p>\n<p></p>\n<h2 id=\"%E7%82%B9%E5%87%BB%E5%8A%9F%E8%83%BD\">点击功能</h2>\n<p>要想电脑帮我们点击，首先要告诉电脑我要点击的位置在哪里。想要获取鼠标位置就需要用到pyautogui库，这个库下有个position()方法可以返回鼠标位置的X坐标，Y坐标。</p>\n<p>也可以参考一下我之前的文章：<a href=\"https://blog.csdn.net/m0_62814033/article/details/124380921?spm=1001.2014.3001.5501\" title=\"实时获取鼠标位置_晋升阁的博客-CSDN博客_实时显示鼠标坐标\">实时获取鼠标位置_晋升阁的博客-CSDN博客_实时显示鼠标坐标</a></p>\n<h3>定义获取位置函数</h3>\n<pre><code class=\"language-python\">import pyautogui\ndef get_xy():\n    x, y = pyautogui.position()\n    return [x,y]</code></pre>\n<p><span style=\"color:#956fe7;\">用面向对象思想来简化程序，提高代码复用率，使程序可读性更高，是python开发的重要思想之一哦</span></p>\n<p>pyautogui库还有非常多常见功能，感兴趣的可以翻看我之前写的博客：<a href=\"https://blog.csdn.net/m0_62814033/article/details/124121870?spm=1001.2014.3001.5501\" title=\"像selenium一样操作电脑，保姆式教学——速成篇_晋升阁的博客-CSDN博客\">像selenium一样操作电脑，保姆式教学——速成篇_晋升阁的博客-CSDN博客</a></p>\n<h3 id=\"%C2%A0%E7%82%B9%E5%87%BB%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"> 点击功能代码如下</h3>\n<pre><code class=\"language-python\">step=[]\nwhile True:\n    choose = input('请输入你需要使用的功能：')\n    if choose == '点击':\n        click = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click.append('点击')\n                click.append(click_weizhi)\n                step.append(click)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')</code></pre>\n<h3 id=\"%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A\">执行时的逻辑：</h3>\n<pre><code class=\"language-python\">            for i in step1:\n                if i[0] == '点击':\n                    x = int(i[1][0])\n                    y = int(i[1][1])\n                    print(f'{x},{y}')\n                    pyautogui.click(x,y)</code></pre>\n<p><span style=\"color:#fe2c24;\">记录点击需要记录点击功能、位置参数生成一个列表，然后将列表append到step总列表中去</span></p>\n<h2 id=\"%E5%BB%B6%E6%97%B6%E5%8A%9F%E8%83%BD\">延时功能</h2>\n<p>使用到了python内置库中的time模块，可以使程序强制停止相应时间。将参数生成列表append到step总列表中去</p>\n<pre><code class=\"language-python\">if choose =='延时':\n    while 1:\n        timerr = []\n        try:\n            timex = int(input('请输入延时时间：'))\n            timerr.append('延时')\n            timerr.append(timex)\n            step.append(timerr)\n            break\n        except:\n            print('延时失败/n请输入正确的延时时间')\n            continue</code></pre>\n<h3 id=\"%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9A%C2%A0\">执行时的逻辑： </h3>\n<pre><code class=\"language-python\">def timer(timex):\n    time.sleep(timex)\nif i[0] == '延时':\n    t = int(i[1])\n    timer(t)</code></pre>\n<h2 id=\"%E8%BF%9E%E7%82%B9%E5%8A%9F%E8%83%BD\">连点功能</h2>\n<p> 有些简单的页面可以通过连点来实现抢票等功能，这个功能必不可少</p>\n<p>记录这个动作的必要参数有连点功能记录、点击频率参数、通过连点次数完成动作还是通过连点时长完成动作。</p>\n<p>同样是调用了获取鼠标位置的函数，</p>\n<pre><code class=\"language-python\">if choose == '连点':\n    click_liandian = []\n    while 1:\n        click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n        if click_dongzuo == '1':\n            click_weizhi = get_xy()\n            click_liandian.append('连点')\n            click_liandian.append(click_weizhi)\n            break\n        elif click_dongzuo == '0':\n            print('操作已取消')\n            break\n        else:\n            print('请输入正确的操作（输入“0”或“1”')\n    click_pinlv = float(input('请输入连点频率：'))\n    while 1:\n        click_stop_choose = input('“连点次数”or“连点时长”')\n        if click_stop_choose =='连点次数':\n            click_cishu = int(input('请输入连点次数：'))\n            click_liandian.append('连点次数')\n            click_liandian.append(click_cishu)\n            click_liandian.append(click_pinlv)\n            step.append(click_liandian)\n            print(click_liandian)\n            print(step)\n            break\n        if click_stop_choose == '连点时长':\n            click_shichang = int(input('请输入连点时长（秒）：'))\n            click_liandian.append('连点时长')\n            click_liandian.append(click_shichang)\n            step.append(click_liandian)\n            click_liandian.append(click_pinlv)\n            print(click_liandian)\n            print(step)\n            break\n        else:\n            continue</code></pre>\n<h3>执行时的逻辑：</h3>\n<pre><code class=\"language-python\">    if choose == '连点':\n        click_liandian = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_liandian.append('连点')\n                click_liandian.append(click_weizhi)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n        click_pinlv = float(input('请输入连点频率：'))\n        while 1:\n            click_stop_choose = input('“连点次数”or“连点时长”')\n            if click_stop_choose =='连点次数':\n                click_cishu = int(input('请输入连点次数：'))\n                click_liandian.append('连点次数')\n                click_liandian.append(click_cishu)\n                click_liandian.append(click_pinlv)\n                step.append(click_liandian)\n                print(click_liandian)\n                print(step)\n                break\n            if click_stop_choose == '连点时长':\n                click_shichang = int(input('请输入连点时长（秒）：'))\n                click_liandian.append('连点时长')\n                click_liandian.append(click_shichang)\n                step.append(click_liandian)\n                click_liandian.append(click_pinlv)\n                print(click_liandian)\n                print(step)\n                break\n            else:\n                continue</code></pre>\n<h2 id=\"%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD\">存储功能</h2>\n<p>当我们记录完所有操作后我们希望将操作保存下来方便下次使用，不需要从头录入。</p>\n<p>这将生成一个与py脚本同级的txt文件，txt文件中保存了所有的步骤，可直接读取使用</p>\n<pre><code class=\"language-python\">    if choose =='存储':\n        if len(step) == 0:\n            print('还未记录你任何操作，请添加操作再使用存储功能')\n        else:\n            do_name = input('请为以上操作命名吧：')\n            path = r\"{}.txt\".format(do_name)\n            with open(path, \"w\",encoding = 'utf8') as f:\n                f.write(str(step))</code></pre>\n<h2 id=\"%E8%AF%BB%E5%8F%96%E5%8A%9F%E8%83%BD\">读取功能</h2>\n<p>这一步呢就稍微麻烦一点，因为txt没办法记录list类型的数据，只能以str类型写出去并且只能以str类型读取进来。我自己定义了一些函数来转化为list类型，比较复杂，就不再说明函数是怎么实现的，日后有机会再跟各位分享。</p>\n<pre><code class=\"language-python\">def writeList2txt(file,data):\n    '''\n    将list写入txt\n    :param data:\n    :return:\n    '''\n    file.write(str(data))\n\ndef readListFromStr(str):\n    '''\n    str -&gt; List\n    除去冗余的方法调用\n    :param str:\n    :return:\n    '''\n    res,pos = help(str,1)\n    res1=[]\n    a ='1'\n    for ii in res:\n        iii=[]\n        for i in ii:\n            if type(i)==type(a):\n                i = i.replace(\"'\", \"\")\n                iii.append(i)\n            else:\n                iii.append(i)\n        res1.append(iii)\n    return res1\n\ndef help(str,startIndex):\n    '''\n    单行字符串的读取，形成list\n    :param str:\n    :return:\n    '''\n    str = str.replace(\" \",\"\") # 将所有空格删去\n    res = []\n    i = startIndex\n    pre = startIndex\n    while i &lt;len(str):\n        if str[i] == '[':\n            # 将pre-i-2的字符都切片，切split\n            if i-2&gt;=pre:\n                slice = str[pre:i-1].split(',')\n                for element in slice:\n                    res.append(element)\n            # 递归调用 加入子list\n            child,pos = help(str,i+1)\n            res.append(child)\n            i = pos # i移动到pos位置，也就是递归的最后一个右括号\n            pre = pos + 2 # 右括号之后是, [ 有三个字符，所以要+2至少\n        elif str[i] == ']':\n            # 将前面的全部放入列表\n            if i-1&gt;=pre:\n                slice = str[pre:i].split(',')\n                for element in slice:\n                    res.append(element)\n            return res,i\n        i = i + 1\n\n    return res,i\ndef get_caozuo(caozuopath):\n    with open(caozuopath , 'r' , encoding='utf8') as f:\n        data = f.read()\n        return data\ndef get_caozuo_name():\n    files1 = []\n    file_dir = r\"C:\\Users\\ge\\Desktop\\test1\\我的作品\\自定义连点器\"\n    for root, dirs, files in os.walk(file_dir, topdown=False):\n        files = files[:-1]\n    for i in files:\n        files1.append(i[:-4])\n    return files1\nprint(get_caozuo_name())\nif choose == '循环执行':\n    caozuojiyi = get_caozuo_name()\n    while True:\n        xunhuan_choose = input('已存储的操作有：{}\\n请输入循环操作的操作名：'.format(caozuojiyi))\n        if xunhuan_choose in caozuojiyi:\n            break\n        else:\n            print('存储库中并无你想要的操作，请重新输入：')</code></pre>\n<h2 id=\"%E5%AD%98%E5%82%A8%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E3%80%90%E5%8D%87%E7%BA%A7%E7%89%88%E3%80%91%EF%BC%9A\">存储导入功能【升级版】</h2>\n<p>上面的功能只能把二维的列表导入成list类型的数据类型，不利于后面的导入。一旦存储或导入的列表达到三维或以上就不适用了。后来我在网上搜了半天，终于发现json库里面有方法支持以list的形式导出txt并且可以以list的方式读取。以下是我实现存储导入的逻辑代码：</p>\n<h3 id=\"%E5%AF%BC%E5%85%A5%EF%BC%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A\">导入（功能实现）</h3>\n<pre><code class=\"language-python\">def txttolist(path):\n    import json\n    b = open(path, \"r\", encoding='UTF-8')\n    out = b.read()\n    out = json.loads(out)\n    return out</code></pre>\n<h3 id=\"%E5%AF%BC%E5%85%A5%EF%BC%88%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%89%EF%BC%9A\">导入（逻辑代码）</h3>\n<p>如果程序内存里已有操作了将提示保存</p>\n<pre><code class=\"language-python\">    if choose == '导入':\n        if len(step) == 0:\n            step = daoru()[0]\n        else:\n            baocun_choose = input('此次操作若未保存请先，导入别的操作会覆盖原来的操作，你确定要导入吗？\\n请输入“yes”or“no”：\\n')\n            while 1:\n                if baocun_choose == 'no':\n                    break\n                if baocun_choose == 'yes':\n                    print('你已取消保存')\n                    step = daoru()[0]\n                    break\n                else:\n                    yorn = input(\"请输入'yes'or'no'：\\n\")</code></pre>\n<h3 id=\"%E5%AD%98%E5%82%A8%EF%BC%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A\">存储（功能实现）</h3>\n<pre><code class=\"language-python\">def cunchu():\n    yorn = input(\"执行完毕，是否保存？\\n输入'yes'or'no'\\n\")\n    while 1:\n        if yorn == 'yes':\n            if len(step) == 0:\n                print('还未记录你任何操作，请添加操作再使用存储功能')\n            else:\n                do_name = input('请为以上操作命名吧：')\n                path = r\"{}.txt\".format(do_name)\n                listtotxt(list=step, path=path)\n            break\n        if yorn == 'no':\n            print('你已取消存储')\n            break\n        else:\n            yorn = input(\"请输入'yes'or'no'：\\n\")\n\ndef listtotxt(list, path):\n    import json\n    c_list = list\n    c_list = json.dumps(c_list)\n    '''将c_list存入文件\n    '''\n    a = open(path, \"w\", encoding='UTF-8')\n    a.write(c_list)\n    a.close()\n    print('已存入txt')</code></pre>\n<h3 id=\"%E5%AD%98%E5%82%A8%EF%BC%88%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%89%20%EF%BC%9A\">存储（逻辑代码） </h3>\n<p>要是程序内存里还没有操作将提醒</p>\n<pre><code class=\"language-python\">    if choose == '存储':\n        if len(step) == 0:\n            print('还未记录你任何操作，请添加操作再使用存储功能')\n        else:\n            do_name = input('请为以上操作命名吧：')\n            path = r\"{}.txt\".format(do_name)\n            listtotxt(list=step, path=path)</code></pre>\n<h2 id=\"%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%EF%BC%9A%C2%A0\">拖拽功能</h2>\n<p>这个功能也是基于pyautogui库来使用的，主要用到了pyautogui.dragTo（）方法</p>\n<h3 id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%9A\">功能实现</h3>\n<pre><code class=\"language-python\">pyautogui.moveTo(int(i[1][0]), int(i[1][1]))\npyautogui.dragTo(int(i[2][0]), int(i[2][1]), 1, button='left')\nprint(f'已执行拖拽动作，拖拽起始位置是X:{int(i[1][0])}，Y:{int(i[1][1])},拖拽后的位置是X:{int(i[2][0])}，Y:{int(i[2][1])}')</code></pre>\n<h3 id=\"%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A%C2%A0\">逻辑代码：</h3>\n<p>先创建列表tuozhuai，向列表添加三个参数：“拖拽”、第一个位置参数、第二个位置参数</p>\n<pre><code class=\"language-python\">    if choose == '拖拽':\n        tuozhuai = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成移动前的位置输入，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                tuozhuai.append('拖拽')\n                tuozhuai.append(click_weizhi)\n                while 1:\n                    click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成移动后的位置输入，输入“0”取消动作')\n                    if click_dongzuo == '1':\n                        click_weizhi = get_xy()\n                        tuozhuai.append(click_weizhi)\n                        break\n                    elif click_dongzuo == '0':\n                        print('操作已取消')\n                        break\n                    else:\n                        print('请输入正确的操作（输入“0”或“1”')\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n        step.append(tuozhuai)</code></pre>\n<p>也是用到了pyauogui库，主要使用pyautogui库的pytewrite函数，但是这个函数对中文不友好，于是我另辟蹊径使用pyperclip库的copy函数将要输入的文本内容拷贝打粘贴板，通过控制按键control+v来输入至目标位置。</p>\n<h3>功能实现</h3>\n<pre><code class=\"language-python\">    if choose == '输入':\n        shuru = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到你要输入的位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                txt_in = input('请输入你要在该位置输入的文字：\\n')\n                shuru.append('输入')\n                shuru.append(click_weizhi)\n                shuru.append(txt_in)\n                step.append(shuru)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')</code></pre>\n<h3 id=\"%C2%A0%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\"> 逻辑代码</h3>\n<pre><code class=\"language-python\">        if i[0] == '输入':\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            pyperclip.copy(i[2])\n            time.sleep(0.1)\n            pyautogui.hotkey('ctrl', 'v')</code></pre>\n<h2 id=\"%E5%8F%B3%E5%87%BB%E3%80%81%E4%B8%AD%E5%87%BB%E3%80%81%E5%8F%8C%E5%87%BB%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\">右击、中击、双击功能的实现</h2>\n<p>原理相同，将不再赘述</p>\n<h3>功能实现</h3>\n<pre><code class=\"language-python\">        if i[0] == '双击':\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            print(f'已执行完点击动作，点击坐标位置：X：{int(i[1][0])},Y：{int(i[1][1])}   ')\n        if i[0] == '右击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.rightClick(x, y)\n            print(f'已执行完右击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '中击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.middleClick(x, y)\n            print(f'已执行完中击动作，点击坐标位置：X：{x},Y：{y}   ')</code></pre>\n<h3 id=\"%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">逻辑代码</h3>\n<pre><code class=\"language-python\">    if choose == '右击':\n        click_r = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_r.append('右击')\n                click_r.append(click_weizhi)\n                step.append(click_r)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n    if choose == '中击':\n        click_m = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_m.append('中击')\n                click_m.append(click_weizhi)\n                step.append(click_m)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n        click_double = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_double.append('双击')\n                click_double.append(click_weizhi)\n                step.append(click_double)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')</code></pre>\n<h2 id=\"%E6%8C%89%E9%94%AE%E5%8A%9F%E8%83%BD%EF%BC%9A\">按键功能</h2>\n<h3>功能实现</h3>\n<pre><code class=\"language-python\">        if i[0] == '按键':\n            pyautogui.hotkey(*i[1])</code></pre>\n<h3>逻辑代码</h3>\n<pre><code class=\"language-python\">    if choose == '按键':\n        while 1:\n            anjian = input('这是模拟操作键盘的操作（例如复制，输入’ctrl‘ + ’c‘）:\\n')\n            if anjian != 'q':\n                anjian = anjian.split('+')\n                anjians = []\n                a = []\n                for an in anjian:\n                    an = an.replace(\"‘\", \"\").replace(\"’\", \"\").strip()\n                    if an in pyautogui.KEYBOARD_KEYS:\n                        anjians.append(an)\n                        nihaofan = 0\n                    else:\n                        print('你的输入不合法')\n                        nihaofan = 1\n                        break\n                if nihaofan == 0:\n                    a.append('按键')\n                    a.append(anjians)\n                    step.append(a)\n                    print('录入成功')\n                    break\n\n            if anjian == 'q':\n                break</code></pre>\n<h2 id=\"%E6%BB%9A%E5%8A%A8%E6%BB%9A%E8%BD%AE%E5%8A%9F%E8%83%BD%EF%BC%9A\">滚动滚轮功能</h2>\n<h3>功能实现</h3>\n<pre><code class=\"language-python\">        if i[0] == '滚动':\n            import pywinauto.mouse\n            x, y = pyautogui.position()\n            pywinauto.mouse.scroll((x, y), i[1])  # (1100,300)是初始坐标，1000是滑动距离（可负）</code></pre>\n<h3>逻辑代码</h3>\n<pre><code class=\"language-python\">    if choose == '滚动':\n        while 1:\n            gundong = []\n            try:\n                gundong1 = int(input('这里是模拟鼠标滚动，请输入你要滚动距离（正数为向上移动，负数为向下移动）：\\n'))\n                gundong.append('滚动')\n                gundong.append(gundong1)\n                step.append(gundong)\n                break\n            except:\n                print('你的输入有误，请重新输入')</code></pre>\n<h2 id=\"%E6%9F%A5%E7%9C%8B%E5%8A%9F%E8%83%BD%EF%BC%9A%C2%A0\">查看功能</h2>\n<pre><code class=\"language-python\">def chakan():\n    if len(step) == 0:\n        print('暂未录入操作，请先录入操作再查看')\n    zizeng = 1\n    for i in step:\n        if i[0] == '点击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            print(f'第{zizeng}步：\\n执行点击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '延时':\n            t = int(i[1])\n            print(f'第{zizeng}步：\\n执行延时动作，延时时长：{t}秒')\n        if i[0] == '连点':\n            if i[2] == '连点次数':\n                print(f'第{zizeng}步：\\n执行连点操作，你选择的是{i[2]}，连点次数是{i[4]}')\n            if i[2] == '连点时长':\n                print(f'第{zizeng}步：\\n执行连点操作，你选择的是{i[2]}，连点时长是{i[4]}秒')\n        if i[0] == '拖拽':\n            print(\n                f'第{zizeng}步：\\n执行拖拽动作，拖拽起始位置是X:{int(i[1][0])}，Y:{int(i[1][1])},拖拽后的位置是X:{int(i[2][0])}，Y:{int(i[2][1])}')\n        if i[0] == '双击':\n            print(f'第{zizeng}步：\\n执行点击动作，点击坐标位置：X：{int(i[1][0])},Y：{int(i[1][1])}   ')\n\n        if i[0] == '按键':\n            print(f'第{zizeng}步：\\n执行按键动作，将同时按下”{i[1]}“键')\n        zizeng += 1</code></pre>\n<h2 id=\"%C2%A0%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD%EF%BC%9A\"> 执行功能</h2>\n<p>执行后将询问是否保存</p>\n<pre><code class=\"language-python\">def zhixing(step):\n    for i in step:\n        if i[0] == '点击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.click(x, y)\n            print(f'已执行完点击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '延时':\n            t = int(i[1])\n            timer(t)\n            print(f'已执行完延时动作，延时时长：{t}秒')\n        if i[0] == '连点':\n            if i[2] == '连点次数':\n                clicker_cishu(int(i[3]), int(i[1][0]), int(i[1][1]), int(i[4]))\n                print(f'已执行完连点操作，你选择的是{i[2]}，连点次数是{i[4]}')\n            if i[2] == '连点时长':\n                clicker_time(int(i[3]), int(i[1][0]), int(i[1][1]), int(i[4]))\n                print(f'已执行完连点操作，你选择的是{i[2]}，连点时长是{i[4]}秒')\n        if i[0] == '拖拽':\n            pyautogui.moveTo(int(i[1][0]), int(i[1][1]))\n            pyautogui.dragTo(int(i[2][0]), int(i[2][1]), 1, button='left')\n            print(f'已执行拖拽动作，拖拽起始位置是X:{int(i[1][0])}，Y:{int(i[1][1])},拖拽后的位置是X:{int(i[2][0])}，Y:{int(i[2][1])}')\n        if i[0] == '双击':\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            print(f'已执行完点击动作，点击坐标位置：X：{int(i[1][0])},Y：{int(i[1][1])}   ')\n        if i[0] == '输入':\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            pyperclip.copy(i[2])\n            time.sleep(0.1)\n            pyautogui.hotkey('ctrl', 'v')\n        if i[0] == '按键':\n            pyautogui.hotkey(*i[1])\n        if i[0] == '右击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.rightClick(x, y)\n            print(f'已执行完右击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '中击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.middleClick(x, y)\n            print(f'已执行完中击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '滚动':\n            import pywinauto.mouse\n            x, y = pyautogui.position()\n            pywinauto.mouse.scroll((x, y), i[1])  # (1100,300)是初始坐标，1000是滑动距离（可负）\n</code></pre>\n<pre><code class=\"language-python\">    if choose == '执行':\n        if len(step) == 0:\n            print('你还未记录任何操作，请至少记录了一个操作再执行')\n        else:\n            zhixing(step)\n            cunchu()</code></pre>\n<h1 id=\"%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E6%9D%BF%E5%9D%97%EF%BC%9A\">逻辑判断功能板块</h1>\n<p><span style=\"color:#fe2c24;\">到了最难最虐脑的逻辑判断功能了，逻辑判断板块这几个功能困扰了我一整天，敲到我脑壳疼</span></p>\n<h2 id=\"%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD\">判断功能</h2>\n<p><span style=\"color:#fe2c24;\">实现这一功能主要是基于颜色的RBG值来判断程序所要要执行的步骤块。</span></p>\n<p><span style=\"color:#fe2c24;\">选择目标点，开启线程去时刻监管这个目标点的颜色变化，一旦目标颜色变为期待值，立即执行之前存储的步骤块，可以选择是否循环这个步骤块的操作。选择完毕后开启第二个线程去执行这个步骤块，此时主程序将继续遍历panduans的操作。设置一个while循环来阻塞主程序的运行及监控state变量值的变化，state初始值为“未触发”,一旦监管线程发现目标值变化为期待值，立即修改state值为“触发”，同时关闭执行步骤块的线程，同时关闭自身的监管线程，此时主程序检测到state值为“触发”后立刻将新的步骤块的线程开启并将state值修改为“未触发”。就此开启新一轮的循环。</span></p>\n<p><span style=\"color:#1a439c;\">之间呢，遇到了多个线程修改同一个值的情况导致报错；遇到了多种停止线程的方法都不适用的情况；遇到了没设置守护进程又要找到这个进程去关闭的情况；尝试了老版的_thread进程库、尝试了主流的threading进程库、尝试了线程池的方法，终于找到一条适合我的方法。不容易呀</span></p>\n<h2 id=\"%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span style=\"color:#0d0016;\">判断功能的逻辑代码</span></h2>\n<pre><code class=\"language-python\">    if choose == '判断':\n        if len(panduans) == 0:\n            tuichu = 0\n            panduan = input('此功能的实现是基于颜色的RBG值来判断程序所要要执行的步骤块。\\n现在，请选择你的‘先执行步骤块等待条件触发’或是‘直接等待条件触发’的操作：(输入\"步骤块\"或\"等待\")\\n')\n            if panduan == '如果':\n                panduan_if = []\n                while 1:\n                    click_dongzuo = input('请移动鼠标到目标位置上吸取颜色，输入“1”完成动作，输入“0”取消动作')\n                    if click_dongzuo == '1':\n                        xy = get_xy()\n                        click_color = GetColor(xy)\n                        panduan_yn = input(f'这个位置的RGB为：{click_color}，是否确定为下一步骤块的判断根据？（输入\"yes\"or\"no\"）\\n')\n                        while 1:\n                            if panduan_yn == 'yes':\n                                get_caozuo_name()\n                                print(f'请选择满足当颜色为{click_color}时要执行的步骤包：')\n                                steps, steps_name = daoru()\n                                xunhuan_yn = input('这个步骤块是否循环执行至下一条件触发？（输入\"yes\"or\"no\"）\\n')\n                                while 1:\n                                    if xunhuan_yn == 'yes':\n                                        panduan_if.append('如果')\n                                        panduan_if.append(xy)\n                                        panduan_if.append(click_color)\n                                        panduan_if.append(steps_name)\n                                        panduan_if.append('循环')\n                                        panduan_if.append(steps)\n                                        panduans.append(panduan_if)\n                                        print('添加成功，该步骤包将会循环')\n                                        break\n                                    elif xunhuan_yn == 'no':\n                                        panduan_if.append('如果')\n                                        panduan_if.append(xy)\n                                        panduan_if.append(click_color)\n                                        panduan_if.append(steps_name)\n                                        panduan_if.append('不循环')\n                                        panduan_if.append(steps)\n                                        panduans.append(panduan_if)\n                                        print('添加成功，该步骤包将只执行一次')\n                                        break\n                                    else:\n                                        xunhuan_yn = input('你的输入有误，请输入\"yes\"or\"no\":')\n                                tuichu = 1\n                                break\n                            if panduan_yn == 'no':\n                                print('请重新选择')\n                                break\n                            else:\n                                panduan_yn = input('你的输入有误，请输入\"yes\"or\"no\"')\n                        if tuichu == 1:\n                            break\n                    elif click_dongzuo == '0':\n                        print('操作已取消')\n                        break\n                    else:\n                        print('请输入正确的操作（输入“0”或“1”)')\n            if panduan == '步骤块':\n                panduan_step = []\n                steps, steps_name = daoru()\n                xunhuan_yn = input('这个步骤块是否循环执行直至条件触发？（输入\"yes\"or\"no\"）\\n')\n                while 1:\n                    if xunhuan_yn == 'yes':\n                        panduan_step.append('步骤块')\n                        panduan_step.append('循环')\n                        panduan_step.append(steps_name)\n                        panduan_step.append(steps)\n                        panduans.append(panduan_step)\n                        break\n                    elif xunhuan_yn == 'no':\n                        panduan_step.append('步骤块')\n                        panduan_step.append('不循环')\n                        panduan_step.append(steps_name)\n                        panduan_step.append(steps)\n                        panduans.append(panduan_step)\n                        break\n                    else:\n                        xunhuan_yn = input('你的输入有误，请输入\"yes\"or\"no\":')\n            if panduan == '等待':\n                panduan_if = []\n                print('你选择了等待，程序将时刻检测目标位置的颜色以执行接下来的步骤块')\n                panduan_if.append('等待')\n                panduans.append(panduan_if)\n            if panduan != '步骤块' and panduan != '如果' and panduan != '等待':\n                print('你的输入有误')\n        if len(panduans) &gt; 0:\n            print('你一录入了至少一个逻辑判断，请选择继续选择目标位置的颜色来触发接下来你选择的步骤块')\n            panduan_if = []\n            while 1:\n                click_dongzuo = input('请移动鼠标到目标位置上吸取颜色，输入“1”完成动作，输入“0”取消动作')\n                if click_dongzuo == '1':\n                    xy = get_xy()\n                    click_color = GetColor(xy)\n                    panduan_yn = input(f'这个位置的RGB为：{click_color}，是否确定为下一步骤块的判断根据？（输入\"yes\"or\"no\"）\\n')\n                    while 1:\n                        if panduan_yn == 'yes':\n                            get_caozuo_name()\n                            print(f'请选择满足当颜色为{click_color}时要执行的步骤包：')\n                            steps, steps_name = daoru()\n                            xunhuan_yn = input('这个步骤块是否循环执行直至条件触发？（输入\"yes\"or\"no\"）\\n')\n                            while 1:\n                                if xunhuan_yn == 'yes':\n                                    panduan_if.append('如果')\n                                    panduan_if.append(xy)\n                                    panduan_if.append(click_color)\n                                    panduan_if.append(steps_name)\n                                    panduan_if.append('循环')\n                                    panduan_if.append(steps)\n                                    panduans.append(panduan_if)\n                                    print('添加成功，该步骤包将会循环')\n                                    break\n                                elif xunhuan_yn == 'no':\n                                    panduan_if.append('如果')\n                                    panduan_if.append(xy)\n                                    panduan_if.append(click_color)\n                                    panduan_if.append(steps_name)\n                                    panduan_if.append('不循环')\n                                    panduan_if.append(steps)\n                                    panduans.append(panduan_if)\n                                    print('添加成功，该步骤包将只执行一次')\n                                    break\n                                else:\n                                    xunhuan_yn = input('你的输入有误，请输入\"yes\"or\"no\":')\n                            tuichu = 1\n                            break\n                        if panduan_yn == 'no':\n                            print('请重新选择')\n                            break\n                        else:\n                            panduan_yn = input('你的输入有误，请输入\"yes\"or\"no\"')\n                    if tuichu == 1:\n                        break\n                elif click_dongzuo == '0':\n                    print('操作已取消')\n                    break\n                else:\n                    print('请输入正确的操作（输入“0”或“1”)')</code></pre>\n<h2 id=\"%C2%A0%E9%80%BB%E8%BE%91%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\"> 逻辑执行功能的实现</h2>\n<pre><code class=\"language-python\">    if choose == '逻辑执行':\n        print('这里是逻辑执行库，所有的逻辑判断都会存储到这里')\n        print(panduans)\n        xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=('等待', '1', '循环'))\n        xiancheng.setDaemon(True)\n        xiancheng.start()\n        for pan in panduans:\n            state = '未触发'\n            if pan[0] == '如果':\n                print(pan[5])\n                print(len(pan[5]))\n                bu = str(pan[5])\n                print(bu)\n                bu = readListFromStr(bu)\n                zhixing(bu)\n                print(bu)\n                if state == '未触发':\n                    if pan[4] == '循环':\n                        rgb = pan[2]\n                        rgb_xy = pan[1]\n                        _thread.start_new_thread(jianshi, ())\n                        while 1:\n                            if state == '触发':\n                                xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[3], pan[5], '循环'))\n                                xiancheng.start()\n                                state = '未触发'\n                                break\n                    if pan[4] == '不循环':\n                        rgb = pan[2]\n                        rgb_xy = pan[1]\n                        _thread.start_new_thread(jianshi, ())\n                        while 1:\n                            if state == '触发':\n                                xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[3], pan[5], '不循环'))\n                                xiancheng.start()\n                                state = '未触发'\n                                break\n            if pan[0] == '步骤块':\n                stop_thread(xiancheng)\n                if pan[1] == '循环':\n                    xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[2], pan[3], '循环'))\n                    xiancheng.start()\n                if pan[1] == '不循环':\n                    xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[2], pan[3], '不循环'))\n                    xiancheng.start()\n            if pan[0] == '等待':\n                print('程序正在监测目标位置RGB值')\n        print('逻辑执行已全部执行完毕')\n        break</code></pre>\n<h3 id=\"%E9%80%BB%E8%BE%91%E5%9D%97%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A\">逻辑块存储功能的实现</h3>\n<pre><code class=\"language-python\">def listtotxt(list, path):\n    import json\n    c_list = list\n    c_list = json.dumps(c_list)\n    '''将c_list存入文件\n    '''\n    a = open(path, \"w\", encoding='UTF-8')\n    a.write(c_list)\n    a.close()\n    print('已存入txt')</code></pre>\n<h3 id=\"%E9%80%BB%E8%BE%91%E5%9D%97%E5%AD%98%E5%82%A8%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%EF%BC%9A\">逻辑块存储逻辑代码</h3>\n<pre><code class=\"language-python\">    if choose == '逻辑块存储':\n        yorn = input(\"确定保存？\\n输入'yes'or'no'\\n\")\n        while 1:\n            if yorn == 'yes':\n                if len(panduans) == 0:\n                    print('还未记录你任何操作，请添加操作再使用逻辑块存储功能')\n                else:\n                    do_name = input('请为以上操作命名吧：')\n                    if '逻辑块存储' in do_name:\n                        do_name = input('抱歉，你的命名里不允许包含”逻辑块存储“，请重新命名')\n                    else:\n                        path = r\"{}逻辑块存储.txt\".format(do_name)\n                        listtotxt(list=panduans, path=path)\n                break\n            if yorn == 'no':\n                print('你已取消存储')\n                break\n            else:\n                yorn = input(\"请输入'yes'or'no'：\\n\")</code></pre>\n<h3 id=\"%E9%80%BB%E8%BE%91%E5%9D%97%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0\">逻辑块导入功能的实现</h3>\n<pre><code class=\"language-python\">def txttolist(path):\n    import json\n    b = open(path, \"r\", encoding='UTF-8')\n    out = b.read()\n    out = json.loads(out)\n    return out</code></pre>\n<p>逻辑块导入逻辑代码：</p>\n<pre><code class=\"language-python\">    if choose == '逻辑块导入':\n        caozuojiyi = get_caozuokuai_name()\n        while True:\n            xunhuan_choose = input('已存储的操作有：{}\\n请输入导入操作的操作名：'.format(caozuojiyi))\n            if xunhuan_choose in caozuojiyi:\n                break\n            else:\n                print('逻辑块存储库中并无你想要的操作，请重新输入：')\n        caozuopath = r\"{}逻辑块存储.txt\".format(xunhuan_choose)\n        panduans = txttolist(path=caozuopath)</code></pre>\n<h1 id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A\"><strong>完整代码</strong></h1>\n<pre><code class=\"language-python\">import threading\nimport pyautogui\nfrom ctypes import *\nimport time\nimport os, sys\nimport pyperclip\nimport inspect\nimport ctypes\nimport _thread\n\n\ndef _async_raise(tid, exctype):\n    \"\"\"raises the exception, performs cleanup if needed\"\"\"\n    tid = ctypes.c_long(tid)\n    if not inspect.isclass(exctype):\n        exctype = type(exctype)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))\n    if res == 0:\n        raise ValueError(\"invalid thread id\")\n    elif res != 1:\n        # \"\"\"if it returns a number greater than one, you're in trouble,\n        # and you should call it again with exc=NULL to revert the effect\"\"\"\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)\n        raise SystemError(\"PyThreadState_SetAsyncExc failed\")\n\n\ndef stop_thread(threa):\n    _async_raise(threa.ident, SystemExit)\n\n\ndef get_caozuo_name():\n    dirname, filename = os.path.split(os.path.abspath(sys.argv[0]))\n    files1 = []\n    file_dir = r\"{}\".format(os.path.realpath(sys.argv[0])[:-13])\n    for root, dirs, files in os.walk(file_dir, topdown=False):\n        files = files[:-1]\n    for i in files:\n        if '.txt' in i:\n            files1.append(i[:-4])\n    return files1\n\n\ndef get_caozuokuai_name():\n    dirname, filename = os.path.split(os.path.abspath(sys.argv[0]))\n    files1 = []\n    file_dir = r\"{}\".format(os.path.realpath(sys.argv[0])[:-13])\n    for root, dirs, files in os.walk(file_dir, topdown=False):\n        files = files[:-1]\n    for i in files:\n        if '逻辑块存储.txt' in i:\n            files1.append(i[:-9])\n    return files1\n\n\ndef writeList2txt(file, data):\n    '''\n    将list写入txt\n    :param data:\n    :return:\n    '''\n    file.write(str(data), encoding='uft8')\n\n\ndef readListFromStr(str):\n    '''\n    str -&gt; List\n    除去冗余的方法调用\n    :param str:\n    :return:\n    '''\n    res, pos = help(str, 1)\n    res1 = []\n    a = '1'\n    for ii in res:\n        iii = []\n        for i in ii:\n            if type(i) == type(a):\n                i = i.replace(\"'\", \"\")\n                iii.append(i)\n            else:\n                iii.append(i)\n        res1.append(iii)\n    return res1\n\n\ndef help(str, startIndex):\n    '''\n    单行字符串的读取，形成list\n    :param str:\n    :return:\n    '''\n    str = str.replace(\" \", \"\")  # 将所有空格删去\n    res = []\n    i = startIndex\n    pre = startIndex\n    while i &lt; len(str):\n        if str[i] == '[':\n            # 将pre-i-2的字符都切片，切split\n            if i - 2 &gt;= pre:\n                slice = str[pre:i - 1].split(',')\n                for element in slice:\n                    res.append(element)\n            # 递归调用 加入子list\n            child, pos = help(str, i + 1)\n            res.append(child)\n            i = pos  # i移动到pos位置，也就是递归的最后一个右括号\n            pre = pos + 2  # 右括号之后是, [ 有三个字符，所以要+2至少\n        elif str[i] == ']':\n            # 将前面的全部放入列表\n            if i - 1 &gt;= pre:\n                slice = str[pre:i].split(',')\n                for element in slice:\n                    res.append(element)\n            return res, i\n        i = i + 1\n\n    return res, i\n\n\ndef get_caozuo(caozuopath):\n    with open(caozuopath, 'r', encoding='utf8') as f:\n        data = f.read()\n        return data\n\n\ndef get_xy():\n    x, y = pyautogui.position()\n    return [x, y]\n\n\ndef GetColor(xy):\n    x = xy[0]\n    y = xy[1]\n    r = 0\n    g = 0\n    b = 0\n    try:\n        gdi32 = windll.gdi32\n        user32 = windll.user32\n        hdc = user32.GetDC(None)  # 获取颜色值\n        pixel = gdi32.GetPixel(hdc, x, y)  # 提取RGB值\n        r = pixel &amp; 0x0000ff\n        g = (pixel &amp; 0x00ff00) &gt;&gt; 8\n        b = pixel &gt;&gt; 16\n    except KeyboardInterrupt:\n        print('\\n')\n    return [r, g, b]\n\n\ndef timer(timex):\n    time.sleep(timex)\n\n\ndef clicker_cishu(cishu, x, y, pinlv):\n    for a in range(cishu):\n        pyautogui.click(x, y)\n        time.sleep(pinlv)\n\n\ndef clicker_time(shijian, x, y, pinlv):\n    start = time.time()\n    while True:\n        pyautogui.click(x, y)\n        time.sleep(pinlv)\n        end = time.time()\n        shijian1 = end - start\n        if shijian1 &gt;= shijian:\n            break\n\n\ndef zhixing(step):\n    for i in step:\n        if i[0] == '点击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.click(x, y)\n            print(f'已执行完点击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '延时':\n            t = int(i[1])\n            timer(t)\n            print(f'已执行完延时动作，延时时长：{t}秒')\n        if i[0] == '连点':\n            if i[2] == '连点次数':\n                clicker_cishu(int(i[3]), int(i[1][0]), int(i[1][1]), int(i[4]))\n                print(f'已执行完连点操作，你选择的是{i[2]}，连点次数是{i[4]}')\n            if i[2] == '连点时长':\n                clicker_time(int(i[3]), int(i[1][0]), int(i[1][1]), int(i[4]))\n                print(f'已执行完连点操作，你选择的是{i[2]}，连点时长是{i[4]}秒')\n        if i[0] == '拖拽':\n            pyautogui.moveTo(int(i[1][0]), int(i[1][1]))\n            pyautogui.dragTo(int(i[2][0]), int(i[2][1]), 1, button='left')\n            print(f'已执行拖拽动作，拖拽起始位置是X:{int(i[1][0])}，Y:{int(i[1][1])},拖拽后的位置是X:{int(i[2][0])}，Y:{int(i[2][1])}')\n        if i[0] == '双击':\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            print(f'已执行完点击动作，点击坐标位置：X：{int(i[1][0])},Y：{int(i[1][1])}   ')\n        if i[0] == '输入':\n            pyautogui.click(int(i[1][0]), int(i[1][1]))\n            pyperclip.copy(i[2])\n            time.sleep(0.1)\n            pyautogui.hotkey('ctrl', 'v')\n        if i[0] == '按键':\n            pyautogui.hotkey(*i[1])\n        if i[0] == '右击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.rightClick(x, y)\n            print(f'已执行完右击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '中击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            pyautogui.middleClick(x, y)\n            print(f'已执行完中击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '滚动':\n            import pywinauto.mouse\n            x, y = pyautogui.position()\n            pywinauto.mouse.scroll((x, y), i[1])  # (1100,300)是初始坐标，1000是滑动距离（可负）\n\n\ndef cunchu():\n    yorn = input(\"执行完毕，是否保存？\\n输入'yes'or'no'\\n\")\n    while 1:\n        if yorn == 'yes':\n            if len(step) == 0:\n                print('还未记录你任何操作，请添加操作再使用存储功能')\n            else:\n                do_name = input('请为以上操作命名吧：')\n                path = r\"{}.txt\".format(do_name)\n                listtotxt(list=step, path=path)\n            break\n        if yorn == 'no':\n            print('你已取消存储')\n            break\n        else:\n            yorn = input(\"请输入'yes'or'no'：\\n\")\n\n\ndef chakan():\n    if len(step) == 0:\n        print('暂未录入操作，请先录入操作再查看')\n    zizeng = 1\n    for i in step:\n        if i[0] == '点击':\n            x = int(i[1][0])\n            y = int(i[1][1])\n            print(f'第{zizeng}步：\\n执行点击动作，点击坐标位置：X：{x},Y：{y}   ')\n        if i[0] == '延时':\n            t = int(i[1])\n            print(f'第{zizeng}步：\\n执行延时动作，延时时长：{t}秒')\n        if i[0] == '连点':\n            if i[2] == '连点次数':\n                print(f'第{zizeng}步：\\n执行连点操作，你选择的是{i[2]}，连点次数是{i[4]}')\n            if i[2] == '连点时长':\n                print(f'第{zizeng}步：\\n执行连点操作，你选择的是{i[2]}，连点时长是{i[4]}秒')\n        if i[0] == '拖拽':\n            print(\n                f'第{zizeng}步：\\n执行拖拽动作，拖拽起始位置是X:{int(i[1][0])}，Y:{int(i[1][1])},拖拽后的位置是X:{int(i[2][0])}，Y:{int(i[2][1])}')\n        if i[0] == '双击':\n            print(f'第{zizeng}步：\\n执行点击动作，点击坐标位置：X：{int(i[1][0])},Y：{int(i[1][1])}   ')\n\n        if i[0] == '按键':\n            print(f'第{zizeng}步：\\n执行按键动作，将同时按下”{i[1]}“键')\n        zizeng += 1\n\n\ndef daoru():\n    caozuojiyi = get_caozuo_name()\n    while True:\n        xunhuan_choose = input('已存储的操作有：{}\\n请输入导入操作的操作名：'.format(caozuojiyi))\n        if xunhuan_choose in caozuojiyi:\n            break\n        else:\n            print('存储库中并无你想要的操作，请重新输入：')\n    caozuopath = r'{}.txt'.format(xunhuan_choose)\n    step1 = txttolist(caozuopath)\n    print(step1)\n    return [step1, xunhuan_choose]\n\n\ndef jianshi():\n    global state, rgb, rgb_xy, xiancheng\n    while 1:\n        aa = GetColor(rgb_xy)\n        if aa == rgb:\n            try:\n                stop_thread(xiancheng)\n            finally:\n\n                state = '触发'\n                print(f'检测到{rgb_xy}位置的RGB值变为{aa}')\n                break\n\n\ndef zhixingbuzhoukuai(buzhou, bu, xunhuanyn):\n    global state\n    print(f'正在执行\"{buzhou}\"代码块的操作')\n    state = '未触发'\n    if bu == '1':\n        while 1:\n            if state == '触发':\n                break\n            if state == '未触发':\n                timer(0.1)\n    elif xunhuanyn == '循环':\n        while 1:\n            if state == '触发':\n                break\n            if state == '未触发':\n                zhixing(bu)\n    elif xunhuanyn == '不循环':\n        zhixing(bu)\n\n\ndef listtotxt(list, path):\n    import json\n    c_list = list\n    c_list = json.dumps(c_list)\n    '''将c_list存入文件\n    '''\n    a = open(path, \"w\", encoding='UTF-8')\n    a.write(c_list)\n    a.close()\n    print('已存入txt')\n\n\ndef txttolist(path):\n    import json\n    b = open(path, \"r\", encoding='UTF-8')\n    out = b.read()\n    out = json.loads(out)\n    return out\n\n\nrgb_xy = []\nrgb = []\nstate = '未触发'\npanduans = []\nstep = []\nwhile True:\n    choose = input('请输入你需要使用的功能：')\n    if choose == '点击':\n        click = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click.append('点击')\n                click.append(click_weizhi)\n                step.append(click)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n    if choose == '延时':\n        while 1:\n            timerr = []\n            try:\n                timex = int(input('请输入延时时间：'))\n                timerr.append('延时')\n                timerr.append(timex)\n                step.append(timerr)\n                break\n            except:\n                print('延时失败/n请输入正确的延时时间')\n                continue\n    if choose == '连点':\n        click_liandian = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_liandian.append('连点')\n                click_liandian.append(click_weizhi)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n        click_pinlv = float(input('请输入连点频率：'))\n        while 1:\n            click_stop_choose = input('“连点次数”or“连点时长”')\n            if click_stop_choose == '连点次数':\n                click_cishu = int(input('请输入连点次数：'))\n                click_liandian.append('连点次数')\n                click_liandian.append(click_cishu)\n                click_liandian.append(click_pinlv)\n                step.append(click_liandian)\n                print(click_liandian)\n                print(step)\n                break\n            if click_stop_choose == '连点时长':\n                click_shichang = int(input('请输入连点时长（秒）：'))\n                click_liandian.append('连点时长')\n                click_liandian.append(click_shichang)\n                step.append(click_liandian)\n                click_liandian.append(click_pinlv)\n                print(click_liandian)\n                print(step)\n                break\n            else:\n                continue\n    if choose == '存储':\n        if len(step) == 0:\n            print('还未记录你任何操作，请添加操作再使用存储功能')\n        else:\n            do_name = input('请为以上操作命名吧：')\n            path = r\"{}.txt\".format(do_name)\n            listtotxt(list=step, path=path)\n    if choose == '拖拽':\n        tuozhuai = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成移动前的位置输入，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                tuozhuai.append('拖拽')\n                tuozhuai.append(click_weizhi)\n                while 1:\n                    click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成移动后的位置输入，输入“0”取消动作')\n                    if click_dongzuo == '1':\n                        click_weizhi = get_xy()\n                        tuozhuai.append(click_weizhi)\n                        break\n                    elif click_dongzuo == '0':\n                        print('操作已取消')\n                        break\n                    else:\n                        print('请输入正确的操作（输入“0”或“1”')\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n        step.append(tuozhuai)\n    if choose == '循环执行':\n        while 1:\n            xunhuan_cishu_zhixing = 0\n            xunhuan_cishu = input('请输入循环次数（如要无限循环请输入\"无限\"）：')\n            if xunhuan_cishu == '无限':\n                while True:\n                    zhixing(step)\n            if xunhuan_cishu.isdigit():\n\n                for i in range(int(xunhuan_cishu)):\n                    xunhuan_cishu_zhixing += 1\n                    zhixing(step)\n                    print(f'已完成{xunhuan_cishu_zhixing}次循环')\n                break\n            else:\n                print('你的输入有误，请重新输入：')\n    if choose == '导入':\n        if len(step) == 0:\n            step = daoru()[0]\n        else:\n            baocun_choose = input('此次操作若未保存请先，导入别的操作会覆盖原来的操作，你确定要导入吗？\\n请输入“yes”or“no”：\\n')\n            while 1:\n                if baocun_choose == 'no':\n                    break\n                if baocun_choose == 'yes':\n                    print('你已取消保存')\n                    step = daoru()[0]\n                    break\n                else:\n                    yorn = input(\"请输入'yes'or'no'：\\n\")\n    if choose == '输入':\n        shuru = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到你要输入的位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                txt_in = input('请输入你要在该位置输入的文字：\\n')\n                shuru.append('输入')\n                shuru.append(click_weizhi)\n                shuru.append(txt_in)\n                step.append(shuru)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n    if choose == '按键':\n        while 1:\n            anjian = input('这是模拟操作键盘的操作（例如复制，输入’ctrl‘ + ’c‘）:\\n')\n            if anjian != 'q':\n                anjian = anjian.split('+')\n                anjians = []\n                a = []\n                for an in anjian:\n                    an = an.replace(\"‘\", \"\").replace(\"’\", \"\").strip()\n                    if an in pyautogui.KEYBOARD_KEYS:\n                        anjians.append(an)\n                        nihaofan = 0\n                    else:\n                        print('你的输入不合法')\n                        nihaofan = 1\n                        break\n                if nihaofan == 0:\n                    a.append('按键')\n                    a.append(anjians)\n                    step.append(a)\n                    print('录入成功')\n                    break\n\n            if anjian == 'q':\n                break\n    if choose == '双击':\n        click_double = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_double.append('双击')\n                click_double.append(click_weizhi)\n                step.append(click_double)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n    if choose == '滚动':\n        while 1:\n            gundong = []\n            try:\n                gundong1 = int(input('这里是模拟鼠标滚动，请输入你要滚动距离（正数为向上移动，负数为向下移动）：\\n'))\n                gundong.append('滚动')\n                gundong.append(gundong1)\n                step.append(gundong)\n                break\n            except:\n                print('你的输入有误，请重新输入')\n    if choose == '查看':\n        chakan()\n    if choose == '右击':\n        click_r = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_r.append('右击')\n                click_r.append(click_weizhi)\n                step.append(click_r)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n    if choose == '中击':\n        click_m = []\n        while 1:\n            click_dongzuo = input('请移动鼠标到目标位置上输入“1”完成动作，输入“0”取消动作')\n            if click_dongzuo == '1':\n                click_weizhi = get_xy()\n                click_m.append('中击')\n                click_m.append(click_weizhi)\n                step.append(click_m)\n                break\n            elif click_dongzuo == '0':\n                print('操作已取消')\n                break\n            else:\n                print('请输入正确的操作（输入“0”或“1”')\n    if choose == '执行':\n        if len(step) == 0:\n            print('你还未记录任何操作，请至少记录了一个操作再执行')\n        else:\n            zhixing(step)\n            cunchu()\n    if choose == '判断':\n        if len(panduans) == 0:\n            tuichu = 0\n            panduan = input('此功能的实现是基于颜色的RBG值来判断程序所要要执行的步骤块。\\n现在，请选择你的‘先执行步骤块等待条件触发’或是‘直接等待条件触发’的操作：(输入\"步骤块\"或\"等待\")\\n')\n            if panduan == '如果':\n                panduan_if = []\n                while 1:\n                    click_dongzuo = input('请移动鼠标到目标位置上吸取颜色，输入“1”完成动作，输入“0”取消动作')\n                    if click_dongzuo == '1':\n                        xy = get_xy()\n                        click_color = GetColor(xy)\n                        panduan_yn = input(f'这个位置的RGB为：{click_color}，是否确定为下一步骤块的判断根据？（输入\"yes\"or\"no\"）\\n')\n                        while 1:\n                            if panduan_yn == 'yes':\n                                get_caozuo_name()\n                                print(f'请选择满足当颜色为{click_color}时要执行的步骤包：')\n                                steps, steps_name = daoru()\n                                xunhuan_yn = input('这个步骤块是否循环执行至下一条件触发？（输入\"yes\"or\"no\"）\\n')\n                                while 1:\n                                    if xunhuan_yn == 'yes':\n                                        panduan_if.append('如果')\n                                        panduan_if.append(xy)\n                                        panduan_if.append(click_color)\n                                        panduan_if.append(steps_name)\n                                        panduan_if.append('循环')\n                                        panduan_if.append(steps)\n                                        panduans.append(panduan_if)\n                                        print('添加成功，该步骤包将会循环')\n                                        break\n                                    elif xunhuan_yn == 'no':\n                                        panduan_if.append('如果')\n                                        panduan_if.append(xy)\n                                        panduan_if.append(click_color)\n                                        panduan_if.append(steps_name)\n                                        panduan_if.append('不循环')\n                                        panduan_if.append(steps)\n                                        panduans.append(panduan_if)\n                                        print('添加成功，该步骤包将只执行一次')\n                                        break\n                                    else:\n                                        xunhuan_yn = input('你的输入有误，请输入\"yes\"or\"no\":')\n                                tuichu = 1\n                                break\n                            if panduan_yn == 'no':\n                                print('请重新选择')\n                                break\n                            else:\n                                panduan_yn = input('你的输入有误，请输入\"yes\"or\"no\"')\n                        if tuichu == 1:\n                            break\n                    elif click_dongzuo == '0':\n                        print('操作已取消')\n                        break\n                    else:\n                        print('请输入正确的操作（输入“0”或“1”)')\n            if panduan == '步骤块':\n                panduan_step = []\n                steps, steps_name = daoru()\n                xunhuan_yn = input('这个步骤块是否循环执行直至条件触发？（输入\"yes\"or\"no\"）\\n')\n                while 1:\n                    if xunhuan_yn == 'yes':\n                        panduan_step.append('步骤块')\n                        panduan_step.append('循环')\n                        panduan_step.append(steps_name)\n                        panduan_step.append(steps)\n                        panduans.append(panduan_step)\n                        break\n                    elif xunhuan_yn == 'no':\n                        panduan_step.append('步骤块')\n                        panduan_step.append('不循环')\n                        panduan_step.append(steps_name)\n                        panduan_step.append(steps)\n                        panduans.append(panduan_step)\n                        break\n                    else:\n                        xunhuan_yn = input('你的输入有误，请输入\"yes\"or\"no\":')\n            if panduan == '等待':\n                panduan_if = []\n                print('你选择了等待，程序将时刻检测目标位置的颜色以执行接下来的步骤块')\n                panduan_if.append('等待')\n                panduans.append(panduan_if)\n            if panduan != '步骤块' and panduan != '如果' and panduan != '等待':\n                print('你的输入有误')\n        if len(panduans) &gt; 0:\n            print('你一录入了至少一个逻辑判断，请选择继续选择目标位置的颜色来触发接下来你选择的步骤块')\n            panduan_if = []\n            while 1:\n                click_dongzuo = input('请移动鼠标到目标位置上吸取颜色，输入“1”完成动作，输入“0”取消动作')\n                if click_dongzuo == '1':\n                    xy = get_xy()\n                    click_color = GetColor(xy)\n                    panduan_yn = input(f'这个位置的RGB为：{click_color}，是否确定为下一步骤块的判断根据？（输入\"yes\"or\"no\"）\\n')\n                    while 1:\n                        if panduan_yn == 'yes':\n                            get_caozuo_name()\n                            print(f'请选择满足当颜色为{click_color}时要执行的步骤包：')\n                            steps, steps_name = daoru()\n                            xunhuan_yn = input('这个步骤块是否循环执行直至条件触发？（输入\"yes\"or\"no\"）\\n')\n                            while 1:\n                                if xunhuan_yn == 'yes':\n                                    panduan_if.append('如果')\n                                    panduan_if.append(xy)\n                                    panduan_if.append(click_color)\n                                    panduan_if.append(steps_name)\n                                    panduan_if.append('循环')\n                                    panduan_if.append(steps)\n                                    panduans.append(panduan_if)\n                                    print('添加成功，该步骤包将会循环')\n                                    break\n                                elif xunhuan_yn == 'no':\n                                    panduan_if.append('如果')\n                                    panduan_if.append(xy)\n                                    panduan_if.append(click_color)\n                                    panduan_if.append(steps_name)\n                                    panduan_if.append('不循环')\n                                    panduan_if.append(steps)\n                                    panduans.append(panduan_if)\n                                    print('添加成功，该步骤包将只执行一次')\n                                    break\n                                else:\n                                    xunhuan_yn = input('你的输入有误，请输入\"yes\"or\"no\":')\n                            tuichu = 1\n                            break\n                        if panduan_yn == 'no':\n                            print('请重新选择')\n                            break\n                        else:\n                            panduan_yn = input('你的输入有误，请输入\"yes\"or\"no\"')\n                    if tuichu == 1:\n                        break\n                elif click_dongzuo == '0':\n                    print('操作已取消')\n                    break\n                else:\n                    print('请输入正确的操作（输入“0”或“1”)')\n    if choose == '逻辑执行':\n        print('这里是逻辑执行库，所有的逻辑判断都会存储到这里')\n        print(panduans)\n        xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=('等待', '1', '循环'))\n        xiancheng.setDaemon(True)\n        xiancheng.start()\n        for pan in panduans:\n            state = '未触发'\n            if pan[0] == '如果':\n                print(pan[5])\n                print(len(pan[5]))\n                bu = str(pan[5])\n                print(bu)\n                bu = readListFromStr(bu)\n                zhixing(bu)\n                print(bu)\n                if state == '未触发':\n                    if pan[4] == '循环':\n                        rgb = pan[2]\n                        rgb_xy = pan[1]\n                        _thread.start_new_thread(jianshi, ())\n                        while 1:\n                            if state == '触发':\n                                xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[3], pan[5], '循环'))\n                                xiancheng.start()\n                                state = '未触发'\n                                break\n                    if pan[4] == '不循环':\n                        rgb = pan[2]\n                        rgb_xy = pan[1]\n                        _thread.start_new_thread(jianshi, ())\n                        while 1:\n                            if state == '触发':\n                                xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[3], pan[5], '不循环'))\n                                xiancheng.start()\n                                state = '未触发'\n                                break\n            if pan[0] == '步骤块':\n                stop_thread(xiancheng)\n                if pan[1] == '循环':\n                    xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[2], pan[3], '循环'))\n                    xiancheng.start()\n                if pan[1] == '不循环':\n                    xiancheng = threading.Thread(target=zhixingbuzhoukuai, args=(pan[2], pan[3], '不循环'))\n                    xiancheng.start()\n            if pan[0] == '等待':\n                print('程序正在监测目标位置RGB值')\n        print('逻辑执行已全部执行完毕')\n        break\n    if choose == '逻辑块存储':\n        yorn = input(\"确定保存？\\n输入'yes'or'no'\\n\")\n        while 1:\n            if yorn == 'yes':\n                if len(panduans) == 0:\n                    print('还未记录你任何操作，请添加操作再使用逻辑块存储功能')\n                else:\n                    do_name = input('请为以上操作命名吧：')\n                    if '逻辑块存储' in do_name:\n                        do_name = input('抱歉，你的命名里不允许包含”逻辑块存储“，请重新命名')\n                    else:\n                        path = r\"{}逻辑块存储.txt\".format(do_name)\n                        listtotxt(list=panduans, path=path)\n                break\n            if yorn == 'no':\n                print('你已取消存储')\n                break\n            else:\n                yorn = input(\"请输入'yes'or'no'：\\n\")\n    if choose == '逻辑块导入':\n        caozuojiyi = get_caozuokuai_name()\n        while True:\n            xunhuan_choose = input('已存储的操作有：{}\\n请输入导入操作的操作名：'.format(caozuojiyi))\n            if xunhuan_choose in caozuojiyi:\n                break\n            else:\n                print('逻辑块存储库中并无你想要的操作，请重新输入：')\n        caozuopath = r\"{}逻辑块存储.txt\".format(xunhuan_choose)\n        panduans = txttolist(path=caozuopath)\n\n    if choose == 'q' or choose == 'quit' or choose == '退出' or choose == 'close':\n        break\n    if choose == 'tips' or choose == '提示' or choose == 'help' or choose == '帮助':\n        print(\n            '''你可以输入'点击', '右击', '中击', '逻辑执行', '判断', '滚动', '延时', '存储', '执行', '循环执行', '拖拽', '连点', '输入', '双击', '查看',\n                      '导入', 'q', 'quit','退出', 'close', 'tips', '提示', 'help', '帮助', '按键'来帮助你完成你的自动化操作''')\n    if not choose in ['点击', '右击', '中击', '逻辑执行', '判断', '滚动', '延时', '存储', '执行', '循环执行', '拖拽', '连点', '输入', '双击', '查看',\n                      '导入', 'q', 'quit','退出', 'close', 'tips', '提示', 'help', '帮助', '按键']:\n        print('你的输入有误或暂未开发此功能，请重新输入（输入”help“获得提示）')\nprint('代码已全部执行完毕,程序已退出')\n</code></pre>\n<p><span style=\"color:#fe2c24;\">这是我的2.0版本，之前把逻辑板块之外的功能都写出来了之后迫不及待地玩了一下，帮朋友买了四价，做了微信信息轰炸的程序，看着鼠标把文件夹拖来拖去，做了些拳皇脚本打出超级连招，等会我再试一下盲僧的马氏三角杀哈哈哈，想想就兴奋~~</span></p>\n<p>本来还想做多点功能的，比如：检测目标区域的文字来执行判断操作（这听起来不难）；</p>\n<p>写个语音输入功能，当执行完什么操作了就让电脑说：“你好厉害啊”、“真的是我的偶像”、“快来看看我抢到四价了”(现在我就能写出来)；</p>\n<pre><code class=\"language-python\">import pyttsx3\nengine = pyttsx3.init()\nengine.say('我抢到了!快来看一下')\nengine.runAndWait()</code></pre>\n<p>当然暂时还没有这些需求，如果我哪天有空就再更新到3.0版本哈，你们感兴趣的可以自己添加功能，至少我语音功能的逻辑代码已经给你们了。真不是懒【偷笑】</p>\n<p>艾玛，居然发了三万多字了，不聊了不聊了。</p>\n<p>不过都发这么多了，最后还是麻烦关注、点赞、收藏下哈。我喜欢在我的博客上分享一些有趣的代码，我跟别人不一样，我不卖课~~纯分享~~喜欢回复私信和留言~~~~     </p>\n<p style=\"text-align:center;\"><span style=\"color:#fe2c24;\">不定期更新~~~~</span></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-04 01:00:08", "summary": "前些天留意到我妈一直在预约四价疫苗都约不上，就想着写个程序来模拟人的操作去点击，判断疫苗是否被抢完，无限循环去刷新这个页面，一旦疫苗可预约就立马抢下来选择时间接种人。当预约成功后就语音循环播报：已经抢"}