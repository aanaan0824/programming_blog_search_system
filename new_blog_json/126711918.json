{"blogid": "126711918", "writerAge": "码龄1年", "writerBlogNum": "15", "writerCollect": "166", "writerComment": "188", "writerFan": "173", "writerGrade": "4级", "writerIntegral": "1092", "writerName": "C语言的前男友", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126711918.jpg", "writerRankTotal": "21445", "writerRankWeekly": "556", "writerThumb": "354", "writerVisitNum": "31757", "blog_read_count": "227", "blog_time": "于 2022-09-05 22:04:37 发布", "blog_title": "C语言深度剖析——bool类型，浮点数相等比较。", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BA%8F%E8%A8%80%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BA%8F%E8%A8%80%EF%BC%9A\">序言：</a></p>\n<p id=\"%E4%B8%80.bool%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.bool%E7%B1%BB%E5%9E%8B\">一.bool类型</a></p>\n<p id=\"%EF%BC%881%EF%BC%89C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89bool%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%EF%BC%881%EF%BC%89C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89bool%E7%B1%BB%E5%9E%8B%EF%BC%9F\">（1）C语言中到底有没有bool类型？</a></p>\n<p id=\"%EF%BC%882%EF%BC%89VS%E4%B8%AD%E7%9A%84BOOL%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%EF%BC%882%EF%BC%89VS%E4%B8%AD%E7%9A%84BOOL%E7%B1%BB%E5%9E%8B\">（2）VS中的BOOL类型</a></p>\n<p id=\"%E4%BA%8C.%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%200%20%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%200%20%E6%AF%94%E8%BE%83\">二.浮点数与 0 比较</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1-toc\" style=\"margin-left:40px;\"><a href=\"#%EF%BC%881%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1\">（1）浮点数的精度缺失</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc\" style=\"margin-left:40px;\"><a href=\"#%EF%BC%882%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">（2）浮点数判断相等解决方案</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%200-toc\" style=\"margin-left:40px;\"><a href=\"#%EF%BC%883%EF%BC%89%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%200\">（3）判断浮点数是否为 0</a></p>\n<p id=\"%E6%9C%80%E5%90%8E%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%9C%80%E5%90%8E%EF%BC%9A\">最后：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%BA%8F%E8%A8%80%EF%BC%9A\"><span style=\"color:#4da8ee;\">序言：</span></h1>\n<p><span style=\"color:#a2e043;\">C语言中有很多类型，但是bool我们至今也没有见过。那到底C语言中到底有没有bool类型呢？</span></p>\n<p><span style=\"color:#ff9900;\">我们之前聊过浮点数的在内存中的存储问题，由于浮点数在内存中比较特殊的存储结构，也造成了浮点数在判断相等的时候，有着比较特殊的比较方法。今天我们也就聊一聊这两个问题。</span></p>\n<h1 id=\"%E4%B8%80.bool%E7%B1%BB%E5%9E%8B\"><span style=\"color:#4da8ee;\">一.bool类型</span></h1>\n<h2 id=\"%EF%BC%881%EF%BC%89C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89bool%E7%B1%BB%E5%9E%8B%EF%BC%9F\"><span style=\"color:#38d8f0;\">（1）C语言中到底有没有bool类型？</span></h2>\n<p><span style=\"color:#ff9900;\">c99之前，主要是c90标准是没有的，目前大部分书，都是认为没有的。因为书，一般都要落后于行业。</span><br/><span style=\"color:#956fe7;\">但是c99引入了_Bool类型（你没有看错，_Bool就是一个类型，不过在新增头文件stdbool.h中，被重新用宏写成了bool，为了保证C/C++兼容性）。</span></p>\n<p>演示代码：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;stdbool.h&gt;\nint main()\n{\n\t_Bool ret1 = false;\n\t_Bool ret2 = true;\n\n\tbool ret3 = false;\n\tbool ret4 = true;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"277\" src=\"..\\..\\static\\image\\463a904916204eef8e7790d2859a24b5.png\" width=\"642\"/></p>\n<p> 这两种写法当然都是正确的，都能编译通过。只不过bool是_Bool宏定义。</p>\n<p><img alt=\"\" height=\"365\" src=\"..\\..\\static\\image\\97d3938cf2b84092b48b3b2eaef77abb.png\" width=\"554\"/></p>\n<p> <img alt=\"\" height=\"314\" src=\"..\\..\\static\\image\\40fefdcdffa145689dec5cadf0842eba.png\" width=\"556\"/></p>\n<p> 那么我们就可以来看一看bool类型占用几个字节，</p>\n<p><img alt=\"\" height=\"233\" src=\"..\\..\\static\\image\\f0b19a683b4b4dac9c3e9e26efa337fd.png\" width=\"547\"/></p>\n<p> <img alt=\"\" height=\"219\" src=\"..\\..\\static\\image\\35e8b1abc1184060b06b5e33a4a2f76e.png\" width=\"548\"/></p>\n<p> <span style=\"color:#a2e043;\">我们查看 true 和 false 底层也是用 0 和 1 宏定义的。</span></p>\n<p> <span style=\"color:#956fe7;\">占用一个字节，理论上也就不难理解，表示真假一个bit就够了，不过这个问题还得取决于编译器，VS2013，VS2017，VS2019，VS2022，都认为是一个字节。</span></p>\n<p><span style=\"color:#ff9900;\">但是因为，目前编译器对C99特性的支持并不全面，所以我们在编码的时候，还是以C90的认识去编码就可以了，使用整形的方式表示真假，0表示假，非0表示真。</span></p>\n<h2 id=\"%EF%BC%882%EF%BC%89VS%E4%B8%AD%E7%9A%84BOOL%E7%B1%BB%E5%9E%8B\"><span style=\"color:#38d8f0;\">（2）VS中的BOOL类型</span></h2>\n<p>我们来看一段代码：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;stdbool.h&gt;\n#include&lt;Windows.h&gt;\nint main()\n{\n\tBOOL ret = true;\n\t\n\tprintf(\"%d\\n\", sizeof(BOOL));\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#ff9900;\"> BOOL类型包含在我们的头文件 windows.h 里面。</span></p>\n<p><img alt=\"\" height=\"336\" src=\"..\\..\\static\\image\\259c4c7f0c224fa489388a9df30420a0.png\" width=\"592\"/></p>\n<p><span style=\"color:#38d8f0;\"> </span><span style=\"color:#956fe7;\">我们发现，竟然也能编过。。。什么鬼？？</span><br/><span style=\"color:#ff9900;\">这都是Microsoft自己搞的一套BOOL值。在vs中转到BOOL对应的头文件，翻到最上面，就能看到微软的版权信息。</span><span style=\"color:#a2e043;\">好了，该听谁的？？微软？强烈不推荐，用微软的标准微软也不能给我们发offer，一个好的习惯是：一定要保证代码的跨平台性，微软定义的专属类型，其他平台不支持。为了保证代码跨平台性，以后如果有使用的话，还是选择使用C99标准。</span></p>\n<h1 id=\"%E4%BA%8C.%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%200%20%E6%AF%94%E8%BE%83\"><span style=\"color:#4da8ee;\">二.浮点数与 0 比较</span></h1>\n<h2 id=\"%EF%BC%881%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1\"><span style=\"color:#38d8f0;\">（1）浮点数的精度缺失</span></h2>\n<p><span style=\"color:#ff9900;\">我们之前讲过浮点数的存储问题了，我们知道浮点数在往计算机的存储的时候都是二进制的存储方式，但是有一些浮点数并不像我们想的，是完整存储的，在十进制转化成为二进制，是有可能有精度损失的。</span><span style=\"color:#a2e043;\">注意这里的损失，不是一味的减少了，还有可能增多。浮点数本身存储的时候，在计算不尽的时候，会“四舍五入”或者其他策略。</span></p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;stdbool.h&gt;\n#include&lt;Windows.h&gt;\nint main()\n{\n\tdouble x = 3.6;\n\tprintf(\"%.50f\\n\", x);\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\b5f6790a692c4d6482277a3b4dd617a2.png\" width=\"913\"/></p>\n<p> 看一段代码：</p>\n<p><span style=\"color:#ff9900;\">大家可以猜一下结果，结果一定会让你大吃一惊！！</span></p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\nint main()\n{\n\tdouble x = 1.0;\n\tdouble y = 0.1;\n\tprintf(\"%.50f\\n\", x - 0.9);\n\tprintf(\"%.50f\\n\", y);\n\tif ((x - 0.9) == y) {\n\t\tprintf(\"you can see me!\\n\");\n\t}\n\telse {\n\t\tprintf(\"oops\\n\");\n\t}\n\treturn 0;\n}</code></pre>\n<p> 运行结果：<img alt=\"\" height=\"456\" src=\"..\\..\\static\\image\\30e669f8e1fc44328e45de5bf22783fc.png\" width=\"1000\"/></p>\n<p> <span style=\"color:#fe2c24;\"><strong>所以使用 == 直接对浮点数经行比较是强烈不建议的。</strong></span></p>\n<h2 id=\"%EF%BC%882%EF%BC%89%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span style=\"color:#38d8f0;\">（2）浮点数判断相等解决方案</span></h2>\n<p><span style=\"color:#a2e043;\">那么两个浮点数该如何比较呢？应该进行范围精度比较。</span></p>\n<pre><code class=\"language-cpp\">//伪代码\nif((x-y) &gt; -精度 &amp;&amp; (x-y) &lt; 精度)\n{\n  //TODO\n}\n//伪代码-简洁版\nif(fabs(x-y) &lt; 精度)\n{ //fabs是浮点数求绝对值，在头文件 math.h 里面。\n  //TODO\n}</code></pre>\n<p><span style=\"color:#fe2c24;\">精度：</span><br/><span style=\"color:#ff9900;\">自己设置？后面如果有需要，可以试试，通常是宏定义。<br/> 使用系统精度？暂时推荐</span><br/>  </p>\n<pre><code class=\"language-cpp\">#include&lt;float.h&gt; //使用下面两个精度，需要包含该头文件\nDBL_EPSILON //double 最小精度\nFLT_EPSILON //float 最小精度</code></pre>\n<p>代码调整后：</p>\n<p><img alt=\"\" height=\"511\" src=\"..\\..\\static\\image\\905fe9c8deb347e5adfc3113c6203e97.png\" width=\"1074\"/></p>\n<p><span style=\"color:#ff9900;\">这里的 DBL_EPSILON 和 FLT_EPSILON可以理解为微积分中的一个概念——无穷小量，他是改变一个数大小的最小值。那自然当我们需要判断两个数是否相等时，只要判断他们差的绝对值是否小于FLT_EPSILON或者DBL_EPSILON；</span></p>\n<h2 id=\"%EF%BC%883%EF%BC%89%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%200\"><span style=\"color:#38d8f0;\">（3）判断浮点数是否为 0</span></h2>\n<p>只要判断是否小于最小精度</p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;  //必须包含math.h,要不然无法使用fabs\n#include &lt;float.h&gt;  //必须包含，要不然无法使用系统精度\nint main()\n{\n\tdouble x = 0.000001;\n\tdouble y = 0.00000000000000000000000000000001;\n\tif (fabs(x) &lt; DBL_EPSILON)\n\t{\n\t\tprintf(\"you can see me!\\n\");\n\t}\n\tif(fabs(y)&lt;DBL_EPSILON)\n\t{\n\t\tprintf(\"bye\\n\");\n\t}\n\treturn 0;\n}</code></pre>\n<p> 运行结果：</p>\n<p><img alt=\"\" height=\"505\" src=\"..\\..\\static\\image\\8784f8cf7f2047f4a60d43c0a6a3a383.png\" width=\"1097\"/></p>\n<p><span style=\"color:#fe2c24;\">x &gt; -DBL_EPSILON &amp;&amp; x &lt; DBL_EPSILON: 为何不是&gt;= &amp;&amp; &lt;= 呢？</span><span style=\"color:#a2e043;\">个人看法：XXX_EPSILON是最小误差,是：XXX_EPSILON+n不等于n的最小的正数。XXX_EPSILON+n不等于n的最小的正数: 有很多数字+n都可以不等于n，但是XXX_EPSILON是最小的，but，XXX_EPSILON依旧是引起不等的一员。</span><span style=\"color:#38d8f0;\">换句话说：fabs(x) &lt;= DBL_EPSILON(确认x是否是0的逻辑)，如果=，就说明x本身，已经能够引起其他和他+-的数据本身的变化了，这个不符合0的概念。</span></p>\n<h1 id=\"%E6%9C%80%E5%90%8E%EF%BC%9A\"><span style=\"color:#4da8ee;\">最后：</span></h1>\n<p><span style=\"color:#ff9900;\">把意念深潜得下，何理不可得，把志气奋发起，何事不可做。击败焦虑的最好的办法就是学习，加油，诸君，山顶见！！</span></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 22:04:37", "summary": "目录序言：一类型语言中到底有没有类型？中的类型二浮点数与比较浮点数的精度缺失浮点数判断相等解决方案判断浮点数是否为最后：序言：语言中有很多类型，但是我们至今也没有见过。那到底语言中到底有没有类型呢？我"}