{"blogid": "126088219", "writerAge": "码龄2年", "writerBlogNum": "48", "writerCollect": "669", "writerComment": "1135", "writerFan": "1942", "writerGrade": "5级", "writerIntegral": "2353", "writerName": "广龙宇", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126088219.jpg", "writerRankTotal": "8128", "writerRankWeekly": "115", "writerThumb": "618", "writerVisitNum": "1805865", "blog_read_count": "20244", "blog_time": "于 2022-08-02 07:12:00 发布", "blog_title": "【一起学Rust | 设计模式】新类型模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\c25d1bdfde5f45a78978e3c27a3cac87.png\"/></p>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_6\">前言</a></li><li><a href=\"#_15\">一、新类型模式</a></li><li><ul><li><a href=\"#1__19\">1. 新类型模式的实现</a></li><li><a href=\"#2__22\">2. 官方例子</a></li><li><a href=\"#3__60\">3. 使用动机</a></li><li><a href=\"#4__65\">4. 优点</a></li><li><a href=\"#5__72\">5. 缺点</a></li></ul>\n</li><li><a href=\"#_75\">二、应用</a></li><li><ul><li><a href=\"#1_76\">1.标识符分离</a></li><li><a href=\"#2_115\">2.为新类型添加功能</a></li><li><a href=\"#3__127\">3. 限制类型内容</a></li><li><a href=\"#4__150\">4. 处理包之间特质和结构体的关系</a></li></ul>\n</li><li><a href=\"#_184\">总结</a></li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_6\"></a>前言</h1>\n<p>新的类型模式提供封装以及保证在编译时提供正确类型的值。新类型模式有多种用途和好处，比如可以处理不同的crate中的结构体和特质的关系。本期我们将一起探讨一下Rust设计模式中的新类型模式。</p>\n<blockquote>\n<p>本期内容是学习Rust设计模式笔记</p>\n</blockquote>\n<hr/>\n<h1><a id=\"_15\"></a>一、新类型模式</h1>\n<p>如果在某些情况下，我们希望一个类型的行为类似于另一种类型，或者在编译时强制执行某些行为，而实现这些仅使用类型别名是不够的。<br/> 例如，出于安全考虑 ，我们想要为String创建自定义实现。对于这种情况，我们可以使用该Newtype模式来提供<code>安全类型</code>和<code>封装 </code>。</p>\n<h2><a id=\"1__19\"></a>1. 新类型模式的实现</h2>\n<p>使用单个字段的元组来实现包装一个类型，使之称为一个新类型，而不是那个类型的别名，这样就可以拓展这个类型。</p>\n<h2><a id=\"2__22\"></a>2. 官方例子</h2>\n<p>下面这段代码来自《Rust设计模式》，只是伪代码，并未实现具体功能，但是描述了新类型模式的思想：使用元组来包装一个新类型，通过拓展这个新类型，来拓展原本类型的功能。Foo是一个基础类型，他有他本身的实现方法，Bar包装自Foo，它除了有Foo的特性，还为其实现了新的方法，通过测试，这两种类型，已然变成了两种独立的类型。</p>\n<pre><code class=\"prism language-rust\"><span class=\"token comment\">// 一个类型，可以是自己包里面的，也可以是别的包里面的。</span>\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Foo</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//..</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// Foo 类型的实现，这些实现在Bar里面是没有的，Bar是下面的类型。</span>\n    <span class=\"token comment\">//..</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 一个新类型，它包装自Foo</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Bar</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Bar</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 构造函数.</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span>\n        <span class=\"token comment\">//..</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">{<!-- --></span>\n\n        <span class=\"token comment\">//..</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//..</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token class-name\">Bar</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Foo和Bar类型不兼容，以下不进行类型检查。</span>\n    <span class=\"token comment\">// let f: Foo = b;</span>\n    <span class=\"token comment\">// let b: Bar = Foo { ... };</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"3__60\"></a>3. 使用动机</h2>\n<p>新类型的主要动机是抽象。它允许在精确控制接口的同时在类型之间共享实现细节。通过使用新类型而不是将实现类型作为 API 的一部分公开，它允许您向后兼容地更改实现。</p>\n<p>这样就是区分同一个类型不同含义，就比如<code>f64</code>类型，可以定义成米，或者千米等不同的类型。</p>\n<h2><a id=\"4__65\"></a>4. 优点</h2>\n<p>新类型是一种零成本的抽象——没有运行时开销。</p>\n<p>新类型与包装类型是互不兼容的，因此用户不会混淆两种类型。</p>\n<p>Rust的隐私系统确保用户不会访问到包装了的类型，他的字段默认是私有的。</p>\n<h2><a id=\"5__72\"></a>5. 缺点</h2>\n<p>没有语言支持，因此包装类型的每一个方法都必须写一个传递方法，来使用包装类型的方法。并且要为每一个实现了的特质来写传递方法。这样就显得极为复杂。</p>\n<h1><a id=\"_75\"></a>二、应用</h1>\n<h2><a id=\"1_76\"></a>1.标识符分离</h2>\n<p>假设我们有一个用户id，他是无符号整数类型的<code>usize</code>。我们系统对用户操作都是通过这个用户id来实现的。就比如我们有这么一个方法：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_user_id_from_username</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token keyword\">usize</span>\n</code></pre>\n<p>如果我们还要对用户的帖子进行操作，那么代码应该这么写</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> user_id<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span> <span class=\"token operator\">=</span> <span class=\"token function\">get_user_id_from_username</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> post_id<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span> <span class=\"token operator\">=</span> <span class=\"token function\">get_last_post</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">delete_post</span><span class=\"token punctuation\">(</span>post_id<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">delete_post</span><span class=\"token punctuation\">(</span>user_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>此时我们使用<code>delete_post</code>删除用户帖子，但是不小心传入了用户id，这就很麻烦了，这样辨识度就很不好，为了提高辨识度，我们使用<code>新类型模式</code>来区分两个类型：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">UserId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">pub</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>然后让<code>get_user_id_from_username</code>返回该类型，</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_user_id_from_username</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">UserId</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">let</span> user_id<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">...</span>\n\t<span class=\"token class-name\">UserId</span><span class=\"token punctuation\">(</span>user_id<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里做了如下改动<br/> <img alt=\"\" src=\"..\\..\\static\\image\\95da90d152df43d58aad134d51ca06d7.png\"/>这样在我们写错代码的时候就会这么提示了</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\def27fb6d86b40d5a4e57753b2e501af.png\"/><br/> 新类型模式在编译时强制执行类型安全，而在运行时没有任何性能开销。</p>\n<h2><a id=\"2_115\"></a>2.为新类型添加功能</h2>\n<p>现在有如下需求，需要为用户设置个“禁止登录”的用户列表。考虑使用<code>HashSet</code>实现，我们定义的代码如下</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> banned_users<span class=\"token punctuation\">:</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">UserId</span><span class=\"token operator\">&gt;</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">HashSet</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>但是光这一点是无法编译的，我们的UserId并没有想等，哈希等行为。我们可以使用内置派生宏来实现这些行为，会自动基于我们的结构体来生成这些实现，代码如下，</p>\n<pre><code class=\"prism language-rust\"><span class=\"token attribute attr-name\">#[derive(PartialEq, Eq, Hash)]</span>\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">UserId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"3__127\"></a>3. 限制类型内容</h2>\n<p>有时候我们需要对用户名进行校验，比如我们需要用户名全部都是由小写字母组成的。现在我们来将String类型来定义成一个新类型，Username</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Username</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>然后创建个创建用户名的唯一方法，我们使用TryFrom特质</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">impl</span> <span class=\"token class-name\">TryFrom</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">for</span> <span class=\"token class-name\">Username</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">type</span> <span class=\"token type-definition class-name\">Error</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">try_from</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">Self</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">Self</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">chars</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>object <span class=\"token class-name\">Object</span><span class=\"token punctuation\">]</span>c<span class=\"token punctuation\">[</span>object <span class=\"token class-name\">Object</span><span class=\"token punctuation\">]</span> <span class=\"token macro property\">matches!</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token char\">'a'</span><span class=\"token punctuation\">..=</span><span class=\"token char\">'z'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t\t<span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Username</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t\t<span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里重写了try_from行为，在类型转换时就已经对username进行了检测构造符合条件的用户名</p>\n<h2><a id=\"4__150\"></a>4. 处理包之间特质和结构体的关系</h2>\n<p>在使用外部特质时我们可能会遇到以下问题<br/> <img alt=\"\" src=\"..\\..\\static\\image\\4b7f5e625c9a4b93a4d9007c7dd3e920.png\"/><br/> 在我们的crate中使用MyTrait时，编译器就不知道我们用的是crate3中的MyTrait还是crate4中的MyTrait。Rust有一套《孤儿规则》专门来处理这种情况，我们会在后期的文章中说明。</p>\n<p>现在我们使用<code>新类型模式</code>来实现外来结构体特质，或者拓展特质。</p>\n<p>在某crate包中有如下特质</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">trait</span> <span class=\"token type-definition class-name\">ToTree</span> <span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">very_useful_function</span><span class=\"token punctuation\">(</span>something<span class=\"token punctuation\">:</span> <span class=\"token keyword\">impl</span> <span class=\"token class-name\">ToTree</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// ..</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在我们的crate中这么写</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Wrapper</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">pub</span> crate_y<span class=\"token punctuation\">[</span>object <span class=\"token class-name\">Object</span><span class=\"token punctuation\">]</span><span class=\"token class-name\">MyType</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">ToTree</span> <span class=\"token keyword\">for</span> <span class=\"token class-name\">Wrapper</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 使用</span>\n<span class=\"token function\">very_useful_function</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Wrapper</span><span class=\"token punctuation\">(</span>foreign_value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<hr/>\n<h1><a id=\"_184\"></a>总结</h1>\n<p>本期介绍了Rust设计模式中的<code>新类型模式</code>，并且指明了该设计模式的使用场景，其优点与缺点。并且通过一个实例来应用<code>新类型模式</code>，拓展包装类型的行为和特质，从而实现处理包与包之间结构体和特质的关系，限制类型内容等操作。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-02 07:12:00", "summary": "文章目录前言一、新类型模式新类型模式的实现官方例子使用动机优点缺点二、应用标识符分离为新类型添加功能限制类型内容处理包之间特质和结构体的关系总结前言新的类型模式提供封装以及保证在编译时提供正确类型的值"}