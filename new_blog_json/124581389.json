{"blogid": "124581389", "writerAge": "码龄134天", "writerBlogNum": "9", "writerCollect": "1065", "writerComment": "800", "writerFan": "4434", "writerGrade": "5级", "writerIntegral": "1658", "writerName": "梦执.py", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124581389.jpg", "writerRankTotal": "27012", "writerRankWeekly": "10456", "writerThumb": "599", "writerVisitNum": "43362", "blog_read_count": "7158", "blog_time": "已于 2022-05-19 23:40:55 修改", "blog_title": "python实现超级玛丽小游戏（动图演示+源码分享）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<table><tbody><tr><td>大家好，我是梦执，对梦执着。希望能和大家共同进步！</td></tr></tbody></table>\n<blockquote>\n<p>下面给大家带来python实现超级玛丽小游戏的源码分享</p>\n</blockquote>\n<p>效果演示：<br/><img alt=\"d61f3f0576034af9a5345be6da56e1ce.gif#pic_center\" src=\"https://img-blog.csdnimg.cn/d61f3f0576034af9a5345be6da56e1ce.gif#pic_center\"/></p>\n<div>\n<h3>基础源码</h3>\n<ul><li>\n<ul><li><a href=\"#1tools_10\">1.基础设置（tools部分）</a></li><li><a href=\"#2setup_158\">2.设置背景音乐以及场景中的文字（setup部分）</a></li><li><a href=\"#3load_screen_184\">3.设置游戏规则(load_screen)</a></li><li><a href=\"#4main_menu_294\">4.设置游戏内菜单等（main_menu）</a></li><li><a href=\"#5main_429\">5.main()</a></li><li><a href=\"#6_450\">6.调用以上函数实现</a></li></ul></li></ul>\n</div>\n<p> </p>\n<h2>1.基础设置（tools部分）</h2>\n<blockquote>\n<p>这个部分设置马里奥以及游戏中蘑菇等怪的的移动设置。</p>\n</blockquote>\n<pre><code class=\"language-python\">import os\nimport pygame as pg\n\nkeybinding = {\n    'action':pg.K_s,\n    'jump':pg.K_a,\n    'left':pg.K_LEFT,\n    'right':pg.K_RIGHT,\n    'down':pg.K_DOWN\n}\n\nclass Control(object):\n    \"\"\"Control class for entire project. Contains the game loop, and contains\n    the event_loop which passes events to States as needed. Logic for flipping\n    states is also found here.\"\"\"\n    def __init__(self, caption):\n        self.screen = pg.display.get_surface()\n        self.done = False\n        self.clock = pg.time.Clock()\n        self.caption = caption\n        self.fps = 60\n        self.show_fps = False\n        self.current_time = 0.0\n        self.keys = pg.key.get_pressed()\n        self.state_dict = {}\n        self.state_name = None\n        self.state = None\n\n    def setup_states(self, state_dict, start_state):\n        self.state_dict = state_dict\n        self.state_name = start_state\n        self.state = self.state_dict[self.state_name]\n\n    def update(self):\n        self.current_time = pg.time.get_ticks()\n        if self.state.quit:\n            self.done = True\n        elif self.state.done:\n            self.flip_state()\n        self.state.update(self.screen, self.keys, self.current_time)\n\n    def flip_state(self):\n        previous, self.state_name = self.state_name, self.state.next\n        persist = self.state.cleanup()\n        self.state = self.state_dict[self.state_name]\n        self.state.startup(self.current_time, persist)\n        self.state.previous = previous\n\n\n    def event_loop(self):\n        for event in pg.event.get():\n            if event.type == pg.QUIT:\n                self.done = True\n            elif event.type == pg.KEYDOWN:\n                self.keys = pg.key.get_pressed()\n                self.toggle_show_fps(event.key)\n            elif event.type == pg.KEYUP:\n                self.keys = pg.key.get_pressed()\n            self.state.get_event(event)\n\n\n    def toggle_show_fps(self, key):\n        if key == pg.K_F5:\n            self.show_fps = not self.show_fps\n            if not self.show_fps:\n                pg.display.set_caption(self.caption)\n\n\n    def main(self):\n        \"\"\"Main loop for entire program\"\"\"\n        while not self.done:\n            self.event_loop()\n            self.update()\n            pg.display.update()\n            self.clock.tick(self.fps)\n            if self.show_fps:\n                fps = self.clock.get_fps()\n                with_fps = \"{} - {:.2f} FPS\".format(self.caption, fps)\n                pg.display.set_caption(with_fps)\n\n\nclass _State(object):\n    def __init__(self):\n        self.start_time = 0.0\n        self.current_time = 0.0\n        self.done = False\n        self.quit = False\n        self.next = None\n        self.previous = None\n        self.persist = {}\n\n    def get_event(self, event):\n        pass\n\n    def startup(self, current_time, persistant):\n        self.persist = persistant\n        self.start_time = current_time\n\n    def cleanup(self):\n        self.done = False\n        return self.persist\n\n    def update(self, surface, keys, current_time):\n        pass\n\n\n\ndef load_all_gfx(directory, colorkey=(255,0,255), accept=('.png', 'jpg', 'bmp')):\n    graphics = {}\n    for pic in os.listdir(directory):\n        name, ext = os.path.splitext(pic)\n        if ext.lower() in accept:\n            img = pg.image.load(os.path.join(directory, pic))\n            if img.get_alpha():\n                img = img.convert_alpha()\n            else:\n                img = img.convert()\n                img.set_colorkey(colorkey)\n            graphics[name]=img\n    return graphics\n\n\ndef load_all_music(directory, accept=('.wav', '.mp3', '.ogg', '.mdi')):\n    songs = {}\n    for song in os.listdir(directory):\n        name,ext = os.path.splitext(song)\n        if ext.lower() in accept:\n            songs[name] = os.path.join(directory, song)\n    return songs\n\n\ndef load_all_fonts(directory, accept=('.ttf')):\n    return load_all_music(directory, accept)\n\n\ndef load_all_sfx(directory, accept=('.wav','.mpe','.ogg','.mdi')):\n    effects = {}\n    for fx in os.listdir(directory):\n        name, ext = os.path.splitext(fx)\n        if ext.lower() in accept:\n            effects[name] = pg.mixer.Sound(os.path.join(directory, fx))\n    return effects\n</code></pre>\n<h2>2.设置背景音乐以及场景中的文字（setup部分）</h2>\n<blockquote>\n<p>该部分主要设置场景中的背景音乐，以及字体的显示等设置。</p>\n</blockquote>\n<pre><code class=\"language-python\">import os\nimport pygame as pg\nfrom . import tools\nfrom .import constants as c\n\nORIGINAL_CAPTION = c.ORIGINAL_CAPTION\n\n\nos.environ['SDL_VIDEO_CENTERED'] = '1'\npg.init()\npg.event.set_allowed([pg.KEYDOWN, pg.KEYUP, pg.QUIT])\npg.display.set_caption(c.ORIGINAL_CAPTION)\nSCREEN = pg.display.set_mode(c.SCREEN_SIZE)\nSCREEN_RECT = SCREEN.get_rect()\n\n\nFONTS = tools.load_all_fonts(os.path.join(\"resources\",\"fonts\"))\nMUSIC = tools.load_all_music(os.path.join(\"resources\",\"music\"))\nGFX   = tools.load_all_gfx(os.path.join(\"resources\",\"graphics\"))\nSFX   = tools.load_all_sfx(os.path.join(\"resources\",\"sound\"))\n</code></pre>\n<h2>3.设置游戏规则(load_screen)</h2>\n<pre><code class=\"language-python\">from .. import setup, tools\nfrom .. import constants as c\nfrom .. import game_sound\nfrom ..components import info\n\n\nclass LoadScreen(tools._State):\n    def __init__(self):\n        tools._State.__init__(self)\n\n    def startup(self, current_time, persist):\n        self.start_time = current_time\n        self.persist = persist\n        self.game_info = self.persist\n        self.next = self.set_next_state()\n\n        info_state = self.set_overhead_info_state()\n\n        self.overhead_info = info.OverheadInfo(self.game_info, info_state)\n        self.sound_manager = game_sound.Sound(self.overhead_info)\n\n\n    def set_next_state(self):\n        \"\"\"Sets the next state\"\"\"\n        return c.LEVEL1\n\n    def set_overhead_info_state(self):\n        \"\"\"sets the state to send to the overhead info object\"\"\"\n        return c.LOAD_SCREEN\n\n\n    def update(self, surface, keys, current_time):\n        \"\"\"Updates the loading screen\"\"\"\n        if (current_time - self.start_time) &lt; 2400:\n            surface.fill(c.BLACK)\n            self.overhead_info.update(self.game_info)\n            self.overhead_info.draw(surface)\n\n        elif (current_time - self.start_time) &lt; 2600:\n            surface.fill(c.BLACK)\n\n        elif (current_time - self.start_time) &lt; 2635:\n            surface.fill((106, 150, 252))\n\n        else:\n            self.done = True\n\n\n\n\nclass GameOver(LoadScreen):\n    \"\"\"A loading screen with Game Over\"\"\"\n    def __init__(self):\n        super(GameOver, self).__init__()\n\n\n    def set_next_state(self):\n        \"\"\"Sets next state\"\"\"\n        return c.MAIN_MENU\n\n    def set_overhead_info_state(self):\n        \"\"\"sets the state to send to the overhead info object\"\"\"\n        return c.GAME_OVER\n\n    def update(self, surface, keys, current_time):\n        self.current_time = current_time\n        self.sound_manager.update(self.persist, None)\n\n        if (self.current_time - self.start_time) &lt; 7000:\n            surface.fill(c.BLACK)\n            self.overhead_info.update(self.game_info)\n            self.overhead_info.draw(surface)\n        elif (self.current_time - self.start_time) &lt; 7200:\n            surface.fill(c.BLACK)\n        elif (self.current_time - self.start_time) &lt; 7235:\n            surface.fill((106, 150, 252))\n        else:\n            self.done = True\n\n\nclass TimeOut(LoadScreen):\n    \"\"\"Loading Screen with Time Out\"\"\"\n    def __init__(self):\n        super(TimeOut, self).__init__()\n\n    def set_next_state(self):\n        \"\"\"Sets next state\"\"\"\n        if self.persist[c.LIVES] == 0:\n            return c.GAME_OVER\n        else:\n            return c.LOAD_SCREEN\n\n    def set_overhead_info_state(self):\n        \"\"\"Sets the state to send to the overhead info object\"\"\"\n        return c.TIME_OUT\n\n    def update(self, surface, keys, current_time):\n        self.current_time = current_time\n\n        if (self.current_time - self.start_time) &lt; 2400:\n            surface.fill(c.BLACK)\n            self.overhead_info.update(self.game_info)\n            self.overhead_info.draw(surface)\n        else:\n            self.done = True\n</code></pre>\n<h2>4.设置游戏内菜单等（main_menu）</h2>\n<pre><code class=\"language-python\">\nimport pygame as pg\nfrom .. import setup, tools\nfrom .. import constants as c\nfrom .. components import info, mario\n\n\nclass Menu(tools._State):\n    def __init__(self):\n        \"\"\"Initializes the state\"\"\"\n        tools._State.__init__(self)\n        persist = {c.COIN_TOTAL: 0,\n                   c.SCORE: 0,\n                   c.LIVES: 3,\n                   c.TOP_SCORE: 0,\n                   c.CURRENT_TIME: 0.0,\n                   c.LEVEL_STATE: None,\n                   c.CAMERA_START_X: 0,\n                   c.MARIO_DEAD: False}\n        self.startup(0.0, persist)\n\n    def startup(self, current_time, persist):\n        \"\"\"Called every time the game's state becomes this one.  Initializes\n        certain values\"\"\"\n        self.next = c.LOAD_SCREEN\n        self.persist = persist\n        self.game_info = persist\n        self.overhead_info = info.OverheadInfo(self.game_info, c.MAIN_MENU)\n\n        self.sprite_sheet = setup.GFX['title_screen']\n        self.setup_background()\n        self.setup_mario()\n        self.setup_cursor()\n\n\n    def setup_cursor(self):\n        \"\"\"Creates the mushroom cursor to select 1 or 2 player game\"\"\"\n        self.cursor = pg.sprite.Sprite()\n        dest = (220, 358)\n        self.cursor.image, self.cursor.rect = self.get_image(\n            24, 160, 8, 8, dest, setup.GFX['item_objects'])\n        self.cursor.state = c.PLAYER1\n\n\n    def setup_mario(self):\n        \"\"\"Places Mario at the beginning of the level\"\"\"\n        self.mario = mario.Mario()\n        self.mario.rect.x = 110\n        self.mario.rect.bottom = c.GROUND_HEIGHT\n\n\n    def setup_background(self):\n        \"\"\"Setup the background image to blit\"\"\"\n        self.background = setup.GFX['level_1']\n        self.background_rect = self.background.get_rect()\n        self.background = pg.transform.scale(self.background,\n                                   (int(self.background_rect.width*c.BACKGROUND_MULTIPLER),\n                                    int(self.background_rect.height*c.BACKGROUND_MULTIPLER)))\n        self.viewport = setup.SCREEN.get_rect(bottom=setup.SCREEN_RECT.bottom)\n\n        self.image_dict = {}\n        self.image_dict['GAME_NAME_BOX'] = self.get_image(\n            1, 60, 176, 88, (170, 100), setup.GFX['title_screen'])\n\n\n\n    def get_image(self, x, y, width, height, dest, sprite_sheet):\n        \"\"\"Returns images and rects to blit onto the screen\"\"\"\n        image = pg.Surface([width, height])\n        rect = image.get_rect()\n\n        image.blit(sprite_sheet, (0, 0), (x, y, width, height))\n        if sprite_sheet == setup.GFX['title_screen']:\n            image.set_colorkey((255, 0, 220))\n            image = pg.transform.scale(image,\n                                   (int(rect.width*c.SIZE_MULTIPLIER),\n                                    int(rect.height*c.SIZE_MULTIPLIER)))\n        else:\n            image.set_colorkey(c.BLACK)\n            image = pg.transform.scale(image,\n                                   (int(rect.width*3),\n                                    int(rect.height*3)))\n\n        rect = image.get_rect()\n        rect.x = dest[0]\n        rect.y = dest[1]\n        return (image, rect)\n\n\n    def update(self, surface, keys, current_time):\n        \"\"\"Updates the state every refresh\"\"\"\n        self.current_time = current_time\n        self.game_info[c.CURRENT_TIME] = self.current_time\n        self.update_cursor(keys)\n        self.overhead_info.update(self.game_info)\n\n        surface.blit(self.background, self.viewport, self.viewport)\n        surface.blit(self.image_dict['GAME_NAME_BOX'][0],\n                     self.image_dict['GAME_NAME_BOX'][1])\n        surface.blit(self.mario.image, self.mario.rect)\n        surface.blit(self.cursor.image, self.cursor.rect)\n        self.overhead_info.draw(surface)\n\n\n    def update_cursor(self, keys):\n        \"\"\"Update the position of the cursor\"\"\"\n        input_list = [pg.K_RETURN, pg.K_a, pg.K_s]\n\n        if self.cursor.state == c.PLAYER1:\n            self.cursor.rect.y = 358\n            if keys[pg.K_DOWN]:\n                self.cursor.state = c.PLAYER2\n            for input in input_list:\n                if keys[input]:\n                    self.reset_game_info()\n                    self.done = True\n        elif self.cursor.state == c.PLAYER2:\n            self.cursor.rect.y = 403\n            if keys[pg.K_UP]:\n                self.cursor.state = c.PLAYER1\n\n\n    def reset_game_info(self):\n        \"\"\"Resets the game info in case of a Game Over and restart\"\"\"\n        self.game_info[c.COIN_TOTAL] = 0\n        self.game_info[c.SCORE] = 0\n        self.game_info[c.LIVES] = 3\n        self.game_info[c.CURRENT_TIME] = 0.0\n        self.game_info[c.LEVEL_STATE] = None\n\n        self.persist = self.game_info\n</code></pre>\n<h2>5.main()</h2>\n<pre><code class=\"language-python\">from . import setup,tools\nfrom .states import main_menu,load_screen,level1\nfrom . import constants as c\n\n\ndef main():\n    \"\"\"Add states to control here.\"\"\"\n    run_it = tools.Control(setup.ORIGINAL_CAPTION)\n    state_dict = {c.MAIN_MENU: main_menu.Menu(),\n                  c.LOAD_SCREEN: load_screen.LoadScreen(),\n                  c.TIME_OUT: load_screen.TimeOut(),\n                  c.GAME_OVER: load_screen.GameOver(),\n                  c.LEVEL1: level1.Level1()}\n\n    run_it.setup_states(state_dict, c.MAIN_MENU)\n    run_it.main()\n</code></pre>\n<h2>6.调用以上函数实现</h2>\n<pre><code class=\"language-python\">import sys\nimport pygame as pg\nfrom 小游戏.超级玛丽.data.main import main\nimport cProfile\n\n\nif __name__=='__main__':\n    main()\n    pg.quit()\n    sys.exit()\n</code></pre>\n<blockquote>\n<p>在这里主要给大家展示主体的代码，完整资源可私聊我领取！！</p>\n</blockquote>\n<p> </p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-19 23:40:55", "summary": "大家好，我是梦执，对梦执着。希望能和大家共同进步！下面给大家带来实现超级玛丽小游戏的源码分享效果演示：基础源码基础设置部分设置背景音乐以及场景中的文字部分设置游戏规则设置游戏内菜单等调用以上函数实现基"}