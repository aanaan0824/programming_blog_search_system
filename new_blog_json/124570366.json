{"blogid": "124570366", "writerAge": "码龄9年", "writerBlogNum": "1", "writerCollect": "4", "writerComment": "1", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "11", "writerName": "迦拉谛", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124570366.jpg", "writerRankTotal": "240208", "writerRankWeekly": "461931", "writerThumb": "0", "writerVisitNum": "1512", "blog_read_count": "1507", "blog_time": "于 2022-05-04 23:02:32 发布", "blog_title": "在 Windows 下通过 CMake 使用 Boost 库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>介绍在Windows 下使用 Boost 的文章很多，但多是讲如何在Visual Studio 界面下直接操作的，这里介绍一下CMake 项目如何使用 Boost.</p>\n<p>本文使用的cmake 版本为 3.23.1</p>\n<h1>下载 Boost</h1>\n<p>Boost 最新版的下载地址为 <a href=\"https://www.boost.org/users/download/\" title=\"Boost Downloads\">Boost Downloads</a> 我写此文章的时候最新版本为1.79.0。按照 Boost 官方的介绍，.7z 的文件 比 .zip 要小一半，可以的话还是使用.7z 格式。</p>\n<p>Boost 的库分为两种，一种是Header only， 也就是只要 include 头文件就可以了。另一种需要提前构建，比如 boost_system、boost_log 等。而编译又分为编译成动态库与静态库两种形式。</p>\n<h1>Windows 动态库与静态库</h1>\n<p>开始之前先简单介绍一下动态库与静态库。</p>\n<p>所谓动态库，通常只看到DLL 文件，实际上动态库由.lib 文件 与 .dll 两部分组成 .lib 定义了动态库的内容，在程序连接的时候使用，.dll 才是真正的库文件，在运行的时候使用。</p>\n<p>静态库只有.lib 文件。在连接的时候，静态库的内容会被连接到应用程序中。在运行的时候不需要任何其它的文件支撑了。下面先介绍 boost 编译成动态还是静态库。</p>\n<h1>编译成静态库</h1>\n<p>Windows 上 boost 最简单的编译方法与 Linux 上是一致的。</p>\n<pre><code class=\"language-bash\">bootstrap\nb2 --prefix=c:\\Boost install </code></pre>\n<p>编译后 C:\\Boost 下会有两个目录，分别是 include 与 lib</p>\n<p>include 目录下的内容如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\26ff02e0622f47ec84d6fbb3bff86b70.png\"/></p>\n<p>lib 目录下的内容为：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\d3f27f02804a4f0ab9ce4f3c53542a2e.png\"/> </p>\n<p>可以看到每个文件均有前缀 lib，代表其是静态库。每个库由4个文件组成，分别代表了不同的编译选项：</p>\n<ul><li>vc142 编译器的名称与版本；</li><li>mt 支持多线程；</li><li>gd Debug 版，没有的为 Release 版；</li><li>x32/x64 64位版本还是32位版本；</li><li>1_79 boost 版本； </li></ul>\n<h1> 建立一个项目测试 boost</h1>\n<p>CMakeLists.txt 内容如下：</p>\n<pre><code>cmake_minimum_required(VERSION 3.23 FATAL_ERROR)\n\nproject(Compiling_Boost CXX)\n\n \nset(BOOST_ROOT C:/boost)\nset(Boost_LIBRARY_DIRS c:/boost/lib)\n\nfind_package(Boost 1.78 REQUIRED COMPONENTS regex)\n\nlink_directories(${Boost_LIBRARY_DIRS})\ninclude_directories(${Boost_INCLUDE_DIRS})\n\n\nmessage(Boost\\ version: ${Boost_VERSION_STRING})\nmessage(Boost\\ include\\ dir: ${Boost_INCLUDE_DIRS})\nmessage(Boost\\ library\\ dir: ${Boost_LIBRARY_DIRS})\n\nmessage(\"Found Boost Libraries:\")\nforeach(boost_lib IN LISTS Boost_LIBRARIES)\n    message(${boost_lib})\n    string(REGEX MATCH \".+/.*boost_([^-]+)-.+\\.(lib|a)\" boost_lib_name ${boost_lib})\n    set(boost_lib_name ${CMAKE_MATCH_1})\n    set(boost_target Boost::${boost_lib_name})\n    if(TARGET ${boost_target})\n        message(STATUS \"Boost target found: \" ${boost_target})\n    endif(TARGET ${boost_target})\nendforeach(boost_lib)\n\nadd_executable(regex regex.cpp)\n\n#cmake -G \"MinGW Makefiles\" ..</code></pre>\n<p> regex.cpp 的内容如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;boost/regex.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::string line;\n    boost::regex pat( \"^Subject: (Re: |Aw: )*(.*)\" );\n\n    while (std::cin)\n    {\n        std::getline(std::cin, line);\n        boost::smatch matches;\n        if (boost::regex_match(line, matches, pat))\n            std::cout &lt;&lt; matches[2] &lt;&lt; std::endl;\n    }\n}</code></pre>\n<p>编译并执行</p>\n<pre><code class=\"language-bash\">mkdir build\ncd build\ncmake ..\ncmake --build . --config Release</code></pre>\n<h1>编译动态库</h1>\n<p>因为我的项目确定要使用 64位多线程版本，因此使用下面的命令进行编译</p>\n<pre><code class=\"language-bash\">bootstrap\nb2 --layout=system variant=release -j 8 address-model=64 link=shared threading=multi --prefix=c:\\Boost install </code></pre>\n<p>注意里面的选项：</p>\n<ul><li>--layout 写定义了文件名的结构。支持 versioned、tagged、system 三种选项，缺省就是versioned 编译静态库时使用的就是缺省值，生成的文件名信息最全。tagged 文件名中不包含编译器名称与版本，本例中为vc142，也不包含boost 版本，本例中为1_79</li></ul>\n<p>        system 文件名最短，只有库名称。    </p>\n<ul><li>variant 可以是release 或 debug，也可以是 release, debug 两个都编译。本例中，因为 --layout=system，如果同时编译 release 与 debug 版本，文件名字相同，因此编译时只能选一种，否则会报错。variant 还有其它选项，可以看 b2 --help</li><li>j 8 编译时可用的线程数</li><li>address-model 不是多讲，编译 64 位版本。</li><li>link=shared 就是要编译成动态库。</li></ul>\n<p>看看编译后的结果</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\6eee7e522c0b4f2aa4530165ca64b88e.png\"/></p>\n<p>每一个库由两个文件组成，一个连接时使用的 .lib 另一个是运行时使用的 .dll</p>\n<p>由于是动态库，文件名前没有 lib 前缀。</p>\n<p>编译我们的例子：</p>\n<pre><code>C:\\src\\boost_test\\build&gt;cmake ..\n-- Building for: Visual Studio 16 2019\n-- Selecting Windows SDK version 10.0.19041.0 to target Windows 10.0.18363.\n-- The CXX compiler identification is MSVC 19.28.29920.0\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Tools/MSVC/14.28.29910/bin/Hostx64/x64/cl.exe - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Found Boost: C:/Boost/lib/cmake/Boost-1.79.0/BoostConfig.cmake (found suitable version \"1.79.0\", minimum required is \"1.78\") found components: regex\nBoost version:1.79.0\nBoost include dir:C:/Boost/include\nBoost library dir:c:/boost/lib\nFound Boost Libraries:\nBoost::regex\n-- Configuring done\n-- Generating done\n-- Build files have been written to: C:/src/boost_test/build\n\n\nC:\\src\\boost_test\\build&gt;cmake --build . --config Release\nMicrosoft (R) Build Engine version 16.9.2+58c36d143 for .NET Framework\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n  Checking Build System\n  Building Custom Rule C:/src/boost_test/CMakeLists.txt\n  regex.cpp\n  regex.vcxproj -&gt; C:\\src\\boost_test\\build\\Release\\regex.exe\n  Building Custom Rule C:/src/boost_test/CMakeLists.txt</code></pre>\n<p>regex 编译成功！</p>\n<h1>cmake 是如何工作的？</h1>\n<p>cmake 是如何确定要使用动态库还是静态库呢？方法有很多，可以整体设置，也可以一个库一个库的设置。我将一个项目从Linux 转到 Windows 时，刚开始编译连接的时候报错：boost_system.lib 没找到，好不容易将 boost 编译好了 boost_system.lib也找到了，又报 boost_log-vc142-mt-x64-1_79.lib 没找到，而它们都是用的同一个命令加入到项目中的。</p>\n<pre><code>target_link_libraries(mylib \n    boost_system\n    boost_log\n    boost_log_setup\n    boost_date_time)</code></pre>\n<p>cmake 通过如下几种方式设置连接要使用的库：</p>\n<ul><li>找到哪个就用哪个</li></ul>\n<p>这个最容易理解，在没有其它设置的情况下，尽量与项目中的其它设置相匹配，找到哪个就用哪个。</p>\n<p>至于如何找，不同的cmake 版本也稍有不同。不过C:\\Boost\\lib\\cmake 起了很大的作用。但是并不是所有的cmake 都支持这种方法，如果你的cmake 版本不支持此方法的话，在b2 时加上 --no-cmake-config 不生成此目录。</p>\n<ul><li>在CMakeLists.txt 中设置</li></ul>\n<p>单纯设置使用动态库，可以在CMakeLists 中加入</p>\n<pre><code>SET(BOOST_ALL_DYN_LINK ON)</code></pre>\n<p>也可以只指定一个库，比如 log</p>\n<pre><code>SET(BOOST_LOG_DYN_LINK ON)</code></pre>\n<p>在CMakeLists 中可设置的变量比较多，这里列几个例子，值得一提的是，这些设置要在find_package 之前进行设置，然后cmake 会按照这些设置去找对应的版本。详细信息可以参见 boost 官网 <a href=\"https://www.boost.org/doc/libs/1_79_0/libs/log/doc/html/log/installation/config.html\" title=\"Configuring and building the library - 1.79.0 (boost.org)\">Configuring and building the library - 1.79.0 (boost.org)</a></p>\n<pre><code>set(BUILD_SHARED_LIBS ON)\nset(Boost_USE_DEBUG_LIBS ON)\nset(Boost_USE_RELEASE_LIBS ON)\nset(Boost_USE_STATIC_LIBS OFF)\nset(Boost_USE_MULTITHREADED ON)\nset(Boost_USE_STATIC_RUNTIME OFF)\nset(Boost_USE_DEBUG_RUNTIME ON)\nset(Boost_COMPILER \"-vc142\")\nset(Boost_DEBUG ON)\n\nfind_package(Boost 1.79 REQUIRED COMPONENTS system log log_setup)</code></pre>\n<ul><li>在源代码中设置</li></ul>\n<p>此方法极其容易出问题，不到万不得已不要使用。我在此介绍此方法可不是为了让你使用它，而是实在找不到问题的时候，查查是不是别人使用了此方法。</p>\n<p>要在源代码中设置，就是在代码中加入以下语句：</p>\n<pre><code class=\"language-cpp\">#define BOOST_ALL_DYN_LINK 1</code></pre>\n<p>当然也可以只指定一个库</p>\n<pre><code class=\"language-cpp\">#define BOOST_LOG_DYN_LINK 1</code></pre>\n<h1>与runtime-link 的区别</h1>\n<p>强调一下，当我们说编译 boost 成动态库还是静态库时，还有一个概念也很容易混淆。运行时连接，它指的是在编译 boost 时，编译器使用的库，是否要编译到boost 库中。如果包含运行时库，也就是静态方式，编译出来的 boost 库，无论是动态还是静态，都不需要其它库支撑；而如果不包含运行时，动态运行时方式，编译出来的boost 库通常需要 MSVCRTXX.DLL 及MSVCPXX.DLL一类的文件才能运行。编译时b2的选项为 --runtime-link 对应 VC 的编译选项为 <code>Multithreaded</code> 或者 <code>Multithreaded DLL</code></p>\n<p>考虑到我们编译的是boost 而在使用boost 时通常也少不了运行时库，所以除非极特别情况，这一项就保持缺省值，具体细节留给编译器处理就好了。</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-04 23:02:32", "summary": "介绍在下使用的文章很多，但多是讲如何在界面下直接操作的，这里介绍一下项目如何使用本文使用的版本为下载最新版的下载地址为我写此文章的时候最新版本为。按照官方的介绍，的文件比要小一半，可以的话还是使用格式"}