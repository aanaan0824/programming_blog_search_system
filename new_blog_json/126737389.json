{"blogid": "126737389", "writerAge": "码龄111天", "writerBlogNum": "51", "writerCollect": "7", "writerComment": "2", "writerFan": "5", "writerGrade": "3级", "writerIntegral": "546", "writerName": "tt142", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126737389.jpg", "writerRankTotal": "35005", "writerRankWeekly": "7288", "writerThumb": "33", "writerVisitNum": "4152", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:57:44 发布", "blog_title": "【C语言】sizeof 和 strlen 深度解析，一文包会", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>其实我们之前就已经讲解过二者的具体差别，但是不够系统，我们当时只是说过，</p>\n<p>sizeof只是求（）里面所占空间的大小，单位是字节，与\\0无关</p>\n<p>strlen是求字符串长度，数组或者指针的形式都可以，看到\\0才会停止</p>\n<p>但是学到现在这个深度，你真的还认识他们吗？</p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.sizeof-toc\" style=\"margin-left:0px;\"><a href=\"#1.sizeof\">1.sizeof</a></p>\n<p id=\"2.strlen-toc\" style=\"margin-left:0px;\"><a href=\"#2.strlen\">2.strlen</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p>.范例讲解 </p>\n<h1>1.sizeof</h1>\n<pre><code class=\"language-cs\">int a[] = {1,2,3,4};\nprintf(\"%d\\n\",sizeof(a));\nprintf(\"%d\\n\",sizeof(a+0));\nprintf(\"%d\\n\",sizeof(*a));\nprintf(\"%d\\n\",sizeof(a+1));\nprintf(\"%d\\n\",sizeof(a[1]));\nprintf(\"%d\\n\",sizeof(&amp;a));\nprintf(\"%d\\n\",sizeof(*&amp;a));\nprintf(\"%d\\n\",sizeof(&amp;a+1));\nprintf(\"%d\\n\",sizeof(&amp;a[0]));\nprintf(\"%d\\n\",sizeof(&amp;a[0]+1));</code></pre>\n<p>是不是看到头都大了。</p>\n<p>不重要，我们先来仔细分析一下</p>\n<p>首先</p>\n<p>1.a是数组名</p>\n<p>我们简单回忆一下数组组名的作用</p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_71138261/article/details/126018166?spm=1001.2014.3001.5501\" title=\"https://blog.csdn.net/weixin_71138261/article/details/126018166?spm=1001.2014.3001.5501\">https://blog.csdn.net/weixin_71138261/article/details/126018166?spm=1001.2014.3001.5501</a></p>\n<p>这里正好符合<strong>数组名单独出现在sizeof内部</strong>的情况，所以就是整个元素</p>\n<p>但是整个数组的地址还是从第一个元素那里开始的，只不过+1的时候会跳过整个数组</p>\n<p>所以整个数组四个元素，一个int是四字节，4*4=16</p>\n<p>2.a+0</p>\n<p>看起来还是没变啊，和a有什么区别</p>\n<p>区别就是他<strong>没有单独放在sizeof内部</strong></p>\n<p>所以这个a就是一个简单的首元素地址，+0还是指向首元素地址，只要是地址就是4/8，32位机器是4,64位是8</p>\n<p>3.*a</p>\n<p>a还是首元素地址，解引用就是第一个元素，所以一个int类型字节是4</p>\n<p>4.a+1</p>\n<p>a是首元素地址，+1跳过一个元素的字节数，4，所以此时是第二个元素的地址，4/8，32位机器是4,64位是8（下面不再重复）</p>\n<p>5.a[1]</p>\n<p>第二个元素，所以一个int类型字节是4</p>\n<p>4.<strong>&amp;a</strong></p>\n<p>注意这里又是两种例外其中之一，&amp;a代表取出整个数组的地址，但是依然是地址4/8</p>\n<p>5.*&amp;a</p>\n<p>刚才说&amp;a是取出整个元素的地址，此时*就是取出整个数组，整个数组有4个元素，所以int类型字节数就是4*4=16</p>\n<p>6.&amp;a+1</p>\n<p>&amp;a是整个数组的地址+1跳过整个数组，但是依旧是地址的本质 4/8</p>\n<p>7.&amp;a[0]</p>\n<p>a会先和[]结合也就是第一个元素，再&amp;就是首元素的地址，4/8</p>\n<p>8.&amp;a[0]+1</p>\n<p>首元素地址+1跳过一个元素（4字节），但是还是地址4/8</p>\n<p>小结：</p>\n<pre><code class=\"language-cs\">int a[] = {1,2,3,4};\nprintf(\"%d\\n\",sizeof(a));    //16\n\nprintf(\"%d\\n\",sizeof(a+0));  //4/8\n\nprintf(\"%d\\n\",sizeof(*a));  //4\n\nprintf(\"%d\\n\",sizeof(a+1));  //4/8\n\nprintf(\"%d\\n\",sizeof(a[1])); //4\n\nprintf(\"%d\\n\",sizeof(&amp;a)); //4/8\n\nprintf(\"%d\\n\",sizeof(*&amp;a));  //16\n\nprintf(\"%d\\n\",sizeof(&amp;a+1));  //4/8\n\nprintf(\"%d\\n\",sizeof(&amp;a[0]));  //4/8\n\nprintf(\"%d\\n\",sizeof(&amp;a[0]+1)); //4/8</code></pre>\n<hr/>\n<p>这个小例子大家吃透了吗</p>\n<p>再来看一组sizeof的例子</p>\n<pre><code class=\"language-cs\">char arr[] = {'a','b','c','d','e','f'};\nprintf(\"%d\\n\", sizeof(arr));\nprintf(\"%d\\n\", sizeof(arr+0));\nprintf(\"%d\\n\", sizeof(*arr));\nprintf(\"%d\\n\", sizeof(arr[1]));\nprintf(\"%d\\n\", sizeof(&amp;arr));\nprintf(\"%d\\n\", sizeof(&amp;arr+1));\nprintf(\"%d\\n\", sizeof(&amp;arr[0]+1));</code></pre>\n<p>首先注意到是一个char类型的字符数组</p>\n<p>1.arr</p>\n<p>数组名单独放在数组内部，是整个数组</p>\n<p><strong>不是字符串，所以不会在结尾补充\\0，一共就是6个元素</strong></p>\n<p>1*6=6</p>\n<p>2.arr+0</p>\n<p>不单独放在sizeof里面 ，就是首元素的地址+0,4/8</p>\n<p>3.*arr</p>\n<p>arr是首元素地址，*之后是首元素，1字节</p>\n<p>4.arr[1]</p>\n<p>第二个元素，插入类型所以是1</p>\n<p>5.&amp;arr</p>\n<p>取出整个数组的地址，4/8</p>\n<p>6.&amp;arr+1</p>\n<p>跳过整个数组，是地址4/8</p>\n<p>7.&amp;arr[0]+1</p>\n<p>取出第一个元素的地址+1，跳过一个char，还是地址4/8</p>\n<p>小结</p>\n<pre><code class=\"language-cs\">char arr[] = {'a','b','c','d','e','f'}; \nprintf(\"%d\\n\", sizeof(arr));  //6\n\nprintf(\"%d\\n\", sizeof(arr+0)); //4/8\n\nprintf(\"%d\\n\", sizeof(*arr)); //1\n\nprintf(\"%d\\n\", sizeof(arr[1])); //1\n\nprintf(\"%d\\n\", sizeof(&amp;arr));  //4/8\n\nprintf(\"%d\\n\", sizeof(&amp;arr+1));  //4/8\n\nprintf(\"%d\\n\", sizeof(&amp;arr[0]+1)); //4/8</code></pre>\n<hr/>\n<p>再来看一个字符串数组 </p>\n<pre><code class=\"language-cs\">char arr[] =\"abcdef\";\n\tprintf(\"%d\\n\", sizeof(arr));\n\tprintf(\"%d\\n\", sizeof(arr + 0));\n\tprintf(\"%d\\n\", sizeof(*arr));\n\tprintf(\"%d\\n\", sizeof(arr[1]));\n\tprintf(\"%d\\n\", sizeof(&amp;arr));\n\tprintf(\"%d\\n\", sizeof(&amp;arr + 1));\n\tprintf(\"%d\\n\", sizeof(&amp;arr[0] + 1));</code></pre>\n<p><strong>千万注意整个数组不是6个元素，而是加上\\0，一共七个 </strong></p>\n<p>1.arr</p>\n<p>单独放在sizeof里面是在整个数组 ，是7</p>\n<p>2.arr+0</p>\n<p>此时不是单独放，有元素地址 4/8</p>\n<p>3.*arr</p>\n<p>首元素 1</p>\n<p>4.arr[1]</p>\n<p>第二个元素</p>\n<p>5.&amp;arr</p>\n<p>整个元素的地址 4/8</p>\n<p>6.&amp;arr+1</p>\n<p>跳过整个数组，但是还是地址</p>\n<p>9.&amp;arr[0]+1</p>\n<p>跳过一个char 还是地址4/8</p>\n<p>所以</p>\n<pre><code class=\"language-cs\">char arr[] =\"abcdef\";\n\tprintf(\"%d\\n\", sizeof(arr));  //7\n\tprintf(\"%d\\n\", sizeof(arr + 0)); //4/8\n\tprintf(\"%d\\n\", sizeof(*arr));  //1\n\tprintf(\"%d\\n\", sizeof(arr[1])); //1\n\tprintf(\"%d\\n\", sizeof(&amp;arr)); //4/8\n\tprintf(\"%d\\n\", sizeof(&amp;arr + 1)); //4/8\n\tprintf(\"%d\\n\", sizeof(&amp;arr[0] + 1)); //4/8</code></pre>\n<hr/>\n<p>下面我们自己做一个练习吧</p>\n<pre><code class=\"language-cs\">char *p=\"abcdef\";\nprintf(\"%d\\n\", sizeof(p));\nprintf(\"%d\\n\", sizeof(p+1));\nprintf(\"%d\\n\", sizeof(*p));\nprintf(\"%d\\n\", sizeof(p[0]));\nprintf(\"%d\\n\", sizeof(&amp;p));\nprintf(\"%d\\n\", sizeof(&amp;p+1));\nprintf(\"%d\\n\", sizeof(&amp;p[0]+1));</code></pre>\n<p> 先不要看答案啊</p>\n<p></p>\n<p></p>\n<p> </p>\n<p>现在来看一下答案是多少吧</p>\n<pre><code class=\"language-cs\">char* p=\"abcdef\";\n\tprintf(\"%d\\n\", sizeof(p));  //4/8\n\tprintf(\"%d\\n\", sizeof(p + 1)); //4/8\n\tprintf(\"%d\\n\", sizeof(*p)); //1\n\tprintf(\"%d\\n\", sizeof(p[0]));//1\n\tprintf(\"%d\\n\", sizeof(&amp;p)); //4/8\n\tprintf(\"%d\\n\", sizeof(&amp;p + 1)); //4/8\n\tprintf(\"%d\\n\", sizeof(&amp;p[0] + 1)); //8</code></pre>\n<h1> 2.strlen</h1>\n<pre><code class=\"language-cs\">char arr[]={'a','b','c','d','e','f'};\n    printf(\"%d\\n\", strlen(arr));\n\tprintf(\"%d\\n\", strlen(arr + 0));\n\tprintf(\"%d\\n\", strlen(*arr));\n\tprintf(\"%d\\n\", strlen(arr[1]));\n\tprintf(\"%d\\n\", strlen(&amp;arr));\n\tprintf(\"%d\\n\", strlen(&amp;arr+1));\n\tprintf(\"%d\\n\", strlen(&amp;arr[0]+1));</code></pre>\n<p>1 .arr</p>\n<p>arr不是单独放在sizeof内部，所以还是表示首元素地址，<strong>注意strlen（）只能放地址，，strlen是要寻找\\0的，所以不知道什么时候可以遇到，随机值</strong></p>\n<p>2.arr+0</p>\n<p>和1.相同都是随机值，而且应该是一样的随机值</p>\n<p>3.*arr</p>\n<p>4.arr[1]</p>\n<p>三和四都是元素而不是地址，</p>\n<p>strlen会用地址的眼光看待3.4.的码值，但是内存不是所有地址都可以正常访问的，所以会导致挂掉</p>\n<p>5.&amp;arr</p>\n<p>虽然是整个数组的地址，但是还是从第一个元素开始</p>\n<p>随机值</p>\n<p>6.&amp;arr+1</p>\n<p>跳过整个数组，还是要找\\0，随机值</p>\n<p>7.&amp;arr[0]+1</p>\n<p>指向第二个元素从这里开始找\\0</p>\n<p>所以</p>\n<pre><code class=\"language-cs\">char arr[]={'a','b','c','d','e','f'};\n\tprintf(\"%d\\n\", strlen(arr)); //随机\n\tprintf(\"%d\\n\", strlen(arr + 0)); //随机\n\t//printf(\"%d\\n\", strlen(*arr)); //err \n\t//printf(\"%d\\n\", strlen(arr[1])); //err\n\tprintf(\"%d\\n\", strlen(&amp;arr)); //随机\n\tprintf(\"%d\\n\", strlen(&amp;arr+1)); //随机\n\tprintf(\"%d\\n\", strlen(&amp;arr[0]+1)); //随机</code></pre>\n<p>感谢观看 </p>\n<p> </p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-07 12:57:44", "summary": "其实我们之前就已经讲解过二者的具体差别，但是不够系统，我们当时只是说过，只是求里面所占空间的大小，单位是字节，与无关是求字符串长度，数组或者指针的形式都可以，看到才会停止但是学到现在这个深度，你真的还"}