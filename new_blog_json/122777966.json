{"blogid": "122777966", "writerAge": "码龄2年", "writerBlogNum": "47", "writerCollect": "237", "writerComment": "31", "writerFan": "149", "writerGrade": "3级", "writerIntegral": "599", "writerName": "ephemeral-fever", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122777966.jpg", "writerRankTotal": "46840", "writerRankWeekly": "362309", "writerThumb": "85", "writerVisitNum": "39564", "blog_read_count": "1970", "blog_time": "于 2022-02-06 12:00:00 发布", "blog_title": "web安全——伪协议", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>伪协议常常用于文件包含漏洞之中。在php中能够造成文件包含的函数有include、require、include_once、require_once、highlight_file、show_source、file_get_contents、fopen、file、readfile</strong></p>\n<h1><a id=\"_3\"></a>函数</h1>\n<h2><a id=\"1include_5\"></a>1.include函数</h2>\n<p>可以放在PHP脚本的任意位置，一般放在流程控制的处理部分中。当PHP脚本执行到include指定引入的文件时，才将它包含并尝试执行。这种方式可以把程序执行时的流程进行简单化。当第二次遇到相同文件时，PHP还是会重新解释一次，include相对于require的执行效率下降很多，同时在引入文件中包含用户自定义函数时，PHP在解释过程中会发生函数重复定义问题。include载入成功后，返回1，失败则返回false。</p>\n<h2><a id=\"2require_9\"></a>2.require函数</h2>\n<p>require函数一般放在PHP脚本的最前面，PHP执行前就会先读入require指定引入的文件，包含并尝试执行引入的脚本文件。require的工作方式是提高PHP的执行效率，当它在同一个网页中解释过一次后，第二次便不会解释。但同样的，正因为它不会重复解释引入文件，所以当PHP中使用循环或条件语句来引入文件时，需要用到include。require载入成功返回1，失败无返回值。</p>\n<h2><a id=\"3include_oncerequire_once_13\"></a>3.include_once和require_once函数</h2>\n<p>分别与require / include作用相同，不同的是他们在执行到时会先检查目标内容是不是在之前已经导入过，如果导入过了，那么便不会再次重复引入其同样的内容。</p>\n<h2><a id=\"4highlight_file_17\"></a>4.highlight_file函数</h2>\n<p>highlight_file() 函数对文件进行语法高亮显示。</p>\n<p>语法：highlight_file(filename,return) —— filename：必需。要进行高亮处理的 PHP 文件的路径。return：可选。如果设置 true，则本函数返回高亮处理的代码。</p>\n<p>该函数通过使用 PHP 语法高亮程序中定义的颜色，输出或返回包含在 filename 中的代码的语法高亮版本。如果 return 参数被设置为 true，那么该函数会返回被高亮处理的代码，而不是输出它们。否则，若成功，则返回 true，失败则返回 false。</p>\n<h2><a id=\"5show_source_25\"></a>5.show_source函数</h2>\n<p>该函数是highlight_file函数的别名。</p>\n<h2><a id=\"6file_get_contents_29\"></a>6.file_get_contents函数</h2>\n<p>file_get_contents() 函数把整个文件读入一个字符串中。和 file() 一样，不同的是 file_get_contents() 把文件读入一个字符串。file_get_contents() 函数是用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\07ae1df8b64b4eff9779a06808678b9a.png\"/></p>\n<h2><a id=\"7file_35\"></a>7.file函数</h2>\n<p>file() 函数把整个文件读入一个数组中。与 file_get_contents() 类似，不同的是 file() 将文件作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内。如果失败，则返回 false。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a3dabab5bfff4ccb86228c90278abb2d.png\"/></p>\n<h1><a id=\"php_41\"></a>php伪协议：</h1>\n<p>file:// 访问本地文件系统<br/> http:// 访问 HTTPs 网址<br/> ftp:// 访问 ftp URL<br/> php:// 访问输入输出流<br/> zlib:// 压缩流<br/> data:// 数据<br/> ssh2:// security shell2<br/> expect:// 处理交互式的流<br/> glob:// 查找匹配的文件路径</p>\n<h2><a id=\"file_53\"></a>file://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a5547c8d79dd4a88be2adb90c88cfc47.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4d7ee0503bab4e239c6cf506a4eb8714.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3afc5e37ba43427798ec35a3e502b67b.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\05153f3c1d6f4dbd853538433c4c3c28.png\"/></p>\n<h2><a id=\"httphttps_64\"></a>http://或https://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b952225c3d9f49e29222225898bbaaf1.png\"/></p>\n<h2><a id=\"php_69\"></a>php://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8f3923229b8e4fc8aabfaa54db18e4f1.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ad6e117800984acfab9d6cea9fbb2dd2.png\"/></p>\n<h3><a id=\"phpfilter_75\"></a>php://filter</h3>\n<p>经常使用的一种伪协议，一般用于任意文件读取，有时也可以用于getshell.在双OFF的情况下也可以使用.<br/> php://filter是一种元封装器，用于数据流打开时筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用。类似readfile()、file()、file_get_contents(),在数据流读取之前没有机会使用其他过滤器。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c2192d9ee30d4748aa0ce11245b9ebe8.png\"/></p>\n<p>例子：</p>\n<blockquote>\n<p>php://filter/[read/write]=string.[rot13/strip_tags/……]/resource=xxx</p>\n</blockquote>\n<blockquote>\n<p>?a=php://filter/read=convert.base64-encode/resource=xxx.php</p>\n</blockquote>\n<blockquote>\n<p>?a=php://filter/read=string.rot13/resource=xxx.php</p>\n</blockquote>\n<p>首先这是一个file关键字的get参数传递，php://是一种协议名称，php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示读取的方式是base64编码后，resource=index.php表示目标文件为index.php。<br/> 通过传递这个参数可以得到index.php的源码，下面说说为什么。看到源码中的include函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。<br/> 而include的内容是由用户控制的，所以通过我们传递的file参数，是include（）函数引入index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码，所以我们得到了源码的base64格式，解码即可。如果不进行base64编码传入，就会直接执行，</p>\n<h3><a id=\"phpinput_93\"></a>php://input</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\956b18098b71469b879c71b3482aa4e4.png\"/></p>\n<h2><a id=\"data_98\"></a>data://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\736ba88050cc496aa26c364154951b7a.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fed711c75d844f9da1c2e364c76aa48b.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\56d90e99e7ad480e88d760ea79255a32.png\"/></p>\n<h2><a id=\"httphttps_105\"></a>http://协议&amp;https://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1b3b61980284134a4872467081b4136.png\"/></p>\n<h2><a id=\"zipbzip2zlib_109\"></a>zip://&amp;bzip2://&amp;zlib://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ce99166563b343d790a2a66ae6f00cdf.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\554f7b76e4174001a41da4923c9912e3.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0753713bc1504c2984b6b250efbf53b0.png\"/></p>\n<h2><a id=\"phar_116\"></a>phar://协议</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5464ef47a83d4a22923b68a218428e27.png\"/></p>\n<h2><a id=\"dict_121\"></a>dict://协议</h2>\n<p>dict://serverip:port/命令:参数<br/> 向服务器的端口请求为【命令:参数】，并在末尾自动补上\\r\\n(CRLF)，为漏洞利用增添了便利<br/> 通过dict协议的话要一条一条的执行，而gopher协议执行一条命令就行了。</p>\n<h1><a id=\"_127\"></a>过滤器</h1>\n<p>过滤器有很多种，有字符串过滤器、转换过滤器、压缩过滤器、加密过滤器</p>\n<h2><a id=\"_131\"></a>字符串过滤器</h2>\n<p>string.rot13 进行rot13转换<br/> string.toupper 将字符全部大写<br/> string.tolower 将字符全部小写<br/> string.strip_tags 去除空字符、HTML 和 PHP 标记后的结果。功能类似于strip_tags()函数，若不 想某些字符不被消除，后面跟上字符，可利用字符串或是数组两种方式</p>\n<h2><a id=\"_138\"></a>转换过滤器</h2>\n<blockquote>\n<p>convert.base64-encode &amp; convert.base64-decode</p>\n</blockquote>\n<p><strong>base64 编码解码</strong><br/> convert.base64-encode和convert.base64-decode使用这两个过滤器等同于分别用 base64_encode()和 base64_decode()函数处理所有的流数据。 convert.base64-encode支持以一个关联数组给出的参数。如果给出了line-length，base64 输出将被用 line-length个字符为长度而截成块。如果给出了* line-break-chars*，每块将被用给出的字符隔开。这些参数的效果和用 base64_encode()再加上 chunk_split()相同。</p>\n<blockquote>\n<p>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</p>\n</blockquote>\n<p><strong>quoted-printable 编码解码</strong><br/> convert.quoted-printable-encode和 convert.quoted-printable-decode等同于用 quoted_printable_decode()函数处理所有的流数据。没有和* convert.quoted-printable-encode*相对应的函数。convert.quoted-printable-encode支持以一个关联数组给出的参数。除了支持和 convert.base64-encode一样的附加参数外，convert.quoted-printable-encode还支持布尔参数 binary和 force-encode-first。 convert.base64-decode只支持 line-break-chars参数作为从编码载荷中剥离的类型提示。</p>\n<h2><a id=\"_150\"></a>压缩过滤器</h2>\n<blockquote>\n<p>zlib.deflate和 zlib.inflate</p>\n</blockquote>\n<p>zlib.deflate（压缩）和 zlib.inflate（解压）实现了定义与 » RFC 1951的压缩算法。 deflate过滤器可以接受以一个关联数组传递的最多三个参数。* level*定义了压缩强度（1-9）。数字更高通常会产生更小的载荷，但要消耗更多的处理时间。存在两个特殊压缩等级：0（完全不压缩）和 -1（zlib 内部默认值，目前是 6）。 window是压缩回溯窗口大小，以二的次方表示。更高的值（大到 15 —— 32768 字节）产生更好的压缩效果但消耗更多内存，低的值（低到 9 —— 512 字节）产生产生较差的压缩效果但内存消耗低。目前默认的 window大小是 15。 memory用来指示要分配多少工作内存。合法的数值范围是从 1（最小分配）到 9（最大分配）。内存分配仅影响速度，不会影响生成的载荷的大小。<br/> Note: 因为最常用的参数是压缩等级，也可以提供一个整数值作为此参数（而不用数组）。</p>\n<blockquote>\n<p>bzip2.compress和 bzip2.decompress</p>\n</blockquote>\n<p>bzip2.compress过滤器接受以一个关联数组给出的最多两个参数：* blocks<em>是从 1 到 9 的整数值，指定分配多少个 100K 字节的内存块作为工作区。 work是 0 到 250 的整数值，指定在退回到一个慢一些，但更可靠的算法之前做多少次常规压缩算法的尝试。调整此参数仅影响到速度，压缩输出和内存使用都不受此设置的影响。将此参数设为 0 指示 bzip 库使用内部默认算法。 bzip2.decompress过滤器仅接受一个参数，可以用普通的布尔值传递，或者用一个关联数组中的</em> small*单元传递。当 small设为&amp;true; 值时，指示 bzip 库用最小的内存占用来执行解压缩，代价是速度会慢一些。</p>\n<h2><a id=\"_161\"></a>加密过滤器</h2>\n<p><em>mcrypt.*</em> 和 <em>mdecrypt.*</em> 使用 libmcrypt 提供了对称的加密和解密。这两组过滤器都支持 mcrypt 扩展库 中相同的算法，格式为_mcrypt.ciphername_，其中 ciphername是密码的名字，将被传递给 mcrypt_module_open()。有以下五个过滤器参数可用：<br/> mcrypt 过滤器参数<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5bfbeababbd245b88dc8a1a2f1147f16.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2022-02-06 12:00:00", "summary": "伪协议常常用于文件包含漏洞之中。在中能够造成文件包含的函数有、、、、、、、、、函数函数可以放在脚本的任意位置，一般放在流程控制的处理部分中。当脚本执行到指定引入的文件时，才将它包含并尝试执行。这种方式"}