{"blogid": "126514907", "writerAge": "码龄3年", "writerBlogNum": "1311", "writerCollect": "11088", "writerComment": "1385", "writerFan": "28025", "writerGrade": "8级", "writerIntegral": "41085", "writerName": "流楚丶格念", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126514907.jpg", "writerRankTotal": "102", "writerRankWeekly": "222", "writerThumb": "3185", "writerVisitNum": "3670212", "blog_read_count": "206", "blog_time": "于 2022-08-28 08:59:38 发布", "blog_title": "Redis 数据结构原理解析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#Redis_1\">Redis</a></li><li><ul><li><a href=\"#Redis__2\">Redis 概念</a></li><li><a href=\"#Redis__8\">Redis 应用场景</a></li><li><a href=\"#Redis__15\">Redis 数据结构</a></li><li><ul><li><a href=\"#String_36\">String（字符串）</a></li><li><a href=\"#List_51\">List（列表）</a></li><li><ul><li><a href=\"#ziplist_61\">补充：ziplist</a></li></ul>\n</li><li><a href=\"#Hash_75\">Hash（哈希）</a></li><li><ul><li><a href=\"#hashtable__79\">补充：hashtable 编码</a></li></ul>\n</li><li><a href=\"#Sorted_Set_100\">Sorted Set</a></li><li><ul><li><a href=\"#_137\">补：跳表查询</a></li></ul>\n</li></ul>\n</li><li><a href=\"#Redis__154\">Redis 数据结构相关命令操作</a></li><li><a href=\"#_160\">数据结构注意点</a></li><li><ul><li><a href=\"#setzset_161\">set与zset区别</a></li><li><a href=\"#Rediswatch_171\">Redis中的watch命令</a></li><li><a href=\"#RedisList_175\">说说Redis中List结构的相关操</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"Redis_1\"></a>Redis</h1>\n<h2><a id=\"Redis__2\"></a>Redis 概念</h2>\n<p>Redis是一种基于键值对的NoSQL数据库，而键值对的值是由多种数据结构和算法组成的。Redis的数据都存储于内存中，因此它的速度惊人，读写性能可达10万/秒，远超关系型数据库。</p>\n<p>关系型数据库是基于二维数据表来存储数据的，它的数据格式更为严谨，并支持关系查询。关系型数据库的数据存储于磁盘上，可以存放海量的数据，但性能远不如Redis。</p>\n<h2><a id=\"Redis__8\"></a>Redis 应用场景</h2>\n<ol><li>Redis最常用来做缓存，是实现分布式缓存的首先中间件；</li><li>Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；</li><li>Redis可以作为计算工具，能用很小的代价，统计诸如PV/UV、用户在线天数等数据；</li><li>Redis还有很多其他的使用场景，例如：可以实现分布式锁，可以作为消息队列使用</li></ol>\n<h2><a id=\"Redis__15\"></a>Redis 数据结构</h2>\n<ol><li>Redis支持5种核心的数据类型，分别是字符串、哈希、列表、集合、有序集合；</li><li>另外Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的；</li><li>Redis在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\775bc368eb9c4f0f87bd0a9c7602b2d7.png\"/></li></ol>\n<blockquote>\n<p>注意：这里的数据类型实际描述的是 value 的类型，key 都是 string，常见数据类型（value）有如下类型</p>\n</blockquote>\n<ol><li>string（embstr、raw、int）</li><li>list（quicklist，由多个 ziplist 双向链表组成）</li><li>hash（ziplist，键值比较少、hashtable键值超过某些阈值或者单个键值比较大）</li><li>set（intset、hashtable）</li><li>sorted set（ziplist、skiplist）</li><li>bitmap</li><li>hyperloglog</li></ol>\n<p>每一种类型都用 redisObject 结构体来表示，每种类型根据情况不同，有不同的编码 encoding（即每种结构体的底层数据结构）</p>\n<p>下面来详细介绍一下：</p>\n<h3><a id=\"String_36\"></a>String（字符串）</h3>\n<p>如果字符串保存的是整数值，则底层编码为 <strong>int</strong>，实际使用 long （8字节）来存储</p>\n<p>如果字符串保存的是非整数值（浮点数字或其它字符）又分两种情况</p>\n<ol><li>长度 &lt;= 39 字节，使用 <strong>embstr</strong> 编码来保存，即将 redisObject 和 sdshdr 结构体保存在一起，分配内存只需一次</li><li>长度 &gt; 39 字节，使用 <strong>raw</strong> 编码来保存，即 redisObject 结构体分配一次内存，sdshdr 结构体分配一次内存，用指针相连</li></ol>\n<blockquote>\n<p>sdshdr 称为<strong>简单动态字符串</strong>，实现上有点类似于 java 中的 StringBuilder，Redis是用C语言实现的，sdshdr 是底层代码定义的一个结构体，它有如下特性</p>\n<ol><li>可以单独存储字符长度，相比 <code>char*</code> 获取长度效率高（<code>char*</code> 是 C 语言原生字符串表示）</li><li>支持动态扩容，方便字符串拼接操作</li><li>预留空间，减少内存分配、释放次数（<strong>&lt; 1M 时容量是字符串实际长度 2 倍，&gt;= 1M 时容量是原有容量 + 1M</strong>）</li><li>二进制安全，例如传统 <code>char*</code> 以 <code>\\0</code> 作为结束字符，这样就不能保存视频、图片等二进制数据，而 sds 以长度来进行读取</li></ol>\n</blockquote>\n<h3><a id=\"List_51\"></a>List（列表）</h3>\n<p>从 Redis 3.2 开始，Redis 采用 quicklist 作为其编码方式，它是一个双向链表，<strong>节点元素是 ziplist</strong></p>\n<ol><li>由于是链表，<strong>内存上不连续</strong></li><li><strong>操作头尾效率高</strong>，时间复杂度 O(1)</li><li>链表中 ziplist 的大小和元素个数都可以设置，其中大小默认 8kb（默认空间可以以后将他们串起来成quicklist ）</li></ol>\n<h4><a id=\"ziplist_61\"></a>补充：ziplist</h4>\n<p>ziplist 用一块<strong>连续的内存</strong>存储数据，设计目标是让数据存储更紧凑，减少碎片开销，节约内存，它的结构如下</p>\n<ol><li>zlbytes – 记录整个 ziplist 占用字节数</li><li>zltail-offset – 记录尾节点偏移量：用于快速定位尾结点，倒着遍历</li><li>zllength – 记录节点数量：</li><li>entry – 节点，1 ~ N 个，每个 entry 记录了前一 entry 长度（也是为了倒序遍历 减去字节），本 entry 的编码、长度、实际数据，为了节省内存，根据<strong>实际数据长度不同，用于记录长度的字节数也不同</strong>，例如前一 entry 长度是 253 时，需要用 1 个字节，但超过了 253，需要用 5 个字节</li><li>zlend – 结束标记</li></ol>\n<p>ziplist <strong>适合存储少量元素，否则查询效率不高，并且长度可变的设计会带来连锁更新问题</strong></p>\n<blockquote>\n<p>quicklist 是大链表 大链表里套了多个小链表（ziplist）</p>\n</blockquote>\n<h3><a id=\"Hash_75\"></a>Hash（哈希）</h3>\n<p>在数据量较小时，采用 ziplist 作为其编码，当键或值长度过大（64）或个数过多（512）时，转为 hashtable 编码</p>\n<h4><a id=\"hashtable__79\"></a>补充：hashtable 编码</h4>\n<p>hash 函数，Redis 5.0 采用了 SipHash 算法</p>\n<p>采用拉链法解决 key 冲突</p>\n<p>rehash 时机<br/> ① 当元素数 &lt; 1 * 桶个数时，不扩容<br/> ② 当元素数 &gt; 5 * 桶个数时，一定扩容<br/> ③ 当 1 * 桶个数 &lt;= 元素数 &lt;= 5 * 桶个数时，如果此时没有进行 AOF 或 RDB 操作时<br/> ④ 当元素数 &lt; 桶个数 / 10 时，缩容</p>\n<p><strong>rehash 要点</strong></p>\n<p>① 每个字典有两个哈希表，桶个数为 <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        \n         2\n        \n        \n         n\n        \n       \n      \n      \n       2^n\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>，平时使用 ht[0]，ht[1] 开始为 null，扩容时新数组大小为元素个数 * 2<br/> ② <strong>渐进式 rehash</strong>，即不是一次将所有桶都迁移过去，每次对这张表 CRUD 仅迁移一个桶<br/> ③ <strong>active rehash</strong>，server 的主循环中，每 100 ms 里留出 1s 进行主动迁移<br/> ④ rehash 过程中，新增操作 ht[1] ，其它操作先操作 ht[0]，若没有，再操作 ht[1]<br/> ⑤ redis 所有 CRUD 都是单线程，因此 rehash 一定是线程安全的</p>\n<h3><a id=\"Sorted_Set_100\"></a>Sorted Set</h3>\n<ol><li> <p>在数据量较小时，采用 ziplist 作为其编码，按 score 有序，当键或值长度过大（64）或个数过多（128）时，转为 skiplist + hashtable 编码，同时采用的理由是</p>\n<ul><li>只用 hashtable，CRUD 是 O(1)，但要执行有序操作，需要排序，带来额外时间空间复杂度</li><li>只用 skiplist，虽然范围操作优点保留，但时间复杂度上升</li><li>虽然同时采用了两种结构，但由于采用了指针，元素并不会占用双份内存</li></ul> </li><li> <p>skiplist 要点：多层链表、排序规则、 backward、level（span，forward）</p> </li></ol>\n<p><img alt=\"image-20210902094835557\" src=\"..\\..\\static\\image\\de7d3ac9b6beddc135731ca54fd7d505.png\"/></p>\n<ul><li>score 存储分数、member 存储数据、按 score 排序，如果 score 相同再按 member 排序</li><li>backward 存储上一个节点指针</li><li>每个节点中会存储层级信息（level），同一个节点可能会有多层，每个 level 有属性： \n  <ul><li>foward 同层中下一个节点指针</li><li>span 跨度，用于计算排名，不是所有跳表都实现了跨度，Redis 实现特有</li></ul> </li></ul>\n<ol start=\"3\"><li> <p>多层链表可以加速查询，规则为，从顶层开始</p>\n<ol><li> <p>大于同层右边的，继续在同层向右找</p> </li><li> <p>相等找到了</p> </li><li> <p>小于同层右边的或右边为 NULL，下一层，重复 1、2 步骤</p> </li></ol> </li></ol>\n<p><img alt=\"image-20210902094835557\" src=\"..\\..\\static\\image\\de7d3ac9b6beddc135731ca54fd7d505.png\"/></p>\n<ul><li>以查找【崔八】为例 \n  <ol><li>从顶层（4）层向右找到【王五】节点，22 &gt; 7 继续向右找，但右侧是 NULL，下一层</li><li>在【王五】节点的第 3 层向右找到【孙二】节点，22 &lt; 37，下一层</li><li>在【王五】节点的第 2 层向右找到【赵六】节点，22 &gt; 19，继续向右找到【孙二】节点，22 &lt; 37，下一层</li><li>在【赵六】节点的第 1 层向右找到【崔八】节点，22 = 22，返回</li></ol> </li></ul>\n<blockquote>\n<p><em><strong>注意</strong></em></p>\n<ul><li>数据量较小时，不能体现跳表的性能提升，跳表查询的时间复杂度是 <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n      \n       \n        \n         \n          l\n         \n         \n          o\n         \n         \n          \n           g\n          \n          \n           2\n          \n         \n         \n          (\n         \n         \n          N\n         \n         \n          )\n         \n        \n        \n         log_2(N)\n        \n       \n      </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0197em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.109em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>，与二叉树性能相当</li></ul>\n</blockquote>\n<h4><a id=\"_137\"></a>补：跳表查询</h4>\n<p>skiplist 查找要点，从顶层开始</p>\n<blockquote>\n<p>右边的，继续向右<br/> = 找到了<br/> &lt; 右边的或右边为 NULL，下一层，重复 1、2 步骤</p>\n</blockquote>\n<p>以查找 score = 22 为例：</p>\n<p><img alt=\"image-20220805100944083\" src=\"..\\..\\static\\image\\339f34e65c9ac2622420f9bb6ab12bb2.png\"/></p>\n<p>按照一层链表，我们找到 22 得查 5 次</p>\n<p>跳表：先查第一层找到7 发现 7 的右边是null了，再从7 查第二层，右边是 37 比22 大，再从7下一层，下一个元素是19 ，19小于22,19的下一个是37，还得下一层，下一层的下一个就是22了，找到了</p>\n<p>跳表查询的时间复杂度 <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        l\n       \n       \n        o\n       \n       \n        \n         g\n        \n        \n         2\n        \n       \n       \n        n\n       \n      \n      \n       log_2n\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0197em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span></span></span></span></span></p>\n<h2><a id=\"Redis__154\"></a>Redis 数据结构相关命令操作</h2>\n<p>内容过多，参考我的另一篇博文：<a href=\"https://blog.csdn.net/weixin_45525272/article/details/126554248\">https://blog.csdn.net/weixin_45525272/article/details/126554248</a></p>\n<h2><a id=\"_160\"></a>数据结构注意点</h2>\n<h3><a id=\"setzset_161\"></a>set与zset区别</h3>\n<p>set：</p>\n<ul><li>集合中的元素是无序、不可重复的，一个集合最多能存储2<sup>32</sup>-1个元素；</li><li>集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。</li></ul>\n<p>zset：</p>\n<ul><li>有序集合保留了集合元素不能重复的特点；</li><li>有序集合会给每个元素设置一个分数，并以此作为排序的依据；</li><li>有序集合不能包含相同的元素，但是不同元素的分数可以相同。</li></ul>\n<h3><a id=\"Rediswatch_171\"></a>Redis中的watch命令</h3>\n<p>很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值.</p>\n<h3><a id=\"RedisList_175\"></a>说说Redis中List结构的相关操</h3>\n<p>列表是线性有序的数据结构，它内部的元素是可以重复的，并且一个列表最多能存储2<sup>32</sup>-1个元素。列表包含如下的常用命令：</p>\n<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>lpush/rpush</code></td><td>从列表的左侧/右侧添加数据；</td></tr><tr><td><code>lrange</code></td><td>指定索引范围，并返回这个范围内的数据；</td></tr><tr><td><code>lindex</code></td><td>返回指定索引处的数据；</td></tr><tr><td><code>lpop/rpop</code></td><td>从列表的左侧/右侧弹出一个数据；</td></tr><tr><td><code>blpop/brpop</code></td><td>从列表的左侧/右侧弹出一个数据，若列表为空则进入阻塞状态</td></tr></tbody></table>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-28 08:59:38", "summary": "文章目录概念应用场景数据结构字符串列表补充：哈希补充：编码补：跳表查询数据结构相关命令操作数据结构注意点与区别中的命令说说中结构的相关操概念是一种基于键值对的数据库，而键值对的值是由多种数据结构和算法"}