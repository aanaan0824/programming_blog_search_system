{"blogid": "123954919", "writerAge": "码龄1年", "writerBlogNum": "41", "writerCollect": "232", "writerComment": "475", "writerFan": "1153", "writerGrade": "5级", "writerIntegral": "1829", "writerName": "*insist", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123954919.jpg", "writerRankTotal": "13105", "writerRankWeekly": "16653", "writerThumb": "462", "writerVisitNum": "23741", "blog_read_count": "1729", "blog_time": "已于 2022-06-24 20:17:24 修改", "blog_title": "STL中string类的实现（细节避坑）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><span style=\"color:#e6b223;\"><strong>C++中的string类 翻译过来就是字符串类型 但是它可不是一个平平无奇的字符串 它具有像线性表一样的增删查改的功能 会自动扩容 还支持迭代器遍历 功能可谓十分齐全 下面就来实现它</strong></span></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\6b987290998457de9c5b75920ef98a67.png\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"396\" src=\"..\\..\\static\\image\\86059b0d0aa94f6a8fe51519f88503ed.png\" width=\"1128\"/></p>\n<p></p>\n<p><strong><span style=\"color:#a2e043;\">实</span><span style=\"color:#ff9900;\">现</span><span style=\"color:#38d8f0;\">的</span><span style=\"color:#ff9900;\">功</span><span style=\"color:#ed7976;\">能</span><span style=\"color:#ff9900;\">总</span><span style=\"color:#956fe7;\">览</span><span style=\"color:#ff9900;\">：</span></strong></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">一、构造函数</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89\">二、拷贝构造函数（传统写法和现代写法）</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">三、析构函数</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E6%8C%89%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9B%9B%E3%80%81%E6%8C%89%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9\">四、按下标访问或修改</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%94%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89\">五、赋值操作（传统写法和现代写法）</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E5%B0%BE%E6%8F%92pushback-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%AD%E3%80%81%E5%B0%BE%E6%8F%92pushback\">六、尾插pushback</a></p>\n<p id=\"%E4%B8%83%E3%80%81%E5%8A%A0%E7%AD%89%E5%AD%97%E7%AC%A6%E5%92%8C%E5%8A%A0%E7%AD%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%83%E3%80%81%E5%8A%A0%E7%AD%89%E5%AD%97%E7%AC%A6%E5%92%8C%E5%8A%A0%E7%AD%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C\">七、加等字符和加等字符串操作</a></p>\n<p id=\"%E5%85%AB%E3%80%81%E6%89%A9%E5%AE%B9(reserve)-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%AB%E3%80%81%E6%89%A9%E5%AE%B9%28reserve%29\">八、扩容(reserve)</a></p>\n<p id=\"%E4%B9%9D%E3%80%81%E6%89%A9%E5%AE%B9%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96(resize)-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B9%9D%E3%80%81%E6%89%A9%E5%AE%B9%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%28resize%29\">九、扩容并初始化(resize)</a></p>\n<p id=\"%E5%8D%81%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0\">十、获取有效字符个数</a></p>\n<p id=\"%E5%8D%81%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F_str%E7%9A%84%E5%87%BD%E6%95%B0c_str()-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F_str%E7%9A%84%E5%87%BD%E6%95%B0c_str%28%29\">十一、获取成员变量_str的函数c_str()</a></p>\n<p id=\"%E5%8D%81%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82%EF%BC%88%E4%B8%A4%E7%A7%8D%E4%B8%8B%E6%A0%87%E6%B3%95%20%E4%B8%80%E7%A7%8D%E6%8C%87%E9%92%88%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82%EF%BC%88%E4%B8%A4%E7%A7%8D%E4%B8%8B%E6%A0%87%E6%B3%95%20%E4%B8%80%E7%A7%8D%E6%8C%87%E9%92%88%E6%B3%95%EF%BC%89\">十二、插入数据的三种方法详解及相关细节（两种下标法 一种指针法）</a></p>\n<p id=\"%E5%8D%81%E4%B8%89%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E4%B8%89%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\">十三、删除数据</a></p>\n<p id=\"%E5%8D%81%E5%9B%9B%E3%80%81%E6%9F%A5%E6%89%BE%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%90%E4%B8%B2-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E5%9B%9B%E3%80%81%E6%9F%A5%E6%89%BE%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%90%E4%B8%B2\">十四、查找单个字符和子串</a></p>\n<p id=\"%E5%8D%81%E4%BA%94%E3%80%81%E7%AE%80%E6%98%93%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E4%BA%94%E3%80%81%E7%AE%80%E6%98%93%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0\">十五、简易迭代器遍历的实现</a></p>\n<p id=\"%E5%8D%81%E5%85%AD%E3%80%81%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E5%85%AD%E3%80%81%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83\">十六、类的直接比较</a></p>\n<p id=\"%E5%8D%81%E4%B8%83%E3%80%81%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E4%B8%83%E3%80%81%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA\">十七、类的直接输入输出</a></p>\n<p id=\"%E5%8D%81%E5%85%AB%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%ADgetline%E7%AE%80%E6%98%93%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8D%81%E5%85%AB%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%ADgetline%E7%AE%80%E6%98%93%E7%9A%84%E5%AE%9E%E7%8E%B0\">十八、标准库中getline简易的实现</a></p>\n<p style=\"margin-left:80px;\">补充、std::swap  和 string 自带的swap 的区别</p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p><span style=\"color:#38d8f0;\"><strong>类的结构：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>类的结构包括三个成员变量</strong></span><span style=\"color:#ed7976;\"><strong> </strong><strong>_str 、_size、_capacity</strong></span><span style=\"color:#0d0016;\"><strong> 以及目录中的</strong></span><span style=\"color:#a2e043;\"><strong>相关方法</strong></span><span style=\"color:#0d0016;\"><strong>、</strong><strong>_str是字符指针指向一块用来</strong></span><span style=\"color:#4da8ee;\"><strong>存储字符串的空间 </strong></span><span style=\"color:#0d0016;\"><strong>、_size是用来记录字符串的</strong></span><span style=\"color:#ffd900;\"><strong>有效字符的个数</strong></span><span style=\"color:#0d0016;\"><strong>、_capacity是用来记录当前空间</strong></span><span style=\"color:#faa572;\"><strong>可以存放多少个字符（容量）</strong></span></p>\n<p></p>\n<h3 id=\"%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">一、构造函数</h3>\n<p>上面介绍了string 类的成员变量 那么构造函数就要对其进行初始化咯</p>\n<p>实参传过来的必须是字符串，所以用字符指针接收，细节一点，就是<span style=\"color:#fe2c24;\">用const修饰一下*str</span>这样<span style=\"color:#fe2c24;\">实参就不能在构造函数中被改变</span></p>\n<p><strong><span style=\"color:#0d0016;\">然后就用strlen函数计算出传过来的字符串的长度，让该类中的成员变量（属性）_size和_capacity都等于该长度，然后再开辟出比容量大一的空间来存储我们要所要构造的字符串。最后一步就是把实参的字符串拷贝到我们新开辟的空间中；这一波操作下来就构造好了一个string对象，该对象（字符串）的内容，空间大小，长度都是和我们初始化时给的参数一样的了</span></strong></p>\n<p>关于这里为什么要开辟_capacity+1个字符的空间，也不一定非得是这样，只要逻辑上走得通都可以；<strong>这里我定义的_capacity 是可以存储有效字符的个数，不包括\\0在内，但是字符串是以\\0 作为结尾标志的，所以要多开辟一个字节的空间用来存放\\0。</strong></p>\n<pre><code>string(const char* str = \"\")\n{\n\t_size = strlen(str);\n\t_capacity = _size;\n\t_str = new char[_capacity + 1];\n\tstrcpy(_str, str);\n}</code></pre>\n<p></p>\n<h3 id=\"%E4%BA%8C%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89\">二、拷贝构造函数（传统写法和现代写法）</h3>\n<p><strong><span style=\"color:#ff9900;\">拷贝构造函数就是拿一个已经创建了初始化好了的对象，去初始化新定义的对象。</span></strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>注意：这里的拷贝够造必须是深拷贝（所有的内容相同，但是原来的和拷贝的是并不是同一个），不能是浅拷贝（光是值的拷贝）。（自身理解，若有考虑不周，还望体谅）</strong></span></p>\n<p>例如：</p>\n<pre><code>string a(\"hello world\");//这是定义了一个对象a 并且拿“hello world”进行初始化\n\nstring b(a);//这种方式就是拷贝构造了 因为b是刚定义的对象\n            // 拿以及定义且初始化的对象a对其进行初识化</code></pre>\n<p>但是这里的拷贝构造有两种写法 传统写法及现代写法</p>\n<p><strong>1.传统写法</strong></p>\n<p>思路：开辟空间，把用来构造的对象的数据一一复制给自己</p>\n<p></p>\n<p>以上面的例子为例说明：</p>\n<p>string a(\"hello world\")；</p>\n<p>string b(a);</p>\n<p><strong><span style=\"color:#4da8ee;\">这里的a初始化后其成员变量_str存的是“hello world” 、_size是11、_capacity是11。那么那a来构造b就是把b里的_str指向的空间放“hello world” 、_size等于a的_size、_capacity等于a的_capacity </span></strong></p>\n<p>代码实现：</p>\n<pre><code>\t//传统写法\n\t\tstring(const string&amp; str)\n\t\t{\n\t\t\t_str = new char[str._capacity + 1];\n\t\t\tstrcpy(_str, str._str);\n\t\t\t_size = str._size;\n\t\t\t_capacity = str._capacity;\n\t\t}</code></pre>\n<p><strong>2.现代写法</strong></p>\n<p>思路：<span style=\"color:#4da8ee;\"><strong>与传统方法不同，传统方法是自己一一去实现拷贝，但是现代方法比较懒，它调写好的构造函数去帮自己构造出一个与传过来的对象一样的对象，在将构造出来的对象的数据和自己交换。</strong></span></p>\n<pre><code class=\"language-cpp\">string(const string&amp; str)\n\t\t:_str(nullptr)//必须初始化为空指针 否则后面调用析构函数会出错 野指针问题\n\t\t,_size(0)\n\t\t,_capacity(0)\n\t\t{\n\t\t\tstring tmp(str._str);\n\t\t\t::swap(_str, tmp._str);//::表示调用的是全局域里的swap\n\t\t\t::swap(_size, tmp._size);\n\t\t\t::swap(_capacity, tmp._capacity);\n\t\t\t\n\t\t}</code></pre>\n<p><strong>注：代码中的三个swap可以合并成一个函数简化代码（标准库里也是这样的）：</strong></p>\n<pre><code>void swap(string&amp; str)\n{\n\t::swap(_str,str._str);\n\t::swap(_size, str._size);\n\t::swap(_capacity, str._capacity);\n}\n\n//现代写法\nstring(const string&amp; str)\n\t:_str(nullptr)\n\t,_size(0)\n\t,_capacity(0)\n\t{\n\t\tstring tmp(str._str);\n\t\t/*::swap(_str, tmp._str);\n\t\t::swap(_size, tmp._size);\n\t\t::swap(_capacity, tmp._capacity);*/\n\t\tswap(tmp);\n\t}</code></pre>\n<p>这里需要注意的是自身的<span style=\"color:#fe2c24;\"><strong>_str必须要初始化</strong></span>，不能是随机的！！！</p>\n<p><span style=\"color:#ff9900;\"><strong>因为利用构造函数构造出来的对象临时tmp出来作用域会自动销毁，那么就会去调用析构函数，但是这里我们把本身对象和临时对象的_str交换了，所以tmp调用析构函数的时候，就是去释放本身对象中_str指向的空间，那么如果本身对象的_str没有初始化指向的就是随机空间是野指针，释放野指针指向的空间是会报错的，所以必须初始化_str 为空指针，这样就不会出错了。</strong></span></p>\n<p>最后对两者进行对比一下：传统写法比较呆板，现代写法比较新颖，也比较简洁</p>\n<p></p>\n<h3 id=\"%E4%B8%89%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">三、析构函数</h3>\n<p>析构函数就比较简单了 ，释放掉_str指向的空间，并将_str置空即可</p>\n<pre><code>~string()\n{\n\tdelete[] _str;\n\t_str = nullptr;\n}</code></pre>\n<p></p>\n<h3 id=\"%E5%9B%9B%E3%80%81%E6%8C%89%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9\">四、按下标访问或修改</h3>\n<p>这里的按下标访问或者修改就是运算符重载的知识了</p>\n<pre><code>const char&amp; operator[](size_t pos) const// 只能读 const对象的遍历专属 返回的引用也得是const引用\n{\n\tassert(pos &lt; _size);\n\treturn _str[pos];\n}\n\nchar&amp; operator[](size_t pos)//可读可写\n{\n\tassert(pos &lt; _size);\n\treturn _str[pos];\n}</code></pre>\n<p>利用[]的运算符重载即可实现按下标访问或者修改</p>\n<p>要分<strong><span style=\"color:#ffd900;\">两种情况</span></strong>：</p>\n<p><strong>一、访问的是非const对象</strong></p>\n<p><span style=\"color:#ff9900;\">对于非const对象我们可读可写 那么就是返回的就是非const的引用类型</span></p>\n<p></p>\n<p><strong>二、访问的是const对象</strong></p>\n<p><span style=\"color:#ff9900;\">1、对于const对象，只能读，不能写，那么其[]的运算符重载函数就要用const修饰，const修饰的函数或者接口，修饰的是隐含的this指针指向的对象（*this），所指向对象的成员变量不可以通过该函数或接口改变，起到了保护作用。</span></p>\n<p><span style=\"color:#ff9900;\">2、既然是只读，而返回的是引用，但又不能通过返回的引用去改变对象成员变量，所以引用也要用const来修饰</span></p>\n<p></p>\n<h3 id=\"%E4%BA%94%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89\">五、赋值操作（传统写法和现代写法）</h3>\n<p>赋值操作可以实现可以拿对象赋值给对象</p>\n<p>例如：</p>\n<pre><code>string a(\"hello world\");\nstring b(\"nice\");\na=b;//把对象b赋值给对象a</code></pre>\n<p><span style=\"color:#4da8ee;\">也分传统写法和现代写法，传统写法就是按部就班的走，现代写法就是借助构造函数构造对象在交换</span></p>\n<p>一、传统写法</p>\n<pre><code> //传统写法\nstring&amp; operator=(const string&amp; str)\n{\n\tdelete[] _str;\n\t_str = new char[str._size + 1];\n\tstrcpy(_str, str._str);\n\t_size = str._size;\n\t_capacity = str._capacity;\n}</code></pre>\n<p><strong>思路：先释放原来的空间，在开辟新的空间，把str对象的_str里的数据拷贝到自己的_str里，再让_size和_capacity都与str对象的_size和_capacity相同</strong></p>\n<p>二、现代写法</p>\n<pre><code>string&amp; operator=(string str)\n{\n\t/*::swap(str._str, _str);\n\t::swap(str._capacity, _capacity);\n\t::swap(str._size, _size);*/\n\tswap(str);//把这三个swap合并成了一个成员函数简化了一下代码\n\treturn *this;\n}</code></pre>\n<p>思路：<span style=\"color:#fe2c24;\">让形参是一个值而不是引用，那么传参的时候编译器就会调用上面的拷贝构造（深拷贝）去构造出与实参有着相同属性的形参，绕后再让自身对象的各个成员变量（属性）一一交换就好了，并且不用去释放空间，因为形参是局部变量出来定义域会自动调用析构函数清理数据，而我们经过交换把自己的各个属性都给了形参，形参就会帮我们调用析构函数自动清理原来的数据了，很棒！</span></p>\n<p></p>\n<h3 id=\"%E5%85%AD%E3%80%81%E5%B0%BE%E6%8F%92pushback\">六、尾插pushback</h3>\n<p>在字符串的尾部插入数据，可以是字符，也可以是字符串。</p>\n<p>一、插入单个字符</p>\n<p>既然是插入单个字符就是先判断容量够不够，不够就进行扩容，再把结束标准\\0设置好，最后把字符插入即可。</p>\n<pre><code>string&amp; pushback(char ch)\n{\n\tif (_capacity == _size)\n\t{\n\tchar* tmp = new char[_capacity == 0 ? 4 : _capacity * 2 + 1];\n\tstrncpy(tmp, _str, _size + 1);\n\tdelete[] _str;\n\t_str = tmp;\n\t_capacity *= 2;\n\t}//也可以复用reserve\n\n\t_str[_size] = ch;\n\t_str[_size + 1] = '\\0';\n\t++_size;\n\treturn *this;\n}</code></pre>\n<p><strong><span style=\"color:#4da8ee;\">下标问题：这里的_size表示的是有效字符的个数，因为小标从0开始，所以最后一个有效字符即使_str[size-1]了，那么_str[_size]就是\\0了。我们插入字符就要把\\0往后挪一个字符的位置就是上面的 _str[_size + 1] = '\\0'; 然后在\\0原来的位置放我们插入的字符_str[_size] = ch，最后更新_size。</span></strong></p>\n<p><strong><span style=\"color:#4da8ee;\">注意：这里的扩容最好用strncpy 否则特定情况会出bug 下面会详细提到</span></strong></p>\n<p>二、插入字符串</p>\n<p>实现一个尾插字符串的函数append(标准库也有的）</p>\n<pre><code>string&amp; append(const char* str)\n{\n\tassert(str);\n\tsize_t len = _size + strlen(str);//先算出插入字符串的总长度，\n//在与当前容量进行比较，判断是否需要扩容\n\tif (_capacity &lt; len)\n\t{\n\t\treserve(len);\n\t}\n\tstrcpy(_str + _size, str);\n\t_size += strlen(str);\n\treturn *this;\n}</code></pre>\n<p><span style=\"color:#fe2c24;\">append函数的实现思路也是先判断是否需要扩容，然后把要插入的字符串拷贝到对象的_str中更新_size(插入数据的思路都是大同小异的)</span></p>\n<p></p>\n<h3 id=\"%E4%B8%83%E3%80%81%E5%8A%A0%E7%AD%89%E5%AD%97%E7%AC%A6%E5%92%8C%E5%8A%A0%E7%AD%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C\">七、加等字符和加等字符串操作</h3>\n<p>加等字符和加等字符串的操作是和上面的插入字符和字符串的操作一样的 就可以复用上面的pushback 和 append 来实现他们 只是函数名不同，内在的实现逻辑是相同的</p>\n<p>1.加等字符</p>\n<pre><code>\tstring&amp; operator+=(char ch)//加等字符\n\t\t{\n\t\t\tpushback(ch);\n\t\t\treturn *this;\n\t\t}\n\t\t</code></pre>\n<p>2.加等字符串</p>\n<pre><code>string&amp; operator+=(const char* str)//加等字符串\n{\n\tassert(str);\n\tappend(str);//复用接口\n\treturn *this;\n}</code></pre>\n<p></p>\n<h3 id=\"%E5%85%AB%E3%80%81%E6%89%A9%E5%AE%B9(reserve)\">八、扩容(reserve)</h3>\n<p>因为string是类似线性表的，可以动态扩容，每次插入数据都需要判断是否需要进行扩容，上面那么多的插入，都需要判断是否需要扩容，那么就可以把扩容写成一个成员函数，需要扩容的时候调用它即可。</p>\n<p><span style=\"color:#ff9900;\"><strong>这里的reserve只是负责开辟空间，不负责初始化空间，只是_capacity会改变，_size是不会改变的</strong></span></p>\n<pre><code>void reserve(size_t len)\n{\n\tif (len &gt; _capacity)\n\t{\n\t\tchar* tmp = new char[len + 1];\n\t\tstrncpy(tmp, _str, _size + 1);//这里要用strncpy 否则再resize后会出现错误 如果填充字符是\\0那么就不会被拷贝到新空间 扩容后数据丢失 是个bug\n\t\tdelete[] _str;\n\t\t_str = tmp;\n\t\t_capacity = len;\n\t\t//_str[_capacity] = '\\0';//这个不能少 因为开辟的一块新空间最后要设置成\\0 防止在析构的时候会出现错误 不知道到哪里结束 注意 \n//上一行的注释是错的 不需要 这是多此一举 因为你如果插入数据或者扩容 本身的\\0 都是会被拷进去的 有效字符的结尾都会有一个\\0\n//不需要你在扩容后为它最后面加上\\0 它自己无论怎样都是\\0 在有效字符的最后的\n\t}\n}</code></pre>\n<p><span style=\"color:#4da8ee;\"><strong>reserve这里就有细节值得扣了，就是上面讲的最好用strncpy不要用strcpy的原因所在</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>问题就是：当我们调用了resize之后如果没有个默认的初始化空间的字符，就是默认的'\\0'；或者说我们自己给的初始化空间的字符就是‘\\0’,之后再调用reserve就会出现bug了</strong></span></p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\de20f090b0494d9c9aa1ba15c324268e.png\" width=\"1200\"/></p>\n<h3 id=\"%E4%B9%9D%E3%80%81%E6%89%A9%E5%AE%B9%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96(resize)\">九、扩容并初始化(resize)</h3>\n<p><span style=\"color:#a2e043;\"><strong>与reserve不同的是，resize 是开空间并且初始化的，给一个字符，将开辟出来的多于的空间用给的字符填充，更新_size，更新_capacity.</strong></span></p>\n<p></p>\n<pre><code>void resize(size_t n,char ch='\\0')\n{\n\tif (n &gt; _capacity)\n\t{\n\treserve(n);\n\tmemset(_str + _size,ch, n-_size);\n\t}\n\telse\n\t{\n\t_str[n] = '\\0';\n\t}\n\t_size = n;\n\n\t\t\t\n}</code></pre>\n<p>这里是<span style=\"color:#4da8ee;\">复用了reserve进行扩容然后用memset去初始化多余的空间</span>，初始化空间的范围是</p>\n<p><span style=\"color:#a2e043;\">(_str + _size,ch, n-_size)</span>，还有考虑缩容的情况，如<span style=\"color:#4da8ee;\">果是n小于_capacity就是缩容了</span>，直接在n下标对应的空间放上一颗零鸭蛋即可，<span style=\"color:#ff9900;\">最后更新_size</span></p>\n<p></p>\n<h3 id=\"%E5%8D%81%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0\">十、获取有效字符个数</h3>\n<p>这个就比较简单了 直接写个成员函数，返回_size 即可</p>\n<pre><code>size_t retsize()\n\t\t{\n\t\t\treturn _size;\n\t\t}</code></pre>\n<p></p>\n<h3 id=\"%E5%8D%81%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F_str%E7%9A%84%E5%87%BD%E6%95%B0c_str()\">十一、获取成员变量_str的函数c_str()</h3>\n<p>这个也比较好实现 写个成员函数返回_str即可</p>\n<pre><code>const char* c_str()\n\t\t{\n\t\t\treturn _str;\n\t\t}</code></pre>\n<p></p>\n<h3 id=\"%E5%8D%81%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82%EF%BC%88%E4%B8%A4%E7%A7%8D%E4%B8%8B%E6%A0%87%E6%B3%95%20%E4%B8%80%E7%A7%8D%E6%8C%87%E9%92%88%E6%B3%95%EF%BC%89\">十二、插入数据的三种方法详解及相关细节（两种下标法 一种指针法）</h3>\n<h3></h3>\n<p>随机插入也是string具有的功能，包括插入字符和字符串，插入的方法有三种。</p>\n<p><strong>一、字符的随机插入</strong></p>\n<p>1、下标法实现插入</p>\n<p><strong>通过对下标对数据进行挪动，在哪插入就从哪开始把数据往后挪动，空出位置来插入新数据</strong></p>\n<p>1.有缺陷的下标法 （不能是从下标为0的位置插入）</p>\n<pre><code>string&amp; insert(size_t pos,char ch)//有问题的写法\n\t\t{\n\t\t\tassert(pos &lt;= _size);//可以是等于_size相当于是尾插 但是不能超过_size 否则越界了\n\t\t\tsize_t end = _size;\n\t\t\twhile (end &gt;= pos)\n\t\t\t{\n\t\t\t\t_str[end + 1] = _str[end];\n\t\t\t\t--end;\n\t\t\t}\n\t\t\t_str[pos] = ch;\n\t\t\t_size++;\n\t\t\treturn *this;\n\t\t}</code></pre>\n<p></p>\n<p>2.没有缺陷的下标法（可以在任意下标进行插入）</p>\n<pre><code>\tstring&amp; insert(size_t pos, char ch)\n\t\t{\n\t\t\tassert(pos &lt;= _size);\n\t\t\tsize_t end = _size + 1;\n\t\t\twhile (end &gt; pos)\n\t\t\t{\n\t\t\t\t_str[end] = _str[end - 1];\n\t\t\t\t--end;\n\t\t\t}\n\t\t\t_str[pos] = ch;\n\t\t\t_size++;\n\t\t\treturn *this;\n\t\t}</code></pre>\n<p></p>\n<p>3.指针法</p>\n<pre><code>string&amp; insert(size_t pos, char ch)\n\t\t{\n\t\t\tassert(pos &lt;= _size);\n\t\t\tchar* end = _str + _size;\n\t\t\twhile (end &gt;= _str + pos)\n\t\t\t{\n\t\t\t\t*(end + 1) = *end;\n\t\t\t\t--end;\n\t\t\t}\n\t\t\t*(_str+pos) = ch;\n\t\t\t_size++;\n\t\t\treturn *this;\n\n\t\t}</code></pre>\n<p><span style=\"color:#4da8ee;\">指针法就直接是对指针指向的数据进行操作了，就没有数的转化了，就不用担心-1的情况了。</span></p>\n<p>注意：</p>\n<p><strong><span style=\"color:#fe2c24;\">这里的两种下标法只是四条代码不同,方法1 是让end等于_size下标（对应的\\0），然后让</span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\"> _str[end + 1] = _str[end] 这样的话如果是从0开始插入数据end最后就会变成-1 ，而-1对应的无符号整数是42亿九千万，会照成死循环；方法2是让end等于_size+1（对应的是\\0的下一个位置），然后让    _str[end] = _str[end - 1] 这样如果是从0开始插入数据，end最后就会变成0 ，最小的情况即使end变成0 ，是不会到-1去的，所以就很好地避开了-1的情况，就解决了缺陷；</span></strong></p>\n<p>具体步骤可以参考俺画的图（老费劲了）</p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\b13f4c510c1344dfbd9ec54c23a1e302.png\" width=\"1200\"/></p>\n<p></p>\n<p>下标法2是怎么解决下标法1的缺陷的具体图解（瞧一瞧吧）：</p>\n<p> <img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\4c46499b8da54cb3bcd2159e7ac6badc.png\" width=\"1200\"/></p>\n<p><strong> </strong></p>\n<p><strong>二、字符串的随机插入</strong></p>\n<p>也有指针法和下标法</p>\n<p>1.指针法</p>\n<pre><code>//2.指针法\n\t\tstring&amp; insert(size_t pos, const char* str)\n\t\t{\n\t\t\tassert(pos &lt;=_size);\n\t\t\t\n\t\t\t//char* end = _str + _size;//如果是用的指针法 这里的标记的最后一个指针的位置不能在扩容之前\n\t\t\t//因为扩容后空间就不是原来的空间了 而是新的空间 原来的空间被释放了 那么end所指向的还是原来的空间上的\\0是不可以\n\t\t\t//所以把end放在开辟好空间后再赋值 切记不可以放在扩容的前面  又是一个小细节！！\n\t\t\t//printf(\"%p\\n\", _str);\n\t\t\tsize_t len = strlen(str);\n\t\t\tif (_capacity &lt; _size + len)\n\t\t\t{\n\t\t\t\treserve(_size + len);\n\t\t\t}\n\t\t\t//printf(\"%p\\n\", _str);\n\n\t\t\tchar* end = _str + _size;\n\n\t\t\twhile (end &gt;= _str + pos)\n\t\t\t{\n\t\t\t\t*(end + len) = *end;\n\t\t\t\t--end;\n\t\t\t}\n\t\t\tstrncpy(_str + pos, str, len+1);//又疏忽了 这里是拷贝len+1个 len只是长度 还有一个\\0 也要\n\t\t\t_size += len;\n\t\t\treturn *this;\n\t\t}</code></pre>\n<p><strong><span style=\"color:#4da8ee;\">注意：这里也有细节要扣，end是用来记录原来字符串的\\0 的位置的，这里的end的初始化要在判断是否扩容的后面进行，否则会出现野指针的问题。因为如果要扩容的话，就会开辟新的空间然后把原来的数据拷贝到新空间，然后把这块空间赋值给原来的_str，相当于是内容没有变，容量变了，空间地址也变了，扩容前后是两块不同的空间，如果在判断扩容之前就初始化了end，那么如果下面进行了扩容_str就会是另一块新的空间了，那么后面循环里对end进行的操作就是非法的了，为什么呢？</span></strong></p>\n<p><span style=\"color:#a2e043;\"><strong>因为扩容后是_str指向的是新空间，end本应该新空间中数据中\\0的位置的指针，但是在扩容前就初始化了end的话那么end就是扩容前空间中数据中'\\0'位置的指针了，在扩容后end还是指向原来空间中\\0的位置，但是原来的空间已经被释放了，你这个时候再用end去访问原来的空间就是非法的，这时的end指针就是大名鼎鼎的“野指针”了！！！</strong></span></p>\n<p>2.下标法</p>\n<pre><code>1.下标法\n\t\tstring&amp; insert(size_t pos, const char* str)\n\t\t{\n\t\t\tassert(pos &lt;= _size);\n\t\t\tsize_t end = _size + 1;\n\t\t\tsize_t len = strlen(str);\n\t\t\tif (_capacity &lt; _size + len);\n\t\t\t{\n\t\t\t\treserve(_size + len);\n\t\t\t}\n\t\t\twhile (end &gt; pos)\n\t\t\t{\n\t\t\t\t_str[end + len-1] = _str[end-1];//这里是一个细节 要让两个方括号的差等于len 不能类比上面的插入字符的insert 写成_str[end + len] = _str[end-1] 会出错\n\t\t\t\t--end;\n\t\t\t}\n\t\t\tstrncpy(_str + pos, str, len);\n\t\t\t_size += len;\n\t\t\treturn *this;\n\n\t\t}</code></pre>\n<p>下标法也有细节：</p>\n<p><span style=\"color:#4da8ee;\"><strong>在写完随机插入字符的函数后，再写随机插入字符串的函数后，会有一个类比的思想，就是把在插入字符函数中的    _str[end] = _str[end - 1];基础之上想着，既然是插入字符串，那么就要从\\0开始往前直到pos位置的数据全部往后挪动插入字符串的长度个位置，也就是</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>_str[end+len] = _str[end - 1];我就是这样想当然地写，然后就错了，再调试调出了问题在哪；</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>这里是不能想当然地写的，我们要知道把数据往后挪插入字符串长度个距离，两个方括号里的数据差就要是字符串的长度，_str[end+len] = _str[end - 1];中很明显差值不是len 而是len+1</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>所以要写成_str[end+len-1] = _str[end - 1];才行，这也算是个小细节吧！！！</strong></span></p>\n<p></p>\n<h3 id=\"%E5%8D%81%E4%B8%89%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\">十三、删除数据</h3>\n<p>删除数据的思路与插入数据的思路相似，也是通过挪动数据，对要删除的数据进行覆盖处理，这里是用的strcpy来实现数据的挪动</p>\n<pre><code>\tstring&amp; erase(size_t pos, size_t len=::string::npos)\n\t\t{\n\t\t\tassert(pos &lt; _size);\n\t\t\tsize_t leftlen = _size - pos;//pos 是标从0开始 _size是长度不是从零开始 因为两个长度一剪再加1才是两者之间的个数 所以这里刚刚好减出来就是之间的元素个数\n\t\t\tif (leftlen &lt; len)//1.剩下的元素不足len\n\t\t\t{\n\t\t\t\t_str[pos] = '\\0';\n\t\t\t\t_size -= len;\n\t\t\t}\n\t\t\telse//2.剩下的元素多于len\n\t\t\t{\n\t\t\t\tstrcpy(_str + pos, _str + pos+len);//利用strcpy把后面的往前面拷贝\n\t\t\t\t_size -= len;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}</code></pre>\n<p><span style=\"color:#4da8ee;\"><strong>注意：删除要分情况</strong></span></p>\n<p><strong><span style=\"color:#ff9900;\">1.pos位置后剩下的字符个数小于要删除的字符个数</span></strong></p>\n<p><strong><span style=\"color:#ff9900;\">这种情况直接就把下标为pos的位置放上\\0 即可，即使代表把pos位置之后的所有数据全部删除</span></strong></p>\n<p><strong><span style=\"color:#ff9900;\">2.pos位置之后剩下的字符个数大于要删除的字符个数</span></strong></p>\n<p><strong><span style=\"color:#ff9900;\">这种情况就是把从下标从pos+len的位置往后的字符全部拷贝到从pos下标位置开始往后的空间中</span></strong></p>\n<p><strong><span style=\"color:#ff9900;\">可以调用strcpy实现    </span></strong></p>\n<p><strong><span style=\"color:#ff9900;\">即：strcpy(_str + pos, _str + pos+len);//利用strcpy把后面的往前面拷贝</span></strong></p>\n<p><strong><span style=\"color:#ff9900;\">最后不要忘了把_size-=len;更新_size</span></strong></p>\n<p></p>\n<h3 id=\"%E5%8D%81%E5%9B%9B%E3%80%81%E6%9F%A5%E6%89%BE%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%90%E4%B8%B2\">十四、查找单个字符和子串</h3>\n<p>这里用到了strstr函数来实现找子串的功能</p>\n<p>1.查找单个字符</p>\n<pre><code>size_t find(size_t pos, char ch)\n\t\t{\n\t\t\tassert(pos &lt; _size);\n\t\t\tfor (int i = 0+pos; i &lt; _size; i++)\n\t\t\t{\n\t\t\t\tif (_str[i] == ch)\n\t\t\t\t{\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ::string::npos;\n\t\t}</code></pre>\n<p>遍历思想，如果找到了就返回下标，否则返回string中的npos （无符号整形的-1 ）</p>\n<p>2.查找字符串</p>\n<p>复用strstr来实现</p>\n<pre><code>\t//查找字符串\n\t\tsize_t find(size_t pos, const char* str)const//不改变成员变量的函数最好都加上const 修饰的是this指针指向的对象 使对象的成员不能被修改\n\t\t{\n\t\t\tassert(pos &lt; _size);\n\t\t\tchar* ret = strstr(_str+pos, str);\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\treturn ret - _str;//这里要的是下标 所以不用加一 求个数才要加一\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn ::string::npos;\n\t\t\t}\n\t\t}</code></pre>\n<p></p>\n<h3 id=\"%E5%8D%81%E4%BA%94%E3%80%81%E7%AE%80%E6%98%93%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0\">十五、简易迭代器遍历的实现</h3>\n<p>利用了<strong><span style=\"color:#4da8ee;\">typedef把iterator 和const_iterator定义为char*和const char*类型</span></strong></p>\n<p>然后各自写两个函数begin（）和end（）作为迭代器的开始和结束</p>\n<p><span style=\"color:#4da8ee;\"><strong>begin是返回_str   而 end是返回_str+_size ,相当于是头尾指针 </strong></span></p>\n<pre><code>\t    typedef char* iterator;\n\t\ttypedef const char* const_iterator;\n\t\titerator begin()\n\t\t{\n\t\t\treturn _str;\n\t\t}\n\t\titerator end()\n\t\t{\n\t\t\treturn _str + _size;\n\t\t}\n\t\tconst_iterator begin()const\n\t\t{\n\t\t\treturn _str;\n\t\t}\n\t\tconst_iterator end()const\n\t\t{\n\t\t\treturn _str + _size;\n\t\t}\n\t</code></pre>\n<p>在函数中使用实现的简易的迭代器去遍历输出字符串</p>\n<pre><code>void testitrator()\n\t{\n\t\tstring a(\"a nice day!\");\n\t\tstring::iterator it = a.begin();\n\t\twhile (it != a.end())\n\t\t{\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\t++it;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}</code></pre>\n<p>运行结果如下：</p>\n<p><img alt=\"\" height=\"401\" src=\"..\\..\\static\\image\\263b3833bbcd44e5a5aa5ab1e3a80eda.png\" width=\"1200\"/></p>\n<p></p>\n<h3 id=\"%E5%8D%81%E5%85%AD%E3%80%81%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83\">十六、类的直接比较</h3>\n<p>实现像比较数字一样比较类（字符串）的大小</p>\n<p>这里用到了strcmp来实现</p>\n<pre><code>//比较两个字符串 可以用函数strcmp\n\tbool operator&gt;(string&amp; str1, string&amp; str2)\n\t{\n\t\treturn strcmp(str1.c_str(), str2.c_str()) &gt; 0;\n\n\t}\n\tbool operator&lt;(string&amp; str1, string&amp; str2)\n\t{\n\t\treturn !(str1 &gt; str2);\n\n\t}\n\tbool operator==(string&amp; str1, string&amp; str2)\n\t{\n\t\treturn strcmp(str1.c_str(), str2.c_str()) == 0;\n\n\t}\n\tbool operator!=(string&amp; str1, string&amp; str2)\n\t{\n\t\treturn !(str1 == str2);\n\n\t}\n\tbool operator&gt;=(string&amp; str1, string&amp; str2)\n\t{\n\t\treturn str1&gt;str2||str1==str2;\n\n\t}\n\tbool operator&lt;=(string&amp; str1, string&amp; str2)\n\t{\n\t\treturn str1 &lt; str2 || str1 == str2;\n\n\t}</code></pre>\n<p>实现了大于小于等于，剩下的借口就可以复用他们来实现了 </p>\n<p><img alt=\"\" height=\"384\" src=\"..\\..\\static\\image\\dd8feadb54c84f3c9ecfb15610a3736f.png\" width=\"1200\"/></p>\n<p></p>\n<h3 id=\"%E5%8D%81%E4%B8%83%E3%80%81%E7%B1%BB%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA\">十七、类的直接输入输出</h3>\n<p>实现像基本类型一样直接输出string对象总的字符串</p>\n<p>1.输出</p>\n<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; out, string&amp; s)\n\t{\n\t\tfor (auto ch : s)\n\t\t{\n\t\t\tout &lt;&lt; ch;\n\t\t\t//ch++; 因为这里是范围for 所以不用自己写加加 他自己会自动加的\n\t\t}\n\t\treturn out;\n\n\t}</code></pre>\n<p>这里要返回的是输出流的引用，使得可以连续地输出，out 是ostream的对象。</p>\n<p>2.输入</p>\n<pre><code>istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; str)\n\t{\n\t\t//如果是本来就有数据的字符串再输入 那就要把原来的数据清理掉 然后size变成0 \n\t\tstr.clear();\n\t\tchar ch;\n\t\t//in.get(ch);\n\t\tch = in.get();//这样用才是对的 上面的是错的\n\t\twhile (ch != '\\0' &amp;&amp; ch != '\\n')\n\t\t{\n\t\t\tstr += ch;\n\t\t\tin.get(ch);\n\t\t}\n\t\treturn in;\n\t}</code></pre>\n<p><span style=\"color:#4da8ee;\"><strong> 注意这里不能直接用in来输入，因为in遇到字符'\\0'和字符'\\n'就会自动忽略，然后程序就不动了，崩了。要用ostream类的in对象的get方法来接收输入的值，相当于C语言中的getchar（），可以接收\\n 和 \\0.除了EOF其他都可以接收。 </strong></span></p>\n<p></p>\n<h3 id=\"%E5%8D%81%E5%85%AB%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%ADgetline%E7%AE%80%E6%98%93%E7%9A%84%E5%AE%9E%E7%8E%B0\">十八、标准库中getline简易的实现</h3>\n<p>getline 是输入一个串 要包括空格在内 cin和cout 都是遇到\\n 和 \\0 就停止的，根据上面的输入可以改变一下条件实现输入的是一个可以包括空格的字符串，那就是把<span style=\"color:#ff9900;\"><strong>while里的ch！= '\\0' 去掉就可以了。</strong></span></p>\n<pre><code>istream&amp; getline(istream&amp; in, string&amp; str)\n\t{\n\t\tstr.clear();\n\t\tchar ch;\n\t\t//in.get(ch);\n\t\tch = in.get();\n\t\twhile (ch != '\\n')\n\t\t{\n\t\t\tstr += ch;\n\t\t\tin.get(ch);\n\t\t}\n\t\treturn in;\n\t}\n\t</code></pre>\n<h3>补充、std::swqp 和 string 自带的成员函数 swap 的区别</h3>\n<p>std::swap 的原理是深拷贝，而string自带的swap是交换两个对象的指针，相比较于全局的swap</p>\n<p>string自带的swap的效率更高 。</p>\n<p><img alt=\"\" height=\"216\" src=\"..\\..\\static\\image\\0f92f94b08a14a8bb180c4eae9296552.png\" width=\"821\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\ef69c0597230b6ab69f42c484b8bbf3c.png\"/></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/bd4039bd5002ae79b0046af67e261d26.gif\"/></p>\n<p></p>\n<p>好了 本文到此就结束了~</p>\n<p>如果喜欢的话就留下你来过的痕迹吧！</p>\n<p>附上源码：<a href=\"https://gitee.com/zhang-hua1313/c-code/blob/master/realization%20of%20string/string.cpp\" title=\"realization of string/string.cpp · 张华/c++code - 码云 - 开源中国 (gitee.com)\">realization of string/string.cpp · 张华/c++code - 码云 - 开源中国 (gitee.com)</a></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-24 20:17:24", "summary": "中的类翻译过来就是字符串类型但是它可不是一个平平无奇的字符串它具有像线性表一样的增删查改的功能会自动扩容还支持迭代器遍历功能可谓十分齐全下面就来实现它实现的功能总览：目录一、构造函数二、拷贝构造函数传"}