{"blogid": "123515964", "writerAge": "码龄182天", "writerBlogNum": "3", "writerCollect": "37", "writerComment": "4", "writerFan": "6", "writerGrade": "1级", "writerIntegral": "51", "writerName": "市外高人47", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123515964.jpg", "writerRankTotal": "187955", "writerRankWeekly": "1071904", "writerThumb": "17", "writerVisitNum": "5845", "blog_read_count": "3217", "blog_time": "于 2022-03-16 20:32:01 发布", "blog_title": "C++之多线程编程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:justify;\"><span style=\"color:#fe2c24;\">一、并发的实现</span></p>\n<p style=\"text-align:justify;\">        1.多进程并发主要解决进程间通信的问题</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">                ①同一电脑上：管道、文件、消息队列、内存共享。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">                ②不同电脑上：socket网络通信。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">        2. 单进程中的多个线程并发（一个主线程+多个子线程实现并发）</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">                ①一个进程中的所有线程共享内存空间 eg：全局变量，指针引用</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"text-align:justify;\"><span style=\"color:#fe2c24;\">二、线程的多种创建方式</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#fe2c24;\"> 1. 调用thread类去创建线程对象</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#0d0016;\">        头文件和子线程处理函数（以下所有代码段共用）：</span></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;thread&gt;\n#include&lt;windows.h&gt;\nusing namespace std;\n\n//线程处理函数\nvoid print() {\n\tSleep(3000);\n\tcout &lt;&lt; \"子线程运行喽........\" &lt;&lt; endl;\n}</code></pre>\n<p style=\"text-align:justify;\">               <span style=\"color:#fe2c24;\"> 注：如果创建一个线程而不做处理，会调用abort函数中止程序</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#fe2c24;\">                        一个线程只能join一次，否则也会abort。</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#fe2c24;\">     </span><span style=\"color:#0d0016;\">   1.1. 使用join()函数加入，汇合线程，阻塞主线程，等待子进程执行结束，才会回到主线程</span></p>\n<p style=\"text-align:justify;\"></p>\n<pre><code>int main(){\n\t//创建线程\n\tthread test1(print);\n\ttest1.join();        //阻塞（若test1线程未执行完，则主线程不会打印）\n\tcout &lt;&lt; \"主线程运行喽.........\" &lt;&lt; endl;\n}</code></pre>\n<p style=\"text-align:justify;\"><span style=\"color:#0d0016;\">运行说明：三秒后依次打印出</span></p>\n<p style=\"text-align:justify;\"><img alt=\"\" height=\"69\" src=\"..\\..\\static\\image\\e34a7f778e994261a6fe49a679890624.png\" width=\"254\"/></p>\n<p> </p>\n<p style=\"text-align:justify;\"><span style=\"color:#0d0016;\">1.2. 使用detach()函数，打破依赖关系，把子线程驻留后台</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#0d0016;\">        </span><span style=\"color:#fe2c24;\">注：线程detach后，就不能在join了</span> </p>\n<pre><code>int main(){\n\t//创建线程\n\tthread test1(print);\n\ttest1.detach();\n\tcout &lt;&lt; \"主线程运行喽.........\" &lt;&lt; endl;\n}</code></pre>\n<p>运行说明：直接只打印出：</p>\n<p><img alt=\"\" height=\"49\" src=\"..\\..\\static\\image\\5540cf82ed40408fafec5c7706f29fb6.png\" width=\"250\"/></p>\n<p> </p>\n<p>1.3 使用joinable()函数判断当前线程是否可以做join或者detach操作，若可以，返回true。</p>\n<pre><code>int main(){\n\t//创建线程\n\tthread test1(print);\n\ttest1.detach();\n\tcout &lt;&lt; \"主线程运行喽.........\" &lt;&lt; endl;\n\tif (test1.joinable())\n\t\ttest1.join();\n\telse\n\t\tcout &lt;&lt; \"该子线程已经被处理啦.....\" &lt;&lt; endl;\n}</code></pre>\n<p>运行说明：</p>\n<p><img alt=\"\" height=\"54\" src=\"..\\..\\static\\image\\65bcdec56dc249a48ea8ea273405aa7c.png\" width=\"289\"/></p>\n<p> </p>\n<p><span style=\"color:#fe2c24;\">2.  通过类和对象创建线程</span></p>\n<pre><code>class Li {\npublic:\n\n\t//STL仿函数\n\tvoid operator()() {\n\t\tcout &lt;&lt; \"子线程启动喽.....\" &lt;&lt; endl;\n\t}\n};\nint main(){\n\t//正常写法:对象充当线程处理函数\n\tLi li;\n\tthread test1(li);\n\ttest1.join();\n\n\tLi(); //无名对象\n\tthread test2((Li()));   //这里如果不多写一个括号，编译器就会把test2解析成一个函数，Li()解析成一个参数，从而出错\n\ttest2.join();\n\t\n}</code></pre>\n<p>运行：</p>\n<p><img alt=\"\" height=\"54\" src=\"..\\..\\static\\image\\adfdbfd818644ae980c22648a20df6b9.png\" width=\"225\"/></p>\n<p> </p>\n<p><span style=\"color:#fe2c24;\">3. 带参的方式创建线程</span></p>\n<pre><code>//传引用可以改变num的实际值\nvoid printInfo(int&amp; num) {\n\tcout &lt;&lt; \"子线程运行喽....\" &lt;&lt; endl;\n}\nint main(){\n\tint num = 0;\n\t//ref 用于包装 “引用传递值” \n\tthread test1(printInfo, ref(num));\n\ttest1.join();\n\tcout &lt;&lt; \"我是主线程....\" &lt;&lt; endl;\n\t\n}</code></pre>\n<p>运行：<br/><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\bc7caca520b94c6da0b7e7f61b294dac.png\" width=\"213\"/></p>\n<p><span style=\"color:#fe2c24;\">4. Lambda表达式创建线程</span></p>\n<pre><code>int Max(int a, int b) {\n\treturn a &gt; b ? a : b;\n}\nint main(){\n\tint (*pMax)(int, int) = nullptr;\n\tpMax = [](int a, int b)-&gt;int {return a &gt; b ? a : b; };\n\t[] {cout &lt;&lt; \"helloword\" &lt;&lt; endl; }();\n\tcout &lt;&lt; pMax(3, 5) &lt;&lt; endl;\n\tthread test1([] {cout &lt;&lt; \"我是子线程...\" &lt;&lt; endl; });\n\ttest1.join();\n\tcout &lt;&lt; \"我是主线程...\" &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p>运行：</p>\n<p><img alt=\"\" height=\"99\" src=\"..\\..\\static\\image\\00c8965f85994f1abc52c2c406357d43.png\" width=\"215\"/></p>\n<p> </p>\n<p><span style=\"color:#fe2c24;\">5. 以智能指针为参数创建线程</span></p>\n<pre><code>void print(unique_ptr&lt;int&gt; ptr) {\n\tcout &lt;&lt; \"我是子线程：\" &lt;&lt; ptr.get()&lt;&lt;endl;\n}\nint main(){\n\tint* p = new int(100);\n\tunique_ptr&lt;int&gt; ptr(p);\n\tcout &lt;&lt; \"我是主线程:\" &lt;&lt; ptr.get() &lt;&lt; endl;\n\tthread test1(print, move(ptr)); //move移动语义，通俗的说就是把ptr移动到子线程中了，这样的话，主线程中的ptr就没了    \n\ttest1.join();\n\tcout &lt;&lt; \"我是主线程:\" &lt;&lt; ptr.get()&lt;&lt;endl;\n\t\n}</code></pre>\n<p>运行：</p>\n<p><img alt=\"\" height=\"74\" src=\"..\\..\\static\\image\\bf59f95f9d3742b2a50baa474f900cd0.png\" width=\"243\"/></p>\n<p> </p>\n<p><span style=\"color:#fe2c24;\">6. 以类的成员函数充当线程处理函数来创建线程</span></p>\n<pre><code>class Li {\npublic:\n\tvoid print(int&amp; num) {\n\t\tnum = 1001;\n\t\tcout &lt;&lt; \"我是子线程：\" &lt;&lt; this_thread::get_id() &lt;&lt; endl;\n\t}\n};\nint main(){\n\tLi li;\n\tint num = 1007;\n\t//需要说明 是哪个对象\n\tthread test1(&amp;Li::print,li,ref(num));\n\ttest1.join();\n\tcout &lt;&lt; \"我是主线程:\" &lt;&lt; this_thread::get_id()&lt;&lt;endl;\n\t\n}</code></pre>\n<p>运行：</p>\n<p><img alt=\"\" height=\"63\" src=\"..\\..\\static\\image\\0466e0fd4a024195abeac0b04da67495.png\" width=\"216\"/></p>\n<p> </p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-16 20:32:01", "summary": "一、并发的实现多进程并发主要解决进程间通信的问题同一电脑上：管道、文件、消息队列、内存共享。不同电脑上：网络通信。单进程中的多个线程并发一个主线程多个子线程实现并发一个进程中的所有线程共享内存空间：全"}