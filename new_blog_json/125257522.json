{"blogid": "125257522", "writerAge": "码龄1年", "writerBlogNum": "29", "writerCollect": "115", "writerComment": "19", "writerFan": "58", "writerGrade": "3级", "writerIntegral": "408", "writerName": "小白还在写代码", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125257522.jpg", "writerRankTotal": "40300", "writerRankWeekly": "26038", "writerThumb": "90", "writerVisitNum": "12184", "blog_read_count": "1571", "blog_time": "于 2022-06-13 12:31:32 发布", "blog_title": "C++关键字override", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"override_1\"></a>一、什么是override</h1>\n<p>override的翻译是覆盖。实际上它在C++中可以检测哪些虚函数没有被重写并报错<br/> 注：在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息。</p>\n<h1><a id=\"_5\"></a>二、使用步骤</h1>\n<p>先定义一个基类，基类中的func被声明为一个虚函数</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Base</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base的构造函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base的func的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">virtual</span> <span class=\"token operator\">~</span><span class=\"token function\">Base</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base的析构函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码<br/> （纯）虚析构可以解决父类指针释放子类对象</p>\n</blockquote>\n<p>派生类对func函数重写</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Son</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Son的构造函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">override</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token operator\">~</span><span class=\"token function\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Son的析构函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Son</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Son的func函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tBase<span class=\"token operator\">*</span> son <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Son<span class=\"token punctuation\">;</span>\n\tson<span class=\"token operator\">-&gt;</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> son<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>运行结果<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f3a1155bc7db478e900e7b3c47d5d70d.png\"/></p>\n<blockquote>\n<p>派生类对象实例化时会创建基类 构建先有父 再有子 析构反之<br/> 派生类的func覆盖重写了基类的func</p>\n</blockquote>\n<p>今天做题时看见之前没见过的关键字override，浅浅记录一下</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-13 12:31:32", "summary": "一、什么是的翻译是覆盖。实际上它在中可以检测哪些虚函数没有被重写并报错注：在派生类的成员函数中使用时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息。二、使用步骤先定义一个基"}