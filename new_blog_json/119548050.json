{"blogid": "119548050", "writerAge": "码龄11年", "writerBlogNum": "28", "writerCollect": "552", "writerComment": "29", "writerFan": "134", "writerGrade": "3级", "writerIntegral": "422", "writerName": "李宥小哥", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_119548050.jpg", "writerRankTotal": "34456", "writerRankWeekly": "14039", "writerThumb": "121", "writerVisitNum": "89737", "blog_read_count": "6915", "blog_time": "于 2021-08-09 22:04:46 发布", "blog_title": "C#高级--反射详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"C_0\"></a>C#高级–反射详解</h1>\n<h2><a id=\"httpsblogcsdnnetliyou123456789articledetails119715435_1\"></a><a href=\"https://blog.csdn.net/liyou123456789/article/details/119715435\">零、文章目录</a></h2>\n<h2><a id=\"_3\"></a>一、反射是什么</h2>\n<h3><a id=\"1C_5\"></a>1、C#编译运行过程</h3>\n<p>高级语言-&gt;编译-&gt;dll/exe文件-&gt;CLR/JIT-&gt;机器码</p>\n<p><img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\05b841fa71ac4f899614cf0797a3ec3d.png\"/></p>\n<h3><a id=\"2_11\"></a>2、原理解析</h3>\n<p><mark>metadata</mark>：元数据数据清单，记录了dll中包含了哪些东西,是一个描述。<br/> <mark>IL</mark>：中间语言，编译把高级语言编译后得到的C#中最真实的语言状态，面向对象语言。</p>\n<p><mark>反射</mark>：来自于System.Reflection，是一个帮助类库，可以读取dll/exe中metadata，使用metadata创建对象。</p>\n<p><mark>Emit</mark>：一种反射技术，可以动态创建dll/exe。</p>\n<p><mark>反编译工具</mark>：ILSpy可以反编译dll/exe，查看对应的C#/IL代码。</p>\n<h2><a id=\"_22\"></a>二、反射创建对象</h2>\n<h3><a id=\"1dll_24\"></a>1、动态读取dll</h3>\n<ul><li>LoadFrom：dll全名称，需要后缀</li><li>LoadFile：全路径，需要dll后缀</li><li>Load：dll名称不需要后缀</li></ul>\n<pre><code class=\"prism language-C#\">//1、动态读取dll的三种方式\n//（1）LoadFrom：dll全名称，需要后缀                        \nAssembly assembly = Assembly.LoadFrom(\"Business.DB.SqlServer.dll\");\n//（2）LoadFile：全路径，需要dll后缀\n//Assembly assembly1 = Assembly.LoadFile(@\"dll文件全路径\");\n//（3）Load：dll名称 不需要后缀\n//Assembly assembly2 = Assembly.Load(\"Business.DB.SqlServer\");\n</code></pre>\n<h3><a id=\"2_40\"></a>2、获取类型</h3>\n<pre><code class=\"prism language-C#\">//2、获取某一个具体的类型，参数需要是类的全名称\nType type1 = assembly.GetType(\"Business.DB.SqlServer.SqlServerHelper\");\n</code></pre>\n<h3><a id=\"3_47\"></a>3、创建对象</h3>\n<ul><li>直接传类型</li><li>重载方法，传dll的全名称</li><li>返回值是object类型，不能直接调用方法</li></ul>\n<pre><code class=\"prism language-C#\">//3、创建对象\n//（1）直接传类型\nobject? oInstance = Activator.CreateInstance(type1);\n//（2）重载方法，传dll的全名称\n//object? oInstanc1= Activator.CreateInstance(\"Business.DB.SqlServer.dll\", \"Business.DB.SqlServer.SqlServerHelper\");\n//a.oInstance.Query();//报错了：因为oInstance当做是一个object类型，object类型是没有Query方法；C#语言是一种强类型语言；编译时决定你是什么类型,以左边为准；不能调用是因为编译器不允许；实际类型一定是SqlServerHelper；\n//b.如果使用dynamic 作为类型的声明，在调用的时候，没有限制；\n//c.dynamic :动态类型：不是编译时决定类型，避开编译器的检查；运行时决定是什么类型\n//d.dynamic dInstance = Activator.CreateInstance(type);\n//e.dInstance.Query();\n//f.dInstance.Get(); //报错了--因为SqlServerHelper没有Get方法\n</code></pre>\n<h3><a id=\"4_67\"></a>4、类型转换</h3>\n<pre><code class=\"prism language-C#\">//4、类型转换\n// SqlServerHelper helper = (SqlServerHelper)oInstance; //不建议这样转换--如果真实类型不一致--会报报错； \nIDBHelper helper = oInstance as IDBHelper;//如果类型一直，就转换，如果不一致；就返回null\n</code></pre>\n<h3><a id=\"5_75\"></a>5、调用方法</h3>\n<pre><code class=\"prism language-C#\">//5、调用方法\nhelper.Query();\n</code></pre>\n<h2><a id=\"_83\"></a>三、反射创建对象封装</h2>\n<p>问题：反射创建对象代码很多。</p>\n<ul><li>其实除了dll的名称和类的全名称都是一样的代码，可以封装反射创建对象帮助类。</li><li>传入的参数都是字符串，可做成配置项，提高代码扩展性和灵活性，可以做到不修改代码而改变程序的功能。</li></ul>\n<h3><a id=\"1_90\"></a>1、反射创建对象封装</h3>\n<p>（1）创建SqlServerHelper的时候，没有依赖SqlServerHelper</p>\n<p>（2）依赖的是两个字符串Business.DB.SqlServer.dll + Business.DB.SqlServer.SqlServerHelper，从配置文件读取。</p>\n<p>（3）去掉个对细节的依赖的：依赖于抽象，不再依赖于细节；依赖倒置原则； 增强代码的稳定性；</p>\n<pre><code class=\"prism language-C#\">using Business.DB.Interface;\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Reflection;\n\nnamespace MyReflecttion\n{\n    public class SimpleFactory\n    {\n        //创建SqlServerHelper的时候，没有依赖SqlServerHelper\n        //依赖的是两个字符串Business.DB.SqlServer.dll + Business.DB.SqlServer.SqlServerHelper\n        //去掉个对细节的依赖的：依赖于抽象，不再依赖于细节；依赖倒置原则； 增强代码的稳定性；\n        public static IDBHelper CreateInstance()\n        {  \n            string ReflictionConfig = CustomConfigManager.GetConfig(\"ReflictionConfig\"); \n            //Business.DB.SqlServer.SqlServerHelper,Business.DB.SqlServer.dll \n            string typeName = ReflictionConfig.Split(',')[0];\n            string dllName = ReflictionConfig.Split(',')[1];\n\n            //Assembly assembly = Assembly.LoadFrom(\"Business.DB.SqlServer.dll\"); \n            //Type type = assembly.GetType(\"Business.DB.SqlServer.SqlServerHelper\");\n\n            Assembly assembly = Assembly.LoadFrom(dllName); \n            Type type = assembly.GetType(typeName);\n\n            object? oInstance = Activator.CreateInstance(type);\n            IDBHelper helper = oInstance as IDBHelper; \n            return helper; \n        }\n    }\n\n    public static class CustomConfigManager\n    {\n        //Core 读取配置文件：appsettings\n        //1.Microsoft.Extensions.Configuration；\n        //2.Microsoft.Extensions.Configuration.Json \n        public static string GetConfig(string key)\n        {\n            var builder = new ConfigurationBuilder().AddJsonFile(\"appsettings.json\");  //默认读取  当前运行目录\n            IConfigurationRoot configuration = builder.Build();\n            string configValue = configuration.GetSection(key).Value;\n            return configValue;\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"2_146\"></a>2、配置文件</h3>\n<pre><code class=\"prism language-json\"><span class=\"token string\">\"ReflictionConfig\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Business.DB.Orcale.OrcaleHelper,Business.DB.Orcale.dll\"</span>\n</code></pre>\n<h3><a id=\"3_152\"></a>3、程序调用</h3>\n<p>如果公司来了一个新的技术经理：要将SqlServer换成MySql<br/> （1）传统方式，必须要修改代码，然后必须要重新编译发布，步骤很多</p>\n<p>（2）反射实现：断开了对普通类的依赖；依赖于配置文件+接口（抽象），做到了程序的可配置</p>\n<p>（3）反射实现的步骤：按照接口约定实现一个Mysql帮助类库，Copy dll 文件到执行目录下，修改配置文件</p>\n<pre><code class=\"prism language-C#\">IDBHelper helper1 = SimpleFactory.CreateInstance();\nhelper1.Query();\n</code></pre>\n<h2><a id=\"_166\"></a>四、反射创建对象之破环单例</h2>\n<p>除了反射之外，没有其他的方法来调用私有化构造函数的；私有化的方法就只能从内部访问；元数据中只要有的，反射都可以给找出来； 完全不用关注权限问题；</p>\n<h3><a id=\"1_170\"></a>1、单例类代码</h3>\n<pre><code class=\"prism language-C#\">using System;\n\nnamespace MyReflecttion\n{\n    /// &lt;summary&gt;\n    /// 单例模式：类，能保证在整个进程中只有一个实例\n    /// &lt;/summary&gt;\n    public sealed class Singleton\n    {\n        private static Singleton _Singleton = null;\n        /// &lt;summary&gt;\n        /// 创建对象的时候执行\n        /// &lt;/summary&gt;\n        private Singleton()\n        {\n            Console.WriteLine(\"Singleton被构造\");\n        }\n\n        /// &lt;summary&gt;\n        /// 被CLR 调用 整个进程中 执行且只执行一次\n        /// &lt;/summary&gt;\n        static Singleton()\n        {\n            _Singleton = new Singleton();\n        }\n\n        public static Singleton GetInstance()\n        {\n            return _Singleton;\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"2_207\"></a>2、传统手艺创建单例类对象</h3>\n<pre><code class=\"prism language-C#\">//1、传统手艺创建单例类对象\nConsole.WriteLine(\"********************传统单例***************************\");\nSingleton singleton1 = Singleton.GetInstance();\nSingleton singleton2 = Singleton.GetInstance();\nSingleton singleton3 = Singleton.GetInstance();\nSingleton singleton4 = Singleton.GetInstance();\nConsole.WriteLine(object.ReferenceEquals(singleton1, singleton2));\nConsole.WriteLine(object.ReferenceEquals(singleton2, singleton3));\nConsole.WriteLine(object.ReferenceEquals(singleton1, singleton4));\nConsole.WriteLine(\"********************传统单例***************************\");\n</code></pre>\n<h3><a id=\"3_222\"></a>3、反射方式创建单例类对象</h3>\n<pre><code class=\"prism language-C#\">//2、反射方式创建单例类对象\nConsole.WriteLine(\"********************反射单例***************************\");\nAssembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.Singleton\");\nSingleton singleton1 = (Singleton)Activator.CreateInstance(type, true);\nSingleton singleton2 = (Singleton)Activator.CreateInstance(type, true);\nSingleton singleton3 = (Singleton)Activator.CreateInstance(type, true);\nSingleton singleton4 = (Singleton)Activator.CreateInstance(type, true);\nConsole.WriteLine(object.ReferenceEquals(singleton1, singleton2));\nConsole.WriteLine(object.ReferenceEquals(singleton2, singleton3));\nConsole.WriteLine(object.ReferenceEquals(singleton1, singleton4));\nConsole.WriteLine(\"********************反射单例***************************\");\n</code></pre>\n<h3><a id=\"4_239\"></a>4、运行结果</h3>\n<pre><code class=\"prism language-bash\">********************传统单例***************************\nSingleton被构造\nTrue\nTrue\nTrue\n********************传统单例***************************\n********************反射单例***************************\nSingleton被构造\nSingleton被构造\nSingleton被构造\nSingleton被构造\nFalse\nFalse\nFalse\n********************反射单例***************************\n</code></pre>\n<h2><a id=\"_259\"></a>五、反射创建对象详解</h2>\n<h3><a id=\"1_261\"></a>1、创建测试类</h3>\n<blockquote>\n<p>普通类重载方法</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">using System;\n\nnamespace MyReflecttion\n{\n    /// &lt;summary&gt;\n    /// 反射测试类\n    /// &lt;/summary&gt;\n    public class ReflectionTest\n    {\n        #region Actor\n        /// &lt;summary&gt;\n        /// 无参构造函数\n        /// &lt;/summary&gt;\n        public ReflectionTest()\n        {\n            Console.WriteLine($\"这里是{this.GetType()} 无参数构造函数\");\n        }\n\n        /// &lt;summary&gt;\n        /// 带参数构造函数\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n        public ReflectionTest(string name)\n        {\n            Console.WriteLine($\"这里是{this.GetType()} 有参数构造函数\");\n        }\n\n        public ReflectionTest(int id)\n        {\n            Console.WriteLine($\"这里是{this.GetType()} 有参数构造函数\");\n        }\n\n        public ReflectionTest(int id, string name)\n        {\n            Console.WriteLine($\"这里是{this.GetType()} 有参数构造函数\");\n        }\n\n        public ReflectionTest(string name,int id )\n        {\n            Console.WriteLine($\"这里是{this.GetType()} 有参数构造函数\");\n        }\n        #endregion\n\n        #region Method\n        /// &lt;summary&gt;\n        /// 无参方法\n        /// &lt;/summary&gt;\n        public void Show1()\n        {\n            Console.WriteLine($\"这里是{this.GetType()}的Show1\" );\n        }\n\n        /// &lt;summary&gt;\n        /// 有参数方法\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"id\"&gt;&lt;/param&gt;\n        public void Show2(int id)\n        {\n\n            Console.WriteLine($\"这里是{this.GetType()}的Show2\");\n        }\n\n        /// &lt;summary&gt;\n        /// 重载方法之一\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"id\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n        public void Show3(int id, string name)\n        {\n            Console.WriteLine($\"这里是{this.GetType()}的Show3\");\n        }\n\n        /// &lt;summary&gt;\n        /// 重载方法之二\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"id\"&gt;&lt;/param&gt;\n        public void Show3(string name, int id)\n        {\n            Console.WriteLine($\"这里是{this.GetType()}的Show3_2\");\n        }\n\n        /// &lt;summary&gt;\n        /// 重载方法之三\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"id\"&gt;&lt;/param&gt;\n        public void Show3(int id)\n        {\n\n            Console.WriteLine($\"这里是{this.GetType()}的Show3_3\");\n        }\n\n        /// &lt;summary&gt;\n        /// 重载方法之四\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n        public void Show3(string name)\n        {\n\n            Console.WriteLine($\"这里是{this.GetType()}的Show3_4\");\n        }\n\n        /// &lt;summary&gt;\n        /// 重载方法之五\n        /// &lt;/summary&gt;\n        public void Show3()\n        {\n            Console.WriteLine($\"这里是{this.GetType()}的Show3_1\");\n        }\n\n        /// &lt;summary&gt;\n        /// 私有方法\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n        private void Show4(string name)  //肯定是可以的\n        {\n            Console.WriteLine($\"这里是{this.GetType()}的Show4\");\n        }\n        /// &lt;summary&gt;\n        /// 静态方法\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n        public static void Show5(string name)\n        {\n            Console.WriteLine($\"这里是{typeof(ReflectionTest)}的Show5\");\n        }\n        #endregion\n    }\n}\n</code></pre>\n<blockquote>\n<p>泛型方法泛型类</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">using System;\n\nnamespace MyReflecttion\n{\n\n    public class GenericMethod\n    {\n        public void Show&lt;T, W, X&gt;(T t, W w, X x)\n        {\n            Console.WriteLine($\"t.type={t.GetType().Name},w.type={ w.GetType().Name},x.type={x.GetType().Name}\");\n        }\n    }\n\n\n    public class GenericClass&lt;T, W, X&gt;\n    {\n        public void Show(T t, W w, X x)\n        {\n            Console.WriteLine($\"t.type={t.GetType().Name},w.type={w.GetType().Name},x.type={x.GetType().Name}\");\n        }\n    }\n     \n    public class GenericDouble&lt;T&gt;\n    {\n        public void Show&lt;W, X&gt;(T t, W w, X x)\n        {\n            Console.WriteLine($\"t.type={t.GetType().Name},w.type={w.GetType().Name},x.type={x.GetType().Name}\");\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"2_432\"></a>2、创建对象</h3>\n<h4><a id=\"1_434\"></a>（1）调用无参数构造函数的</h4>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.ReflectionTest\");\nobject noParaObject = Activator.CreateInstance(type);\n</code></pre>\n<h4><a id=\"2_442\"></a>（2）调用有参数构造函数的</h4>\n<p>需要传递一个object类型的数组作为参数，参数按照从昨往右严格匹配，如果没有匹配的报异常</p>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.ReflectionTest\");\nobject paraObject = Activator.CreateInstance(type, new object[] { 123 });\nobject paraObject1 = Activator.CreateInstance(type, new object[] { \"三三\" });\nobject paraObject2 = Activator.CreateInstance(type, new object[] { 234, \"四四\" });\nobject paraObject3 = Activator.CreateInstance(type, new object[] { \"五五\", 456 });\n</code></pre>\n<h2><a id=\"_455\"></a>六、反射调用方法详解</h2>\n<p>获取方法MethodInfo，执行MethodInfo 的Invoke方法，传递方法所在的类的实例对象+参数</p>\n<h3><a id=\"1_459\"></a>1、调用无参数的方法</h3>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.ReflectionTest\");\nobject oInstance = Activator.CreateInstance(type);\nMethodInfo show1 = type.GetMethod(\"Show1\");\nshow1.Invoke(oInstance, new object[] { });\nshow1.Invoke(oInstance, new object[0]);\nshow1.Invoke(oInstance, null);\n</code></pre>\n<h3><a id=\"2_471\"></a>2、调用有参数的方法</h3>\n<p>需要通过方法参数类型类区别方法，传递参数，严格匹配参数类型</p>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.ReflectionTest\");\nobject oInstance = Activator.CreateInstance(type);\nMethodInfo show2 = type.GetMethod(\"Show2\");\nshow2.Invoke(oInstance, new object[] { 123 });\nMethodInfo show31 = type.GetMethod(\"Show3\", new Type[] { typeof(string), typeof(int) });\nshow31.Invoke(oInstance, new object[] { \"一一一\", 234 });\nMethodInfo show32 = type.GetMethod(\"Show3\", new Type[] { typeof(int) });\nshow32.Invoke(oInstance, new object[] { 345 });\nMethodInfo show33 = type.GetMethod(\"Show3\", new Type[] { typeof(string) });\nshow33.Invoke(oInstance, new object[] { \"二二二\" });\nMethodInfo show34 = type.GetMethod(\"Show3\", new Type[0]);\nshow34.Invoke(oInstance, null);\n</code></pre>\n<h3><a id=\"3_491\"></a>3、调用私有方法</h3>\n<p>在获取方法的时候，加上参数BindingFlags.NonPublic | BindingFlags.Instance</p>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.ReflectionTest\");\nobject oInstance = Activator.CreateInstance(type);\nMethodInfo show4 = type.GetMethod(\"Show4\", BindingFlags.NonPublic | BindingFlags.Instance);\nshow4.Invoke(oInstance, new object[] { \"String\" });\n</code></pre>\n<h3><a id=\"4_503\"></a>4、调用静态方法</h3>\n<p>不需要创建对象也可以调用</p>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.ReflectionTest\");\nMethodInfo show5 = type.GetMethod(\"Show5\");\nshow5.Invoke(null, new object[] { \"String\" });\n</code></pre>\n<h3><a id=\"5_514\"></a>5、调用普通类的泛型方法</h3>\n<p>获取到泛型方法后需要先确定类型</p>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\nType type = assembly.GetType(\"MyReflecttion.GenericMethod\");\nobject oInstance = Activator.CreateInstance(type);\nMethodInfo show = type.GetMethod(\"Show\");\n//获取到泛型方法后需要先确定类型\nMethodInfo genericshow = show.MakeGenericMethod(new Type[] { typeof(int), typeof(string), typeof(DateTime) });\ngenericshow.Invoke(oInstance, new object[] { 123, \"三三三\", DateTime.Now });\n</code></pre>\n<h3><a id=\"6_528\"></a>6、调用泛型类的普通方法</h3>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\n//泛型类的类型需要在类后面加占位符\nType type = assembly.GetType(\"MyReflecttion.GenericClass`3\");\n//泛型类获取到类型后需要先确定类型\nType generType = type.MakeGenericType(new Type[] { typeof(int), typeof(string), typeof(DateTime) });\nobject oInstance = Activator.CreateInstance(generType);\nMethodInfo show = generType.GetMethod(\"Show\");\nshow.Invoke(oInstance, new object[] { 123, \"四四四\", DateTime.Now });\n</code></pre>\n<h3><a id=\"7_541\"></a>7、调用泛型类的泛型方法</h3>\n<pre><code class=\"prism language-C#\">Assembly assembly = Assembly.LoadFrom(\"MyReflecttion.dll\");\n//泛型类的类型需要在类后面加占位符\nType type = assembly.GetType(\"MyReflecttion.GenericDouble`1\");\n//泛型类获取到类型后需要先确定类型\nType generType = type.MakeGenericType(new Type[] { typeof(int) });\nobject oInstance = Activator.CreateInstance(generType);\nMethodInfo show = generType.GetMethod(\"Show\");\n//获取到泛型方法后需要先确定类型\nMethodInfo genericMethod = show.MakeGenericMethod(new Type[] { typeof(string), typeof(DateTime) });\ngenericMethod.Invoke(oInstance, new object[] { 123, \"五五五\", DateTime.Now });\n</code></pre>\n<h2><a id=\"_556\"></a>七、反射操作属性字段</h2>\n<ul><li>普通方法调用属性字段简单快捷，反射操作麻烦点。</li><li>类增加一个字段呢，普通方法调用需要修改代码，重新编译发布，代码不稳定，反射赋值没啥优势，反射取值不需要修改代码，代码就更加稳定。</li><li>type.GetProperties()获取属性，type.GetFields()获取字段。</li></ul>\n<h3><a id=\"1_562\"></a>1、创建测试类</h3>\n<pre><code class=\"prism language-C#\">using System;\n\nnamespace Business.DB.Model\n{\n    /// &lt;summary&gt;\n    /// 实体---属性是不能保存数据，只有字段才能保存数据\n    /// &lt;/summary&gt;\n    public class People\n    {\n        public People()\n        {\n            Console.WriteLine(\"{0}被创建\", this.GetType().FullName);\n        }\n         \n        public int Id { get; set; }//带有Get Set 方法的叫做属性\n\n        public string Name { get; set; }\n\n        public int Age { get; set; }\n         \n        public string Description;//字段\n    }\n}\n</code></pre>\n<h3><a id=\"2_590\"></a>2、传统方式赋值取值</h3>\n<pre><code class=\"prism language-C#\">//传统手艺赋值取值\nConsole.WriteLine(\"***********传统手艺赋值取值*************\");\nPeople people = new People();\npeople.Id = 134;\npeople.Name = \"WWWW\";\npeople.Age = 25;\npeople.Description = \"XXXXX\";\nConsole.WriteLine($\"people.Id={people.Id}\");\nConsole.WriteLine($\"people.Name={people.Name}\");\nConsole.WriteLine($\"people.Age={people.Age}\");\nConsole.WriteLine($\"people.Description={people.Description}\");\n</code></pre>\n<h3><a id=\"3_606\"></a>3、反射方式赋值取值</h3>\n<pre><code class=\"prism language-C#\">//反射方式赋值取值\nConsole.WriteLine(\"***********反射方式赋值取值*************\");\nType type = typeof(People);\nobject pObject = Activator.CreateInstance(type);\nforeach (var prop in type.GetProperties())\n{\n    if (prop.Name.Equals(\"Id\"))\n    {\n        prop.SetValue(pObject, 134);\n    }\n    else if (prop.Name.Equals(\"Name\"))\n    {\n        prop.SetValue(pObject, \"WWWW\");\n    }\n    else if (prop.Name.Equals(\"Age\"))\n    {\n        prop.SetValue(pObject, 25);\n    }                            \n}                        \nforeach (var prop in type.GetProperties())\n{\n    Console.WriteLine($\"people.{prop.Name}={prop.GetValue(pObject)}\");\n}\n</code></pre>\n<h3><a id=\"4_634\"></a>4、运行结果</h3>\n<pre><code class=\"prism language-bash\">***********传统手艺赋值取值*************\nBusiness.DB.Model.People被创建\npeople.Id<span class=\"token operator\">=</span><span class=\"token number\">134</span>\npeople.Name<span class=\"token operator\">=</span>WWWW\npeople.Age<span class=\"token operator\">=</span><span class=\"token number\">25</span>\npeople.Description<span class=\"token operator\">=</span>XXXX\n***********反射方式赋值取值*************\nBusiness.DB.Model.People被创建\npeople.Id<span class=\"token operator\">=</span><span class=\"token number\">134</span>\npeople.Name<span class=\"token operator\">=</span>WWWW\npeople.Age<span class=\"token operator\">=</span><span class=\"token number\">25</span>\n</code></pre>\n<h2><a id=\"_650\"></a>八、反射的局限/性能问题</h2>\n<h3><a id=\"1_652\"></a>1、性能对比代码实现</h3>\n<pre><code class=\"prism language-C#\">using Business.DB.Interface;\nusing Business.DB.SqlServer;\nusing System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace MyReflecttion\n{\n    public class Monitor\n    {\n        public static void Show()\n        {\n            Console.WriteLine(\"*******************Monitor*******************\");\n            long commonTime = 0;\n            long reflectionTime = 0;\n            {\n                Stopwatch watch = new Stopwatch();\n                watch.Start();\n                for (int i = 0; i &lt; 1000_000; i++) //1000000000\n                {\n                    IDBHelper iDBHelper = new SqlServerHelper();\n                    iDBHelper.Query();\n                }\n                watch.Stop();\n                commonTime = watch.ElapsedMilliseconds;\n            }\n            {\n                Stopwatch watch = new Stopwatch();\n                watch.Start();\n                //优化代码，加载dll放到循环外面\n                Assembly assembly = Assembly.Load(\"Business.DB.SqlServer\");//1 动态加载\n                Type dbHelperType = assembly.GetType(\"Business.DB.SqlServer.SqlServerHelper\");//2 获取类型\n                for (int i = 0; i &lt; 1000_000; i++)\n                {\n                    //创建对象+方法调用\n                    object oDBHelper = Activator.CreateInstance(dbHelperType);//3 创建对象\n                    IDBHelper dbHelper = (IDBHelper)oDBHelper;//4 接口强制转换\n                    dbHelper.Query();//5 方法调用\n                }\n                watch.Stop();\n                reflectionTime = watch.ElapsedMilliseconds;\n            }\n\n            Console.WriteLine($\"commonTime={commonTime} reflectionTime={reflectionTime}\");\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"2_704\"></a>2、运行结果</h3>\n<ul><li>测试用例：普通方式循环100000次，创建对象+方法调用：16毫秒<br/> 反射方式循环100000次，加载dll+创建对象+方法调用：6300毫秒</li><li>加载dll放到循环外面，创建对象+方法调用放循环里面，泛型方法：57毫秒</li></ul>\n<pre><code class=\"prism language-C#\">*******************Monitor*******************\ncommonTime=16 reflectionTime=57\n</code></pre>\n<h3><a id=\"3_715\"></a>3、使用反射的建议</h3>\n<p>反射确实有性能问题，但是差别没有那么大，在需要的地方可以放心使用</p>\n<h2><a id=\"ORM_719\"></a>九、反射实现ORM框架</h2>\n<p>ORM：对象关系映射，通过对象查询数据库数据</p>\n<h3><a id=\"1_723\"></a>1、创建测试类，继承基类</h3>\n<pre><code class=\"prism language-C#\">using System;\n\nnamespace Business.DB.Model\n{\n    public class SysCompany : BaseModel\n    { \n        public string Name { get; set; }\n        public DateTime CreateTime { get; set; }\n        public int CreatorId { get; set; }\n        public int? LastModifierId { get; set; }\n        public DateTime? LastModifyTime { get; set; }\n    }\n}\n</code></pre>\n<pre><code class=\"prism language-C#\">namespace Business.DB.Model\n{\n    /// &lt;summary&gt;\n    /// 数据库basemodel\n    /// &lt;/summary&gt;\n    public class BaseModel\n    {\n        public int Id { set; get; }\n    }\n}\n</code></pre>\n<h3><a id=\"2_754\"></a>2、使用泛型方法来兼容不同的对象查询</h3>\n<h3><a id=\"3_756\"></a>3、使用反射获取字段</h3>\n<h3><a id=\"4_758\"></a>4、使用反射来对结果赋值</h3>\n<pre><code class=\"prism language-C#\">using Business.DB.Interface;\nusing Business.DB.Model;\nusing System;\nusing System.Data.SqlClient;\n\nnamespace Business.DB.SqlServer\n{\n    public class SqlServerHelper : IDBHelper\n    {\n\n        //Nuget:System.Data.SqlClient\n\n        private string ConnectionString = \"Data Source=XXX; Database=YYY; User ID=sa; Password=ZZZ; MultipleActiveResultSets=True\";\n\n        public SqlServerHelper()\n        {\n           //Console.WriteLine($\"{this.GetType().Name}被构造\");\n        }\n        \n\n        public void Query()\n        {\n            //Console.WriteLine($\"{this.GetType().Name}.Query\");\n        }\n\n        /// &lt;summary&gt; \n        /// 泛型方法适配查询不同对象数据\n        /// &lt;/summary&gt;\n        public T Find&lt;T&gt;(int id) where T : BaseModel\n        {\n            //（1）反射创建对象\n            Type type = typeof(T);\n            object oReulst = Activator.CreateInstance(type);\n\n            //（2）连接数据库,数据库链接字符串ConnectionString \n            using (SqlConnection connection = new SqlConnection(ConnectionString))\n            {\n                //（3）准备SqlConnection，使用数据库链接字符串\n                connection.Open();\n                \n                //（4）准备sql，通过泛型缓存缓存sql\n                string sql = ConstantSqlString&lt;T&gt;.GetFindSql(id);\n                //（5）准备SqlCommand\n                //（6）通过SqlCommand对象执行Sql语句\n                SqlCommand sqlCommand = new SqlCommand(sql, connection);\n                //（7）开始获取数据\n                SqlDataReader reader = sqlCommand.ExecuteReader();\n                if (reader.Read())\n                {\n                    foreach (var prop in type.GetProperties())\n                    {\n                        //（8）反射赋值\n                        prop.SetValue(oReulst, reader[prop.Name] is DBNull ? null : reader[prop.Name]);\n                    }\n                }\n            }\n            return (T)oReulst;\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"5sql_823\"></a>5、使用泛型缓存来缓存sql</h3>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Linq;\n\nnamespace Business.DB.SqlServer\n{\n    public class ConstantSqlString&lt;T&gt;\n    {\n        private static string FindSql = null;\n\n        static ConstantSqlString()\n        {\n            Type type = typeof(T);\n            FindSql = $\"Select {string.Join(',', type.GetProperties().Select(c =&gt; $\"[{c.Name}]\").ToList())} from {type.Name} where id=\";\n        }\n\n        /// &lt;summary&gt;\n        /// GetSql语句\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"id\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static string GetFindSql(int id)\n        {\n            return $\"{FindSql}{id}\";\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"6_854\"></a>6、反射多种应用场景</h3>\n<h4><a id=\"1IOC___856\"></a>（1）IOC容器：反射+ 配置文件+ 工厂</h4>\n<h4><a id=\"2MVC_858\"></a>（2）MVC框架：反射调用类型方法</h4>\n<h4><a id=\"3ORMAdoNet_860\"></a>（3）ORM：反射+泛型+Ado.Net</h4>\n<h4><a id=\"4AOP_862\"></a>（4）AOP：在方法的前面后面添加处理内容</h4>\n<h2><a id=\"Emit_864\"></a>十、反射的Emit的技术</h2>\n<ul><li>在运行时去动态的生成dll、exe包括dll内部的方法、属性、字段等内容</li><li>偏向于底层，学习成本比较高 除非是非常复杂的业务逻辑，一般情况，用的比较少；</li></ul>\n<h3><a id=\"1_869\"></a>1、程序集内部结构</h3>\n<p><img alt=\"请添加图片描述\" src=\"..\\..\\static\\image\\c35d0c554715409d8ac97504d5c2b50e.png\"/></p>\n<h3><a id=\"2_874\"></a>2、动态创建程序过程</h3>\n<p>一般的，使用反射发出（reflection emit）可能会是这样子的步骤</p>\n<h4><a id=\"1_878\"></a>（1）创建一个新的程序集</h4>\n<p>程序集是动态的存在于内存中或把它们保存到磁盘上</p>\n<h4><a id=\"2_882\"></a>（2）在程序集内部，创建一个模块</h4>\n<h4><a id=\"3_884\"></a>（3）在模块内部，创建一个类型</h4>\n<h4><a id=\"4_886\"></a>（4）给类型添加属性和方法</h4>\n<h4><a id=\"5_888\"></a>（5）产生属性和方法内部的代码</h4>\n<h3><a id=\"3_890\"></a>3、参照类</h3>\n<pre><code class=\"prism language-C#\">public class MyDynamicType\n{\n    /// &lt;summary&gt;\n    /// 字段\n    /// &lt;/summary&gt;\n    public int NumberField = 0;       \n\n    /// &lt;summary&gt;\n    /// int类型参数构造函数\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"numberField\"&gt;&lt;/param&gt;\n    public MyDynamicType(int numberField)\n    {\n        this.NumberField = numberField;\n    }\n\n    /// &lt;summary&gt;\n    /// 无参数方法\n    /// &lt;/summary&gt;\n    public void ConsoleMethod()\n    {\n        Console.WriteLine(\"方法输出的内容\");\n    }\n\n    /// &lt;summary&gt;\n    /// 有参数方法\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"para\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public int MyMethod(int para)\n    {\n        return 2 * para;\n    }\n}\n</code></pre>\n<h3><a id=\"4emit_929\"></a>4、emit实现参照类</h3>\n<pre><code class=\"prism language-C#\">public class ReflectionEmit\n{\n    //一般的，使用反射发出（reflection emit）可能会是这样子的步骤\n    //（1）创建一个新的程序集\n    //程序集是动态的存在于内存中或把它们保存到磁盘上\n    //（2）在程序集内部，创建一个模块\n    //（3）在模块内部，创建一个类型\n    //（4）给类型添加属性和方法\n    //（5）产生属性和方法内部的代码\n    public static void Show()\n    {\n\n        //（1）创建一个新的程序集\n        AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\"DynamicAssemblyExample\"), AssemblyBuilderAccess.RunAndCollect);\n\n        //（2）在程序集内部，创建一个模块\n        ModuleBuilder modulebuilder = assemblyBuilder.DefineDynamicModule(\"MyModal\");\n\n        //（3）在模块内部，创建一个类型\n        TypeBuilder typebuilder = modulebuilder.DefineType(\"MyDynamicType\", TypeAttributes.Public);\n\n        //（4）给类型添加属性和方法\n        // 在Type中生成字段\n        FieldBuilder fieldBuilder = typebuilder.DefineField(\"NumberField\", typeof(int), FieldAttributes.Public);\n\n        #region 定义一个接受整数参数的构造函数\n        //（4）给类型添加属性和方法\n        Type[] parameterTypes = { typeof(int) };\n        ConstructorBuilder ctor1 = typebuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, parameterTypes);\n\n        //（5）产生属性和方法内部的代码\n        //中间语言的生成者\n        ILGenerator ctor1IL = ctor1.GetILGenerator();\n        //对于构造函数，参数0是对新 \n        //实例。在调用base之前将其推到堆栈上 \n        //类构造函数。指定的默认构造函数\n        //类型（Type.EmptyTypes）到GetConstructor。\n        ctor1IL.Emit(OpCodes.Ldarg_0);\n        ctor1IL.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes));\n        //在推送参数之前，先将实例推送到堆栈上 \n        //将被分配给私有字段m\\u编号。 \n        ctor1IL.Emit(OpCodes.Ldarg_0);\n        ctor1IL.Emit(OpCodes.Ldarg_1);\n        ctor1IL.Emit(OpCodes.Stfld, fieldBuilder);\n        ctor1IL.Emit(OpCodes.Ret);//写IL最后一定要Ret\n\n        //测试代码\n        {\n            //Type type1 = typebuilder.CreateType();\n            //object oInstacne = Activator.CreateInstance(type1, new object[] { 123456 });\n            //FieldInfo fieldInfo = type1.GetField(\"NumberField\");\n            //object numberFieldResult = fieldInfo.GetValue(oInstacne);\n        }\n        #endregion\n\n        #region 定义一个无参数方法\n        //（4）给类型添加属性和方法\n        MethodBuilder consoleMethod = typebuilder.DefineMethod(\"ConsoleMethod\", MethodAttributes.Public | MethodAttributes.Static, null, null);\n\n        //（5）产生属性和方法内部的代码\n        ILGenerator consoleMethodIL = consoleMethod.GetILGenerator();\n        consoleMethodIL.Emit(OpCodes.Ldstr, \"方法输出的内容\");\n        consoleMethodIL.Emit(OpCodes.Call, typeof(Console).GetMethod(\"WriteLine\", new Type[] { typeof(string) }));\n        consoleMethodIL.Emit(OpCodes.Ret); \n\n        //测试代码\n        {\n            //Type type1 = typebuilder.CreateType();\n            //object oInstacne = Activator.CreateInstance(type1, new object[] { 123456 });\n            //MethodInfo myMethod = type1.GetMethod(\"ConsoleMethod\");\n            //object oResult = myMethod.Invoke(oInstacne, null);\n        }\n        #endregion\n\n        #region 定义一个有参数方法\n        //（4）给类型添加属性和方法\n        MethodBuilder AddMethod = typebuilder.DefineMethod(\"MyMethod\", MethodAttributes.Public | MethodAttributes.Static, typeof(int), new Type[] { typeof(int), typeof(int) });\n\n        //（5）产生属性和方法内部的代码\n        ILGenerator AddMethodIL = AddMethod.GetILGenerator();\n        AddMethodIL.Emit(OpCodes.Ldarg_0);\n        AddMethodIL.Emit(OpCodes.Ldarg_1);\n        AddMethodIL.Emit(OpCodes.Add_Ovf_Un);\n        AddMethodIL.Emit(OpCodes.Ret);\n\n        //测试代码\n        {                \n            //Type type1 = typebuilder.CreateType();\n            //object oInstacne = Activator.CreateInstance(type1, new object[] { 123456 });\n            //MethodInfo myMethod = type1.GetMethod(\"MyMethod\");\n            //object oResult = myMethod.Invoke(oInstacne, new object[] { 12, 34 });\n        }\n        #endregion\n    }\n}\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2021-08-09 22:04:46", "summary": "高级反射详解零、文章目录一、反射是什么、编译运行过程高级语言编译文件机器码请添加图片描述、原理解析：元数据数据清单，记录了中包含了哪些东西是一个描述。：中间语言，编译把高级语言编译后得到的中最真实的语"}