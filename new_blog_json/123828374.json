{"blogid": "123828374", "writerAge": "码龄2年", "writerBlogNum": "156", "writerCollect": "9133", "writerComment": "2473", "writerFan": "22571", "writerGrade": "7级", "writerIntegral": "13219", "writerName": "柠檬叶子C", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123828374.jpg", "writerRankTotal": "785", "writerRankWeekly": "635", "writerThumb": "6776", "writerVisitNum": "500619", "blog_read_count": "5084", "blog_time": "已于 2022-04-09 22:55:50 修改", "blog_title": "【C++要笑着学】C++动态内存管理 | new/delete底层探索 | new/delete实现原理 | 定位new", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\451dfef5a53e4c94a3ecbfb02d167973.png\" width=\"286\"/> ​​​​​​ 🤣 <strong>爆笑教程</strong> 👉 <a href=\"https://blog.csdn.net/weixin_50502862/category_11602059.html\" title=\"《C++要笑着学》\">《C++要笑着学》</a> 👈 <strong>火速订阅 </strong>🔥</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\b53338b09e69459b894fa4840fc02f40.png\"/></p>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\c52b4035e4864f4ba6cbbd9070bc53cd.png\" width=\"324\"/>  <strong> 本篇博客全站热榜排名：<span style=\"color:#be191c;\">4</span></strong></p>\n<p></p>\n<p><strong>前言：</strong></p>\n<p><img alt=\"\" height=\"82\" src=\"..\\..\\static\\image\\0dcec9278df246298bfe6f7db3c9d9f1.png\" width=\"82\"/>是这样的，C语言里的 \"动态内存管理\" 放到 C++ 里面，用起来不是那么爽，所以C++就对这一块进行了升级，本章我们就探索探索 C++的内存管理，顺便复习一下C语言里讲过的动态内存管理的知识。学完本章，单身的同学不用怕了，以后没有对象我们可以 new 一个。</p>\n<p></p>\n<hr/>\n<h2>Ⅰ.  C语言内存管理的方式回顾</h2>\n<h3>0x00  C/C++ 内存分布</h3>\n<p>💬 观察下面一段代码，并回答问题：</p>\n<pre><code class=\"language-cpp\">int globalVar = 1;\nstatic int staticGlobalVar = 1;\nvoid Test()\n{\n\tstatic int staticVar = 1;\n\tint localVar = 1;\n\n\tint num1[10] = { 1, 2, 3, 4 };\n\tchar char2[] = \"abcd\";\n\tconst char* pChar3 = \"abcd\";\n\tint* ptr1 = (int*)malloc(sizeof(int) * 4);\n\tint* ptr2 = (int*)calloc(4, sizeof(int));\n\tint* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);\n\tfree(ptr1);\n\tfree(ptr3);\n}\n\n1. 选择题：\n\n    选项: A.栈 B.堆 C.数据段 D.代码段\n\n    globalVar在哪里？____    staticGlobalVar在哪里？____\n    staticVar在哪里？____    localVar在哪里？____\n    num1 在哪里？____\n \n    char2在哪里？____        *char2在哪里？___\n    pChar3在哪里？____       *pChar3在哪里？____\n    ptr1在哪里？____         *ptr1在哪里？____\n\n\n2. 填空题：\n    sizeof(num1) = ____;\n    sizeof(char2) = ____;    strlen(char2) = ____;\n    sizeof(pChar3) = ____;   strlen(pChar3) = ____;\n    sizeof(ptr1) = ____;</code></pre>\n<p><img alt=\"\" height=\"804\" src=\"..\\..\\static\\image\\2fbfba6d91964f3d8561fa6dcfad4603.png\" width=\"1200\"/></p>\n<blockquote>\n<p>🔑 答案：CCCAA  AAADAB</p>\n</blockquote>\n<p></p>\n<p><strong>栈区（stack）</strong></p>\n<p><img alt=\"\" height=\"47\" src=\"..\\..\\static\\image\\ee3d57b217c24d93aed08327fb7180f2.png\" width=\"56\"/> 栈又叫堆栈，非静态局部变量/函数参数/返回值等等，<span style=\"background-color:#f9eda6;\">栈是向下增长的。</span></p>\n<p>执行函数时，函数内部局部变量的存储单元都可以在栈上创建。</p>\n<p>函数执行结束后这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集中，</p>\n<p>拥有很高的效率，但是分配的内存容量是有限的。</p>\n<p><span style=\"background-color:#f9eda6;\">栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。</span></p>\n<p></p>\n<p><strong>堆区（heap）</strong></p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\609995812de84d29b1f4cbc7d9b9d229.png\" width=\"69\"/> 堆用于程序运行时动态内存分配，<span style=\"background-color:#f9eda6;\">堆是可以上增长的。</span></p>\n<p>一般由程序员自主分配释放，若程序员不主动不释放，程序结束时可能由操作系统回收。</p>\n<p>其分配方式类似于链表。</p>\n<p></p>\n<p><strong>数据段（data segment）</strong></p>\n<p><img alt=\"\" height=\"47\" src=\"..\\..\\static\\image\\46b133fc046647bcb6d5a5dd1421de96.png\" width=\"59\"/> 静态存储区，<span style=\"background-color:#f9eda6;\">数据段存放全局变量和静态数据</span>，程序结束后由系统释放。</p>\n<p></p>\n<p><strong>代码段（code segment）</strong></p>\n<p><img alt=\"\" height=\"45\" src=\"..\\..\\static\\image\\9d4fea608d6f40ccb3030163fddaaea3.png\" width=\"54\"/> 可执行的代码 / 只读常量。<span style=\"background-color:#f9eda6;\">代码段存放类成员函数和全局函数的二进制代码。</span></p>\n<p>一个程序起来之后，会把它的空间进行划分，而划分是为了更好地管理。</p>\n<p>函数调用，函数里可能会有很多变量，函数调用建立栈帧，栈帧里存形参、局部变量等等。</p>\n<p></p>\n<p><strong>内存映射段（memory mapping）</strong></p>\n<p><img alt=\"\" height=\"49\" src=\"..\\..\\static\\image\\dc3c908bb421484b8fdb4e95171aad35.png\" width=\"58\"/> <span style=\"background-color:#f9eda6;\">内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。</span></p>\n<p>用户可使用系统接口创建共享共享内存，做进程间通信。</p>\n<p></p>\n<p></p>\n<h3>0x01  C语言中动态内存管理的方式</h3>\n<blockquote>\n<p>【面试题】malloc / calloc / realloc 的区别？</p>\n</blockquote>\n<p>这些我们在C语言章节中都有详细的讲解：<a href=\"https://blog.csdn.net/weixin_50502862/article/details/119354489\" title=\"【维生素C语言】第十三章 - 动态内存管理\">【维生素C语言】第十三章 - 动态内存管理</a></p>\n<p><img alt=\"\" height=\"298\" src=\"..\\..\\static\\image\\20210805172433720.png\" width=\"450\"/></p>\n<p><strong>malloc</strong></p>\n<p><img alt=\"\" height=\"41\" src=\"..\\..\\static\\image\\20210805182300881.png\" width=\"625\"/></p>\n<p>📜 头文件：<span style=\"color:#511b78;\">stdlib.h</span></p>\n<p> 📚 介绍：<span style=\"color:#956fe7;\">malloc<strong> </strong></span>是C语言提供的一个动态内存开辟的函数，该函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。具体情况如下：</p>\n<p>      ① 如果开辟成功，则返回一个指向开辟好空间的指针。</p>\n<p>      ② 如果开辟失败，则返回一个 <span style=\"color:#be191c;\">NULL </span>指针。</p>\n<p>      ③ 返回值的类型为<span style=\"color:#ad720d;\"> void*</span> ，<span style=\"color:#956fe7;\">malloc </span>函数并不知道开辟空间的类型，由使用者自己决定。</p>\n<p>      ④ 如果 <strong>size </strong>为 0（开辟0个字节），<span style=\"color:#956fe7;\">malloc </span>的行为是标准未定义的，结果将取决于编译器。</p>\n<p></p>\n<p><strong>calloc</strong></p>\n<p><img alt=\"\" height=\"44\" src=\"..\\..\\static\\image\\20210805182416998.png\" width=\"642\"/></p>\n<p>📜 头文件：<span style=\"color:#511b78;\">stdlib.h</span></p>\n<p>📚 介绍：<span style=\"color:#956fe7;\">calloc </span>函数的功能实为 <strong>num </strong>个大小为 <strong>size</strong> 的元素开辟一块空间，并把空间的每个字节初始化为 0 ，返回一个指向它的指针。</p>\n<p></p>\n<p>⭕ 对比：</p>\n<p>      ① <span style=\"color:#956fe7;\">malloc</span> 只有一个参数，而<span style=\"color:#956fe7;\"> <strong><span style=\"background-color:#f9eda6;\">calloc</span></strong></span><span style=\"background-color:#f9eda6;\"> 有两个参数，分别为元素的个数和元素的大小。</span></p>\n<p>      ② 与函数<span style=\"color:#956fe7;\"> malloc</span> 的区别在于<span style=\"color:#956fe7;\"> calloc</span> 会在返回地址前把申请的空间的每个字节初始化为 0 。</p>\n<p></p>\n<p> 💬 验证：<span style=\"color:#956fe7;\"> calloc </span>会对内存进行初始化</p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    // malloc\n    int* p = (int*)malloc(40); // 开辟40个空间\n    if (p == NULL)\n        return 1;\n    int i = 0;\n    for (i = 0; i &lt; 10; i++)\n        printf(\"%d \", *(p + i));\n    free(p);\n    p = NULL;\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p> 🚩  （运行结果是10个随机值）</p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    // calloc\n    int* p = (int*)calloc(10, sizeof(int)); // 开辟10个大小为int的空间，40\n    if (p == NULL)\n        return 1;\n    int i = 0;\n    for (i = 0; i &lt; 10; i++)\n        printf(\"%d \", *(p + i));\n    free(p);\n    p = NULL;\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p> 🚩  0 0 0 0 0 0 0 0 0 0</p>\n</blockquote>\n<p>🔺 总结：说明 <span style=\"color:#956fe7;\">calloc </span>会对内存进行初始化，把空间的每个字节初始化为 0 。如果我们对于申请的内存空间的内容，要求其初始化，我们就可以使用<span style=\"color:#956fe7;\"> calloc </span>函数。</p>\n<p></p>\n<p></p>\n<h3><strong>0x03 realloc</strong></h3>\n<p><img alt=\"\" height=\"35\" src=\"..\\..\\static\\image\\20210805223727937.png\" width=\"600\"/></p>\n<p>📜 头文件：stdlib.h</p>\n<p>📚 介绍：<span style=\"color:#956fe7;\">realloc</span> 函数，让动态内存管理更加灵活。用于重新调整之前调用 <span style=\"color:#956fe7;\">malloc </span>或 <span style=\"color:#956fe7;\">calloc </span>所分配的 <strong>ptr </strong>所指向的内存块的大小，可以对动态开辟的内存进行大小的调整。具体介绍如下：</p>\n<p>      ①<strong> ptr </strong>为指针要调整的内存地址。</p>\n<p>      ②<strong> size </strong>为调整之后的新大小。</p>\n<p>      ③ 返回值为调整之后的内存起始位置，请求失败则返回空指针。</p>\n<p>      ④<span style=\"color:#956fe7;\"> realloc </span>函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。</p>\n<p></p>\n<p>📌 <span style=\"color:#956fe7;\">realloc </span>函数在调整内存空间时存在的三种情况：</p>\n<p>     <em> 情况1</em>：原有空间之后有足够大的空间。</p>\n<p>      <em>情况2</em>：原有空间之后没有足够大的空间。</p>\n<p>      <em>情况3</em>：realloc 有可能找不到合适的空间来调整大小。</p>\n<p><img alt=\"\" height=\"465\" src=\"..\\..\\static\\image\\20210805233659616.png\" width=\"522\"/></p>\n<blockquote>\n<p><strong>情况1：</strong>当原有空间之后没有足够大的空间时，直接在原有内存之后直接追加空间，原来空间的数组不发生变化。</p>\n<p><strong>情况2：</strong>当原有空间之后没有足够大的空间时，会在堆空间上另找一个合适大小的连续的空间来使用。函数的返回值将是一个新的内存地址。</p>\n<p><strong>情况3</strong>：如果找不到合适的空间，就会返回一个空指针。</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2>Ⅱ.  C++动态内存管理方式</h2>\n<h3>0x00 引入</h3>\n<pre><code class=\"language-cpp\">#include &lt;stdlib.h&gt;\n\nvoid Test_C() {\n    int* p1 = (int*)malloc(sizeof(int));\n    int* p2 = (int*)malloc(sizeof(int) * 5);\n}\n</code></pre>\n<p>C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦。</p>\n<p><img alt=\"\" height=\"69\" src=\"..\\..\\static\\image\\ccb0dc56887e4ad0895ba59b3a458d40.png\" width=\"63\"/> 为了解决这种问题，C++ 又进化出属于自己的内存管理方式。</p>\n<p>通过 <span style=\"color:#956fe7;\">new</span> 和 <span style=\"color:#956fe7;\">delete </span>操作符进行动态内存管理。</p>\n<p></p>\n<p></p>\n<h3>0x01 new / delete 操作内置类型</h3>\n<p>💬 <span style=\"color:#956fe7;\">new </span>开辟空间：</p>\n<pre><code class=\"language-cpp\">void Test_CPP() {\n    // 动态申请一个int类型的空间\n    int* p1 = new int;\n\n    // 动态申请一个int类型的空间并初始化为10\n    int* p2 = new int(10);\n\n    // 动态申请10个int类型的空间\n    int* p3 = new int[10];\n}</code></pre>\n<p><img alt=\"\" height=\"250\" src=\"..\\..\\static\\image\\908493cc334c4ab59a63ff135b90ad4a.png\" width=\"447\"/></p>\n<p> <img alt=\"\" height=\"164\" src=\"https://img-blog.csdnimg.cn/bfccdfeaf3cb4f07b530ecb1f907d4d7.gif\" width=\"292\"/> 是不是非常的爽，<span style=\"background-color:#f9eda6;\">而且 <strong><span style=\"color:#956fe7;\">new</span></strong> 不需要强制类型转换。</span></p>\n<p></p>\n<p>💬 C语言用完之后我们要用<span style=\"color:#956fe7;\"> free </span>函数释放：</p>\n<pre><code class=\"language-cpp\">#include &lt;stdlib.h&gt;\n\nvoid Test_C() {\n    int* p1 = (int*)malloc(sizeof(int));\n    int* p2 = (int*)malloc(sizeof(int) * 5);\n\n    free(p1);\n    free(p2);\n}\n</code></pre>\n<p></p>\n<p>💬 但是在C++里，我们可以用 <span style=\"color:#956fe7;\">delete</span>：</p>\n<pre><code class=\"language-cpp\">void Test_CPP() {\n    int* p1 = new int;\n    int* p2 = new int(10);\n    int* p3 = new int[10];    // 多个对象\n    \n    // 单个对象，delete即可。\n    delete p1;\n    delete p2;\n\n    // 多个对象，delete[] 。\n    delete[] p3;\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"179\" src=\"..\\..\\static\\image\\7ae84278c6df4b689cdc3ab8691fe087.png\" width=\"180\"/> 这些指针要不要置空呢？</p>\n<p>从安全角度看，这里当然还是置空一下比较好：</p>\n<pre><code class=\"language-cpp\">void Test_CPP() {\n    int* p1 = new int;\n    int* p2 = new int(10);\n    int* p3 = new int[3];\n\n    delete p1;\n    delete p2;\n    delete[] p3;\n\n    p1 = nullptr;\n    p2 = nullptr;\n    p3 = nullptr;\n}\n</code></pre>\n<p>不知道大家还是否记得下面这张图（维生素C语言中讲解free的插图）</p>\n<p><img alt=\"\" height=\"399\" src=\"..\\..\\static\\image\\20210805180951770.png\" width=\"537\"/></p>\n<p>只是我们这里用 <span style=\"color:#956fe7;\">delete</span>，并用 <span style=\"color:#4da8ee;\">nullptr</span> 置空了，本质是一样的。</p>\n<p></p>\n<p></p>\n<h3>0x03 初始化new数组的问题</h3>\n<p><img alt=\"\" height=\"53\" src=\"..\\..\\static\\image\\6fc52959f4c542909dd9f5ce6e4b6826.png\" width=\"113\"/> C++98 不支持初始化<span style=\"color:#956fe7;\"> new </span>数组：</p>\n<pre><code class=\"language-cpp\">int* p = new int[5];</code></pre>\n<p><img alt=\"\" height=\"95\" src=\"..\\..\\static\\image\\576e1e94a61a4955b18300b7009eebc5.png\" width=\"82\"/> C++11 允许大括号初始化，我们就可以用 <strong>{ } </strong>列表初始化：</p>\n<pre><code class=\"language-cpp\">int* p1 = new int[5]{1,2}         // 1 2 0 0 0\nint* p2 = new int[5]{1,2,3,4,5};  // 1 2 3 4 5</code></pre>\n<p></p>\n<h3>0x04 new 和 delete 操作自定义类型</h3>\n<p>我们知道了，<span style=\"color:#956fe7;\">malloc</span> /<span style=\"color:#956fe7;\"> free </span>和 <span style=\"color:#956fe7;\">new</span> / <span style=\"color:#956fe7;\">delete</span> 对于内置类型没有本质区别，</p>\n<p><img alt=\"\" height=\"60\" src=\"..\\..\\static\\image\\09cd2ea145e44146b77999a266858c13.png\" width=\"60\"/> 那么它存在的意义是什么呢？仅仅是因为用法更简洁吗？</p>\n<p><img alt=\"\" height=\"59\" src=\"..\\..\\static\\image\\a47abcabf46e4b1a9173d795c995c0e7.png\" width=\"60\"/> 当然不是，因为 <span style=\"color:#956fe7;\">new </span>和<span style=\"color:#956fe7;\"> malloc</span> 可以操作自定义类型，我们继续往下看。</p>\n<p></p>\n<p></p>\n<p></p>\n<p><strong>malloc 和 new 的对比</strong></p>\n<p><img alt=\"\" height=\"207\" src=\"..\\..\\static\\image\\23daad5537b644f19d23cb1bb395e4db.png\" width=\"387\"/></p>\n<p>我们先来对比一下 <span style=\"color:#956fe7;\">malloc</span> 和 <span style=\"color:#956fe7;\">new</span>，俗话说的好，没有对比就没有伤害。</p>\n<p>对于自定义类型，你也是可以用 <span style=\"color:#956fe7;\">malloc</span> 的。</p>\n<p>💬 用<span style=\"color:#956fe7;\"> malloc </span>创建对象：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n\tA()\n\t\t: _a(0) {\n\t\tcout &lt;&lt; \"A():\" &lt;&lt; this &lt;&lt; endl;\n\t}\n\t~A() {\n\t\tcout &lt;&lt; \"~A():\" &lt;&lt; this &lt;&lt; endl;\n\t}\n\nprivate:\n\tint _a;\n};\n\nint main(void)\n{\n\t// 动态申请单个A对象和5个A对象数组\n\tA* p1 = (A*)malloc(sizeof(A));\n\tA* p2 = (A*)malloc(sizeof(A) * 5);\n}</code></pre>\n<p>对于这种是自定义类型的场景，你继续坚持用C语言的动态内存开辟的手段，</p>\n<p>是 彳亍 的，没人会拦你，但是我们在来看看C++的：</p>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\t// 动态申请单个A对象和5个A对象数组\n\tA* p1 = (A*)malloc(sizeof(A));\n\tA* p2 = (A*)malloc(sizeof(A) * 5);\n\n\tA* p3 = new A;     // 后面只需要跟类型就可以\n\tA* p4 = new A[5];\n}</code></pre>\n<p><img alt=\"\" height=\"60\" src=\"..\\..\\static\\image\\f7fafc6cf16d4f99954749913f8e18ac.png\" width=\"60\"/>直接看代码，同样是申请单个A对象和5个对象数组，C++写法明显是是更简单。</p>\n<p> 仅仅是因为如此吗？我们再来调试看一看。</p>\n<p>🔍 让我看看！</p>\n<p><img alt=\"\" height=\"965\" src=\"..\\..\\static\\image\\9103f2e5de814dc58e464007d9f4b822.png\" width=\"1200\"/></p>\n<p>我敲，还有这种功能？玩的这么花的吗，不仅能开内存，还能帮你初始化！</p>\n<p>如果是一个数组，<span style=\"color:#956fe7;\">new </span>也会对它初始化。</p>\n<p></p>\n<p>💬 比如这里的 <span style=\"color:#956fe7;\">new </span><strong>A</strong>[5] ，它会依次对动态创建的5个对象进行初始化。</p>\n<p><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\bd3d47e4f6d94373a518486edec426f9.png\" width=\"609\"/></p>\n<p>真的是太棒了，<strong><span style=\"color:#956fe7;\"><span style=\"background-color:#f9eda6;\">new</span></span></strong><span style=\"background-color:#f9eda6;\"> 不仅会开内存，还会调用对应的构造函数初始化</span>，多省事？</p>\n<p>不仅仅是写法上变得简单了，对于自定义类型来说用起来也特别爽！还有什么理由不用<span style=\"color:#956fe7;\"> new</span> 呢？</p>\n<p></p>\n<p><strong>free 与 delete 的对比</strong></p>\n<p><img alt=\"\" height=\"194\" src=\"..\\..\\static\\image\\6f6d9e9347b94f50bca32072ec6f30a2.png\" width=\"344\"/></p>\n<p>💬 我们来对比一下<span style=\"color:#956fe7;\"> free </span>和<span style=\"color:#956fe7;\"> delete</span>，它们都是用来释放内存空间的。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n\tA()\n\t\t: _a(0) {\n\t\tcout &lt;&lt; \"A():\" &lt;&lt; this &lt;&lt; endl;\n\t}\n\t~A() {\n\t\tcout &lt;&lt; \"~A():\" &lt;&lt; this &lt;&lt; endl;\n\t}\n\nprivate:\n\tint _a;\n};\n\nint main(void)\n{\n\tA* p1 = (A*)malloc(sizeof(A));\n\tA* p2 = (A*)malloc(sizeof(A) * 5);\n\n\tA* p3 = new A;  \n\tA* p4 = new A[5];\n\n\tfree(p1);\n\tfree(p2);\n    \n\tdelete p3;\n\tdelete[] p4;\n\n    // ...\n}</code></pre>\n<p>相对的，<span style=\"color:#956fe7;\">free </span>只是把 <strong>p1 p2</strong> 指向的空间释放掉。</p>\n<p>而 <span style=\"color:#956fe7;\">delete </span>不仅会释<strong> p1 p2</strong> 指向的空间，<strong><span style=\"color:#956fe7;\"><span style=\"background-color:#f9eda6;\">delete</span></span></strong><span style=\"background-color:#f9eda6;\"> 还会调用对应的析构函数。</span></p>\n<p><img alt=\"\" height=\"321\" src=\"..\\..\\static\\image\\d5e2f650cbb043fb981bd7b2ab4b3c44.png\" width=\"581\"/></p>\n<p>🔺 总结：</p>\n<p>在申请自定义类型的空间时，<span style=\"color:#956fe7;\">new </span>会调用构造函数，</p>\n<p><span style=\"color:#956fe7;\">delete </span>会调用析构函数，而 <span style=\"color:#956fe7;\">malloc </span>与<span style=\"color:#956fe7;\"> free</span> 不会。</p>\n<p><strong>new：</strong><span style=\"background-color:#f9eda6;\">在堆上申请空间 + 调用构造函数输出。</span></p>\n<p><strong>delete：</strong><span style=\"background-color:#f9eda6;\">先调用指针类型的析构函数 + 释放空间给堆上。</span></p>\n<p></p>\n<p></p>\n<h3>0x05 建议匹配使用</h3>\n<pre><code class=\"language-cpp\">new     👉  delete \nnew[]   👉  delete[] \n\nmalloc  👉  free(A)</code></pre>\n<p><img alt=\"\" height=\"84\" src=\"..\\..\\static\\image\\2da7fd7b4ffc4856b76bfe17ea72058a.png\" width=\"99\"/><span style=\"color:#956fe7;\">  new </span>对应的是<span style=\"color:#956fe7;\"> delete</span>，可以可以 <span style=\"color:#956fe7;\">new </span>出来的用 <span style=\"color:#956fe7;\">free</span> 释放？</p>\n<p>💡 不建议大家混着用， <span style=\"color:#956fe7;\">new </span>出来的用<span style=\"color:#956fe7;\"> free</span>，有的编译器就会爆炸。</p>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\tA* p4 = new A[5];\n\tfree(p4);\t      // delete[] p4;     \n}\n</code></pre>\n<p><img alt=\"\" height=\"302\" src=\"..\\..\\static\\image\\31a7e26ea54f41a389db7c99e7e38d4a.png\" width=\"512\"/></p>\n<p></p>\n<p>💬<span style=\"color:#956fe7;\"> new[]</span> 出来的 你去<span style=\"color:#956fe7;\"> delate </span>而不是 <span style=\"color:#956fe7;\">delate[]  </span>也会崩：</p>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\tA* p4 = new A[5];\n\tdelete p4;\t      // delete[] p4;     \n}</code></pre>\n<p><img alt=\"\" height=\"250\" src=\"..\\..\\static\\image\\ddb7c86dfae84ddc9bfdf5d81eecaf10.png\" width=\"518\"/></p>\n<p> 记住一个点就可以了：<span style=\"background-color:#f9eda6;\">壹壹对应，匹配使用！malloc/free 和 delete/delete   new[] / delete[] </span></p>\n<p>（你要过马路你就老老实实走斑马线，不要瞎穿）</p>\n<p>其实也不一定会出问题，具体得看编译器的检查机制，但是这个 \"不一定\" 就带有悬念了。</p>\n<p><img alt=\"\" height=\"155\" src=\"..\\..\\static\\image\\2c3ec9066ee74601adb63e3eab358633.png\" width=\"155\"/>  所以个人建议，还是老老实实的比较好。</p>\n<p></p>\n<p></p>\n<p></p>\n<h2>Ⅲ.  new 和 delete 的底层探索</h2>\n<h3>0x00 operator new 与 operator delete 函数</h3>\n<pre><code class=\"language-cpp\">/*\noperator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，\n尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。\n*/\n\nvoid* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)\n{\n\t// try to allocate size bytes\n\tvoid* p;\n\twhile ((p = malloc(size)) == 0)\n\t\tif (_callnewh(size) == 0)\n\t\t{\n\t\t\t// report no memory\n\t\t\t// 如果申请内存失败了，这里会抛出bad_alloc 类型异常\n\t\t\tstatic const std::bad_alloc nomem;\n\t\t\t_RAISE(nomem);\n\t\t}\n\n\treturn (p);\n}\n\n\n/*\noperator delete: 该函数最终是通过free来释放空间的\n*/\n\nvoid operator delete(void* pUserData)\n{\n\t_CrtMemBlockHeader* pHead;\n\n\tRTCCALLBACK(_RTC_Free_hook, (pUserData, 0));\n\n\n\tif (pUserData == NULL\n\t\treturn;\n\n\t_mlock(_HEAP_LOCK); /* block other threads */\n\t__TRY\n\t\t/* get a pointer to memory block header */\n\t\tpHead = pHdr(pUserData);\n\n\t\t/* verify block type */\n\t\t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));\n\n\t\t_free_dbg(pUserData, pHead-&gt;nBlockUse);\n\n\t__FINALLY\n\t\t_munlock(_HEAP_LOCK); /* release other threads */\n\t__END_TRY_FINALLY\n\t\n\treturn;\n}\n\n/*\nfree的实现\n*/\n#define free(p) _free_dbg(p, _NORMAL_BLOCK)</code></pre>\n<p><img alt=\"\" height=\"42\" src=\"..\\..\\static\\image\\1df3a04526264a9fbbea81b60e334eef.png\" width=\"102\"/> 通过上述两个全局函数的实现可以知道： </p>\n<p>① <span style=\"color:#956fe7;\">operator new</span> 实际上也是通过 <span style=\"color:#e6b223;\">malloc </span>来申请空间的。</p>\n<p>②<span style=\"color:#956fe7;\"> operator delete</span> 最终也是通过<span style=\"color:#956fe7;\"> </span><span style=\"color:#e6b223;\">free </span>来释放空间的。</p>\n<p></p>\n<p>如果<span style=\"color:#e6b223;\"> malloc</span><span style=\"color:#956fe7;\"> </span>申请空间成功就直接返回，否则执行用户提供的空间不足的应对措施，</p>\n<p>如果用户提供该措施就继续申请，否则就抛异常。</p>\n<p><strong>面向过程的语言处理错误的方式：</strong></p>\n<p>返回值 + 错误码解决（这个我们之前学过）。</p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    char* p1 = (char*)malloc(1024u * 1024u * 1024u *2u);\n    if (p1 == nullptr) {\n        printf(\"%d\\n\", errno);\n        perror(\"malloc fail\");\n        exit(-1);\n    } else {\n        printf(\"%p\\n\", p1);\n    }\n\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\77c7e780ed15471792b35cc6bffc7fbe.png\" width=\"415\"/></p>\n<p></p>\n<p><strong>而面向对象语言处理错误的方式：</strong></p>\n<p>一般是抛异常，C++中也要求出错抛异常 ——<span style=\"color:#956fe7;\"> try </span><span style=\"color:#e6b223;\">catch</span>（后期会细说）。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main(void)\n{\n    char* p2 = nullptr;\n    try {\n        char* p2 = new char[1024u * 1024u * 1024u * 2u - 1];\n    } catch (const exception&amp; e) {\n        cout &lt;&lt; e.what() &lt;&lt; endl;\n    }\n    printf(\"%p\\n\", p2);\n\n    return 0;\n}\n</code></pre>\n<p><img alt=\"\" height=\"133\" src=\"..\\..\\static\\image\\edef6305320c4f0c9a91ae14967260db.png\" width=\"452\"/></p>\n<p></p>\n<p>🔺 C++ 提出 <span style=\"color:#956fe7;\">new</span> 和 <span style=\"color:#956fe7;\">delete</span>，主要是解决两个问题：</p>\n<p>① 自定义类型对象自动申请的时候，初始化合清理的问题。<span style=\"color:#956fe7;\">new</span> /<span style=\"color:#956fe7;\"> delete</span> 会调用构造函数和析构函数。</p>\n<p>②<span style=\"color:#956fe7;\"> new </span>失败了以后要求抛异常，这样才符合面向语言的出错处理机制。</p>\n<p>（<span style=\"color:#956fe7;\">delete </span>和 <span style=\"color:#e6b223;\">free </span>一般不会失败，如果失败了，都是释放空间上存在越界或者释放指针位置不对）</p>\n<p></p>\n<h3>0x02  operator new 与 operator delete 的类专属重载</h3>\n<p>下面代码演示了，针对链表的节点 <span style=\"color:#4da8ee;\">ListNode</span> 通过重载类专属 <span style=\"color:#956fe7;\">operator new </span>/ <span style=\"color:#956fe7;\">operator delete</span>，</p>\n<p><img alt=\"\" height=\"120\" src=\"https://img-blog.csdnimg.cn/d20fc5d273634fdb98142b65ee4572df.gif\" width=\"120\"/>实现链表节点使用内存池申请和释放内存，提高效率。</p>\n<p></p>\n<p>💬 我们先看看按照C的方式写：</p>\n<pre><code class=\"language-cpp\">struct ListNode {\n\tListNode* _next;\n\tListNode* _prev;\n\tint _val;\n};\n\n\nint main(void)\n{\n\tstruct ListNode* n1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n\tif (n1 == NULL) {\n\t\tprintf(\"malloc failed!\\n\");\n\t\texit(-1);\n\t}\n\tn1-&gt;_next = NULL;\n\tn1-&gt;_prev = NULL;\n\tn1-&gt;_val = 0;\n\n\treturn 0;\n}</code></pre>\n<p>我们创建节点还需要用<span style=\"color:#e6b223;\"> malloc </span>申请空间，还需要强制类型转换，之后还要自己写上初始化，</p>\n<p>因为 <span style=\"color:#e6b223;\">malloc</span> 失败返回<span style=\"color:#be191c;\"> NULL</span>，会存在野指针隐患，所以出于安全还要检查一下。</p>\n<p></p>\n<p>💬 我们再来看看 C++ 的方式：</p>\n<pre><code class=\"language-cpp\">struct ListNode {\n\tListNode* _next;\n\tListNode* _prev;\n\tint _val;\n\n\t/* 构造函数*/\n\tListNode(int val)\n\t\t: _next(nullptr)\n\t\t, _prev(nullptr)\n\t\t, _val(val) {}\n};\n\nint main(void)\n{\n\tListNode* n2 = new ListNode(0);\n\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"\" height=\"103\" src=\"..\\..\\static\\image\\4b3bbe27b435490b9b165de786f6c3e6.png\" width=\"141\"/> 而在C++里，因为 <span style=\"color:#956fe7;\">new </span>会自动调用构造函数去完成初始化，就很舒服。</p>\n<p>而且还不需要去检查是否开辟失败，因为<span style=\"color:#956fe7;\"> new</span> 失败不会返回空，而是抛异常。</p>\n<p></p>\n<p>💬 我们再举个能用得上析构函数的例子 —— Stack：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Stack {\npublic:\n\tStack(int capacity = 4)\n\t\t: _top(0)\n\t\t, _capacity(capacity) {\n\t\t_arr = new int[capacity];\n\t}\n\t~Stack() {\n\t\tdelete[] _arr;\n\t\t_arr = nullptr;\n\t\t_capacity = _top = 0;\n\t}\n\t// ...\n\t\nprivate:\n\tint* _arr;\n\tint  _top;\n\tint  _capacity;\n};\n\nint main(void)\n{\n\tStack st;  // 完事了\n\tStack* pst2 = new Stack;  // 开空间 + 构造函数初始化\n\tdelete pst2;  // 析构函数（清理对象中资源）+ 释放空间\n\n\treturn 0;\n}\n</code></pre>\n<p></p>\n<h2>Ⅳ.  new 和 delete 的实现原理</h2>\n<h3>0x00  对于内置类型</h3>\n<p><img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\533f2d194e2b44b1a6a005fdac8c9688.png\" width=\"50\"/> 如果申请的是内置类型的空间，<span style=\"color:#956fe7;\">new </span>和<span style=\"color:#e6b223;\"> malloc</span>，<span style=\"color:#956fe7;\">delete</span> 和<span style=\"color:#e6b223;\"> free </span>基本相似。</p>\n<p>不同的地方是，<span style=\"color:#956fe7;\">new </span>/<span style=\"color:#956fe7;\"> delete </span>申请和释放的是单个元素的空间，</p>\n<p><span style=\"color:#956fe7;\">new[]</span> 和<span style=\"color:#956fe7;\"> delete[] </span>申请的是连续空间。而且 <span style=\"color:#956fe7;\">new </span>再申请空间失败时会抛异常。</p>\n<pre><code class=\"language-cpp\">A* p3 = new A;      // 开辟单个空间\nA* p4 = new A[5];   // 开辟的是连续地5个空间</code></pre>\n<p><span style=\"color:#956fe7;\">operator new </span>和 <span style=\"color:#956fe7;\">operator delete </span>就是对<span style=\"color:#e6b223;\"> malloc </span>和<span style=\"color:#e6b223;\"> free </span>的封装。</p>\n<p><span style=\"color:#956fe7;\">operator new </span>中调用 <span style=\"color:#e6b223;\">malloc </span>后申请内存，失败以后，改为抛异常处理错误，</p>\n<p>这样符合C++面向对象语言处理错误的方式。</p>\n<pre><code class=\"language-cpp\">new Stack\ncall malloc + call Stack 构造函数   ❌ 如果失败返回0，这不符合C++处理错误的方式\n\nnew Stack\ncall operator new + call Stack 构造函数  ✅  失败抛异常，这就非常滴合适</code></pre>\n<p><img alt=\"\" height=\"224\" src=\"..\\..\\static\\image\\9ee2dcfd6b024951b45576dc5fe7796c.png\" width=\"505\"/></p>\n<p></p>\n<p></p>\n<h3>0x01 对于自定义类型</h3>\n<p><strong>new 的原理：</strong></p>\n<p>① 调用 <span style=\"color:#956fe7;\">operator new </span>函数申请空间。</p>\n<p>② 在申请空间上执行构造函数，完成对象的构造。</p>\n<p></p>\n<p><strong>delete 的原理：</strong></p>\n<p>① 在空间上执行析构函数，完成对象中资源的清理工作。</p>\n<p>② 调用<span style=\"color:#956fe7;\"> operator delete </span>函数释放对象的空间。</p>\n<p></p>\n<p><strong>new T[N] 的原理：</strong></p>\n<p>① 调用 <span style=\"color:#956fe7;\">operator new[]</span> 函数，在<span style=\"color:#956fe7;\"> operator new[] </span>中实际调用 <span style=\"color:#956fe7;\">operator new</span> 函数完成 N 个对象空间的申请。</p>\n<p>② 在申请的空间上调用 N 次构造函数，对它们分别初始化。</p>\n<pre><code class=\"language-cpp\">Stack* p1 = new[10];\nStack* pst1 = (Stack*)operator new[](sizeof(Stack) * 10);</code></pre>\n<p><img alt=\"\" height=\"314\" src=\"..\\..\\static\\image\\74b4644ec3b248e6a0f1e73b81bde51e.png\" width=\"459\"/></p>\n<p></p>\n<p><strong>delete[] 的原理：</strong></p>\n<p>① 在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理。</p>\n<p>② 调用 <span style=\"color:#956fe7;\">operator delete[] </span>释放空间，实际在<span style=\"color:#956fe7;\"> operator delete[]</span> 中调用 <span style=\"color:#956fe7;\">operator delete </span>来释放空间。</p>\n<p></p>\n<p></p>\n<h2>Ⅴ.  定位new</h2>\n<h3>0x00 引入 - 我想手动初始化</h3>\n<p>如果不用 <span style=\"color:#956fe7;\">new</span>，我想手动调用构造函数初始化，</p>\n<p>假设我们这有一块空间，是从内存池取来的，或者是 <span style=\"color:#e6b223;\">malloc </span>出来的、<span style=\"color:#956fe7;\">operator new </span>出来的……</p>\n<p><img alt=\"\" height=\"96\" src=\"..\\..\\static\\image\\a689320886894563bfe808ae224a6cf8.png\" width=\"89\"/> 我就不想用 <span style=\"color:#956fe7;\">new</span>，但是我想对他进行初始化，行不行？</p>\n<pre><code class=\"language-cpp\">A* p = (A*)malloc(sizeof(A));  // 我能不能调用构造函数初始化？</code></pre>\n<p>当然可以！定位new表达式帮你！</p>\n<p></p>\n<h3>0x01 定位new表达式</h3>\n<p>定位 <span style=\"color:#ad720d;\">new</span> 表达式实在已分配的原始空间中调用构造函数初始化一个对象。</p>\n<p>简单来说就是，<span style=\"background-color:#f9eda6;\">定位new表达式可以在已有的空间进行初始化。</span></p>\n<p>📚 写法：</p>\n<pre><code class=\"language-cpp\">new(目标地址指针)类型                         // 不带参\nnew(目标地址指针）类型(该类型的初始化列表)       // 带参</code></pre>\n<p>📌 注意：目标地址必须是一个指针</p>\n<p></p>\n<h3>0x02 定位new的使用场景</h3>\n<p><img alt=\"\" height=\"101\" src=\"..\\..\\static\\image\\dfc9376ca0a74202a97424a0d23414b6.png\" width=\"100\"/>定位 new 是很有用的！</p>\n<p>比如开的空间是从内存池来的，如果想初始化，我们就可以使用它。</p>\n<p>因为内存池分配出的内存初始化，所以如果是自定义类型的对象，</p>\n<p>需要使用 <span style=\"color:#956fe7;\">new </span>定义的表达式进行显示调用构造函数进行初始化。</p>\n<p></p>\n<p></p>\n<h3>0x03 定位new用法演示</h3>\n<p><strong>不带参定位new：</strong></p>\n<pre><code class=\"language-cpp\">class A {\npublic:\n\tA(int a = 0)\n\t\t: _a(a) {\n\t\tcout &lt;&lt; \"A(): \" &lt;&lt; this &lt;&lt; endl;\n\t}\n\t~A() {\n\t\tcout &lt;&lt; \"~A(): \" &lt;&lt; this &lt;&lt; endl;\n\t}\n\nprivate:\n\tint _a;\n};\n\nint main(void)\n{\n\tA* p = (A*)malloc(sizeof(A));\n\tnew(p)A;   // 定位new\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"431\" src=\"..\\..\\static\\image\\952978a881c3491fb20a306edfcd2b31.png\" width=\"600\"/></p>\n<p></p>\n<p></p>\n<p><strong>带参定位new：</strong></p>\n<pre><code class=\"language-cpp\">class A {\npublic:\n\tA(int a)\n\t\t: _a(a) {\n\t\tcout &lt;&lt; \"A(): \" &lt;&lt; this &lt;&lt; endl;\n\t}\n\t~A() {\n\t\tcout &lt;&lt; \"~A(): \" &lt;&lt; this &lt;&lt; endl;\n\t}\n\nprivate:\n\tint _a;\n};\n\nint main(void)\n{\n\tA* p1 = (A*)malloc(sizeof(A));\n\tnew(p1)A(10);\n\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"\" height=\"261\" src=\"..\\..\\static\\image\\1da88d604bcd493cadaa6da9959fb0dc.png\" width=\"516\"/></p>\n<p></p>\n<p>💬 模拟一下<span style=\"color:#956fe7;\"> new</span> 的行为：</p>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\tA* p1 = (A*)malloc(sizeof(A));\n\tnew(p1)A(10);\n\n    // 模拟一下new的行为\n\tA* p2 = new A(2); \n\n\t// 等价于:\n\tA* p3 = (A*)operator new(sizeof(A));\n\tnew(p3)A(3);\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"137\" src=\"..\\..\\static\\image\\4823a3116eff4907b2674a62a4acad17.png\" width=\"362\"/></p>\n<p><img alt=\"\" height=\"91\" src=\"..\\..\\static\\image\\9ecca676ffbf47f2bce43d82fbb2f8de.png\" width=\"138\"/>  没事这么写，其实就是脱裤子放屁，</p>\n<p>但是有时候，内存不一定是从堆来的，比如从内存池来的，定位 new 就可以大显神功。</p>\n<p>高并发内存池，实现定长内存池的时候就需要使用 定位 new。</p>\n<p></p>\n<p><strong>析构函数释放</strong></p>\n<p>析构函数是可以显式调用的（构造函数不行）</p>\n<pre><code class=\"language-cpp\">p-&gt;~A;</code></pre>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\tA* p1 = (A*)malloc(sizeof(A));\n\tnew(p1)A(1);\n\n\tA* p2 = new A(2);\n\tdelete p2;\n\n\t// 等价于:\n\tA* p3 = (A*)operator new(sizeof(A));\n\tnew(p3)A(3);\n\n\tp3-&gt;~A;\n\toperator delete(p3);\n\n\treturn 0;\n}\n</code></pre>\n<p></p>\n<p></p>\n<hr/>\n<p><strong>参考资料：</strong></p>\n<p><span style=\"color:#a5a5a5;\">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p>\n<p><span style=\"color:#a5a5a5;\">. C++reference[EB/OL]. []. http://www.cplusplus.com/reference/.</span></p>\n<p><span style=\"color:#a5a5a5;\">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p>\n<p><span style=\"color:#a5a5a5;\">比特科技. C++[EB/OL]. 2021[2021.8.31]. </span></p>\n<p><span style=\"color:#a5a5a5;\">封面作者：啊不Abu</span></p>\n<blockquote>\n<p>📌 笔者：王亦优</p>\n<p>📃 更新： 2022.3.28</p>\n<p>❌ 勘误：暂无</p>\n<p>📜 声明： 由于作者水平有限，本文有错误和不准确之处在所难免，本人也很想知道这些错误，恳望读者批评指正！</p>\n</blockquote>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-09 22:55:50", "summary": "爆笑教程《要笑着学》《要笑着学》火速订阅本篇博客全站热榜排名：前言：是这样的，语言里的动态内存管理放到里面，用起来不是那么爽，所以就对这一块进行了升级，本章我们就探索探索的内存管理，顺便复习一下语言里"}