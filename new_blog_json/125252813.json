{"blogid": "125252813", "writerAge": "码龄5年", "writerBlogNum": "82", "writerCollect": "609", "writerComment": "73", "writerFan": "5301", "writerGrade": "5级", "writerIntegral": "1830", "writerName": "熊思宇", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125252813.jpg", "writerRankTotal": "9706", "writerRankWeekly": "1170", "writerThumb": "149", "writerVisitNum": "238839", "blog_read_count": "945", "blog_time": "已于 2022-08-20 10:08:31 修改", "blog_title": "C# Winform自动更新", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82\">一、需求</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8\">二、更新文件列表生成器</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%99%A8\">三、软件启动器</a></p>\n<p id=\"1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0\">1.判断是否需要更新</a></p>\n<p id=\"1%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#1%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6\">1）检测到新版本，是否更新软件</a></p>\n<p id=\"2%EF%BC%89%E7%89%88%E6%9C%AC%E8%BF%87%E6%97%A7%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC-toc\" style=\"margin-left:80px;\"><a href=\"#2%EF%BC%89%E7%89%88%E6%9C%AC%E8%BF%87%E6%97%A7%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC\">2）版本过旧，请更新到最新版本</a></p>\n<p id=\"3%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#3%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD\">2.文件下载</a></p>\n<p id=\"4%EF%BC%89%E6%89%A7%E8%A1%8C%20%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E5%88%A0%E9%99%A4%20%E4%BB%BB%E5%8A%A1-toc\" style=\"margin-left:40px;\"><a href=\"#4%EF%BC%89%E6%89%A7%E8%A1%8C%20%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E5%88%A0%E9%99%A4%20%E4%BB%BB%E5%8A%A1\">3.执行 下载，覆盖，删除任务</a></p>\n<p id=\"5%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-toc\" style=\"margin-left:40px;\"><a href=\"#5%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C\">4.执行结果</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E6%90%AD%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E6%90%AD%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8\">四、搭建更新服务器</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95\">五、整体测试</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E6%9D%9F\">结束</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82\">一、需求</h1>\n<p>在Unity里面，有XLua，ILRuntime 这样的热更新框架，有Unity经验的人都知道，在Unity里面发布的各个平台，哪怕是Windows平台，根本不必关闭程序才能进行更新，但是 Winform 项目必须关闭程序才进行下载替换，我也在网上找了一下，目前 Winform 还没看到什么比较好的开源框架，于是我自己动手写了一个</p>\n<p>效果如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"https://img-blog.csdnimg.cn/8d699a0874db478482b48b95c5b07337.gif\"/></p>\n<p>在 Windows 平台，客户端自动更新方法一般如下面几个步骤，最少需要做三个软件</p>\n<p><span style=\"color:#fe2c24;\"><strong>1.更新文件列表生成器</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>2.软件启动器</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>3.软件本体（只能由软件启动器 打开）</strong></span></p>\n<p>软件启动入口可以加密码，防止用户随意打开</p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8\">二、<strong>更新文件列表生成器</strong></h1>\n<p>我们知道，在原有基础上更新文件必要的三个基础：新增，覆盖，删除，那么问题来了，新增和删除好理解，在覆盖文件这块，假如：最新文件和旧版文件有一个同名的文件都叫 Test.dll，这时候要怎么判断是否进行下载和替换？</p>\n<p>这个问题，可以用文件的哈希值去解决，如果客户端匹配不上，那么就需要从服务器下载和替换了，代码如下：</p>\n<pre><code class=\"language-cs\">using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\nnamespace Test\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            string path1 = \"D:\\\\单据备份\\\\53.png\";\n            string saveHash = \"97-9F-FC-54-BF-C0-95-B8-15-64-C5-AC-81-03-DE-90-13-CD-03-D5\";\n            using (HashAlgorithm hash = HashAlgorithm.Create())\n            {\n                using (FileStream file1 = new FileStream(path1, FileMode.Open))\n                {\n                    byte[] hashByte1 = hash.ComputeHash(file1);//哈希算法根据文本得到哈希码的字节数组\n                    string str1 = BitConverter.ToString(hashByte1);//将字节数组装换为字符串\n                    Console.WriteLine(str1);\n\n                    if (saveHash.Equals(str1))\n                        Console.WriteLine(\"两个文件相同\");\n                    else\n                        Console.WriteLine(\"两个文件不相同\");\n                }\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>\n<p>更新文件生成器界面如下，将最新的软件文件放到服务器一个固定的文件夹，然后用更新文件生成器就可以生成文件列表等数据了</p>\n<p><img alt=\"\" height=\"274\" src=\"..\\..\\static\\image\\d9bbed1c0e1a4c6382512db3bb733282.png\" width=\"600\"/></p>\n<p>生成的是一个json文件，不过json文件是加密的，直接是看不出里面有什么的，这个需要在客户端软件启动器中进行解密。</p>\n<p>加密json如下图</p>\n<p><img alt=\"\" height=\"72\" src=\"..\\..\\static\\image\\c72a92d109bc46d1a2f1995a933ce3e5.png\" width=\"600\"/></p>\n<p>这里加密了文件列表也是为了传输的安全。另外也可以加一些文件完整性校验，这个功能我暂时没加。</p>\n<p>原 json 的格式如下</p>\n<pre><code class=\"language-XML\">{\n\t\"DirectoryList\": [],\n\t\"FilesinfoList\": [{\n\t\t\"Path\": \"/2012年硕士研究生入学考试管理类专业硕士综合能力真题及参考答案.doc.pdf\",\n\t\t\"Hashs\": \"27-7B-18-DD-D6-A3-9A-CB-CE-79-D3-B1-62-C2-5E-0B-80-71-EB-37\"\n\t}, {\n\t\t\"Path\": \"/2013年全国硕士研究生入学统一考试英语试题及答案.pdf\",\n\t\t\"Hashs\": \"0D-63-3F-F6-7E-77-AB-DE-B4-7C-F6-20-66-72-AC-CF-B6-B8-C8-3A\"\n\t}, {\n\t\t\"Path\": \"/2014年全国硕士研究生入学统一考试管理类专业学位联考综合能力试题.pdf\",\n\t\t\"Hashs\": \"E7-06-D0-A5-7A-03-7F-09-D8-BB-5B-14-B2-88-40-0F-54-E6-79-4B\"\n\t},  {\n\t\t\"Path\": \"/全国硕士研究生入学统一考试数学一试题完整版.pdf\",\n\t\t\"Hashs\": \"6B-B6-0D-86-23-C9-EE-CB-D7-9D-55-17-06-81-DB-69-58-9E-81-14\"\n\t}, {\n\t\t\"Path\": \"/全国硕士研究生入学考试政治试题及答案.pdf\",\n\t\t\"Hashs\": \"2C-56-95-7E-7C-6F-B5-F9-18-CE-6D-22-89-5B-68-36-23-0D-D7-68\"\n\t}, {\n\t\t\"Path\": \"/全国硕士研究生入学考试数学二试题及解析(1).pdf\",\n\t\t\"Hashs\": \"D8-07-32-A0-56-94-7D-21-CD-B6-7D-C3-6B-04-7E-28-59-A1-D5-19\"\n\t}, {\n\t\t\"Path\": \"/全国硕士研究生入学考试英语(一)试题.pdf\",\n\t\t\"Hashs\": \"7E-07-67-36-15-D9-A4-59-5A-86-68-F9-9C-38-92-71-A2-03-21-34\"\n\t}]\n}</code></pre>\n<p>Json 中的 DirectoryList 属于文件夹的路径列表，由于我打包的这个路径没用子文件夹，所以就是空的，FilesinfoList 则是文件列表。</p>\n<p>更新文件列表生成器 代码并不复杂，只是将要打包的文件转化为一个json 文件，给客户端访问。</p>\n<p>首先，先将加密的文件写好，新建一个类 DES</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Utils\n{\n\n    public class DESKey\n    {\n        /// &lt;summary&gt;\n        /// Des默认密钥向量\n        /// &lt;/summary&gt;\n        public static byte[] IV = { 0x13, 0x35, 0x16, 0x78, 0x90, 0xAB, 0xCD, 0xEF };\n        /// &lt;summary&gt;\n        /// Des加解密钥必须8位\n        /// &lt;/summary&gt;\n        public const string Key = \"4hghhgg\";\n    }\n\n    public class DES\n    {\n        /// &lt;summary&gt;\n        /// Des加密\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"source\"&gt;源字符串&lt;/param&gt;\n        /// &lt;param name=\"key\"&gt;des密钥，长度必须8位&lt;/param&gt;\n        /// &lt;param name=\"iv\"&gt;密钥向量&lt;/param&gt;\n        /// &lt;returns&gt;加密后的字符串&lt;/returns&gt;\n        public static string EncryptDes(string source, string key, byte[] iv)\n        {\n            using (DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider())\n            {\n                byte[] rgbKeys = GetDesKey(key),\n                    rgbIvs = iv,\n                    inputByteArray = Encoding.UTF8.GetBytes(source);\n                using (MemoryStream memoryStream = new MemoryStream())\n                {\n                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, desProvider.CreateEncryptor(rgbKeys, rgbIvs), CryptoStreamMode.Write))\n                    {\n                        cryptoStream.Write(inputByteArray, 0, inputByteArray.Length);\n                        cryptoStream.FlushFinalBlock();\n                        return Convert.ToBase64String(memoryStream.ToArray());\n                    }\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Des解密\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"source\"&gt;源字符串&lt;/param&gt;\n        /// &lt;param name=\"key\"&gt;des密钥，长度必须8位&lt;/param&gt;\n        /// &lt;param name=\"iv\"&gt;密钥向量&lt;/param&gt;\n        /// &lt;returns&gt;解密后的字符串&lt;/returns&gt;\n        public static string DecryptDes(string source, string key, byte[] iv)\n        {\n            using (DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider())\n            {\n                byte[] rgbKeys = GetDesKey(key), rgbIvs = iv, inputByteArray = Convert.FromBase64String(source);\n                using (MemoryStream memoryStream = new MemoryStream())\n                {\n                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, desProvider.CreateDecryptor(rgbKeys, rgbIvs), CryptoStreamMode.Write))\n                    {\n                        cryptoStream.Write(inputByteArray, 0, inputByteArray.Length);\n                        cryptoStream.FlushFinalBlock();\n                        return Encoding.UTF8.GetString(memoryStream.ToArray());\n                    }\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 获取Des8位密钥\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"key\"&gt;Des密钥字符串&lt;/param&gt;\n        /// &lt;returns&gt;Des8位密钥&lt;/returns&gt;\n        private static byte[] GetDesKey(string key)\n        {\n            if (string.IsNullOrEmpty(key))\n            {\n                throw new ArgumentNullException(\"key\", \"Des密钥不能为空\");\n            }\n            if (key.Length &gt; 8)\n            {\n                key = key.Substring(0, 8);\n            }\n            if (key.Length &lt; 8)\n            {\n                // 不足8补全\n                key = key.PadRight(8, '0');\n            }\n            return Encoding.UTF8.GetBytes(key);\n        }\n    }\n}\n</code></pre>\n<p>Form1.cs</p>\n<pre><code class=\"language-cs\">using Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace UpdateFileCreater\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private class FileType\n        {\n            /// &lt;summary&gt;\n            /// 路径\n            /// &lt;/summary&gt;\n            public string Path { get; set; }\n            /// &lt;summary&gt;\n            /// 哈希值\n            /// &lt;/summary&gt;\n            public string Hashs { get; set; }\n        }\n\n        private class UpdateFile\n        {\n            /// &lt;summary&gt;\n            /// 文件夹列表\n            /// &lt;/summary&gt;\n            public List&lt;string&gt; DirectoryList { get; set; } = new List&lt;string&gt;();\n            /// &lt;summary&gt;\n            /// 文件列表\n            /// &lt;/summary&gt;\n            public List&lt;FileType&gt; FilesinfoList { get; set; } = new List&lt;FileType&gt;();\n        }\n\n        //需要生成列表的目录\n        private string Path = \"D:\\\\H\\\\本地服务器工具\\\\Software\\\\News\\\\\";\n        //存放json的位置\n        private string FileConfigJsonPath = Application.StartupPath + \"\\\\FileList.json\";\n\n        //本地文件的黑名单（不参与到更新）\n        private static List&lt;string&gt; LocalFileBlacklist = new List&lt;string&gt;();\n\n        //文件夹列表\n        private static List&lt;string&gt; DirectorysList = new List&lt;string&gt;();\n        //文件列表\n        private static List&lt;FileType&gt; FilesinfoList = new List&lt;FileType&gt;();\n\n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            this.TextBox_Path.Text = Path;\n\n            //添加黑名单\n            LocalFileBlacklist.Add(\"log4net.dll\");\n            LocalFileBlacklist.Add(\"log4net.xml\");\n            LocalFileBlacklist.Add(\"Newtonsoft.Json.dll\");\n            LocalFileBlacklist.Add(\"Newtonsoft.Json.xml\");\n        }\n\n        /// &lt;summary&gt;\n        /// 选择路径\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void Button_SelectionPath_Click(object sender, EventArgs e)\n        {\n            FolderBrowserDialog dialog = new FolderBrowserDialog();\n            dialog.Description = \"请选择文件夹\";\n            dialog.SelectedPath = Path;\n            if (dialog.ShowDialog() == DialogResult.OK)\n            {\n                if (string.IsNullOrEmpty(dialog.SelectedPath))\n                {\n                    MessageBox.Show(this, \"文件夹路径不能为空\", \"提示\");\n                    return;\n                }\n                Path = dialog.SelectedPath;\n                this.TextBox_Path.Text = Path;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 生成文件\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void Button_CreaterFile_Click(object sender, EventArgs e)\n        {\n            DirectorysList.Clear();\n            FilesinfoList.Clear();\n\n            if (System.IO.Directory.Exists(Path))\n            {\n                Task.Run(() =&gt;\n                {\n                    GetDirectoryFileList(Path);\n\n                    if (FilesinfoList.Count &gt; 0)\n                    {\n                        UpdateFile updateFile = new UpdateFile();\n                        updateFile.DirectoryList = DirectorysList;\n                        updateFile.FilesinfoList = FilesinfoList;\n                        //生成json文件\n                        string json = JsonConvert.SerializeObject(updateFile);\n                        //加密json文件\n                        json = Utils.DES.EncryptDes(json, Utils.DESKey.Key, Utils.DESKey.IV);\n                        WriteJsonFile(FileConfigJsonPath, json);\n                        MessageBox.Show(\"生成文件成功！\");\n                    }\n                });\n            }\n        }\n\n\n        /// &lt;summary&gt;\n        /// 获取一个文件夹下的所有文件和文件夹集合\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"path\"&gt;&lt;/param&gt;\n        private void GetDirectoryFileList(string path)\n        {\n            DirectoryInfo directory = new DirectoryInfo(path);\n            FileSystemInfo[] filesArray = directory.GetFileSystemInfos();\n            foreach (var item in filesArray)\n            {\n                if (item.Attributes == FileAttributes.Directory)\n                {\n                    //添加文件夹\n                    string dir = item.FullName.Replace(Path, \"\");\n                    DirectorysList.Add(dir);\n                    GetDirectoryFileList(item.FullName);\n                }\n                else\n                {\n                    string fileName = item.FullName.Replace(Path, \"\");\n                    fileName = fileName.Replace(@\"\\\", @\"/\");\n\n                    //是否在黑名单中\n                    bool isBlackList = false;\n                    if (LocalFileBlacklist.Count &gt; 0)\n                    {\n                        for (int i = 0; i &lt; LocalFileBlacklist.Count; i++)\n                        {\n                            if (LocalFileBlacklist[i].Equals(fileName))\n                            {\n                                isBlackList = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!isBlackList)\n                    {\n                        //添加文件\n                        FileType fileType = new FileType();\n                        fileType.Path = fileName;\n                        fileType.Hashs = GetHashs(item.FullName);\n                        FilesinfoList.Add(fileType);\n                    }\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 获取文件的哈希值\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"path\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private string GetHashs(string path)\n        {\n            //创建一个哈希算法对象\n            using (HashAlgorithm hash = HashAlgorithm.Create())\n            {\n                using (FileStream file1 = new FileStream(path, FileMode.Open))\n                {\n                    //哈希算法根据文本得到哈希码的字节数组\n                    byte[] hashByte1 = hash.ComputeHash(file1);\n                    //将字节数组装换为字符串\n                    return BitConverter.ToString(hashByte1);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 将json字符串内容写入Json文件并保存（若json文件不存在则创建）\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"path\"&gt;路径&lt;/param&gt;\n        /// &lt;param name=\"jsonConents\"&gt;Json内容&lt;/param&gt;\n        private void WriteJsonFile(string path, string jsonConents)\n        {\n            using (FileStream fs = new FileStream(path, FileMode.OpenOrCreate, System.IO.FileAccess.ReadWrite, FileShare.ReadWrite))\n            {\n                fs.Seek(0, SeekOrigin.Begin);\n                fs.SetLength(0);\n                using (StreamWriter sw = new StreamWriter(fs, Encoding.UTF8))\n                {\n                    sw.WriteLine(jsonConents);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>这样 更新文件列表生成器 就基本完成了。</p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%99%A8\">三、<strong>软件启动器</strong></h1>\n<p>在我们平时用到的很多Windows软件打开时都会有软件启动器，大部分的作用都是基于软件的更新和文件的效验，这也形成了软件体系一个固定的框架，那么为什么要用软件启动器呢，那是因为，Windows软件打开以后，软件的文件就会被占用，无法进行删除，替换等操作，所以，想要更新软件，软件启动器是必须的。</p>\n<p>软件启动器需要给项目添加管理员权限，软件启动器是启动软件之前，做的一些安全判断，比如文件是否完整，是否需要更新到最新版本，然后执行文件的新增，删除，覆盖 等任务。</p>\n<p></p>\n<h2 id=\"1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0\"><strong>1.判断是否需要更新</strong></h2>\n<p>软件启动器的第一个作用就是判断是否需要更新了，这里其实可以设置是否需要强制更新，用提示框提示，提示框为：</p>\n<h3 id=\"1%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6\">1）检测到新版本，是否更新软件</h3>\n<p>提示按钮，更新，取消</p>\n<p>1-1 按钮---点击更新</p>\n<p>打开文件下载界面</p>\n<p>读取服务器文件列表</p>\n<p>如果读取成功，</p>\n<p>进入下一步，判断是否有需要更新软件</p>\n<p>如果读取失败，处理方式有两种：</p>\n<p>① 提示无法连接到服务器（无法进入主界面）</p>\n<p>② 直接进入软件主界面</p>\n<p>1-2 按钮---点击取消：进入软件本体</p>\n<p>判断版本是否更新的方法：</p>\n<pre><code class=\"language-cs\">Version v1 = new Version(txt1.Text);\nVersion v2 = new Version(txt2.Text);\nif (v1 &gt; v2)\n{\n    MessageBox.Show(\"版本1高于版本2\");\n}\nif (v1 &lt; v2)\n{\n    MessageBox.Show(\"版本1低于版本2\");\n}</code></pre>\n<p></p>\n<h3 id=\"2%EF%BC%89%E7%89%88%E6%9C%AC%E8%BF%87%E6%97%A7%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC\">2）版本过旧，请更新到最新版本</h3>\n<p>提示按钮，更新，退出</p>\n<p>点击更新：打开文件下载界面</p>\n<p>点击退出：退出文件启动器</p>\n<p></p>\n<h2 id=\"3%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD\"><strong>2.文件下载</strong></h2>\n<p>1.如果需要更新，将本地文件的哈希值和服务器返回的列表进行判断，如果服务器文件哈希值和本地文件哈希值不一致，那么就加入到下载列表</p>\n<p>2.文件操作，更新软件本体通常的操作是：</p>\n<p>① 新增文件直接下载</p>\n<p>② 相同文件直接覆盖</p>\n<p>③ 删除文件直接删除</p>\n<p></p>\n<h2 id=\"4%EF%BC%89%E6%89%A7%E8%A1%8C%20%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E5%88%A0%E9%99%A4%20%E4%BB%BB%E5%8A%A1\">3.<strong>执行 下载，覆盖，删除任务</strong></h2>\n<p>需要操作的文件加入到任务列表（下载，覆盖，删除），需要专门写一个任务系统来执行此次操作，将每个子任务的结果显示到UI界面，这里可以用一个进度条和文本来显示执行的进度，</p>\n<p>但也需要注意一点，自动更新系统都有一个毛病，就是不能确保文件的完整性，如果在下载的中途结束软件启动器进程，会导致软件的文件不全，从而打不开软件，解决这个问题，可以用一个文件夹先下载好文件，下完之后，直接覆盖现有的文件。</p>\n<p></p>\n<h2 id=\"5%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C\"><strong>4.执行结果</strong></h2>\n<p>如果执行完成，打开软件本体</p>\n<p>如果执行失败，弹框显示错误信息，退出</p>\n<p><span style=\"color:#fe2c24;\">代码等待我优化完成上传</span></p>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E6%90%AD%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8\">四、搭建更新服务器</h1>\n<p>服务器可以使用软件来实现，不用的时候就关掉，在测试的时候，我们不必使用 IIS 这样的服务器，配置起来太麻烦了，软件名如下图</p>\n<p><img alt=\"\" height=\"115\" src=\"..\\..\\static\\image\\3cc73dd8f1f04085946c8f82f85ab8ff.png\" width=\"200\"/></p>\n<p>搭建软件服务器，主要有两个功能，</p>\n<p>1.主要就是让客户端在启动的时候，判断是否需要更新，</p>\n<p>2.当需要更新的时候，主动从服务器下载需要更新的文件</p>\n<p>后续更新。。。。</p>\n<p></p>\n<h1 id=\"%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95\">五、整体测试</h1>\n<p>后续更新。。。。</p>\n<p></p>\n<p></p>\n<h1 id=\"%E7%BB%93%E6%9D%9F\">结束</h1>\n<p>如果这个帖子对你有用，欢迎 关注 + 点赞 + 留言，谢谢</p>\n<p>end</p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-20 10:08:31", "summary": "目录一、需求二、更新文件列表生成器三、软件启动器判断是否需要更新检测到新版本，是否更新软件版本过旧，请更新到最新版本文件下载执行下载，覆盖，删除任务执行结果四、搭建更新服务器五、整体测试结束一、需求在"}