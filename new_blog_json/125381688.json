{"blogid": "125381688", "writerAge": "码龄2年", "writerBlogNum": "133", "writerCollect": "65", "writerComment": "6", "writerFan": "8", "writerGrade": "4级", "writerIntegral": "1373", "writerName": "姑老爷呀", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125381688.jpg", "writerRankTotal": "15864", "writerRankWeekly": "8650", "writerThumb": "26", "writerVisitNum": "35455", "blog_read_count": "2248", "blog_time": "于 2022-06-20 22:13:03 发布", "blog_title": "Vue3 手把手教你自定义组件——setup版", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>目录</h2>\n<p>自定义组件，我们一般需要实现这几个点：</p>\n<ul><li><a title=\"#1\">props</a> —— 定义属性</li><li><a title=\"#1\">events</a> —— 定义事件</li><li><a title=\"#2\">slots</a> —— 插槽</li><li><a title=\"#3\">expose</a> —— 定义组件可供外部访问的内容</li><li><a title=\"#4\">v-model</a> —— 自定义组件实现双向数据绑定</li><li><a title=\"#5\">provide 与 inject</a></li></ul>\n<h2><a id=\"_script_setup__12\"></a>为什么使用 script setup ？</h2>\n<p>刚开始尝试Vue 3的时候用的组合式API都是这样的写法</p>\n<pre><code>export default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n    ...\n    return {\n        ...\n    }\n  }\n} \n</code></pre>\n<p>乍一看感觉不如原来的<code>Options API</code>啊，什么逻辑都写到setup里面了，好臃肿的一个方法。</p>\n<p>但事实上，Vue 3在对响应式重新设计之后，让我们可以通过<code>ref</code>和<code>reactive</code>方法来创建声明一个响应式变量，也就意味着我们很多逻辑可以不依赖this.data进行开发和编写，甚至一些响应式逻辑都可以多组件复用。</p>\n<p>在了解了这些点之后，即便我们可以将逻辑拆分独立，通过解构的方式导入setup中，让我们代码更加高内聚低耦合，但我们依然避免不了，复杂组件需要return无数的方法或者变量提供给模板使用。</p>\n<p>但是，在<code>&lt;script setup&gt;</code> 语法糖出现之后，这个问题得到了极大的改善，不管是import的组件也好，还是声明的变量也罢，都可以不用一个个return了。</p>\n<p>编译器会帮助我们转换成<code>setup()</code>函数的内容，这意味着与普通的 <code>&lt;script&gt;</code> 只在组件被首次引入的时候执行一次不同，<code>&lt;script setup&gt;</code> 中的代码会在<strong>每次组件实例被创建的时候执行</strong>。</p>\n<p>所以，还不赶紧学起来？</p>\n<h2><a id=\"_44\"></a>自定义组件</h2>\n<h3><a id=\"props__events_47\"></a>props 与 events</h3>\n<p>在 <code>&lt;script setup&gt;</code> 中必须使用 <code>defineProps</code> 和 <code>defineEmits</code> API 来声明 <code>props</code> 和 <code>emits</code> ，它们具备完整的类型推断并且在 <code>&lt;script setup&gt;</code> 中是直接可用的：</p>\n<pre><code>&lt;script setup&gt;\nconst props = defineProps({\n  foo: String\n})\n\nconst emit = defineEmits(['change', 'delete'])\n// setup code\n&lt;/script&gt; \n</code></pre>\n<ul><li><code>defineProps</code> 和 <code>defineEmits</code> 都是只在 <code>&lt;script setup&gt;</code> 中才能使用的<strong>编译器宏</strong>。他们不需要导入且会随着 <code>&lt;script setup&gt;</code> 处理过程一同被编译掉。</li><li><code>defineProps</code> 接收与 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Foptions-data.html%23props\" title=\"https://v3.cn.vuejs.org/api/options-data.html#props\"><code>props</code> 选项</a>相同的值，<code>defineEmits</code> 也接收 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Foptions-data.html%23emits\" title=\"https://v3.cn.vuejs.org/api/options-data.html#emits\"><code>emits</code> 选项</a>相同的值。</li><li><code>defineProps</code> 和 <code>defineEmits</code> 在选项传入后，会提供恰当的类型推断。</li><li>传入到 <code>defineProps</code> 和 <code>defineEmits</code> 的选项会从 setup 中提升到模块的范围。因此，传入的选项不能引用在 setup 范围中声明的局部变量。这样做会引起编译错误。但是，它_可以_引用导入的绑定，因为它们也在模块范围内。</li></ul>\n<p>以上是官方文档对于定义Props和Emits的相关介绍，笔者觉得说的还是很清楚的，这里在<strong>圈一下重点</strong>：</p>\n<ul><li>在<code>&lt;script setup&gt;</code>中<strong>不需要导入</strong><code>defineProps</code> 和 <code>defineEmits</code></li><li>定义<code>props</code>时传入的参数与<code>options API</code>中<code>props</code>选项一致</li><li>在TS中可以直接<strong>纯类型声明</strong></li></ul>\n<pre><code>interface Props {\n    foo: string\n    bar?: number \n}\nconst props = defineProps&lt;Props&gt;(); \n</code></pre>\n<p>这里肯定很多小伙伴有疑问了，那如果用TS做纯类型的声明，默认值该怎么定义呢？</p>\n<p>呐，看这里！</p>\n<pre><code>interface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps&lt;Props&gt;(), {\n  msg: 'hello',\n  labels: () =&gt; ['one', 'two']\n}) \n</code></pre>\n<p>还有一个<code>withDefaults</code>编译器宏</p>\n<p>上面代码会被编译为等价的运行时 props 的 <code>default</code> 选项。此外，<code>withDefaults</code> 辅助函数提供了对默认值的类型检查，并确保返回的 <code>props</code> 的类型删除了已声明默认值的属性的可选标志。</p>\n<h3><a id=\"Slots_101\"></a>Slots</h3>\n<p>大部分情况，我们可能需要根据外部的slots的传入情况来决定组件内部的展示部分，在模板中我们可以通过<code>$slots</code>来访问所有的默认插槽以及具名插槽</p>\n<h4><a id=\"Authslots_105\"></a>比如：Auth组件校验不通过时，隐藏slots的内容</h4>\n<p>那么我们可以在模板中这样来做</p>\n<pre><code>// page\n&lt;Auth auth=\"commit\"&gt;\n    &lt;button&gt;提交&lt;button&gt;\n&lt;/Auth&gt;\n// components\n&lt;template&gt;\n    &lt;slot v-if=\"condition\" /&gt;\n&lt;/template&gt; \n</code></pre>\n<p>这样既不会增加dom节点也可以增加逻辑来处理按钮权限的问题</p>\n<h4><a id=\"_122\"></a>再比如：组件内部有多个插槽及具名插槽的时候</h4>\n<p>form表单中的<code>form-item</code>组件是可以自定义插槽来覆盖默认的input内容的，在模板中就可以通过$slots来访问具体的插槽对象</p>\n<pre><code>// page\n&lt;form-item&gt;\n    &lt;template #input&gt;\n        自定义form input内容\n    &lt;/template&gt;\n&lt;/form-item&gt;\n\n// components\n&lt;template&gt;\n    &lt;slot v-if=\"$slots.input\" name=\"input\" /&gt;\n    &lt;input v-else /&gt;\n&lt;/template&gt; \n</code></pre>\n<p>我们很少情况会在setup中操作Slots，但是它依然提供了<code>useSlots</code>方法来帮我们操作组件的Slots</p>\n<pre><code>&lt;script setup&gt;\n\nimport { useSlots } from 'vue'\n\nconst slots = useSlots()\n\n&lt;/script&gt; \n</code></pre>\n<h3><a id=\"Expose_153\"></a>Expose</h3>\n<p>使用 <code>&lt;script setup&gt;</code> 的组件是<strong>默认关闭</strong>的，也即通过模板 ref 或者 <code>$parent</code> 链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定。</p>\n<p>我们组件内部的状态和方法可能会很多，比如一些复杂的组件，但是有些状态外部或许需要在适当时候操作或访问的时候，我们就需要考虑那些属性和方法是可以暴露给外部的</p>\n<p>这个时候我们就可以使用<code>defineExpose</code>来声明绑定</p>\n<pre><code>&lt;script setup&gt;\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n&lt;/script&gt; \n</code></pre>\n<p>当父组件通过模板 ref 的方式获取到当前组件的实例，获取到的实例会像这样 <code>{ a: number, b: number }</code> (ref 会和在普通实例中一样被自动解包)</p>\n<h3><a id=\"vmodel_177\"></a>v-model</h3>\n<p>v-model其实是一个语法糖</p>\n<p>它代表声明了一个<code>modelValue</code>的属性以及一个<code>update:modelValue</code>的事件</p>\n<p>Vue 3 中你可以通过 <code>propsName + update:propsName</code> 来自定义v-model</p>\n<p>也就是说：一个组件里可以定义多个<strong>v-model</strong></p>\n<pre><code>// page\n&lt;cmp v-model:foo=\"xxx\" v-model:bar=\"xxxx\" /&gt;\n\n// components\n&lt;script setup&gt; interface Props {\n    foo: string\n    bar: string\n}\n\nconst props = defineProps&lt;Props&gt;();\nconst emits = defineEmits([\"update:foo\", \"update:bar\"]); &lt;/script&gt; \n</code></pre>\n<h3><a id=\"provide__inject_201\"></a>provide 与 inject</h3>\n<p>这里需要用到 provide() 与 inject()</p>\n<p>父组件：</p>\n<pre><code>&lt;script setup&gt;\nimport { provide } from \"vue\";\n\nconst userObj = ref&lt;User&gt;(...);\n\nprovide(\"user\", userObj);\n\nconst fn = () =&gt; {\n    ...\n}\n\nprovide(\"change\", fn);\n\n&lt;/script&gt; \n</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;script setup&gt;\nimport { inject } from \"vue\";\n\nconst injectUserObj = inject(\"user\");\n\nconst injectFn = inject(\"change\");\n&lt;/script&gt; \n</code></pre>\n<h2><a id=\"_236\"></a>总结</h2>\n<p>目前笔者整理的就这么多，我自己在开发组件的过程中常用到的目前也就这些知识点</p>\n<p>当然还有函数式组件相关的写法，这个可能大部分人不常会用到，组件库考虑到动态性或许会选择</p>\n<p>不过我们做业务组件时我还是建议大家使用单文件组件</p>\n<p>维护性还是高了不少的</p>\n<p>喜欢的就点赞收藏起来吧~</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-20 22:13:03", "summary": "目录自定义组件，我们一般需要实现这几个点：定义属性定义事件插槽定义组件可供外部访问的内容自定义组件实现双向数据绑定与为什么使用？刚开始尝试的时候用的组合式都是这样的写法乍一看感觉不如原来的啊，什么逻辑"}