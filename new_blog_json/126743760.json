{"blogid": "126743760", "writerAge": "码龄14年", "writerBlogNum": "150", "writerCollect": "480", "writerComment": "78", "writerFan": "145", "writerGrade": "5级", "writerIntegral": "2814", "writerName": "v3u.cn", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743760.jpg", "writerRankTotal": "7142", "writerRankWeekly": "6699", "writerThumb": "106", "writerVisitNum": "142780", "blog_read_count": "13", "blog_time": "于 2022-09-07 13:24:17 发布", "blog_title": "延宕执行,妙用无穷,Go lang1.18入门精炼教程,由白丁入鸿儒,Golang中defer关键字延迟调用机制使用EP17", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>先行定义，延后执行。不得不佩服Go lang设计者天才的设计，事实上，defer关键字就相当于Python中的try{ …}except{ …}finally{…}结构设计中的finally语法块，函数结束时强制执行的代码逻辑，但是defer在语法结构上更加优雅，在函数退出前统一执行，可以随时增加defer语句，多用于系统资源的释放以及相关善后工作。当然了，这种流程结构是必须的，形式上可以不同，但底层原理是类似的，Golang 选择了更简约的defer，避免多级嵌套的try except finally 结构。</p>\n<h2><a id=\"_4\"></a>使用场景</h2>\n<p>操作系统资源在业务上避免不了的，比方说单例对象的使用权、文件读写、数据库读写、锁的获取和释放等等，这些资源需要在使用完之后释放掉或者销毁，如果忘记释放、资源会常驻内存，长此以往就会造成内存泄漏的问题。但是人非圣贤，孰能无过？因此研发者在撰写业务的时候有几率忘记关闭这些资源。</p>\n<p>Golang中defer关键字的优势在于，在打开资源语句的下一行，就可以直接用defer语句来注册函数结束后执行关闭资源的操作。说白了就是给程序逻辑“上闹钟”，定义好逻辑结束时需要关闭什么资源，如此，就降低了忘记关闭资源的概率：</p>\n<pre><code>package main  \n  \nimport (  \n\t\"fmt\"  \n\t\"github.com/jinzhu/gorm\"  \n\t_ \"github.com/jinzhu/gorm/dialects/mysql\"  \n)  \n  \nfunc main() {  \n\tdb, err := gorm.Open(\"mysql\", \"root:root@(localhost)/mytest?charset=utf8mb4&amp;parseTime=True&amp;loc=Local\")  \n  \n\tif err != nil {  \n                fmt.Println(err)  \n       \t\tfmt.Println(\"连接数据库出错\")  \n\t\treturn  \n\t}  \n  \n\tdefer db.Close()  \n        fmt.Println(\"链接Mysql成功\")  \n  \n}\n</code></pre>\n<p>这里通过gorm获取数据库指针变量后，在业务开始之前就使用defer定义好数据库链接的关闭，在main函数执行完毕之前，执行db.Close()方法，所以打印语句是在defer之前执行的。</p>\n<p>所以需要注意的是，defer最好在业务前面定义，如果在业务后面定义：</p>\n<pre><code>fmt.Println(\"链接Mysql成功\")  \ndefer db.Close()\n</code></pre>\n<p>这样写就是画蛇添足了，因为本来就是结束前执行，这里再加个defer关键字的意义就不大了，反而会在编译的时候增加程序的判断逻辑，得不偿失。</p>\n<h2><a id=\"defer_46\"></a>defer执行顺序问题</h2>\n<p>Golang并不会限制defer关键字的数量，一个函数中允许多个“延迟任务”：</p>\n<pre><code>package main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n\tdefer func1()  \n\tdefer func2()  \n\tdefer func3()  \n}  \n  \nfunc func1() {  \n\tfmt.Println(\"任务1\")  \n}  \n  \nfunc func2() {  \n\tfmt.Println(\"任务2\")  \n}  \n  \nfunc func3() {  \n\tfmt.Println(\"任务3\")  \n}\n</code></pre>\n<p>程序返回：</p>\n<pre><code>任务3  \n任务2  \n任务1\n</code></pre>\n<p>我们可以看到，多个defer的执行顺序其实是“反”着的，先定义的后执行，后定义的先执行，为什么？因为defer的执行逻辑其实是一种“压栈”行为：</p>\n<pre><code>package main  \n  \nimport (  \n\t\"fmt\"  \n\t\"sync\"  \n)  \n  \n// Item the type of the stack  \ntype Item interface{}  \n  \n// ItemStack the stack of Items  \ntype ItemStack struct {  \n\titems []Item  \n\tlock  sync.RWMutex  \n}  \n  \n// New creates a new ItemStack  \nfunc NewStack() *ItemStack {  \n\ts := &amp;ItemStack{}  \n\ts.items = []Item{}  \n\treturn s  \n}  \n  \n// Pirnt prints all the elements  \nfunc (s *ItemStack) Print() {  \n\tfmt.Println(s.items)  \n}  \n  \n// Push adds an Item to the top of the stack  \nfunc (s *ItemStack) Push(t Item) {  \n\ts.lock.Lock()  \n\ts.lock.Unlock()  \n\ts.items = append(s.items, t)  \n}  \n  \n// Pop removes an Item from the top of the stack  \nfunc (s *ItemStack) Pop() Item {  \n\ts.lock.Lock()  \n\tdefer s.lock.Unlock()  \n\tif len(s.items) == 0 {  \n\t\treturn nil  \n\t}  \n\titem := s.items[len(s.items)-1]  \n\ts.items = s.items[0 : len(s.items)-1]  \n\treturn item  \n}\n</code></pre>\n<p>这里我们使用切片和结构体实现了栈的数据结构，当元素入栈的时候，会进入栈底，后进的会把先进的压住，出栈则是后进的先出：</p>\n<pre><code>func main() {  \n  \n\tvar stack *ItemStack  \n\tstack = NewStack()  \n\tstack.Push(\"任务1\")  \n\tstack.Push(\"任务2\")  \n\tstack.Push(\"任务3\")  \n\tfmt.Println(stack.Pop())  \n\tfmt.Println(stack.Pop())  \n\tfmt.Println(stack.Pop())  \n  \n}\n</code></pre>\n<p>程序返回：</p>\n<pre><code>任务3  \n任务2  \n任务1\n</code></pre>\n<p>所以，在defer执行顺序中，业务上需要先执行的一定要后定义，而业务上后执行的一定要先定义。</p>\n<p>除此以外，就是与其他执行关键字的执行顺序问题，比方说return关键字：</p>\n<pre><code>package main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n\ttest()  \n}  \n  \nfunc test() string {  \n\tdefer fmt.Println(\"延时任务执行\")  \n\treturn testRet()  \n}  \n  \nfunc testRet() string {  \n\tfmt.Println(\"返回值函数执行\")  \n\treturn \"\"  \n}\n</code></pre>\n<p>程序返回：</p>\n<pre><code>返回值函数执行  \n延时任务执行\n</code></pre>\n<p>一般情况下，我们会认为return就是结束逻辑，所以return逻辑应该会最后执行，但实际上defer会在retrun后面执行，所以defer中的逻辑如果依赖return中的执行结果，那么就绝对不能使用defer关键字。</p>\n<h2><a id=\"_192\"></a>业务与特性结合</h2>\n<p>我们知道，有些内置关键字不仅仅具备表层含义，如果了解其特性，是可以参与业务逻辑的，比如说Python中的try{ …}except{ …}finally{…}结构，表面上是捕获异常，输出异常，其实可以利用其特性搭配唯一索引，就可以直接完成排重业务，从而减少一次磁盘的IO操作。</p>\n<p>defer也如此，假设我们要在同一个函数中打开不同的文件进行操作：</p>\n<pre><code>package main  \n  \nimport (  \n\t\"os\"  \n)  \n  \nfunc mergeFile() error {  \n  \n\tf1, _ := os.Open(\"file1.txt\")  \n\tif f1 != nil {  \n  \n\t\t//操作文件  \n\t\tf1.Close()  \n\t}  \n  \n\tf2, _ := os.Open(\"file2.txt\")  \n\tif f2 != nil {  \n  \n\t\t//操作文件  \n\t\tf2.Close()  \n\t}  \n  \n\treturn nil  \n}  \n  \nfunc main(){  \nmergeFile()  \n}\n</code></pre>\n<p>所以理论上，需要两个文件句柄对象，分别打开不同的文件，然后同步执行。</p>\n<p>但让defer关键字参与进来：</p>\n<pre><code>package main  \n  \nimport (  \n\t\"fmt\"  \n\t\"io\"  \n\t\"os\"  \n)  \n  \nfunc mergeFile() error {  \n  \n\tf, _ := os.Open(\"file1.txt\")  \n\tif f != nil {  \n\t\tdefer func(f io.Closer) {  \n\t\t\tif err := f.Close(); err != nil {  \n\t\t\t\tfmt.Printf(\"文件1关闭 err %v\\n\", err)  \n\t\t\t}  \n\t\t}(f)  \n\t}  \n  \n\tf, _ = os.Open(\"file2.txt\")  \n\tif f != nil {  \n\t\tdefer func(f io.Closer) {  \n\t\t\tif err := f.Close(); err != nil {  \n\t\t\t\tfmt.Printf(\"文件2关闭 err err %v\\n\", err)  \n\t\t\t}  \n\t\t}(f)  \n\t}  \n  \n\treturn nil  \n}  \n  \nfunc main() {  \n  \n\tmergeFile()  \n}\n</code></pre>\n<p>这里就用到了defer的特性，defer函数定义的时候，句柄参数就已经复制进去了，随后，真正执行close()函数的时候就刚好关闭的是对应的文件了，如此，同一个句柄对不同文件进行了复用，我们就节省了一次内存空间的分配。</p>\n<h2><a id=\"defer_274\"></a>defer一定会执行吗</h2>\n<p>我们知道Python中的try{ …}except{ …}finally{…}结构，finally仅仅是理论上会执行，一旦遇到特殊情况：</p>\n<pre><code>from peewee import MySQLDatabase  \n  \nclass Db:  \n  \n    def __init__(self):  \n  \n        self.db = MySQLDatabase('mytest', user='root', password='root',host='localhost', port=3306)  \n  \n    def __enter__(self):  \n        print(\"connect\")  \n        self.db.connect()  \n        exit(-1)  \n  \n    def __exit__(self,*args):  \n        print(\"close\")  \n        self.db.close()  \n  \nwith Db() as db:  \n    print(\"db is opening\")\n</code></pre>\n<p>程序返回：</p>\n<pre><code>connect\n</code></pre>\n<p>并未执行print(“db is opening”)逻辑，是因为在__enter__方法中就已经结束了（exit(-1)）</p>\n<p>而defer同理：</p>\n<pre><code>package main  \n  \nimport (  \n\t\"fmt\"  \n\t\"os\"  \n)  \n  \nfunc main() {  \n\tdefer func() {  \n\t\tfmt.Printf(\"延后执行\")  \n\t}()  \n\tos.Exit(1)  \n}\n</code></pre>\n<p>这里和Python一样，同样调用os包中的Exit函数，程序返回：</p>\n<pre><code>exit status 1\n</code></pre>\n<p>延迟方法并未执行，所以defer并非一定会执行。</p>\n<h2><a id=\"_335\"></a>结语</h2>\n<p>defer关键字是极其天才的设计，业务简单的情况下不会有什么问题。但也需要深入理解defer的特性以及和其他内置关键字的关系，才能发挥它最大的威力，著名语言C#最新版本支持了 using无括号的形式，默认当前块结束时释放资源，这也算是对defer关键字的一种致敬罢。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 1, "python": 1, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-09-07 13:24:17", "summary": "先行定义，延后执行。不得不佩服设计者天才的设计，事实上，关键字就相当于中的结构设计中的语法块，函数结束时强制执行的代码逻辑，但是在语法结构上更加优雅，在函数退出前统一执行，可以随时增加语句，多用于系统"}