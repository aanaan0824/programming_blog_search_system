{"blogid": "125231552", "writerAge": "码龄1年", "writerBlogNum": "4", "writerCollect": "2", "writerComment": "0", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "42", "writerName": "X1iaoXu666", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125231552.jpg", "writerRankTotal": "165961", "writerRankWeekly": "353782", "writerThumb": "1", "writerVisitNum": "2558", "blog_read_count": "761", "blog_time": "于 2022-06-11 14:14:45 发布", "blog_title": "Unity——InputSystem入门及部分问题讲解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>距离Unity发布InputSystem已经过去了一段时间了，很多人可能都有所耳闻这个新的输入系统，也有人去下载过使用过，结果发现这个新的输入系统还没老板的好用，于是就放弃使用了。说实话，这个新的输入系统我刚开始使用的时候也觉得操作十分繁琐，一点儿也不好用。但是随着我去看了油管上讲解这个视频之后我发现不是不好用，而是不太会用。</p>\n<p>我现在虽然使用InputSystem并没很久，但是先来说一下我认为InputSystem的优势，当我们开发输入方式比较少的软件的时候，的确使用老板的InputManager会方便一点，但是一旦输入方式增多，例如需要手柄，摇杆，键盘，鼠标，触屏等等，当一个软件要同时拥有很多输入方式的时候，使用InputSystem会非常方便，因为他不需要去修改输入判定的代码，只需要挂在相关逻辑就行了。而且其实新版的InputSystem也可以实现老板的功能，并不一定要用新版方式，下面是我自己做的案例。</p>\n<p>首先我们先下载InputSystem，这里从Window——PackManager<img alt=\"\" height=\"568\" src=\"..\\..\\static\\image\\900e62c4246241dba8a4f4ba4ab48f45.png\" width=\"814\"/></p>\n<p>如果没有找请把划线处调整为Unity Registry。</p>\n<p>导入之后会有一个弹窗，上面选启用那个就好了，这就是让你换成新的输入系统，老板的将不能使用了。如果想调整回来就在Editor——ProjectSetting——Player——OtherSetting——ActiveInputHandel中换成Both或者Old。<img alt=\"\" height=\"53\" src=\"..\\..\\static\\image\\c744aaf712af4ba0b9ad77b0f28b71f7.png\" width=\"895\"/></p>\n<p> 导入完成之后就开始我们的正题了，先反键点击一个文件夹，选择Creat创建，创建一个InputAction并打开他。<img alt=\"\" height=\"871\" src=\"..\\..\\static\\image\\3d6b26de11e04752a41b40fd33e999f3.png\" width=\"1097\"/></p>\n<p> </p>\n<p>这里就会出来一个这样的界面。</p>\n<p>ActionMap就如字面意思行动地图，里面可以创建很多东西，便于玩家分类。例如PlayerInput就是玩家输入，UI就是UI输入。</p>\n<p>Action就是具体的行动输入了。我们先创建一个PlayerInput——Jump<img alt=\"\" height=\"359\" src=\"..\\..\\static\\image\\aca45df10d7d4a6e8e427e8c5228eded.png\" width=\"1086\"/></p>\n<p>众所周知，跳远应该是一个按钮，一般按下跳远键返回的是一个布尔值，所以我们ActionType中选择Button。</p>\n<p>这里说一下ActionType中的另外几种Value他的返回值是一个很广泛的值，这个可以自己设置，当你选择了Value之后下面就会出现很多属性，后面我会再讲到。PassThrough这个其实和Value差不多，但是你不输入之后他会返回一个初始值，这个我也没有研究很透彻。大部分情况我都会使用Value。</p>\n<p> 选好了Button之后点击下面的&lt;No Binding&gt;，这里点击Path。上面有很多种输入<img alt=\"\" height=\"393\" src=\"..\\..\\static\\image\\8fc1a7579fd44560b6421e2e9f49c840.png\" width=\"532\"/></p>\n<p>如果大家不知道需要哪种的时候，点击旁边那个Listen，然后在点击需要的那个按键，他就会出现那个按键的绑定选项。如果没有那就是你设置的情况不适合此输入。这里我们跳跃绑定一个键盘的空格，到这里就设置好了，点击右上方SaveAsset保存一下。（最好不要选择AutoSave）</p>\n<p>这里InputAction的使用方法有两种方式，我这里只讲我觉得更好的一种，也是更合适程序员的一种方式，点击我们保存之后的InputAction。（用其他方式的小伙伴注意了，按一个按键会打印很多次的原因是因为检查一个按键的输入分为三个检测点，Start，Performed和Cancel，所以才会打印多次）</p>\n<p><img alt=\"\" height=\"445\" src=\"..\\..\\static\\image\\fb68ca04fc3a48ab809b118431a1ce4d.png\" width=\"283\"/></p>\n<p> 这里会有这样一个选项，勾选之后就会自动生成C#脚本，这就是为什么上面不要选择AutoSave的原因，不然你一边修改它一边保存会很令人头疼。</p>\n<p>生成了这个脚本之后你就可以在脚本中实例化了。这里要注意的位置：</p>\n<p>声明的脚本要new（），而不是GetComComponent，声明完之后要启用，示例：</p>\n<p><img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\b4bef9e296bf499eb18d02b49a81e1db.png\" width=\"611\"/></p>\n<p>我这里写了一个相机的移动，我认为这是输入中比较有代表性的，相机的移动和旋转均不是是一个按钮，而是要返回一个三维向量Vector3和一个二维向量Vector2。所以我选择的为Value，下面选择的是Vector3与Vector2。像这样：<img alt=\"\" height=\"394\" src=\"..\\..\\static\\image\\f32ab9845c0a4cf78fbd7d39b6bd0c51.png\" width=\"1089\"/></p>\n<p><img alt=\"\" height=\"261\" src=\"..\\..\\static\\image\\9816a9d3b6f14f84b7af0c613d7cb951.png\" width=\"1088\"/> 这里旋转是控制鼠标的X，Y轴偏移，我试了里面的选项，Delta应该对应着Input.GetAxis。相机移动的代码如下：</p>\n<pre><code class=\"language-cs\">    private void Update()\n    {\n        #region 新输入系统移动\n        Vector2 v2 = inputs.Camera.Rotate.ReadValue&lt;Vector2&gt;();//Rotate绑定返回的Vector2向量\n        Vector3 v3 = inputs.Camera.Move.ReadValue&lt;Vector3&gt;();//Move绑定返回的Vector3向量\n        if (Mouse.current.rightButton.ReadValue() == 1)//这里相当于老板输入法Input.GetMouseButton(1)，按住鼠标右键，新版输入法感觉语法上更详细了\n        {\n            //以下就是关于移动相机功能代码没什么要讲的\n            Cursor.lockState = CursorLockMode.Locked;\n            transform.Translate((Keyboard.current.leftShiftKey.ReadValue() == 1/* 这里是一样类似于老板的Input.GetKey(\"left shift\")*/ ? fastSpeed : speed) * v3 * Time.deltaTime, Space.Self);\n            transform.RotateAround(transform.position, Vector3.up, v2.x * 0.1f);\n            transform.RotateAround(transform.position, transform.right, -v2.y * 0.1f);\n        }\n        else\n            Cursor.lockState = CursorLockMode.None;\n        #endregion\n \n    }</code></pre>\n<p> 其实新版的输入系统没想象中那么难用，熟练使用之后，复杂项目你会发现他的强大。</p>\n<p></p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p></p>\n<p> </p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-11 14:14:45", "summary": "距离发布已经过去了一段时间了，很多人可能都有所耳闻这个新的输入系统，也有人去下载过使用过，结果发现这个新的输入系统还没老板的好用，于是就放弃使用了。说实话，这个新的输入系统我刚开始使用的时候也觉得操作"}