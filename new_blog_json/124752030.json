{"blogid": "124752030", "writerAge": "码龄1年", "writerBlogNum": "40", "writerCollect": "100", "writerComment": "1", "writerFan": "12", "writerGrade": "3级", "writerIntegral": "444", "writerName": "XXXxxx光", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124752030.jpg", "writerRankTotal": "37633", "writerRankWeekly": "215853", "writerThumb": "41", "writerVisitNum": "22481", "blog_read_count": "3084", "blog_time": "于 2022-05-13 14:58:34 发布", "blog_title": "JS中的this指向", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h4><a id=\"this_0\"></a>this的概念：</h4>\n<ol><li> <p>在js中，this的意思为“这个;当前”，<strong>是一个指针型变量，它动态指向当前函数的运行环境。</strong></p> </li><li> <p>在不同的场景中调用同一个函数，this的指向也可能会发生变化，但是它永远指向其所在函数的真实调用者；如果没有调用者，就指向全局对象window。</p> </li></ol>\n<blockquote>\n<h6><a id=\"thiswindow_6\"></a>普通函数：关于this，谁调用就指向谁，没有调用者，就指向全局对象window。</h6>\n<h6><a id=\"this_7\"></a>箭头函数：箭头函数的this指向于函数作用域所用的对象。</h6>\n</blockquote>\n<h4><a id=\"this_9\"></a>一、全局环境下的this指向</h4>\n<blockquote>\n<h6><a id=\"httpssocsdnnetsosearchqE4BD9CE794A8E59F9Fspm1001210130017020thiswindow_11\"></a>在全局<a href=\"https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;spm=1001.2101.3001.7020\">作用域</a>下，this始终指向全局对象window，无论是否是严格模式！</h6>\n</blockquote>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\d9dde27560c1b6c982b1a7894a148551.png\"/></p>\n<p><code>congsole.log()</code>完整的写法是<code>window.console.log(),window</code>可以省略，<em>window</em>调用了<code>console.log()</code>方法，所以此时this指向window。</p>\n<h4><a id=\"this_17\"></a>二、函数内的this</h4>\n<ul><li>普通函数内的this分为两种情况，严格模式下和非严格模式下。</li></ul>\n<h5><a id=\"1__21\"></a><strong>1. 严格模式下：</strong></h5>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\8ba49481002c498e75a28c6f627794e4.png\"/></p>\n<p>直接test()调用函数,this指向undefined，<code>window.test()</code>调用函数this指向window。因此，在<strong>严格模式下</strong>， 我们对代码的的调用必须严格的<strong>写出被调用的函数的对象</strong>，不可以有省略或者说简写。</p>\n<h5><a id=\"2__27\"></a><strong>2. 非严格模式下：</strong></h5>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\456fe7b204beb334b8400c0ab2fc7e49.png\"/></p>\n<p>非严格模式下，通过test()和<code>window.test()</code>调用函数对象，this都指向window。</p>\n<h4><a id=\"this_33\"></a>三、对象中的this</h4>\n<blockquote>\n<h6><a id=\"this_35\"></a>对象内部方法的this指向调用这些方法的对象，也就是<strong>谁调用就指向谁</strong>。</h6>\n</blockquote>\n<p><strong>1. 一层对象：</strong></p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\d9ea2b41d29f06130fe55a4bd71a907f.png\"/></p>\n<p>调用<code>obj.skill()</code>方法，返回值为<em>蒙犽</em>，说明此时this指向obj。</p>\n<p><strong>2. 二层对象：</strong></p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\fec4b67ed934bd3b0b4e702c6e390e35.png\"/></p>\n<p>调用skill2()方法的顺序为，<code>obj.obj2.skill2()</code> ,返回值为<em>鲁班</em>，说明<code>skill2()</code>方法中的this指向obj2。</p>\n<p><strong>总结：</strong></p>\n<ol><li> <p>函数的定义位置不影响其this指向，<strong>this指向只和调用函数的对象有关</strong>。</p> </li><li> <p>多层嵌套的对象，<strong>内部方法的this指向离被调用函数最近的对象</strong>。</p> </li></ol>\n<h4><a id=\"httpssocsdnnetsosearchqE7AEADE5A4B4E587BDE695B0spm1001210130017020this_55\"></a>四、<a href=\"https://so.csdn.net/so/search?q=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020\">箭头函数</a>中的this</h4>\n<blockquote>\n<h6><a id=\"this_57\"></a>箭头函数：this指向于函数作用域所用的对象。</h6>\n</blockquote>\n<ul><li> <p>箭头函数的<strong>重要特征</strong>：<strong>箭头函数中没有this和arguments，是真的没有！</strong></p> </li><li> <p>箭头函数没有自己的this指向，它会捕获自己<strong>定义</strong>所处的<strong>外层执行环境</strong>，并且继承这个this值,<strong>指向当前定义时所在的对象</strong>。箭头函数的this指向在被定义的时候就确定了，之后<strong>永远都不会改变。即使使用<code>call()</code>、<code>apply()</code>、<code>bind()</code>等方法改变this指向也不可以。</strong></p> </li></ul>\n<p><strong>例子1：</strong></p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\eacb2beb65f200fb3a17d38a34ac556d.png\"/></p>\n<ul><li>声明的是全局变量Obj，this指向箭头函数所在全局作用域的对象，即indow对象。</li></ul>\n<p><strong>例子2：</strong></p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\495789f4cd08f75e7496c91215f12e0a.png\"/></p>\n<ol><li> <p>由于show函数是箭头函数，所以自身不能绑定this，因此找它的上一级作用域。如果父级作用域还是箭头函数，就再往上找，一层一层的直到直到this的指向。</p> </li><li> <p><code>window.show()</code>返回值是window，所以this此时指向window；</p> </li><li> <p><code>window.obj.show(),obj</code>是对象，非箭头函数，所以找到这里就停止了，this绑定到obj上。<strong>window调用obj，所以obj中的this也指向window。</strong></p> </li></ol>\n<h4><a id=\"httpssocsdnnetsosearchqE69E84E980A0E587BDE695B0spm1001210130017020this_79\"></a>五、<a href=\"https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020\">构造函数</a>中的this</h4>\n<blockquote>\n<h6><a id=\"this_81\"></a>构造函数中的this是指向实例。</h6>\n</blockquote>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\edaa8a2c0710178305107fa020d20743.png\"/></p>\n<p>由上图可以看出，<strong>构造函数中的this指向构造函数下创建的实例</strong>。</p>\n<h4><a id=\"this_87\"></a><strong>六</strong>、原型链中的this</h4>\n<blockquote>\n<h6><a id=\"this_89\"></a>this这个值在一个继承机制中，仍然是<strong>指向它原本属于的对象</strong>，而不是从原型链上找到它时，它所属于的对象。</h6>\n</blockquote>\n<h4><a id=\"this_91\"></a>七、改变this指向的方法</h4>\n<h5><a id=\"1_call_93\"></a>1. call()</h5>\n<ul><li><code>call（a, b, c）</code>方法接收三个参数，第一个是this指向，第二个，三个是传递给函数的实参，可以是数字，字符串，数组等类型的数据类型都可以。</li></ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">//定义函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n1<span class=\"token punctuation\">,</span>n2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>n1<span class=\"token punctuation\">,</span>n2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//调用call()方法</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//=&gt;this:window;</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token literal-property property\">fn</span><span class=\"token operator\">:</span>fn<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//=&gt;this:obj;n1,n2:undefined</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//=&gt;this: 1;n1=2,n2=undefined;</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//=&gt;this: obj;n1=1,n2=2;</span>\n\n<span class=\"token comment\">//Call方法的几个特殊属性</span>\n<span class=\"token comment\">//非严格模式下</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//this=&gt;window</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//this=&gt;window</span>\n<span class=\"token comment\">//严格模式下</span>\n<span class=\"token string\">\"use strict\"</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//this=&gt;undefined</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//this=&gt;null</span>\n</code></pre>\n<h5><a id=\"2_apply_122\"></a>2. apply()</h5>\n<ul><li> <p><code>apply(a, [b])</code>和call基本上一致，<strong>唯一区别在于传参方式</strong>，apply把需要传递给<code>fn()</code>的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给<code>fn()</code>一个个的传递。</p> </li><li> <pre><code class=\"prism language-javascript\"><span class=\"token comment\">//call()的传参方式</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//apply()的传参方式</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre> </li></ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"prism language-javascript\"><span class=\"token comment\">//apply方法的使用和call方法基本相同，唯一的区别是，apply方法传参要求是数组类型的，数组内可以任意形式的数据</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n1<span class=\"token punctuation\">,</span>n2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>n1<span class=\"token punctuation\">,</span>n2<span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token literal-property property\">fn</span><span class=\"token operator\">:</span>fn<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//调用apply()方法</span>\nfn<span class=\"token punctuation\">.</span><span class=\"token function\">applay</span><span class=\"token punctuation\">(</span>abj<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfn<span class=\"token punctuation\">.</span><span class=\"token function\">applay</span><span class=\"token punctuation\">(</span>abj<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>；<span class=\"token comment\">//报错</span>\n\nfn<span class=\"token punctuation\">.</span><span class=\"token function\">applay</span><span class=\"token punctuation\">(</span>abj<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token string\">'apply'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span><span class=\"token number\">123</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//注意第二个参数必须是数组，否则会报错</span>\n</code></pre>\n<h5><a id=\"3_bind_150\"></a>3. bind()</h5>\n<ul><li> <p><code>bind（a, b, c）</code>：语法和call一模一样，区别在于立即执行还是等待执行，bind不兼容IE6~8</p> </li><li> <p>bind与call的<strong>唯一区别</strong>就是call直接改变函数test的指向，而<strong>bind</strong>是<strong>生成了一个新函数</strong><code>test2()</code>，该函数改变了指向。</p> </li><li> <pre><code class=\"prism language-javascript\"><span class=\"token comment\">//call()方法：改变fn中的this，并且把fn立即执行</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">//bind()方法：改变fn中的this，fn并不执行</span>\n<span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n</code></pre> </li></ul>\n<p><strong>示例：</strong></p>\n<pre><code>//bind和call方法调用形式类似，但是原理完全不同\nfn.call(obj,10,20);//=&gt;fn先执行，将fn内的this指向obj，并且把参数10,20传递给fn\n\nfn.bind(obj,10,20)//bind是先将fn中的this指向obj，并且将参数10,20预先传递给fn，但是此时的fn并没有被执行，只有fn执行时this指向和传递参数才有作用\nfn.bind(obj,10,20);//=&gt;不会有任何输出\nfn.bind(obj,10,20)();//=&gt;调用后才会有输出\n\n//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向obj\noBox.onclick=fn; //=&gt;点击的时候执行了fn,但此时fn中的this是oBox\n\noBox.onclick=fn.call(opp); //=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件\n\noBox.onclick=fn.bind(opp);\n//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个/* \n * function(){\n *     fn.call(opp);\n * }\n */\noBox.onclick=function(){\n   //=&gt;this:oBox\n    fn.call(opp);\n}\n</code></pre>\n<blockquote>\n<p><strong>相同点：</strong></p>\n<ul><li>call、apply和bind都是JS函数的公有的内部方法，他们都是重置函数的this，改变函数的执行环节。</li></ul>\n<p><strong>不同点：</strong></p>\n<ul><li>bind是创建一个新的函数，而call和aplay是用来调用函数；</li><li>call和apply作用一样，只不过call为函数提供的参数是一个个地罗列出来，而apply为函数提供的参数是一个数组</li></ul>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-05-13 14:58:34", "summary": "的概念：在中，的意思为这个当前，是一个指针型变量，它动态指向当前函数的运行环境。在不同的场景中调用同一个函数，的指向也可能会发生变化，但是它永远指向其所在函数的真实调用者；如果没有调用者，就指向全局对"}