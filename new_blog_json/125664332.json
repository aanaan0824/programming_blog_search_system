{"blogid": "125664332", "writerAge": "码龄180天", "writerBlogNum": "53", "writerCollect": "685", "writerComment": "1430", "writerFan": "2258", "writerGrade": "5级", "writerIntegral": "2939", "writerName": "旧梦拾遗186", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125664332.jpg", "writerRankTotal": "6256", "writerRankWeekly": "204", "writerThumb": "948", "writerVisitNum": "98392", "blog_read_count": "4511", "blog_time": "已于 2022-07-11 17:41:27 修改", "blog_title": "字符串函数---其他类型的函数（strstr，strtok，strerror函数和字符分类函数字符转换函数）努力积累才能进大厂拿offer", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>作者：<a class=\"link-info\" href=\"https://blog.csdn.net/weixin_67900732?type=blog\" title=\"旧梦拾遗\">旧梦拾遗</a></p>\n<p>专栏：<a class=\"link-info\" href=\"https://blog.csdn.net/weixin_67900732/category_11777359.html?spm=1001.2014.3001.5482\" title=\"C语言编程----小比特成长日记\">C语言编程----小比特成长日记</a></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\a32adc6b6d2649d4bb1db95ced67424c.png\"/></p>\n<p></p>\n</blockquote>\n<p>每日励志：</p>\n<blockquote>\n<p>不想认命，就去拼命，我始终相信，付出就会有收获，或大或小，或迟或早，始终不会辜负你的努力。有一种落差是，你总是羡慕别人的成功，自己却不敢开始。</p>\n</blockquote>\n<p>前言：</p>\n<blockquote>\n<p>上篇我们学到了，不受长度受限制的字符串函数----<a href=\"https://blog.csdn.net/weixin_67900732/article/details/125651264#1.strncpy%EF%BC%9A\" title=\"strncpy\">strncpy</a>，<a href=\"https://blog.csdn.net/weixin_67900732/article/details/125651264#2.strncat%E5%87%BD%E6%95%B0%EF%BC%9A\" title=\"strnca\">strnca</a>t，<a href=\"https://blog.csdn.net/weixin_67900732/article/details/125651264#%C2%A03.strncmp%E5%87%BD%E6%95%B0%EF%BC%9A\" title=\"strncmp\">strncmp</a>，今天小编讲一些其它类型的函数---strstr，strtok，strerror函数和字符分类函数字符转换函数。</p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E4%B8%80.strstr%E5%87%BD%E6%95%B0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0%EF%BC%9A-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.strstr%E5%87%BD%E6%95%B0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.strstr%E5%87%BD%E6%95%B0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0%EF%BC%9A\">一.strstr函数子字符串查找函数：</a></p>\n<p id=\"1.%E5%8A%9F%E8%83%BD%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%8A%9F%E8%83%BD%EF%BC%9A\">1.功能：</a></p>\n<p id=\"%C2%A02.%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A\"> 2.函数自身的实现方法：</a></p>\n<p id=\"a%EF%BC%89%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%8C%B9%E9%85%8D%E5%B0%B1%E8%83%BD%E6%89%BE%E5%88%B0-toc\" style=\"margin-left:80px;\"><a href=\"#a%EF%BC%89%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%8C%B9%E9%85%8D%E5%B0%B1%E8%83%BD%E6%89%BE%E5%88%B0\">a）源字符串能够在目标字符串中一次匹配就能找到</a></p>\n<p id=\"b%EF%BC%89%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%A4%9A%E6%AC%A1%E5%8C%B9%E9%85%8D%E6%89%8D%E8%83%BD%E6%88%90%E5%8A%9F-toc\" style=\"margin-left:80px;\"><a href=\"#b%EF%BC%89%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%A4%9A%E6%AC%A1%E5%8C%B9%E9%85%8D%E6%89%8D%E8%83%BD%E6%88%90%E5%8A%9F\">b）源字符串多次匹配才能成功</a></p>\n<p id=\"3.%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A\">3.函数的模拟实现：</a></p>\n<p id=\"%C2%A0%E6%80%9D%E8%B7%AF%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E6%80%9D%E8%B7%AF%EF%BC%9A\"> 思路：</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%EF%BC%9A\">代码：</a></p>\n<p id=\"%E7%BB%93%E6%9E%9C%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BB%93%E6%9E%9C%EF%BC%9A\">结果：</a></p>\n<p id=\"%C2%A0%E4%BA%8C.strtok%E5%88%87%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%BA%8C.strtok%E5%88%87%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%9A\"> 二.strtok切割字符串函数：</a></p>\n<p id=\"1.%E5%8A%9F%E8%83%BD%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%8A%9F%E8%83%BD%EF%BC%9A\">1.功能：</a></p>\n<p id=\"2.%20%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E4%BB%A3%E7%A0%81%EF%BC%9A\">2. 代码：</a></p>\n<p id=\"3.%E7%BB%93%E6%9E%9C%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E7%BB%93%E6%9E%9C%EF%BC%9A\">3.结果：</a></p>\n<p id=\"%C2%A04.%E6%A8%A1%E6%8B%9Fstrtok%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A04.%E6%A8%A1%E6%8B%9Fstrtok%EF%BC%9A\"> 4.模拟strtok：</a></p>\n<p id=\"a%EF%BC%89%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#a%EF%BC%89%E4%BB%A3%E7%A0%81%EF%BC%9A\">a）代码：</a></p>\n<p id=\"b%EF%BC%89%E7%BB%93%E6%9E%9C%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#b%EF%BC%89%E7%BB%93%E6%9E%9C%EF%BC%9A\">b）结果：</a></p>\n<p id=\"%E4%B8%89.strerror%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E5%87%BD%E6%95%B0%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.strerror%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E5%87%BD%E6%95%B0%EF%BC%9A\">三.strerror错误报告函数：</a></p>\n<p id=\"1.%E5%8A%9F%E8%83%BD%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%8A%9F%E8%83%BD%EF%BC%9A\">1.功能：</a></p>\n<p id=\"2.%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E4%BB%A3%E7%A0%81%EF%BC%9A\">2.代码：</a></p>\n<p id=\"a%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#a%EF%BC%89\">a）</a></p>\n<p id=\"%C2%A0b%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0b%EF%BC%89\"> b）</a></p>\n<p id=\"%C2%A0%E5%9B%9B.%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%9B%9B.%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%9A\"> 四.字符分类函数：</a></p>\n<p id=\"%E4%BA%94.%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94.%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A\">五.字符转换函数：</a></p>\n<p id=\"%C2%A0%E5%85%AD%EF%BC%9A%E8%87%AA%E8%B4%9F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E4%B8%8E%E8%87%AA%E8%B4%9F%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%85%AD%EF%BC%9A%E8%87%AA%E8%B4%9F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E4%B8%8E%E8%87%AA%E8%B4%9F%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B\"> 六：自负转换函数与自负分类函数综合案例</a></p>\n<p id=\"1.%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E4%BB%A3%E7%A0%81%EF%BC%9A\">1.代码：</a></p>\n<p id=\"2.%20%E7%BB%93%E6%9E%9C%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E7%BB%93%E6%9E%9C%EF%BC%9A\">2. 结果：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80.strstr%E5%87%BD%E6%95%B0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0%EF%BC%9A\">一.strstr函数子字符串查找函数：</h1>\n<h2 id=\"1.%E5%8A%9F%E8%83%BD%EF%BC%9A\">1.功能：</h2>\n<blockquote>\n<p><img alt=\"\" height=\"176\" src=\"..\\..\\static\\image\\6d08fad6c9d04d63bef4f30d3c800233.png\" width=\"962\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%C2%A02.%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A\"> 2.函数自身的实现方法：</h2>\n<blockquote>\n<p><img alt=\"\" height=\"395\" src=\"..\\..\\static\\image\\8db35e110b8e4ea2bfa78e862f6f0f4c.png\" width=\"1200\"/></p>\n</blockquote>\n<p>这里可以大致分为两种情况讨论</p>\n<h3 id=\"a%EF%BC%89%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%8C%B9%E9%85%8D%E5%B0%B1%E8%83%BD%E6%89%BE%E5%88%B0\">a）源字符串能够在目标字符串中<span style=\"color:#fe2c24;\">一次匹配</span>就能找到</h3>\n<p>大致思路是假设指针s1指向目标字符串首地址，指针s2指向源字符串首地址，分别对指针s1和s2解引用并比较，若匹配内容不相同我们称之为<span style=\"color:#fe2c24;\">匹配失败</span>，则目标字符串指针s1，向后移动一位，<span style=\"color:#fe2c24;\">若匹配内容相同我们称之为第</span><span style=\"color:#956fe7;\">n次匹配</span>，则指针s1和s2，分别后移，直到目标指针s2指向字符'\\0'，结束例如。</p>\n<p><span style=\"color:#fe2c24;\">注意：（若s2指针指向字符串首地址的内容和s1指向的字符串地址的内容相同，我们称之为第</span></p>\n<p><span style=\"color:#fe2c24;\">n次匹配）</span></p>\n<blockquote>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[] = \"cbbac\";\n\n\tchar* ch=strstr(arr1, \"bba\");\n\tprintf(\"%s\", ch);\n\treturn 0;\n\n}</code></pre>\n</blockquote>\n<blockquote>\n<p><img alt=\"\" height=\"719\" src=\"..\\..\\static\\image\\f6c4b5e3b8154878ae91e3fa3356b0b3.png\" width=\"1193\"/></p>\n<p>最后函数返回第一次就能匹配成功的首地址。 </p>\n</blockquote>\n<p>结果：</p>\n<blockquote>\n<p><img alt=\"\" height=\"219\" src=\"..\\..\\static\\image\\b2ad8adce88d456a9cb675de65fc5cb9.png\" width=\"702\"/></p>\n<p></p>\n</blockquote>\n<h3 id=\"b%EF%BC%89%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%A4%9A%E6%AC%A1%E5%8C%B9%E9%85%8D%E6%89%8D%E8%83%BD%E6%88%90%E5%8A%9F\">b）源字符串多次匹配才能成功</h3>\n<p> 大致思路是假设指针s1指向目标字符串首地址，指针s2指向目标字符串首地址，分别对指针s1和s2解引用并比较，若匹配内容不相同我们称之为<span style=\"color:#fe2c24;\">匹配失败</span>，则目标字符串指针s1，向后移动一位，<span style=\"color:#fe2c24;\">若匹配内容相同我们称之为第</span><span style=\"color:#956fe7;\">n次匹配，</span><span style=\"color:#0d0016;\">假设</span><u><span style=\"color:#956fe7;\">第一次匹配</span></u><span style=\"color:#0d0016;\">成功则我们将</span><u><span style=\"color:#956fe7;\">第一次匹配</span></u><span style=\"color:#0d0016;\">中的指针s1和s2分别后移，</span><span style=\"color:#38d8f0;\">若后移后指针s1和s2指向的内容不相同，则第一次匹配失败</span><span style=\"color:#0d0016;\">，s1回到第一次匹配的首位值得下一位，s2回到首地址，</span><span style=\"color:#38d8f0;\">若此时指针s1和s2指向的内容相同</span><span style=\"color:#0d0016;\">则，</span><u><span style=\"color:#956fe7;\">开启第二次匹配</span></u><span style=\"color:#0d0016;\">，以此类推直到s2指向空，则匹配成功。</span></p>\n<p>例如：</p>\n<blockquote>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[] = \"aabba\";\n\n\tchar* ch=strstr(arr1, \"abb\");\n\tprintf(\"%s\", ch);\n\treturn 0;\n\n}</code></pre>\n</blockquote>\n<blockquote>\n<p> <img alt=\"\" height=\"817\" src=\"..\\..\\static\\image\\89cd8410c19148f99a883d5438d5823c.png\" width=\"1200\"/></p>\n<p></p>\n</blockquote>\n<blockquote>\n<p><img alt=\"\" height=\"798\" src=\"..\\..\\static\\image\\502e2fd820ed49c586073c3315846e98.png\" width=\"1200\"/>  </p>\n</blockquote>\n<blockquote>\n<p><img alt=\"\" height=\"802\" src=\"..\\..\\static\\image\\51bbbf2027654203853da256c2a185a6.png\" width=\"1200\"/>  </p>\n</blockquote>\n<p>结果：</p>\n<blockquote>\n<p><img alt=\"\" height=\"523\" src=\"..\\..\\static\\image\\8943f20d9ddf425480a375a017b55d6d.png\" width=\"775\"/></p>\n</blockquote>\n<h2 id=\"3.%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A\">3.函数的模拟实现：</h2>\n<h3 id=\"%C2%A0%E6%80%9D%E8%B7%AF%EF%BC%9A\"> 思路：</h3>\n<blockquote>\n<p></p>\n<p>1.源字符串能够在目标字符串中<span style=\"color:#fe2c24;\">一次匹配</span>就能找到</p>\n<p>大致思路是假设指针s1指向原字符串首地址，指针s2指向目标字符串首地址，分别对指针s1和s2解引用并比较，若匹配内容不相同我们称之为<span style=\"color:#fe2c24;\">匹配失败</span>，则原字符串指针s1，向后移动一位，<span style=\"color:#fe2c24;\">若匹配内容相同我们称之为第</span><span style=\"color:#956fe7;\">n次匹配，</span><span style=\"color:#0d0016;\">假设</span><u><span style=\"color:#956fe7;\">第一次匹配</span></u><span style=\"color:#0d0016;\">成功则我们将</span><u><span style=\"color:#956fe7;\">第一次匹配</span></u><span style=\"color:#0d0016;\">中的指针s1和s2分别后移，</span><span style=\"color:#38d8f0;\">若后移后指针s1和s2指向的内容不相同，则第一次匹配失败</span><span style=\"color:#0d0016;\">，s1回到第一次匹配的首位值得下一位，s2回到首地址，</span><span style=\"color:#38d8f0;\">若此时指针s1和s2指向的内容相同</span><span style=\"color:#0d0016;\">则，</span><u><span style=\"color:#956fe7;\">开启第二次匹配</span></u><span style=\"color:#0d0016;\">，以此类推直到s2指向空，则匹配成功。</span></p>\n<p><span style=\"color:#0d0016;\">2.源字符串</span>多次匹配才能成功</p>\n<p> 大致思路是假设指针s1指向目标字符串首地址，指针s2指向源字符串首地址，分别对指针s1和s2解引用并比较，若匹配内容不相同我们称之为<span style=\"color:#fe2c24;\">匹配失败</span>，则目标字符串指针s1，向后移动一位，<span style=\"color:#fe2c24;\">若匹配内容相同我们称之为第</span><span style=\"color:#956fe7;\">n次匹配，</span><span style=\"color:#0d0016;\">假设</span><u><span style=\"color:#956fe7;\">第一次匹配</span></u><span style=\"color:#0d0016;\">成功则我们将</span><u><span style=\"color:#956fe7;\">第一次匹配</span></u><span style=\"color:#0d0016;\">中的指针s1和s2分别后移，</span><span style=\"color:#38d8f0;\">若后移后指针s1和s2指向的内容不相同，则第一次匹配失败</span><span style=\"color:#0d0016;\">，s1回到第一次匹配的首位值得下一位，s2回到首地址，</span><span style=\"color:#38d8f0;\">若此时指针s1和s2指向的内容相同</span><span style=\"color:#0d0016;\">则，</span><u><span style=\"color:#956fe7;\">开启第二次匹配</span></u><span style=\"color:#0d0016;\">，以此类推直到s2指向空，则匹配成功。</span></p>\n<p><span style=\"color:#fe2c24;\">3.这里我们以指针p来记录第n此匹配的起始位置；</span></p>\n</blockquote>\n<blockquote>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"719\" src=\"..\\..\\static\\image\\f6c4b5e3b8154878ae91e3fa3356b0b3.png\" width=\"1193\"/></h3>\n</blockquote>\n<p><img alt=\"\" height=\"817\" src=\"..\\..\\static\\image\\89cd8410c19148f99a883d5438d5823c.png\" width=\"1200\"/></p>\n<blockquote>\n<p><img alt=\"\" height=\"798\" src=\"..\\..\\static\\image\\502e2fd820ed49c586073c3315846e98.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"802\" src=\"..\\..\\static\\image\\51bbbf2027654203853da256c2a185a6.png\" width=\"1200\"/></p>\n</blockquote>\n<h3 id=\"%E4%BB%A3%E7%A0%81%EF%BC%9A\">代码：</h3>\n<blockquote>\n<pre><code> #include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nchar* my_strstr(const char* arr1,const char* arr2)\n{\n\tassert(arr1 &amp;&amp; arr2);\n\tconst char* s1 = arr1;\n\tconst char* s2 = arr2;\n\tconst char* p = arr1;\n\twhile (*p)\n\t{\n\t\ts1 = p;\n\t\ts2 = arr2;\n\t\twhile (*s1 != '\\0' &amp;&amp; *s2 != '\\0' &amp;&amp; *s1 == *s2)\n\t\t{\n\t\t\ts1++;\n\t\t\ts2++;\n\t\t}\n\t\tif (*s2 == '\\0')\n\t\t{\n\t\t\treturn (char*)p;\n\t\t}\n\t\tp++;\n\t}\n\treturn NULL;\n}\nint main()\n{\n\tchar arr1[] = \"aabba\";\n\tchar arr2[] = \"abb\";\n\tchar* ch = my_strstr(arr1, arr2);\n\tif (ch == NULL)\n\t{\n\t\tprintf(\"子字符串不存在\\n\");\n\t}\n\tprintf(\"%s\", ch);\n\treturn 0;\n}</code></pre>\n</blockquote>\n<h3 id=\"%E7%BB%93%E6%9E%9C%EF%BC%9A\">结果：</h3>\n<p><img alt=\"\" height=\"456\" src=\"..\\..\\static\\image\\5fded448998f43619c963abbc94d472c.png\" width=\"1092\"/></p>\n<h1 id=\"%C2%A0%E4%BA%8C.strtok%E5%88%87%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%9A\"> 二.strtok切割字符串函数：</h1>\n<h2>1.功能：</h2>\n<p><img alt=\"\" height=\"156\" src=\"..\\..\\static\\image\\cb602e24dc5242c8bc8894410b7dbf7f.png\" width=\"1022\"/></p>\n<p> 在这里解释一下：</p>\n<div>\n<span style=\"color:#fe2c24;\">1.sep参数是个字符串，定义了用作分隔符的字符集合 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">2.第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">记。 </span>\n</div>\n<div>\n<div>\n<span style=\"color:#fe2c24;\">3.strtok函数找到str中的下一个标记，并将其用 \\0 结尾，返回一个指向这个标记的指针。（注： </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">并且可修改。） </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">4.strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">中的位置。 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">5.strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">记。 </span>\n</div>\n<div>\n<span style=\"color:#fe2c24;\">6.如果字符串中不存在更多的标记，则返回 NULL 指针。 </span>\n</div>\n</div>\n<div>\n<div></div>\n</div>\n<h2 id=\"2.%20%E4%BB%A3%E7%A0%81%EF%BC%9A\">2. 代码：</h2>\n<blockquote>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n int main()\n{\n\tconst char* sep = \"@.\";\n\tchar email[] = \"zhangpengwei@bitejiuyeke.com.net\";\n\tchar cp[40] = { 0 };//\"zhangpengwei@bitejiuyeke.com\"\n\tstrcpy(cp, email);\n    char* ret = strtok(cp, sep);\n\tif(ret != NULL)\n\t\tprintf(\"%s\\n\", ret);\n\n\tret = strtok(NULL, sep);\n\tif (ret != NULL)\n\t\tprintf(\"%s\\n\", ret);\n\n\tret = strtok(NULL, sep);\n\tif (ret != NULL)\n\t\tprintf(\"%s\\n\", ret);\n\n\tret = strtok(NULL, sep);\n\tif (ret != NULL)\n\t\tprintf(\"%s\\n\", ret);\n\n\treturn 0;\n}</code></pre>\n</blockquote>\n<p style=\"text-align:center;\">以为这就完了？<img alt=\"\" src=\"..\\..\\static\\image\\14815be4c796406ba453feeb28e1d52b.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\e85dd148a27c4f969c6c10f8441e33e2.png\"/></p>\n<p>事实上代码可以进行简化：</p>\n<blockquote>\n<p></p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n int main()\n{\n\tconst char* sep = \"@.\";\n\tchar email[] = \"zhangpengwei@bitejiuyeke.com.net\";\n\tchar cp[40] = { 0 };//\"zhangpengwei@bitejiuyeke.com\"\n\tstrcpy(cp, email);\n    \n\tchar* ret = NULL;\n\t\tfor (ret = strtok(cp, sep); \n\t\t\t ret != NULL; \n\t\t\t ret=strtok(NULL, sep))\n\t\t{\n\t\t\tprintf(\"%s\\n\", ret);\n\t\t}\n\n\treturn 0;\n}</code></pre>\n<p></p>\n</blockquote>\n<h2 id=\"3.%E7%BB%93%E6%9E%9C%EF%BC%9A\">3.结果：</h2>\n<blockquote>\n<p><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\b882eca791a949b6961579f4b241ba67.png\" width=\"448\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%C2%A04.%E6%A8%A1%E6%8B%9Fstrtok%EF%BC%9A\"> 4.模拟strtok：</h2>\n<h3 id=\"a%EF%BC%89%E4%BB%A3%E7%A0%81%EF%BC%9A\">a）代码：</h3>\n<blockquote>\n<pre><code>\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\n#include&lt;string.h&gt;\n//模拟实现strtok  字符串切割函数 \nchar* my_strtok(char* str1, const char* str2)\n{\n\tassert(str2);\n\tstatic int sz1 = NULL;\n\tstatic int count = NULL;\n\tstatic char* s1 = NULL;\n\tstatic char* s2 = NULL;\n\tint sz = 0;\n\tif (str1 != NULL)//说明是第一次进入。\n\t{\n\t\tsz1 = strlen(str1);//计算出str1中所有字符的个数\n\t\ts2 = str1;//记录初始地址，等下找到分割符时，将这个地址返回。\n        sz = strlen(str2);\n\t    for (*str1; *str1 != 0; str1++)\n\t\t{\t\t\t\n\t\t   for (int i = 0; i &lt; sz; i++)\n\t\t   {  \n\t\t\t   if (i == 0)\n\t\t\t   {\n\t\t\t\t   count++;\n\t\t\t   }\n\t\t\t   if (*str1 == *(str2 + i))\n\t\t\t   {\n\t\t\t\t   *str1 = 0;\n\t\t\t\t   s1 = str1;//记录这一次置0的位置。\n\t\t\t\t   return s2;\n\t\t\t   }\t\t\t \n\t\t   }\n\t    }\n\t}\n\telse\n\t{\n\t\ts2 = s1+1;\t\n\t\tstr1 = s2;\n\t\tsz = strlen(str2);\n\t\tfor (*str1; *str1 != 0; str1++)\n\t\t{\t\t\t\n\t\t\tfor (int i = 0; i &lt; sz; i++)\n\t\t\t{\t\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tif (*str1 == *(str2 + i))\n\t\t\t\t{\n\t\t\t\t\t*str1 = 0;\n\t\t\t\t\ts1 = str1;//记录这一次置0的位置。\n\t\t\t\t\treturn s2;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tif (count &gt; sz1)\n\t\t{\n\t\t\treturn NULL;\n\t\t}\n\t\treturn s2;\n\t}\n\t\n}\nint main()\n{\n\tchar arr[20] = \"12@34.5\";\n\tchar* p = \"@.\";\n\tchar* str = NULL;\n\tfor (str = my_strtok(arr, p); str != NULL; str = my_strtok(NULL, p))\n\t{\n\t\tprintf(\"%s\\n\", str);\n\t}\n   \n\treturn 0;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"b%EF%BC%89%E7%BB%93%E6%9E%9C%EF%BC%9A\">b）结果：</h3>\n<blockquote>\n<p><img alt=\"\" height=\"324\" src=\"..\\..\\static\\image\\fc23b84b3d304c23a8813c0f233d85ea.png\" width=\"485\"/></p>\n<p></p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"> 这里需要注意的就是当目的字符串被遍历完成之后，再次调用该函数会返回一个NULL指针。我是以计数器的方式进行实现，每当成功比对一个字符，就进行一次计数，当计数的个数比目的字符串字符个数大时，说明目的字符串被遍历完成了，此时会返回空指针。</span></p>\n<h1 id=\"%E4%B8%89.strerror%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E5%87%BD%E6%95%B0%EF%BC%9A\"><span style=\"color:#0d0016;\">三.strerror错误报告函数：</span></h1>\n<h2>1.功能：</h2>\n<p><img alt=\"\" height=\"148\" src=\"..\\..\\static\\image\\4e645386c0b74c24973078cd8a30a0c7.png\" width=\"833\"/></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">返回错误码，所对应的错误信息。 </span> </p>\n</blockquote>\n<h2 id=\"2.%E4%BB%A3%E7%A0%81%EF%BC%9A\">2.代码：</h2>\n<h3 id=\"a%EF%BC%89\">a）</h3>\n<blockquote>\n<p>注意：</p>\n<table><tbody><tr><td>C语言的库函数，在执行失败的时候，都会设置错误码</td></tr><tr><td>0 1 2 3 4 5 6 7 8</td><td></td><td></td></tr></tbody></table>\n</blockquote>\n<blockquote>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tprintf(\"%s\\n\", strerror(0));\n\tprintf(\"%s\\n\", strerror(1));\n\tprintf(\"%s\\n\", strerror(2));\n\tprintf(\"%s\\n\", strerror(3));\n\tprintf(\"%s\\n\", strerror(4));\n\tprintf(\"%s\\n\", strerror(5));\n\treturn 0;\n}</code></pre>\n</blockquote>\n<p>结果：<img alt=\"\" height=\"383\" src=\"..\\..\\static\\image\\d7f072adced64cdea64842daa8867d93.png\" width=\"694\"/> </p>\n<h3 id=\"%C2%A0b%EF%BC%89\"> b）</h3>\n<blockquote>\n<p>errno - C语言设置的一个全局的错误码存放的变量</p>\n</blockquote>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;errno.h&gt;\nint main()\n{\n\tFILE* pf = fopen(\"C:\\\\Users\\\\zpeng\\\\Desktop\\\\test.txt\", \"r\");\n\t\tif (pf == NULL)\n\t\t{\n\t\t\tprintf(\"%s\\n\", strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//\n\t\t}\n\t\treturn 0;\n}</code></pre>\n<p> 如果文件夹不在会返回错误信息进行提醒：</p>\n<p><img alt=\"\" height=\"405\" src=\"..\\..\\static\\image\\64642b9e55954aeb9d972eeceb078841.png\" width=\"1029\"/></p>\n<h1 id=\"%C2%A0%E5%9B%9B.%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%9A\"> 四.字符分类函数：</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\"><strong>函数</strong></span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\"><strong>如果他的参数符合下列条件就返回真</strong></span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">iscntr</span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">任何控制字符</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isspace </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">空白字符：空格</span>\n<span style=\"color:#333333;\">‘ ’</span>\n<span style=\"color:#333333;\">，换页</span>\n<span style=\"color:#333333;\">‘\\f’</span>\n<span style=\"color:#333333;\">，换行</span>\n<span style=\"color:#333333;\">'\\n'</span>\n<span style=\"color:#333333;\">，回车</span>\n<span style=\"color:#333333;\">‘\\r’</span>\n<span style=\"color:#333333;\">，制表符</span>\n<span style=\"color:#333333;\">'\\t'</span>\n<span style=\"color:#333333;\">或者垂直制表符</span>\n<span style=\"color:#333333;\">'\\v' </span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isdigit </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">十进制数字</span>\n<span style=\"color:#333333;\"> 0~9</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isxdigit</span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">十六进制数字，包括所有十进制数字，小写字母</span>\n<span style=\"color:#333333;\">a~f</span>\n<span style=\"color:#333333;\">，大写字母</span>\n<span style=\"color:#333333;\">A~F</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">islower </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">小写字母</span>\n<span style=\"color:#333333;\">a~z</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isupper</span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">大写字母</span>\n<span style=\"color:#333333;\">A~Z </span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isalpha </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">字母</span>\n<span style=\"color:#333333;\">a~z</span>\n<span style=\"color:#333333;\">或</span>\n<span style=\"color:#333333;\">A~Z</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isalnum</span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">字母或者数字，</span>\n<span style=\"color:#333333;\">a~z,A~Z,0~9</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">ispunct </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">标点符号，任何不属于数字或者字母的图形字符（可打印）</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isgraph </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">任何图形字符</span>\n</div> </td></tr><tr><td style=\"width:116px;\">\n<div>\n<span style=\"color:#333333;\">isprint </span>\n</div> </td><td style=\"width:382px;\">\n<div>\n<span style=\"color:#333333;\">任何可打印字符，包括图形字符和空白字符</span>\n</div> </td></tr><tr><td style=\"width:116px;\"></td><td style=\"width:382px;\"></td></tr><tr><td style=\"width:116px;\"></td><td style=\"width:382px;\"></td></tr><tr><td style=\"width:116px;\"></td><td style=\"width:382px;\"></td></tr></tbody></table>\n<h1 id=\"%E4%BA%94.%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A\">五.字符转换函数：</h1>\n<blockquote>\n<div>\n<span style=\"color:#008855;\">int </span>\n<span style=\"color:#0000ff;\">tolower</span>\n<span style=\"color:#333333;\"> ( </span>\n<span style=\"color:#008855;\">int </span>\n<span style=\"color:#000000;\">c</span>\n<span style=\"color:#333333;\"> )</span>\n</div>\n<div>\n<span style=\"color:#008855;\">int </span>\n<span style=\"color:#0000ff;\">toupper</span>\n<span style=\"color:#333333;\"> ( </span>\n<span style=\"color:#008855;\">int </span>\n<span style=\"color:#000000;\">c</span>\n<span style=\"color:#333333;\"> )</span>\n</div>\n</blockquote>\n<h1 id=\"%C2%A0%E5%85%AD%EF%BC%9A%E8%87%AA%E8%B4%9F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E4%B8%8E%E8%87%AA%E8%B4%9F%E5%88%86%E7%B1%BB%E5%87%BD%E6%95%B0%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B\"> 六：自负转换函数与自负分类函数综合案例</h1>\n<h2 id=\"1.%E4%BB%A3%E7%A0%81%EF%BC%9A\">1.代码：</h2>\n<blockquote>\n<pre><code>#include&lt;stdio.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\nint main()\n{\n\tint i = 0;\n\tchar str[] = \"Test String.\\n\";\n\tchar c;\n\twhile (str[i])\n\t{\n\t\tc = str[i];\n\t\tif (isupper(c))\n\t\t\tc = tolower(c);\n\t\tputchar(c);\n\t\ti++;\n\t}\n\treturn 0;\n}</code></pre>\n</blockquote>\n<p><img alt=\"\" height=\"194\" src=\"..\\..\\static\\image\\f0ab34d39e8740bc839b2057044e9221.png\" width=\"1200\"/></p>\n<h2 id=\"2.%20%E7%BB%93%E6%9E%9C%EF%BC%9A\">2. 结果：</h2>\n<blockquote>\n<p><img alt=\"\" height=\"391\" src=\"..\\..\\static\\image\\345b2329d26243a5a9e1e4c2dde696f9.png\" width=\"860\"/></p>\n</blockquote>\n<blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\14dc9a29b1cb42d4a2b8ee2dae466468.png\"/></p>\n<p></p>\n</blockquote>\n<p>结语：</p>\n<p> 每个人的成长都是能力和想要得到的东西，不断匹配的过程，当你的才华和欲望不匹配时，你就该静下心来学习了，如果小编的总结能对你有所帮助，希望小伙伴们三连加关注哦，你的支持是小编创作的最大动力。</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-11 17:41:27", "summary": "作者：旧梦拾遗旧梦拾遗专栏：语言编程小比特成长日记语言编程小比特成长日记每日励志：不想认命，就去拼命，我始终相信，付出就会有收获，或大或小，或迟或早，始终不会辜负你的努力。有一种落差是，你总是羡慕别人"}