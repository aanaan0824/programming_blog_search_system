{"blogid": "124670823", "writerAge": "码龄1年", "writerBlogNum": "65", "writerCollect": "175", "writerComment": "5", "writerFan": "25", "writerGrade": "3级", "writerIntegral": "715", "writerName": "dangoxiba", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124670823.jpg", "writerRankTotal": "27327", "writerRankWeekly": "215095", "writerThumb": "77", "writerVisitNum": "63133", "blog_read_count": "914", "blog_time": "已于 2022-05-09 21:18:48 修改", "blog_title": "【Unity好插件介绍】介绍DOTween以及其常用函数属性介绍", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><a id=\"_0\"></a></h1>\n<p> </p>\n<p></p>\n<h1>学习目标：</h1>\n<h3>今天来介绍一下Unity的一个好插件DOTween，也就当复习巩固了，没想到在B站上看到了一个远古视频有老师教学怎么使用DOTween，于是在学习了42P视频后就讲学到的常用函数属性给大伙看一遍。</h3>\n<p>如果你想系统性的学习请看：<a class=\"has-card\" href=\"https://www.bilibili.com/video/BV1Fx411Z7Bi?spm_id_from=333.851.header_right.fav_list.click\" title=\"Unity常用插件之DoTween_哔哩哔哩_bilibili\"><span class=\"link-card-box\"><span class=\"link-title\">Unity常用插件之DoTween_哔哩哔哩_bilibili</span><span class=\"link-desc\">详细了讲解了Unity中的常用插件DoTween的使用方法。</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\e990b3eb3b27705646f68cdcf460730c0c6fe0dc.jpg@57w_57h_1c.png\"/>https://www.bilibili.com/video/BV1Fx411Z7Bi?spm_id_from=333.851.header_right.fav_list.click</span></span></a></p>\n<p>如果有懂哥的话肯定知道这个插件大致就是通过代码控制住动画，让游戏运行的时候能进行相应的动画，下列是公司说的优点</p>\n<p><img alt=\"\" height=\"724\" src=\"..\\..\\static\\image\\2a79fb80f5c94af2911c91b2ad416763.png\" width=\"1200\"/></p>\n<p></p>\n<p>然后我们在Asset Store下载一个免费版的，然后倒入到Unity中<img alt=\"\" height=\"927\" src=\"..\\..\\static\\image\\48c7a75bc9a24d2b8e1f4a1f2259c57f.png\" width=\"1200\"/></p>\n<p>右下角Import一下，<img alt=\"\" height=\"688\" src=\"..\\..\\static\\image\\7bf370f8b4214e24828d97f5bced3eeb.png\" width=\"439\"/></p>\n<p><img alt=\"\" height=\"350\" src=\"..\\..\\static\\image\\37bb2ada688f417a9ed507e0435e8877.png\" width=\"500\"/></p>\n<p><img alt=\"\" height=\"813\" src=\"..\\..\\static\\image\\9a8435cae55d4f6a908515f9124a2ded.png\" width=\"463\"/></p>\n<p><img alt=\"\" height=\"813\" src=\"..\\..\\static\\image\\c17e24b77d424ad1bf0fc4fe862d0525.png\" width=\"463\"/></p>\n<p></p>\n<p>导入成功后就会看到这个绿色按钮点一下等一会Apply成功后即可退出，DOTween插件成功导入。然后我们还可以在代码中引用它的命名空间了。</p>\n<p>准备好了话就先创建一个3D 的项目，然后开始每个方法都要实践吧。</p>\n<h1><a id=\"_10\"></a>学习内容：</h1>\n<p>  <span style=\"color:#fe2c24;\">红色注意：要使用它的命名空间要在一开始的using下添加命名空间using DG.Tweening;</span></p>\n<p><span style=\"color:#fe2c24;\"> 除非特殊说明，不然所有代码都是在Untiy自带的Start()函数上完成的。</span></p>\n<p>  一：首先从移动和旋转，大小开始</p>\n<pre><code> //transform.DOMove(Vet3目标点,float时长)\n        //transform.DOMove(Vector3.one, 2f);\n        //transform.DOMoveX() //移动x轴\n        //transform.DOLocalMove() Unity中有自身坐标（相对）以及世界坐标（绝对）</code></pre>\n<p>还有另一种Punch的可以让你的移动反复（一般震动和弹性都是用默认的）</p>\n<pre><code>//DOPunchPosition反复开始和结尾的位置\n        //transform.DOPunchPosition(new Vector3(0, 1, 0),2f,3,0.1f); //Vet3 时间 震动 弹性</code></pre>\n<pre><code>//DORotate(Vet3目标度数,float时长)\n        //transform.DORotate(new Vector3(50, 50, 50), 2f);</code></pre>\n<pre><code>//DOScale(Vet3目标大小，float时长)\n        //transform.DOScale(new Vector3(2, 2, 2), 2f);</code></pre>\n<p>然后还有一个震动的</p>\n<pre><code> //震动的时长，强度，频率，随机的角度\n        //transform.DOShakePosition(2f, 4, 10, 90);</code></pre>\n<p></p>\n<p>二丶材质部分</p>\n<p>  我们还可以用于修改材质</p>\n<p>  首先创建一个3D Object 叫Cube，然后创建一个Material，再将照片给它<img alt=\"\" height=\"345\" src=\"..\\..\\static\\image\\84ecb2f21d3e48f29caa8414480ad4c4.png\" width=\"636\"/></p>\n<p> 可以见到我们两种Shader都用的不一样的<img alt=\"\" height=\"830\" src=\"..\\..\\static\\image\\5f9be7c3fd8543339e32f3d046328278.png\" width=\"991\"/></p>\n<p> 如果我们用Patricals的，则啊草图片是显示不出来的。</p>\n<p>下面是Standard</p>\n<p><img alt=\"\" height=\"270\" src=\"..\\..\\static\\image\\57625227beca47a7a54ec2cbf8ac359d.png\" width=\"359\"/></p>\n<p>扯的有点远了，首先我们用回第一张图的Shader，然后我们开始介绍代码</p>\n<pre><code>//材质\n        Material material = GetComponent&lt;MeshRenderer&gt;().material;\n        //DOColor(Color你想要改变的颜色，把颜色赋值给Shader属性的Color(默认\"_Color\",看你用的是什么shader了)，时长)\n        //material.DOColor(Color.red,\"_TintColor\", 2);</code></pre>\n<p> 那么这个_TintColor在哪里看呢？就在你的材质里，找到Color的名字后复制粘贴进去，不然会报错的（Standard则没有这种问题）点击Edit，可以看到它的属性</p>\n<p><img alt=\"\" height=\"913\" src=\"..\\..\\static\\image\\d7e440386f3d48e59909ef1d5e736b1f.png\" width=\"345\"/></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"169\" src=\"..\\..\\static\\image\\4b3e7da97a2e47faaf9221c2f4fc25c9.png\" width=\"635\"/></p>\n<pre><code>//修改透明度第一方法：DOColor()将颜色清零\n        //material.DOColor(Color.clear, \"_TintColor\", 2f);</code></pre>\n<p></p>\n<pre><code> //修改透明度第二方法：DOFade(Float Fade你想要改变的透明度大小，把颜色赋值给Shader属性的Color(默认\"_Color\",看你用的是什么shader了)，时长)\n        //material.DOFade(0, \"_TintColor\", 2f);</code></pre>\n<p>如果要修改颜色的渐变值，首先我们要在回调函数外声明一个Grandient类</p>\n<p>public Gradient gradient;//渐变</p>\n<pre><code>//渐变颜色DOGradientColor(Gradient 要渐变的，指定的属性, float时长)\n        //material.DOGradientColor(gradient, \"_TintColor\", 2);</code></pre>\n<p>材料的纹理坐标指的是Offset<img alt=\"\" height=\"344\" src=\"..\\..\\static\\image\\cc4b8147fa304ce3b14918232811feef.png\" width=\"351\"/></p>\n<p> 可以改变它的Offset让Material有个滚动的效果</p>\n<pre><code>//纹理偏移值DOOffset(Vec2 Offset,float 时长)\n        //material.DOOffset(new Vector2(1, 1), 2);</code></pre>\n<p>我们还有一个混合模式，如果你只是单纯的列两条函数，那它只会执行后一条</p>\n<pre><code>//这两行最终执行结果也只是变为绿色\n        //material.DOColor(Color.red,\"_TintColor\", 2);\n        //material.DOColor(Color.green, \"_TintColor\", 2);</code></pre>\n<p></p>\n<p>但你用了混合模式就不一样了，它会选择两种颜色的中间色</p>\n<pre><code>//材质的混合模式\n        material.DOBlendableColor(Color.red, \"_TintColor\", 2);\n        material.DOBlendableColor(Color.green, \"_TintColor\", 2);</code></pre>\n<p>三丶摄像机属性相关的动画</p>\n<p>再声明一遍，如果你想要使用这些扩展函数的话，一定要引用命名空间<strong><span style=\"color:#fe2c24;\">using DG.Tweening;</span></strong></p>\n<p>首先我们创建一个脚本挂载到摄像机上，再获取Camera组件，</p>\n<p>Camera cam = GetComponent&lt;Camera&gt;();</p>\n<pre><code>//设置摄像机宽高比cam.DOAspect(float 宽高比值，float 时长)\n        //cam.DOAspect(1.5f, 2);</code></pre>\n<p></p>\n<pre><code>//设置摄像机的背景颜色(Color 你要变换的颜色，float 时长)\n        //cam.DOColor(Color.red, 2f);</code></pre>\n<p></p>\n<pre><code>//设置摄像机的近切面和远切面（Clipping Plane）Near,Far\n        //cam.DONearClipPlane(1.4f, 2f);\n        //cam.DOFarClipPlane(5f, 2f);</code></pre>\n<p>点开摄像机其实是这里</p>\n<p><img alt=\"\" height=\"63\" src=\"..\\..\\static\\image\\05bd1c375bd94d92a89c32a8b682b7f0.png\" width=\"327\"/></p>\n<p></p>\n<pre><code>//设置Perspective摄像机的视域Fiew of View\n        //DOFieldOfView(float size,float 时长)\n        //cam.DOFieldOfView(100f, 2f);\n        //cam.DOOrthoSize()调整正交摄像机otherographic的视域大小\n        //cam.DOOrthoSize(6f, 2f);</code></pre>\n<p>这里涉及到摄像机的两种透视模式</p>\n<p><img alt=\"\" height=\"1080\" src=\"..\\..\\static\\image\\1cf339e39e404d5caa63c62b91f9936a.png\" width=\"1200\"/></p>\n<pre><code>//设置摄像机在屏幕的比例cam.DORect(Rect 矩形,float时长)\n        //cam.DORect(new Rect(0, 0, 0.5f, 0.5f),2f);</code></pre>\n<pre><code> //根据像素设置摄像机在屏幕的比例\n        cam.DOPixelRect(new Rect(0, 0, 512, 384), 2f);</code></pre>\n<p>这里则是摄像机能在屏幕上显示的比例（一种是多少比例，一种是多少个像素）</p>\n<p><img alt=\"\" height=\"93\" src=\"..\\..\\static\\image\\08f81f3734b54276828c59ba99a75b49.png\" width=\"321\"/></p>\n<p> 我用的是1024:768个像素比</p>\n<p><img alt=\"\" height=\"342\" src=\"..\\..\\static\\image\\5301dea8f5c54b199d54cdcc07bde93c.png\" width=\"285\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"958\" src=\"..\\..\\static\\image\\79ad22425a4c4f978f868a64bc156ce1.png\" width=\"1200\"/></p>\n<h3> <strong>设置摄像机抖动这个是最常见的：</strong></h3>\n<pre><code>//设置相机的震动(float时长，float 强度,int 频率,float 随机度数)\n        cam.DOShakePosition(2);</code></pre>\n<p><img alt=\"\" height=\"114\" src=\"..\\..\\static\\image\\7c4f16f56464465ea6524316f4f1a3f9.png\" width=\"1200\"/></p>\n<p>四丶UI部分</p>\n<p>可以看到这个DOTween真的已经覆盖了Unity组件的大部分。</p>\n<p>首先是Text我们可以让Text像打字机一样输出文字，后面的SetEase()函数表示我们可以使用什么类型的模式来输出，每一种大伙都可以试一下</p>\n<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing DG.Tweening;\npublic class TextDOTween : MonoBehaviour\n{\n    \n    void Start()\n    {\n        Text text = GetComponent&lt;Text&gt;();\n        //text.DOText(string,float).SetEase(样式)\n        text.DOText(\"abcdefghijklmnopqrstuvwxyz\", 5f).SetEase(Ease.Linear);\n    }\n\n   \n}\n</code></pre>\n<p>同样，我们也可以用在Button上</p>\n<p>这里简单写一点了，比如直接创建一个脚本然后挂载在一个新建的Button上，当触发点击事件的时候回进行反复移动</p>\n<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing DG.Tweening;\npublic class ButtonDOTween : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n\n    public void aniBtn()\n    {\n        transform.DOPunchPosition(new Vector3(0, 20, 0), 0.4f,6,0.3f);\n        transform.DOPunchScale(new Vector3(0.3f, 0, 0), 0.3f, 4, 0.4f);\n    }\n}\n</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"977\" src=\"..\\..\\static\\image\\20e28ed59a0447a4af2b349d69d0882f.png\" width=\"1200\"/></p>\n<p>截的不是很好，但可以看出按钮已经播放动画了。</p>\n<p></p>\n<p><img alt=\"\" height=\"1080\" src=\"..\\..\\static\\image\\ff66751641934bf093d63de99e804ae7.png\" width=\"1200\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 五丶（核心部分）运动序列</strong></span></p>\n<p></p>\n<p>  之所以我称呼他为核心部分，是因为它可以为某个动画添加各种一样行为，顺序逆序</p>\n<p>首先我们先创建一个运动队列</p>\n<p>运动队列本身就是一个队列，它所创建的所有序列都遵循队列的先进先出的顺序</p>\n<pre><code>Sequence sequence = DOTween.Sequence();</code></pre>\n<pre><code> sequence.Append(transform.DOMove(Vector3.one, 2f));//0-2\n        //在上一个动作的基础上再加一个动作Join（Tween 动作）</code></pre>\n<p></p>\n<pre><code>//插入在某一时刻插入某个动作Insert(flaot 时刻，Tween 动作)\n        //sequence.Insert(0, transform.DOMove(-Vector3.one, 1.5f)); //从第0秒开始，就把一开始的Apeend给替换掉了</code></pre>\n<p></p>\n<pre><code>sequence.InsertCallback(2, appCallBack); \n \nprivate void appCallBack()\n    {\n        Debug.Log(\"InsertCallBack\");\n\n    }</code></pre>\n<pre><code> sequence.Join(transform.DOScale(Vector3.one * 2, 2f));</code></pre>\n<pre><code> //下列这两步和上面的Join一样\n        //sequence.Insert(0f, transform.DOScale(Vector3.one * 2, 2f));\n        //sequence.Insert(3f, transform.DOScale(Vector3.one, 2f));</code></pre>\n<pre><code> //sequence.AppendCallback(); 回调函数\n //我们现在Start（）外面创建一个函数\n private void appendCallBack()\n    {\n        Debug.Log(\"AppendCallBack\");\n    }\n  然后就可以调用它了\n  sequence.AppendCallback(appendCallBack);</code></pre>\n<p></p>\n<p>接下来介绍反过来的添加动作Prepend预添加Prepend则是一个栈 后进先出的</p>\n<p>执行的顺序是先执行Prepend,再执行Append</p>\n<pre><code> sequence.PrependInterval(1f); //等待一秒\n        sequence.Prepend(transform.DOMove(-Vector3.one, 2f)); //先反方向\n        sequence.PrependCallback(prependCallBack);\n\n\n\n  private void prependCallBack()\n    {\n        Debug.Log(\"PrependCallBack\");\n    }</code></pre>\n<p>这些是先执行的。</p>\n<p><span style=\"color:#956fe7;\"><strong>六丶运动参数TweenParams</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>  也是挺重要的，标记为紫色。</strong></span></p>\n<p><strong><span style=\"color:#956fe7;\">  </span><span style=\"color:#0d0016;\">首先要创建一个对象</span></strong></p>\n<pre><code>TweenParams tp = new TweenParams();</code></pre>\n<p>然后是设置循环，第一个参数是循环的次数（如果是-1则代表无限循环，后面是循环的类型有Yoyo,Restart等）</p>\n<pre><code> TweenParams tp = new TweenParams();\n        //tp.SetLoops(-1, LoopType.Yoyo);</code></pre>\n<p>给一个动作赋予参数（通常bool值为false）</p>\n<pre><code> //transform.DOMove((Vector3.one), 1f).SetAs(tp).SetAutoKill(); //SetAutoKill()动作完成时自动销毁\n        //transform.DOMove((Vector3.one), 1f).From(true); //From(bool 基于方向进行移动，如果两个点重合的话，如果设置为true 即使两个点重合还会根据方向移动过来，如果都是(1,1,1)),他会从</code></pre>\n<pre><code>//设置延迟参数\n        //transform.DOMove(Vector3.one, 1).SetDelay(3f);\n        //设置速度(DOMove里面的数字10就是速度)\n        //transform.DOMove(Vector3.one, 10).SetSpeedBased(true); //SetSpeedBased(bool true则是速度,false则是时间)</code></pre>\n<p> 通过ID来编号你要执行的动作</p>\n<pre><code>//设置 SetId(string ID名字)\n        //transform.DOMove(Vector3.one, 2f).SetId(\"ID03\");\n        //DOTween.Play(\"ID03\");</code></pre>\n<pre><code>//设置可回收的\n        //transform.DOMove(Vector3.one, 2f).SetRecyclable();\n\n        //设置增量的使用\n        //transform.DOMove(Vector3.one, 2f).SetRelative();</code></pre>\n<pre><code>//SetUpdate(UpdateType Upadte的类型Normal则是通常的,bool 播放的时间帧值true则不受Time.scaletime控制)\n        //transform.DOMove(Vector3.one, 2f).SetUpdate(UpdateType.Normal,true);</code></pre>\n<pre><code>//Linear匀速 Flash闪动 float 10速度的变换 \n        //transform.DOMove(Vector3.one, 2f).SetEase(Ease.Linear,10,0);</code></pre>\n<p>自定义曲线，首先要在开头声明一个</p>\n<p>public AnimationCurve ac;</p>\n<p>可以看到在Inspector面板上我们点击后可以选择你的曲线，也可以通过鼠标右键点击Add Key来添加属性让曲线呈现你想要的。<img alt=\"\" height=\"1080\" src=\"..\\..\\static\\image\\6f3063c2d1a4486082038c0feeb61985.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code>//自定义曲线Easer、\n        //transform.DOMove(Vector3.one, 2).SetEase(ac);</code></pre>\n<p>你也可以自定义一个函数来绘制曲线</p>\n<pre><code> //自定义函数型曲线\n        //transform.DOMove(Vector3.one, 2).SetEase(MyEaseRun);\n\nprivate float MyEaseRun(float time, float duration, float overshootOrAmplitude, float period)\n    {\n        return time / duration;\n    }</code></pre>\n<p>八丶回调函数</p>\n<p>  DOTween上的回调函数同样也是非常重要的内容。</p>\n<p> 例如我们可以用Lamada表达式来创造动作完成时候的回调</p>\n<pre><code>//Lamada表达式OnComplete\n        //transform.DOMove(Vector3.one, 2f).OnComplete(() =&gt; { Debug.Log(\"kkjjj\"); });</code></pre>\n<p>除此之外还有其他的，与Unity的MonoBehavior自带的回调函数相似知识在前面加了个on</p>\n<p></p>\n<p>还有一个输出动作的时间点fullPosition这里以异步为例</p>\n<p>接下来介绍fullPosition,这里引用异步函数，首先先声明两个命名空间</p>\n<p>using System;<br/> using System.Threading.Tasks;</p>\n<pre><code>async void Start()\n    {\n       \n\n        var tweener = transform.DOMove(Vector3.one, 2f);\n        await Task.Delay(TimeSpan.FromSeconds(1));\n        //tweener.fullPosition = 2; //如果是2，则表示暂停线程1秒后直接到达2秒的位置\n        Debug.Log(tweener.fullPosition); //返回的是当前位置是在总时间的第几秒\n        //动画的时间时刻tweener.fullPosition;\n}</code></pre>\n<p>可以看到它通过当前位置计算出方块的位置相当于总时间的多少秒</p>\n<p>等我们把注释解掉，仅有一秒就运行到本来动画2秒就要运行到的位置</p>\n<p><img alt=\"\" height=\"913\" src=\"..\\..\\static\\image\\ec9aac4d85c444deae56a97f77db3803.png\" width=\"924\"/></p>\n<hr/>\n<pre><code>//var tweener = transform.DOMove(Vector3.one, 1f).SetLoops(3);\n        //获取有多少个暂停动画tweener.Delay();\n\n        //执行的时间tweener.Duration(bool 是否包含循环) false则是总时长(1)，true则要乘以循环次数（1*3）;\n\n        //已经执行完成的时间tweener.Elapsed(bool 是否包含循环) false则是总时长(1)，true则要乘以循环次数（1 * 3）);\n\n        //动画的播放进度[0,1]tweener.ElapsedDirectionalPercentage()\n\n        //tweener.ElapsedPercentage(bool); //也有判断是否包含循环</code></pre>\n<pre><code>//可以看是否包括循环，如果是则返回整体循环的百分比  tweener.ElapsedPercentage(bool);\n        //返回循环次数tweener.Loops();\n\n        //await Task.Delay(TimeSpan.FromSeconds(1));\n        //Debug.Log(tweener.CompletedLoops());\n        //await Task.Delay(TimeSpan.FromSeconds(1));\n        //Debug.Log(tweener.CompletedLoops());\n        //await Task.Delay(TimeSpan.FromSeconds(1));\n        //Debug.Log(tweener.CompletedLoops());</code></pre>\n<pre><code>//transform.DORestart();\n        //transform.DORewind(); //重新回到开始位置\n        //transform.DOSmoothRewind();// 平滑的重新回到开始位置\n        //transform.DOPause(); //暂停\n        //transform.DOPlay(); //播放\n        //transform.DORestart(); //重新开始\n\n        //await Task.Delay(TimeSpan.FromSeconds(1)); //延迟人物，把秒转化为毫秒TimeSpan.FromSeconds\n        //transform.DORewind(); //回到开始的位置\n        //transform.DOSmoothRewind();\n\n        //transform.DOFlip();\n        //transform.DOGoto(1,true); //float跳到那个时间点,bool 是否继续播放\n        //transform.DOPlayForward();\n        //transform.DOPlayBackwards();\n        //transform.DOTogglePause(); //暂停一瞬间感觉没什么用\n        //await Task.Delay(TimeSpan.FromSeconds(1));\n        //transform.DOTogglePause();</code></pre>\n<p>九丶类方法</p>\n<p>  用于统筹你的之前创造的动画动作等。</p>\n<p></p>\n<pre><code>//transform.DORestart();\n        //transform.DORewind(); //重新回到开始位置\n        //transform.DOSmoothRewind();// 平滑的重新回到开始位置\n        //transform.DOPause(); //暂停\n        //transform.DOPlay(); //播放\n        //transform.DORestart(); //重新开始\n\n        //await Task.Delay(TimeSpan.FromSeconds(1)); //延迟人物，把秒转化为毫秒TimeSpan.FromSeconds\n        //transform.DORewind(); //回到开始的位置\n        //transform.DOSmoothRewind();\n\n        //transform.DOFlip();\n        //transform.DOGoto(1,true); //float跳到那个时间点,bool 是否继续播放\n        //transform.DOPlayForward();\n        //transform.DOPlayBackwards();\n        //transform.DOTogglePause(); //暂停一瞬间感觉没什么用\n        //await Task.Delay(TimeSpan.FromSeconds(1));\n        //transform.DOTogglePause();</code></pre>\n<p>十丶协程</p>\n<p>  协程与进程不同，一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。（引用文章：<a class=\"has-card\" href=\"https://blog.csdn.net/u011484013/article/details/51136780?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165209865816782246448450%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165209865816782246448450&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-51136780-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=unity%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187\" title=\"unity 协程原理与线程的区别_天涯过客TYGK的博客-CSDN博客_协程与线程的区别\"><span class=\"link-card-box\"><span class=\"link-title\">unity 协程原理与线程的区别_天涯过客TYGK的博客-CSDN博客_协程与线程的区别</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://blog.csdn.net/u011484013/article/details/51136780?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165209865816782246448450%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165209865816782246448450&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-51136780-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=unity%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187</span></span></a>）是Unity独特的，利用计数器IEnumerator和StartCorountine来调用协程</p>\n<p>只不过看到这里的应该都是大多懂Unity协程的运行进程的，所以我就不细讲了。</p>\n<p></p>\n<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing DG.Tweening;\npublic class IEnumeratorDOTween : MonoBehaviour\n{\n    Tween twn;\n    void Start()\n    {\n        twn = transform.DOMove(new Vector3(2, 2, 2), 2f).SetLoops(3,LoopType.Yoyo);\n        StartCoroutine(waitFuc()); \n    }\n\n    IEnumerator waitFuc()\n    {\n        //等待动画完成\n        yield return twn.WaitForCompletion();\n        //执行几次循环以后\n        yield return twn.WaitForElapsedLoops(2);\n        //等待销毁以后\n        yield return twn.WaitForKill();\n        //等待运行的多少时间后\n        yield return twn.WaitForPosition(1.5f);\n        //等待到重新来的时候\n        yield return twn.WaitForRewind();\n        //等待起始化的时候\n        yield return twn.WaitForStart();\n    }\n    \n}\n</code></pre>\n<p></p>\n<p>十一丶路径动画</p>\n<p>  这点有些难以讲解，推荐看我一开头推荐的老师讲的视频，然后以下是路径动画创建的整个过程：</p>\n<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing DG.Tweening;\nusing System.Linq;\nusing System;\npublic class PathAnimationDOTween : MonoBehaviour\n{\n    //创建一个路径编辑器\n    public Transform[] listTrans;\n    void Start()\n    {\n        var listPosition = listTrans.Select(u =&gt; u.position).ToArray();\n        transform.DOPath(listPosition, 5f,PathType.Linear,PathMode.Full3D,10,Color.red)\n            .SetOptions(true,AxisConstraint.None,AxisConstraint.Y) //bool 是否为闭口，锁定哪个轴以及哪个 转向\n            .SetLookAt(new Vector3(0,0,0)); //一直看到0,0,0这个点\n        //SetLokkAt(0)一直看前方，数值为0到1，0.3是和正前方的角度的夹角\n\n        //SetOptions（bool是否是封闭路径,AxisConstrains.锁定哪个轴,AxisContstrains.锁定哪个角度)\n    }\n\n    \n}\n</code></pre>\n<p><img alt=\"\" height=\"524\" src=\"..\\..\\static\\image\\a8eccb83b2b7420da3435931529845c2.png\" width=\"997\"/></p>\n<p>然后把我们创建的八个新方块拖进来List，然后点击运行，会发现已经创建好路径了，接下来你的Cube将按照设置的参数属性等进行移动<img alt=\"\" height=\"911\" src=\"..\\..\\static\\image\\57a09798d7a94a79acde7d2672a27c96.png\" width=\"946\"/></p>\n<p><img alt=\"\" height=\"819\" src=\"..\\..\\static\\image\\fe53390a30c2436b81ae99a0544d9c5a.png\" width=\"883\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<hr/>\n<h1><a id=\"_34\"></a>学习产出：</h1>\n<h3> 以上便是本人当前对DOTween的所有理解，如果你能看到最后说明你耐心是真的NB。</h3>\n<p>接下来的文章会对学到DOTween进行综合应用，感谢支持。</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-09 21:18:48", "summary": "学习目标：今天来介绍一下的一个好插件，也就当复习巩固了，没想到在站上看到了一个远古视频有老师教学怎么使用，于是在学习了视频后就讲学到的常用函数属性给大伙看一遍。如果你想系统性的学习请看：常用插件之哔哩"}