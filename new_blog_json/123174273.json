{"blogid": "123174273", "writerAge": "码龄1年", "writerBlogNum": "44", "writerCollect": "348", "writerComment": "702", "writerFan": "2178", "writerGrade": "5级", "writerIntegral": "2472", "writerName": "jxwd", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123174273.jpg", "writerRankTotal": "9504", "writerRankWeekly": "8661", "writerThumb": "1119", "writerVisitNum": "65107", "blog_read_count": "1559", "blog_time": "于 2022-03-02 21:47:23 发布", "blog_title": "C++ 第八节&数据结构 第七节 ——二叉搜索树 AVL树 红黑树（底层原理图+模拟实现）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><span style=\"color:#fe2c24;\"><strong>第一次，C++和数据结构联合推出，倾情献上呦~~</strong></span></p>\n<p>给个关注吧 23333~~~~~~（现在每天系统就给我一个机器人的粉丝量了55555~~~~~）</p>\n<p>本节内容，我们将着重来探讨 <strong>二叉树</strong> 中特殊的两种树——<span style=\"color:#fe2c24;\"><strong>搜索二叉树 和 平衡二叉树</strong></span>。而平衡二叉树我们可以有<span style=\"color:#fe2c24;\"><strong>AVL树，红黑树</strong></span>等。</p>\n<p>我们今天就重点来说说这三种结构。</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">1、二叉搜索树</a></p>\n<p id=\"1-1%E3%80%81%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1-1%E3%80%81%E6%A6%82%E5%BF%B5\">1-1、概念</a></p>\n<p id=\"1-2%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%9F%A5-toc\" style=\"margin-left:40px;\"><a href=\"#1-2%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%9F%A5\">1-2 二叉搜索树的增、删、查</a></p>\n<p id=\"1-2-1%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%8A%A0%EF%BC%88%E7%BB%93%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#1-2-1%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%8A%A0%EF%BC%88%E7%BB%93%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%89\">1-2-1 二叉搜索树的增加（结点数据）</a></p>\n<p id=\"1-2-2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:80px;\"><a href=\"#1-2-2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE\">1-2-2二叉搜索树的查找</a></p>\n<p id=\"1-2-3%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:80px;\"><a href=\"#1-2-3%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4\">1-2-3 二叉搜索树的删除</a></p>\n<p id=\"1-2-4%C2%A0%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#1-2-4%C2%A0%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\">1-2-4  二叉搜索树的性能分析</a></p>\n<p id=\"2%E3%80%81AVLTree-toc\" style=\"margin-left:0px;\"><a href=\"#2%E3%80%81AVLTree\">2、AVLTree</a></p>\n<p id=\"2-1%20AVLTree%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#2-1%20AVLTree%E7%9A%84%E6%A6%82%E5%BF%B5\">2-1 AVLTree的概念</a></p>\n<p id=\"2-1-1%20%E5%B7%A6%E5%8D%95%E6%97%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#2-1-1%20%E5%B7%A6%E5%8D%95%E6%97%8B%EF%BC%9A\">2-1-1 左单旋：</a></p>\n<p id=\"2-1-2%20%E5%8F%B3%E5%8D%95%E6%97%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#2-1-2%20%E5%8F%B3%E5%8D%95%E6%97%8B%EF%BC%9A\">2-1-2 右单旋：</a></p>\n<p id=\"2-1-3%20%E5%B7%A6%E5%8F%B3%E5%8D%95%E6%97%8B%EF%BC%9A%E2%80%8B-toc\" style=\"margin-left:80px;\"><a href=\"#2-1-3%20%E5%B7%A6%E5%8F%B3%E5%8D%95%E6%97%8B%EF%BC%9A%E2%80%8B\">2-1-3 左右单旋：​</a></p>\n<p id=\"2-2%20%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2-2%20%E6%80%BB%E7%BB%93%EF%BC%9A\">2-2 总结：</a></p>\n<p id=\"3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91-toc\" style=\"margin-left:0px;\"><a href=\"#3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91\">3、红黑树</a></p>\n<p id=\"3-1%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#3-1%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A\">3-1 红黑树的概念：</a></p>\n<p id=\"3-2%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#3-2%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A\">3-2 红黑树的性质：</a></p>\n<p id=\"3-3%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4-toc\" style=\"margin-left:40px;\"><a href=\"#3-3%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4\">3-3 红黑树的调整</a></p>\n<p id=\"3-3-1%20%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%94%E5%8F%94%E4%B8%BA%E7%BA%A2%E3%80%82-toc\" style=\"margin-left:80px;\"><a href=\"#3-3-1%20%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%94%E5%8F%94%E4%B8%BA%E7%BA%A2%E3%80%82\">3-3-1 第一种情况：叔叔为红。</a></p>\n<p id=\"3-3-2%20%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%94%E5%8F%94%E4%B8%BA%E9%BB%91%E8%89%B2%E6%88%96%E8%80%85%E5%8F%94%E5%8F%94%E4%B8%8D%E5%AD%98%E5%9C%A8-toc\" style=\"margin-left:80px;\"><a href=\"#3-3-2%20%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%94%E5%8F%94%E4%B8%BA%E9%BB%91%E8%89%B2%E6%88%96%E8%80%85%E5%8F%94%E5%8F%94%E4%B8%8D%E5%AD%98%E5%9C%A8\">3-3-2 第二种情况：叔叔为黑色或者叔叔不存在</a></p>\n<p id=\"3-3-3%20%E9%92%88%E5%AF%B9%E5%8F%94%E5%8F%94%E4%B8%BA%E7%BA%A2%E6%88%96%E8%80%85%E5%8F%94%E5%8F%94%E4%B8%8D%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD%EF%BC%8C%E5%8D%B3%E6%96%B0%E5%A2%9E%E7%BB%93%E7%82%B9%E4%BD%8D%E4%BA%8Ep2%E7%9A%84%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%A4%84%E3%80%82%EF%BC%88%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#3-3-3%20%E9%92%88%E5%AF%B9%E5%8F%94%E5%8F%94%E4%B8%BA%E7%BA%A2%E6%88%96%E8%80%85%E5%8F%94%E5%8F%94%E4%B8%8D%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD%EF%BC%8C%E5%8D%B3%E6%96%B0%E5%A2%9E%E7%BB%93%E7%82%B9%E4%BD%8D%E4%BA%8Ep2%E7%9A%84%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%A4%84%E3%80%82%EF%BC%88%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%89\">3-3-3 针对叔叔为红或者叔叔不存的情况，还有一种可能，即新增结点位于p2的右孩子处。（情况三）</a></p>\n<p id=\"3-4%20%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:40px;\"><a href=\"#3-4%20%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83\">3-4 红黑树与AVL树的比较</a></p>\n<p id=\"3-5%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3-5%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">3-5 红黑树的应用</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">1、二叉搜索树</h1>\n<p>我们之所以将其放在这里来讲，最主要的原因就是之前我们所有模拟实现都是用C去实现的，而这些东西用C语言很难实现，<strong>所以，我们将其放在C++当中。</strong></p>\n<h2 id=\"1-1%E3%80%81%E6%A6%82%E5%BF%B5\">1-1、概念</h2>\n<p>二叉搜索树又称二叉排序树，它要么是一个空树，要么是满足以下性质的一个二叉树。</p>\n<ul><li><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</span></strong></span></li><li><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</span></strong></span></li><li><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">它的左右子树也分别为二叉搜索树</span></strong></span></li></ul>\n<p>就像下面这棵树一样：</p>\n<p><img alt=\"\" height=\"301\" src=\"..\\..\\static\\image\\dc541101449f4aae8c19a0b3b5ab91a8.png\" width=\"570\"/></p>\n<h2 id=\"1-2%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%9F%A5\">1-2 二叉搜索树的增、删、查</h2>\n<h3 id=\"1-2-1%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%8A%A0%EF%BC%88%E7%BB%93%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%89\">1-2-1 二叉搜索树的增加（结点数据）</h3>\n<p>假设我们已经有了这么一棵二叉搜索树A，那么我现在要增加一个结点key，遵循以下原则：</p>\n<blockquote>\n<p><strong>①如果原来的树A<span style=\"color:#fe2c24;\">为空</span>，那就<span style=\"color:#fe2c24;\">直接插入。</span></strong></p>\n<p><strong>②如果原来的树A<span style=\"color:#fe2c24;\">不为空</span>，按照二叉树的性质寻找插入位置：<span style=\"color:#fe2c24;\">从根结点开始，如果比根结点的数据大，那就继续在根结点的右子树中去寻找；如果比根节点的数据小，那就继续在根结点的左子树中去寻找。</span></strong></p>\n<p><strong>③直至找到空（指针）为止。</strong></p>\n<p><strong>④插入结点。</strong></p>\n</blockquote>\n<p><strong>我们举一个例子：</strong></p>\n<blockquote>\n<p>就比如上图的那个二叉搜索树，<strong>我们要插入元素12</strong>，按照步骤来：</p>\n<p>①树A不为空树。</p>\n<p>②12比5大，继续往其（根结点5的）右子树中寻找；12比7大，继续往其（结点7的）右子树中寻找；12比8大，继续往其（结点8的）右子树中寻找；12比9大，继续往其（结点9的）右子树中寻找。</p>\n<p>③此时我们发现，9的右子树为空，停止寻找。</p>\n<p>④插入新结点12。</p>\n</blockquote>\n<p>动图我就不做了，就看文字描述吧，已经说得很清楚了。而且这个点也比较简单。</p>\n<p></p>\n<h3 id=\"1-2-2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE\">1-2-2二叉搜索树的查找</h3>\n<p>与增加结点类似，查找也是同样的道理。</p>\n<p><strong>从根结点开始，如果根结点比目标结点的数值（key值）<span style=\"color:#fe2c24;\">大</span>，那么就<span style=\"color:#fe2c24;\">往其左子树找</span>，<span style=\"color:#fe2c24;\">反之则往其右子树找</span>。直到找到目标的数为止。找到则返回true，否则返回false。</strong></p>\n<p>通过我们下面的代码也可以很清晰地看出这一过程。</p>\n<p></p>\n<h3 id=\"1-2-3%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4\">1-2-3 二叉搜索树的删除</h3>\n<p>首先查找元素是否在二叉搜索树中，如果不存在，则返回, 否则要删除的结点可能分下面四种情况：</p>\n<blockquote>\n<p>a. 要删除的结点<strong>无孩子结点</strong><br/> b. 要删除的结点<strong>只有左孩子结点</strong><br/> c. 要删除的结点<strong>只有右孩子结点</strong><br/> d. 要删除的结点<strong>有左、右孩子结点</strong></p>\n</blockquote>\n<p>看起来有待删除节点有4中情况，实际情况a可以与情况b或者c合并起来，因此真正的删除过程如下：</p>\n<blockquote>\n<p>情况b：<strong>删除该结点</strong>且使<strong>被删除节点的<span style=\"color:#fe2c24;\">双亲结点</span>指向被删除节点的<span style=\"color:#fe2c24;\">左孩子结点</span></strong></p>\n<p>情况c：<strong>删除该结点</strong>且使被删除节点的双亲结点指向被删除结点的<span style=\"color:#fe2c24;\"><strong>右孩子结点</strong></span></p>\n<p>情况d：在它的右子树中<strong>寻找中序下的第一个结点<span style=\"color:#fe2c24;\">(关键码最小)</span></strong>，<strong>用它的值填补到被删除节点中，</strong>再来处理该结点的删除问题</p>\n</blockquote>\n<p>什么叫关键码最小？</p>\n<p><strong>简而言之，就是在其右子树中找到一个最小的数然后和它替换（也可以在左子树中找到一个最大的数来进行替换），我们下面的例子都是采用右子树中找到一个最小的数然后和它进行替换。</strong></p>\n<p></p>\n<p>看起来这很复杂，但是与下面的AVL树的旋转相比，这就是小菜一碟。</p>\n<p>不过删除的操作也确实是二叉搜索树中比较复杂的部分了。</p>\n<p>我们只在普通的二叉搜索树讲解删除操作，至于后面的AVLTree和红黑树的删除，原理是一样的，只是太复杂了，就不写了。</p>\n<p></p>\n<p>我们下面来看代码：<span style=\"color:#fe2c24;\"><strong>（在下面的代码中，我们将会给出思路，即解释每行代码或者某段代码是什么意思）</strong></span></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\"><strong>千言万语，都在代码中间了。</strong></span></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nnamespace K\n{\n\ttemplate&lt;class K&gt;\n\tstruct BSTreeNode\n\t{\n\t\tBSTreeNode&lt;K&gt;* _left;        //存储左孩子的结点的指针\n\t\tBSTreeNode&lt;K&gt;* _right;       //存储右孩子的结点的指针\n\t\tK _key;                      //数值（数据域）\n\t\tBSTreeNode(const K&amp; key)     //该结点的构造函数，我们初始化的时\n\t\t\t:_left(nullptr)          //候将所有的指针都赋值成空，然后key给到_key\n\t\t\t, _right(nullptr)\n\t\t\t, _key(key)\n\t\t{}\n\t};               //创建树节点，每一个树节点中，存储着左孩子和右孩子的指针\n\n\n\ttemplate &lt;class K&gt;\n\tclass BSTree                     //接下来是正式的二叉搜索树的类\n\t{\n\t\ttypedef BSTreeNode&lt;K&gt; Node;  //先进行typedef一下\n\tpublic:\n\t\tBSTree()\n\t\t\t:_root(nullptr)         //构造函数\n\t\t{}\n\n\t\t~BSTree()\n\t\t{\n\t\t\t_Destroy(_root);    //析构函数，调用_Destroy函数，前面带有_\n\t\t}                       //表示其是内置类型，我们将会把其定义为私有\n\n\t\tBSTree(const BSTree&lt;K&gt;&amp; t)\n\t\t{\n\t\t\t_root = _Copy(t._root);  //拷贝构造，我们调用_Copy函数\n\t\t}\n\t\tBSTree&lt;K&gt;&amp; operator=(BSTree&lt;K&gt; t) //操作符重载，赋值拷贝\n\t\t{\n\t\t\tswap(_root, t._root);    //通过交换结点指针的内容实现\n\t\t\treturn *this;            //返回*this，即拷贝的对象的值\n\t\t}\n\t\tbool Insert(const K&amp; key)    //插入（重点）\n\t\t{\n\t\t\tif (_root == nullptr)   //如果根为空\n\t\t\t{\n\t\t\t\t_root = new Node(key); //那就直接new一个新结点\n\t\t\t\treturn true;           //然后结束\n\t\t\t}\n\t\t\tNode* parent = nullptr;   //先定义一个parent结点，用于记录\n\t\t\tNode* cur = _root;        //存储一下根结点的数据\n\t\t\twhile (cur)               //如果cur不为空\n\t\t\t{\n\t\t\t\tif (cur-&gt;_key &lt; key)  //判断，插入的结点是比现在的结点大还是小\n\t\t\t\t{                     //即先需要查找插入的位置，如果插入的比现在的要大，\n\t\t\t\t\tparent = cur;     //先记录当前位置\n\t\t\t\t\tcur = cur-&gt;_right;//然后往右走\n\t\t\t\t}\n\t\t\t\telse if (cur-&gt;_key &gt; key)//同理，如果插入的结点比现在结点小\n\t\t\t\t{                        //先记录，再往左走\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur-&gt;_left;\n\t\t\t\t}\n\t\t\t\telse                    //否则，就直接返回false\n\t\t\t\t{                       //说明这个值已经存在了（默认不能被重复插入）\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//出来后，此时cur为空\n\t\t\tcur = new Node(key);           //找到那个位置后，然后插入进去\n\t\t\tif (parent-&gt;_key &lt; key)        //判断，看是应该插在其左边还是插在其右边\n\t\t\t{\n\t\t\t\tparent-&gt;_right = cur;      //连接起来（注意，刚刚的cur为空，得到new的新地址后\n\t\t\t\t                           //，并未和parent连接起来）\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparent-&gt;_left = cur;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t\n\n\t\tvoid Inorder()       //中序遍历，用于打印的，没啥好说的了\n\t\t{\n\t\t\t_InOrder(_root); //我们让其调用内部接口，因为这里\n\t\t\tcout &lt;&lt; endl;    //函数实现要传_root，而用户不需要\n\t\t}\n\n\t\tNode* find(const K&amp; key)    //查找结点，比较简单\n\t\t{\n\t\t\tNode* cur = _root;\n\t\t\twhile (cur) \n\t\t\t{\n\t\t\t\tif (cur-&gt;_key &lt; key)//比它大，就往右\n\t\t\t\t{\n\t\t\t\t\tcur = cur-&gt;_right;\n\t\t\t\t}\n\t\t\t\telse if (cur-&gt;_key &lt; key)//比它小，就往左\n\t\t\t\t{\n\t\t\t\t\tcur = cur-&gt;_left;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn cur;       //如果不是前两种，那就找到了，返回该结点\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nullptr;    //如果找到了空结点还没有找到，那么说明没有该结点，返回空\n\t\t}\n\t\tbool Erase(const K&amp; key)   //删除结点\n\t\t{\n\t\t\tNode* parent = nullptr;  //让parent置空，等会用于记录\n\t\t\tNode* cur = _root;       //存储_root的数据\n\t\t\twhile (cur)\n\t\t\t{\n\t\t\t\tif (cur-&gt;_key &gt; key)  //同样的道理，先去查找要删除的结点\n\t\t\t\t{\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur-&gt;_left;\n\t\t\t\t}\n\t\t\t\telse if (cur-&gt;_key &lt; key)\n\t\t\t\t{\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur-&gt;_right;\n\t\t\t\t}                     \n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//找到了，开始删\n\n\t\t\t\t\t//分成三种情况 —— 左为空，右为空和左右都不为空\n\t\t\t\t\t//左右都为空的情况属于左为空（或者右为空）的情况的一种，所以就没有单独拿出来\n\n\t\t\t\t\tif (cur-&gt;_left == nullptr)   //如果其左为空\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cur == _root)    //如果是根结点\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_root = cur-&gt;_right;  //那就直接将其右侧的结点作为根结点（因为左为空）（不论右是否为空）\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse                     //如果其不是根结点\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parent-&gt;_left == cur)//如果该结点是其父亲的左孩子\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tparent-&gt;_left = cur-&gt;_right;  //那就将父亲的左孩子变成该结点的右孩子（因为左为空）\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse                    //如果是右孩子\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tparent-&gt;_right = cur-&gt;_right;  //同理\n\t\t\t\t\t\t\t}                       //注意这里必须要去查找一下，否则可能会出现一些意想不到的错误\n\t\t\t\t\t\t\tdelete cur;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cur-&gt;_right == nullptr)  //如果右为空\n\t\t\t\t\t{\n\t\t\t\t\t\tif (parent-&gt;_left == cur)     //同理，看cur是其父亲的左孩子还是右孩子\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparent-&gt;_left = cur-&gt;_left;//如果是左孩子，那就将父亲的左孩子变成cur的左孩子（因为右为空）\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparent-&gt;_right = cur-&gt;_left;//同理\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete cur;\n\t\t\t\t\t}\n\t\t\t\t\telse   //如果左右都不为空\n\t\t\t\t\t{\n\t\t\t\t\t\t//方法一：非递归方法\n\t\t\t\t\t\t// 我们的思路是找到最大的左或者最小的右来去替换它（这里我们找的是最小的右）\n\t\t\t\t\t\t//Node* minparent = cur;           //先记录\n\t\t\t\t\t\t//Node* tp = cur-&gt;_right;          //记录右孩子\n\t\t\t\t\t\t//while (tp-&gt;_left)                //如果右孩子的左不为空\n\t\t\t\t\t\t//{                                //那就一直往下找，知道找到为nullptr\n\t\t\t\t\t\t//\tminparent = tp;\n\t\t\t\t\t\t//\ttp = tp-&gt;_left;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\t//cur-&gt;_key = tp-&gt;_key;           //将此时找到的结点的值给cur\n\t\t\t\t\t\t//if (minparent-&gt;_left == tp)     //如果它是左孩子\n\t\t\t\t\t\t//{\n\t\t\t\t\t\t//\tminparent-&gt;_left = tp-&gt;_right; //那就将其右子树给它父亲的左孩子\n\t\t\t\t\t\t//}\n\t\t\t\t\t\t//else//特殊情况        注意，这里我们虽然找的是最小的右，但是仍可能存在一种情况：即minparent-&gt;_right === tp\n\t\t\t\t\t\t\t\t\t\t\t//这种情况存在于 只有一个根结点、并且根结点只有一个右孩子，需要删除右孩子的时候，\n\t\t\t\t\t\t\t\t\t\t\t//即上面的while循环根本没有进去\n\t\t\t\t\t\t//{\n\t\t\t\t\t\t//\tminparent-&gt;_right = tp-&gt;_right;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\t//delete tp;\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//还可以这样：\n\t\t\t\t\t\t//方法二：（回调法）\n\t\t\t\t\t\tNode* minRight = cur-&gt;_right;  //同样先记录，记录的是右孩子（因为要找最小的右）\n\t\t\t\t\t\twhile (minRight-&gt;_left)        //循环开始，直到找到空（即直到找到最小的右）\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tminRight = minRight-&gt;_left;\n\t\t\t\t\t\t} //找到之后\n\t\t\t\t\t\tK min = minRight-&gt;_key;      //将其存储起来\n\t\t\t\t\t\tthis-&gt;Erase(min);             //回调该函数，删除（因为此时存储min结点一定有左孩子为空）\n\t\t\t\t\t\tcur-&gt;_key = min;              //把刚刚记录的值给cur，即完成了互换\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;                //没找到就删不了，返回false\n\t\t}\n\n\t\tNode* findR(const K&amp; key)     //查找\n\t\t{\n\t\t\treturn _FindR(_root, key); //直接调用内部函数，实现一层封装\n\t\t}\n\t\tbool InsertR(const K&amp; key)   //插入同理（后面带有R的表示用递归的方法完成）\n\t\t{\n\t\t\treturn _InsertR(_root, key);\n\t\t}\n\tprivate:\n\t\tNode* _root;\n\t\tNode* _FindR(Node* root, const K&amp; key)   //递归的方法查找（上面用的是迭代）\n\t\t{\n\t\t\tif (root == nullptr)//如果找到空还没有找到，就返回空，表明没有找到\n\t\t\t{\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tif (root-&gt;_key &lt; key)   //如果查找的数比当前结点要大，\n\t\t\t{\n\t\t\t\treturn _FindR(root-&gt;_right, key);//那就继续往右找\n\t\t\t}\n\t\t\telse if (root-&gt;_key &gt; key)\n\t\t\t{\n\t\t\t\treturn _FindR(root-&gt;_left, key); //反之，就继续往左找\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn root;        //找到了的话，就返回该结点\n\t\t\t}\n\t\t}\n\t\tbool _InsertR(Node*&amp; root, const K&amp; key)//递归方法插入\n\t\t{\n\t\t\tif (root == NULL)           //本质还是先查找，找到之后去插入\n\t\t\t{\n\t\t\t\troot = new Node(key);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (root-&gt;_key &lt; key)\n\t\t\t{\n\t\t\t\treturn _InsertR(root-&gt;_right, key);\n\t\t\t}\n\t\t\telse if (root-&gt;_key &gt; key)\n\t\t\t{\n\t\t\t\treturn _InsertR(root-&gt;_left, key);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid _Destroy(Node* root)        //递归式删除\n\t\t{\n\t\t\tif (root == nullptr)\n\t\t\t\treturn;\n\t\t\t_Destroy(root-&gt;_left);\n\t\t\t_Destroy(root-&gt;_right);\n\t\t\tdelete root;\n\t\t}\n\t\tNode* _Copy(Node* root)   \n\t\t{\n\t\t\tif (root == nullptr)//一定要记得写如果是空就返回，否则将会栈溢出\n\t\t\t{\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tNode* copyNode = new Node(root-&gt;_key); //先定义一个结点，作为根结点，而后为递归产生的结点\n\t\t\tcopyNode-&gt;_left = _Copy(root-&gt;_left);  //然后一一拷贝，递归式拷贝（可以画一个图去感受）\n\t\t\tcopyNode-&gt;_right = _Copy(root-&gt;_right);\n\t\t\treturn copyNode;\n\n\t\t}\n\t\tvoid _InOrder(Node* root)\n\t\t{                                  //中序遍历，没啥好说的了\n\t\t\tif (root == nullptr)\n\t\t\t\treturn;\n\t\t\t_InOrder(root-&gt;_left);\n\t\t\tcout &lt;&lt; root-&gt;_key &lt;&lt; \" \";\n\t\t\t_InOrder(root-&gt;_right);\n\t\t}\n\t};\n}</code></pre>\n<p>上面的属于Key模型，<span style=\"color:#fe2c24;\"><strong>实际上，我们还有&lt;K，V&gt;模型</strong></span></p>\n<p>&lt;K，V&gt;是什么意思呢？</p>\n<blockquote>\n<p>1. K模型：K模型即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值。<br/> 比如：给一个单词word，判断该单词是否拼写正确，具体方式如下：<br/><strong>以单词集合中的每个单词作为key，构建一棵二叉搜索树</strong><br/><strong>在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。</strong></p>\n<p>2. KV模型：每一个关键码key，<strong>都有与之对应的值Value</strong>，即&lt;Key, Value&gt;的键值对。该种方式在现实生活中非常常见：<strong>比如英汉词典就是英文与中文的对应关系</strong>，通过英文可以快速找到与其对应的中文，英文单词与其对应的<strong>中文&lt;word, chinese&gt;</strong>就构成一种键值对；</p>\n</blockquote>\n<p>再比如统计单词次数，统计成功后，<strong>给定单词就可快速找到其出现的次数，</strong>单词与其出现次数就是<strong>&lt;word, count&gt;</strong>就构成一种键值对。<br/> 比如：实现一个简单的英汉词典dict，可以通过英文找到与其对应的中文。</p>\n<p></p>\n<p></p>\n<p>这里说一下，我们都是用pair&lt;&gt;来进行输入的。至于pair是啥</p>\n<p><img alt=\"\" height=\"266\" src=\"..\\..\\static\\image\\33ee44dc2d4f4fd0b9ee9b8d27d7343a.png\" width=\"1200\"/></p>\n<p>可以认为其实一个类，然后有两个模板。 </p>\n<p></p>\n<p>实际上，有了上面的K模型之后，我们稍微修改修改就可以变成我们想要的&lt;K，V&gt;模型了。</p>\n<p>至于要改什么地方，笔者在这里只能说：改的地方很少，至于具体改了哪些地方，请读者自行欣赏吧。(这个地方只需要和上面的代码对比一下就可以了)</p>\n<pre><code>namespace KV\n{\n\ttemplate&lt;class K, class V&gt;\n\tstruct BSTreeNode                \n\t{\n\t\tBSTreeNode&lt;K ,V&gt;* _left;\n\t\tBSTreeNode&lt;K,V&gt;* _right;\n\t\tK _key;\n\t\tV _value;\n\t\tBSTreeNode(const K&amp; key,const V&amp; value)\n\t\t\t:_left(nullptr)\n\t\t\t, _right(nullptr)\n\t\t\t, _key(key)\n\t\t\t,_value(value)\n\t\t{}\n\t};\n\n\n\ttemplate &lt;class K, class V&gt;\n\tclass BSTree\n\t{\n\t\ttypedef BSTreeNode&lt;K ,V&gt; Node;\n\tpublic:\n\t\tBSTree()\n\t\t\t:_root(nullptr)\n\t\t{}\n\t\t//涉及深浅拷贝，需要实现拷贝构造\n\t\tvoid Destroy()\n\t\t{\n\t\t\t_Destroy(_root);\n\t\t}\n\n\t\tBSTree(const BSTree&lt;K,V&gt;&amp; t)\n\t\t{\n\t\t\t_root = _Copy(t._root);\n\t\t}\n\t\tBSTree&lt;K,V&gt;&amp; operator=(BSTree&lt;K,V&gt; t)\n\t\t{\n\t\t\tswap(_root, t._root);\n\t\t\treturn *this;\n\t\t}\n\t\t//bool Insert(const K&amp; key)\n\t\t//{\n\t\t//\tif (_root == nullptr)\n\t\t//\t{\n\t\t//\t\t_root = new Node(key);\n\t\t//\t\treturn true;\n\t\t//\t}\n\t\t//\tNode* parent = nullptr;\n\t\t//\tNode* cur = _root;\n\t\t//\twhile (cur)\n\t\t//\t{\n\t\t//\t\tif (cur-&gt;_key &lt; key)\n\t\t//\t\t{\n\t\t//\t\t\tparent = cur;\n\t\t//\t\t\tcur = cur-&gt;_right;\n\t\t//\t\t}\n\t\t//\t\telse if (cur-&gt;_key &gt; key)\n\t\t//\t\t{\n\t\t//\t\t\tparent = cur;\n\t\t//\t\t\tcur = cur-&gt;_left;\n\t\t//\t\t}\n\t\t//\t\telse\n\t\t//\t\t{\n\t\t//\t\t\treturn false;\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tcur = new Node(key);           //找到那个位置，然后插入进去\n\t\t//\tif (parent-&gt;_key &lt; key)\n\t\t//\t{\n\t\t//\t\tparent-&gt;_right = cur;\n\t\t//\t}\n\t\t//\telse\n\t\t//\t{\n\t\t//\t\tparent-&gt;_left = cur;\n\t\t//\t}\n\t\t//\treturn true;\n\t\t//}\n\n\t\tvoid _InOrder(Node* root)\n\t\t{\n\t\t\tif (root == nullptr)\n\t\t\t\treturn;\n\t\t\t_InOrder(root-&gt;_left);\n\t\t\tcout &lt;&lt; root-&gt;_key &lt;&lt; \":\"&lt;&lt;root-&gt;_value;\n\t\t\t_InOrder(root-&gt;_right);\n\t\t}\n\t\tvoid Inorder()\n\t\t{\n\t\t\t_InOrder(_root);\n\t\t\tcout &lt;&lt; endl;\n\t\t}\n\t\t/*Node* find(const K&amp; key)\n\t\t{\n\t\t\tNode* cur = _root;\n\t\t\twhile (cur)\n\t\t\t{\n\t\t\t\tif (cur-&gt;_key &lt; key)\n\t\t\t\t{\n\t\t\t\t\tcur = cur-&gt;_right;\n\t\t\t\t}\n\t\t\t\telse if (cur-&gt;_key &lt; key)\n\t\t\t\t{\n\t\t\t\t\tcur = cur-&gt;_left;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nullptr;\n\t\t}*/\n\t\t\n\n\t\tbool EraseR(const K&amp; key)\n\t\t{\n\t\t\treturn _EraseR(_root, key);\n\t\t}\n\n\n\t\tNode* findR(const K&amp; key)\n\t\t{\n\t\t\treturn _FindR(_root, key);\n\t\t}\n\t\tbool InsertR(const K&amp; key,const V&amp; value)\n\t\t{\n\t\t\treturn _InsertR(_root, key,value);\n\t\t}\n\tprivate:\n\t\tNode* _root;\n\t\tNode* _FindR(Node* root, const K&amp; key)\n\t\t{\n\t\t\tif (root == nullptr)\n\t\t\t{\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tif (root-&gt;_key &lt; key)\n\t\t\t{\n\t\t\t\treturn _FindR(root-&gt;_right, key);\n\t\t\t}\n\t\t\telse if (root-&gt;_key &gt; key)\n\t\t\t{\n\t\t\t\treturn _FindR(root-&gt;_left, key);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn root;\n\t\t\t}\n\t\t}\n\t\tbool _InsertR(Node*&amp; root, const K&amp; key,const V&amp; value)\n\t\t{\n\t\t\tif (root == NULL)\n\t\t\t{\n\t\t\t\troot = new Node(key,value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (root-&gt;_key &lt; key)\n\t\t\t{\n\t\t\t\treturn _InsertR(root-&gt;_right, key, value);\n\t\t\t}\n\t\t\telse if (root-&gt;_key &gt; key)\n\t\t\t{\n\t\t\t\treturn _InsertR(root-&gt;_left, key, value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tbool _EraseR(Node*&amp; root, const K&amp; key)\n\t\t{\n\t\t\tif (root == nullptr)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (root-&gt;_key == key)\n\t\t\t{\n\t\t\t\t/*Node* pt = root-&gt;_right;\n\t\t\t\twhile (pt-&gt;_left != NULL)\n\t\t\t\t{\n\t\t\t\t\tpt = pt-&gt;_left;\n\t\t\t\t}\n\t\t\t\troot-&gt;_key = pt-&gt;_key;\n\t\t\t\tdelete pt;*/\n\t\t\t\tif (root-&gt;_left == nullptr &amp;&amp; root-&gt;_right == nullptr)\n\t\t\t\t{\n\t\t\t\t\tdelete root;\n\t\t\t\t\troot = nullptr;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (root-&gt;_left == nullptr)\n\t\t\t\t{\n\t\t\t\t\tNode* del = root;\n\t\t\t\t\troot = root-&gt;_right;\n\t\t\t\t\tdelete del;\n\t\t\t\t\t//root = root-&gt;_right;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (root-&gt;_right == nullptr)\n\t\t\t\t{\n\t\t\t\t\tNode* del = root;\n\t\t\t\t\troot = root-&gt;_left;\n\t\t\t\t\tdelete del;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNode* minparent = root;\n\t\t\t\t\tNode* tp = root-&gt;_right;\n\t\t\t\t\twhile (tp-&gt;_left)\n\t\t\t\t\t{\n\t\t\t\t\t\tminparent = tp;\n\t\t\t\t\t\ttp = tp-&gt;_left;\n\t\t\t\t\t}\n\t\t\t\t\t//swap(tp,cur)//不需要这么复杂\n\n\t\t\t\t\t//还要再进一步地将其连接上\n\t\t\t\t\troot-&gt;_key = tp-&gt;_key;\n\t\t\t\t\tif (minparent-&gt;_left == tp)\n\t\t\t\t\t{\n\t\t\t\t\t\tminparent-&gt;_left = tp-&gt;_right;\n\t\t\t\t\t}\n\t\t\t\t\telse//特殊情况\n\t\t\t\t\t{\n\t\t\t\t\t\tminparent-&gt;_right = tp-&gt;_right;\n\t\t\t\t\t}\n\t\t\t\t\tdelete tp;\n\t\t\t\t\t//Node*&amp; pt = root-&gt;_right;//不可以这样去删除，这里只能中规中矩的删除，因为我们的规则关系是不能够乱动的\n\t\t\t\t\t//while (pt-&gt;_left)\n\t\t\t\t\t//{\n\t\t\t\t\t//\tpt = pt-&gt;_left;\n\t\t\t\t\t//}\n\t\t\t\t\t//K min = pt-&gt;_key;             //保存数据的智慧\n\t\t\t\t\t// V valuemin = pt-&gt;_value;\n\t\t\t\t\t//this-&gt;_EraseR(pt, min);\n\t\t\t\t\t//root-&gt;_key = min;\n\t\t\t\t\t//root-&gt;value = valuemin\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (root-&gt;_key &gt; key)\n\t\t\t{\n\t\t\t\treturn _EraseR(root-&gt;_left, key);\n\t\t\t}\n\t\t\telse if (root-&gt;_key &lt; key)\n\t\t\t{\n\t\t\t\treturn _EraseR(root-&gt;_right, key);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tvoid _Destroy(Node* root)\n\t\t{\n\t\t\tif (root == nullptr)\n\t\t\t\treturn;\n\t\t\t_Destroy(root-&gt;_left);\n\t\t\t_Destroy(root-&gt;_right);\n\t\t\tdelete root;\n\t\t}\n\t\tNode* _Copy(Node* root)\n\t\t{\n\t\t\tif (root == nullptr)\n\t\t\t{\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tNode* copyNode = new Node(root-&gt;_key,root-&gt;_value);\n\t\t\tcopyNode-&gt;_left = _Copy(root-&gt;_left);\n\t\t\tcopyNode-&gt;_left = _Copy(root-&gt;_right);\n\t\t\treturn copyNode;\n\n\t\t}\n\t};\n}</code></pre>\n<p> 关于这样的KV模型，我们下面还会反复地提到。</p>\n<p></p>\n<p>注意：</p>\n<p>&lt;单词，中文含义&gt;为键值对构造二叉搜索树，注意：二叉搜索树需要比较，<strong>键值对比较时只比较<br/> Key</strong></p>\n<p>查询英文单词时，只需给出英文单词，就可快速找到与其对应的key</p>\n<p></p>\n<p>我们以上面的代码给出一个例子：</p>\n<pre><code>#include \"BSTree.h\"\n\nvoid test1()\n{\n\tK::BSTree&lt;int&gt; t;\n\tint a[] = { 5,3,4,1,7,8,2,6,0,9 };\n\tfor (auto e : a)\n\t{\n\t\tt.InsertR(e);\n\t}\n\tt.Inorder();\n\tt.Erase(7);\n\tt.EraseR(5);\n\tt.Inorder();\n}\n\nvoid test2()\n{\n\tKV::BSTree&lt;string, string&gt; dict;\n\tdict.InsertR(\"string\", \"字符串\");\n\tstring str;\n\twhile (cin &gt;&gt; str)\n\t{\n\t\tKV::BSTreeNode&lt;string, string&gt;* ret = dict.findR(str);\n\t\tif (ret == nullptr)\n\t\t{\n\t\t\tcout &lt;&lt; \"拼写错误\" &lt;&lt; endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout &lt;&lt;  \"中文翻译:\" &lt;&lt; ret-&gt;_value &lt;&lt; endl;\n\t\t}\n\t}\n}\nvoid test3()\n{\n\tstring arr[] = {\"苹果\",\"香蕉\", \"苹果\", \"香蕉\", \"苹果\" ,\"西瓜\" ,\"香蕉\" };\n\tKV::BSTree&lt;string, int&gt; countTree;\n\tfor (const auto&amp; str : arr)\n\t{\n\t\tauto ret = countTree.findR(str);\n\t\tif (ret == nullptr)\n\t\t{\n\t\t\tcountTree.InsertR(str, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret-&gt;_value++;\n\t\t}\n\t}\n\tcountTree.Inorder();\n}\n\nint main()\n{\n\ttest3();\n    return 0;\n}</code></pre>\n<p>运行截图（如下）：<br/><img alt=\"\" height=\"117\" src=\"..\\..\\static\\image\\299ec598faa7455f9df43295c834a071.png\" width=\"386\"/></p>\n<h3 id=\"1-2-4%C2%A0%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\">1-2-4  二叉搜索树的性能分析</h3>\n<p>插入和删除操作都必须先查找，<strong>查找效率代表了二叉搜索树中各个操作的性能。</strong></p>\n<p>对有n个结点的二叉搜索树，若每个元素查找的概率相等，<span style=\"color:#fe2c24;\"><strong>则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数</strong>，</span><strong>即结点越深，则比较次数越多。</strong></p>\n<p>但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树</p>\n<blockquote>\n<p>最优情况下，二叉搜索树为完全二叉树，其平均比较次数为：<strong>logN</strong></p>\n<p>最差情况下，二叉搜索树退化为单支树，其平均比较次数为：<strong>N/2</strong></p>\n</blockquote>\n<p><strong>那能否进行改进，不论按照什么次序插入关键码，都可以是二叉搜索树的性能最佳？</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>答案就是AVLTree.</strong></span></p>\n<p></p>\n<p>我们接下来就说AVLTree</p>\n<h1 id=\"2%E3%80%81AVLTree\">2、AVLTree</h1>\n<h2 id=\"2-1%20AVLTree%E7%9A%84%E6%A6%82%E5%BF%B5\">2-1 AVLTree的概念</h2>\n<p>二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法<strong>：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。</strong></p>\n<p></p>\n<p>说人话：<span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">在二叉搜索树的基础上，每一棵树的结点都可以认为存在一个平衡因子，平衡因子=右子树的深度-左子树的深度。通过一系列骚操作，能够使得平衡因子始终保持在 -1~1 之间。</span></strong></span></p>\n<p>这里需要注意一点，<span style=\"color:#fe2c24;\"><strong>定义并不是说一定要有这个“平衡因子”这个概念，</strong></span><strong>你可以没有，但是你要保证左子树的深度和右子树的深度的差的绝对值在1之内（小于等于1）。</strong></p>\n<p>而我们为了方便，就设立了这么一个平衡因子，便于我们调控。</p>\n<p></p>\n<p>现在问题的关键就是骚操作到底是什么操作？</p>\n<p>这里笔者也就不卖关子了，也懒得通过引例啥的去一步一步引入了，直接说结论：</p>\n<p><strong>当插入一个结点之后，<span style=\"color:#fe2c24;\">如果父节点的平衡因子变成了0，那么停止往上计算</span>，插入完毕；（理由很简单，因为这个时候代表着插入新增结点并没有改变树的深度）</strong></p>\n<p><strong>如果父节点的平衡因子为1或者-1，那么需要继续往上去算，<span style=\"color:#fe2c24;\">即需要再去算父节点的父节点的平衡因子。</span></strong></p>\n<p>当平衡因子的绝对值超过1时，<strong>我们有<span style=\"color:#fe2c24;\">四种方法</span>来去让它重新会到原有的平衡，</strong>使平衡因子的绝对值回到1之内。</p>\n<p>四种方法分别为：</p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">左单旋；</span></strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">右单旋；</span></strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">左右单旋；</span></strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">右左单旋。</span></strong></span></p>\n<p><strong>后面两个从字面意思就可以看出其会前面两种的组合。</strong></p>\n<p>我们来分别说说吧：</p>\n<h3 id=\"2-1-1%20%E5%B7%A6%E5%8D%95%E6%97%8B%EF%BC%9A\">2-1-1 左单旋：</h3>\n<p><img alt=\"\" height=\"282\" src=\"..\\..\\static\\image\\62edfc0f9623440980038f783a12d9da.png\" width=\"977\"/></p>\n<p> 我们可以这样来去理解：<strong>当出现<span style=\"color:#fe2c24;\">右右这样的情况</span>，使平衡因子失衡时，原有的<span style=\"color:#fe2c24;\">父亲节点</span>（值为30的结点）<span style=\"color:#fe2c24;\">将60结点的左孩子挤掉，自己呢跑去卖乖，当它的左孩子</span>。那么结点60原有的左孩子被挤掉之后<span style=\"color:#fe2c24;\">，其左孩子就成孤儿了，所以要被领养</span>，而刚好<span style=\"color:#fe2c24;\">结点30</span>此时没有右孩子了，所以<span style=\"color:#fe2c24;\">就去做结点30的右孩子。</span></strong></p>\n<p>当然，这里<strong>只是一种记忆方式</strong>，<strong>实际的原理要求是要遵循二叉搜索树来完成的。</strong></p>\n<p>具体过程见上图。</p>\n<p>至于代码，我们马上就说。</p>\n<p></p>\n<p>再来看</p>\n<h3 id=\"2-1-2%20%E5%8F%B3%E5%8D%95%E6%97%8B%EF%BC%9A\">2-1-2 右单旋：</h3>\n<p><img alt=\"\" height=\"238\" src=\"..\\..\\static\\image\\4f7d97568c42486b9bab001747e36e5b.png\" width=\"987\"/></p>\n<p> 这种情况相当于左左的情况——<strong>插入的结点在最左边，左边连成一条线。</strong></p>\n<p>右单旋和左单旋的原理是一样的。</p>\n<p><strong>首先，30的右孩子（b）拿出来，让60去做30的右孩子，再让30原来的右孩子（b）去做60的左孩子。</strong></p>\n<p></p>\n<h3 id=\"2-1-3%20%E5%B7%A6%E5%8F%B3%E5%8D%95%E6%97%8B%EF%BC%9A%E2%80%8B\">2-1-3 左右单旋：<img alt=\"\" height=\"570\" src=\"..\\..\\static\\image\\280782bfa453458fa8c4408ab702acfd.png\" width=\"912\"/></h3>\n<p><strong> 先左单旋，再右单旋。</strong></p>\n<p>运用场景：<strong>其是一条折线。<span style=\"color:#fe2c24;\">即90（平衡因子超出的位置）、30、60和要新增的结点，其是一条折线。</span></strong></p>\n<p>因为你会发现，<strong>你单单只进行一次左单旋，是无法做到将整棵树弄平衡的。</strong></p>\n<p>折线开口朝右，那么就是左右单旋——<strong>即先左单旋，使得30、60、90在同一条线上</strong>（只是感官上能够看出其是在同一条线上）<strong>，然后再右单旋。</strong>（具体过程如上图）</p>\n<p></p>\n<p>右左单旋：</p>\n<p><img alt=\"\" height=\"646\" src=\"..\\..\\static\\image\\c49776c506df43b99e64ffe6654fe704.png\" width=\"877\"/></p>\n<p>关于其具体旋转过程，我们就不再赘述了，各位类比即可。</p>\n<p></p>\n<h2 id=\"2-2%20%E6%80%BB%E7%BB%93%EF%BC%9A\">2-2 总结：</h2>\n<p><br/> 假如以pParent为根的子树不平衡，即pParent的平衡因子为2或者-2，分以下情况考虑</p>\n<blockquote>\n<p>1. pParent的平衡因子为2，说明pParent的右子树高，设pParent的右子树的根为pSubR<br/><strong>当pSubR的平衡因子为1时，执行左单旋<br/> 当pSubR的平衡因子为-1时，执行右左双旋</strong></p>\n<p>2. pParent的平衡因子为-2，说明pParent的左子树高，设pParent的左子树的根为pSubL<br/><strong>当pSubL的平衡因子为-1是，执行右单旋<br/> 当pSubL的平衡因子为1时，执行左右双旋</strong><br/> 旋转完成后，原pParent为根的子树个高度降低，已经平衡，不需要再向上更新。</p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">即父子的平衡因子是一正一负，那么就是双旋；如果是同号，那就是单旋。</span></strong></span></p>\n</blockquote>\n<p>接下来我们来看代码：（该有的代码注释已经全部标注出来了，一切尽在代码中）</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;assert.h&gt;\n#include&lt;string&gt;\nusing namespace std;\n\ntemplate&lt;class K, class V&gt;\nstruct AVLTreeNode\n{\n\tAVLTreeNode&lt;K, V&gt;* _left;\n\tAVLTreeNode&lt;K, V&gt;* _right;\n\tAVLTreeNode&lt;K, V&gt;* _parent;  //弄成一个三叉链\n\n\tint _bf;//暂且将其当作平衡因子\n\n\tpair&lt;K, V&gt; _kv;//好处是我如果返回值或者迭代器的时候，我可以直接就返回两个\n\t//解释一下这里的pair，实际上其就是一个类，它有两个值，一个用来存储key,一个用来存储value\n\tAVLTreeNode(const pair&lt;K, V&gt;&amp; kv)        //结点的构造函数\n\t\t:_left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t\t, _bf(0)\n\t\t,_kv(kv)\n\t{}\n};\n\n\ntemplate&lt;class K, class V&gt;\nclass AVLTree\n{\npublic:\n\ttypedef AVLTreeNode&lt;K, V&gt; Node;   \n\tAVLTree()           //树的构造函数\n\t\t:_root(nullptr)\n\t{}\n\n\tvoid _Destroy(Node* root)   //销毁函数（类比二叉搜索树）\n\t{\n\t\tif (root == nullptr)\n\t\treturn;\n\t\t_Destroy(root-&gt;_left);\n\t\t_Destroy(root-&gt;_right);\n\t\tdelete root;\n\t}\n\n\t~AVLTree()//（类比二叉搜索树）\n\t{\n\t\t_Destroy(_root);\n\t\t_root = nullptr;\n\t}\n\t//拷贝构造和复制需要深拷贝\n\n\tpair&lt;Node*,bool&gt; Insert(const pair&lt;K, V&gt;&amp; kv)       //我们重点来看插入\n\t{\n\t\tif (_root == nullptr)                           //前面该怎么做和搜索二叉树是一样的\n\t\t{\n\t\t\t_root = new Node(kv);                      \n\t\t\treturn make_pair(_root,true);\n\t\t}\n\t\tNode* parent = _root, * cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur-&gt;_kv.first &gt; kv.first)\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_left;\n\t\t\t}\n\t\t\telse if (cur-&gt;_kv.first &lt; kv.first)\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn make_pair(cur,false);\n\t\t\t}\n\t\t}\n\t\tcur = new Node(kv);\n\t\tNode* newnode = cur;\n\t\tif (parent-&gt;_kv.first &lt; kv.first)\n\t\t{\n\t\t\tparent-&gt;_right = cur;\n\t\t\tcur-&gt;_parent = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent-&gt;_left = cur;\n\t\t\tcur-&gt;_parent = parent;\n\t\t}\n\n\t\t//从现在开始，需要去控制平衡。这也是AVLTree和普通二叉搜索树有区别的开始\n\n\t\t//控制平衡\n\t\t//1、控制平衡因子\n\t\twhile (cur != _root)          //如果插入的cur不是根结点\n\t\t{\n\t\t\tif (parent-&gt;_right == cur)  //如果cur是右孩子\n\t\t\t{\n\t\t\t\tparent-&gt;_bf++;          //父亲的平衡因子++\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparent-&gt;_bf--;           //否则就--\n\t\t\t}\n\t\t\tif (parent-&gt;_bf == 0)       //如果此时父亲结点的平衡因子为0，说明新结点的增加并未改变子树的高度\n\t\t\t{\n\t\t\t\tbreak;                  //那么就停止调节，直接跳出循环\n\t\t\t}\n\t\t\telse if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)\n\t\t\t{\n\t\t\t\t//parent所在子树的高度变了，会影响parent的parent\n\t\t\t\t//继续往上更新\n\t\t\t\tcur = cur-&gt;_parent;       //把cur-&gt;_parent给cur\n\t\t\t\tparent = parent-&gt;_parent; //parent的_parent给cur\n\t\t\t}\n\t\t\telse if(parent -&gt;_bf == 2||parent-&gt;_bf ==-2)//倘若为2或者-2\n\t\t\t{\n\t\t\t\t//需要进行平衡调节\n\t\t\t\tif (parent-&gt;_bf == -2)     \n\t\t\t\t{\n\t\t\t\t\tif (cur-&gt;_bf == -1)  //如果是-2和-1，为左左，\n\t\t\t\t\t{\n\t\t\t\t\t\t//那就进行右单旋\n\t\t\t\t\t\tRotateR(parent);\n\t\t\t\t\t}\n\t\t\t\t\telse //  cur-&gt;_bf == 1，左右异号，折现开口向右\n\t\t\t\t\t{\n\t\t\t\t\t\t//那就进行左右双旋\n\t\t\t\t\t\tRotateLR(parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse  //parent-&gt;_bf == 2\n\t\t\t\t{\n\t\t\t\t\tif (cur-&gt;_bf == 1)//为右右\n\t\t\t\t\t{\n\t\t\t\t\t\tRotateL(parent);//左单旋\n\t\t\t\t\t}\n\t\t\t\t\telse//cur-&gt;_bf == -1  异号且折线开口向左\n\t\t\t\t\t{\n\t\t\t\t\t\tRotateRL(parent);//进行右左双旋\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;  //旋转后直接跳出\n\t\t\t}\n\t\t\telse  //如果都不是上面的情况，说明调节的有问题，直接结束进程\n\t\t\t{\n\t\t\t\tassert(false);\n\t\t\t\texit(-1);\n\t\t\t}\n\n\t\t}\n\t\treturn make_pair(newnode,true);  //插入成功，返回新结点和true\n\t}\n\n\tV&amp; operator[](const K&amp; key)  //对[]进行重载\n\t{\n\t\tpair&lt;Node*, bool&gt; ret = Insert(make_pair(key, V()));//直接调用Insert函数\n\t\treturn ret.first-&gt;_kv.second;                //返回其Node结点的value\n\t}\n\n\tvoid RotateLR(Node* parent)    //左右双旋\n\t{\n\t\tNode* subL = parent-&gt;_left; \n\t\tNode* subLR = subL-&gt;_right;//先将左右结点进行记录\n\t\tint bf = subLR-&gt;_bf;       //记录平衡因子\n\n\t\tRotateL(parent-&gt;_left);//先调用左单旋（以parent的左结点为函数的parent）\n\t\tRotateR(parent);       //再调用右单旋\n\t\tif (bf == -1)          //接下来分情况讨论，去调节平衡因子\n\t\t{\n\t\t\tsubL-&gt;_bf = 0;\n\t\t\tparent-&gt;_bf = 1;\n\t\t\tsubLR-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == 1)\n\t\t{\n\t\t\tsubL-&gt;_bf = 0;\n\t\t\tparent-&gt;_bf = -1;\n\t\t\tsubLR-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == 0)\n\t\t{\n\t\t\tsubL-&gt;_bf = 0;\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubLR-&gt;_bf = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);\n\t\t}\n\t\t//再去调节平衡因子\n\t}\n\n\tvoid RotateRL(Node* parent)\n\t{\n\t\tNode* subR = parent-&gt;_right;\n\t\tNode* subRL = subR-&gt;_left;\n\t\tint bf = subRL-&gt;_bf;\n\t\tRotateR(parent-&gt;_right);\n\t\tRotateL(parent);\n\n\t\t//平衡因子更新\n\t\tif (bf == 1)\n\t\t{\n\t\t\tsubR-&gt;_bf = 0;\n\t\t\tparent-&gt;_bf = -1;\n\t\t\tsubRL-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == -1)\n\t\t{\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubR-&gt;_bf = 1;\n\t\t\tsubRL-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == 0)\n\t\t{\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubR-&gt;_bf = 0;\n\t\t\tsubRL-&gt;_bf = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\n\tvoid RotateL(Node* parent)    //左单旋\n\t{\n\t\tNode* subR = parent-&gt;_right;   \n\t\tNode* subRL = subR-&gt;_left;\n\t\tNode* parentparent = parent-&gt;_parent;  //先记录\n\t\tparent-&gt;_right = subRL;\n\t\tif (subRL)\n\t\t{\n\t\t\tsubRL-&gt;_parent = parent;\n\t\t}   //两个一组\n\t\tsubR-&gt;_left = parent;\n\t\tparent-&gt;_parent = subR;//两个一组\n\n\t\t//连接主体，找到组织\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = subR;\n\t\t\tsubR-&gt;_parent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (parentparent-&gt;_left == parent)\n\t\t\t{\n\t\t\t\tparentparent-&gt;_left = subR;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparentparent-&gt;_right = subR;\n\t\t\t\t\n\t\t\t}\n\t\t\tsubR-&gt;_parent = parentparent;\n\t\t}\n\t\tsubR-&gt;_bf = parent-&gt;_bf = 0;\n\t}\n\n\tvoid RotateR(Node* parent) //右单旋\n\t{\n\t\tNode* subL = parent-&gt;_left;\n\t\tNode* subLR = subL-&gt;_right;\n\t\tparent-&gt;_left = subLR;\n\t\tif (subLR)\n\t\t{\n\t\t\tsubLR-&gt;_parent = parent;\n\t\t}\n\t\tsubL-&gt;_right = parent;\n\t\tNode* parentparent = parent-&gt;_parent;\n\t\tparent-&gt;_parent = subL;\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = subL;\n\t\t\t_root-&gt;_parent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (parentparent-&gt;_left == parent)\n\t\t\t{\n\t\t\t\tparentparent-&gt;_left = subL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparentparent-&gt;_right = subL;\n\t\t\t}\n\t\t\tsubL-&gt;_parent = parentparent;\n\t\t}\n\t\tsubL-&gt;_bf = parent-&gt;_bf = 0;\n\t}\n\n\n\tNode* Find(const K&amp; key)\n\t{\n\t\tNode* cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur-&gt;_kv.first &lt; key)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse if (cur-&gt;_kv.first &gt; key)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn cur;\n\t\t\t}\n\t\t}\n\t\treturn nullptr;\n\t}\n\tbool Erase(const K&amp; key)\n\t{\n\t\t//自己有兴趣实现\n\t\treturn false;\n\t}\n\n\n\n\tvoid InOrder()\n\t{\n\t\t_InOrder(_root);\n\t}\n\n\n\tbool IsAVLTree()\n\t{\n\t\treturn _IsBalance(_root);\n\t}\n\nprivate:\n\tNode* _root;\n\tvoid _InOrder(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_InOrder(root-&gt;_left);\n\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; \":\" &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;\n\t\t_InOrder(root-&gt;_right);\n\t}\n\n\tbool _IsBalance(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tint leftHeight = _Height(root-&gt;_left);\n\t\tint rightHeight = _Height(root-&gt;_right);\n\t\tif (rightHeight - leftHeight != root-&gt;_bf)\n\t\t{\n\t\t\tcout &lt;&lt; \"平衡因子异常\" &lt;&lt; root-&gt;_kv.first &lt;&lt; endl;\n\t\t\treturn false;\n\t\t}\n\t\treturn abs(rightHeight - leftHeight) &lt; 2\n\t\t\t&amp;&amp; _IsBalance(root-&gt;_left)\n\t\t\t&amp;&amp; _IsBalance(root-&gt;_right);\n\t}\n\n\n\tint _Height(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tint leftHeight = _Height(root-&gt;_left);\n\t\tint rightHeight = _Height(root-&gt;_right);\n\t\treturn rightHeight &gt; leftHeight ? rightHeight + 1 : leftHeight + 1;\n\t}\n};</code></pre>\n<p>这就是AVLTree。</p>\n<p></p>\n<p>那红黑树呢？</p>\n<p>我们继续来说。</p>\n<h1 id=\"3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91\">3、红黑树</h1>\n<h2 id=\"3-1%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A\">3-1 红黑树的概念：</h2>\n<p>红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p>\n<p>对于红黑树而言，其可以理解为是近似平衡；而我们刚刚说的AVLTree，是严格平衡。</p>\n<h2 id=\"3-2%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A\">3-2 红黑树的性质：</h2>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>1. 每个结点不是红色就是黑色<br/> 2. 根节点是黑色的<br/> 3. 如果一个节点是红色的，则它的两个孩子结点是黑色的（不能有两个连续的红色结点）<br/> 4. 对于每个结点，从该结点到其所有后代叶结点的简单路径上，<span style=\"background-color:#ffd900;\">均包含相同数目的黑色结点</span><br/> 5. 每个叶子结点都是黑色的(此处的叶子结点指的是空结点)</strong></span></p>\n</blockquote>\n<p>比如，下面的这一颗树就是红黑树：</p>\n<p><img alt=\"\" height=\"385\" src=\"..\\..\\static\\image\\fe88ad12ec0e498a9096b29b08f4f47e.png\" width=\"800\"/></p>\n<p></p>\n<p></p>\n<p>那红黑树是怎样实现插入并且能够调节平衡的呢？</p>\n<blockquote>\n<p><strong>1、首先，如果插入的结点是根结点，那么就标记为黑；</strong></p>\n<p><strong>2、接下来的每个新增的结点，都默认是红色结点（因为其对原有的红黑树的破坏性与默认是黑色结点相比较小）。</strong></p>\n<p><strong>3、如果存在了相邻的两个红色结点，那么此时就破坏了规则3。需要进行调整。</strong></p>\n</blockquote>\n<p>那怎么调整呢？</p>\n<p></p>\n<h2 id=\"3-3%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4\">3-3 红黑树的调整</h2>\n<p></p>\n<p><img alt=\"\" height=\"693\" src=\"..\\..\\static\\image\\f220706fbc9d439f9c95ccf92b28316e.png\" width=\"1114\"/></p>\n<p>此时，我们<strong>已经确定的关系是这样的：</strong></p>\n<p><strong> <span style=\"color:#fe2c24;\">p1是黑的，p2和p4都是红的。p3暂时不知道是黑是红</span></strong>（甚至有可能不存在）</p>\n<p>于是，我们要分情况讨论。</p>\n<p><strong>我们暂且把<span style=\"color:#fe2c24;\">p3称为p2的兄弟，即p4的叔叔。</span></strong></p>\n<h3 id=\"3-3-1%20%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%94%E5%8F%94%E4%B8%BA%E7%BA%A2%E3%80%82\">3-3-1 第一种情况：叔叔为红。</h3>\n<p>就是这样：</p>\n<p><img alt=\"\" height=\"665\" src=\"..\\..\\static\\image\\31b45bab60124756bc614ca1a99d77c2.png\" width=\"1005\"/></p>\n<p><strong> 此时变动的规则是：</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">将父亲和叔叔都变成黑，然后将祖父变成红。</span></strong></span></p>\n<p>即变动以后为：</p>\n<p><img alt=\"\" height=\"667\" src=\"..\\..\\static\\image\\c517796348d84a49997515705e832697.png\" width=\"953\"/></p>\n<p> 理由很简单：<strong>在上面所展示的树中，可能仅仅只是树的一个分支。<span style=\"color:#fe2c24;\">而要保证规则4，就必须要改变后每一条路径上的黑色结点的数量不变。</span></strong></p>\n<p><strong>如果不把祖父（即p1）的颜色修改为红，那么该分支上的两条路径，黑色结点就会多了一个</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">需要注意的是，如果p1是根结点，我们最终还应当将其变回黑色，否则就违背了规则2.</span></strong></span></p>\n<p></p>\n<p></p>\n<h3 id=\"3-3-2%20%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%8F%94%E5%8F%94%E4%B8%BA%E9%BB%91%E8%89%B2%E6%88%96%E8%80%85%E5%8F%94%E5%8F%94%E4%B8%8D%E5%AD%98%E5%9C%A8\">3-3-2 第二种情况：叔叔为黑色或者叔叔不存在</h3>\n<p><img alt=\"\" height=\"787\" src=\"..\\..\\static\\image\\a779ea7af47d4196b59327c38e6425d2.png\" width=\"1182\"/></p>\n<p> </p>\n<p><strong>如果是这样一种情况，那么需要进行一次旋转。</strong></p>\n<p>如果是按照上图所示的情况，<strong>那么需要以p1为parent进行一次右单旋，然后将p2变成黑，将p1变成红。</strong>具体过程如下图所示：</p>\n<p><img alt=\"\" height=\"868\" src=\"..\\..\\static\\image\\da17b71f4a2149bab971f028e39d84db.png\" width=\"1200\"/></p>\n<p><strong>如果是在左边（对称镜像的位置也是一样的，需要进行一次左单旋）</strong></p>\n<p></p>\n<p></p>\n<p></p>\n<h3 id=\"3-3-3%20%E9%92%88%E5%AF%B9%E5%8F%94%E5%8F%94%E4%B8%BA%E7%BA%A2%E6%88%96%E8%80%85%E5%8F%94%E5%8F%94%E4%B8%8D%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD%EF%BC%8C%E5%8D%B3%E6%96%B0%E5%A2%9E%E7%BB%93%E7%82%B9%E4%BD%8D%E4%BA%8Ep2%E7%9A%84%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%A4%84%E3%80%82%EF%BC%88%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%89\">3-3-3 针对叔叔为红或者叔叔不存的情况，还有一种可能，即新增结点位于p2的右孩子处。（情况三）</h3>\n<p><span style=\"color:#fe2c24;\"><strong>那么此时，需要进行双旋。</strong></span></p>\n<p>我们再来举一个例子：</p>\n<p><img alt=\"\" height=\"356\" src=\"..\\..\\static\\image\\f184a1ab2a7e441c9a90ea5e015e0259.png\" width=\"1191\"/></p>\n<p> 如上图所示，假设存在这样一种情况，<strong>下面的结点在新增的时候，通过某种变换方式，让cur变成了红色。</strong>此时，<span style=\"color:#fe2c24;\"><strong>先以p为根，进行一次左单旋</strong></span>；<strong>然后就变成了我们上面所说的情况了（即情况二所说），再进行一次右单旋即可。</strong></p>\n<p></p>\n<p>好，我们接下来就来模拟实现红黑树。</p>\n<p>还是那句话，一切尽在代码中，改注释的地方已经注释到位了。</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nenum Colour\n{\n\tRED,\n\tBLACK,\n};\ntemplate&lt;class K, class V&gt;\nstruct RBTreeNode\n{\n\tRBTreeNode&lt;K, V&gt;* _left;\n\tRBTreeNode&lt;K, V&gt;* _right;\n\tRBTreeNode&lt;K, V&gt;* _parent;\n\tpair&lt;K, V&gt; _kv;\n\tColour _col;              //给出个参考颜色（用于标识红或者黑）\n\n\tRBTreeNode(const pair&lt;K,V&gt;&amp; kv)  //红黑树结点的构造函数\n\t\t:_left(nullptr)\n\t\t,_right(nullptr)\n\t\t,_parent(nullptr)\n\t\t,_kv(lv)\n\t\t,_col(RED)\n\t{}\n\n};\ntemplate&lt;class K, class V&gt;\nclass RBTree\n{\n\ttypedef RBTreeNode&lt;K, V&gt; Node;\npublic:\n\tRBTree()\n\t\t:_root(nullptr)      //构造函数初始化\n\t{}\n\n\n\t//拷贝构造和operator自己实现\n\n\tvoid Destroy(Node* root)//销毁函数\n\t{\n\n\t\tif (root == nullptr)\n\t\t\treturn;\n\t\tDestroy(root-&gt;_left);  //通过不断递归来去实现，类比二叉搜索树\n\t\tDestroy(root-&gt;_right);\n\t\tdelete root;\n\t}\n\t~RBTree()            //析构函数——去调用销毁函数\n\t{\n\t\tDestroy(_root);\n\t}\n\n\n\tNode* Find(const K&amp; key)  //查找（类比搜索二叉树）\n\t{\n\t\tNode* cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur-&gt;_kv.first &gt; key)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_left;\n\t\t\t}\n\t\t\telse if (cur-&gt;_kv.first &lt; key)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn cur;\n\t\t\t}\n\t\t}\n\t\treturn nullptr;\n\t}\n\n\tpair&lt;Node* ,bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)//插入\n\t{\n\t\tif (_root == nullptr)           \n\t\t{\n\t\t\t_root = new Node(kv);\n\t\t\t_root-&gt;_col = BLACK;\n\t\t\treturn make_pair(_root, true);\n\t\t}\n\n\t\tNode* parent = nullptr;\n\t\tNode* cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur-&gt;_kv.first &lt;= kv.first)\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse if(cur-&gt;_kv.first &gt;kv.first)\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur-&gt; = cur-&gt;_left;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn make_pair(cur, false);\n\t\t\t}\n\t\t}\n\t\tNode* newnode = new Node(kv);\n\t\tnewnode-&gt;_col = RED;               //标记为红\n\n\t\tif (parent-&gt;_kv.first &lt; kv.first)\n\t\t{\n\t\t\tparent-&gt;_right = newnode;\n\t\t\tnewnode-&gt;_parent = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent-&gt;_left = newnode;\n\t\t\tnewnode-&gt;_parent = parent;\n\t\t}\n\t\tcur = newnode;                         //前面的和搜索二叉树的插入完全一样，就标记了一下颜色。这里不再过多赘述\n\t\t\n\t\t\n\t\twhile (parent &amp;&amp; parent-&gt;_col == RED)  //如果父亲存在，且颜色为红色就要处理\n\t\t{\n\t\t\t//关键看叔叔\n\t\t\tNode* grandfather = parent-&gt;_parent;//并且祖父一定存在\n\t\t\tif (parent == grandfather -&gt;  _left)   //如果父亲是祖父的左孩子\n\t\t\t{\n\t\t\t\tNode* uncle = grandfather-&gt;_right;    //那么叔叔就是祖父的右孩子\n\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)      //如果叔叔存在且为红（情况一）\n\t\t\t\t{\n\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;//把父亲和叔叔变成黑\n\t\t\t\t\tgrandfather-&gt;_col = RED;    //祖父变成红\n\n\t\t\t\t\t//继续往上处理\n\t\t\t\t\tcur = grandfather;         //将祖父的位置给孙子\n\t\t\t\t\tparent = cur-&gt;_parent;     //父亲变为祖父的父亲\n\t\t\t\t}\n\t\t\t\telse  //情况2+3：叔叔不存在或者叔叔存在且为黑\n\t\t\t\t{\n\t\t\t\t\t//情况2：单旋\n\t\t\t\t\tif (cur == parent-&gt;_left)   //如果孩子是父亲的左孩子\n\t\t\t\t\t{\n\t\t\t\t\t\tRotateR(grandfather);  //右单旋\n\t\t\t\t\t\tgrandfather-&gt;_col = RED;  //再变色\n\t\t\t\t\t\tparent-&gt;_col = BLACK;\n\t\t\t\t\t}\n\t\t\t\t\telse//情况3：双旋\n\t\t\t\t\t{\n\t\t\t\t\t\tRotateL(parent);\n\t\t\t\t\t\tRotateR(grandfather);\n\t\t\t\t\t\tcur-&gt;_col = BLACK;         //最终变的还是祖父的颜色和父亲的颜色\n\t\t\t\t\t\tgrandfather-&gt;_col = RED;    //祖父的颜色变成红，父亲的颜色变成黑\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse  //parent == grandparent -&gt; _right   情况是相同的\n\t\t\t{\n\t\t\t\tNode* uncle = grandfather-&gt;_left;\n\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)//情况1\n\t\t\t\t{\n\t\t\t\t\tuncle-&gt;_col == BLACK;\n\t\t\t\t\tgrandfather-&gt;_col = RED;\n\n\t\t\t\t\tcur = grandfather;\n\t\t\t\t\tparent = cur-&gt;_parent;\n\t\t\t\t}\n\t\t\t\telse//情况2+3\n\t\t\t\t{\n\t\t\t\t\tif (cur == parent-&gt;_right)\n\t\t\t\t\t{\n\t\t\t\t\t\tRotateL(grandfather);\n\t\t\t\t\t\tparent-&gt;_col = BLACK;\n\t\t\t\t\t\tgrandfather-&gt;_col = RED;\n\t\t\t\t\t}\n\t\t\t\t\telse //cur为父亲的左\n\t\t\t\t\t{\n\t\t\t\t\t\t//双旋\n\t\t\t\t\t\tRotateR(parent);\n\t\t\t\t\t\tRotateL(grandfather);\n\t\t\t\t\t\tcur-&gt;_col = BLACK;\n\t\t\t\t\t\tgrandfather-&gt;_col = RED;\n\t\t\t\t\t}\n\t\t\t\t\t//插入结束\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_root-&gt;_col = BLACK;\n\t\treturn make_pair(newnode, true);\n\t}\n\n\t//剩余的就不解释了，和搜索二叉树、AVLTree都是一样的道理\n\t//只不过这里的旋转就不需要再调节平衡因子了。\n\tvoid RotateLR(Node* parent)\n\t{\n\t\tNode* subL = parent-&gt;_left;\n\t\tNode* subLR = subL-&gt;_right;\n\n\t\tRotateL(parent-&gt;_left);\n\t\tRotateR(parent);\n\t}\n\n\tvoid RotateRL(Node* parent)\n\t{\n\t\tNode* subR = parent-&gt;_right;\n\t\tNode* subRL = subR-&gt;_left;\n\t\tRotateR(parent-&gt;_right);\n\t\tRotateL(parent);\n\n\t}\n\n\n\tvoid RotateL(Node* parent)    //左单旋\n\t{\n\t\tNode* subR = parent-&gt;_right;\n\t\tNode* subRL = subR-&gt;_left;\n\t\tNode* parentparent = parent-&gt;_parent;\n\t\tparent-&gt;_right = subRL;\n\t\tif (subRL)\n\t\t{\n\t\t\tsubRL-&gt;_parent = parent;\n\t\t}   //两个一组\n\t\tsubR-&gt;_left = parent;\n\t\tparent-&gt;_parent = subR;//两个一组\n\n\t\t//连接主体，找到组织\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = subR;\n\t\t\tsubR-&gt;_parent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (parentparent-&gt;_left == parent)\n\t\t\t{\n\t\t\t\tparentparent-&gt;_left = subR;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparentparent-&gt;_right = subR;\n\n\t\t\t}\n\t\t\tsubR-&gt;_parent = parentparent;\n\t\t}\n\t}\n\n\tvoid RotateR(Node* parent) //右单旋\n\t{\n\t\tNode* subL = parent-&gt;_left;\n\t\tNode* subLR = subL-&gt;_right;\n\t\tparent-&gt;_left = subLR;\n\t\tif (subLR)\n\t\t{\n\t\t\tsubLR-&gt;_parent = parent;\n\t\t}\n\t\tsubL-&gt;_right = parent;\n\t\tNode* parentparent = parent-&gt;_parent;\n\t\tparent-&gt;_parent = subL;\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = subL;\n\t\t\t_root-&gt;_parent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (parentparent-&gt;_left == parent)\n\t\t\t{\n\t\t\t\tparentparent-&gt;_left = subL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparentparent-&gt;_right = subL;\n\t\t\t}\n\t\t\tsubL-&gt;_parent = parentparent;\n\t\t}\n\t}\n\n\tbool _CheckBlance(Node* root, int blackNum, int count)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\tif (count != blackNum)\n\t\t\t{\n\t\t\t\tcout &lt;&lt; \"黑色节点数量不等\" &lt;&lt; endl;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)\n\t\t{\n\t\t\tcout &lt;&lt; \"存在连续的红色结点\" &lt;&lt; endl;\n\t\t\treturn false;\n\t\t}\n\t\tif (root-&gt;_col == BLACK)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\treturn _CheckBlance(root-&gt;_left,blackNum ,count)\n\t\t\t&amp;&amp; _CheckBlance(root-&gt;_right, blackNum, count);\n\t}\n\n\tbool CheckBlance()\n\t{\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif (_root-&gt;_col == RED)\n\t\t{\n\t\t\tcout &lt;&lt; \"根结点是红色的\"&lt;&lt;endl;\n\t\t\treturn false;\n\t\t}\n\n\t\t//找最左路径做黑色结点的参考值\n\t\tint blackNum = 0;\n\t\tNode* left = _root;\n\t\twhile (left)\n\t\t{\n\t\t\tif (left-&gt;_col == BLACK)\n\t\t\t{\n\t\t\t\tblackNum++;\n\t\t\t}\n\n\t\t\tleft = left-&gt;_left;\n\t\t}\n\t\tint count = 0;\n\t\treturn _CheckBlance(_root,blackNum,count)\n\t}\nprivate:\n\tNode* _root;\n};</code></pre>\n<p> </p>\n<p><strong>说明： 关于红黑树的删除，</strong>我们在这里就不做过多的探讨了，其实原理还是那个原理，结合着二叉搜索树的删除以及平衡调节的原理是可以弄出来的，<strong>但是由于其基本不会考，而我们并不是为了造轮子而造轮子，</strong>所以，有兴趣的同学可以自行下去尝试。</p>\n<p></p>\n<h2 id=\"3-4%20%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83\">3-4 红黑树与AVL树的比较</h2>\n<p>红黑树和AVL树都是高效的平衡二叉树，<span style=\"color:#fe2c24;\"><strong>增删改查的时间复杂度都是O( logN )，</strong></span><strong>红黑树不追求绝对平衡，</strong>其只需保证最长路径不超过最短路径的2倍，<strong>相对而言，降低了插入和旋转的次数，<span style=\"color:#fe2c24;\">所以在经常进行增删的结构中性能比AVL树更优</span>，<span style=\"color:#fe2c24;\">而且红黑树实现比较简单</span></strong>，<span style=\"color:#fe2c24;\">所以实际运用中红黑树更多。</span></p>\n<p></p>\n<h2 id=\"3-5%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">3-5 红黑树的应用</h2>\n<p><strong>1. C++ STL库 -- map/set、mutil_map/mutil_set<br/> 2. Java 库<br/> 3. linux内核<br/> 4. 其他一些库</strong><br/>  </p>\n<p> </p>\n<p>好啦，本节的内容就到此结束了，C++和数据结构联合推出，倾情奉献，到此结束。</p>\n<p><br/>  </p>\n<p>最后，球球给个关注吧~~~</p>\n<p>或者系统能不能多给我几个机器人😀</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-03-02 21:47:23", "summary": "第一次，和数据结构联合推出，倾情献上呦给个关注吧现在每天系统就给我一个机器人的粉丝量了本节内容，我们将着重来探讨二叉树中特殊的两种树搜索二叉树和平衡二叉树。而平衡二叉树我们可以有树，红黑树等。我们今天"}