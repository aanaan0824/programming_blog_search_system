{"blogid": "125226752", "writerAge": "码龄11年", "writerBlogNum": "192", "writerCollect": "636", "writerComment": "177", "writerFan": "4928", "writerGrade": "5级", "writerIntegral": "3100", "writerName": "万里鹏程转瞬至", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125226752.jpg", "writerRankTotal": "5824", "writerRankWeekly": "893", "writerThumb": "118", "writerVisitNum": "301558", "blog_read_count": "1449", "blog_time": "已于 2022-06-28 10:34:33 修改", "blog_title": "C++下GDAL的详细使用案例（含项目配置、tif读取为cv::Mat、Mat保存为tif）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>1、GDAL的安装与配置</h2>\n<h3>1.1 GDAL的下载安装</h3>\n<p>直接到下列链接下载即可，按照说明，将lib目录添加的系统环境变量中即可</p>\n<p><a href=\"https://download.csdn.net/download/a486259/85603934\" title=\"windows下GDAL322的库-深度学习文档类资源-CSDN下载\">windows下GDAL322的库-深度学习文档类资源-CSDN下载</a></p>\n<h3>1.2 vs中GDAL的配置</h3>\n<p>包含目录中设置include目录</p>\n<p><img alt=\"\" height=\"335\" src=\"..\\..\\static\\image\\2f2dc7c1af5840d69ff5eaccc8589d0c.png\" width=\"1122\"/></p>\n<p> 库目录中设置lib的路径</p>\n<p><img alt=\"\" height=\"410\" src=\"..\\..\\static\\image\\8b4012f9fa0040228def67541cea3f5e.png\" width=\"601\"/></p>\n<p> 附加依赖项中设置gdal_i.lib</p>\n<p> <img alt=\"\" height=\"445\" src=\"..\\..\\static\\image\\33a9b5dc9d634f61a4aff53fab823f9a.png\" width=\"651\"/></p>\n<p></p>\n<h2>2、GDAL读取数据</h2>\n<p>GDAL读取数钱需要注册一下驱动（用于编码解码图像的驱动），同时可以设置一下支持中文路径。加载数据时需要注意，GA_Update和GA_ReadOnly两种模式。</p>\n<pre><code class=\"language-cpp\">\tGDALAllRegister();//注册所有的驱动\n\tCPLSetConfigOption(\"GDAL_FILENAME_IS_UTF8\", \"NO\");  //设置支持中文路径和文件名\n\t//1、加载tif数据\n\tstring file_path_name = \"test.tif\";\n\t//std::cout &lt;&lt; \"请输入图片路径：\" &lt;&lt; std::endl;\n\t//std::cin &gt;&gt; file_path_name;\n\tGDALDataset* poDataset = (GDALDataset*)GDALOpen(file_path_name.c_str(), GA_ReadOnly);//GA_Update和GA_ReadOnly两种模式\n\tif (poDataset == NULL)\n\t{\n\t\tstd::cout &lt;&lt; \"指定的文件不能打开!\" &lt;&lt; std::endl;\n\t\treturn 0;\n\t}</code></pre>\n<h3>2.1 获取图像的尺寸</h3>\n<p>这里所有的波段的size都是一样的</p>\n<pre><code class=\"language-cpp\">    int nImgSizeX = poDataset-&gt;GetRasterXSize();\n    int nImgSizeY = poDataset-&gt;GetRasterYSize();\n    std::cout &lt;&lt; \"ImageX = \" &lt;&lt; nImgSizeX &lt;&lt; \",\tImageY = \" &lt;&lt; nImgSizeY &lt;&lt; std::endl;</code></pre>\n<h3>2.2 获取图像的通道数</h3>\n<pre><code class=\"language-cpp\">    int bandCount = poDataset-&gt;GetRasterCount();\n    std::cout &lt;&lt; \"bandCount = \" &lt;&lt; bandCount &lt;&lt; std::endl;</code></pre>\n<h3>2.3 获取特定波段</h3>\n<p>需要注意的是在GDAL中波段数的起始数是1，而非0</p>\n<pre><code class=\"language-cpp\">    GDALRasterBand* poBand1 = poDataset-&gt;GetRasterBand(1);</code></pre>\n<h3>2.4 获取数据类型</h3>\n<p>根据波段获取数据类型，而数据中有多个波段。由此可知，每一个波段都可以有不同的数据类型。</p>\n<pre><code class=\"language-cpp\">    GDALDataType g_type = GDALDataType(poBand1-&gt;GetRasterDataType());\n\tstd::cout &lt;&lt; \"g_type = \" &lt;&lt; g_type &lt;&lt; std::endl;</code></pre>\n<p>GDAL中共有12种数据类型，具体如下所示</p>\n<pre><code class=\"language-cpp\">\ttypedef enum {\n\t\tGDT_Unknown = 0,\n\t\tGDT_Byte = 1,\n\t\tGDT_UInt16 = 2,\n\t\tGDT_Int16 = 3,\n\t\tGDT_UInt32 = 4,\n\t\tGDT_Int32 = 5,GDT_UInt64,GDT_Int64\n\t\tGDT_Float32 = 6,\n\t\tGDT_Float64 = 7,\n\t\tGDT_CInt16 = 8,\n\t\tGDT_CInt32 = 9,GDT_CInt64\n\t\tGDT_CFloat32 = 10,\n\t\tGDT_CFloat64 = 11,\n\t\tGDT_TypeCount = 12\n\t} GDALDataType;</code></pre>\n<h2>3、坐标系与投影信息处理</h2>\n<h3>3.1 获取及设置坐标变换系数</h3>\n<p>坐标变换系数的具体格式为左上角x坐标， 水平分辨率，旋转参数， 左上角y坐标，旋转参数，竖直分辨率。对应同一区域不同级别的的图像，只有水平分辨率（trans[1]）与竖直分辨率（trans[5]）的值不一样。其默认值为{ 0,1,0,0,0,1 }，即x、y分辨率为1，其他信息为0 。</p>\n<pre><code class=\"language-cpp\">    double trans[6] = { 0,1,0,0,0,1 };//定义为默认值，即x、y分辨率为1，其他信息为0 \n\t//具体格式为左上角x坐标， 水平分辨率，旋转参数， 左上角y坐标，旋转参数，竖直分辨率。对应同一区域不同级别的的图像，只有水平分辨率（trans[1]）与竖直分辨率（trans[5]）的值不一样\n\tCPLErr aaa = poDataset-&gt;GetGeoTransform(trans);\n\ttrans[2] = 0.3;//修改x的旋转参数信息\n\ttrans[4] = 0.1;//修改y的旋转参数信息\n\t//poDataset-&gt;SetGeoTransform(trans);//设置坐标变换系数\n\tstd::cout &lt;&lt; \"trans = \" &lt;&lt; trans[0] &lt;&lt; \",\" &lt;&lt; trans[1] &lt;&lt; \",\" &lt;&lt; trans[2] &lt;&lt; \",\" &lt;&lt; trans[3] &lt;&lt; \",\" &lt;&lt; trans[4] &lt;&lt; \",\" &lt;&lt; trans[5] &lt;&lt; std::endl;\n</code></pre>\n<h3>3.2 像素坐标与投影坐标的相互转换</h3>\n<p>下面实现了经纬度坐标与像素坐标的相互转换</p>\n<pre><code class=\"language-cpp\">\tdouble dProjX, dProjY;\n\tint iCol, iRow;\n\tiCol = 111;\n\tiRow = 111;\n\tImageRowCol2Projection(trans, iCol, iRow, dProjX, dProjY);\n\tstd::cout &lt;&lt; \"在trans中，像素坐标=》经纬度：\" &lt;&lt; iCol &lt;&lt; \"，\" &lt;&lt; iRow &lt;&lt; \"====》\" &lt;&lt; dProjX &lt;&lt; \"，\" &lt;&lt; dProjY &lt;&lt; std::endl;\n\tProjection2ImageRowCol(trans, dProjX, dProjY, iCol, iRow);\n\tstd::cout &lt;&lt; \"在trans中，经纬度=》像素坐标：\" &lt;&lt; dProjX &lt;&lt; \"，\" &lt;&lt; dProjY &lt;&lt; \"====》\" &lt;&lt; iCol &lt;&lt; \"，\" &lt;&lt; iRow &lt;&lt; std::endl;\n</code></pre>\n<p>两个转换函数的定义如下所示，参考了<a href=\"https://blog.csdn.net/ivan_ljf/article/details/9226463\" title=\"关于GDAL计算图像坐标的几个问题_IvanLJF的博客-CSDN博客\">关于GDAL计算图像坐标的几个问题_IvanLJF的博客-CSDN博客</a> </p>\n<pre><code class=\"language-cpp\">//计算trans中图片xy点的经纬度信息\n//adfGeoTransform的6个参数分别为左上角x坐标，水平分辨率，旋转参数，左上角y坐标，旋转参数，竖直分辨率,一般来说，旋转参数都为0\nbool Projection2ImageRowCol(double* adfGeoTransform, double dProjX, double dProjY, int&amp; iCol, int&amp; iRow)\n{\n\ttry\n\t{\n\t\tdouble dTemp = adfGeoTransform[1] * adfGeoTransform[5] - adfGeoTransform[2] * adfGeoTransform[4];\n\t\tdouble dCol = 0.0, dRow = 0.0;\n\t\tdCol = (adfGeoTransform[5] * (dProjX - adfGeoTransform[0]) -\n\t\t\tadfGeoTransform[2] * (dProjY - adfGeoTransform[3])) / dTemp + 0.5;\n\t\tdRow = (adfGeoTransform[1] * (dProjY - adfGeoTransform[3]) -\n\t\t\tadfGeoTransform[4] * (dProjX - adfGeoTransform[0])) / dTemp + 0.5;\n\n\t\tiCol = int(dCol);\n\t\tiRow = int(dRow);\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\treturn false;\n\t}\n}\n\nbool ImageRowCol2Projection(double* adfGeoTransform, int iCol, int iRow, double&amp; dProjX, double&amp; dProjY)\n{\n\ttry\n\t{\n\t\tdProjX = adfGeoTransform[0] + adfGeoTransform[1] * iCol + adfGeoTransform[2] * iRow;\n\t\tdProjY = adfGeoTransform[3] + adfGeoTransform[4] * iCol + adfGeoTransform[5] * iRow;\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\treturn false;\n\t}\n}</code></pre>\n<h3>3.3 获取与设置投影坐标系信息</h3>\n<p>在GDAL数据坐标系中有WGS84坐标系、CGCS2000坐标系、GCJ02坐标系、BD09坐标系等。具体可分为地心坐标系、投影坐标系、原始坐标系、加密坐标系4类。更多坐标系信息可以参考https://blog.csdn.net/sinat_41310868/article/details/115551276</p>\n<pre><code class=\"language-cpp\">    std::string projs = poDataset-&gt;GetProjectionRef();\n\t//设置地理坐标系信息\n\t//poDataset-&gt;SetProjection(projs.c_str());\n\tstd::cout &lt;&lt; \"projs = \" &lt;&lt; projs &lt;&lt; std::endl;</code></pre>\n<h2>4、读写GDAL数据</h2>\n<h3>4.1 将数据读取到Mat中</h3>\n<p>需要注意的是cv::Mat创建时，是(height,width)的格式，与GDAL的(width,height)刚好相反。<span style=\"color:#fe2c24;\">同时GADL的起始通道数是1，不是0.</span></p>\n<pre><code class=\"language-cpp\">\tcv::Mat gdal_mat1(nImgSizeY, nImgSizeX, CV_8UC1, Scalar(0));\n\tcv::Mat gdal_mat2(nImgSizeY, nImgSizeX, CV_8UC1, Scalar(0));\n\tcv::Mat gdal_mat3(nImgSizeY, nImgSizeX, CV_8UC1, Scalar(0));\n\tpoDataset-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, gdal_mat1.data, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\tpoDataset-&gt;GetRasterBand(2)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, gdal_mat2.data, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\tpoDataset-&gt;GetRasterBand(3)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, gdal_mat3.data, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\tcv::Mat mg;\n\tcv::merge(vector&lt;cv::Mat&gt;{ gdal_mat3, gdal_mat2, gdal_mat1,}, mg);\n\tcv::imwrite(\"read_save.jpg\", mg);</code></pre>\n<p>RasterIO函数的参数列表如下所示。从参数列表中是可以看到，GDAL是支持将数据分块读入的内存中的 。RasterIO参数列表的详细说明可以参考 https://blog.51cto.com/u_15469043/4903358</p>\n<pre><code class=\"language-cpp\">    CPLErr GDALRasterBand::RasterIO (   GDALRWFlag eRWFlag,\n\t\t\t\t\t\t\t\t\t\tint     nXOff,//x的起始点\n\t\t\t\t\t\t\t\t\t\tint     nYOff,//y的起始点\n\t\t\t\t\t\t\t\t\t\tint     nXSize,//读取窗口的宽\n\t\t\t\t\t\t\t\t\t\tint     nYSize,//读取窗口的高\n\t\t\t\t\t\t\t\t\t\tvoid * pData,\n\t\t\t\t\t\t\t\t\t\tint     nBufXSize,//与nXSize相同\n\t\t\t\t\t\t\t\t\t\tint     nBufYSize,//与nYSize相同\n\t\t\t\t\t\t\t\t\t\tGDALDataType    eBufType,\n\t\t\t\t\t\t\t\t\t\tint     nPixelSpace,//通常默认为0\n\t\t\t\t\t\t\t\t\t\tint     nLineSpace //通常默认为0\n\t\t\t\t\t\t\t\t\t\t)</code></pre>\n<p>除了将数据读取到mat中外，我们还可以将数据读取到指针或者数组中</p>\n<pre><code class=\"language-cpp\">    //void * malloc(size_t n)：给指针分配相应的内存，并返回内存空间的首地址。当内存不再使用的时候，应使用free()函数将内存块释放掉。\n\tuint8_t* srcData = (uint8_t*)malloc(sizeof(uint8_t) * nImgSizeX * nImgSizeY);\n\t//void * memset (void * p,int c,size_t n)：将p中的n个字节都赋值为c\n\tmemset(srcData, 0, sizeof(uint8_t) * 1 * nImgSizeX * nImgSizeY);//为空间赋默认值0\n\tpoDataset-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, srcData, nImgSizeX, nImgSizeY, g_type, 0, 0);</code></pre>\n<h3>4.2 将mat数据保存到GDAL中（tiff格式）</h3>\n<p>创建gdal对象   一次性写入数据，只支持tiff数据。PEN、JPEG等驱动没有实现相应的Create方法。</p>\n<pre><code class=\"language-cpp\">    int nImgSizeX3 = gdal_mat1.cols;\n\tint nImgSizeY3 = gdal_mat1.rows;\n\tGDALDriver* pDriverMEM3 = GetGDALDriverManager()-&gt;GetDriverByName(\"GTiff\");\n\tif (!pDriverMEM3) {\n\t\tfprintf(stderr, \"get driver by name failed\\n\");\n\t\treturn -1;\n\t}\n\tint nBands3 = 1;\n\tGDALDataset* poDataset3 = pDriverMEM3-&gt;Create(\"saved3.tif\", nImgSizeX3, nImgSizeY3, nBands3, g_type, NULL);\n\tif (!poDataset3) {\n\t\tfprintf(stderr, \"Create GDALDataset failed\\n\");\n\t\treturn -1;\n\t}\n\tpoDataset3-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Write, 0, 0, nImgSizeX3, nImgSizeY3, gdal_mat1.data, nImgSizeX3, nImgSizeY3, GDT_Byte, 0, 0);\n\tstd::cout &lt;&lt; \"tif 文件保存成功\" &lt;&lt; std::endl;</code></pre>\n<h3>4.3 将mat数据保存到GDAL中（任意格式）</h3>\n<p>GDAL中可用的驱动格式还有：BMP、JPEG、PNG、GTiff、GIF、HFA、BT、ECW、FITS、HDF4、EHdr。这些驱动格式分别对应着不同的文件类型，MEM表示为内存对象，可以快速的分块追加写入数据。MEM文件大小是和你的系统内存大小有关系，并不会存储到磁盘中。</p>\n<pre><code class=\"language-cpp\">    int nImgSizeX2 = gdal_mat1.cols;\n\tint nImgSizeY2 = gdal_mat1.rows;\n\t//获取GDAL驱动\n\tGDALDriver* pDriverMEM = GetGDALDriverManager()-&gt;GetDriverByName(\"MEM\");\n\tint nBands = 1;\n\t//创建GDAL对象，只保存原图的一个通道\n\t//Create(const char * pszName,int nXSize, int nYSize, int nBands, GDALDataType eType, char** papszOptions)\n\tGDALDataset* poDataset2 = pDriverMEM-&gt;Create(\"\", nImgSizeX2, nImgSizeY2, nBands, g_type, NULL);\n\t//将mat数据写入到GDALDataset中\n\tpoDataset2-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Write, 0, 0, nImgSizeX2, nImgSizeY2, gdal_mat1.data, nImgSizeX2, nImgSizeY2, GDT_Byte, 0, 0);\n\t//获取GDAL驱动，PNG表示为用png驱动保存数据\n\tGDALDriver* pDriverSave = GetGDALDriverManager()-&gt;GetDriverByName(\"PNG\");\n\tpDriverSave-&gt;CreateCopy(\"saved.png\", poDataset2, TRUE, 0, 0, 0); //创建png文件\n\tstd::cout &lt;&lt; \"png 文件保存成功\" &lt;&lt; std::endl;</code></pre>\n<h3>4.4 关闭GDAL对象，并注销所有驱动</h3>\n<pre><code class=\"language-cpp\">\tGDALClose(poDataset);\n\tGDALClose(poDataset2);\n\tGDALClose(poDataset3);\n\tGDALDestroyDriverManager();</code></pre>\n<h2>5、代码及效果</h2>\n<h3>5.1 全部代码</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;iomanip&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include \"gdal_priv.h\"\n#include &lt;gdal_alg_priv.h&gt;\n#include &lt;gdal.h&gt;\nusing namespace std;\nusing namespace cv;\n//参考https://blog.csdn.net/ivan_ljf/article/details/9226463\n//计算trans中图片xy点的经纬度信息\n//adfGeoTransform的6个参数分别为左上角x坐标，水平分辨率，旋转参数，左上角y坐标，旋转参数，竖直分辨率,一般来说，旋转参数都为0\nbool Projection2ImageRowCol(double* adfGeoTransform, double dProjX, double dProjY, int&amp; iCol, int&amp; iRow)\n{\n\ttry\n\t{\n\t\tdouble dTemp = adfGeoTransform[1] * adfGeoTransform[5] - adfGeoTransform[2] * adfGeoTransform[4];\n\t\tdouble dCol = 0.0, dRow = 0.0;\n\t\tdCol = (adfGeoTransform[5] * (dProjX - adfGeoTransform[0]) -\n\t\t\tadfGeoTransform[2] * (dProjY - adfGeoTransform[3])) / dTemp + 0.5;\n\t\tdRow = (adfGeoTransform[1] * (dProjY - adfGeoTransform[3]) -\n\t\t\tadfGeoTransform[4] * (dProjX - adfGeoTransform[0])) / dTemp + 0.5;\n\n\t\tiCol = int(dCol);\n\t\tiRow = int(dRow);\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\treturn false;\n\t}\n}\n\nbool ImageRowCol2Projection(double* adfGeoTransform, int iCol, int iRow, double&amp; dProjX, double&amp; dProjY)\n{\n\ttry\n\t{\n\t\tdProjX = adfGeoTransform[0] + adfGeoTransform[1] * iCol + adfGeoTransform[2] * iRow;\n\t\tdProjY = adfGeoTransform[3] + adfGeoTransform[4] * iCol + adfGeoTransform[5] * iRow;\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\treturn false;\n\t}\n}\nint main() {\n\tGDALAllRegister();//注册所有的驱动\n\tCPLSetConfigOption(\"GDAL_FILENAME_IS_UTF8\", \"NO\");  //设置支持中文路径和文件名\n\t//1、加载tif数据\n\tstring file_path_name = \"test.tif\";\n\t//std::cout &lt;&lt; \"请输入图片路径：\" &lt;&lt; std::endl;\n\t//std::cin &gt;&gt; file_path_name;\n\tGDALDataset* poDataset = (GDALDataset*)GDALOpen(file_path_name.c_str(), GA_ReadOnly);//GA_Update和GA_ReadOnly两种模式\n\tif (poDataset == NULL)\n\t{\n\t\tstd::cout &lt;&lt; \"指定的文件不能打开!\" &lt;&lt; std::endl;\n\t\treturn 0;\n\t}\n\n\t//获取图像的尺寸\n\tint nImgSizeX = poDataset-&gt;GetRasterXSize();\n\tint nImgSizeY = poDataset-&gt;GetRasterYSize();\n\tstd::cout &lt;&lt; \"ImageX = \" &lt;&lt; nImgSizeX &lt;&lt; \",\tImageY = \" &lt;&lt; nImgSizeY &lt;&lt; std::endl;\n\n\t//获取图像的通道数（波段数量）\n\tint bandCount = poDataset-&gt;GetRasterCount();\n\tstd::cout &lt;&lt; \"bandCount = \" &lt;&lt; bandCount &lt;&lt; std::endl;\n\n\t//获取图像波段  在GDAL中波段数的起始数是1，而非0\n\tGDALRasterBand* poBand1 = poDataset-&gt;GetRasterBand(1);\n\n\t//GDAL中的数据类型 由此可知，每一个波段都可以有不同的数据类型\n\t/* 一共包含以下12种数据类型\n\ttypedef enum {\n\t\tGDT_Unknown = 0,\n\t\tGDT_Byte = 1,\n\t\tGDT_UInt16 = 2,\n\t\tGDT_Int16 = 3,\n\t\tGDT_UInt32 = 4,\n\t\tGDT_Int32 = 5,GDT_UInt64,GDT_Int64\n\t\tGDT_Float32 = 6,\n\t\tGDT_Float64 = 7,\n\t\tGDT_CInt16 = 8,\n\t\tGDT_CInt32 = 9,GDT_CInt64\n\t\tGDT_CFloat32 = 10,\n\t\tGDT_CFloat64 = 11,\n\t\tGDT_TypeCount = 12\n\t} GDALDataType;\n\t*/\n\tGDALDataType g_type = GDALDataType(poBand1-&gt;GetRasterDataType());\n\tstd::cout &lt;&lt; \"g_type = \" &lt;&lt; g_type &lt;&lt; std::endl;\n\n\n\t//获取坐标变换系数\n\tdouble trans[6] = { 0,1,0,0,0,1 };//定义为默认值，即x、y分辨率为1，其他信息为0 \n\tCPLErr aaa = poDataset-&gt;GetGeoTransform(trans);\n\ttrans[2] = 0.3;//修改x的旋转参数信息\n\ttrans[4] = 0.1;//修改y的旋转参数信息\n\t//poDataset-&gt;SetGeoTransform(trans);//设置坐标变换系数\n\tstd::cout &lt;&lt; \"trans = \" &lt;&lt; trans[0] &lt;&lt; \",\" &lt;&lt; trans[1] &lt;&lt; \",\" &lt;&lt; trans[2] &lt;&lt; \",\" &lt;&lt; trans[3] &lt;&lt; \",\" &lt;&lt; trans[4] &lt;&lt; \",\" &lt;&lt; trans[5] &lt;&lt; std::endl;\n\n\t//像素坐标与投影坐标的换算\n\tdouble dProjX, dProjY;\n\tint iCol, iRow;\n\tiCol = 111;\n\tiRow = 111;\n\tImageRowCol2Projection(trans, iCol, iRow, dProjX, dProjY);\n\tstd::cout &lt;&lt; \"在trans中，像素坐标=》经纬度：\" &lt;&lt; iCol &lt;&lt; \"，\" &lt;&lt; iRow &lt;&lt; \"====》\" &lt;&lt; dProjX &lt;&lt; \"，\" &lt;&lt; dProjY &lt;&lt; std::endl;\n\tProjection2ImageRowCol(trans, dProjX, dProjY, iCol, iRow);\n\tstd::cout &lt;&lt; \"在trans中，经纬度=》像素坐标：\" &lt;&lt; dProjX &lt;&lt; \"，\" &lt;&lt; dProjY &lt;&lt; \"====》\" &lt;&lt; iCol &lt;&lt; \"，\" &lt;&lt; iRow &lt;&lt; std::endl;\n\n\n\t//获取图像投影坐标系信息，\n\tstd::string projs = poDataset-&gt;GetProjectionRef();\n\t//设置地理坐标系信息\n\t//poDataset-&gt;SetProjection(projs.c_str());\n\tstd::cout &lt;&lt; \"projs = \" &lt;&lt; projs &lt;&lt; std::endl;\n\n\n\t//读取gadl中第一个通道的数据到mat中 【通道数是从1开始的】\n\t//RasterIO参数列表的详细说明可以参考 https://blog.51cto.com/u_15469043/4903358\n\t/*从参数列表中是可以看到，GDAL是支持将数据分块读入的内存中的\n\tCPLErr GDALRasterBand::RasterIO (   GDALRWFlag eRWFlag,\n\t\t\t\t\t\t\t\t\t\tint     nXOff,//x的起始点\n\t\t\t\t\t\t\t\t\t\tint     nYOff,//y的起始点\n\t\t\t\t\t\t\t\t\t\tint     nXSize,//读取窗口的宽\n\t\t\t\t\t\t\t\t\t\tint     nYSize,//读取窗口的高\n\t\t\t\t\t\t\t\t\t\tvoid * pData,\n\t\t\t\t\t\t\t\t\t\tint     nBufXSize,//与nXSize相同\n\t\t\t\t\t\t\t\t\t\tint     nBufYSize,//与nYSize相同\n\t\t\t\t\t\t\t\t\t\tGDALDataType    eBufType,\n\t\t\t\t\t\t\t\t\t\tint     nPixelSpace,//通常默认为0\n\t\t\t\t\t\t\t\t\t\tint     nLineSpace //通常默认为0\n\t\t\t\t\t\t\t\t\t\t)\n\t*/\n\t//\n\tcv::Mat gdal_mat1(nImgSizeY, nImgSizeX, CV_8UC1, Scalar(0));\n\tcv::Mat gdal_mat2(nImgSizeY, nImgSizeX, CV_8UC1, Scalar(0));\n\tcv::Mat gdal_mat3(nImgSizeY, nImgSizeX, CV_8UC1, Scalar(0));\n\tpoDataset-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, gdal_mat1.data, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\tpoDataset-&gt;GetRasterBand(2)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, gdal_mat2.data, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\tpoDataset-&gt;GetRasterBand(3)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, gdal_mat3.data, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\tcv::Mat mg;\n\tcv::merge(vector&lt;cv::Mat&gt;{ gdal_mat3, gdal_mat2, gdal_mat1,}, mg);\n\tcv::imwrite(\"read_save.jpg\", mg);\n\t/*\n\t//读取gadl中第一个通道的数据到指针中\n\t//void * malloc(size_t n)：给指针分配相应的内存，并返回内存空间的首地址。当内存不再使用的时候，应使用free()函数将内存块释放掉。\n\tuint8_t* srcData = (uint8_t*)malloc(sizeof(uint8_t) * nImgSizeX * nImgSizeY);\n\t//void * memset (void * p,int c,size_t n)：将p中的n个字节都赋值为c\n\tmemset(srcData, 0, sizeof(uint8_t) * 1 * nImgSizeX * nImgSizeY);//为空间赋默认值0\n\tpoDataset-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Read, 0, 0, nImgSizeX, nImgSizeY, srcData, nImgSizeX, nImgSizeY, g_type, 0, 0);\n\t*/\n\n\t//-----------创建gdal对象   MEM追加，CreateCopy保存支持tif、png、jpg等格式-----\n\tint nImgSizeX2 = gdal_mat1.cols;\n\tint nImgSizeY2 = gdal_mat1.rows;\n\t//获取GDAL驱动，MEM表示为内存对象，可以快速的分块追加写入数据。MEM文件大小是和你的系统内存大小有关系，并不会存储到磁盘中。可用的驱动格式还有：BMP、JPEG、PNG、GTiff、GIF、HFA、BT、ECW、FITS、HDF4、EHdr。分别对应着不同的文件类型\n\tGDALDriver* pDriverMEM = GetGDALDriverManager()-&gt;GetDriverByName(\"MEM\");\n\tint nBands = 1;\n\t//创建GDAL对象，只保存原图的一个通道\n\t//Create(const char * pszName,int nXSize, int nYSize, int nBands, GDALDataType eType, char** papszOptions)\n\tGDALDataset* poDataset2 = pDriverMEM-&gt;Create(\"\", nImgSizeX2, nImgSizeY2, nBands, g_type, NULL);\n\t//将mat数据写入到GDALDataset中\n\tpoDataset2-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Write, 0, 0, nImgSizeX2, nImgSizeY2, gdal_mat1.data, nImgSizeX2, nImgSizeY2, GDT_Byte, 0, 0);\n\t//获取GDAL驱动，PNG表示为用png驱动保存数据\n\tGDALDriver* pDriverSave = GetGDALDriverManager()-&gt;GetDriverByName(\"PNG\");\n\tpDriverSave-&gt;CreateCopy(\"saved.png\", poDataset2, TRUE, 0, 0, 0); //创建png文件\n\tstd::cout &lt;&lt; \"png 文件保存成功\" &lt;&lt; std::endl;\n\n\t//-----------创建gdal对象   一次性写入，只支持tiff数据。PEN、JPEG等驱动没有实现相应的Create方法-----\n\tint nImgSizeX3 = gdal_mat1.cols;\n\tint nImgSizeY3 = gdal_mat1.rows;\n\tGDALDriver* pDriverMEM3 = GetGDALDriverManager()-&gt;GetDriverByName(\"GTiff\");\n\tif (!pDriverMEM3) {\n\t\tfprintf(stderr, \"get driver by name failed\\n\");\n\t\treturn -1;\n\t}\n\tint nBands3 = 1;\n\tGDALDataset* poDataset3 = pDriverMEM3-&gt;Create(\"saved3.tif\", nImgSizeX3, nImgSizeY3, nBands3, g_type, NULL);\n\tif (!poDataset3) {\n\t\tfprintf(stderr, \"Create GDALDataset failed\\n\");\n\t\treturn -1;\n\t}\n\tpoDataset3-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Write, 0, 0, nImgSizeX3, nImgSizeY3, gdal_mat1.data, nImgSizeX3, nImgSizeY3, GDT_Byte, 0, 0);\n\tstd::cout &lt;&lt; \"tif 文件保存成功\" &lt;&lt; std::endl;\n\n\t//关闭GDAL对象，并注销所有驱动\n\tGDALClose(poDataset);\n\tGDALClose(poDataset2);\n\tGDALClose(poDataset3);\n\tGDALDestroyDriverManager();\n\n\treturn -1;\n}</code></pre>\n<h3>5.2 运行结果</h3>\n<p>运行界面输出</p>\n<p><img alt=\"\" height=\"449\" src=\"..\\..\\static\\image\\374916f13736472ebd8b7665d93565c1.png\" width=\"958\"/></p>\n<p> 运行过程中的测试数据及保存结果</p>\n<p><img alt=\"\" height=\"294\" src=\"..\\..\\static\\image\\e71b0158d2b54e92b53a14b978d8238f.png\" width=\"1024\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-28 10:34:33", "summary": "、的安装与配置的下载安装直接到下列链接下载即可，按照说明，将目录添加的系统环境变量中即可下的库深度学习文档类资源下载下的库深度学习文档类资源下载中的配置包含目录中设置目录库目录中设置的路径附加依赖项中"}