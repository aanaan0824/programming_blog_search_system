{"blogid": "124429390", "writerAge": "码龄12年", "writerBlogNum": "8", "writerCollect": "48", "writerComment": "18", "writerFan": "15", "writerGrade": "4级", "writerIntegral": "1423", "writerName": "lyshiba", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124429390.jpg", "writerRankTotal": "46091", "writerRankWeekly": "238584", "writerThumb": "12", "writerVisitNum": "151623", "blog_read_count": "1944", "blog_time": "于 2022-04-26 15:42:18 发布", "blog_title": "std::shared_ptr的使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete，当引用计数变为零的时候就会将对象自动删除。</p>\n</blockquote>\n<p><strong>std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。例如:</strong></p>\n<p></p>\n<pre><code>auto pointer = std::make_shared&lt;int&gt;(10);\nauto pointer2 = pointer; // 引用计数+1\nauto pointer3 = pointer; // 引用计数+1\nint *p = pointer.get(); // 这样不会增加引用计数\nstd::cout &lt;&lt; \"pointer.use_count() = \" &lt;&lt; pointer.use_count() &lt;&lt; std::endl; // 3\nstd::cout &lt;&lt; \"pointer2.use_count() = \" &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 3\nstd::cout &lt;&lt; \"pointer3.use_count() = \" &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 3\n\npointer2.reset();\nstd::cout &lt;&lt; \"reset pointer2:\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"pointer.use_count() = \" &lt;&lt; pointer.use_count() &lt;&lt; std::endl; // 2\nstd::cout &lt;&lt; \"pointer2.use_count() = \" &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 0, pointer2 已 reset\nstd::cout &lt;&lt; \"pointer3.use_count() = \" &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 2\npointer3.reset();\nstd::cout &lt;&lt; \"reset pointer3:\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"pointer.use_count() = \" &lt;&lt; pointer.use_count() &lt;&lt; std::endl; // 1\nstd::cout &lt;&lt; \"pointer2.use_count() = \" &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 0\nstd::cout &lt;&lt; \"pointer3.use_count() = \" &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 0, pointer3 已 reset\n\n</code></pre>\n<h2>创建</h2>\n<p></p>\n<pre><code>方式一：shared_ptr&lt;string&gt; pTom{new string(\"tom\")};\n方式二：shared_ptr&lt;string&gt; pTom;\n               pTom.reset(new string(\"tom\"));\n方式三：shared_ptr&lt;string&gt; pTom = make_shared&lt;string&gt;(\"tom\");\n推荐：使用方式三，更快（一次复制），更安全\n</code></pre>\n<h2>使用</h2>\n<p></p>\n<pre><code>shared_ptr&lt;string&gt; pTom = make_shared&lt;string&gt;(\"tom\");\nshared_ptr&lt;string&gt; pJerry = make_shared&lt;string&gt;(\"jerry\");\n(*pTom)[0] = ’T’;  //tom -&gt; Tom\npJerry-&gt;replace(0, 1, \"i\"); //jerry -&gt; Jerry\n\nvector&lt;shared_ptr&lt;string&gt;&gt; vtWhoCleanRoom;   \nvtWhoCleanRoom.push_back(pTom);   \nvtWhoCleanRoom.push_back(pJerry);    \nvtWhoCleanRoom.push_back(pTom);\n\n//此时vtWhoCleanRoom的内容为Tom Jerry Tom\n*pTom = \"Tomy\"; \n//此时vtWhoCleanRoom的内容为Tomy Jerry Tomy\n</code></pre>\n<h2>比较运算符</h2>\n<p><strong>所有比较运算符都会调用共享指针，内部封装的原始指针的比较运算符；支持==、!=、&lt;、&lt;=、&gt;、&gt;=；同类型的共享指针才能使用比较运算符。</strong></p>\n<p></p>\n<pre><code>shared_ptr&lt;int&gt; sp_n1 = make_shared&lt;int&gt;(1);\nshared_ptr&lt;int&gt; sp_n2 = make_shared&lt;int&gt;(2);\nshared_ptr&lt;int&gt; sp_nu;\nshared_ptr&lt;double&gt; sp_d1 = \n    make_shared&lt;double&gt;(1);\n\nbool bN1LtN2 = sp_n1 &lt; sp_n2;  //true\nbool bN1GtNu = sp_n1 &gt; sp_nu;  //true\nbool bNuEqNu = sp_nu == sp_nu; //true\nbool bN2GtD1 = sp_d1 &lt; sp_n2;  //编译错误\n</code></pre>\n<h2>线程安全接口</h2>\n<p><strong>①共享指针不是线程安全的<br/> ②标准库提供了共享指针的原子接口<br/> ③只并发访问指针，而不是对它们所引用的值。</strong></p>\n<p></p>\n<pre><code>std::shared_ptr&lt;X&gt; global; //创建空的共享指针\nvoid foo()\n{\n    std::shared_ptr&lt;X&gt; local{new X};\n    ...\n    std::atomic_store(&amp;global, local);\n}\n</code></pre>\n<table><thead><tr><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>atomic_is_lock_free(&amp;sp)</td><td>如果sp的原子接口是无锁的，则返回true</td></tr><tr><td>atomic_load(&amp;sp)</td><td>返回sp</td></tr><tr><td>atomic_store(&amp;sp,sp2)</td><td>使用sp2对sp进行赋值</td></tr><tr><td>atomic_exchange(&amp;sp,sp2)</td><td>交换sp与sp2的值</td></tr></tbody></table>\n<h2>错误使用</h2>\n<p><strong>①多个共享指针不能拥有同一个对象<br/> ②可以使用enable_shared_from_this<br/> 和shared_from_this生成共享指针</strong></p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass CTest{\npublic:\n    CTest(const string &amp; sName) : m_sName(sName) {}\n    ~CTest() {\n        cout &lt;&lt; m_sName &lt;&lt; \" destroy\" &lt;&lt; endl; }\n\nprivate:\n    string m_sName;\n};\n\n\nint main()\n{\n    CTest* p = new CTest(\"test\");\n    shared_ptr&lt;CTest&gt; sp1(p);\n    shared_ptr&lt;CTest&gt; sp2(p); //错误\n\n    return 0;\n}\n</code></pre>\n<p>运行输出：</p>\n<p></p>\n<pre><code>test destroy\nSegmentation fault      (core dumped)\n</code></pre>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass CTest : public enable_shared_from_this&lt;CTest&gt;\n{\npublic:\n    CTest(const string &amp; sName) : m_sName(sName) {}\n    ~CTest() {\n        cout &lt;&lt; m_sName &lt;&lt; \" destroy\" &lt;&lt; endl; }\n\n    shared_ptr&lt;CTest&gt; getSharePtr() {\n        return shared_from_this();\n    }\n\nprivate:\n    string m_sName;\n};\n\nint main()\n{\n    CTest* p = new CTest(\"test\");\n    shared_ptr&lt;CTest&gt; sp1(p);\n    shared_ptr&lt;CTest&gt; sp2 = p-&gt;getSharePtr(); //正确\n\n    return 0;\n}\n\n</code></pre>\n<h2>销毁</h2>\n<p><strong>①定义删除器sp(…, D)<br/> ②删除器可以定义为普通函数、匿名函数、函数指针等符合签名要求的可调用对象<br/> ③只有最后引用对象的sp销毁时才会销毁对象</strong></p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nvoid delFun(string *p)\n{\n    cout &lt;&lt; \"Fun delete \" &lt;&lt; *p &lt;&lt; endl;\n    delete p;\n}\n\nint main()\n{\n    cout &lt;&lt; \"begin\" &lt;&lt; endl;\n    shared_ptr&lt;string&gt; pTom;\n    {\n        shared_ptr&lt;string&gt; pTom1(new string(\"tom\"),\n                                 [](string* p) {\n            cout &lt;&lt; \"Lamda delete \" &lt;&lt; *p &lt;&lt; endl;\n            delete p;\n        });\n        pTom = pTom1;\n        shared_ptr&lt;string&gt; pJerry(new string(\"jerry\"), delFun);\n    }\n    cout &lt;&lt; \"end\" &lt;&lt; endl;\n\n    return 0;\n}\n\n</code></pre>\n<p><strong>①可以为数组创建一个共享指针，但这样做是错误的。<br/> ②共享指针提供的默认删除程序,将调用delete，而不是delete []<br/> ③可以使用自定义的删除器，删除器中使用delete[]<br/> ④也可以使用default_delete作删除器, 因为它使用delete []</strong></p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main()\n{\n    std::shared_ptr&lt;char&gt; sp1(new char[20]); //错误但能编译通过\n\n    std::shared_ptr&lt;char&gt; sp2(new char[20],\n                             [](char* p) {\n                                 delete[] p;\n                             }\n                            );\n\n    std::shared_ptr&lt;char&gt; sp3(new char[20],\n                              std::default_delete&lt;char[]&gt;());\n\n    return 0;\n}\n\n</code></pre>\n<p><strong>①除了释放内存，也可以释放其他资源<br/> ②要释放其他资源，就必须使用自定义的删除器</strong></p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;memory&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nclass FileDeleter\n{\n  public:\n    FileDeleter (const string&amp; sFileName)\n     : m_sFileName(sFileName) {\n    }\n\n    void operator () (ofstream* pOfs) {\n        delete pOfs;  //关闭文件\n        remove(m_sFileName.c_str()); //删除文件\n        cout &lt;&lt; \"Delete file -- \" &lt;&lt; m_sFileName &lt;&lt; endl;\n    }\n\n  private:\n    string m_sFileName;\n};\n\nint main()\n{\n    const string sFileName = \"TempFile.txt\";\n    std::shared_ptr&lt;ofstream&gt;\n            fp(new ofstream(sFileName),\n               FileDeleter(sFileName));\n    cout &lt;&lt; \"Program exit\" &lt;&lt; endl;\n\n    return 0;\n}\n\n</code></pre>\n<h2>强制类型转换</h2>\n<p><strong>①共享指针强制转换运算符允许将其中包裹的指针强制转换为其他类型。<br/> ②不能使用普通的强制转换运算符，因为它会导致未定义的行为。<br/> ③共享指针的强制类型转换运算符包括<br/> static_pointer_cast、<br/> dynamic_pointer_cast、<br/> const_pointer_cast</strong></p>\n<p></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main()\n{\n    shared_ptr&lt;void&gt; spv(new int(1));\n    shared_ptr&lt;int&gt; spe(static_cast&lt;int*&gt;(spv.get()));\n    shared_ptr&lt;int&gt; spn = static_pointer_cast&lt;int&gt;(spv);\n\n    cout &lt;&lt; *spe &lt;&lt; endl;\n    cout &lt;&lt; *spn &lt;&lt; endl;\n\n    return 0;\n}\n\n</code></pre>\n<h2>共享指针存在的问题</h2>\n<p><strong>①循环引用<br/> ②明确想要共享但不拥有对象</strong></p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-26 15:42:18", "summary": "是一种智能指针，它能够记录多少个共同指向一个对象，从而消除显示的调用，当引用计数变为零的时候就会将对象自动删除。可以通过方法来获取原始指针，通过来减少一个引用计数，并通过来查看一个对象的引用计数。例如"}