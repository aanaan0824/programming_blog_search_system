{"blogid": "120757832", "writerAge": "码龄2年", "writerBlogNum": "65", "writerCollect": "6547", "writerComment": "2223", "writerFan": "11747", "writerGrade": "6级", "writerIntegral": "7709", "writerName": "林慢慢脑瓜子嗡嗡的", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120757832.jpg", "writerRankTotal": "3879", "writerRankWeekly": "8855", "writerThumb": "3358", "writerVisitNum": "179676", "blog_read_count": "1219", "blog_time": "于 2021-10-14 09:53:27 发布", "blog_title": "【C++初阶】extern C,引用,内联函数,auto和指针空值", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>前言：紧跟上一篇文章，补完C++入门初期的零散知识点，本章知识点包括extern “C”、引用、内联函数、auto等内容！</strong></p>\n<hr/>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#1extern_C_29\">1.extern “C”</a></li><li><a href=\"#2_64\">2.引用</a></li><li><ul><li><a href=\"#21__66\">2.1 引用的概念</a></li><li><a href=\"#22__115\">2.2 引用的特性</a></li><li><a href=\"#23__168\">2.3 常引用</a></li><li><a href=\"#24__189\">2.4 引用的使用场景</a></li><li><ul><li><a href=\"#1_191\">（1）作参数</a></li><li><a href=\"#2_238\">（2）作返回值</a></li></ul>\n</li><li><a href=\"#25__277\">2.5 那么引用与指针有哪些区别？</a></li></ul>\n</li><li><a href=\"#3_293\">3.内联函数</a></li><li><ul><li><a href=\"#31__295\">3.1 概念</a></li><li><a href=\"#32__299\">3.2 三个特性</a></li></ul>\n</li><li><a href=\"#4auto_311\">4.auto关键字</a></li><li><ul><li><a href=\"#41__313\">4.1 概念</a></li><li><a href=\"#42_auto_339\">4.2 auto的使用细则</a></li><li><ul><li><a href=\"#421_auto_341\">4.2.1 auto与指针和引用结合起来使用</a></li><li><a href=\"#422__362\">4.2.2 在同一行定义多个变量</a></li></ul>\n</li><li><a href=\"#43_auto_381\">4.3 auto不能推导的场景</a></li><li><ul><li><a href=\"#431_auto_383\">4.3.1 auto不能直接用来声明数组.</a></li><li><a href=\"#432_auto_393\">4.3.2 auto声明的变量不能作为函数的形参类型</a></li></ul>\n</li></ul>\n</li><li><a href=\"#5nullptr_417\">5.指针空值nullptr</a></li><li><a href=\"#6_498\">6.习题（选择题，别慌！）</a></li><li><ul><li><ul><li><a href=\"#1_500\">练习题1</a></li><li><a href=\"#2_516\">练习题2：</a></li><li><a href=\"#3_530\">练习题3：</a></li><li><a href=\"#4_544\">练习题4：</a></li><li><a href=\"#5_559\">练习题5：</a></li><li><a href=\"#6_574\">练习题6：</a></li><li><a href=\"#7_588\">练习题7：</a></li><li><a href=\"#8_602\">练习题8：</a></li><li><a href=\"#9_616\">练习题9：</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"1extern_C_29\"></a>1.extern “C”</h1>\n<p><strong>我们知道，在C++代码当中可以调用C语言部分，但是在C语言编写的代码当中无法直接调用纯C++语言编写的内容，如何解决这一问题呢？</strong></p>\n<blockquote>\n<p>在C++模块前加上extern \"C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的，这样C语言便可以调用这部分C++编写的模块。</p>\n</blockquote>\n<blockquote>\n<p>比如：<code>tcmalloc</code>是google用C++实现的一个项目，他提供<code>tcmallc()</code>和<code>tcfree()</code><br/> 两个接口来使用，但如果是C项目就没办法直接使用，这时候就可以使用<code>extern “C”</code>来解决。</p>\n</blockquote>\n<p><strong>实例</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">//引入extern \"C\" 是告诉编译器其修饰下的函数的命名修饰规则按照C语言下的命名规则进行</span>\n<span class=\"token comment\">//即此时的函数add在转化到符号表中后为_Add 而非 _Z3Addii</span>\n <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> ret<span class=\"token operator\">=</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"image-20211011112006643\" src=\"..\\..\\static\\image\\2d5f4d53a0a30d80e5d39804a11bf22f.png\"/></p>\n<hr/>\n<h1><a id=\"2_64\"></a>2.引用</h1>\n<h2><a id=\"21__66\"></a>2.1 引用的概念</h2>\n<p>引用不同于指针，引用并不会定义新的变量，而是给原来的变量起一个“别名”，就好像华为公司，又被称为“菊厂”、“沸腾厂”等，而这些称呼指的对象都是华为公司，本质是一样的。因此编译器并不会为引用变量单独开辟一块内存空间，该变量与它引用的变量共用同一块内存空间。</p>\n<blockquote>\n<p>引用的符号为&amp;，其使用方法是 <strong>类型 + &amp; + 引用变量名称（对象名） = 引用实体</strong>； (引用实体的类型必须和<code>&amp;</code>前的类型保持一致)</p>\n</blockquote>\n<p><strong>示例代码：</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 一定要注意这里跟C取地址用了一个符号 &amp;</span>\n\t<span class=\"token comment\">// 但是他们之前没有关联，各个各用处</span>\n\t<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> d <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n\n\tc <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\td <span class=\"token operator\">=</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> e<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>观察到初始值均为10</strong></p>\n<p><img alt=\"image-20211011113009693\" src=\"..\\..\\static\\image\\d0fc0da48e64f2373d33bd1806c4d8e0.png\"/></p>\n<p><strong>当执行完 c=20之后，均为20</strong></p>\n<p><img alt=\"image-20211011113104671\" src=\"..\\..\\static\\image\\a2f6ecf9cac793733d572d5f697d41c4.png\"/></p>\n<p><strong>当执行完 d=30之后，均为30</strong></p>\n<p><img alt=\"image-20211011113131484\" src=\"..\\..\\static\\image\\8c75edd3b8c844ef86a5bd8fa2c5ec26.png\"/></p>\n<hr/>\n<h2><a id=\"22__115\"></a>2.2 引用的特性</h2>\n<blockquote>\n<p>1.引用在定义同时必须要初始化。比如在取别名的时候就需要有这个被取别名的对象。<br/> 2.一个引用实体可以有多个引用。<br/> 3.一旦引用变量成为了一个实体的引用，就不能再成为其他实体的引用。</p>\n</blockquote>\n<p><strong>示例代码：</strong></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n    int a = 10;  \n    int d = 100;\n    \n    int&amp; b = a; \n    //一旦写了引用,就必须有完整的实体,不能写成  int&amp; b;  这是不允许的,即第一条特性\n    \n    int&amp; c = a; \n    //a变量被引用了两次,也就是第二条特性意思\n    \n    c = d;\n    //前面c已经成了a的别名,那么c就永远只能是a的别名，只不过这里C的值变成了100（同样ab也变成100）.   第三     条特性意思\n\n    return 0;\n}\n</code></pre>\n<p><strong>来一道测试题看看，分别画出分割线之前和之后各个变量的图示</strong></p>\n<pre><code class=\"prism language-c++\">int x = 0,y = 1;\nint* p1 = &amp;x;\nint* p2 = &amp;y;\nint*&amp; p3 = p1;\n/————————————————分割线——————————————/\n*p3 = 10;\np3 = p2;\n</code></pre>\n<p><strong>分割线之前的：</strong></p>\n<p><img alt=\"image-20211011115123652\" src=\"..\\..\\static\\image\\2fb32145950f89463152ef1b0e72f23f.png\"/></p>\n<p><strong>分割线之后的：P3、P1均指向了y</strong></p>\n<p><img alt=\"image-20211011115158058\" src=\"..\\..\\static\\image\\8c199a761c8d8d4e7b8e3a9367186742.png\"/></p>\n<hr/>\n<h2><a id=\"23__168\"></a>2.3 常引用</h2>\n<blockquote>\n<p>常数无法直接引用，引用前需要加上const构成常引用，如下：</p>\n</blockquote>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> ra <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//该句代码编译出错，因为a为常量</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> ra <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//成功引用</span>\n\n<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> b <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//引用失败,因为100是常数,无法int引用</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> rb <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//成功引用</span>\n</code></pre>\n<p><strong>总结：可以缩小读写权限,但不能放大读写权限.</strong></p>\n<hr/>\n<h2><a id=\"24__189\"></a>2.4 引用的使用场景</h2>\n<h3><a id=\"1_191\"></a>（1）作参数</h3>\n<blockquote>\n<p>根据以上特性，<strong>引用在作参数过程中，引用能发挥哪些作用呢？</strong></p>\n</blockquote>\n<p>1.可以减少传参拷贝(引用作用)<br/> 2.可以保护形参不被修改，既可以接收变量,又可以接收常量(常量引用作用).</p>\n<p><strong>代码1：减少传参拷贝</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span>   <span class=\"token comment\">//某个结构体,假设他很大</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//某函数定义如下:  如果其参数设置为引用,将不需要通过函数传递方式中的值传递(拷贝),造成空间消耗巨大.</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">node</span><span class=\"token operator\">&amp;</span> node0<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//此处省略相关操作....</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>代码2：保护形参不被修改，既可以接收变量,又可以接收常量</strong></p>\n<pre><code class=\"prism language-c++\">int add(const int&amp; a,const int&amp; b)\n{\n    return a-b;  //比如加法函数,如果手误,码码错代码,修改了a或b的值,编译器会自动提示.\n}\n\nint main()\n{\n    int a = 10;\n    int b = 20;\n    \n    cout&lt;&lt;\"变量作为实参\"&lt;&lt;add(a,b)&lt;&lt;endl;\n    \n    cout&lt;&lt;\"常量作为实参\"&lt;&lt;add(10,20)&lt;&lt;endl;   //必须是常量引用,否则将无法接收实参.\n    return 0;\n}\n</code></pre>\n<h3><a id=\"2_238\"></a>（2）作返回值</h3>\n<blockquote>\n<p>首先来看看下面这段代码是否正确：</p>\n</blockquote>\n<pre><code class=\"prism language-c++\">int Add(int x, int y)\n{\n\tint z = x + y;\n\treturn z;\n}\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint&amp; ra = Add(a, b);\n\tcout &lt;&lt; ra &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>编译器对上述程序会报错！这是啥原因？</strong></p>\n<blockquote>\n<p>函数调用是会建立栈帧的，而栈帧在函数调用结束后会销毁并将这块栈帧还给操作系统，那么函数中创建的变量也会被销毁。</p>\n</blockquote>\n<p><strong>但是为什么函数的返回值还能被接收呢？</strong></p>\n<blockquote>\n<p>这是因为系统会创建一个临时变量，函数返回值会赋给这个临时变量，同时这个临时变量又会赋给要赋给的变量；<strong>而这种临时变量具有常性</strong>，<strong>只能赋给了一个类型为const int 的临时变量</strong>，而ra作为int类型的引用，显然是无法接收这个<strong>具有常性的临时变量</strong>。<br/> <img alt=\"image-20211011122145380\" src=\"..\\..\\static\\image\\75e07fa4e8853310253d5aad1474d662.png\"/></p>\n</blockquote>\n<p>注意：<strong>当引用作为函数返回值时,被引用的对象其作用域必须是有效范围,所以返回一个对局部变量的引用是不合法的,应该是返回值为全局变量或则static修饰的变量.</strong></p>\n<p><strong>引用作为引用实体的别名，没有独立空间，与实体共用同一块空间，但是在底层实现上，引用和指针的实现方式是一样的（可以通过编译器反汇编观察到）。</strong></p>\n<hr/>\n<h2><a id=\"25__277\"></a>2.5 那么引用与指针有哪些区别？</h2>\n<blockquote>\n<p>（1）引用需要初始化，而指针没有要求。<br/> （2）引用一旦作为一个引用实体的引用，就不能再作为其他实体的引用，但指针可以修改其所指向的对象的。<br/> （3）引用没有独立空间，而指针有，但是引用的效率也会更高（毕竟少开辟了一大块内存空间）。<br/> （4）对于sizeof，引用变量的大小与类型有关，指针变量的大小与类型无关。<br/> （5）对于自加，引用加一是数值上加一，而指针加一是跳过一个类型的大小。<br/> （6）访问实体的方式不同，指针是通过解引用访问，而引用是编译器自己处理。<br/> （7）引用使用起来相对于指针更安全。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"3_293\"></a>3.内联函数</h1>\n<h2><a id=\"31__295\"></a>3.1 概念</h2>\n<blockquote>\n<p><strong>一种通过<code>inline</code>修饰的函数,C++编译器进行编译时可以直接在函数调用的地方进行展开,减少了多余的函数栈帧开销,提高了程序运行效率</strong></p>\n</blockquote>\n<h2><a id=\"32__299\"></a>3.2 三个特性</h2>\n<blockquote>\n<p>一、 inline 是一种以空间换时间的做法，省去调用函数的开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。<br/> 二、inline 对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline 的函数体内有循环/递归等等，编译器优化时会忽略掉内联。<br/> 三、inline 不建议声明和定义分离，分离会导致链接错误。因为inline 被展开，就没有函数地址了，链接就会找不到。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"4auto_311\"></a>4.auto关键字</h1>\n<h2><a id=\"41__313\"></a>4.1 概念</h2>\n<blockquote>\n<p><strong>一个新的类型指示符,auto声明的变量必须由编译器在编译时期推导而得.</strong></p>\n</blockquote>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">auto</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//编译器会自行推导数据类型</span>\n\t<span class=\"token keyword\">auto</span> c <span class=\"token operator\">=</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//编译器会自行推导数据类型</span>\n\t<span class=\"token keyword\">auto</span> d <span class=\"token operator\">=</span> <span class=\"token number\">3.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//编译器会自行推导数据类型</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">typeid</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\">//显示变量类型</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">typeid</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">typeid</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"image-20211011123419527\" src=\"..\\..\\static\\image\\9759c1eec5772ea404b9e8c54e9ed6aa.png\"/></p>\n<hr/>\n<h2><a id=\"42_auto_339\"></a>4.2 auto的使用细则</h2>\n<h3><a id=\"421_auto_341\"></a>4.2.1 auto与指针和引用结合起来使用</h3>\n<blockquote>\n<p><strong>用auto声明<code>指针类型</code>时，auto和auto * 没有任何区别，但用auto声明引用类型时则必须加&amp;</strong></p>\n</blockquote>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tint a = 10;\n\tauto b = &amp;a;\n\tauto* c = &amp;a;\n\tauto&amp; d = a;\n\tcout &lt;&lt; typeid(b).name() &lt;&lt; endl;\n\tcout &lt;&lt; typeid(c).name() &lt;&lt; endl;\n\tcout &lt;&lt; typeid(d).name() &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20211011123753636\" src=\"..\\..\\static\\image\\54138475a815d5909342635e72740a9d.png\"/></p>\n<h3><a id=\"422__362\"></a>4.2.2 在同一行定义多个变量</h3>\n<blockquote>\n<p>当在同一行声明多个变量时，这些变量必须是<code>相同的类型</code>，否则编译器将会<code>报错</code>，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量</p>\n</blockquote>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">auto</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">auto</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> d <span class=\"token operator\">=</span> <span class=\"token number\">4.0</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//编译错误，c和d的初始表达式类型不同</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h2><a id=\"43_auto_381\"></a>4.3 auto不能推导的场景</h2>\n<h3><a id=\"431_auto_383\"></a>4.3.1 auto不能直接用来声明数组.</h3>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">TestAuto</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token comment\">//  错误</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">auto</span> b<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">4</span>，<span class=\"token number\">5</span>，<span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"432_auto_393\"></a>4.3.2 auto声明的变量不能作为函数的形参类型</h3>\n<blockquote>\n<p><strong>这是因为在编译阶段编译器无法推导形参的类型。</strong></p>\n</blockquote>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">Count</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> n<span class=\"token punctuation\">)</span><span class=\"token comment\">//错误</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Count</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h1><a id=\"5nullptr_417\"></a>5.指针空值nullptr</h1>\n<p><strong>在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针。如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：</strong></p>\n<pre><code class=\"prism language-c++\">void TestPtr()\n{\n\tint* p1 = NULL;\n\tint* p2 = 0;\n}\n</code></pre>\n<p><strong>实际上，NULL是一个宏，在C语言的头文件（stddef.h）中我们可以看到:</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\"><span class=\"token constant\">NULL</span></span></span>\n    <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">__cplusplus</span></span>\n        <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NULL</span> <span class=\"token expression\"><span class=\"token number\">0</span></span></span>\n    <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span>\n        <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NULL</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></span></span>\n    <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span>\n</code></pre>\n<p><strong>可以看到，在C++中，NULL被定义为字面常量0，其他情况下，NULL被无指针类型（void * ）的常量0，无论使用何种定义，在使用NULL作为空指针时，总会不可避免的出现一些问题</strong>。</p>\n<hr/>\n<p><strong>比如下例程序,大家现在猜猜输出结果会是啥?</strong></p>\n<pre><code class=\"prism language-c++\">void f(int x)\n{\n\tcout&lt;&lt;\"f(int)\"&lt;&lt;endl;\n}\nvoid f(int* x)\n{\n\tcout&lt;&lt;\"f(int*)\"&lt;&lt;endl;\n}\n\nint main()\n{\n\tf(0);\n\tf(NULL);\n\tf((int*)NULL);       \n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20211011124507223\" src=\"..\\..\\static\\image\\a72053e0fc31a0b3d2f337aa4f63c915.png\"/></p>\n<p><strong>我们传参<code>NULL</code>时候,本意是想调用第二个函数,但是编译器却认为我们想要调用第一个函数,这就是在C语言中使用NULL的缺陷,因此,C++提出了<code>nullptr</code>代替<code>NULL</code>。</strong></p>\n<blockquote>\n<p>在C++98中，编译器默认将NULL看成一个整型常量，在函数重载的作用下，编译器无法通过NULL来调用参数为指针类型的Test函数，这会产生歧义。如果要将其按照指针方式来使用，必须对其进行强转(void * )0。</p>\n</blockquote>\n<p><strong>需要注意：</strong></p>\n<blockquote>\n<p>1.nullptr在C++11中是作为新关键字引入的，因此在使用其表示空指针时，无需包含头文件。<br/> 2.在C++11中，sizeof(nullptr)与sizeof((void* )0)大小相同。<br/> 3.为了提高代码的健壮性，后续代码中表示指针空值时最好使用nullptr。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"6_498\"></a>6.习题（选择题，别慌！）</h1>\n<h3><a id=\"1_500\"></a>练习题1</h3>\n<p><img alt=\"image-20211011104952353\" src=\"..\\..\\static\\image\\128d6c59916fd46db26c04c2a530de0d.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105016027\" src=\"..\\..\\static\\image\\ed7a97392193591fee906c7546e19439.png\"/></p>\n<hr/>\n<h3><a id=\"2_516\"></a>练习题2：</h3>\n<p><img alt=\"image-20211011105027164\" src=\"..\\..\\static\\image\\9e538538263fe50cd1ea9ed189b0743a.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105049598\" src=\"..\\..\\static\\image\\bb88eb27c26205b209db7a92b0ea7857.png\"/></p>\n<hr/>\n<h3><a id=\"3_530\"></a>练习题3：</h3>\n<p><img alt=\"image-20211011105101030\" src=\"..\\..\\static\\image\\39a552968a8db7e3f772999cb05bda51.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105109259\" src=\"..\\..\\static\\image\\7293ebb3a06a14f2d0add7c0f180d973.png\"/></p>\n<hr/>\n<h3><a id=\"4_544\"></a>练习题4：</h3>\n<p><img alt=\"image-20211011105116646\" src=\"..\\..\\static\\image\\0a24d4e5d5532e885dfa8d2e154c4bcf.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105126662\" src=\"..\\..\\static\\image\\163dab7bfc2cc2ac3963a93eae242e00.png\"/></p>\n<hr/>\n<h3><a id=\"5_559\"></a>练习题5：</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e497f2946283463f8b648b0d078be583.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105149543\" src=\"..\\..\\static\\image\\17ee73eba2f25e83638deb68d694a843.png\"/></p>\n<hr/>\n<h3><a id=\"6_574\"></a>练习题6：</h3>\n<p><img alt=\"image-20211011105333696\" src=\"..\\..\\static\\image\\c6e12b14cc7dd1f8f48aeb1fe2933c71.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105415406\" src=\"..\\..\\static\\image\\31e3f0bc7d85a72f5eed30164ec6b4f4.png\"/></p>\n<hr/>\n<h3><a id=\"7_588\"></a>练习题7：</h3>\n<p><img alt=\"image-20211011105433244\" src=\"..\\..\\static\\image\\a8720b789345032ab3afe63e091f5b88.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105602424\" src=\"..\\..\\static\\image\\b4e7252f304c44a75ba9efb6ce055fb9.png\"/></p>\n<hr/>\n<h3><a id=\"8_602\"></a>练习题8：</h3>\n<p><img alt=\"image-20211011105627077\" src=\"..\\..\\static\\image\\90749d26efedd73f89a87de8cbcbb0ea.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105801296\" src=\"..\\..\\static\\image\\53d816614a9b1ebecde16582a5e74f18.png\"/></p>\n<hr/>\n<h3><a id=\"9_616\"></a>练习题9：</h3>\n<p><img alt=\"image-20211011105856784\" src=\"..\\..\\static\\image\\e8a5221247f1c0fc38ed25f336fce785.png\"/></p>\n<p><strong>解析：</strong></p>\n<p><img alt=\"image-20211011105909010\" src=\"..\\..\\static\\image\\3ba59cf12d242b59e12ca7a35a4fb3a8.png\"/></p>\n<hr/>\n<hr/>\n<p><strong>C++的extern “C”、引用、内联函数、auto内容</strong>到此介绍结束了，感谢您的阅读！！！<strong>如果内容对你有帮助的话，记得给我三连（点赞、收藏、关注）——做个手有余香的人。</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-10-14 09:53:27", "summary": "前言：紧跟上一篇文章，补完入门初期的零散知识点，本章知识点包括、引用、内联函数、等内容！文章目录引用引用的概念引用的特性常引用引用的使用场景作参数作返回值那么引用与指针有哪些区别？内联函数概念三个特性"}