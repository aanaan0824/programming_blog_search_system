{"blogid": "126492195", "writerAge": "码龄7年", "writerBlogNum": "304", "writerCollect": "2113", "writerComment": "126", "writerFan": "271", "writerGrade": "6级", "writerIntegral": "4537", "writerName": "瞻邈", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126492195.jpg", "writerRankTotal": "4286", "writerRankWeekly": "9723", "writerThumb": "311", "writerVisitNum": "367636", "blog_read_count": "503", "blog_time": "已于 2022-08-24 00:38:19 修改", "blog_title": "双目立体校正", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1. 为什么要进行立体校正</h1>\n<p>在2-View Geometry中，假设我们有<img alt=\"C_1\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?C_1\"/>和<img alt=\"C_2\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?C_2\"/>两个相机，<img alt=\"p_1\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_1\"/>、<img alt=\"p_2\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_2\"/>是空间中的三维点投影到不同相机上的像素点。在本文中，我们称<img alt=\"p_1\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_1\"/>、<img alt=\"p_2\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_2\"/>为对应的。 我们可以通过<a href=\"https://www.zhihu.com/search?q=%E4%B8%89%E8%A7%92%E5%8C%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2631686893%7D\" title=\"三角化\">三角化</a>的方法来得到P在三维空间中的坐标。而求解三角化问题需要已知相机内参、外参还有在像素点之间的对应关系。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\c94c46f4887c355bac78f4c11d4aeca3.jpeg\"/></p>\n<p>如何在两张不同的照片中寻找相对应的两个点是有难度的。给定<img alt=\"p_1\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_1\"/>的情况下，在另一张图片上遍历所有像素点搜索<img alt=\"p_2\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_2\"/>在计算上是非常昂贵的。 幸运的是，我们可以用对极约束（epipolar constraint）将搜索问题简化到一维上。根据对<a href=\"https://www.zhihu.com/search?q=%E6%9E%81%E5%87%A0%E4%BD%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2631686893%7D\" title=\"极几何\">极几何</a>的知识，我们可以知道的<img alt=\"p_1\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_1\"/>对应点<img alt=\"p_2\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?p_2\"/>一定是在另一张图片的极线上面的。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\ecbc0bde3097a9e3da9c7ad8c6be2e23.jpeg\"/></p>\n<p>但是因为大部分情况下极线是倾斜的，使用图像块去匹配的时候，往往效率不高，最方便的情况是能将极线与基线平行，即保持水平。因此我们需要进行立体校正Stereo Rectification。下图为通常情况下沿极线搜索对应点的示意图。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\10e58cd062291a85e33574e22d989994.jpeg\"/></p>\n<h1>2. 立体校正推导</h1>\n<p>我们可以认为虚构了两个具有以下特性的相机 <em> 两个相机是完全相同的，包括内参。 </em> 因为焦距相同，所以成像平面是共面的。 <em> 因为内参相同，对应点在同一水平线上，加速搜索。 </em> 基线必须平行于相机新的x轴，这样可以保证极线平行。 * 极线是平行的，因此极点在无穷远处。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\433d6b5c28b6fe63c50b952f4b33ac79.jpeg\"/></p>\n<p>我们通过单应变换来将原先的图片变换到新的虚拟相机的平面上。因此重点是求左右两边相机对应的单应变换。我们接下来就来推导这个单应变换。 一般我们通过旋转矩阵<img alt=\"R=R_{cw}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?R%3DR_%7Bcw%7D\"/>和平移向量</p>\n<p><img alt=\"t=t_{cw}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?t%3Dt_%7Bcw%7D\"/>来将点从世界坐标系变换到相机坐标系，此时<img alt=\"P_c = RP_w +t\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?P_c%20%3D%20RP_w%20&amp;plus;t\"/>其中<img alt=\"P_c\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?P_c\"/>是点在相机<a href=\"https://www.zhihu.com/search?q=%E5%9D%90%E6%A0%87%E7%B3%BB&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2631686893%7D\" title=\"坐标系\">坐标系</a>中的坐标，<img alt=\"P_w\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?P_w\"/>是点在世界坐标系中的坐标。我们一般会将透视投影写成以下的形式。</p>\n<p><img alt=\"\" height=\"718\" src=\"..\\..\\static\\image\\a82ae856d88c4c1a8bfb0a72076b60fa.png\" width=\"612\"/></p>\n<p><img alt=\"\" height=\"93\" src=\"..\\..\\static\\image\\b62b149e454d40a89ae6a8fc53ecc4d7.png\" width=\"739\"/><img alt=\"\" height=\"376\" src=\"..\\..\\static\\image\\29b88daec34842ba8f1239b8fae9f229.png\" width=\"720\"/></p>\n<p>在之后，我们写出左右两个相机的透视投影关系式。</p>\n<p><img alt=\"\" height=\"389\" src=\"..\\..\\static\\image\\d8ffb819a6bf44f5858b554fe13cdfb1.png\" width=\"720\"/></p>\n<p>我们假设了两个完全相同的虚拟相机，他们的成相平面是共面的（相同的外参<img alt=\"\\hat{R}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Chat%7BR%7D\"/>），同时他们具有相同的内参<img alt=\"\\hat{K}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Chat%7BK%7D\"/>。此时我们将世界中的点P投影到我们假设的两个相机平面上，可以得到如下的关系式。</p>\n<p><img alt=\"\" height=\"340\" src=\"..\\..\\static\\image\\ae58a27a2e374d3185829ff16b8f9edb.png\" width=\"720\"/></p>\n<p>经过观察，我们可以发现新的相机和旧的相机投影<a href=\"https://www.zhihu.com/search?q=%E5%85%B3%E7%B3%BB%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2631686893%7D\" title=\"关系式\">关系式</a>有相同的公共部分</p>\n<p>我们通过提取这个公共部分可以推导出以下的关系式。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\e1f612e03156840dfeb0a785729065d4.jpeg\"/></p>\n<p>这就是我们在立体校正过程中，将原图像变换到新的虚拟相机上的单应变换。</p>\n<p>此时仅需要求解虚拟相机的内参<img alt=\"\\hat{K}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Chat%7BK%7D\"/>以及旋转矩阵<img alt=\"\\hat{R}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Chat%7BR%7D\"/></p>\n<h1><img alt=\"\" height=\"230\" src=\"..\\..\\static\\image\\94aa979a6a0741868bfa117ec072a831.png\" width=\"744\"/></h1>\n<h1>3. 立体校正流程</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f12ef9ff69c3b7211d88e973a06dce86.jpeg\"/></p>\n<p>先进行图片的去畸变。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f96ad279f089bfdeb66e07bc141dd4aa.jpeg\"/></p>\n<p>再计算立体校正需要的单应变换，使用双线性插值完成变换。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\93f9102a6f52b54d6c0c354203794767.jpeg\"/></p>\n<h1>4. OpenCV中的StereoRectify</h1>\n<h2>4.1. cv::fisheye::stereoRectify</h2>\n<p>cv::fisheye::StereoRectify()函数, 主要用于对双目图像做出矫正,计算出用于立体矫正的参数;具体的使用方法如下:</p>\n<pre><code class=\"language-cpp\">void cv::fisheye::stereoRectify\t(InputArray K1,InputArray D1,\n                                 InputArray K2, InputArray D2,\n                                 const Size &amp;imageSize, InputArray R, \n                                 InputArray tvec, \n                                 OutputArray \tR1,OutputArray \tR2,\n                                 OutputArray P1, OutputArray P2, OutputArray Q, \n                                 int flags, const Size &amp;newImageSize = Size(), \n                                 double balance = 0.0, double fov_scale = 1.0)\t</code></pre>\n<p>其中参数的含义如下:</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td>K1</td><td>第一个相机的内参,Size为3x3, 数据类型为CV_32F 或者 CV_64F</td></tr><tr><td>D1</td><td>第一个相机的畸变参数, Size必须为4x1, 数据类型为CV_32F 或者 CV_64F</td></tr><tr><td>K2</td><td>第二个相机的内参,Size为3x3, 数据类型为CV_32F 或者 CV_64F</td></tr><tr><td>D2</td><td>第二个相机的畸变参数, Size必须为4x1, 数据类型为CV_32F 或者 CV_64F</td></tr><tr><td>imageSize</td><td>做双目标定StereoCalibration() 时用的图片的size, 如ImageSize = cv::Size(640,480)</td></tr><tr><td>R</td><td>两个相机之间的旋转矩阵, Rrl, 如果内参采用Kalibr标定, 那么这里的R就是Kalibr标定出的T的前3x3</td></tr><tr><td>tvec</td><td>两个相机之间的平移向量,trl, 即为左目相机在右目相机坐标系中的坐标, 所以,如果两个相机左右摆放, 该向量中x值一般为负数;</td></tr><tr><td>R1</td><td>第一个相机的修正矩阵, 即从实际去畸变后的左目摆放位姿到经过极线矫正后的左目位姿之间, 有一个旋转量,为R1</td></tr><tr><td>R2</td><td>第二个相机的修正矩阵, 即从实际去畸变后的右目摆放位姿到经过极线矫正后的右目位姿之间, 有一个旋转量,为R2</td></tr><tr><td>P1</td><td>修正后第一个相机的投影矩阵; P1包含了R1和K1, 可直接将左目相机坐标系的三维点,投影到像素坐标系中; 要注意会投影到修正后的图像中</td></tr><tr><td>P2</td><td>修正后第二个相机的投影矩阵; P2包含了R2和K2, 可直接将左目相机坐标系的三维点,投影到像素坐标系中; 要注意会投影到修正后的图像中</td></tr><tr><td>Q</td><td>视差图转换成深度图的矩阵; </td></tr><tr><td>flags</td><td>Operation flags that may be zero or fisheye::CALIB_ZERO_DISPARITY . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</td></tr><tr><td>newImageSize</td><td>修正后图像的新Size.  该参数应该与下一步使用initUndistortRectifyMap()时所使用的iMAGE SIZE一致. 默认为 (0,0), 表示和 imageSize 一致. 当图像的径向畸变较严重时, 这个值设置的大一点,可以更好地保留一个细节;  (see the stereo_calib.cpp sample in OpenCV samples directory)</td></tr><tr><td>balance</td><td>值在[0,1]之间, 设置这个值可以改变新图像的focal length, 从最小值到最大值之间变动;</td></tr><tr><td>fov_scale</td><td>新的focal length = original focal length/ fov_scale</td></tr></tbody></table>\n<p>使用示例</p>\n<pre><code class=\"language-cpp\">//设定左目内参和畸变参数: 分别是3x3和4x1\nMat cameraMatrixL =(Mat_&lt;double&gt;(3, 3) &lt;&lt; 216.0891385028069, 0., 319.19103592168216, 0.,286.915780332698, 237.28788884900933, 0., 0., 1.);\n \nMat distCoeffL =(Mat_&lt;double&gt;(4, 1) &lt;&lt; 0.16031814840882294, 0.09948097914060017,\n                                      -0.05647543763319335, 0.02313587059407878);\n//设定右目内参和畸变参数: 分别是3x3和4x1\nMat cameraMatrixR =(Mat_&lt;double&gt;(3, 3) &lt;&lt; 216.47145152004367, 0., 319.57751832884156, 0.,287.23866506549973, 240.30796467665027, 0., 0., 1.);\n \nMat distCoeffR = (Mat_&lt;double&gt;(4, 1) &lt;&lt; 0.15400500709721424, 0.109194432654468,\n                                      -0.06512886784397008, 0.025788980687450808);\n//设定两个相机之间的旋转和平移, R为Rrl\nMat R = (Mat_&lt;double&gt;(3, 3) &lt;&lt; \n        0.9998867545031103, -0.007295111520593036,0.013162808102250304, \n        0.007472043953567141, 0.9998817186236534,-0.01344311427322331, \n        -0.013063182169384159, 0.013539944981760093,0.9998229959155261);\n//从平移的数值应该能看出来, t为 左目相机在右目相机的坐标系中的位置\nMat T = (Mat_&lt;double&gt;(3, 1) &lt;&lt; \n        -0.10139343341319906, -0.0003237508769501881,0.0013986876758678593);\n \nMat Rl, Rr, Pl, Pr, Q;\n \ncv::fisheye::stereoRectify(cameraMatrixL, distCoeffL, cameraMatrixR, distCoeffR, imageSize,R, T, Rl, Rr, Pl, Pr, Q, CALIB_ZERO_DISPARITY, imageSize);\n//使用R1,P1输出两个映射矩阵\ncv::fisheye::initUndistortRectifyMap(cameraMatrixL, distCoeffL, Rl, Pl, \n                                     imageSize,CV_32FC1, mapLx, mapLy);\n//使用R2,P2输出两个映射矩阵\ncv::fisheye::initUndistortRectifyMap(cameraMatrixR, distCoeffR, Rr, Pr, \n                                     imageSize,V_32FC1, mapRx, mapRy);\nMat ImageL, ImageR;\nImageL = cv::imread(\"left.png\",-1);\nImageR = cv::imread(\"right.png\", -1);\n//将双目矫正后的图像放入rectifyImageL2和rectifyImageR2中\nMat rectifyImageL2, rectifyImageR2;\ncv::remap(ImageL, rectifyImageL2, mapLx, mapLy, cv::INTER_LINEAR);\ncv::remap(ImageR, rectifyImageR2, mapRx, mapRy, cv::INTER_LINEAR);</code></pre>\n<h2>4.2. cv::stereoRectify</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;opencv2/core/core.hpp&gt;\n#include &lt;opencv2/calib3d/calib3d.hpp&gt;\n\n\nint main( int argc, char* argv[] )\n{\n   cv::Mat K0 = (cv::Mat_&lt;double&gt;(3,3) &lt;&lt; 1457.572438721727, 0, 1212.945694211622, 0, 1457.522226502963, 1007.32058848921, 0, 0, 1);\n   cv::Mat kk0 =  cv::Mat_&lt;double&gt;::zeros(1,5);\n   cv::Mat K1 = (cv::Mat_&lt;double&gt;(3,3) &lt;&lt; 1460.868570835972, 0, 1215.024068023046, 0, 1460.791367088, 1011.107202932225, 0, 0, 1);\n   cv::Mat kk1 =  cv::Mat_&lt;double&gt;::zeros(1,5);\n\n   cv::Mat R = (cv::Mat_&lt;double&gt;(3,3) &lt;&lt; 0.9985404059825475, 0.02963547172078553, -0.04515303352041626, -0.03103795276460111, 0.9990471552537432, -0.03068268351343364, 0.04420071389006859, 0.03203935697372317, 0.9985087763742083 );\n\n   cv::Mat T = (cv::Mat_&lt;double&gt;(3,1) &lt;&lt; 0.9995500167379527, 0.0116311595111068, 0.02764923448462666 );\n\n   cv::Size imgsize( 2456, 2058 );\n\n   cv::Mat R1;\n   cv::Mat R2;\n   cv::Mat P1;\n   cv::Mat P2;\n   cv::Mat Q;\n\n   cv::Rect RL;\n   cv::Rect RR;\n\n   cv::stereoRectify( K0, kk0, K1, kk1, imgsize, R, T, R1, R2, P1, P2, Q, 0, 1.0, imgsize,  &amp;RL, &amp;RR );\n\n   std::cout &lt;&lt; \"Results with OpenCV \" &lt;&lt; CV_VERSION_MAJOR &lt;&lt; \".\" &lt;&lt; CV_VERSION_MINOR &lt;&lt; \".\" &lt;&lt; CV_VERSION_REVISION &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"R1 = \" &lt;&lt; R1 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"R2 = \" &lt;&lt; R1 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"P1 = \" &lt;&lt; R1 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"P2 = \" &lt;&lt; R1 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \" Q = \" &lt;&lt; Q &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"RL = \" &lt;&lt; RL &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"RR = \" &lt;&lt; RR &lt;&lt; std::endl;\n\n   return 0;\n}\n</code></pre>\n<p><a href=\"https://www.zhihu.com/question/486136535/answer/2631686893\" title=\"双目视觉之立体校正的过程是什么？ - 知乎\">双目视觉之立体校正的过程是什么？ - 知乎</a></p>\n<p><a href=\"https://blog.csdn.net/qq_25458977/article/details/114829674\" title=\"正确使用StereoRectify_三轮车的视觉进阶_的博客-CSDN博客_stereorectify\">正确使用StereoRectify_三轮车的视觉进阶_的博客-CSDN博客_stereorectify</a></p>\n<p><a href=\"https://github.com/opencv/opencv/issues/11131\" title=\"cv::stereoRectify  gives different results between version 3.4.0 and 3.4.1 · Issue #11131 · opencv/opencv · GitHub\">cv::stereoRectify gives different results between version 3.4.0 and 3.4.1 · Issue #11131 · opencv/opencv · GitHub</a></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-24 00:38:19", "summary": "为什么要进行立体校正在中，假设我们有和两个相机，、是空间中的三维点投影到不同相机上的像素点。在本文中，我们称、为对应的。我们可以通过三角化三角化的方法来得到在三维空间中的坐标。而求解三角化问题需要已知"}