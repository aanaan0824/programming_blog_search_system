{"blogid": "125109070", "writerAge": "码龄2年", "writerBlogNum": "100", "writerCollect": "98", "writerComment": "8", "writerFan": "21", "writerGrade": "4级", "writerIntegral": "1012", "writerName": "缘笙箫196", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125109070.jpg", "writerRankTotal": "37180", "writerRankWeekly": "285188", "writerThumb": "14", "writerVisitNum": "58916", "blog_read_count": "1392", "blog_time": "已于 2022-06-04 16:49:59 修改", "blog_title": "Unity——异步方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>异步方法和同步方法的区别</strong></p>\n<p><strong>        同步方法：</strong></p>\n<p>                方法中逻辑执行完毕后，再继续执行后面的方法</p>\n<p><strong>        异步方法：</strong></p>\n<p>                方法中逻辑可能还没有执行完毕，就继续执行后面的内容</p>\n<p></p>\n<p><strong>        异步方法的本质：</strong></p>\n<p>                往往异步方法当中都会使用多线程执行某部分逻辑</p>\n<p>                因为我们不需要等待方法中逻辑执行完毕就可以继续执行下面的逻辑了</p>\n<p></p>\n<p><strong>注：</strong>unity中的协同程序中的某些异步方法，有的使用的是多线程有的使用的是迭代器分步执行。</p>\n<p></p>\n<p><strong>异步倒计时</strong></p>\n<p><strong>        1.线程回调</strong></p>\n<pre><code class=\"language-cs\">        CountDownAsync(5, () =&gt;\n        {\n            print(\"倒计时结束\");\n        });\n        print(\"这就是异步进行倒计时\");\n\n    /// &lt;summary&gt;\n    /// 倒计时\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"second\"&gt;倒计时的时间&lt;/param&gt;\n    /// &lt;param name=\"callBack\"&gt;倒计时后需要执行的函数&lt;/param&gt;\n    public void CountDownAsync(int second,UnityAction callBack)\n    {\n        //每次调用都开一个线程来进行倒计时\n        Thread t = new Thread(() =&gt;\n        {\n            while (true)\n            {\n                print(second); //输出秒数\n                Thread.Sleep(1000); //该线程休眠1s\n                --second;\n\n                //如果倒计时到达0之后就跳出循环\n                if (second == 0)\n                    break;\n            }\n            callBack?.Invoke(); //callBack不为null就执行callBack方法\n        });\n\n        t.Start(); // 启动该线程\n\n        print(\"开始倒计时\");\n    }</code></pre>\n<p><img alt=\"\" height=\"619\" src=\"..\\..\\static\\image\\82363f3469944af49f90658332ca1a86.png\" width=\"751\"/></p>\n<p></p>\n<p>        <strong>2.async和awit 会等待线程执行完毕 继续执行后面的逻辑</strong></p>\n<p><strong>           相对第一种方式 可以让函数分布执行</strong></p>\n<pre><code class=\"language-cs\">        CountDownAsync(5);\n        print(\"这是另外一种异步进行的倒计时\");\n\n    public async void CountDownAsync(int second)\n    {\n        print(\"倒计时开始\");\n\n        //await代表要等待该步运行完了之后再运行下面的程序\n        await Task.Run(() =&gt; {\n            while (true)\n            {\n                print(second);\n                Thread.Sleep(1000);\n                --second;\n                if (second == 0)\n                    break;\n            }\n        });\n\n        print(\"倒计时结束\");\n    }</code></pre>\n<p><img alt=\"\" height=\"619\" src=\"..\\..\\static\\image\\8a765297fe2c4573ae3ddf6c602931b9.png\" width=\"751\"/></p>\n<p></p>\n<p><strong>Socket TCP通信中的异步方法（Begin开头的方法）</strong></p>\n<p><strong>        </strong>回调函数参数IAsyncResult</p>\n<p>        AsyncState 调用异步方法时传入的参数 需要转换</p>\n<p>        AsyncWaitHandle 用于同步等待</p>\n<p>        内部开多线程，通过回调形式返回结果，需要和End相关方法 配合使用</p>\n<p></p>\n<p>        <strong>服务器相关（BeginAccept、EndAccept）    </strong></p>\n<pre><code class=\"language-cs\">        //服务器相关\n        socketTCP.BeginAccept(AcceptCallBack, socketTCP); //BeginAccept的第二个参数会转化为 IAsyncResult 并作为回调函数的参数使用\n\n\n    /// &lt;summary&gt;\n    /// 连入客户端\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"result\"&gt;传入Socket&lt;/param&gt;\n    private void AcceptCallBack(IAsyncResult result)\n    {\n        try\n        {\n            //获取到传入的参数\n            Socket s = result.AsyncState as Socket;\n\n            //通过调用EndAccept就可以得到连入的客户端Socket\n            Socket clientSocket = s.EndAccept(result);\n\n            //再开一个异步去监听下一个连入的客户端\n            s.BeginAccept(AcceptCallBack, s);\n        }\n        catch(SocketException e)\n        {\n            print(e.SocketErrorCode);\n        }\n    }</code></pre>\n<p>        <strong>客户端相关（BeginConnect、EndConnect）</strong></p>\n<pre><code class=\"language-cs\">IPEndPoint ipPoint = new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 8080);\n        socketTcp.BeginConnect(ipPoint, (result) =&gt;\n        {\n            Socket s = result.AsyncState as Socket;\n            try\n            {\n                s.EndConnect(result);\n                print(\"连接成功\");\n            }\n            catch (SocketException e)\n            {\n                print(\"连接出错\" + e.SocketErrorCode + e.Message);\n            }\n\n        }, socketTcp);</code></pre>\n<p></p>\n<p>        <strong>服务端和客户端通用</strong></p>\n<p><strong>        </strong>        <strong>接收消息（BeginReceive、EndReceive）</strong></p>\n<pre><code class=\"language-cs\"> //接收消息\n        socketTCP.BeginReceive(resultBytes, 0, resultBytes.Length, SocketFlags.None, ReceiveCallBack, socketTCP);\n\n\n    private void ReceiveCallBack(IAsyncResult result)\n    {\n        try\n        {\n            Socket s = result.AsyncState as Socket;\n\n            //这个返回值是你收到了多少个字节\n            int num = s.EndReceive(result);\n\n            //进行消息处理\n            Encoding.UTF8.GetString(resultBytes, 0, num);\n\n            //回调函数，继续接收下一个消息\n            s.BeginReceive(resultBytes, 0, resultBytes.Length, SocketFlags.None, ReceiveCallBack, s);\n        }catch(SocketException e)\n        {\n            print(\"接受消息出现问题\" + e.SocketErrorCode + e.Message);\n        }\n    }</code></pre>\n<p>                <strong>发送消息（BeginSend、EndSend）</strong></p>\n<pre><code class=\"language-cs\">         //发送消息\n        byte[] bytes = Encoding.UTF8.GetBytes(\"123456789\");\n\n        socketTCP.BeginSend(bytes, 0, bytes.Length, SocketFlags.None, (result) =&gt;\n        {\n            try\n            {\n                socketTCP.EndSend(result);\n                print(\"发送成功\");\n            }\n            catch (SocketException e)\n            {\n                print(\"发送错误\" + e.SocketErrorCode + e.Message);\n            }\n        }, socketTCP);</code></pre>\n<p></p>\n<p><strong>Socket TCP通信中的异步（Async结尾方法）</strong></p>\n<p>        关键变量类型（SocketAsyncEventArgs）</p>\n<p>        它会作为Async异步方法的传入值，我们需要通过它进行一些关键参数的赋值</p>\n<p>        内部开多线程，通过回调形式返回结果，依赖SocketAsyncEventArgs对象配合使用</p>\n<p></p>\n<p>        <strong>服务器端（AcceptAsync）</strong></p>\n<pre><code class=\"language-cs\">        //服务器端\n        SocketAsyncEventArgs e = new SocketAsyncEventArgs();//异步的一个参数后续很多操作都要基于这个变量\n\n        e.Completed += (socket, args) =&gt;\n        {\n            //首先判断是否连接成功\n            if (args.SocketError == SocketError.Success)\n            {\n                //获取连入的socket\n                Socket clientSocket = args.AcceptSocket;\n\n                (socket as Socket).AcceptAsync(args);\n            }\n            else\n            {\n                print(\"连入客户端失败\" + args.SocketError);\n            }\n        };\n        socketTCP.AcceptAsync(e);</code></pre>\n<p>        <strong>客户端(ConnectAsync)</strong></p>\n<pre><code class=\"language-cs\"> //客户端\n        SocketAsyncEventArgs e2 = new SocketAsyncEventArgs();\n\n        e2.Completed += (socket, args) =&gt;\n        {\n            if (args.SocketError == SocketError.Success)\n            {\n                //连接成功\n            }\n            else\n            {\n                //连接失败\n                print(args.SocketError);\n            }\n        };\n        socketTCP.ConnectAsync(e2);</code></pre>\n<p>        <strong>发送消息（SendAsync）</strong></p>\n<pre><code class=\"language-cs\">        //发送消息\n        SocketAsyncEventArgs e3 = new SocketAsyncEventArgs();\n\n        byte[] bytes2 = Encoding.UTF8.GetBytes(\"yuanshengxiao缘笙箫\");\n\n        e3.SetBuffer(bytes2, 0, bytes2.Length);\n        e3.Completed += (socket, args) =&gt;\n        {\n            if (args.SocketError == SocketError.Success)\n            {\n                print(\"发送成功\");\n            }\n            else\n            {\n\n            }\n        };\n        socketTCP.SendAsync(e3);</code></pre>\n<p>·        <strong>接收消息（ReceiveAsync）</strong></p>\n<pre><code class=\"language-cs\">        SocketAsyncEventArgs e4 = new SocketAsyncEventArgs();\n        //设置接受数据的容器，偏移位置，容量\n        e4.SetBuffer(new byte[1024 * 1024], 0, 1024 * 1024);\n        e4.Completed += (socket, args) =&gt;\n        {\n            if(args.SocketError == SocketError.Success)\n            {\n                //收取存储在容器当中的字节\n                //Buffer是容器\n                //BytesTransferred是收取了多少个字节\n                Encoding.UTF8.GetString(args.Buffer, 0, args.BytesTransferred);\n\n                args.SetBuffer(0, args.Buffer.Length);\n                //接收完消息 再接收下一条\n                (socket as Socket).ReceiveAsync(args);\n            }\n            else\n            {\n\n            }\n        };\n        socketTcp.ReceiveAsync(e4);</code></pre>\n<p></p>\n<p><strong>服务端</strong></p>\n<p><strong>        Program</strong></p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 异步服务端\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ServerSocket serverSocket = new ServerSocket();\n            serverSocket.Start(\"127.0.0.1\", 8080, 1024);\n            Console.WriteLine(\"开启服务器成功\");\n\n            while (true)\n            {\n                string input = Console.ReadLine();\n                if(input.Substring(0,2) == \"B:\")\n                {\n                    serverSocket.Broadcast(input.Substring(2));\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>        <strong>ServerSocket</strong></p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 异步服务端\n{\n    class ServerSocket\n    {\n        private Socket socket;\n        private Dictionary&lt;int, ClientSocket&gt; clientDic = new Dictionary&lt;int, ClientSocket&gt;();\n\n        public void Start(string ip,int port,int num)\n        {\n            socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint ipPoint = new IPEndPoint(IPAddress.Parse(ip), port);\n\n            try\n            {\n                socket.Bind(ipPoint);\n                socket.Listen(num);\n\n                //通过异步接收客户端连入\n                socket.BeginAccept(AcceptCallBack, null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(\"启动服务器失败\" + e.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 客户端连入的回调函数\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"result\"&gt;&lt;/param&gt;\n        private void AcceptCallBack(IAsyncResult result)\n        {\n            try\n            {\n                //获取连入的客户端\n                Socket clientSocket = socket.EndAccept(result);\n                ClientSocket client = new ClientSocket(clientSocket);\n\n                //记录客户端对象\n                clientDic.Add(client.clientID, client);\n\n                //继续让等待别的客户端连入\n                socket.BeginAccept(AcceptCallBack, null);\n            }\n            catch(Exception e)\n            {\n                Console.WriteLine(\"客户端连入失败\" + e.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 广播消息\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"str\"&gt;需要广播的消息&lt;/param&gt;\n        public void Broadcast(string str)\n        {\n            foreach(ClientSocket client in clientDic.Values)\n            {\n                client.Send(str);\n            }\n        }\n    }\n}\n</code></pre>\n<p>        <strong>ClientSocket</strong></p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 异步服务端\n{\n    class ClientSocket\n    {\n        public Socket socket;\n        public int clientID;\n        private static int CLIENT_BEGIN_ID = 1;\n\n        private byte[] cacheBytes = new byte[1024];\n        private int cacheNum = 0;\n\n        public ClientSocket(Socket socket)\n        {\n            this.clientID = CLIENT_BEGIN_ID++; //将ID赋值给该客户端之后就加1方便下一个客户端赋值\n            this.socket = socket;\n\n            //开始接收消息\n            this.socket.BeginReceive(cacheBytes, cacheNum, cacheBytes.Length, SocketFlags.None, ReceiveCallBack, null);\n        }\n\n        /// &lt;summary&gt;\n        /// 接收的回调函数\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"result\"&gt;因为是在该类里面所以可以直接传this.不用传具体的值&lt;/param&gt;\n        private void ReceiveCallBack(IAsyncResult result)\n        {\n            try\n            {\n                cacheNum = this.socket.EndReceive(result);//Begin和End进行配对\n\n                //通过字符串去解析\n                Console.WriteLine(Encoding.UTF8.GetString(cacheBytes, 0, cacheNum));\n\n                //如果是连接状态再继续接收消息\n                //因为目前我们是以字符串的形式解析的 所以 解析完 就直接从0开始\n                cacheNum = 0;\n                if (this.socket.Connected)\n                    this.socket.BeginReceive(cacheBytes, cacheNum, cacheBytes.Length, SocketFlags.None, ReceiveCallBack, null);\n                else\n                {\n                    Console.WriteLine(\"没有连接，不用再收消息了\");\n                }\n            }\n            catch(SocketException e)\n            {\n                Console.WriteLine(\"接收消息错误\" + e.SocketErrorCode + e.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 发送消息\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"str\"&gt;要发送的消息&lt;/param&gt;\n        public void Send(string str)\n        {\n            if (this.socket.Connected)\n            {\n                byte[] bytes = Encoding.UTF8.GetBytes(str);\n                this.socket.BeginSend(bytes, 0, bytes.Length, SocketFlags.None, SendCallBack, null);\n            }\n            else\n            {\n\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 发送的回调函数\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"result\"&gt;&lt;/param&gt;\n        private void SendCallBack(IAsyncResult result)\n        {\n            try\n            {\n                this.socket.EndSend(result);\n            }\n            catch(SocketException e)\n            {\n                Console.WriteLine(\"发送失败\" + e.SocketErrorCode + e.Message);\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>客户端</strong></p>\n<p><strong>        NetAsyncMgr</strong></p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing UnityEngine;\n\npublic class NetAsyncMgr : MonoBehaviour\n{\n    private static NetAsyncMgr instance;\n\n    public static NetAsyncMgr Instance =&gt; instance;\n\n    //和服务器进行连接的socket\n    private Socket socket;\n\n    //接受消息用的 缓冲容器\n    private byte[] cacheBytes = new byte[1024];\n    private int cacheNum = 0;\n\n    private void Awake()\n    {\n        instance = this;\n\n        //过场景不移除\n        DontDestroyOnLoad(this.gameObject);\n    }\n\n    /// &lt;summary&gt;\n    /// 连接服务器\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"ip\"&gt;服务器的ip&lt;/param&gt;\n    /// &lt;param name=\"port\"&gt;服务器的端口&lt;/param&gt;\n    public void Connect(string ip,int port)\n    {\n        if (socket != null &amp;&amp; socket.Connected)\n            return;\n\n        IPEndPoint ipPoint = new IPEndPoint(IPAddress.Parse(ip), port);\n        socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n\n        SocketAsyncEventArgs args = new SocketAsyncEventArgs(); //回调函数的参数\n        args.RemoteEndPoint = ipPoint;\n        args.Completed += (socket, args) =&gt;  //该lambda表达式代表在连接完成之后，执行后面的函数\n        {\n            if(args.SocketError == SocketError.Success)\n            {\n                print(\"连接成功\");\n\n                //收消息\n                SocketAsyncEventArgs receiveArgs = new SocketAsyncEventArgs();\n                receiveArgs.SetBuffer(cacheBytes, 0, cacheBytes.Length); //利用setBufffer设置接受的字节串，第一个是接受的容器，第二个参数是从哪开始存储，第二个是接收的最大长度\n                receiveArgs.Completed += ReceiveCallBack; //接收完毕后，调用处理的函数\n                this.socket.ReceiveAsync(receiveArgs);\n            }\n            else\n            {\n                print(\"连接失败\" + args.SocketError);\n            }\n        };\n        socket.ConnectAsync(args);\n    }\n\n    /// &lt;summary&gt;\n    /// 收消息完成后的回调函数\n    /// &lt;/summary&gt;\n    public void ReceiveCallBack(object obj,SocketAsyncEventArgs args)\n    {\n        if (args.SocketError == SocketError.Success)\n        {\n            //解析消息 目前用的字符串规则   args.Buffer是字节串  args.BytesTransferred是字节长度\n            print(Encoding.UTF8.GetString(args.Buffer, 0, args.BytesTransferred));\n\n            //继续接收消息\n            args.SetBuffer(0, args.Buffer.Length);\n\n            //继续异步收消息\n            if (this.socket != null &amp;&amp; this.socket.Connected)\n                socket.ReceiveAsync(args);\n            else\n                Close();\n        }\n        else\n        {\n            print(\"接受消息出错\" + args.SocketError);\n            //关闭客户端连接\n            Close();\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 关闭该客户端的连接\n    /// &lt;/summary&gt;\n    public void Close()\n    {\n        if(socket != null)\n        {\n            socket.Shutdown(SocketShutdown.Both);\n            socket.Disconnect(false);\n            socket.Close();\n            socket = null;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 发送消息\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"str\"&gt;发送的消息&lt;/param&gt;\n    public void Send(string str)\n    {\n        if (this.socket != null &amp;&amp; this.socket.Connected)\n        {\n            byte[] bytes = Encoding.UTF8.GetBytes(str);\n            SocketAsyncEventArgs args = new SocketAsyncEventArgs();\n            args.SetBuffer(bytes, 0, bytes.Length);\n\n            args.Completed += (socket, args) =&gt;\n            {\n                if (args.SocketError != SocketError.Success)\n                {\n                    print(\"接受消息出错\" + args.SocketError);\n                    //关闭客户端连接\n                    Close();\n                }\n            };\n            this.socket.SendAsync(args);\n        }\n        else\n        {\n            Close();\n        }\n    }\n}\n</code></pre>\n<p><strong>        MainAsync</strong></p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MainAsync : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        //如果场景里面没有Instance的函数就添加一个\n        if(NetAsyncMgr.Instance == null)\n        {\n            GameObject obj = new GameObject(\"NetAsync\");\n            obj.AddComponent&lt;NetAsyncMgr&gt;();\n        }\n\n        NetAsyncMgr.Instance.Connect(\"127.0.0.1\", 8080);\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n}\n</code></pre>\n<p>        <strong>Lesson13</strong></p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class Lesson13 : MonoBehaviour\n{\n    public Button btnSend;\n    public InputField input;\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        btnSend.onClick.AddListener(() =&gt;\n        {\n            if (input.text != \"\")\n                NetAsyncMgr.Instance.Send(input.text);\n        });\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n}\n</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-04 16:49:59", "summary": "异步方法和同步方法的区别同步方法：方法中逻辑执行完毕后，再继续执行后面的方法异步方法：方法中逻辑可能还没有执行完毕，就继续执行后面的内容异步方法的本质：往往异步方法当中都会使用多线程执行某部分逻辑因为"}