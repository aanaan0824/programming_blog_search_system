{"blogid": "124828768", "writerAge": "码龄4年", "writerBlogNum": "12", "writerCollect": "118", "writerComment": "23", "writerFan": "186", "writerGrade": "2级", "writerIntegral": "313", "writerName": "只要六元", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124828768.jpg", "writerRankTotal": "45134", "writerRankWeekly": "486878", "writerThumb": "34", "writerVisitNum": "17224", "blog_read_count": "1594", "blog_time": "已于 2022-05-22 19:49:39 修改", "blog_title": "C++学习之Socket", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"Socket_0\"></a>Socket是什么</h2>\n<p>socket就是套接字的意思，用于描述地址和端口。应用程序通过socket向网络发出请求或者回应。</p>\n<p>socket编程有三种：</p>\n<ul><li>流式套接字（SOCK_STREAM）</li><li>数据报套接字(SOCK_DGRAM)</li><li>原始套接字(SOCK_RAW)</li></ul>\n<p>前两者较常用。基于TCP的socket编程是流式套接字。</p>\n<h2><a id=\"_11\"></a>服务端和客户端都做了什么</h2>\n<p><strong>服务端：</strong></p>\n<blockquote>\n<p>建立socket，声明自身的port和IP，并绑定到socket，使用listen监听，然后不断用accept去查看是否有连接。如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket。如果不需要等待任何客户端连接，那么用closeSocket直接关闭自身的socket。</p>\n</blockquote>\n<p>转载至：https://blog.csdn.net/zahngjialiang/article/details/53929584<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\90062dfd95134833a4557e0072e26992.png\"/></p>\n<p><strong>客户端：</strong></p>\n<blockquote>\n<p>建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\be70b7f5f2504124a2e4c2ee9f1725aa.png\"/></p>\n</blockquote>\n<h2><a id=\"_25\"></a>三次握手四次挥手是什么</h2>\n<p>第一次握手：Client将SYN（同步序列编号Synchronize Sequence Numbers）置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；<br/> 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK（确认字符Acknowledge Character）置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；<br/> 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8e1ee878d9cf447fa3bc89c0c7e883bc.png\"/></p>\n<p>第一次挥手：Client将FIN(finish)置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；<br/> 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。<br/> 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；<br/> 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ceb39441131c434d846695b43e3520c8.png\"/></p>\n<p>—————————————————————————————<br/> 原文链接：https://blog.csdn.net/weixin_41969690/article/details/106196702<br/> <img alt=\"服务端和客户端互动\" src=\"..\\..\\static\\image\\91127a6ddbd5472ba67ac0be694ed962.png\"/><br/> Windows下的代码怎么写，参考：<br/> https://blog.csdn.net/zahngjialiang/article/details/53929584<br/> 对于函数解释的很清晰。</p>\n<p>另外目前的教程都是有服务端和客户端的代码的，刚开始看真的很蒙，不明白要怎么运行。其实他们是把两个代码分别编译成EXE后进行测试的。其实我们可以下载一个TCP调试助手，就可以只写一端的代码进行测试了。比如下图这个：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6b80f2ca90d14e90942fd0696614d020.png\"/></p>\n<h2><a id=\"Socket_47\"></a>Socket代码解析</h2>\n<p><strong>1. WSAStartup函数</strong></p>\n<p>使用Socket之前必须调用WSAStartup函数，此函数在应用程序中用来初始化Windows Sockets DLL，只有此函数调用成功后，应用程序才可以调用Windows SocketsDLL中的其他API函数，否则后面的任何函数都将调用失败。</p>\n<p><strong>函数的原型：</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> WSAAPI <span class=\"token function\">WSAStartup</span><span class=\"token punctuation\">(</span>\n  WORD      wVersionRequested<span class=\"token punctuation\">,</span>\n  LPWSADATA lpWSAData\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>函数的使用：</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token function\">WSAStartup</span><span class=\"token punctuation\">(</span><span class=\"token function\">MAKEWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>wsaData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//第一个参数是dll版本号，第二个参数是创建的socket对象</span>\n</code></pre>\n<p><strong>2. WSADATA</strong></p>\n<p>WSADATA，一种数据结构。<br/> 这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据。</p>\n<p><strong>3. MAKEWORD函数</strong></p>\n<p>Windows Sockets DLL期望调用者使用的Windows Sockets规范的版本。 高位字节存储副版本号, 低位字节存储主版本号，可以用WORD MAKEWORD(BYTE,BYTE ) 返回这个值,例如:MAKEWORD(1,1)</p>\n<p>前面都做完了之后：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">//需要确认是否初始化成功</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">WSAStartup</span><span class=\"token punctuation\">(</span>sockVersion<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>wsdata<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>4. SOCKET函数</strong></p>\n<blockquote>\n<p>SOCKET socket(int af,int type,int protocol);<br/> af:一个地址家族，通常为AF_INET(AF–ADDRESS FAMILY)<br/> type:套接字类型，SOCK_STREAM表示创建面向流连接的套接字。为SOCK_DGRAM，表示创建面向无连接的数据包套接字。为SOCK_RAW，表示创建原始套接字<br/> protocol:套接字所用协议，不指定可以设置为0 返回值就是一个socket</p>\n</blockquote>\n<p>函数的使用：</p>\n<pre><code class=\"prism language-cpp\">\tSOCKET serverSocket <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> IPPROTO_TCP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>serverSocket <span class=\"token operator\">==</span> INVALID_SOCKET<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Socket error\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>5. sockaddr_in 结构体</strong></p>\n<p>成员变量如下：</p>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span><span class=\"token punctuation\">{<!-- --></span>\n    sa_family_t     sin_family<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//地址族（Address Family），也就是地址类型</span>\n    <span class=\"token keyword\">uint16_t</span>        sin_port<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//16位的端口号</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">in_addr</span>  sin_addr<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//32位IP地址</span>\n    <span class=\"token keyword\">char</span>            sin_zero<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//不使用，一般用0填充</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<ol><li> <p>sin_family 和 socket() 的第一个参数的含义相同，取值也要保持一致。</p> </li><li> <p>sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 0~65536，但 0~1023<br/> 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在<br/> 1024~65536 之间分配端口号。 端口号需要用 htons() 函数转换，后面会讲解为什么。</p> </li><li> <p>sin_addr 是 struct in_addr 结构体类型的变量，下面会详细讲解。</p> </li><li> <p>sin_zero[8] 是多余的8个字节，没有用，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset()<br/> 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。</p> </li></ol>\n</blockquote>\n<p><strong>6. memset函数</strong></p>\n<p>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>函数的使用：</p>\n<pre><code class=\"prism language-cpp\">\tsockaddr_in sockAddr<span class=\"token punctuation\">;</span><span class=\"token comment\">//创建套接字地址</span>\n\t<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sockAddr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>sockAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//用0填充每个字节</span>\n\tsockAddr<span class=\"token punctuation\">.</span>sin_family <span class=\"token operator\">=</span> PF_INET<span class=\"token punctuation\">;</span><span class=\"token comment\">//使用PF_INET地址族，也就是IPv4</span>\n\tsockAddr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr <span class=\"token operator\">=</span> <span class=\"token function\">inet_addr</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"192.168.1.200\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//具体的地址</span>\n\tsockAddr<span class=\"token punctuation\">.</span>sin_port <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span><span class=\"token number\">4196</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//端口</span>\n</code></pre>\n<p><strong>7. in_addr 结构体（sin_addr）</strong></p>\n<p>sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">in_addr</span><span class=\"token punctuation\">{<!-- --></span>\n  in_addr_t  s_addr<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//32位的IP地址</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>in_addr_t</code> 在头文件 &lt;netinet/in.h&gt; 中定义，等价于 <code>unsigned long</code>，长度为4个字节。也就是说，<code>s_addr</code> 是一个整数，而IP地址是一个字符串，所以需要 <code>inet_addr() 函数</code>进行转换。</p>\n<p><strong>8. bind（）函数</strong></p>\n<p>函数声明：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>SOCKET sock<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span> <span class=\"token operator\">*</span>addr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。</p>\n</blockquote>\n<p>函数的使用：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>servSock<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>SOCKADDR<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>sockAddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>SOCKADDR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>或者用下面的代码：</p>\n<pre><code class=\"prism language-cpp\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>serverSocket<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>sockaddr<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>sockAddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>sockAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Bind error\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>9.listen（）函数</strong></p>\n<p>函数原型为：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>SOCKET sock<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> backlog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n</code></pre>\n<blockquote>\n<p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。<br/> 该函数只有服务端有，客户端没有</p>\n</blockquote>\n<p>函数的使用：</p>\n<pre><code class=\"prism language-cpp\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>serverSocket<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> SOCKET_ERROR<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Listen error\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>10.accept（）函数</strong></p>\n<p>函数的原型：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span> <span class=\"token operator\">*</span> addr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span> addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>函数说明：</p>\n<blockquote>\n<p>accept()用来接受参数s 的socket 连线. 参数s 的socket 必需先经bind()、listen()函数处理过,<br/> 当有连线进来时accept()会返回一个新的socket 处理代码, 往后的数据传送与读取就是经由新的socket处理, 而原来参数s<br/> 的socket 能继续使用accept()来接受新的连线要求. 连线成功时, 参数addr 所指的结构会被系统填入远程主机的地址数据,<br/> 参数addrlen 为scokaddr 的结构长度</p>\n</blockquote>\n<p>函数的使用：</p>\n<pre><code class=\"prism language-cpp\">    SOCKET clientSocket<span class=\"token punctuation\">;</span>\n    sockaddr_in client_sin<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>client_sin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    clientSocket <span class=\"token operator\">=</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>serverSocket<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>sockaddr<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>client_sin<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>11.send（）函数</strong></p>\n<p>函数的原型：</p>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">int</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>SOCKET s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>send()用来将数据由指定的socket 传给对方主机. 参数s 为已建立好连接的socket. 参数msg 指向欲连线的数据内容, 参数len 则为数据长度. 参数flags 一般设0</p>\n</blockquote>\n<p><strong>11.closesocket（）函数</strong></p>\n<p>函数的原型：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>SOCKET s<span class=\"token punctuation\">)</span>\n</code></pre>\n<blockquote>\n<p>关闭套接字，释放与套接字关联的所有资源</p>\n</blockquote>\n<p>函数的使用：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>clientSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">closesocket</span><span class=\"token punctuation\">(</span>serverSocket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>12.WSACleanup（）函数</strong></p>\n<blockquote>\n<p>终止使用WinSock，释放为应用程序分配的相关资源</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-22 19:49:39", "summary": "是什么就是套接字的意思，用于描述地址和端口。应用程序通过向网络发出请求或者回应。编程有三种：流式套接字数据报套接字原始套接字前两者较常用。基于的编程是流式套接字。服务端和客户端都做了什么服务端：建立，"}