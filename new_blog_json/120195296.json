{"blogid": "120195296", "writerAge": "码龄2年", "writerBlogNum": "100", "writerCollect": "1493", "writerComment": "1462", "writerFan": "5045", "writerGrade": "6级", "writerIntegral": "5162", "writerName": "^jhao^", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120195296.jpg", "writerRankTotal": "3102", "writerRankWeekly": "1295", "writerThumb": "2001", "writerVisitNum": "65665", "blog_read_count": "814", "blog_time": "于 2021-09-09 17:41:50 发布", "blog_title": "【数据结构初阶】新学期带你领跑二叉树，二叉树的迭代遍历，递归遍历详解，建议收藏", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>二叉树</h3>\n<ul><li><a href=\"#_9\">前言</a></li><li><a href=\"#_15\">一、二叉树的结构介绍</a></li><li><a href=\"#_33\">二、二叉树的遍历（递归）（易）</a></li><li><ul><li><a href=\"#1_34\">1.前序遍历</a></li><li><a href=\"#2_111\">2.中序遍历</a></li><li><a href=\"#3_138\">3.后序遍历</a></li></ul>\n</li><li><a href=\"#_162\">三、二叉树的遍历（迭代）（偏难）</a></li><li><ul><li><a href=\"#1__163\">1.利用队列进行迭代 (易)</a></li><li><a href=\"#2_316\">2.非递归实现前中后序（难）</a></li><li><ul><li><a href=\"#21_319\">2.1前序遍历</a></li><li><a href=\"#22_443\">2.2中序遍历</a></li><li><a href=\"#23_500\">2.3后序遍历</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_564\">总结</a></li></ul>\n</div>\n<p></p>\n<hr color=\"#000000\" size='1\"'/>\n<h1><a id=\"_9\"></a>前言</h1>\n<p>首先我们这里所讲述的二叉树是最为常见的，本章主要带大家了解这种二叉树，并且学会它常见的遍历方式（递归，迭代），由于普通的二叉树没有插入删除的意义，到了AVL，红黑树这种平衡二叉搜索树才有插入删除的意义，所以我们在本章节主要是带大家先简要理解这种结构，对于二叉树有一个初步的认识。</p>\n<hr/>\n<h1><a id=\"_15\"></a>一、二叉树的结构介绍</h1>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">// 对int typedef 是因为二叉树的节点可以存放任意的值，这里是为了方便后续有需要方便调整</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> BTDataType<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 二叉树</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">BinaryTreeNode</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//二叉树的每一个节点都有一个值</span>\n\tBTDataType val<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//二叉树的每一个节点都有指向左孩子（右孩子）的指针</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">BinaryTreeNode</span><span class=\"token operator\">*</span> left<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">BinaryTreeNode</span><span class=\"token operator\">*</span> right<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>BTNode<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\15e75263b936491584965c963003b193.png\"/><br/> 这就是一个常见的二叉树</p>\n<h1><a id=\"_33\"></a>二、二叉树的遍历（递归）（易）</h1>\n<h2><a id=\"1_34\"></a>1.前序遍历</h2>\n<blockquote>\n<p>对于一棵树，树的本身性质让他非常适合递归，当我们想要递归一颗树的时候，我们可以访问它的<strong>根，左子树，右子树</strong>，<strong>注意是左子树不是左孩子</strong>，左子树又可以分成根，左子树，右子树</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ef171107a5e04b8bbf4645d45ee66fef.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d5fa038e9a314800865eb21b813c0480.png\"/><br/> 前序遍历也是标准的深度优先搜索模式：遍历当前节点，再往深处走，走到底就回来尝试新的方法❗️❗️❗️❗️<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4035583e13454923a89ce9ee176dec10.png\"/><br/> ❗️❗️❗️接下来我们尝试创建这样上图所示的树</p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">// 创建节点并进行初始化</span>\nBTNode<span class=\"token operator\">*</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span>BTDataType x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tBTNode<span class=\"token operator\">*</span> newnode <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>BTNode<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>BTNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tnewnode<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnewnode<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnewnode<span class=\"token operator\">-&gt;</span>val <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> newnode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//手动创建一棵树</span>\nBTNode<span class=\"token operator\">*</span> <span class=\"token function\">CreateTree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tBTNode<span class=\"token operator\">*</span> nodeA <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tBTNode<span class=\"token operator\">*</span> nodeB <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tBTNode<span class=\"token operator\">*</span> nodeC <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'C'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tBTNode<span class=\"token operator\">*</span> nodeD <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'D'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tBTNode<span class=\"token operator\">*</span> nodeE <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tBTNode<span class=\"token operator\">*</span> nodeF <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'F'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tBTNode<span class=\"token operator\">*</span> nodeG <span class=\"token operator\">=</span> <span class=\"token function\">BuyNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'G'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\tnodeA<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> nodeB<span class=\"token punctuation\">;</span>\n\tnodeA<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> nodeC<span class=\"token punctuation\">;</span>\n\tnodeB<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> nodeD<span class=\"token punctuation\">;</span>\n\tnodeB<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> nodeE<span class=\"token punctuation\">;</span>\n\tnodeC<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> nodeF<span class=\"token punctuation\">;</span>\n\tnodeC<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> nodeG<span class=\"token punctuation\">;</span>\n\tnodeD<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeD<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeE<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeE<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeF<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeF<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeG<span class=\"token operator\">-&gt;</span>left <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tnodeG<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> nodeA<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>❗️❗️❗️我们可以先预测结果，如果将NULL也打印出来的话，上面得到的前序遍历的结果应该是<br/> <strong>A B D NULL NULL E NULL NULL C F NULL NULL G NULL NULL</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>BTNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//我们这里用打印的方式表示遍历这个节点的值</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token comment\">//如果这棵树本身是空，或者递归到空的位置我们打印NULL</span>\n\t\t<span class=\"token comment\">//再返回上一层</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NULL \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">//访问当前节点</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c \"</span><span class=\"token punctuation\">,</span> root<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//访问当前节点的左子树</span>\n\t<span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//访问当前节点的右子树</span>\n\t<span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cf6d97daf6f448bc998729d2910ab29a.png\"/></p>\n<p>看不懂的同学可以按照上面来那张图片想一想</p>\n<hr/>\n<h2><a id=\"2_111\"></a>2.中序遍历</h2>\n<p>❗️❗️❗️<br/> 对于中序遍历我们先走<strong>左子树，根，右子树</strong><br/> 例子：ABCDEFG（层序）<br/> 我们也可以预测中序遍历的结果：<br/> <strong>NULL D NULL B NULL E NULL A NULL F NULL C NULL G NULL</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">Inorder</span><span class=\"token punctuation\">(</span>BTNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span>  <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NULL \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">//访问左子树</span>\n\t<span class=\"token function\">Inorder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//根</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c \"</span><span class=\"token punctuation\">,</span> root<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//右子树</span>\n\t<span class=\"token function\">Inorder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4d6b2e8088ad4139a1a807014e139f8c.png\"/></p>\n<hr/>\n<h2><a id=\"3_138\"></a>3.后序遍历</h2>\n<p>❗️❗️❗️<br/> 后序遍历：左右根<br/> 例子：ABCDEFG（层序）<br/> 我们也可以预测中序遍历的结果：<br/> <strong>NULL NULL D NULL NULL E B NULL NULL F NULL NULL G C A</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">PostOrder</span><span class=\"token punctuation\">(</span>BTNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NULL \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">//左子树</span>\n\t<span class=\"token function\">PostOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//右子树</span>\n\t<span class=\"token function\">PostOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//根</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c \"</span><span class=\"token punctuation\">,</span> root<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>其实到这里大家应该都差不多会了，我们接下来讲讲迭代方式走二叉树</p>\n<h1><a id=\"_162\"></a>三、二叉树的遍历（迭代）（偏难）</h1>\n<h2><a id=\"1__163\"></a>1.利用队列进行迭代 (易)</h2>\n<p>❗️❗️❗️❗️❗️❗️<br/> 建议不会队列的同学看看这一篇：<a href=\"https://blog.csdn.net/weixin_52344401/article/details/119569271\">【数据结构】栈和队列，看完这一篇就够了（万字配动图配习题）</a><br/> 队列的代码：有需要的自取</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span>  <span class=\"token macro-name\">_CRT_SECURE_NO_WARNINGS</span> <span class=\"token expression\"><span class=\"token number\">1</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\">once</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;assert.h&gt;</span></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">BinaryTreeNode</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 链式结构：表示队列 </span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">BinaryTreeNode</span><span class=\"token operator\">*</span> QDataType<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">QListNode</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">QListNode</span><span class=\"token operator\">*</span> _next<span class=\"token punctuation\">;</span>\n\tQDataType _data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>QNode<span class=\"token punctuation\">;</span><span class=\"token comment\">//队列中结点的结构</span>\n\n<span class=\"token comment\">// 队列的结构 </span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">Queue</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tQNode<span class=\"token operator\">*</span> _front<span class=\"token punctuation\">;</span>\n\tQNode<span class=\"token operator\">*</span> _rear<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>Queue<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 初始化队列 </span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueueInit</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 队尾入队列 </span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueuePush</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">,</span> QDataType data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 队头出队列 </span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueuePop</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 获取队列头部元素 </span>\nQDataType <span class=\"token function\">QueueFront</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 获取队列队尾元素 </span>\nQDataType <span class=\"token function\">QueueBack</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 获取队列中有效元素个数 </span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">QueueSize</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 </span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 销毁队列 </span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueueDestroy</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueueInit</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tq<span class=\"token operator\">-&gt;</span>_front <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\tq<span class=\"token operator\">-&gt;</span>_rear <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueuePush</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">,</span> QDataType data<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tQNode<span class=\"token operator\">*</span> tmp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>QNode<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>QNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ttmp<span class=\"token operator\">-&gt;</span>_next <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\ttmp<span class=\"token operator\">-&gt;</span>_data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-&gt;</span>_rear <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tq<span class=\"token operator\">-&gt;</span>_front <span class=\"token operator\">=</span> q<span class=\"token operator\">-&gt;</span>_rear <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">else</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tq<span class=\"token operator\">-&gt;</span>_rear<span class=\"token operator\">-&gt;</span>_next <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\t\tq<span class=\"token operator\">-&gt;</span>_rear <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueuePop</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tQNode<span class=\"token operator\">*</span> first <span class=\"token operator\">=</span> q<span class=\"token operator\">-&gt;</span>_front<span class=\"token operator\">-&gt;</span>_next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t\tq<span class=\"token operator\">-&gt;</span>_rear <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//处理这一步</span>\n\t<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">-&gt;</span>_front<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tq<span class=\"token operator\">-&gt;</span>_front <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nQDataType <span class=\"token function\">QueueFront</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> q<span class=\"token operator\">-&gt;</span>_front<span class=\"token operator\">-&gt;</span>_data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nQDataType <span class=\"token function\">QueueBack</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> q<span class=\"token operator\">-&gt;</span>_rear<span class=\"token operator\">-&gt;</span>_data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">QueueSize</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\tQNode<span class=\"token operator\">*</span> cur <span class=\"token operator\">=</span> q<span class=\"token operator\">-&gt;</span>_front<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tn<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\tcur <span class=\"token operator\">=</span> cur<span class=\"token operator\">-&gt;</span>_next<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> q<span class=\"token operator\">-&gt;</span>_front <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">QueueDestroy</span><span class=\"token punctuation\">(</span>Queue<span class=\"token operator\">*</span> q<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tQNode<span class=\"token operator\">*</span> tmp <span class=\"token operator\">=</span> q<span class=\"token operator\">-&gt;</span>_front<span class=\"token operator\">-&gt;</span>_next<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">-&gt;</span>_front<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tq<span class=\"token operator\">-&gt;</span>_front <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\tq<span class=\"token operator\">-&gt;</span>_front <span class=\"token operator\">=</span> q<span class=\"token operator\">-&gt;</span>_rear <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n</code></pre>\n<p>我们走层序遍历需要怎么做呢？其实很简单，我们先入头结点入队列，然后每次在出队头元素之前把他的<strong>左孩子和右孩子</strong>带入节点，遍历队列直到队列为空。❗️❗️❗️❗️</p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">//层序遍历</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">LevelOrder</span><span class=\"token punctuation\">(</span>BTNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//我们借用之前写过的队列</span>\n\tQueue q<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">QueueInit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">QueuePush</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QueueEmpty</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tBTNode<span class=\"token operator\">*</span> first <span class=\"token operator\">=</span> <span class=\"token function\">QueueFront</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//访问元素</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c \"</span><span class=\"token punctuation\">,</span> first<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NULL \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//入下一个元素</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t<span class=\"token function\">QueuePush</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">,</span> first<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">QueuePush</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">,</span> first<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token function\">QueuePop</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h2><a id=\"2_316\"></a>2.非递归实现前中后序（难）</h2>\n<p>❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️<br/> 其实这三道题是非常类似的，我们先给大家讲最简单的前序遍历！！</p>\n<h3><a id=\"21_319\"></a>2.1前序遍历</h3>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">leetcode. 二叉树的前序遍历</a><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5cf725a8b6c042d8bdfb4d8fa98209b8.png\"/><br/> <strong>前提提示：<br/> 一.这里的NULL我们不用访问，访问在这里相当于入一个数组（vector），不懂的同学先把他当成数组！<br/> 二. 以及这里所说的最左列为当前节点一直递归它的左子树，即上图的1 , 2，4</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e9b5b3da4f5144b2aa9b19a909c1a572.png\"/></p>\n<blockquote>\n<p><strong>分析</strong>：我们想要利用栈对我们的二叉树进行前序遍历，我们可以观察前序遍历的时候会先遍历<br/> 1–&gt;2–&gt;4，我们一边遍历一边将遍历的值放入栈中看看。发现这棵树的话只剩下4，2，1的右子树就可以走完了！！！！</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\da532fa970d746ffa3474e5561ed55e7.png\"/><br/> <strong>如何遍历右子树呢？</strong> 实际上我们观察**（3）这颗子树<strong>我们可以发现什么，我们没有办法通过一次操作遍历完右子树，但是我们可以把3这颗子树进行拆分，我们入它的最左列节点</strong>访问<strong>再进行</strong>入栈**，就<strong>相当于遍历了（3）的左子树与每个节点的根（细品）</strong>，这个时候我们<strong>遍历（7）是不是就是一次操作就能解决了？其实还可以再分一次，分到像（5）的时候，当节点的右子树为空树的时候</strong>，我们就访问他！！！</p>\n<hr/>\n<p>重要：<br/> <strong>一棵树一定能分到没有右子树的时候，这时访问当前节点相当于访问上一个根节点的右子树</strong><br/> <strong>一棵树一定能分到没有右子树的时候，这时访问当前节点相当于访问上一个根节点的右子树</strong><br/> <strong>一棵树一定能分到没有右子树的时候，这时访问当前节点相当于访问上一个根节点的右子树</strong><br/> 就像访问5的时候是不是相当于访问了2的右子树？是的！</p>\n<hr/>\n<p>💖💖💖💖💖💖<br/> 上面没看懂，没关系，带大家再走一下每一个步骤<br/> 💖💖💖💖💖💖<br/> <strong>这里再拆分一下每一个步骤</strong></p>\n<blockquote>\n<p>刚开始<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\30a0beb298d94203a0096216c22f8a64.png\"/></p>\n</blockquote>\n<blockquote>\n<p>第一步：我们就访问每一个节点并且入栈（将1,2，4入栈并且放入数组），这时候我们要拿出栈顶的4，将它的<strong>右子树的最左列</strong>入栈（NULL不入栈），我们重复此操作，到2的时候，我们将它的右子树（5）及其<strong>最左列</strong>入栈并且访问，并且把2出栈，这时候的栈只有（5,1）<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fb748854ff154fa2b13fc516cb63fb36.png\"/></p>\n</blockquote>\n<blockquote>\n<p>重复上述操作，取栈顶数据，将栈顶数据的<strong>右子树的最左列</strong>入栈之后将原栈顶数据出栈，这里5右子树为NULL不用入栈，我们栈里就只剩下1，接着入1的右子树的最左列，即3,6入栈<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\21dd87808e634a128a5d995663993bc2.png\"/></p>\n</blockquote>\n<blockquote>\n<p>重复上述操作，取栈顶数据，将栈顶数据的右子树的最左列入栈之后将原栈顶数据出栈，6无右子树，就弹出了，到3的时候把3的右子树最左列带入（7），最后栈里面还有一个7<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8b7eb1e234b44f02ad883a30e510db16.png\"/><br/> 重复上述操作，取栈顶数据，将栈顶数据的右子树的最左列入栈之后将原栈顶数据出栈，把7出掉，结束！！！！</p>\n</blockquote>\n<pre><code class=\"prism language-c\">class Solution <span class=\"token punctuation\">{<!-- --></span>\npublic<span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">preorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//利用栈进行迭代遍历</span>\n        <span class=\"token comment\">//思路：每次遍历当前节点（cur）的左子树，再进行入栈，最后从栈中依次取出以相同的方式遍历右子树</span>\n        <span class=\"token comment\">//可以先入最左的树</span>\n        TreeNode<span class=\"token operator\">*</span> cur <span class=\"token operator\">=</span>root<span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> retArr<span class=\"token punctuation\">;</span><span class=\"token comment\">//用来返回的答案</span>\n        stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span> s<span class=\"token punctuation\">;</span><span class=\"token comment\">//利用栈进行迭代遍历</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            retArr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cur <span class=\"token operator\">=</span> cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">//现在只要遍历栈当中的所有的右子树就遍历完所有树</span>\n        <span class=\"token comment\">//当然遍历每个右子树也不是一次就能搞定的，我们分解成遍历每个右子树和他的左子树，...在遍历他的右子树，就类似我们的递归遍历</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">//我们可以对于栈当中的右子树一个一个处理</span>\n            cur <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cur <span class=\"token operator\">=</span> cur<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//将右子树的最左列也都入栈</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token comment\">//每个右子树又会带出更多的右子树....</span>\n                retArr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cur <span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> retArr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5cf725a8b6c042d8bdfb4d8fa98209b8.png\"/></p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">//分析子过程，这里是第一步，将root即右子树的最左列入栈</span>\n <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token comment\">//每个右子树又会带出更多的右子树....</span>\n     retArr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     cur <span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p><strong>总结</strong>，我们面对这种题都可以先<strong>入该节点及它的最左列节点</strong>，然后我们上面这一段代码再去带出右子树当中的最左列，当我们带出来的时候相当于所有的根与左子树已经遍历完了，我们只用对右子树处理。右子树又可以被继续拆分！！！</p>\n</blockquote>\n<pre><code class=\"prism language-c\"> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">//我们可以对于栈当中的右子树一个一个处理</span>\n            cur <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//取出当前节点所有的右子树，没有就在后面的循环中拿出这个值（相当于访问上一个根的右子树）</span>\n            cur <span class=\"token operator\">=</span> cur<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//将右子树的最左列也都入栈</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token comment\">//每个右子树又会带出更多的右子树....</span>\n                retArr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cur <span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h3><a id=\"22_443\"></a>2.2中序遍历</h3>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">leetcode.中序遍历</a></p>\n<blockquote>\n<p>中序遍历的逻辑类似，就是我们访问顺序左子树，根，右子树。<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4295561996f142e4b90a77936290b8e8.png\"/></p>\n</blockquote>\n<blockquote>\n<p>还是用这个例子来：访问栈顶的元素之后带出该元素的右子树的最左列，再删除原来的栈顶元素<br/> 我们一开始就可以访问4（左子树相当于访问了NULL），我们走到4访问再入右子树的最左列（这里没有），再将4出栈，然后我们2的左子树访问完了，我们就直接将2入到数组，将2的右子树带进去（即带2的最左一列），再将2出栈。如下图<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e0e21c74c0fa495eada762233b201b64.png\"/></p>\n</blockquote>\n<blockquote>\n<p>这时候对5进行重复操作（即访问栈顶的元素之后带出该元素的右子树的最左列，再删除原来的栈顶元素），即像4的时候5的左子树也是NULL（5的左子树访问了），我们访问5，带入右子树（这里没有），出栈。这时候栈里只剩下1，我们访问1，再拿出它的右子树的最左列（3,6）<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6f971a7370a34587964c423174c60ca8.png\"/></p>\n</blockquote>\n<blockquote>\n<p>然后我们再访问6，同理上面（左子树访问过了），然后带出它的右子树（这里没有），将6出栈，带出6的右子树，(这里没有)。<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e1f870d49a114d64b8dc76695368196a.png\"/></p>\n</blockquote>\n<blockquote>\n<p>这时候栈里面只剩下3，我们访问3，把他的右子树的最左列带进去，并且把3出掉，这时候栈里面就剩下一个7<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8f6f3ff74ee0443ba5db2edbe2e80945.png\"/></p>\n</blockquote>\n<blockquote>\n<p>最后访问7，然后入它的右子树（NULL不访问），把7出栈。</p>\n</blockquote>\n<pre><code class=\"prism language-c\">class Solution <span class=\"token punctuation\">{<!-- --></span>\npublic<span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//类似前序遍历的迭代，只不过中序遍历是左根右</span>\n        <span class=\"token comment\">//所以我们我们入完最左列之后从里面取得时候在放入结果的vector就可以啦</span>\n        TreeNode<span class=\"token operator\">*</span> cur <span class=\"token operator\">=</span>root<span class=\"token punctuation\">;</span>\n        stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span> s<span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> retArr<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//先入最左列</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cur<span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">//访问当前节点并且访问它的右子树</span>\n            cur <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            retArr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cur<span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cur<span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> retArr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<hr/>\n<h3><a id=\"23_500\"></a>2.3后序遍历</h3>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\">leetcode.后序遍历</a><br/> 后序遍历会稍微难一些，我们在按照上面的逻辑去写的时候会出现一点问题，我们用画图的方式来剖析。</p>\n<blockquote>\n<p>我们一开始还是将根以及它的最左列入栈，根据后序遍历的左右根。<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bd9929c71f7a48bd9970e4a6d244826c.png\"/></p>\n</blockquote>\n<blockquote>\n<p>观察4是可以访问的，访问完并且可以出栈，那么<strong>1.它的条件就是当前节点的右子树为空。</strong><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5f037a4086fc4f76a4e52e026d0094bf.png\"/></p>\n</blockquote>\n<blockquote>\n<p>现在对于2来说，我们访问它的右子树，并且不能把2出掉，因为要访问完右子树才可以出，所以我们现在将<strong>2的右子树的最左列</strong>入栈<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\83c46f25f9c6483c8d3cca81de9a5ded.png\"/></p>\n</blockquote>\n<blockquote>\n<p>这个时候栈顶元素5的右子树为NULL，所以我们访问5，到了现在栈顶元素就是2了，我们人为肯定知道它的右子树已经遍历了，但是程序要识别就必须要有条件，我们只有一个条件就是当前节点的右子树为空才访问栈顶元素。<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\91e1605338cc4161960e5f63adc20b62.png\"/></p>\n</blockquote>\n<p>结论：<strong>第二个条件</strong>应该是什么呢，我们访问当前栈顶元素（2）的时候，我们可以设置一个<strong>前驱指针</strong>，指向我们上一个访问的节点，那么我们2的上一个访问的节点是谁呢？（5）<strong>！！！</strong>，我们就可以让 <strong>cur-&gt;right == prev</strong> 即当前节点的右子树是不是指向前驱指针，若是，则该cur（2）的右子树5已经访问完了。这样就能辨别当前栈顶元素的右节点是否有访问过。</p>\n<p>那么这个是不是巧合呢，其实不是的，想一想，我们遍历（5）这颗子树的也是遵循后序遍历的原则，最后遍历的就是子树的根（5），所以前驱指针是指向右子树的根的。</p>\n<pre><code class=\"prism language-c\">class Solution <span class=\"token punctuation\">{<!-- --></span>\npublic<span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">postorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> retArr<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span> s<span class=\"token punctuation\">;</span>\n        TreeNode<span class=\"token operator\">*</span> cur <span class=\"token operator\">=</span>root<span class=\"token punctuation\">;</span>\n        TreeNode<span class=\"token operator\">*</span> prev <span class=\"token operator\">=</span>root<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cur <span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">//接下来遍历每棵树的右子树</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            cur <span class=\"token operator\">=</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">==</span><span class=\"token constant\">NULL</span> <span class=\"token operator\">||</span> cur<span class=\"token operator\">-&gt;</span>right <span class=\"token operator\">==</span> prev<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                retArr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                prev <span class=\"token operator\">=</span>cur<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">//表示当前节点的右子树访问完了，就更新prev然后pop掉</span>\n                s<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>   \n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                cur <span class=\"token operator\">=</span> cur<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{<!-- --></span>\n                    s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    cur <span class=\"token operator\">=</span>cur<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> retArr<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h1><a id=\"_564\"></a>总结</h1>\n<p>💓💓💓<br/> 二叉树的初阶就在这里告一段落啦，大家觉得有帮助可以给博主一键三连，这对我真的很重要，谢谢啦。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-09-09 17:41:50", "summary": "二叉树前言一、二叉树的结构介绍二、二叉树的遍历递归易前序遍历中序遍历后序遍历三、二叉树的遍历迭代偏难利用队列进行迭代易非递归实现前中后序难前序遍历中序遍历后序遍历总结前言首先我们这里所讲述的二叉树是最"}