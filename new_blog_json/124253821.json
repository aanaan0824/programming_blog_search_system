{"blogid": "124253821", "writerAge": "码龄11年", "writerBlogNum": "43", "writerCollect": "279", "writerComment": "27", "writerFan": "24", "writerGrade": "4级", "writerIntegral": "1421", "writerName": "glmushroom", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124253821.jpg", "writerRankTotal": "47589", "writerRankWeekly": "96528", "writerThumb": "54", "writerVisitNum": "215681", "blog_read_count": "5618", "blog_time": "已于 2022-04-19 17:15:31 修改", "blog_title": "C# 搭建GRPC，实现双向通信", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>一、新建项目，定义GRPC服务接口</p>\n<p>vs新建dll项目，项目中NuGet程序包添加Grpc相关引用</p>\n<p><img alt=\"\" height=\"202\" src=\"..\\..\\static\\image\\5ff1847366c24ae6bf7cdd052e4579a0.png\" width=\"314\"/></p>\n<p>定义服务，创建.proto文件</p>\n<p>创建文件CorrespondService.proto</p>\n<pre><code>syntax = \"proto3\";\npackage My.Public;\nservice CorrespondGrpcService {\n  rpc SendMsg(GrpcData) returns (GrpcResult);\n  rpc ReceiveDataFromServer(GrpcData) returns (stream GrpcData);\n}\n\nmessage GrpcData {\n  string Ip = 1;\n  int32 Port = 2;\n  string DataId = 3;\n  int32 DataPriority = 4;\n  string DataType = 5;\n  string Conntent = 6;\n  string NodeName = 7;\n}\n\nmessage GrpcResult{\n\tbool result = 1;\n}\n\n</code></pre>\n<p>定义两个服务方法：</p>\n<p>客户端发送数据到服务端：SendMsg</p>\n<p>服务端发送数据到客户端(从服务端接收数据)：ReceiveDataFromServer，因为是服务端主动触发，所以从服务端的返回数据定义成stream形式，流式传输，客户端启动一次该方法，即可等待服务端流式数据发送到客户端。</p>\n<p>二、生成代码，添加到项目中</p>\n<p>在添加的引用package下找到Grpc.Tool下的文件\\tools\\windows_x64</p>\n<p><img alt=\"\" height=\"71\" src=\"..\\..\\static\\image\\840ba59053ef4e259d446d4f1db4bfa3.png\" width=\"249\"/></p>\n<p>使用文件夹中的工具生成文件，到packages的上一层目录框输入cmd回车打开命令提示符窗口</p>\n<p>运行命令：packages\\Grpc.Tools.2.24.0\\tools\\windows_x64\\protoc.exe -ISystemPublic --csharp_out SystemPublic SystemPublic\\PublicClass\\Grpc\\GrpcService\\CorrespondService.proto --grpc_out SystemPublic --plugin=protoc-gen-grpc=packages\\Grpc.Tools.2.24.0\\tools\\windows_x64\\grpc_csharp_plugin.exe</p>\n<p><img alt=\"\" height=\"224\" src=\"..\\..\\static\\image\\16ce48f0009b4e5e9849af5de275b2d8.png\" width=\"1131\"/></p>\n<p> 注意自己引用包的版本号和目录路径。 </p>\n<p>生成文件后拷贝到相应的目录下，添加到项目中。</p>\n<p><img alt=\"\" height=\"96\" src=\"..\\..\\static\\image\\98f3c21f41f94f07ba4ca81e6aaa81f3.png\" width=\"307\"/></p>\n<p>三、 服务接口实现：</p>\n<p>创建通信服务类CorrespondServiceServer.cs继承CorrespondGrpcService.CorrespondGrpcServiceBase，并实现定义的方法：</p>\n<pre><code>    /// &lt;summary&gt;\n    /// Grpc服务\n    /// &lt;/summary&gt;\n    public class CorrespondServiceServer : CorrespondGrpcService.CorrespondGrpcServiceBase\n    {\n        public ConcurrentDictionary&lt;string, TaskInfo&gt; _receiveDataTaskId = new ConcurrentDictionary&lt;string, TaskInfo&gt;();\n        public Func&lt;GrpcData, GrpcResult&gt; MessageHandler { get; set; } = null;\n\n        public override Task&lt;GrpcResult&gt; SendMsg(GrpcData request, ServerCallContext context)\n        {\n            if (MessageHandler == null)\n            {\n                return Task.FromResult&lt;GrpcResult&gt;(new GrpcResult() { Result = false });\n            }\n            Tuple&lt;string, int&gt; clientIP = SplitKeyStrGrpcContextPeer(context.Peer);\n\n            if (string.IsNullOrEmpty(request.Ip))\n            {\n                request.Ip = clientIP.Item1;\n                request.Port = clientIP.Item2;\n            }\n            GrpcResult result = MessageHandler(request);\n            return Task.FromResult&lt;GrpcResult&gt;(result);\n        }\n\n        public override Task ReceiveDataFromServer(GrpcData request, IServerStreamWriter&lt;GrpcData&gt; responseStream, ServerCallContext context)\n        {\n            Tuple&lt;string, int&gt; clientIP = SplitKeyStrGrpcContextPeer(context.Peer);\n            string IPkeyStr = GetKeyStr(clientIP.Item1, clientIP.Item2);\n            if (_receiveDataTaskId.ContainsKey(IPkeyStr))\n            {\n                // 线程未完成\n                if (_receiveDataTaskId[IPkeyStr].IsStarted)\n                {\n                    bool res = _receiveDataTaskId[IPkeyStr].Stop();\n                }\n\n                TaskInfo tmp;\n                _receiveDataTaskId.TryRemove(IPkeyStr, out tmp);\n            }\n\n            if (!DataQueues.SendDataQueue.ContainsKey(IPkeyStr))\n            {\n                DataQueues.SendDataQueue[IPkeyStr] = new QueueInfo&lt;GrpcData&gt;();\n            }\n            DataQueues.SendDataQueue[IPkeyStr].Clear();\n            if (string.IsNullOrEmpty(request.Ip))\n            {\n                request.Ip = clientIP.Item1;\n                request.Port = clientIP.Item2;\n            }\n            TaskInfo tInfo = new TaskInfo(request, responseStream, context, DataQueues.SendDataQueue[IPkeyStr]);\n            bool result = tInfo.Start();\n            _receiveDataTaskId[IPkeyStr] = tInfo;\n            return tInfo.GetTask();\n        }\n        private string GetKeyStr(string ip, int port)\n        {\n            return string.Format(\"{0}:{1}\", ip, port.ToString());\n        }\n        private Tuple&lt;string, int&gt; SplitKeyStr(string strKey)\n        {\n            Tuple&lt;string, int&gt; tuple = new Tuple&lt;string, int&gt;(\"\", 0);\n            string[] res = strKey.Split(':');\n            if (res.Length != 2)\n            {\n                return tuple;\n            }\n            int port;\n            if (!int.TryParse(res[1], out port))\n            {\n                return tuple;\n            }\n\n            tuple = new Tuple&lt;string, int&gt;(res[0], port);\n\n            return tuple;\n        }\n        private Tuple&lt;string, int&gt; SplitKeyStrGrpcContextPeer(string strKey)\n        {\n            Tuple&lt;string, int&gt; tuple = new Tuple&lt;string, int&gt;(\"\", 0);\n            string[] res = strKey.Split(':');\n            if (res.Length &lt; 2)\n            {\n                return tuple;\n            }\n            int lenth = res.Length;\n            int port;\n            if (!int.TryParse(res[lenth - 1], out port))\n            {\n                return tuple;\n            }\n\n            tuple = new Tuple&lt;string, int&gt;(res[lenth - 2], port);\n\n            return tuple;\n        }\n\n    }</code></pre>\n<p>ReceiveDataFromServer方法只需要被客户端启动一次。</p>\n<p>队列DataQueues：</p>\n<pre><code>    public class DataQueues\n    {\n        public static ConcurrentDictionary&lt;string, QueueInfo&lt;GrpcData&gt;&gt; SendDataQueue = new ConcurrentDictionary&lt;string, QueueInfo&lt;GrpcData&gt;&gt;();\n        public static ConcurrentDictionary&lt;int, string&gt; ServerDatas = new ConcurrentDictionary&lt;int, string&gt;();\n    }</code></pre>\n<p>数据任务异步处理TaskInfo：</p>\n<pre><code>    public class TaskInfo\n    {\n\n        private Task _tk = null;\n        private bool _isStarted = false;\n\n        private GrpcData _request = null;\n        private IServerStreamWriter&lt;GrpcData&gt; _writerStream = null;\n        private ServerCallContext _context = null;\n        private QueueInfo&lt;GrpcData&gt; _resDataQueue = null;\n        private CancellationTokenSource _cacelTokenSource = new CancellationTokenSource();\n\n        public TaskInfo(GrpcData request, IServerStreamWriter&lt;GrpcData&gt; responseStream, ServerCallContext context, QueueInfo&lt;GrpcData&gt; resDataQueue)\n        {\n            _request = request;\n            _writerStream = responseStream;\n            _context = context;\n            _resDataQueue = resDataQueue;\n        }\n\n        public bool IsStarted\n        {\n            get\n            {\n                if (_tk == null)\n                {\n                    _isStarted = false;\n                }\n                else if (_tk.IsCompleted)\n                {\n                    _isStarted = false;\n                    _tk.Dispose();\n                    _tk = null;\n                }\n                else\n                {\n                    _isStarted = true;\n                }\n                return _isStarted;\n            }\n        }\n\n        public Task GetTask()\n        {\n            return _tk;\n        }\n        public bool Start()\n        {\n            try\n            {\n                if (IsStarted)\n                {\n                    return true;\n                }\n                _isStarted = true;\n                _tk = Task.Factory.StartNew(DataWriteThead);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                return false;\n            }\n        }\n\n        public bool Stop()\n        {\n            try\n            {\n                if (IsStarted)\n                {\n                    _isStarted = false;\n                    if (_resDataQueue == null)\n                    {\n                        return false;\n                    }\n                    _resDataQueue.QueueResetEvent.Set();\n                }\n                _isStarted = false;\n                _cacelTokenSource.Cancel();\n                return true;\n            }\n            catch (Exception ex)\n            {\n                return false;\n            }\n        }\n\n        private void DataWriteThead()\n        {\n            if (_writerStream == null || _request == null || _context == null || _resDataQueue == null)\n            {\n                return;\n            }\n            while (_isStarted &amp;&amp; !_context.CancellationToken.IsCancellationRequested &amp;&amp; !_cacelTokenSource.IsCancellationRequested)\n            {\n                try\n                {\n                    if (_resDataQueue.IsEmpty)\n                    {\n                        _resDataQueue.QueueResetEvent.WaitOne();\n                    }\n                    GrpcData data;\n                    if (_resDataQueue.TryPeek(out data))\n                    {\n                        // 向客户端发送数据\n                        Task wTask = _writerStream.WriteAsync(data);\n                        wTask.Wait(5000, _cacelTokenSource.Token);\n                        if (!wTask.IsCanceled &amp;&amp; !wTask.IsFaulted)\n                        {\n                            _resDataQueue.TryDequeue(out data);\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n\n                }\n            }\n        }\n    }</code></pre>\n<p>四、服务端启动</p>\n<pre><code>        private Grpc.Core.Server _pServer = null;\n        CorrespondServiceServer csServer = null;\n        public bool Start()\n        {\n            try\n            {\n                if (_pServer == null)\n                {\n                    csServer = new CorrespondServiceServer();\n                    csServer.MessageHandler = ServerReceiveData;\n                    _pServer = new Grpc.Core.Server\n                    {\n                        Services = { CorrespondGrpcService.BindService(csServer) },\n                        Ports = { new ServerPort(IP, Port, ServerCredentials.Insecure) }\n                    };\n                    _pServer.Start();\n                }\n\n                IsStarted = true;\n                return IsStarted;\n\n            }\n            catch (Exception ex)\n            {\n                return false;\n            }\n        }\n        public bool Stop()\n        {\n            try\n            {\n                if (!IsStarted)\n                {\n                    return true;\n                }\n                if (_pServer != null)\n                {\n                    _pServer.ShutdownAsync();\n                    _pServer = null;\n                }\n                IsStarted = false;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                return false;\n            }\n        }\n        //服务端向客户端发送消息，把消息加入队列进行处理\n        public bool SendMsg(string ip, int port, GrpcData msg)\n        {\n            string strKey = GetKeyStr(ip.Trim(), port);\n            TaskInfo tk = null;\n            if (csServer._receiveDataTaskId.ContainsKey(strKey))\n            {\n                tk = csServer._receiveDataTaskId[strKey];\n                if (tk == null || !tk.IsStarted)\n                {\n                    return false;\n                }\n            DataQueues.SendDataQueue[IpPortStrKey].Enqueue(msg);\n                return true;\n            }\n            else\n            {\n                return false;\n            }            \n        }\n        /// &lt;summary&gt;\n        /// 收到client调用SendMsg传来的数据，Grpc的Server可以直接响应返回，不需要再给指定Ip端口发送返回数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"data\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private GrpcResult ServerReceiveData(GrpcData data)\n        {\n            Task tk = new Task(() =&gt; { ProcessData(data, data.Ip, data.Port); });\n            tk.Start();\n            return new GrpcResult() { Result = true };\n        }\n</code></pre>\n<p>五、客户端连接</p>\n<pre><code>Channel channel = null;\n        CorrespondGrpcService.CorrespondGrpcServiceClient csClient = null;\n        private CancellationTokenSource _receiveCancelSource = new CancellationTokenSource();\n\n        public bool Connect(string ip, int port)\n        {\n            try\n            {\n                if (IsStarted)\n                {\n                    return true;\n                }\n                IsStarted = true;\n                RemoteIp = ip;\n                RemotePort = port;\n                if (channel == null)\n                {\n                    channel = new Channel(ip, port, ChannelCredentials.Insecure);\n                    csClient = new CorrespondGrpcService.CorrespondGrpcServiceClient(channel);\n                }\n                if (_guardThread == null)\n                {\n                    _guardThread = new Thread(new ThreadStart(GuardThread));\n                    _guardThread.IsBackground = true;\n                    _guardThread.Name = \"CorrespondServiceClientGuard\";\n                    _guardThread.Start();\n                }\n                _guardThreadEvent.Set();\n            }\n            catch (Exception ex)\n            {\n                IsStarted = false;\n            }\n            return IsStarted;\n        }\n\n        public bool DisConnect()\n        {\n            if (!IsStarted)\n            {\n                return true;\n            }\n            IsStarted = false;\n            _guardThreadEvent.Set();\n            try\n            {\n                _sendCancelSource.Cancel();\n                _receiveCancelSource.Cancel();\n                if (channel != null)\n                {\n                    channel.ShutdownAsync();\n                    channel = null;\n                }\n            }\n            catch (Exception ex)\n            {\n                return false;\n            }\n            return true;\n        }\n\n        private void GuardThread()\n        {\n            while (true)\n            {\n                if (!IsStarted)\n                {\n                    _guardThreadEvent.WaitOne();\n                }\n                try\n                {\n                    // 检查接收数据通道\n                    CheckReceiveChn();\n                }\n                catch (Exception ex)\n                {\n                }\n                Thread.Sleep(6 * 1000);\n            }\n        }\n        #region 客户端接收数据处理\n        private Task receiveTask = null;\n        private void CheckReceiveChn()\n        {\n            if (channel == null || csClient == null)\n            {\n                return;\n            }\n            if (channel.State == ChannelState.Ready)\n            {\n                if (receiveTask == null || receiveTask.IsCompleted)\n                {\n             GrpcData cdata = new GrpcData();\n                    AsyncServerStreamingCall&lt;GrpcData&gt; callback = csClient.ReceiveDataFromServer(cdata,\n                        cancellationToken: _receiveCancelSource.Token);\n                    receiveTask = Task.Factory.StartNew(() =&gt; { ReceivedData(callback, _receiveCancelSource.Token); });\n                }\n                return;\n            }\n            if (channel.State == ChannelState.Connecting)\n            {\n                return;\n            }\n            try\n            {\n                _receiveCancelSource.Cancel();\n                if (channel.State == ChannelState.TransientFailure)\n                {\n                    channel.ShutdownAsync().Wait();\n                    channel = new Channel(RemoteIp, RemotePort, ChannelCredentials.Insecure);\n                    csClient = new CorrespondGrpcService.CorrespondGrpcServiceClient(channel);\n                }\n                _receiveCancelSource = new CancellationTokenSource();\n                bool res = channel.ConnectAsync().Wait(3000);\n            }\n            catch (TaskCanceledException)\n            {\n                // 取消线程，不需要记录日志\n                return;\n            }\n            catch (Exception ex)\n            {\n                return;\n            }\n        }\n\n        private void ReceivedData(AsyncServerStreamingCall&lt;GrpcData&gt; callback, CancellationToken token)\n        {\n            try\n            {\n                while (!token.IsCancellationRequested &amp;&amp; channel != null &amp;&amp; channel.State == ChannelState.Ready\n                    &amp;&amp; callback.ResponseStream.MoveNext().Result)\n                {\n                    Task tk = new Task(() =&gt; { HandleData(callback.ResponseStream.Current); }, _receiveCancelSource.Token);\n                    tk.Start();\n                }\n            }\n            catch (Exception)\n            {\n            }\n        }\n\n        private void HandleData(GrpcData Data)\n        {\n            Task tk = new Task(() =&gt; { ProcessData(Data); });\n            tk.Start();\n        }\n\n        #endregion\n        //客户端向服务端发送数据\n        public bool SendMsg(GrpcData Data)\n        {\n            if (channel == null || csClient == null)\n            {\n                return false;\n            }\n            // 消息发送加锁， 避免消息粘包\n            lock (_msgSendLock)\n            {\n                if (channel.State != ChannelState.Ready)\n                {\n                    return false;\n                }\n                try\n                {\n                    GrpcResult resData = csClient.SendMsg(Data);\n                    if (!resData.Result)\n                    {\n                        return false;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }</code></pre>\n<p>客户端启动Connect连接服务端后，创建了数据接收检查通道线程，在连接Ready后receiveTask 为null时，调用一次服务接口方法ReceiveDataFromServer使用回调接收服务端传来的数据ReceivedData。</p>\n<p>客户端调用服务端ReceiveDataFromServer时，服务端创建了该客户端的Ip Port为key的任务TaskInfo来处理服务端后续传输给客户端的数据。当队列有数据时，通过服务接口的流传输_writerStream.WriteAsync(data);将数据发送给客户端，客户端利用回调方法接收到后进行处理。</p>\n<p>客户端给服务端发送数据：调用客户端的SendMsg(GrpcData Data)发送数据，服务端接收到数据后传给Func方法ServerReceiveData进行下一步处理。</p>\n<p>服务端给客户端发送数据：调用服务端的SendMsg(string ip, int port, GrpcData msg)方法，查看已连接客户端的Ip:Port的TaskInfo，将数据添加至相应队列。</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-19 17:15:31", "summary": "一、新建项目，定义服务接口新建项目，项目中程序包添加相关引用定义服务，创建文件创建文件定义两个服务方法：客户端发送数据到服务端：服务端发送数据到客户端从服务端接收数据：，因为是服务端主动触发，所以从服"}