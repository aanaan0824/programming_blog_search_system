{"blogid": "123062129", "writerAge": "码龄3年", "writerBlogNum": "21", "writerCollect": "121", "writerComment": "25", "writerFan": "13", "writerGrade": "2级", "writerIntegral": "365", "writerName": "风华绝代一只猫", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123062129.jpg", "writerRankTotal": "43691", "writerRankWeekly": "693142", "writerThumb": "21", "writerVisitNum": "35252", "blog_read_count": "13609", "blog_time": "已于 2022-03-15 15:57:02 修改", "blog_title": "pytest", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>参考链接：<a href=\"https://www.osgeo.cn/pytest/getting-started.html\" title=\"安装和入门 — pytest documentation\">安装和入门 — pytest documentation</a></p>\n<h1>一、关于pytest</h1>\n<p><strong>0.安装</strong></p>\n<pre>pip install -U pytest 或者 在pycharm中安装pytest\n</pre>\n<p> -u代表如果安装了升级到最新版</p>\n<p>查看版本</p>\n<p>pytest --version</p>\n<p><strong>1.关于pytest</strong></p>\n<p>        按照一定顺序执行文件和类、方法（（小写英文---&gt;大写英文---&gt;0-9数字））</p>\n<ul><li>测试文件以test_开头（以_test结尾也可以）</li><li>测试类以Test开头，并且不能带有 <strong>init</strong> 方法</li><li>测试函数以test_开头</li><li>断言使用基本的assert即可</li></ul>\n<p><strong>2.运行方式</strong></p>\n<p><strong>运行一个方法（pycharm点击方法或者类前面的运行按钮，选择pytest run。。。）</strong></p>\n<p><img alt=\"\" height=\"145\" src=\"..\\..\\static\\image\\2985759479e54c67a347074326bed1f8.png\" width=\"443\"/></p>\n<p></p>\n<p>1）通过主函数启动，可以在运行的文件中写主函数，像这样</p>\n<p>        主函数启动需要引入pytest包，不然找不到pytest方法）</p>\n<pre><code>import pytest\n\nclass TestClass:\n    def test_one(self):\n        x = \"this\"\n        assert \"h\" in x\n\n    def test_two(self):\n        x = \"hello\"\n        assert hasattr(x, \"check\")\n\nif __name__ == '__main__':\n#    pytest.main()\n    pytest.main(\"test_study.py\")\n</code></pre>\n<p>pytest.main()会自动读取当前目录下的所有test开头的.py文件，运行test方法或者类</p>\n<p>可以传入不同的参数，让运行更加定制化</p>\n<pre><code>pytest.main(['./'])               # 运行./目录下所有（test_*.py  和 *_test.py）\npytest.main (['./subpath1'])    # 运行./subpath1 目录下用例\npytest.main (['./subpath1/test_module1.py'])    # 运行指定模块\npytest.main (['./subpath1/test_module1.py::test_m1_1'])  # 运行模块中的指定用例\npytest.main (['./subpath2/test_module2.py::TestM2::test_m2_02'])  # 运行类中的指定用例\npytest.main (['-k','pp'])         # 匹配包含pp的用例(匹配目录名、模块名、类名、用例名)\npytest.main(['-k','spec','./subpath1/test_module1.py'])     # 匹配test_module1.py模块下包含spec的用例\npytest.main(['-k','pp','./subpath2/test_module2.py::TestM2'])   # 匹配TestM2类中包含pp的用例\n</code></pre>\n<p>值得注意的一点，如果main中传入的参数没生效，右键运行的时候，默认运行了当前文件的所有用例，这是因为程序识别到了pytest框架，默认pytest运行，要main主函数运行，需要修改陈python解释器</p>\n<p>第一步：编辑解释器</p>\n<p><img alt=\"\" height=\"242\" src=\"..\\..\\static\\image\\dd771837f3254ec2844021a4ff819ec2.png\" width=\"334\"/></p>\n<p>第二步：如果列表中没有python解释器，新增一个python解释器，选择要执行的文件</p>\n<p><img alt=\"\" height=\"516\" src=\"..\\..\\static\\image\\2223353c35da42049206f9de4dc14c55.png\" width=\"402\"/><img alt=\"\" height=\"330\" src=\"..\\..\\static\\image\\6296c33aebc347c5a3f698a758497442.png\" width=\"990\"/></p>\n<p>第三步：确定后，查看右上角运行，变为了普通运行，这时候运行文件会运行main函数 </p>\n<p> <img alt=\"\" height=\"453\" src=\"..\\..\\static\\image\\8ada1f8adeb04246be281ebff825f052.png\" width=\"772\"/></p>\n<p>另外一种 ：可以直接在控制台使用python xx.py      指定用python解释器运行main主函数</p>\n<p>再另外一种： python -m pytest 调用pytest框架</p>\n<p>2)通过控制台启动（推荐）</p>\n<p>选择pycharm&gt;terminal</p>\n<p><img alt=\"\" height=\"348\" src=\"..\\..\\static\\image\\e65bcd4fd2c14183835705de681050fe.png\" width=\"1000\"/></p>\n<p></p>\n<ul><li><code>pytest test_mod.py</code> 执行该模块下的测试类测试方法</li><li><code>pytest testing</code> 执行该文件夹下的所有模块</li><li><code>pytest test_cgi.py::test_answer</code>，执行test_answer方法</li><li><code>pytest test_cgi.py::TestMyClass::test_one</code>，执行TestMyClass类下的test_one方法产</li><li>查看详细的输出：-r随意拼接下方字符 例如-rfp  -fa (展示全部的用例情况）pytest -ra study.py \n  <ul><li>-x 用例一旦失败，就立刻停止执行</li><li>--maxfile=num 用例达到多少停止执行</li><li>-m 标记用例</li><li>-k 执行包含某个关键字的测试用例</li><li>-v 打印详细日志</li><li>-s 打印输出日志 和v连用</li><li>--lf 只重新运行失败的用例</li><li>--ff 先运行失败的用例再运行正常的用例</li></ul></li></ul>\n<p><strong>3.查看详细情况</strong></p>\n<p>        通过-vv查看每个用例通过的时长和详细情况</p>\n<p>        pytest -vv test_study.py</p>\n<p>        获取长度超过1s的最慢10个测试用例持续时间的列表</p>\n<p>        pytest --durations=10 --durations-min=1.0 -vv test_study.py</p>\n<p>        </p>\n<p><strong>4.断言  </strong></p>\n<p><code>pytest</code> 允许您使用标准的python <code>assert</code> 用于验证Python测试中的期望和值，<code>pytest</code> 支持显示最常见的子表达式的值</p>\n<pre><code>def f():\n    return 3\n\n\ndef test_function():\n    assert f() == 4</code></pre>\n<h3>5.套件</h3>\n<pre><code># -*-coding:utf-8-*-\nimport pytest\n\n# module一个模块只会执行一次，最开头和最结尾调用\ndef setup_module():\n    print('每个模块执行一次 开始')\n\ndef teardown_module():\n    print('每个模块执行一次 结束')\n\n# function 每个用例执行一次，不会对类中的用例生效\ndef setup_function():\n    print(\"每个类外用例前执行\")\n\ndef teardown_function():\n    print(\"每个类外用例后执行\")\n\n\n\ndef test_case2():\n    print(\"2\")\n\nclass TestDemo:\n    def setup_class(self):\n        print(\"当前类之前执行\")\n    def teardown_class(self):\n        print(\"当前类之后执行\")\n    def setup(self):\n        print(\"类里的每个方法调用  前\")\n    def teardown(self):\n        print(\"类里的每个方法调用  后\")\n\n    def test_case3(self):\n        print(\"我是测试用例\")</code></pre>\n<h3>6.装饰器（常用）</h3>\n<p>        skip  ： 跳过这个用例  reason是解释</p>\n<p>    </p>\n<pre><code># 跳过这个用例skip装饰器\n@pytest.mark.skip(reason = \"暂时不执行\")\ndef test_case5():\n    print(\"test5\")\n\ndef test_case6():\n    return  4\n\n# 可以在用例里面做判断，判断结果为真跳过这条用例\ndef test_case7():\n    if 4 == test_case6():\n        pytest.skip(\"跳过原因case6等于4\")\n    print(\"case7\")\n\n# 可以直接在外面做判断skipif\n@pytest.mark.skipif(test_case6() == 4 ,reason=\"跳过因为是windows系统\")\ndef test_case8():\n    print(\"case8\")</code></pre>\n<p>        装饰器都已pytest.mark开头，可以自定义装饰器，相当于分组</p>\n<p>        运行pytest xx.py -m group2  </p>\n<p>        运行所有带有这个装饰器的用例，没有则显示为 deselected</p>\n<pre><code>@pytest.mark.group2\ndef test_case4():\n    print(\"test4\")</code></pre>\n<h3>7.ini配置文件</h3>\n<p>      它是一个固定的文件pytest.ini文件，读取配置信息，按指定的方式去运行。pytest.ini的位置：一般放在项目工程的根目录（即当前项目的顶级文件夹下）</p>\n<p>        注意ini中最好不要写入中文，运行 会报错'gbk' codec can't decode byte 0x80 in position 92: illegal multibyte sequence<br/>         </p>\n<p>        配置项解释：</p>\n<p>        1)    markers： 默认分组，将标记的用例加入自定义分组，添加到ini中，启动后将忽略非自定义分组带来的warnings</p>\n<p>        <img alt=\"\" height=\"162\" src=\"..\\..\\static\\image\\aa517cec071c41389a546a2092957dd2.png\" width=\"401\"/></p>\n<p></p>\n<p>        <img alt=\"\" height=\"88\" src=\"..\\..\\static\\image\\8e306b6d91274a3e8703a6000b2f776c.png\" width=\"221\"/></p>\n<p>        运行：pytest run.py -m group1</p>\n<p>        <img alt=\"\" height=\"286\" src=\"..\\..\\static\\image\\0326ae24bca94f22b61a69dccc3a8a81.png\" width=\"751\"/></p>\n<p>         2) addopts：可以添加指定的OPTS命令行参数集,在执行命令时,不用再每次都输入长串命令</p>\n<p>                 addopts：-p no：warning  （忽略warning）</p>\n<h3><strong>8.读取yaml文件</strong></h3>\n<pre><code># 直接读出来是字典\n    def read_y(self):\n        last_filename = \"yamlfile/\" + self.filename+\".yaml\"\n        print(last_filename)\n        f = yaml.safe_load(open(last_filename,encoding=\"utf-8\"))\n        print(f)\n        print(type(f))\n        return f</code></pre>\n<h1>对应的yaml文件数据长这样：</h1>\n<p><img alt=\"\" height=\"149\" src=\"..\\..\\static\\image\\bd66b61d99ff43f5bbd0748fa9f12cec.png\" width=\"301\"/></p>\n<p>读取出来的数据为： {'TEST': {'TEST_HOST': '127.0.0.1'}, 'ZS': {'ZS_HOST': '251.214.32.21'}}</p>\n<p> 如果想要传入一个列表到用例中，需要在TEST和ZS前面加上-</p>\n<p><img alt=\"\" height=\"130\" src=\"..\\..\\static\\image\\562f6e2211d342398c282327e6eae895.png\" width=\"301\"/></p>\n<p>读取出来的数据为： [{'TEST': None, 'TEST_HOST': '127.0.0.1'}, {'ZS': None, 'ZS_HOST': '251.214.32.21'}]</p>\n<p> 装饰器传入数据的时候必须是个列表，才能按照列表下标传入数据,列表中有几个数据，测试用例有几条</p>\n<pre><code>    # 传入的argnames必须是列表，yaml文件在key前加上- 读取为列表，不然会自动读取字典的key；\n    # 传入一个值\n    @pytest.mark.parametrize((\"env\"),yaml.safe_load(open(\"./env.yml\")))\n    def test_demo(self,env):\n        print(env)\n    def test_read_yaml(self):\n        a = yaml.safe_load(open(\"./env.yml\"))\n        print(type(a),a)\n    # 传入多个值\n    @pytest.mark.parametrize('user, pwd', [('root', '123'), ('admin', '456')])\n    def test_03(self,user, pwd):\n        print(user,pwd)</code></pre>\n<h1>二、allure</h1>\n<p>0.安装java1.8</p>\n<p>1、安装alluer+ allure-pytest</p>\n<p>        1）下载allure 的zip包，下载后放到python文件夹lib下        </p>\n<p>        2）进入allure 的bin目录下，复制路径，放到path环境变量</p>\n<p>        3）安装alluer-pytest</p>\n<p>                pip install allure-pytest</p>\n<p> 2、生成报告（terminal）</p>\n<p>        1）terminal启动用例，指定数据存在什么文件夹下（目前是存在当前文件夹下的tmp文件夹）</p>\n<p>        pytest --alluredir=tmp test_study.py</p>\n<p>        2）查看报告</p>\n<p>               2.1) 直接打开生成数据图表：allure serve 生成数据文件目录</p>\n<p>                注意：如果直接在pycharm中启动命令行，需要定位到allure.bat的详细位置</p>\n<p>                D:\\python\\Lib\\allure-2.9.0\\bin\\ allure serve 生成的数据文件路径</p>\n<p></p>\n<p>                2.2)生成一个文件夹，存储html，进入report打开html查看报告</p>\n<p>                D:\\python\\Lib\\allure-2.9.0\\bin\\allure generate 生成的数据文件路径 -o html的路径 --clean</p>\n<p>              </p>\n<p>3、生成报告（main）</p>\n<pre><code>if __name__==\"__main__\":\n\n# --alluredir  生成allure报告需要的数据文件\n    pytest.main(['test_study.py','-s', \"--alluredir=tmp\"])\n\n# allure generate 生成allure测试报告默认生成一个文件夹allure-result； --clean保证每一次生成的html是最新的数据\n    os.system(\"allure generate tmp --clean\")</code></pre>\n<p><img alt=\"\" height=\"739\" src=\"..\\..\\static\\image\\684b34974d0a4994938a134aa55351d1.png\" width=\"1200\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-03-15 15:57:02", "summary": "参考链接：安装和入门安装和入门一、关于安装或者在中安装代表如果安装了升级到最新版查看版本关于按照一定顺序执行文件和类、方法小写英文大写英文数字测试文件以开头以结尾也可以测试类以开头，并且不能带有方法测"}