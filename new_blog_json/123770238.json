{"blogid": "123770238", "writerAge": "码龄2年", "writerBlogNum": "35", "writerCollect": "283", "writerComment": "733", "writerFan": "1465", "writerGrade": "5级", "writerIntegral": "2772", "writerName": "Soryu_Shikinami", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123770238.jpg", "writerRankTotal": "41089", "writerRankWeekly": "214964", "writerThumb": "934", "writerVisitNum": "17392", "blog_read_count": "730", "blog_time": "于 2022-03-29 16:29:01 发布", "blog_title": "【STL详解】list的模拟实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%BB%E8%A7%88%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%BB%E8%A7%88%EF%BC%9A\">list的模拟实现总览：</a></p>\n<p id=\"1.%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">1.节点类的模拟实现</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></p>\n<p id=\"2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.迭代器类的模拟实现</a></p>\n<p id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E\">迭代器类的模板参数说明</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></p>\n<p id=\"%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">++运算符的重载</a></p>\n<p id=\"--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">--运算符的重载</a></p>\n<p id=\"%3D%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%3D%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">==运算符的重载</a></p>\n<p id=\"!%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#!%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">!=运算符的重载</a></p>\n<p id=\"*%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#*%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">*运算符的重载</a></p>\n<p id=\"%C2%A0-%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0-%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\"> -&gt;运算符的重载</a></p>\n<p id=\"list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">list的模拟实现</a></p>\n<p id=\"%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">默认成员函数</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</a></p>\n<p id=\"%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89\"> 拷贝构造函数（迭代器版本）</a></p>\n<p id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95)-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%28%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%29\">拷贝构造函数(现代写法)</a></p>\n<p id=\"%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89\">赋值运算符重载函数（现代写法）</a></p>\n<p id=\"%C2%A0%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"> 其他构造函数</a></p>\n<p id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">析构函数</a></p>\n<p id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\">迭代器相关函数</a></p>\n<p id=\"%C2%A0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\"> 访问容器相关函数</a></p>\n<p id=\"%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0\">插入、删除函数</a></p>\n<p id=\"insert%EF%BC%88%E5%89%8D%E6%8F%92%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#insert%EF%BC%88%E5%89%8D%E6%8F%92%EF%BC%89\">insert（前插）</a></p>\n<p id=\"erase-toc\" style=\"margin-left:40px;\"><a href=\"#erase\">erase</a></p>\n<p id=\"push_back%E5%92%8Cpop_back-toc\" style=\"margin-left:40px;\"><a href=\"#push_back%E5%92%8Cpop_back\">push_back和pop_back</a></p>\n<p id=\"push_front%E5%92%8Cpop_front-toc\" style=\"margin-left:40px;\"><a href=\"#push_front%E5%92%8Cpop_front\">push_front和pop_front</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p><img alt=\"\" height=\"494\" src=\"..\\..\\static\\image\\326dd62e720947b7a775c8a12c753636.png\" width=\"749\"/></p>\n<p></p>\n<h1 id=\"list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%BB%E8%A7%88%EF%BC%9A\">list的模拟实现总览：</h1>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nnamespace lxy\n{\n\t//模拟实现list当中的结点类\n\ttemplate&lt;class T&gt;\n\tstruct ListNode\n\t{\n\t\t//构造函数\n\t\tListNode(const T&amp; data = T());\n\t\t//成员变量\n\t\tT _data;\t\t\t//数据域\n\t\tListNode&lt;T&gt;* _next;\t//后继指针\n\t\tListNode&lt;T&gt;* _prev;\t//前驱指针\n\t};\n\n\t//模拟实现list迭代器\n\ttemplate&lt;class T,class Ref,class Ptr&gt;\n\tstruct __list_iterator\n\t{\n\t\ttypedef ListNode&lt;T&gt; Node;\n\t\ttypedef __list_iterator&lt;T, Ref, Ptr&gt; self;\n\n\t\t//构造函数\n\t\t__list_iterator(Node* x);\n\n\t\t//各种运算符重载函数\n\t\tself&amp; operator++();\n\t\tself&amp; operator--();\n\t\tself operator++(int);\n\t\tself operator--(int);\n\t\tbool operator==(const self&amp; it) const;\n\t\tbool operator!=(const self&amp; it) const;\n\t\tRef operator*();\n\t\tPtr operator-&gt;();\n\n\t\t//成员变量\n\t\tNode* _node;\n\t};\n\n\n\t//模拟实现list\n\ttemplate&lt;class T&gt;\n\tclass list\n\t{\n\tpublic:\n\t\ttypedef ListNode&lt;T&gt; Node;\n\t\ttypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;\n\t\ttypedef __list_iterator&lt;T, const T&amp;, const  T*&gt; const_iterator;\n\t\t\n\t\t//默认成员函数\n\t\tlist();\n\t\tlist(const list&lt;T&gt;&amp; lt);\n\t\tlist&lt;T&gt;&amp; operator=(const list&lt;T&gt;&amp; lt);\n\t\t~list();\n\n\t\t//迭代器相关函数\n\t\titerator begin();\n\t\titerator end();\n\t\tconst_iterator begin() const;\n\t\tconst_iterator end() const;\n\n\t\t//访问容器相关函数\n\t\tT&amp; front();\n\t\tT&amp; back();\n\t\tconst T&amp; front() const;\n\t\tconst T&amp; back() const;\n\n\t\t//插入、删除函数\n\t\titerator insert(iterator pos, const T&amp; x);\n\t\titerator erase(iterator pos);\n\t\tvoid push_back(const T&amp; x);\n\t\tvoid pop_back();\n\t\tvoid push_front(const T&amp; x);\n\t\tvoid pop_front();\n\n\t\t//其他函数\n\t\tsize_t size() const;\n\t\tvoid resize(size_t n, const T&amp; val = T());\n\t\tvoid clear();\n\t\tbool empty() const;\n\t\tvoid swap(list&lt;T&gt;&amp; lt);\n\n\tprivate:\n\t\t//指向链表头结点的指针\n\t\tNode* _head;\n\t};\n}</code></pre>\n<h1 id=\"1.%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">1.节点类的模拟实现</h1>\n<pre><code class=\"language-cpp\">\ttemplate&lt;class T&gt;\n\tstruct ListNode\n\t{\n\t\t//构造函数\n\t\tListNode(const T&amp; data = T());\n\t\t//成员变量\n\t\tT _data;\t\t\t//数据域\n\t\tListNode&lt;T&gt;* _next;\t//后继指针\n\t\tListNode&lt;T&gt;* _prev;\t//前驱指针\n\t};\n</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\a54ae561a0b06a20d0d9b6fd46ca795b.png\"/></p>\n<blockquote>\n<p>list是一个带头双向循环链表，故先实现一个结点类。</p>\n</blockquote>\n<h2 id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</h2>\n<pre><code class=\"language-cpp\">\t\tListNode(const T&amp; data = T())\n\t\t\t:_next(nullptr)\n\t\t\t, _prev(nullptr)\n\t\t\t, _data(data)\n\t\t{ }\n</code></pre>\n<p> <strong>注意：</strong> 若构造结点时未传入数据，则默认以list容器所存储类型的默认构造函数所构造出来的值为传入数据。</p>\n<h1 id=\"2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.迭代器类的模拟实现</h1>\n<pre><code class=\"language-cpp\">\t//模拟实现list迭代器\n\ttemplate&lt;class T,class Ref,class Ptr&gt;\n\tstruct __list_iterator\n\t{\n\t\ttypedef ListNode&lt;T&gt; Node;\n\t\ttypedef __list_iterator&lt;T, Ref, Ptr&gt; self;\n\n\t\t//构造函数\n\t\t__list_iterator(Node* x);\n\n\t\t//各种运算符重载函数\n\t\tself&amp; operator++();\n\t\tself&amp; operator--();\n\t\tself operator++(int);\n\t\tself operator--(int);\n\t\tbool operator==(const self&amp; it) const;\n\t\tbool operator!=(const self&amp; it) const;\n\t\tRef operator*();\n\t\tPtr operator-&gt;();\n\n\t\t//成员变量\n\t\tNode* _node;\n\t};\n</code></pre>\n<p>对于list来说，其各个结点在内存当中的位置是随机的，并不是连续的，我们不能仅通过结点指针的自增、自减以及解引用等操作对相应结点的数据进行操作。迭代器让使用者可以不必关心容器的底层实现，可以用简单统一的方式对容器内的数据进行访问。</p>\n<blockquote>\n<p> list迭代器类，<strong>实际上就是对结点指针进行了封装，对其各种运算符进行了重载</strong>，使得结点指针的各种行为看起来和普通指针一样。</p>\n</blockquote>\n<h2 id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E\">迭代器类的模板参数说明</h2>\n<pre><code class=\"language-cpp\">\ttemplate&lt;class T,class Ref,class Ptr&gt;\n</code></pre>\n<p>在list的模拟实现当中，typedef了两个迭代器类型，普通迭代器和const迭代器。</p>\n<pre><code class=\"language-cpp\">\t\ttypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;\n\t\ttypedef __list_iterator&lt;T, const T&amp;, const  T*&gt; const_iterator;\n</code></pre>\n<p>可知：Ref代表<strong>引用</strong>类型，Ptr代表<strong>指针</strong>类型。</p>\n<p>若该迭代器类不设计三个模板参数，那么就不能很好的区分普通迭代器和const迭代器。</p>\n<h2>构造函数</h2>\n<p>对结点指针进行了封装，封装成迭代器。</p>\n<pre><code class=\"language-cpp\">\t\t__list_iterator(Node* x)\n\t\t\t:_node(x)\n\t\t{}\n</code></pre>\n<h2 id=\"%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">++运算符的重载</h2>\n<p>前置++，后置++</p>\n<p>迭代器++，访问下一个节点</p>\n<pre><code class=\"language-cpp\">\t\t// ++it\n\t\tself&amp; operator++()\n\t\t{\n\t\t\t_node = _node-&gt;_next;\n\t\t\treturn *this;\n\t\t}\n\n\t\t// it++\n\t\tself operator++(int)\n\t\t{\n\t\t\tself tmp(*this);\n\t\t\t_node = _node-&gt;_next;\n\t\t\treturn tmp;\n\t\t}\n</code></pre>\n<p><strong>说明：</strong> self是当前迭代器对象的类型：</p>\n<pre><code class=\"language-cpp\">\t\ttypedef __list_iterator&lt;T, Ref, Ptr&gt; self;\n</code></pre>\n<h2 id=\"--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">--运算符的重载</h2>\n<p>前置--，后置--</p>\n<p>迭代器--，访问上一个节点</p>\n<pre><code class=\"language-cpp\">\t\t// --it\n\t\tself&amp; operator--()\n\t\t{\n\t\t\t_node = _node-&gt;_prev;\n\t\t\treturn *this;\n\t\t}\n\n\t\t// it--\n\t\tself operator--(int)\n\t\t{\n\t\t\tself tmp(*this);\n\t\t\t_node = _node-&gt;_prev;\n\t\t\treturn tmp;\n\t\t}\n</code></pre>\n<h2 id=\"%3D%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">==运算符的重载</h2>\n<p>判断两个迭代器当中的结点指针的指向是否相同，注意加上const</p>\n<pre><code class=\"language-cpp\">\t\tbool operator!=(const self&amp; it) const\n\t\t{\n\t\t\treturn _node != it._node;\n\t\t}\n</code></pre>\n<h2 id=\"!%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">!=运算符的重载</h2>\n<p>判断两个迭代器当中的结点指针的指向是否不同，注意加上const</p>\n<pre><code class=\"language-cpp\">\t\tbool operator==(const self&amp; it) const\n\t\t{\n\t\t\treturn _node != it._node;\n\t\t}\n</code></pre>\n<h2 id=\"*%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">*运算符的重载</h2>\n<p>*运算符得到该位置的数据内容，并且<strong>返回引用</strong></p>\n<pre><code class=\"language-cpp\">\t\tRef operator*()\n\t\t{\n\t\t\treturn _node-&gt;_data;\n\t\t}\n</code></pre>\n<h2 id=\"%C2%A0-%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\"> -&gt;运算符的重载</h2>\n<p>某些情景下，我们使用迭代器的时候可能会用到-&gt;运算符。</p>\n<p>当list容器当中的每个结点存储的<strong>不是内置类型，而是自定义类型</strong>，例如日期类，那么当我们拿到一个位置的迭代器时，我们可能会使用-&gt;运算符访问Date的成员：</p>\n<pre><code class=\"language-cpp\">\tvoid test()\n\t{\n\t\tlist&lt;Date&gt; lt;\n\t\tlt.push_back(Date(2022, 3, 12));\n\t\tlt.push_back(Date(2022, 3, 13));\n\t\tlt.push_back(Date(2022, 3, 14));\n\n\t\tlist&lt;Date&gt;::iterator it = lt.begin();\n\t\twhile (it != lt.end())\n\t\t{\n\t\t\t//cout &lt;&lt; (*it)._year &lt;&lt; \"/\" &lt;&lt; (*it)._month &lt;&lt; \"/\" &lt;&lt; (*it)._day &lt;&lt; endl;\n\t\t\tcout &lt;&lt; it-&gt;_year &lt;&lt; \"/\" &lt;&lt; it-&gt;_month &lt;&lt; \"/\" &lt;&lt; it-&gt;_day &lt;&lt; endl;\n\n\t\t\t++it;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n</code></pre>\n<p> <strong>注意：</strong> 使用pos-&gt;_year这种访问方式时，需要将日期类的成员变量设置为公有。</p>\n<p>对于-&gt;运算符的重载，我们直接<strong>返回结点当中所存储数据的地址</strong>即可。</p>\n<pre><code class=\"language-cpp\">\t\tPtr operator-&gt;()\n\t\t{\n\t\t\treturn &amp;_node-&gt;_data;\n\t\t}\n</code></pre>\n<p>这里本来是应该有两个-&gt;的，第一个箭头是pos -&gt;去调用重载的operator-&gt;返回Date* 的指针，第二个箭头是Date* 的指针去访问对象当中的成员变量_year。</p>\n<p>但是一个地方出现两个箭头，程序的可读性太差了，所以编译器做了特殊识别处理，为了增加程序的可读性，省略了一个箭头。</p>\n<h1 id=\"list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">list的模拟实现</h1>\n<h2 id=\"%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">默认成员函数</h2>\n<h2>构造函数</h2>\n<p>list是一个<strong>带头双向循环链表</strong>，在构造一个list对象时，申请一个头结点，并让其前驱指针和后继指针都指向自己即可。</p>\n<p><img alt=\"\" height=\"154\" src=\"..\\..\\static\\image\\ace70fb6ec8f448586f5f2bc7cd5c221.png\" width=\"372\"/></p>\n<pre><code class=\"language-cpp\">\t\tlist()\n\t\t{\n\t\t\t_head = new Node();\n\t\t\t_head-&gt;_next = _head;\n\t\t\t_head-&gt;_prev = _head;\n\t\t}\n</code></pre>\n<h2 id=\"%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89\"> 拷贝构造函数（迭代器版本）</h2>\n<p>先申请一个头节点，再遍历一个范围，push进去</p>\n<p>说明：push_back函数稍后讲解。</p>\n<pre><code class=\"language-cpp\">\t\t//list lst2(lst1.begin(),lst1.end());\n        template&lt;class InputIterator&gt;\n\t\tlist(InputIterator first, InputIterator last)\n\t\t{\n\t\t\t_head = new Node();\n\t\t\t_head-&gt;_next = _head;\n\t\t\t_head-&gt;_prev = _head;\n\t\t\twhile (first != last)\n\t\t\t{\n\t\t\t\tpush_back(*first);\n\t\t\t\t++first;\n\t\t\t}\n\t\t}\n</code></pre>\n<h2 id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95)\">拷贝构造函数(现代写法)</h2>\n<p>先用<strong>迭代器版本构造函数</strong>构造tmp，再<strong>交换头指针指向位置</strong>。</p>\n<pre><code class=\"language-cpp\">\t\t// lt2(lt1)\n\t\tlist(const list&lt;T&gt;&amp; lt)\n\t\t{\n\t\t\t_head = new Node();\n\t\t\t_head-&gt;_next = _head;\n\t\t\t_head-&gt;_prev = _head;\n\n\t\t\tlist&lt;T&gt; tmp(lt.begin(), lt.end());\n\t\t\tstd::swap(_head, tmp._head);\n\t\t}\n</code></pre>\n<h2 id=\"%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89\">赋值运算符重载函数（现代写法）</h2>\n<p>利用编译器机制，故意<strong>不使用引用接收参数</strong>，通过编译器自动调用list的拷贝构造函数构造出来一个list对象，然后调用swap函数将原容器与该list对象进行交换即可。</p>\n<pre><code class=\"language-cpp\">\t\t// lt2 = lt1\n\t\tlist&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)\n\t\t{\n\t\t\tstd::swap(_head, lt._head);\n\t\t\treturn *this;\n\t\t}\n</code></pre>\n<h2 id=\"%C2%A0%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"> 其他构造函数</h2>\n<p>使用案例：</p>\n<p>构造一个list：1，1，1，1，1</p>\n<p>构造一个list含5个Date类型。</p>\n<p><strong>注意：</strong></p>\n<p><img alt=\"\" height=\"71\" src=\"..\\..\\static\\image\\0027640826944b009a553969a14cd267.png\" width=\"738\"/></p>\n<p> class InputIterator应该为<strong>迭代器类型</strong>，但是如果</p>\n<p>list&lt;int&gt; lt2(5, 1);</p>\n<p>则会识别为<strong>int</strong>类型，所以写出带<strong>int</strong>的构造函数，编译器会优先选择。 </p>\n<pre><code class=\"language-cpp\">\t\t// list&lt;Date&gt; lt1(5, Date(2022, 3, 15));\n\t\t// list&lt;int&gt; lt2(5, 1);\n\t\tlist(int n, const T&amp; val = T())\n\t\t{\n\t\t\t_head = new Node();\n\t\t\t_head-&gt;_next = _head;\n\t\t\t_head-&gt;_prev = _head;\n\t\t\tfor (int i = 0; i &lt; n; ++i)\n\t\t\t{\n\t\t\t\tpush_back(val);\n\t\t\t}\n\t\t}\n\n\t\tlist(size_t n, const T&amp; val = T())\n\t\t{\n\t\t\t_head = new Node();\n\t\t\t_head-&gt;_next = _head;\n\t\t\t_head-&gt;_prev = _head;\n\t\t\tfor (size_t i = 0; i &lt; n; ++i)\n\t\t\t{\n\t\t\t\tpush_back(val);\n\t\t\t}\n\t\t}\n</code></pre>\n<h2 id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">析构函数</h2>\n<p>首先说明：clear 函数（2钟写法），erase函数稍后解析。</p>\n<pre><code class=\"language-cpp\">void clear()\n{\n\titerator it = begin();\n\twhile (it != end())\n\t{\n\t\titerator del = it++;    //迭代器前进\n\t\tdelete del._node;       //删除当前位置数据\n\t}\n\n\t_head-&gt;_next = _head;\n\t_head-&gt;_prev = _head;\n}\n\nvoid clear()\n{\n\titerator it = begin();\n\twhile (it != end())\n\t{\n\t\terase(it++);\n\t}\n}</code></pre>\n<p><strong>析构函数：</strong>首先调用clear函数清理容器当中的数据，然后将头结点释放，最后将头指针置空即可。</p>\n<pre><code class=\"language-cpp\">\t\t~list()\n\t\t{\n\t\t\tclear();\n\n\t\t\tdelete _head;\n\t\t\t_head = nullptr;\n\t\t}\n</code></pre>\n<h2 id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\">迭代器相关函数</h2>\n<p><strong>begin和end：</strong>begin函数返回的是第一个有效数据的迭代器，end函数返回的是最后一个有效数据的下一个位置的迭代器。即begin指向首元素，end指向尾后。</p>\n<p>对于list这个带头双向循环链表来说：</p>\n<p><img alt=\"\" height=\"219\" src=\"..\\..\\static\\image\\b209df78e7cf4978a73feb8df2e1affc.png\" width=\"876\"/></p>\n<p>说明：</p>\n<pre><code class=\"language-cpp\">typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;\ntypedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n</code></pre>\n<p><strong>并且迭代器就是对节点指针的封装。</strong></p>\n<pre><code class=\"language-cpp\">\niterator begin()\n{\n\treturn iterator(_head-&gt;_next);\n}\n\niterator end()\n{\n\treturn iterator(_head);\n}\n\nconst_iterator begin() const\n{\n\treturn const_iterator(_head-&gt;_next);\n}\n\nconst_iterator end() const\n{\n\treturn const_iterator(_head);\n}</code></pre>\n<h2 id=\"%C2%A0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\"> 访问容器相关函数</h2>\n<p>front和back函数分别用于获取第一个有效数据和最后一个有效数据，并且返回引用。</p>\n<pre><code class=\"language-cpp\">T&amp; front()\n{\n\treturn *begin(); //返回第一个有效数据的引用\n}\nT&amp; back()\n{\n\treturn *(--end()); //返回最后一个有效数据的引用\n}\n</code></pre>\n<p>const版本不再赘述。</p>\n<h2 id=\"%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0\">插入、删除函数</h2>\n<p><strong>核心函数：insert函数  erase函数，其他函数复用insert和erase得到</strong></p>\n<h2 id=\"insert%EF%BC%88%E5%89%8D%E6%8F%92%EF%BC%89\">insert（前插）</h2>\n<p>插入后返回指向newNode的迭代器。</p>\n<pre><code class=\"language-cpp\">\t\t// 这里insert以后，pos不失效\n\t\titerator insert(iterator pos, const T&amp; x)\n\t\t{\n\t\t\tNode* cur = pos._node;\n\t\t\tNode* prev = cur-&gt;_prev;\n\t\t\tNode* newnode = new Node(x);\n\n\t\t\tprev-&gt;_next = newnode;\n\t\t\tnewnode-&gt;_prev = prev;\n\t\t\tnewnode-&gt;_next = cur;\n\t\t\tcur-&gt;_prev = newnode;\n\n\t\t\treturn iterator(newnode);\n\t\t}\n</code></pre>\n<h2 id=\"erase\">erase</h2>\n<pre><code class=\"language-cpp\">\t\t// 这里erase以后，pos失效\n\t\titerator erase(iterator pos)\n\t\t{\n\t\t\tassert(pos != end());\n\n\t\t\tNode* prev = pos._node-&gt;_prev;\n\t\t\tNode* next = pos._node-&gt;_next;\n\t\t\tdelete pos._node;\n\t\t\tprev-&gt;_next = next;\n\t\t\tnext-&gt;_prev = prev;\n\n\t\t\treturn iterator(next);\n\t\t}\n</code></pre>\n<p>删除后返回下一个位置的迭代器</p>\n<h2 id=\"push_back%E5%92%8Cpop_back\">push_back和pop_back</h2>\n<p><strong>复用insert、erase</strong></p>\n<pre><code class=\"language-cpp\">//尾插\nvoid push_back(const T&amp; x)\n{\n\tinsert(end(), x); //在头结点前插入结点\n}\n//尾删\nvoid pop_back()\n{\n\terase(--end()); //删除头结点的前一个结点\n}\n</code></pre>\n<h2 id=\"push_front%E5%92%8Cpop_front\">push_front和pop_front</h2>\n<p><strong>复用insert、erase</strong></p>\n<pre><code class=\"language-cpp\">//头插\nvoid push_front(const T&amp; x)\n{\n\tinsert(begin(), x); //在第一个有效结点前插入结点\n}\n//头删\nvoid pop_front()\n{\n\terase(begin()); //删除第一个有效结点\n}\n</code></pre>\n<h2>其他函数</h2>\n<h3>size</h3>\n<pre><code class=\"language-cpp\">size_t size() const\n{\n\tsize_t sz = 0; //统计有效数据个数\n\tconst_iterator it = begin(); //获取第一个有效数据的迭代器\n\twhile (it != end()) //通过遍历统计有效数据个数\n\t{\n\t\tsz++;\n\t\tit++;\n\t}\n\treturn sz; //返回有效数据个数\n}\n</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-29 16:29:01", "summary": "目录的模拟实现总览：节点类的模拟实现构造函数迭代器类的模拟实现迭代器类的模板参数说明构造函数运算符的重载运算符的重载运算符的重载运算符的重载运算符的重载运算符的重载的模拟实现默认成员函数构造函数拷贝构"}