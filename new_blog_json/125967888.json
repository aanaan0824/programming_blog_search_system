{"blogid": "125967888", "writerAge": "码龄2年", "writerBlogNum": "25", "writerCollect": "1668", "writerComment": "913", "writerFan": "9216", "writerGrade": "5级", "writerIntegral": "2785", "writerName": "石原里美的微笑", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125967888.jpg", "writerRankTotal": "7270", "writerRankWeekly": "781", "writerThumb": "1063", "writerVisitNum": "94603", "blog_read_count": "1108", "blog_time": "已于 2022-08-09 10:09:37 修改", "blog_title": "Java中的网络编程如何理解——精简", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BC%95%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E8%A8%80\">引言</a></p>\n<p id=\"%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0\">网络通信的三要素 </a></p>\n<p id=\"IP%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#IP%C2%A0\">IP </a></p>\n<p id=\"IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BBInetAddress%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BBInetAddress%C2%A0\">IP地址操作类InetAddress </a></p>\n<p id=\"%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0\">端口号（了解） </a></p>\n<p id=\"%E5%8D%8F%E8%AE%AE%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%8F%E8%AE%AE%C2%A0\">协议 </a></p>\n<p id=\"UDP%E9%80%9A%E4%BF%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#UDP%E9%80%9A%E4%BF%A1%C2%A0\">UDP通信 </a></p>\n<p id=\"TCP%E9%80%9A%E4%BF%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#TCP%E9%80%9A%E4%BF%A1%C2%A0\">TCP通信 </a></p>\n<p id=\"%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0\">实现同时接收多个客户端 </a></p>\n<p id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%C2%A0\">线程池优化 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%BC%95%E8%A8%80\">引言</h1>\n<blockquote>\n<p>         经过前面的课程，我们已经大概地了解到多线程的知识了，不知道大家是否已经掌握了呢？如果已经掌握了的话，那么我们今天就开始学习Java中的网络编程的相关知识，那么什么是网络编程呢？网络编程是可以让程序与网络上的其他设备中的数据进行数据交互。常见的通信模式有两种形式：Client-Server(CS)、Browser/Server(BS)。接下来我们将要学习的知识是网络通信的三要素、UDP通信、TCP通信。</p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\9cf3e118b7924a3985ae558a6986875c.png\" width=\"1200\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0\">网络通信的三要素 </h1>\n<blockquote>\n<p>关键的三要素：</p>\n<ul><li><span style=\"background-color:#a2e043;\">IP地址</span>：设备在网络中的地址。</li><li><span style=\"background-color:#38d8f0;\">端口</span>：应用程序在设备中唯一的标识。</li><li><span style=\"background-color:#faa572;\">协议</span>：数据库在网络中传输的规则，常见的协议有UDP协议和TCP协议。</li></ul>\n<p>（在通信过程中通过IP地址寻找设备，端口确定设备中的应用中的程序。） </p>\n<p></p>\n</blockquote>\n<h2 id=\"IP%C2%A0\"><span style=\"background-color:#a2e043;\">IP </span></h2>\n<blockquote>\n<p>IP地址形式：</p>\n<ul><li>公网地址和私有地址（局域网使用）</li><li>192.168.开头的就是常见的局域网地址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用。</li></ul>\n<p>IP常用命令：</p>\n<ul><li>ipconfig：查看本机IP地址</li><li>ping IP地址：检查网路是否连通</li></ul>\n<p>特殊IP地址：</p>\n<ul><li>本机IP：127.0.0.1或者localhost：称为回送地址也可称为本地回环地址，只会寻找当前所在本机。 </li></ul>\n</blockquote>\n<h3 id=\"IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BBInetAddress%C2%A0\">IP地址操作类InetAddress </h3>\n<blockquote>\n<p>InetAddress常用API</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>名称</td><td>说明</td></tr><tr><td>public static InetAddress getLocalHost()</td><td>返回本主机的地址对象</td></tr><tr><td>public static InetAddress getByName(String host)</td><td>得到指定主机的IP地址对象，参数是域名或者IP地址</td></tr><tr><td>public string getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>public string getHostAddress()</td><td>返回IP地址字符串</td></tr><tr><td>public boolean isReachable(int timeout)</td><td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">\n        InetAddress ip1 = InetAddress.getLocalHost();\n        //获取IP地址字符串\n        System.out.println(ip1.getHostAddress());\n        //返回IP地址主机名\n        System.out.println(ip1.getHostName());\n        //得到指定主机的IP地址对象\n        InetAddress ip2 = InetAddress.getByName(\"www.bilibili.com\");\n        //返回IP地址主机名\n        System.out.println(ip2.getHostName());\n        //获取IP地址字符串\n        System.out.println(ip2.getHostAddress());\n        //得到指定主机的IP地址对象\n        InetAddress ip3 = InetAddress.getByName(\"111.6.174.2\");\n        //返回IP地址主机名\n        System.out.println(ip3.getHostName());\n        //获取IP地址字符串\n        System.out.println(ip3.getHostAddress());\n        //5秒后连通\n        System.out.println(ip3.isReachable(5000));</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"178\" src=\"https://img-blog.csdnimg.cn/3668bb26ae8c48a6b917f895dabf17e2.gif\" width=\"220\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0\"><span style=\"background-color:#38d8f0;\">端口号（了解） </span></h2>\n<blockquote>\n<p>端口号：标识正在计算机设备上运行的进程（程序），被规定为一个16位的二进制，范围是0-65535。</p>\n<p>端口类型：0-1023，被预先定义的知名应用占用（如:HTTP占用80，FTP占用21)。</p>\n<p>注册端口:1024-49151，分配给用户进程或某些应用程序。(如:Tomcat占用8080，MySQL占用3306)。</p>\n<p>动态端口:49152-65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配。</p>\n<p><span style=\"color:#fe2c24;\"><strong>注意:</strong></span>我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</p>\n</blockquote>\n<h2 id=\"%E5%8D%8F%E8%AE%AE%C2%A0\"><span style=\"background-color:#faa572;\">协议 </span></h2>\n<blockquote>\n<p>传输层的两个常见协议：</p>\n<ul><li><span style=\"background-color:#a2e043;\">TCP：传输控制协议</span></li><li><span style=\"background-color:#38d8f0;\">UDP：用户数据协议</span></li></ul>\n<p><span style=\"background-color:#a2e043;\">TCP</span>协议特点：</p>\n<ul><li>使用TCP协议，必须双方先建立连接，它是一种面向连接的可靠通信协议</li><li>传输前，采用“三次握手”方式建立连接，所以是可靠的</li><li>在连接中可进行大数据量的传输</li><li>连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低</li></ul>\n<p><span style=\"background-color:#a2e043;\">TCP</span>协议通信场景：</p>\n<ul><li>对信息安全要求较高的场景，如：文件下载、金融等数据通信</li></ul>\n<p><span style=\"background-color:#38d8f0;\">UDP</span>协议：</p>\n<ul><li>UDP是一种无连接、不可靠传输的协议</li><li>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</li><li>每个数据包的大小限制在64KB内</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li><li>可以广播发送，发送数据结束时无需释放资源，开销小，速度快</li></ul>\n<p><span style=\"background-color:#38d8f0;\">UDP</span>协议通信场景：</p>\n<p>语言通话、视频通话等。</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"212\" src=\"https://img-blog.csdnimg.cn/3103e087c8a7478092d80bca7e3d255a.gif\" width=\"256\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"UDP%E9%80%9A%E4%BF%A1%C2%A0\">UDP通信 </h1>\n<blockquote>\n<p>DatagramPacket：数据包对象</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public DatagramPacket(byte[ ]buf,int length,InetAddress address,int port)</td><td> <p><span style=\"color:#fe2c24;\">创建发送端数据包对象</span><br/> buf:要发送的内容，字节数组</p> <p>length:要发送内容的字节长度</p> <p>address:接收端的</p> <p>IP地址对象</p> <p>port:接收端的端口号</p> </td></tr><tr><td>public DatagramPacket(byte [ ] buf, int length  )</td><td> <p><span style=\"color:#fe2c24;\">创建接收端的数据包对象</span></p> <p>buf:用来存储接收的内容</p> <p>length:能够接收内容的长度</p> </td></tr></tbody></table>\n<p> DatagramSocket:发送端和接收端对象</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public DatagramSocket( )</td><td>创建发送端的socket对象，系统会随机分配一个端口号</td></tr><tr><td>public DatagramSocket(int port)</td><td>创建接收端的socket对象并指定端口号</td></tr></tbody></table>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public void send （DatagramPacket dp）</td><td>发送数据包</td></tr><tr><td>public void receive （DatagramPacket p）</td><td>接收数据包</td></tr></tbody></table>\n<p>        为了更好的理解DatagramSocket和DatagramPacket，我们可以形象的把UDP形象的想象成“网购”，其中DatagramPacket就代表我们想要网购的商品，虽然这是我们买的，但是我们肯定是没有办法亲自去把商品拿走，因此就需要快递的运送，而DatagramSocket就是充当这个角色。商家将需要邮寄的商品通过DatagramPacket封装起来，然后再通过快递DatagramSocket将该商品派送到买家的手中。</p>\n<pre><code class=\"language-java\">//客户端\npublic static void main(String[] args) throws Exception{\n        DatagramSocket socket = new DatagramSocket();\n        byte [] buffer = \"你好，我是石原里美！\".getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer,buffer.length, InetAddress.getLocalHost(),9999);\n        socket.send(packet);\n        socket.close();\n    }</code></pre>\n<pre><code class=\"language-java\">//服务端\npublic static void main(String[] args) throws Exception{\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer,buffer.length);\n        socket.receive(packet);\n        int len = packet.getLength();//返回获取数据的长度\n        String s = new String(buffer,0,len);\n        System.out.println(s);\n        socket.close();\n    }</code></pre>\n<p><span style=\"color:#fe2c24;\">注意：</span>服务端需要先启动，等待客户端向服务端传送数据。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"177\" src=\"https://img-blog.csdnimg.cn/2e1f3746c6f244389bf14101ca58837d.gif\" width=\"230\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"TCP%E9%80%9A%E4%BF%A1%C2%A0\">TCP通信 </h1>\n<blockquote>\n<p>Socket</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public Socket(String host , int port)<br/>  </td><td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。<br/>  </td></tr></tbody></table>\n<p></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>OutputStream getOutputStream( )</td><td>获得字节输出流对象</td></tr><tr><td>InputStream getInputStream()</td><td>获得字节输入流对象</td></tr></tbody></table>\n<p>ServerSocket(服务端)</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public ServerSocket(int port)</td><td>注册服务端端口</td></tr></tbody></table>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public Socket accept（）</td><td> <p>等待接口客户端的Socket通信连接，连接成功返回Socket对象与客户端建立端与端通信</p> </td></tr></tbody></table>\n<pre><code class=\"language-java\">//客户端\npublic static void main(String[] args) throws Exception{\n        Socket socket = new Socket(\"172.0.0.1\",7777);\n        OutputStream os = socket.getOutputStream();\n        //通过打印输入流可以更高效\n        PrintStream printStream = new PrintStream(os);\n        printStream.println(\"你好，我是石原里美！\");\n        printStream.flush();\n        }\n    }</code></pre>\n<pre><code class=\"language-java\">public static void main(String[] args) throws  Exception{\n        ServerSocket serverSocket = new ServerSocket(7777);\n        Socket socket = serverSocket.accept();\n        InputStream is = socket.getInputStream();\n        //将字节输入流转化位字符输入流，再封装位缓冲字符输入流\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));\n        String s ;\n        while ((s = bufferedReader.readLine())!=null){\n            System.out.println(socket.getLocalSocketAddress()+s);\n        }\n    }</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"207\" src=\"https://img-blog.csdnimg.cn/f8bf0f38197c4171883f3e73eb762861.gif\" width=\"207\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0\">实现同时接收多个客户端 </h2>\n<blockquote>\n<p>如果想要实现同时接收多个客户端的话，就需要使用多线程的知识，创建多个服务端。</p>\n<p>首先创建一个类继承Thread，用于创建多线程：</p>\n<pre><code class=\"language-java\">public class ServerThread extends Thread{\n    private Socket socket;\n\n    public ServerThread(Socket socket) {\n        this.socket = socket;\n    }\n//中间内容不在此赘述\n\n    @Override\n    public void run() {\n        try {\n            InputStream is = socket.getInputStream();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));\n            String s ;\n            while ((s = bufferedReader.readLine())!=null){\n                System.out.println(socket.getLocalSocketAddress()+s);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p> 客户端代码：</p>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception{\n        Socket socket = new Socket(\"172.0.0.1\",7777);\n        OutputStream os = socket.getOutputStream();\n        PrintStream printStream = new PrintStream(os);\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            String s = sc.next();\n            printStream.println(s);\n            printStream.flush();\n        }\n    }</code></pre>\n<p>服务端代码：</p>\n<pre><code class=\"language-java\">public static void main(String[] args) throws  Exception{\n        ServerSocket serverSocket = new ServerSocket(7777);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new ServerThread(socket).start();\n        }\n\n    }</code></pre>\n<p>具体操作：在运行单个服务端代码之后，运行多个客户端代码即可实现同时接收多个客户端。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"205\" src=\"https://img-blog.csdnimg.cn/453ff129b7ad46b28f1c523a1d320d46.gif\" width=\"243\"/></p>\n<p></p>\n</blockquote>\n<h3 id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%C2%A0\">线程池优化 </h3>\n<blockquote>\n<p>通过前面的知识，我们了解到每一次都创建一个线程会影响系统的效率，因此需要通过线程池来控制线程的数量，若对线程池不理解的可以看这篇文章：</p>\n<p><a class=\"link-info\" href=\"http://t.csdn.cn/sORad\" title=\"Java中的多线程如何理解\">Java中的多线程如何理解</a></p>\n<p>相对之前需要将线程类更改一下，需要写一个实现Runnable接口的线程类。</p>\n<pre><code class=\"language-java\">public class ServerRunnable implements Runnable{\n    private Socket socket;\n\n    @Override\n    public void run() {\n        \n    }\n}</code></pre>\n<p>最后则是需要在服务端作出修改，定义一个线程池：</p>\n<pre><code class=\"language-java\">public class ServerData {\n    private static ExecutorService pool = new ThreadPoolExecutor(3,5,5, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(3),\n            Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n    public static void main(String[] args) throws  Exception{\n        ServerSocket serverSocket = new ServerSocket(7777);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            ServerRunnable target = new ServerRunnable(socket);\n            pool.execute(target);\n        }\n\n    }\n}</code></pre>\n<p></p>\n</blockquote>\n<p style=\"text-align:center;\"><span style=\"color:#38d8f0;\"><strong>创作不易，给个三连</strong></span> </p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"331\" src=\"..\\..\\static\\image\\87e44749101b4304a8acec5c12b37dd0.jpeg\" width=\"232\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-09 10:09:37", "summary": "目录引言网络通信的三要素地址操作类端口号了解协议通信通信实现同时接收多个客户端线程池优化引言经过前面的课程，我们已经大概地了解到多线程的知识了，不知道大家是否已经掌握了呢？如果已经掌握了的话，那么我们"}