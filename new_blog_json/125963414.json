{"blogid": "125963414", "writerAge": "码龄1年", "writerBlogNum": "39", "writerCollect": "551", "writerComment": "897", "writerFan": "1088", "writerGrade": "5级", "writerIntegral": "3127", "writerName": "披星戴月的贾维斯", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125963414.jpg", "writerRankTotal": "9166", "writerRankWeekly": "2907", "writerThumb": "865", "writerVisitNum": "29555", "blog_read_count": "2293", "blog_time": "于 2022-07-25 12:53:22 发布", "blog_title": "【C++】 C++入门和基础", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>                                                        什么是C++？</p>\n<p>        1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。因此：C++是基于C语言而产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"291\" src=\"..\\..\\static\\image\\731c6208c071494087e5cad34fb697f5.jpeg\" width=\"291\"/></p>\n<p style=\"text-align:center;\">登高莫问顶，途中耳目新！</p>\n<div>\n<h3>文章目录</h3>\n<ul><li><span style=\"color:#4da8ee;\">一、C++的发展历史和应用领域</span></li><li><span style=\"color:#4da8ee;\">二、C++的关键字</span></li><li><span style=\"color:#4da8ee;\">三、命名空间</span></li><li><span style=\"color:#4da8ee;\">四、C++的输入输出</span></li><li><span style=\"color:#4da8ee;\">五、缺省参数</span></li><li><span style=\"color:#4da8ee;\">六、函数重载</span></li><li><span style=\"color:#4da8ee;\">七、C++的引用</span></li><li><span style=\"color:#4da8ee;\">八、内联函数</span></li><li><a href=\"#_45\"><span style=\"color:#4da8ee;\">总结</span></a></li></ul>\n</div>\n<p></p>\n<hr/>\n<p><code>提示：以下是本篇文章正文内容，下面案例可供参考</code></p>\n<h1><a id=\"pandas_16\"></a>一、<span style=\"color:#0d0016;\">C++的发展历史和应用领域</span></h1>\n<h3>1.1、C++的起源</h3>\n<blockquote>\n<p>        C语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂的问题，规模较大的程序，需要高度 的抽象和建模时，C语言则不合适。为了解决软件危机， 20世纪80年代， 计算机界提出了OOP(object oriented programming：面向对象)思想，支持面向对象的程序设计语言应运而生。之后便有了本贾尼博士等人设计出了C++这门语言。</p>\n</blockquote>\n<h3>1.2、C++发展史及历代版本</h3>\n<blockquote>\n<p>        1979年，贝尔实验室的本贾尼等人试图分析unix内核的时候，试图将内核模块化，于是在C语言的基础上进行扩展，增加了类的机制，完成了一个可以运行的预处理程序，称之为C with classes。</p>\n</blockquote>\n<h3>1.3、C++的历史版本</h3>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:650px;\"><tbody><tr><td style=\"width:112px;\"><strong>        阶段</strong></td><td style=\"width:536px;\">                                                             <strong>   内容</strong></td></tr><tr><td style=\"width:112px;\">C with classes</td><td style=\"width:536px;\">类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符重载等</td></tr><tr><td style=\"width:112px;\">C++1.0</td><td style=\"width:536px;\">添加虚函数概念，函数和运算符重载，引用、常量等</td></tr><tr><td style=\"width:112px;\">C++2.0</td><td style=\"width:536px;\">更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静态成员以 及const成员函数</td></tr><tr><td style=\"width:112px;\">C++3.0</td><td style=\"width:536px;\">进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处理</td></tr><tr><td style=\"width:112px;\"><strong>C++98</strong></td><td style=\"width:536px;\"><strong>C++标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织(ISO)和美国标准化 协会认可，以模板方式重写C++标准库，引入了STL(标准模板库)</strong></td></tr><tr><td style=\"width:112px;\"><strong>···</strong></td><td style=\"width:536px;\"><strong>···之后介绍重要版本</strong></td></tr><tr><td style=\"width:112px;\"><strong>C++11</strong></td><td style=\"width:536px;\">增加了许多特性，使得C++更像一种新语言，比如：正则表达式、基于范围for循环、auto 关键字、新容器、列表初始化、标准线程库等</td></tr><tr><td style=\"width:112px;\">C++14</td><td style=\"width:536px;\">对C++11的扩展，主要是修复C++11中漏洞以及改进，比如：泛型的lambda表达式， auto的返回值类型推导，二进制字面常量等</td></tr></tbody></table>\n<p>        现阶段我们常用的还是C++98和C++11；</p>\n<h3>1.4、C++的应用领域</h3>\n<blockquote>\n<p> 1. 操作系统以及大型系统软件开发</p>\n<p>2. 服务器端开发</p>\n<p>3. 人工智能</p>\n<p>4. 网络工具</p>\n<p>5. 游戏开发</p>\n<p>6. 嵌入式领域</p>\n<p>7. 数字图像处理</p>\n<p>8. 分布式应用</p>\n<p>9. 移动设备</p>\n</blockquote>\n<h1><a id=\"_19\"></a>二、<span style=\"color:#0d0016;\">C++的关键字</span></h1>\n<h3>1.1、C++关键字</h3>\n<blockquote>\n<p>        (C++98) C++总计63个关键字，C语言32个关键字</p>\n</blockquote>\n<p><img alt=\"\" height=\"495\" src=\"..\\..\\static\\image\\c82885f096134268bcafba4e3e8759cf.png\" width=\"936\"/></p>\n<h1>三、 <span style=\"color:#0d0016;\">命名空间</span></h1>\n<h3>3.1、命名空间的概念</h3>\n<blockquote>\n<p>        在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作 用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。</p>\n</blockquote>\n<p>示例：如下，我们自己定义的rand和库里的rand函数产生命名冲突</p>\n<p><img alt=\"\" height=\"435\" src=\"..\\..\\static\\image\\824ccb5a69aa42f8991a916e46993f57.png\" width=\"452\"/></p>\n<h3> 3.2、命名空间的定义</h3>\n<blockquote>\n<p>        定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空间的成员。</p>\n<p>        注意点：</p>\n<p>       1、命名空间中的内容，既可以定义变量，也可以定义函数</p>\n<p>       2、命名空间还可以嵌套,同名的命名空间会被编译器合并到一起。</p>\n</blockquote>\n<h3>3.3、命名空间嵌套的示例</h3>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nnamespace jjx\n{\n       namespace xiang\n       {\n              struct ListNode\n              {\n                      int val;\n                      struct ListNode* next;\n              };\n       }\n}</code></pre>\n<p>加域访问限定符访问使用示例：</p>\n<pre><code>#include&lt;iostream&gt;//放出来，方便使用了，但是存在冲突风险\n//using namespace std; \n//std封C++库的命名空间//放部分常用的\nusing std::cout;\nusing std::endl;\nusing std::cin;\nint main()\n{       \n    cout &lt;&lt; \"hello world\" &lt;&lt; endl;\n    return 0;\n}</code></pre>\n<h3>注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</h3>\n<h3>3.4命名空间的使用</h3>\n<blockquote>\n<p>1、加命名空间名称及作用域限定符        ：：</p>\n<p>2、使用using将命名空间中成员引入        using N::b;</p>\n<p>3、使用using namespace 命名空间名称引入        using namespce N;</p>\n</blockquote>\n<h1><span style=\"color:#0d0016;\">四、C++的输入输出</span></h1>\n<h3>4.1、C++是如何实现输入输出的例子：</h3>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\nint main()\n{\n\tint a = 0;\n\tscanf(\"%d\", &amp;a);\n\tprintf(\"%d\\n\", a);\n\t// &gt;&gt; 流提取运算符,cin 是对象， &gt;&gt; 是运算符重载，并且自动识别输入类型\n\tcin &gt;&gt; a;\n\t// &lt;&lt; 流插入运算符\n\tcout &lt;&lt; a;\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>说明：</p>\n<p>1. 使用cout标准输出(控制台)和cin标准输入(键盘)时，必须包含&lt; iostream &gt;头文件以及std标准命名空间。</p>\n<p>注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用</p>\n<p>&lt;iostream&gt;+std的方式。</p>\n<p>2. 使用C++输入输出更方便，不需增加数据格式控制，比如：整形--%d，字符--%c</p>\n<p>cin中的&gt;&gt;是通过重载&gt;&gt;和模板实现自动识别类型。</p>\n</blockquote>\n<h1><span style=\"color:#0d0016;\">五、缺省参数</span></h1>\n<h3>5.1、 缺省参数概念</h3>\n<blockquote>\n<p>        缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该 默认值，否则使用指定的实参。</p>\n</blockquote>\n<p>类似于备胎的概念：</p>\n<p><img alt=\"\" height=\"232\" src=\"..\\..\\static\\image\\6e39f5400a9e4297a1ba6fe877ca0830.png\" width=\"368\"/></p>\n<pre><code>缺省参数/默认参数\nvoid Fun(int a = 0)\n{\n\tcout &lt;&lt; a &lt;&lt; endl;\n}\nint main()\n{\n\tFun();//没有传参数的时候，使用参数的默认值\n\tFun(1);//传参时，使用指定的实参\n\treturn 0;\n}</code></pre>\n<h3> 5.2、 缺省参数分类</h3>\n<p><strong>  ·全缺省参数：</strong></p>\n<pre><code>void Fun(int a = 10, int b = 20, int c = 30)\n{\n       cout &lt;&lt; \"a =\" &lt;&lt; a &lt;&lt; endl;\n       cout &lt;&lt; \"b =\" &lt;&lt; b &lt;&lt; endl;\n       cout &lt;&lt; \"c =\" &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;\n}\nint main()\n{\n       Fun();\n       Fun(1);\n       Fun(1, 2);\n       Fun(1, 2, 3);\n       return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"614\" src=\"..\\..\\static\\image\\5a42ae984816415a864e5829aeff97ea.png\" width=\"1116\"/></p>\n<p> ·<strong>半缺省参数：</strong></p>\n<blockquote>\n<p> 注：</p>\n<p>1. 半缺省参数必须从右往左依次来给出，不能间隔着给</p>\n<p>2. 缺省参数不能在函数声明和定义中同时出现</p>\n<p>3. 缺省值必须是常量或者全局变量</p>\n<p>4. C语言不支持（编译器不支持）</p>\n</blockquote>\n<pre><code>void Fun(int a , int b = 20, int c = 30)\n{\n       cout &lt;&lt; \"a =\" &lt;&lt; a &lt;&lt; endl;\n       cout &lt;&lt; \"b =\" &lt;&lt; b &lt;&lt; endl;\n       cout &lt;&lt; \"c =\" &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;\n}\nint main()\n{\n//     Fun();半缺省至少传一个参数\n       Fun(1);\n       Fun(1, 2);\n       Fun(1, 2, 3);\n       return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"315\" src=\"..\\..\\static\\image\\1d793f76e4c74926bc15bf2c43abc646.png\" width=\"1200\"/></p>\n<p><strong> 缺省值必须是常量或者全局变量</strong></p>\n<pre><code>void QueueInit(int n = 10);//申明给值\n#include\"Queue.h\"\nvoid QueueInit(int n)//定义给值不可以，必须在申明给值\n{\n       cout &lt;&lt; n &lt;&lt; endl;\n}\n#include\"Queue.h\"\nint main()\n{\n       QueueInit();//不给值默认是10，如果是定义给值，则头文件在这展开时\n       //编译器找不到其默认值，链接时找定义\n       QueueInit(20);\n       return 0;\n}</code></pre>\n<h2><a id=\"1_20\"></a></h2>\n<h1><span style=\"color:#0d0016;\">六、函数重载</span></h1>\n<blockquote>\n<p>C语言不支持重载，C++支持重载！</p>\n<p>C++是如何支持的？为什么C语言不能支持？</p>\n<p>这里我们一起探索一下问题的答案！</p>\n</blockquote>\n<h3>6.1、函数重载概念 :</h3>\n<blockquote>\n<p>函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的 形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题</p>\n</blockquote>\n<pre><code>//C语言不支持同名函数\n//CPP支持同名函数\n//要求：参数名相同————\n//参数不同：参数个数/类型/顺序\nint Add(int left, int right)\n{\n\treturn left + right;\n}\ndouble Add(double left, double right)\n{\n\treturn left + right;\n}\nvoid f(int i, double d)\n{\n\tcout &lt;&lt; \"void f(int i, double d)\" &lt;&lt; endl;\n}\nvoid f(double i, int d)\n{\n\tcout &lt;&lt; \"void f(double i, int d)\" &lt;&lt; endl;\n}\n//示例二\nvoid swap(int* p1, int* p2)\n{\n\tint x = *p1;\n\t*p1 = *p2;\n\t*p2 = x;\n}\nvoid swap(double* p1, double* p2)\n{\n\tdouble x = *p1;\n\t*p1 = *p2;\n\t*p2 = x;\n}\nint main()\n{\n\tcout &lt;&lt; Add(1, 2) &lt;&lt; endl;\n\tcout &lt;&lt; Add(1.1, 2.2) &lt;&lt; endl;\n\n\tf(1, 22.2);\n\tf(22.2, 1);\n\n\tint a = 0, b = 1;\n\tdouble c = 1.1, d = 2.2;\n\tswap(&amp;a, &amp;b);\n\tswap(&amp;c, &amp;d);\n\treturn 0;\n\n}</code></pre>\n<p></p>\n<p>为什么C++支持函数重载，而C语言不支持函数重载呢？为此我们不得不提到一个新的概念名字修饰(name Mangling)。</p>\n<h3>6.2、 名字修饰(name Mangling)</h3>\n<blockquote>\n<p>在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。</p>\n</blockquote>\n<p><img alt=\"\" height=\"290\" src=\"..\\..\\static\\image\\8039140f49f049618106539c3d57ea05.png\" width=\"418\"/></p>\n<blockquote>\n<p>         1. 实际我们的项目通常是由多个头文件和多个源文件构成，而通过我们C语言阶段学习的编译链接，我们 可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标文件中没有 Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？</p>\n<p>        2. 所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符 号表中找Add的地址，然后链接到一起。(如果同学们忘记了上面过程，咋们老师要带同学们回顾一下)</p>\n<p>        3. 那么链接时，面对Add函数，连接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。</p>\n</blockquote>\n<p>示例：由于Windows下vs的修饰规则过于复杂，而Linux下gcc的修饰规则简单易懂</p>\n<p><img alt=\"\" height=\"372\" src=\"..\\..\\static\\image\\cab38c3f32954ec0a45f006abe24ad10.png\" width=\"948\"/></p>\n<p> g++（C++）的函数名修饰</p>\n<p><img alt=\"\" height=\"441\" src=\"..\\..\\static\\image\\9c7c8a6f3b464bf2b9c282e7c842f14b.png\" width=\"1200\"/>gcc</p>\n<p> <img alt=\"\" height=\"67\" src=\"..\\..\\static\\image\\e740fb1030934c089ea3d1420b5dc5d4.png\" width=\"675\"/></p>\n<h3>6.3 、extern “C”</h3>\n<blockquote>\n<p> 在函数前加extern \"C\"，意思是告诉编译器， 将该函数按照C语言规则来编译.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"361\" src=\"..\\..\\static\\image\\918ef781eb774b858d69042aa2f6ff12.png\" width=\"1200\"/></p>\n<blockquote>\n<p>C++可以调用C的库，利用extern 是c++的语法</p>\n<p>C也可以调用C++的库，但是很麻烦，需要条件编译</p>\n<p>下面就是条件编译</p>\n</blockquote>\n<p><img alt=\"\" height=\"847\" src=\"..\\..\\static\\image\\de69c996027c4cfbbd2fcac0fcafa7a4.png\" width=\"1200\"/></p>\n<h3>小结：为啥C++支持函数重载</h3>\n<blockquote>\n<p>        了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区 分，只要参数不同，修饰出来的名字就不一样，就支持了重载。</p>\n</blockquote>\n<h1><span style=\"color:#0d0016;\">七、C++的引用</span></h1>\n<h3> 7.1 、引用概念</h3>\n<blockquote>\n<p>         引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</p>\n<p>        就是类似于有些和正品耐克鞋质量一样好的莆田鞋，他们之间的价格可能差了好几倍，但是他们的本质是一样的。</p>\n</blockquote>\n<p>代码+监视示例：</p>\n<p><img alt=\"\" height=\"766\" src=\"..\\..\\static\\image\\7962f41c67894932ab750cb8c73bdd48.png\" width=\"1200\"/></p>\n<h3> 7.2、 引用特性</h3>\n<blockquote>\n<p>1. 引用在定义时必须初始化</p>\n<p>2. 一个变量可以有多个引用 </p>\n<p>3. 引用一旦引用一个实体，再不能引用其他实体</p>\n</blockquote>\n<p><img alt=\"\" height=\"474\" src=\"..\\..\\static\\image\\b0dca552f92a42038e2404fc33c0f76a.png\" width=\"1200\"/></p>\n<p>赋值操作执行时，比如说是上面的e赋值给b，编译器会给e产生一个临时变量，再把临时变量赋值给b，临时变量具有常性权限缩小，所以+const </p>\n<p>比如：</p>\n<p>示例1：</p>\n<pre><code>int main()\n{\n\tint a = 10;\n\tint&amp; b = a;//不变\n\n\t//取别名原则：对原引用变量，权限只能缩小，不能放大\n\tconst int x = 20;//const是可读但不可改写（读写权限）\n\t//int&amp; y = x; //权限放大了\n\tconst int&amp; y = x;\n\tint c = 30;\n\tconst int&amp; d = c;//权限的缩小\n\n\treturn 0;\n}</code></pre>\n<p>示例2：</p>\n<pre><code>int main()\n{\n\tint a = 10;\n\tint&amp; b = a;\n\tconst int&amp; c = 20;//在传参过程取别名,才是它更多的作用\n\t//C++允许相似类型隐式转换，会发生截断或者是整形提升\n\tdouble d = 2.2;\n\n\tconst int&amp; e = d;//e是临时变量的地址，不是d的地址\n    retuen 0;\n}</code></pre>\n<h3>7.3、 使用场景</h3>\n<p>1、做参数</p>\n<pre><code>void Swap(int&amp; left, int&amp; right)\n{\n int temp = left;\n left = right;\n right = temp;\n}</code></pre>\n<p> 2. 做返回值</p>\n<pre><code>int&amp; Count()\n{\n static int n = 0；\n n++;\n // ...\n return n;\n}\n</code></pre>\n<p> 注意：</p>\n<blockquote>\n<p>        如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回。</p>\n</blockquote>\n<h3>7.4、传值、传引用效率比较</h3>\n<blockquote>\n<p>        以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是 传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p>\n</blockquote>\n<p>测试引用传参的效率、传值、指针传参效率的区别的函数</p>\n<pre><code>#include &lt;time.h&gt;\nstruct A{ int a[10000]; };\nvoid TestFunc1(A aa){}\nvoid TestFunc2(A&amp; aa){}\nvoid TestFunc3(A* paa){}\nvoid TestRefAndValue()\n{\n       A a;\n       // 以值作为函数参数\n       size_t begin1 = clock();\n       for (size_t i = 0; i &lt; 10000; ++i)\n              TestFunc1(a);\n       size_t end1 = clock();\n       // 以引用作为函数参数\n       size_t begin2 = clock();\n       for (size_t i = 0; i &lt; 10000; ++i)\n              TestFunc2(a);\n       size_t end2 = clock();\n       size_t begin3 = clock();\n       for (size_t i = 0; i &lt; 10000; ++i)\n              TestFunc3(&amp;a);\n       size_t end3 = clock();\n       // 分别计算两个函数运行结束后的时间\n       cout &lt;&lt; \"TestFunc1(A)-time:\" &lt;&lt; end1 - begin1 &lt;&lt; endl;\n       cout &lt;&lt; \"TestFunc2(A&amp;)-time:\" &lt;&lt; end2 - begin2 &lt;&lt; endl;\n       cout &lt;&lt; \"TestFunc3(A*)-time:\" &lt;&lt; end3 - begin3 &lt;&lt; endl;\n}</code></pre>\n<p>在我的电脑下测试结果</p>\n<p><img alt=\"\" height=\"286\" src=\"..\\..\\static\\image\\255bf4ff402a45d7994d5a69008d1373.png\" width=\"1200\"/></p>\n<p><strong>顺带提一下引用和指针的区别</strong>：<strong>底层的角度，指针和引用是一样的，因为引用底层就是指针</strong></p>\n<p><strong> 为啥传值会更慢？</strong></p>\n<p><strong>传值调用会产生一个临时变量，也就是图中的方块，所以效率更低</strong></p>\n<p><img alt=\"\" height=\"838\" src=\"..\\..\\static\\image\\11715a5c26e6427a91eda6de3c6e271d.png\" width=\"1200\"/></p>\n<h3> 7.5、引用和指针的不同点:</h3>\n<blockquote>\n<h3>1. 引用在定义时必须初始化，指针没有要求</h3>\n<h3>2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型 实体</h3>\n<h3>3. 没有NULL引用，但有NULL指针</h3>\n<h3>4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占 4个字节)</h3>\n<h3>5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</h3>\n<h3>6. 有多级指针，但是没有多级引用</h3>\n<h3>7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理</h3>\n<h3>8. 引用比指针使用起来相对更安全</h3>\n</blockquote>\n<h1><span style=\"color:#0d0016;\">八、内联函数</span></h1>\n<h3>8.1、内联函数的概念</h3>\n<blockquote>\n<p>        以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销， 内联函数提升程序运行的效率。</p>\n</blockquote>\n<h3>8.2、内联函数的特性</h3>\n<blockquote>\n<p>        1. inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜 使用作为内联函数。</p>\n<p>        2. inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等 等，编译器优化时会忽略掉内联。</p>\n<p>        3. inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会 找不到。</p>\n</blockquote>\n<p><strong>探究：为什么C++要写出内联函数？</strong></p>\n<p>用C语言实现一个加法的宏</p>\n<pre><code>#define ADD(x, y)((x) + (y))</code></pre>\n<p> <strong>宏的优缺点：</strong></p>\n<blockquote>\n<p>优点： 1.增强代码的复用性。 2.提高性能。 缺点： 1.不方便调试宏。（因为预编译阶段进行了替换） 2.导致代码可读性差，可维护性差，容易误用。 3.没有类型安全的检查 。</p>\n</blockquote>\n<p>使用内联写一个加法函数</p>\n<pre><code>inline int Add(int x, int y)\n{\n\tint z = x + y;\n\treturn z;\n}</code></pre>\n<p> <strong>内联函数的优点：</strong></p>\n<blockquote>\n<p>        inline: 1、debug版本下支持调试 2、不容易写错，就是普通函数的写法</p>\n<p>所以内联函数是替换宏的一个好办法。</p>\n</blockquote>\n<hr/>\n<p></p>\n<h1><a id=\"_45\"></a>总结</h1>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\4a40670acab9403a8b1c6789dba4590d.jpeg\"/></p>\n<p>        本文写了约7000字，比较详细地向大家介绍了什么是C++以及C++发展历史， 还向大家讲述了C++关键字、命名空间等知识，希望大家在看完后能够有所收获，感谢大家的支持！</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-25 12:53:22", "summary": "什么是？年，博士在语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与语言的渊源关系，命名为。因此：是基于语言而产生的，它既可以进行语言的过程化程序设计，又可以进行以抽象数"}