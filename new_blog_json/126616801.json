{"blogid": "126616801", "writerAge": "码龄1年", "writerBlogNum": "363", "writerCollect": "182", "writerComment": "16", "writerFan": "8118", "writerGrade": "5级", "writerIntegral": "3783", "writerName": "m0_67402588", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126616801.jpg", "writerRankTotal": "5266", "writerRankWeekly": "1043", "writerThumb": "39", "writerVisitNum": "175676", "blog_read_count": "377", "blog_time": "于 2022-08-31 09:07:43 发布", "blog_title": "计算机网络 --- 网络编程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_2\"></a>文章目录</h3>\n<ul><li><a href=\"#1__1\">1. 网络编程</a></li><li>\n<ul><li><a href=\"#11__2\">1.1 什么是网络编程</a></li><li><a href=\"#12__6\">1.2 发送端和接收端</a></li><li><a href=\"#13__11\">1.3 请求和响应</a></li><li><a href=\"#14__15\">1.4 客户端和服务端</a></li></ul> </li><li><a href=\"#2_Socket__24\">2. Socket 套接字</a></li><li>\n<ul><li><a href=\"#21__27\">2.1 分类</a></li><li>\n<ul><li><a href=\"#___TCP__28\">流套接字 : 使用传输层 TCP 协议</a></li><li><a href=\"#___UDP__37\">数据报接字 : 使用传输层 UDP 协议</a></li></ul> </li></ul> </li><li><a href=\"#3_UDP_47\">3. UDP数据报套接字编程</a></li><li>\n<ul><li><a href=\"#31_DatagramSocket_API_48\">3.1 DatagramSocket API</a></li><li>\n<ul><li><a href=\"#_50\">构造方法</a></li><li><a href=\"#_55\">方法</a></li></ul> </li><li><a href=\"#32_DatagramPacket_API_61\">3.2 DatagramPacket API</a></li><li>\n<ul><li><a href=\"#_63\">构造方法</a></li><li><a href=\"#_68\">方法</a></li></ul> </li><li><a href=\"#33__81\">3.3 基本使用方法:</a></li><li>\n<ul><li><a href=\"#_82\">服务端:</a></li><li><a href=\"#_90\">客户端</a></li></ul> </li><li><a href=\"#__98\">使用示例: 一发一收</a></li><li><a href=\"#__201\">使用示例: 翻译程序</a></li></ul> </li><li><a href=\"#4_%09TCP_312\">4. TCP流套接字编程</a></li><li>\n<ul><li><a href=\"#41_ServerSocket_API_313\">4.1 ServerSocket API</a></li><li>\n<ul><li><a href=\"#_314\">构造方法</a></li><li><a href=\"#_319\">方法</a></li></ul> </li><li><a href=\"#42_Socket_API_325\">4.2 Socket API</a></li><li>\n<ul><li><a href=\"#_326\">构造方法</a></li><li><a href=\"#_330\">方法</a></li></ul> </li><li><a href=\"#43__336\">4.3 基本使用方法</a></li><li>\n<ul><li><a href=\"#_337\">服务器</a></li><li><a href=\"#_350\">客户端</a></li></ul> </li><li><a href=\"#1__359\">使用示例1: 一发一收</a></li><li><a href=\"#2___495\">使用示例2: 多个客户端发 一个服务器收</a></li><li><a href=\"#3___580\">使用示例3: 多个客户端发 一个服务器收(优化版)</a></li><li><a href=\"#4__662\">使用示例4: 翻译程序</a></li></ul> </li><li><a href=\"#5__697\">5. 网络计算器(自定义协议)</a></li><li>\n<ul><li><a href=\"#_702\">服务端代码</a></li><li><a href=\"#_765\">客户端代码</a></li><li><a href=\"#_821\">运行结果:</a></li></ul> </li></ul>\n<h1><a id=\"1__44\"></a>1. 网络编程</h1>\n<h2><a id=\"11__47\"></a>1.1 什么是网络编程</h2>\n<p><strong>网络编程</strong> : 指网络上的主机,通过不同的进程,以编程的方式实现网络通信.<br/> 简单来说: 网络编程就是通过代码的方式来控制不同进程间能够进行数据交互.</p>\n<h2><a id=\"12__53\"></a>1.2 发送端和接收端</h2>\n<p><strong>发送端</strong>：数据的<strong>发送方进程</strong>，称为发送端。发送端主机即网络通信中的源主机。<br/> <strong>接收端</strong>：数据的<strong>接收方进程</strong>，称为接收端。接收端主机即网络通信中的目的主机。<br/> <strong>收发端</strong>：<strong>发送端和接收端两端</strong>，也简称为收发端</p>\n<h2><a id=\"13__60\"></a>1.3 请求和响应</h2>\n<p><strong>请求(Request)</strong> : 客户端给服务端发送的数据<br/> <strong>响应(Response)</strong> : 服务端给客户端返回的数据</p>\n<h2><a id=\"14__66\"></a>1.4 客户端和服务端</h2>\n<p><strong>客户端</strong> : 主动发送请求的一方<br/> <strong>服务端</strong> : 被动接受请求的一方</p>\n<p><strong>客户端和服务端的交互方式</strong>:</p>\n<blockquote>\n<ol><li>一问一答,客户端发送一个请求,服务端给一个响应</li><li>一问多答,客户端发送一个请求,服务端给多个响应</li><li>多问一答,客户端发送多个请求,服务端给一个响应</li><li>多问多答,客户端发送多个请求,服务器端多个响应</li></ol>\n</blockquote>\n<h1><a id=\"2_Socket__79\"></a>2. Socket 套接字</h1>\n<p>Socket套接字，是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。基于Socket套接字的网络程序开发就是网络编程.</p>\n<h2><a id=\"21__84\"></a>2.1 分类</h2>\n<h3><a id=\"___TCP__87\"></a>流套接字 : 使用传输层 TCP 协议</h3>\n<p>TCP协议,(Transmission Control Protocol)<br/> TCP的特点:</p>\n<ol><li>有连接</li><li>可靠传输</li><li>面向字节流</li><li>有接收缓冲区,也有发送缓冲区</li><li>大小不限</li><li>全双工</li></ol>\n<h3><a id=\"___UDP__99\"></a>数据报接字 : 使用传输层 UDP 协议</h3>\n<p>UDP协议,(User Datagram Protocl)<br/> UDP的特点:</p>\n<ol><li>无连接</li><li>不可靠传输</li><li>面向数据报</li><li>有接收缓冲区,无发送缓冲区</li><li>大小受限: 一次最多传输64k</li><li>全双工</li></ol>\n<h1><a id=\"3_UDP_111\"></a>3. UDP数据报套接字编程</h1>\n<h2><a id=\"31_DatagramSocket_API_114\"></a>3.1 DatagramSocket API</h2>\n<p><code>DatagramSocket</code> 是UDP Socket, 用于发送和接收UDP数据报.</p>\n<h3><a id=\"_119\"></a>构造方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>DatagramSocket()</p>\n<p>创建一个UDP数据报套接字的Socket，绑定到本机任意一个随机端口（一般用于客户端）</p>\n<p>DatagramSocket(int port)</p>\n<p>创建一个UDP数据报套接字的Socket，绑定到本机指定的端口（一般用于服务端）</p>\n<h3><a id=\"_133\"></a>方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>void receive(DatagramPacket p)</p>\n<p>从此套接字接收数据报（如果没有接收到数据报，该方法会阻塞等待）</p>\n<p>void send(DatagramPacket p)</p>\n<p>从此套接字发送数据报包（不会阻塞等待，直接发送）</p>\n<p>void close()</p>\n<p>关闭此数据报套接字</p>\n<h2><a id=\"32_DatagramPacket_API_151\"></a>3.2 DatagramPacket API</h2>\n<p><code>DatagramPacket</code>是UDP Socket发送和接收的数据报.</p>\n<h3><a id=\"_156\"></a>构造方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>DatagramPacket(byte[] buf, int length)</p>\n<p>构造一个DatagramPacket以用来接收数据报，接收的数据保存在字节数组（第一个参数buf）中，接收指定长度（第二个参数length）</p>\n<p>DatagramPacket(byte[] buf, int offset, int length,SocketAddress address)</p>\n<p>构造一个DatagramPacket以用来发送数据报，发送的数据为字节数组（第一个参数buf）中，从0到指定长度（第二个参数length）。address指定目的主机的IP和端口号</p>\n<h3><a id=\"_170\"></a>方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>InetAddress getAddress()</p>\n<p>从接收的数据报中，获取发送端主机IP地址；或从发送的数据报中，获取接收端主机IP地址</p>\n<p>int getPort()</p>\n<p>从接收的数据报中，获取发送端主机的端口号；或从发送的数据报中，获取接收端主机端口号</p>\n<p>byte[] getData()</p>\n<p>获取数据报中的数据</p>\n<blockquote>\n<p>注: 构造UDP发送的数据报时，需要传入 <code>SocketAddress</code> ，该对象可以使用 <code>InetSocketAddress</code> 来创建。<br/> <code>InetSocketAddress</code>的构造方法</p>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>InetSocketAddress(InetAddress addr, int port)</p>\n<p>创建一个Socket地址，包含IP地址和端口号</p>\n</blockquote>\n<h2><a id=\"33__199\"></a>3.3 基本使用方法:</h2>\n<h3><a id=\"_202\"></a>服务端:</h3>\n<blockquote>\n<ol><li>创建一个 DatagramSocket 对象,创建的同时关联一个端口号</li><li>读取请求 并解析</li><li>根据请求计算响应</li><li>把响应写回到客户端</li><li>打印日志</li></ol>\n</blockquote>\n<h3><a id=\"_210\"></a>客户端</h3>\n<blockquote>\n<ol><li>创建一个 DatagramSocket 对象,创建的同时指定服务器的ip和端口号</li><li>读取输入的数据</li><li>构造请求 并 发送给服务器</li><li>从服务器读取响应</li><li>把数据显示给用户</li></ol>\n</blockquote>\n<h2><a id=\"__218\"></a>使用示例: 一发一收</h2>\n<p>代码示例: UdpServer</p>\n<pre><code>import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class UdpEchoServer {\n    private DatagramSocket socket = null;\n\n    public UdpEchoServer(int port) throws SocketException {\n        this.socket = new DatagramSocket(port);\n    }\n\n    public void start() throws IOException {\n        System.out.println(\"服务器启动!\");\n        while (true) {\n            // 1. 读取请求 并 解析\n            DatagramPacket requestPacket = new DatagramPacket(new byte[4096],4096);\n            socket.receive(requestPacket);\n            String request = new String(requestPacket.getData(),0, requestPacket.getLength());\n            // 2. 根据请求计算响应\n            String response = process(request);\n            // 3. 把响应写回到客户端\n            DatagramPacket responsePacket = new DatagramPacket(response.getBytes(),response.getBytes().length,\n                                                                requestPacket.getSocketAddress());\n            socket.send(responsePacket);\n            // 4. 打印日志\n            String log = String.format(\"[%s:%d] req: %s; resp: %s\",requestPacket.getAddress().toString(),\n                                                                requestPacket.getPort(),request,response);\n            System.out.println(log);\n        }\n    }\n\n    private String process(String request) {\n        return request;\n    }\n\n    public static void main(String[] args) throws IOException {\n        UdpEchoServer server = new UdpEchoServer(9090);\n        server.start();\n    }\n}\n</code></pre>\n<p>代码示例: UdpClient</p>\n<pre><code>import java.io.IOException;\nimport java.net.*;\nimport java.util.Scanner;\n\npublic class UdpEchoClient {\n    private DatagramSocket socket = null;\n    private String serverIp;\n    private int serverPort;\n\n    public UdpEchoClient(String serverIp,int serverPort) throws SocketException {\n        this.serverIp = serverIp;\n        this.serverPort = serverPort;\n        this.socket = new DatagramSocket();\n    }\n\n    public void start() throws IOException {\n        while (true) {\n            // 1. 读取输入数据\n            System.out.print(\"-&gt;\");\n            Scanner sc = new Scanner(System.in);\n            String request = sc.next();\n            if(request.equals(\"exit\")){\n                System.out.println(\"exit\");\n                break;\n            }\n\n            // 2. 构造请求 并 发送给服务器\n            DatagramPacket requestPacket = new DatagramPacket(request.getBytes(),0,request.getBytes().length,\n                                                        InetAddress.getByName(serverIp),serverPort);\n            socket.send(requestPacket);\n\n            // 3. 读取服务器的响应 并 解析\n            DatagramPacket responsePacket = new DatagramPacket(new byte[4096],4096);\n            socket.receive(responsePacket);\n            String response = new String(responsePacket.getData(),0, responsePacket.getLength());\n\n            // 4.显式给用户\n            String log = String.format(\"req: %s; resp: %s\",request,response);\n            System.out.println(log);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        UdpEchoClient client = new UdpEchoClient(\"127.0.0.1\",9090);\n        client.start();\n    }\n}\n</code></pre>\n<p>运行结果:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9427c513c6b94efcb47786bfacf02d77.png\"/></p>\n<h2><a id=\"__322\"></a>使用示例: 翻译程序</h2>\n<p>客户端 输入需要查找的英文的请求<br/> 客户端 返回对应的英文翻译的响应<br/> 代码示例: UdpServer</p>\n<pre><code>package Translation;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class UdpTranslateServer {\n    private DatagramSocket socket = null;\n    private Map&lt;String,String&gt; map = new HashMap&lt;&gt;();\n\n    public UdpTranslateServer(int port) throws SocketException {\n        this.socket = new DatagramSocket(port);\n        map.put(\"translate\",\"翻译\");\n        map.put(\"china\",\"中国\");\n        map.put(\"hello\",\"你好\");\n    }\n\n    public void start() throws IOException {\n        System.out.println(\"服务器启动!\");\n        while (true) {\n            // 1. 读取请求并解析\n            DatagramPacket requestPacket = new DatagramPacket(new byte[4096],4096);\n            socket.receive(requestPacket);\n            String request = new String(requestPacket.getData(),0, requestPacket.getLength());\n            // 2. 根据请求计算响应\n            String response = process(request);\n            // 3. 把响应写回给客户端\n            DatagramPacket responsePacket = new DatagramPacket(response.getBytes(),response.getBytes().length,\n                                                                requestPacket.getSocketAddress());\n            socket.send(responsePacket);\n            // 4. 打印日志\n            String log = String.format(\"[%s:%d] req: %s; resp: %s\",requestPacket.getAddress().toString(),\n                                        requestPacket.getPort(),request,response);\n            System.out.println(log);\n        }\n    }\n\n    private String process(String request) {\n        return map.getOrDefault(request,\"查无此单词\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        UdpTranslateServer server = new UdpTranslateServer(9090);\n        server.start();\n    }\n}\n</code></pre>\n<p>代码示例: UDPClient</p>\n<pre><code>package Translation;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.Scanner;\n\npublic class UdpTranslateClient {\n    private DatagramSocket socket = null;\n    private String serverIp;\n    private int serverPort;\n\n    public UdpTranslateClient (String serverIp,int serverPort) throws SocketException {\n        this.serverIp = serverIp;\n        this.serverPort = serverPort;\n        socket = new DatagramSocket();\n    }\n\n    public void start() throws IOException {\n        while (true) {\n            System.out.print(\"-&gt;\");\n            Scanner sc = new Scanner(System.in);\n            // 1. 根据用户的输入 构造请求\n            String request = sc.next();\n            if(request.equals(\"exit\")){\n                System.out.println(\"exit!\");\n                return;\n            }\n            // 2. 发送请求给服务器\n            DatagramPacket requestPacket = new DatagramPacket(request.getBytes(),request.getBytes().length,\n                                                    InetAddress.getByName(serverIp),serverPort);\n            socket.send(requestPacket);\n            // 3. 读取服务器的响应\n            DatagramPacket responsePacket = new DatagramPacket(new byte[4096],4096);\n            socket.receive(responsePacket);\n            String response = new String(responsePacket.getData(),0, responsePacket.getLength());\n            System.out.println(response);\n            // 4. 解析响应并显式\n            String log = String.format(\"req: %s; resp: %s\",request,response);\n            System.out.println(log);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        UdpTranslateClient client = new UdpTranslateClient(\"127.0.0.1\",9090);\n        client.start();\n    }\n}\n</code></pre>\n<p>运行结果:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bad7e905b0d14c98a49b64221029d44f.png\"/></p>\n<h1><a id=\"4_TCP_436\"></a>4. TCP流套接字编程</h1>\n<h2><a id=\"41_ServerSocket_API_439\"></a>4.1 ServerSocket API</h2>\n<h3><a id=\"_442\"></a>构造方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>ServerSocket(int port)</p>\n<p>创建一个服务端流套接字Socket，并绑定到指定端口</p>\n<h3><a id=\"_452\"></a>方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>Socket accept()</p>\n<p>开始监听指定端口（创建时绑定的端口），有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待</p>\n<p>void close()</p>\n<p>关闭此套接字</p>\n<h2><a id=\"42_Socket_API_466\"></a>4.2 Socket API</h2>\n<h3><a id=\"_469\"></a>构造方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>Socket(String host, int port)</p>\n<p>创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接</p>\n<h3><a id=\"_479\"></a>方法</h3>\n<p>方法签名</p>\n<p>方法说明</p>\n<p>InetAddress getInetAddress()</p>\n<p>返回套接字所连接的地址</p>\n<p>InputStream getInputStream()</p>\n<p>返回此套接字的输入流</p>\n<p>OutputStream getOutputStream()</p>\n<p>返回此套接字的输出流</p>\n<h2><a id=\"43__497\"></a>4.3 基本使用方法</h2>\n<h3><a id=\"_500\"></a>服务器</h3>\n<blockquote>\n<ol><li>创建<code>ServerSocket</code> 关联上一个端口号</li><li>调用 <code>ServerSocket</code> 的 <code>accept</code> 方法 \n   <ul><li>目的是 建立连接</li><li>会返回一个 <code>Socket</code> 实例,称为 <code>clientSocket</code></li></ul> </li><li>使用 <code>clientSocket</code> 的 <code>getInputStream</code> 和 <code>getOutputStream</code> 得到字节流对象,进行读写和写入 \n   <ul><li>读取请求 并 解析</li><li>根据请求计算响应</li><li>把响应写回客户端</li><li>打印日志</li></ul> </li><li>当客户端断开连接之后,服务器就应该要及时的关闭 <code>clientSocket</code>. (防止出现文件泄露的情况)</li></ol>\n</blockquote>\n<h3><a id=\"_513\"></a>客户端</h3>\n<blockquote>\n<ol><li>创建一个 <code>Socket</code> 对象.创建的同时指定服务器的 <strong>ip</strong> 和<strong>端口</strong></li><li>客户端就可以通过 <code>Socket</code> 对象的 <code>getInputStream</code> 和 <code>getOutputStream</code> 来和服务器进行通信 \n   <ul><li>从键盘上,读取用户输入的内容</li><li>把这个读取的内容构造成请求,发送给服务端</li><li>从服务器读取响应并解析</li><li>把结构显示到界面上</li></ul> </li></ol>\n</blockquote>\n<h2><a id=\"1__522\"></a>使用示例1: 一发一收</h2>\n<p>这里的是普通版本 不能处理多个客户端</p>\n<p>代码示例: TCPClient</p>\n<pre><code>package TCP;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class TcpEchoClient {\n    private Socket socket = null;\n    private String serverIp;\n    private int serverPort;\n\n    public TcpEchoClient(String serverIp,int serverPort) throws IOException {\n        this.serverIp = serverIp;\n        this.serverPort = serverPort;\n        // 让 socket 创建的同时,就和服务器尝试建立连接\n        this.socket = new Socket(serverIp,serverPort);\n    }\n\n    public void start() {\n        Scanner scanner = new Scanner(System.in);\n        try(InputStream inputStream = socket.getInputStream();\n            OutputStream outputStream = socket.getOutputStream()){\n            while (true) {\n                // 1. 从键盘上,读取用户输入的内容\n                System.out.print(\"-&gt;\");\n                String request = scanner.next();\n                if (request.equals(\"exit\")){\n                    break;\n                }\n                // 2. 把这个读取的内容构造成请求,发送给服务器\n                PrintWriter printWriter = new PrintWriter(outputStream);\n                printWriter.println(request);\n                printWriter.flush();\n                // 3. 从服务器读取响应并解析\n                Scanner respScanner = new Scanner(inputStream);\n                String response = respScanner.next();\n                // 4. 把结果显示到界面上\n                String log = String.format(\"req: %s; resp: %s\",request,response);\n                System.out.println(log);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        TcpEchoClient client = new TcpEchoClient(\"127.0.0.1\",9090);\n        client.start();\n    }\n}\n</code></pre>\n<p>代码示例: TCPServer</p>\n<pre><code>package TCP;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class TcpEchoServer {\n    private ServerSocket listenSocket = null;\n\n    public TcpEchoServer(int port) throws IOException {\n        listenSocket = new ServerSocket(port);\n    }\n\n    public void start() throws IOException {\n        System.out.println(\"服务器启动!\");\n        while (true) {\n            // 1. 建立连接\n            Socket clientSocket = listenSocket.accept(); // 没有客户端来就会 阻塞等待\n            processConnection(clientSocket);\n        }\n    }\n\n    private void processConnection(Socket clientSocket) throws IOException {\n        String log = String.format(\"[%s:%d] 客户端上线!\",\n                clientSocket.getInetAddress().toString(),clientSocket.getPort());\n        System.out.println(log);\n        try(InputStream inputStream = clientSocket.getInputStream();\n            OutputStream outputStream = clientSocket.getOutputStream()) {\n            while (true) {\n                // 1. 读取请求并解析\n                Scanner scanner = new Scanner(inputStream);\n                if(!scanner.hasNext()){\n                    log = String.format(\"[%s:%d] 客户端下线\",clientSocket.getInetAddress().toString(),clientSocket.getPort());\n                    System.out.println(log);\n                    break;\n                }\n                String request = scanner.next();\n                // 2. 根据请求计算响应\n                String response = process(request);\n                // 3. 把响应写回给客户端\n                PrintWriter writer = new PrintWriter(outputStream);\n                writer.println(response);\n                writer.flush();\n\n                log = String.format(\"[%s:%d] req: %s; resp: %s\",clientSocket.getInetAddress().toString(),\n                        clientSocket.getPort(),request,response);\n                System.out.println(log);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            clientSocket.close();\n        }\n    }\n\n    private String process(String request) {\n        return request;\n    }\n\n    public static void main(String[] args) throws IOException {\n        TcpEchoServer server =  new TcpEchoServer(9090);\n        server.start();\n    }\n}\n</code></pre>\n<h2><a id=\"2___658\"></a>使用示例2: 多个客户端发 一个服务器收</h2>\n<p>多线程版本,能处理多个客户端,但是需要频繁的创建销毁线程<br/> 代码示例 TCPServer (客户端一致)</p>\n<pre><code>package TCPThread;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class TcpThreadEchoServer {\n    private ServerSocket listenSocket = null;\n\n    public TcpThreadEchoServer(int port) throws IOException {\n        listenSocket = new ServerSocket(port);\n    }\n\n    public void start() throws IOException {\n        System.out.println(\"服务器启动!\");\n        while (true) {\n            Socket clientSocket = listenSocket.accept();\n            // 创建一个线程来给这个客户提供服务\n            Thread t = new Thread(){\n                @Override\n                public void run() {\n                    try {\n                        processConnection(clientSocket);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            };\n            t.start();\n        }\n    }\n    public void processConnection(Socket clientSocket) throws IOException {\n        // 1. 打印日志\n        String log = String.format(\"[%s,%d] 客户端上线\",clientSocket.getInetAddress().toString(),clientSocket.getPort());\n        System.out.println(log);\n        try (InputStream inputStream = clientSocket.getInputStream();\n             OutputStream outputStream = clientSocket.getOutputStream()){\n            while (true) {\n                // 1. 读取 请求 并 解析\n                Scanner sc = new Scanner(inputStream);\n                if(!sc.hasNext()){\n                    log = String.format(\"[%s,%d] 客户端下线\",clientSocket.getInetAddress().toString(),clientSocket.getPort());\n                    System.out.println(log);\n                    break;\n                }\n                String request = sc.next();\n                // 2. 根据请求计算响应\n                String response = process(request);\n                // 3. 把响应写回客户端\n                PrintWriter printWriter = new PrintWriter(outputStream);\n                printWriter.println(response);\n                printWriter.flush();\n                // 4. 打印日志\n                log = String.format(\"[%s:%d] req: %s; resp: %s\",clientSocket.getInetAddress().toString(),\n                        clientSocket.getPort(),request,response);\n                System.out.println(log);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            clientSocket.close();\n        }\n    }\n\n    public String process(String request){\n        return request;\n    }\n\n    public static void main(String[] args) throws IOException {\n        TcpThreadEchoServer server = new TcpThreadEchoServer(9090);\n        server.start();\n    }\n}\n</code></pre>\n<h2><a id=\"3___744\"></a>使用示例3: 多个客户端发 一个服务器收(优化版)</h2>\n<p>由于多线程版的创建销毁线程的开销太大,这里使用线程池的方法.</p>\n<pre><code>package TCPThread;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TcpThreadPoolEchoServer {\n    private ServerSocket listenSocket = null;\n\n    public TcpThreadPoolEchoServer(int port) throws IOException {\n        listenSocket = new ServerSocket(port);\n    }\n\n    public void start() throws IOException {\n        System.out.println(\"服务器启动\");\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        while (true) {\n            Socket clientSocket = listenSocket.accept();\n            // 使用线程池 来 处理当前的 processConnextion\n            executorService.submit(()-&gt; {\n                try {\n                    processConnection(clientSocket);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n    public void processConnection(Socket clientSocket) throws IOException {\n        // 1. 打印日志\n        String log = String.format(\"[%s,%d] 客户端上线\",clientSocket.getInetAddress().toString(),clientSocket.getPort());\n        System.out.println(log);\n        try (InputStream inputStream = clientSocket.getInputStream();\n             OutputStream outputStream = clientSocket.getOutputStream()){\n            while (true) {\n                // 1. 读取 请求 并 解析\n                Scanner sc = new Scanner(inputStream);\n                if(!sc.hasNext()){\n                    log = String.format(\"[%s,%d] 客户端下线\",clientSocket.getInetAddress().toString(),clientSocket.getPort());\n                    System.out.println(log);\n                    break;\n                }\n                String request = sc.next();\n                // 2. 根据请求计算响应\n                String response = process(request);\n                // 3. 把响应写回客户端\n                PrintWriter printWriter = new PrintWriter(outputStream);\n                printWriter.println(response);\n                printWriter.flush();\n                // 4. 打印日志\n                log = String.format(\"[%s:%d] req: %s; resp: %s\",clientSocket.getInetAddress().toString(),\n                        clientSocket.getPort(),request,response);\n                System.out.println(log);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            clientSocket.close();\n        }\n    }\n\n    public String process(String request){\n        return request;\n    }\n\n\n}\n</code></pre>\n<p>运行结果<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bb94b3c6b761403e9e2ad000b294260d.png\"/></p>\n<h2><a id=\"4__828\"></a>使用示例4: 翻译程序</h2>\n<p>代码示例: TCPServer (这里的客户端还是跟前面一样)</p>\n<pre><code>package Translation;\n\nimport TCPThread.TcpThreadPoolEchoServer;\n\nimport java.io.IOException;\nimport java.util.HashMap;\n\n// echo 和 translate 两个服务器之间,大多都是类似的\npublic class TcpTranslateServer extends TcpThreadPoolEchoServer {\n    private HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();\n\n    public TcpTranslateServer(int port) throws IOException {\n        super(port);\n        map.put(\"china\",\"中国\");\n        map.put(\"hello\",\"你好\");\n        map.put(\"translate\",\"翻译\");\n    }\n\n    @Override\n    public String process(String request) {\n        return map.getOrDefault(request,\"查无此单词!\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        TcpTranslateServer server = new TcpTranslateServer(9090);\n        server.start();\n    }\n}\n</code></pre>\n<p>运行结果:<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\854ccdfe64d54138aeb82d1b36e21a0d.png\"/></p>\n<h1><a id=\"5__867\"></a>5. 网络计算器(自定义协议)</h1>\n<p>我们自定义协议<br/> 请求 : 字符串类型 操作数1;操作数2;运算符<br/> 响应 : 字符串类型 计算响应</p>\n<h2><a id=\"_874\"></a>服务端代码</h2>\n<pre><code>package Calculator;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class CalcServer {\n    private DatagramSocket socket = null;\n\n    public CalcServer(int port) throws SocketException {\n        socket = new DatagramSocket(port);\n    }\n\n    public void start() throws IOException {\n        System.out.println(\"服务器启动!\");\n        while (true){\n            // 1. 读取请求并解析\n            DatagramPacket requestPacket = new DatagramPacket(new byte[4096],4096);\n            socket.receive(requestPacket);\n            String request = new String(requestPacket.getData(),0,requestPacket.getLength());\n            // 2. 跟据请求计算响应\n            String response = process(request);\n            // 3. 把响应写回给客户端\n            DatagramPacket responsePacket = new DatagramPacket(response.getBytes(),response.getBytes().length,\n                                                            requestPacket.getSocketAddress());\n            socket.send(responsePacket);\n            // 4. 打印日志\n            String log = String.format(\"[%s:%d] req: %s; resp: %s\",requestPacket.getAddress().toString(),\n                                    requestPacket.getPort(),request,response);\n            System.out.println(log);\n        }\n    }\n\n    private String process(String request) {\n        // 分离\n        String[] str = request.split(\";\");\n        if(str.length != 3) return \"[请求的格式出错!]\";\n        int num1 = Integer.parseInt(str[0]);\n        int num2 = Integer.parseInt(str[1]);\n        if(str[2].equals(\"+\")){\n            return num1+num2+\"\";\n        }else if(str[2].equals(\"-\")){\n            return num1-num2+\"\";\n        }else if(str[2].equals(\"*\")){\n            return (num1 * num2)+\"\";\n        }else if(str[2].equals(\"/\")){\n            return (num1 / num2)+\"\";\n        }\n        return \"[请求格式出错!操作符不支持!]\";\n    }\n\n    public static void main(String[] args) throws IOException {\n        CalcServer server = new CalcServer(9090);\n        server.start();\n    }\n}\n</code></pre>\n<h2><a id=\"_938\"></a>客户端代码</h2>\n<pre><code>package Calculator;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.util.Scanner;\n\npublic class CalcClient {\n    private String serverIp;\n    private int serverPort;\n    private DatagramSocket socket = null;\n\n    public CalcClient(String serverIp,int serverPort) throws SocketException {\n        this.serverIp = serverIp;\n        this.serverPort = serverPort;\n        socket = new DatagramSocket();\n    }\n\n    public void start() throws IOException {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            // 1. 用户输入的请求\n            System.out.print(\"请输入操作数1: \");\n            int num1 = sc.nextInt();\n            System.out.print(\"请输入操作数2: \");\n            int num2 = sc.nextInt();\n            System.out.print(\"请输入运算符: \");\n            String operator = sc.next();\n            String request = num1+\";\"+num2+\";\"+operator;\n            // 2. 构造请求,并发给服务器\n            DatagramPacket requestPacket = new DatagramPacket(request.getBytes(),0,request.getBytes().length,\n                    InetAddress.getByName(serverIp),serverPort);\n            socket.send(requestPacket);\n            // 3. 从服务器中读取响应\n            DatagramPacket responsePacket = new DatagramPacket(new byte[4096],4096);\n            socket.receive(responsePacket);\n            String response = new String(responsePacket.getData(),0,responsePacket.getLength());\n\n            // 4. 将结果显示到屏幕上\n            String log = String.format(\"req: %s; resp: %s\",request,response);\n            System.out.println(log);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        CalcClient client = new CalcClient(\"127.0.0.1\",9090);\n        client.start();\n    }\n}\n</code></pre>\n<h2><a id=\"_995\"></a>运行结果:</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9473f332550f44ea98f123221fb17e7e.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-31 09:07:43", "summary": "文章目录网络编程什么是网络编程发送端和接收端请求和响应客户端和服务端套接字分类流套接字使用传输层协议数据报接字使用传输层协议数据报套接字编程构造方法方法构造方法方法基本使用方法服务端客户端使用示例一发"}