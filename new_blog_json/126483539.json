{"blogid": "126483539", "writerAge": "码龄3年", "writerBlogNum": "159", "writerCollect": "202", "writerComment": "47", "writerFan": "412", "writerGrade": "5级", "writerIntegral": "1842", "writerName": "天才小熊猫啊", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126483539.jpg", "writerRankTotal": "11387", "writerRankWeekly": "3180", "writerThumb": "57", "writerVisitNum": "52423", "blog_read_count": "3961", "blog_time": "于 2022-08-23 18:25:40 发布", "blog_title": "Spring和SpringBoot学习", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>Spring的两个核心特性</strong>：依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）</p>\n<h1>第1章 Spring之旅</h1>\n<p>Spring的使命：简化Java开发</p>\n<blockquote>\n<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p>\n<ol><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ol>\n</blockquote>\n<h2>一、依赖注入（dependency injection，DI）</h2>\n<p>目的是松耦合<strong> </strong>，关键是如何进行装配：</p>\n<p>方法1.XML的配置</p>\n<p><img alt=\"\" height=\"211\" src=\"..\\..\\static\\image\\1ea9c8dee6224daba445df92f003d192.png\" width=\"588\"/></p>\n<p><img alt=\"\" height=\"197\" src=\"..\\..\\static\\image\\c97ab0743eff4f7db0d892003f344d28.png\" width=\"589\"/></p>\n<p> </p>\n<p>方法2.基于Java的配置</p>\n<p><img alt=\"\" height=\"335\" src=\"..\\..\\static\\image\\07ab1e0962a14acba5a807a55960449d.png\" width=\"369\"/></p>\n<p> ----------------------------------------------------------------------------------------------------------------</p>\n<h2>二、面向切面编程（aspect-oriented programming，AOP）</h2>\n<p>允许把遍布应用各处的<strong>功能分离</strong>出来形成可重用的组件，确保POJO的简单性。</p>\n<p><img alt=\"\" height=\"251\" src=\"..\\..\\static\\image\\58f1291c3f4b4ab4913e72ab677f8b6f.png\" width=\"492\"/></p>\n<p> 在xml文件中配置  把Minstrel声明为一个Spring切面</p>\n<p><img alt=\"\" height=\"440\" src=\"..\\..\\static\\image\\194820fc66c147e380912c4f98d38181.png\" width=\"697\"/></p>\n<p> ---------------------------------------------------------------------------------------------------------------------------</p>\n<h2>三、使用模板消除样板式代码</h2>\n<p>Spring旨在通过模板封装来消除样板式代码。Spring的JdbcTemplate使得执行数据库操作时，避免传统的JDBC样板代码成为了可能。</p>\n<p>例：旧的，不适用模板的连接数据库查询操作</p>\n<p><img alt=\"\" height=\"481\" src=\"..\\..\\static\\image\\d87064bdc7344594a1a3e046d0280501.png\" width=\"416\"/></p>\n<p> 使用模板进行查询：</p>\n<p><img alt=\"\" height=\"211\" src=\"..\\..\\static\\image\\aad364af642b4e669ad3515bd0b15f38.png\" width=\"459\"/></p>\n<p> -------------------------------------------------------------------------------------------------------------------------------</p>\n<h2>四、Bean</h2>\n<p>对象生存于Spring容器（container）中。</p>\n<blockquote>\n<p>Spring自带了多个容器实现，可以归为两种不同的类型：</p>\n<ol><li>bean工厂（由org.springframework. beans.factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。</li><li>应用上下文（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。（更高级，更常使用）</li></ol>\n</blockquote>\n<h3>1.使用应用上下文</h3>\n<ul><li>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。</li><li>AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。</li><li>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li><li>FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li><li>XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。</li></ul>\n<p>例如，如下代码展示了如何加载一个FileSystemXmlApplicationContext：</p>\n<p><img alt=\"\" height=\"45\" src=\"..\\..\\static\\image\\1766913e701b4ac0874faa8b0906bba9.png\" width=\"421\"/></p>\n<p> 类似地，可以使用ClassPathXmlApplicationContext从应用的类路径下加载应用上下文：</p>\n<p><img alt=\"\" height=\"54\" src=\"..\\..\\static\\image\\f461a316353d4258bf92c2b35cca3fae.png\" width=\"395\"/></p>\n<p>如果想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext</p>\n<p> <img alt=\"\" height=\"38\" src=\"..\\..\\static\\image\\4415d40bc5f64aa5ba0c867f727690a4.png\" width=\"447\"/></p>\n<p>在这里没有指定加载Spring应用上下文所需的XML文件，AnnotationConfig-ApplicationContext通过一个配置类加载bean。</p>\n<p><br/><strong>应用上下文准备就绪之后，就可以调用上下文的getBean()方法从Spring容器中获取bean。</strong></p>\n<h3>2.bean的生命周期</h3>\n<p><img alt=\"\" height=\"427\" src=\"..\\..\\static\\image\\3e460abde4234d668b3e490c24e78493.png\" width=\"778\"/></p>\n<p> </p>\n<blockquote>\n<p>1．Spring对bean进行实例化；<br/> 2．Spring将值和bean的引用注入到bean对应的属性中；<br/> 3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；<br/> 4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；<br/> 5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；<br/> 6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法；<br/> 7．如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；<br/> 8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法；<br/> 9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；<br/> 10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>\n</blockquote>\n<p>---------------------------------------------------------------------------------------------------------------------------------</p>\n<h2>五、Spring模块</h2>\n<p><img alt=\"\" height=\"490\" src=\"..\\..\\static\\image\\4da212dab2e34cffa02af2492a2a6fc0.png\" width=\"576\"/></p>\n<h1> 第2章 装配Bean</h1>\n<p><strong>装配：</strong>创建应用对象之间协作关系的行为通常称为<strong>装配（wiring）</strong>，这也是依赖注入（DI）的本质</p>\n<blockquote>\n<p><strong>配置Spring容器最常见的三种方法：</strong></p>\n<ol><li>在XML中进行显式配置。</li><li>在Java中进行显式配置。</li><li>隐式的bean发现机制和自动装配</li></ol>\n<p>建议是尽可能地使用自动配置的机制。显式配置越少越好</p>\n</blockquote>\n<h2>一、自动化装配bean</h2>\n<p>Spring从两个角度来实现自动化装配：</p>\n<ol><li>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</li><li>自动装配（autowiring）：Spring自动满足bean之间的依赖。</li></ol>\n<p>例：带有<strong>@Component注解</strong>的CompactDisc实现类</p>\n<p><img alt=\"\" height=\"388\" src=\"..\\..\\static\\image\\c03ca2cf9a264042918a559e62f5e0de.png\" width=\"613\"/></p>\n<p> <strong>组件扫描</strong>默认是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有<strong>@Component注解</strong>的类，并为其创建bean：</p>\n<p><img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\44fcb9cad3d743ebb97c9748bb0b14cf.png\" width=\"356\"/></p>\n<p> 另外，还可以通过XML来启用组件扫描，使用Spring context命名空间的&lt;context:component-scan&gt;元素：（不常用）</p>\n<p><img alt=\"\" height=\"372\" src=\"..\\..\\static\\image\\a1938d9f791f41c38d1cd5822ecfc6f1.png\" width=\"903\"/></p>\n<h2></h2>\n<h2>1.为组件扫描的bean命名  @Component</h2>\n<p><strong>默认是将类名的第一个字母变为小写</strong>。如果想为这个bean设置不同的ID，你所要做的就是将期望的ID作为值传递给@Component注解。比如说，如果想将这个bean标识为lonelyHeartsClub，那么你需要将SgtPeppers类的@Component注解配置为如下所示：</p>\n<p><img alt=\"\" height=\"94\" src=\"..\\..\\static\\image\\4fbc936c2e094bbc8ed4e4fc3eccfdc0.png\" width=\"471\"/></p>\n<p> 另外，还有一种：@Named  （不常用）</p>\n<p> <img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\4f9b76dfcd07426cbe3d0e883cef4b4b.png\" width=\"529\"/></p>\n<h2>2.设置组件扫描的基础包 @ComponentScan</h2>\n<p>有一个原因会促使我们明确地设置基础包，那就是我们<strong>想要将配置类放在单独的包中，使其与其他的应用代码区分开来</strong>。如果是这样的话，那默认的基础包就不能满足要求了。<br/> 为了指定不同的基础包，所需要做的就是在@ComponentScan的value属性中指明包的名称：</p>\n<p><img alt=\"\" height=\"96\" src=\"..\\..\\static\\image\\ada42e13a73c48acb4375b45b8e708e6.png\" width=\"364\"/></p>\n<p> 如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：</p>\n<p><img alt=\"\" height=\"78\" src=\"..\\..\\static\\image\\6d4df307f267456891b5681fd4f0c999.png\" width=\"437\"/></p>\n<p>如果想设置多个基础包，只需要将basePackages属性设置为要扫描包的一个数组即可：</p>\n<p> <img alt=\"\" height=\"83\" src=\"..\\..\\static\\image\\fa99778f20ae4d7e9f466eb1071360dd.png\" width=\"516\"/></p>\n<p> 除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：</p>\n<p><img alt=\"\" height=\"79\" src=\"..\\..\\static\\image\\2bc5b1c887ac453aa9f84a2737f44fae.png\" width=\"630\"/></p>\n<h2>3.通过为bean添加注解实现自动装配 <strong>@Autowired</strong></h2>\n<p>自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，可借助Spring的<strong>@Autowired</strong>注解。</p>\n<p> eg:通过自动装配，将一个CompactDisc注入到CDPlayer之中</p>\n<p><img alt=\"\" height=\"390\" src=\"..\\..\\static\\image\\38208e37ea9f493a871235eb1db403c1.png\" width=\"388\"/></p>\n<p> 注意：@Autowired是Spring特有的注解。如果不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，那么可以考虑将其替换为@Inject：</p>\n<p><img alt=\"\" height=\"331\" src=\"..\\..\\static\\image\\a596e53fa114442cb03b1f0cd65b706a.png\" width=\"365\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-23 18:25:40", "summary": "的两个核心特性：依赖注入，和面向切面编程，第章之旅的使命：简化开发为了降低开发的复杂性，采取了以下种关键策略：基于的轻量级和最小侵入性编程；通过依赖注入和面向接口实现松耦合；基于切面和惯例进行声明式编"}