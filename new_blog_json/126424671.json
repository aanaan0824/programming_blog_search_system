{"blogid": "126424671", "writerAge": "码龄1年", "writerBlogNum": "172", "writerCollect": "3742", "writerComment": "4219", "writerFan": "13596", "writerGrade": "7级", "writerIntegral": "14533", "writerName": "未见花闻", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126424671.jpg", "writerRankTotal": "693", "writerRankWeekly": "144", "writerThumb": "5562", "writerVisitNum": "200926", "blog_read_count": "357", "blog_time": "于 2022-09-06 21:09:03 发布", "blog_title": "猿创征文|Spring系列框架之面向切面编程AOP", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><font color=\"#87CEFA\" size=\"4\">⭐️<strong>前面的话</strong>⭐️</font></p>\n<p>本篇文章将介绍一种特别重要的思想，AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。</p>\n<p>AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</p>\n<blockquote>\n<p>📒博客主页：<a href=\"https://weijianhuawen.blog.csdn.net/\">未见花闻的博客主页</a><br/> 🎉欢迎关注🔎点赞👍收藏⭐️留言📝<br/> 📌本文由<strong>未见花闻</strong>原创，<strong>CSDN</strong>首发！<br/> 📆首发时间：🌴2022年9月6日🌴<br/> ✉️坚持和努力一定能换来诗与远方！<br/> 💭推荐书籍：📚《Spring实战》，📚《SpringBoot实战》<br/> 💬参考在线编程网站：🌐<a href=\"https://www.nowcoder.com/\">牛客网</a>🌐<a href=\"https://leetcode-cn.com/\">力扣</a><br/> <a href=\"https://gitee.com/weijianhuawen\">博主的码云gitee，平常博主写的程序代码都在里面。</a><br/> <a href=\"https://github.com/weijianhuawen\">博主的github，平常博主写的程序代码都在里面。</a><br/> 🍭<font color=\"orange\">作者水平很有限，如果发现错误，一定要及时告知作者哦！感谢感谢！</font></p>\n</blockquote>\n<hr/>\n<p></p>\n<div class=\"toc\">\n<h3>📌导航小助手📌</h3>\n<ul><li><a href=\"#1AOP_29\">1.面向切面编程AOP</a></li><li><ul><li><a href=\"#11AOP_31\">1.1什么是AOP？</a></li><li><a href=\"#12AOP_38\">1.2AOP的作用</a></li><li><a href=\"#13AOP_59\">1.3AOP的核心概念</a></li></ul>\n</li><li><a href=\"#2Spring_AOP_112\">2.Spring AOP</a></li><li><ul><li><a href=\"#21Spring_AOP_116\">2.1Spring AOP的使用</a></li><li><a href=\"#22AspectJ_205\">2.2AspectJ表达式基本语法</a></li><li><a href=\"#23_255\">2.3抛出异常后通知与环绕通知</a></li><li><a href=\"#24Spring_AOP_341\">2.4Spring AOP的实现原理</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<p><img alt=\"封面区\" src=\"..\\..\\static\\image\\e2d6c5364ba441539d46b5a9d94ec1f8.png\"/></p>\n<hr/>\n<h1><a id=\"1AOP_29\"></a>1.面向切面编程AOP</h1>\n<h2><a id=\"11AOP_31\"></a>1.1什么是AOP？</h2>\n<p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP技术恰恰相反，它利用一种称为\"横切\"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\"Aspect\"，即切面。所谓\"切面\"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>\n<p>使用\"横切\"技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>\n<h2><a id=\"12AOP_38\"></a>1.2AOP的作用</h2>\n<p>想象一个场景，我们在做后台系统时，除了登录和注册等几个功能不需要做用户登录验证之外，其他几乎所有页面都需要先验证用户登录的状态，那这个时候我们要怎么处理呢？</p>\n<p>如果不使用AOP，我们就需要在每一个Controller层都写一遍验证用户是否已经登录的程序，如果你实现的功能有很多，并且这些功能都需要进行登录验证，那你就需要编写大量重复的代码，非常的麻烦，尽管你可以将登录验证实现的逻辑封装在一个方法中，但是你要在很多地方调用这个方法，还是很麻烦。</p>\n<p>如果使用AOP，在进入核心的业务代码之前会做统一的一个拦截，去验证用户是否登录，这样就很方便，仅需做一个拦截工作，再将验证代码一执行即可。</p>\n<p>除了登录验证功能之外，还有很多功能也可以使用AOP，比如：</p>\n<ul><li>统一日志记录与持久化。</li><li>统一方法执行时间统计。</li><li>统一数据返回格式。</li><li>统一处理程序中的异常。</li><li>统一事务的开启与提交。</li></ul>\n<p>也就是说使用 AOP 可以扩充多个对象的某个能力，所以 AOP 可以说是 OOP （Object Oriented Programming，面向对象编程）的补充和完善。</p>\n<h2><a id=\"13AOP_59\"></a>1.3AOP的核心概念</h2>\n<p>1、横切关注点</p>\n<p>想要对哪些方法或类进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。</p>\n<p>2、切面（aspect）</p>\n<p>类是对物体特征的抽象，切面就是对横切关注点的抽象，你可以认为切面相当于横切关注点。</p>\n<p>3、连接点（joinpoint）</p>\n<p>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。</p>\n<p>4、切入点（pointcut）</p>\n<p>提供一组规则，根据规则匹配合法的连接点，满足规则的连接点可以理解为切点，然后可以为切点提供具体的处理（通知）。</p>\n<p>5、通知（advice）</p>\n<p>所谓通知指的就是指拦截到连接点之后要执行的代码，或者说在切点出所需要执行的代码是什么。</p>\n<p>通知包含前置通知，后置通知，返回之后通知，抛异常后通知与环绕通知五类。</p>\n<p>在Spring切面类中，可以在方法上使用以下注解，会设置方法为通知方法，在满足条件后会调用对应满足条件的方法：</p>\n<ul><li>前置通知使用@Before∶通知方法会在目标方法调用之前执行。</li><li>后置通知使用@After∶通知方法会在目标方法返回或者抛出异常后调用。</li><li>返回之后通知使用@AfterReturning∶ 通知方法会在目标方法返回后调用。</li><li>抛异常后通知使用@AfterThrowing∶ 通知方法会在目标方法抛出异常后调用。</li><li>环绕通知使用@Around∶通知包裹了被通知的方法，在被通知的方法通知之前和调用之后执行自定义的行为。</li></ul>\n<p><img alt=\"1\" src=\"..\\..\\static\\image\\546e7887b0d043be830123c595b96cf2.png\"/></p>\n<p>6、目标对象</p>\n<p>代理的目标对象。</p>\n<p>7、织入（weaving）</p>\n<p>织入（weaving）即代理的生成时机，<br/> 织入是把切面应用到目标对象并创建新的代理对象的过程，切面在指定的连接点被织入到目标对象中。<br/> 在目标对象的生命周期里有多个点可以进行织入∶</p>\n<ul><li>编译期∶切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载器∶切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving.LTW）就支持以这种方式织入切面。</li><li>运行期∶切面在应用运行的某一时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态创建一个代理对象。SpringAOP就是以这种方式织入切面的。</li></ul>\n<p>8、引入（introduction）</p>\n<p>在不修改代码的前提下，引入可以在<strong>运行期</strong>为类动态地添加一些方法或字段。</p>\n<h1><a id=\"2Spring_AOP_112\"></a>2.Spring AOP</h1>\n<p>面向切面编程是一种思想，Spring AOP是AOP的一种实现。</p>\n<h2><a id=\"21Spring_AOP_116\"></a>2.1Spring AOP的使用</h2>\n<p>SpringAOP使用的主要步骤为：<br/> 第一步，在SpringBoot项目中添加AOP相关的依赖。<br/> 第二步，定义切面。<br/> 第三步，定义切点。<br/> 第四步，实现通知。</p>\n<p>第一步，在SpringBoot项目中添加AOP相关的依赖，就是在Maven的配置文件中添加aop的依赖。<br/> 由于使用Edit Starters插件访问官方的源是找不到有关SpringBoot的AOP依赖，这是因为在idea中，上面只列举了一些常用的依赖，不是所有依赖都在上面，如果找不到我们就去Maven中央仓库中去寻找。</p>\n<p>搜索一下，找到这个依赖，然后进去复制依赖信息拷贝到Maven的配置文件中就行。<br/> <img alt=\"2\" src=\"..\\..\\static\\image\\7c27c02799ae4acbb9021ee6ecb3d6d4.png\"/></p>\n<pre><code class=\"prism language-xml\">\t\t<span class=\"token comment\">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --&gt;</span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n\t\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n\t\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-boot-starter-aop<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre>\n<p>第二步，定义切面，在spring boot项目中其实就是加上@Aspect和@Component注解的一个类，这个类就表示一个切面。</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">//设置切面，这个类就是一个切面</span>\n<span class=\"token annotation punctuation\">@Aspect</span>\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserAspect</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>第三步，在切面里面定义切点，在Spring中其实本质上就是一个方法，具体说是使用 @Pointcut注解修饰的一个方法，该方法不需要配置任何信息。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">//定义切点,设置拦截规则</span>\n    <span class=\"token annotation punctuation\">@Pointcut</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"execution(* com.example.demo.controller.UserController.* (..))\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">pointcut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>其中@Pointcut注解中的参数是一个AspectJ表达式，它的作用就是设置哪些返回值类型哪些类的哪些方法需要拦截可以指定到参数列表。<br/> <img alt=\"4\" src=\"..\\..\\static\\image\\f60466549ac848cfb88496d22cad2946.png\"/></p>\n<p>第四步，实现通知，本质上就是实现一个方法，只不过在方法上加上不同通知类型的注解即可，如前置通知加上@Before注解，注解的参数为切点方法名。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">//前置通知</span>\n    <span class=\"token annotation punctuation\">@Before</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointcut()\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doBefore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行Before通知\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>同理，后置通知也是如此，就是将注解改为@After：</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">//后置通知</span>\n    <span class=\"token annotation punctuation\">@After</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointcut()\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doAfter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行After通知\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>以及目标方法返回后通知@AfterReturning：</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">//返回之后通知</span>\n    <span class=\"token annotation punctuation\">@AfterReturning</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointcut()\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doAfterRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行AfterRunning通知\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们来验证一下上述设置切面拦截代码的正确性，我们写一个在拦截范围的类以及方法：<br/> <img alt=\"5\" src=\"..\\..\\static\\image\\e17d8915abb5406c8368d8d84d9fe7dc.png\"/><br/> 启动程序，我们访问页面<code>http://127.0.0.1:8080/user/hello</code>，看看控制台的输出：<br/> <img alt=\"6\" src=\"..\\..\\static\\image\\a13974dab2ca4fd195a9cb6e7b94902a.png\"/><br/> 通过运行结果我们也能够看出上面三种通知方式执行的时机以及先后顺序。</p>\n<h2><a id=\"22AspectJ_205\"></a>2.2AspectJ表达式基本语法</h2>\n<p><code>*</code>∶匹配任意字符，只匹配一个元素（包，类，或方法，方法参数）<br/> <code>..</code>∶匹配任意字符，可以匹配多个元素，在表示类时，必须和<code>*</code>联合使用，匹配参数列表时表示匹配所有类型的参数列表。<br/> <code>+</code> ∶ 表示按照类型匹配指定类及其所有子类，必须跟在类名后面，如com.Car+，表示拦截Cat类以及继承Cat类的所有子类。</p>\n<p>切点表达式由切点函数组成，其中<code>execution()</code>是最常用的切点函数，用来匹配方法，语法为∶</p>\n<pre><code class=\"prism language-java\"><span class=\"token function\">execution</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>权限修饰符<span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>返回类型<span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>包<span class=\"token punctuation\">.</span>类<span class=\"token punctuation\">.</span>方法<span class=\"token punctuation\">(</span>参数<span class=\"token punctuation\">)</span><span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span>异常<span class=\"token operator\">&gt;</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>其中权限修饰符与异常项一般省略，返回类型方法以及参数不可省略，其他项可以省略。</p>\n<p>权限修饰符：</p>\n<ul><li>填写权限修饰符，就只会匹配相应修饰符修饰的方法。</li><li>省略，权限不作为限制，所有权限修饰符的方法都会匹配。</li></ul>\n<p>返回类型，必须参数，不可省略：</p>\n<ul><li>填写具体返回类型，就匹配相应返回类型的方法。</li><li><code>*</code>表示匹配所有返回值类型的方法。</li></ul>\n<p>包，类，一般情况下要有，但是可以省略：</p>\n<ul><li>填写包和类，就只匹配你所规定的包或类。</li><li><code>*</code>表示匹配某目录下所有的包或者类。</li><li><code>+</code>作用在类上，匹配该类以及继承该类的所有子类。</li></ul>\n<p>方法，表示需要匹配方法的名字，参数表示需要匹配参数列表的类型，不可省略：</p>\n<ul><li>指定方法名和参数列表，就只匹配你所限定的方法。</li><li><code>*</code>可以作用在方法匹配字段上，表示匹配某类中所有的方法。</li><li><code>..</code>可以作用在参数列表上，对参数列表类型不做限制。</li></ul>\n<p>异常，可以匹配抛出指定异常的方法，该参数一般省略。</p>\n<p>下面来看几个例子，我们来了解一下AspectJ表达式：</p>\n<p><code>execution(* com.cad.demo.User.*(..))</code>∶匹配User类里的所有方法。<br/> <code>execution(* com.cad.demo.User+.*(..))</code>∶匹配User类及其子类中的所有方法。<br/> <code>execution（* com.cad.*.*(..))</code>∶匹配com.cad包下的所有类的所有方法。<br/> <code>execution(* com.cad..*.*(..))</code>∶匹配 com.cad 包下、子孙包下所有类的所有方法。<br/> <code>execution(* addUser(String，int))</code>∶ 匹配 addUser 方法，且第一个参数类型是 String，第二个参数类型是int。</p>\n<h2><a id=\"23_255\"></a>2.3抛出异常后通知与环绕通知</h2>\n<p>前面我们已经介绍了前置通知，后者通知以及返回后通知的演示，下面我们继续介绍剩下两种通知，在上面已经实现代码基础上，我们继续添加通知来进行演示。</p>\n<p>抛出异常后通知，其实和前面三种通知的用法可以说一模一样，只不过只有当程序出现异常的时候才会执行该通知，写法如下，就是在切面类中实现一个方法，使用@AfterThrowing注解修饰即可：</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">//抛异常后通知</span>\n    <span class=\"token annotation punctuation\">@AfterThrowing</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointcut()\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doAfterThrowing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"抛出异常后，执行AfterThrowing通知\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>然后我们再在目标方法中构造一个异常，异常随便写一个异常就行，如算术异常：<br/> <img alt=\"8\" src=\"..\\..\\static\\image\\5f66e04026f34c07b582ea1a4347b7dd.png\"/></p>\n<p>我们访问页面<code>http://127.0.0.1:8080/user/world</code>来看一看控制台输出：<br/> <img alt=\"9\" src=\"..\\..\\static\\image\\022a9661833c4193a86e1ca4c0564904.png\"/><br/> 由于出现了异常，方法被强制终止了，没有返回，所以没有返回后通知。</p>\n<p>最后还剩下一个环绕通知，环绕通知你可以理解为将前置通知和后置通知一体化了，环绕通知最常见的用法之一就是计算目标方法执行的时间是多少，使用其他通知无法做到，如果使用前置加后置通知进行对目标方法的计时，在单线程下没有问题，但是在多线程下有问题，当一个线程正在计时时，另外一个线程调用了前置通知，此时计时开始的时间就被刷新了，那自然计算得到的目标方法执行时间也就不准确了，而环绕通知使一体化的，不存在类似这种线程安全的问题。</p>\n<p>环绕通知相比于其他的三种通知的使用方法较为复杂，首先实现环绕通知的方法必须含有<code>ProceedingJoinPoint</code>类的参数和使用 @Around注解修饰，表示连接点的执行进度，方法体里面第一步是执行环绕方法的前置通知，然后通过该类对象获取目标方法执行进度并调用，再执行环绕通知的后置通知，最后并返回该目标方法进度。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token annotation punctuation\">@Around</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointcut()\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">doAround</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ProceedingJoinPoint</span> joinPoint<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Object</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行环绕通知前置通知\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">//根据连接点进度获取目标方法，并执行目标方法</span>\n            res <span class=\"token operator\">=</span> joinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"环绕通知后置通知\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们访问页面<code>http://127.0.0.1:8080/user/hello</code>来看一看控制台输出：<br/> <img alt=\"10\" src=\"..\\..\\static\\image\\2045078ccfcb468eacfc0ac4e7b244d9.png\"/></p>\n<p>我们可以基于环绕通知实现对目标方法的计时功能：<br/> 实现思路很简单，就是在执行目标方法之前开始计时，执行完目标方法之后结束计时，差值就是方法运行的时间。</p>\n<p>计时的方式可以使用时间戳或者spring中的<code>StopWatch</code>类，后者更准确一点，其实都差不多。</p>\n<p>我们可以通过传入的<code>joinPoint</code>对象获取目标方法的方法名以及具体所在类和包，<code>joinPoint.getSignature().toString()</code>就能生成目标方法的全部有关名字的信息，我们可以加上一个方法的信息来表示哪一个方法执行的时间。</p>\n<pre><code class=\"prism language-java\">    <span class=\"token annotation punctuation\">@Around</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointcut()\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">doTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ProceedingJoinPoint</span> joinPoint<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//System.out.println(\"环绕通知前置通知\");</span>\n        <span class=\"token class-name\">String</span> methodName <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">long</span> end <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">StopWatch</span> stopWatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StopWatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">//执行拦截方法</span>\n            start <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            stopWatch<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            methodName <span class=\"token operator\">=</span> joinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">getSignature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            result <span class=\"token operator\">=</span> joinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            throwable<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{<!-- --></span>\n            end <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            stopWatch<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">//System.out.println(\"环绕通知后置通知\");</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>methodName <span class=\"token operator\">+</span> <span class=\"token string\">\"执行了\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>methodName <span class=\"token operator\">+</span> <span class=\"token string\">\"执行了\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>stopWatch<span class=\"token punctuation\">.</span><span class=\"token function\">getTotalTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>运行结果：<br/> <img alt=\"11\" src=\"..\\..\\static\\image\\e31301d9b2f0417f9d0526a4cc1d097a.png\"/></p>\n<h2><a id=\"24Spring_AOP_341\"></a>2.4Spring AOP的实现原理</h2>\n<p>Spring AOP是构建在动态代理基础上，因此 Spring对AOP的支持局限于方法级别的拦截。</p>\n<p>Spring AOP支持JDKProxy 和CGLIBProxy方式实现动态代理。默认情况下，对于非<code>final</code>修饰的类，SpringAOP会基于CGLIBProxy生成代理类，CGLIBProxy生成代理类的原理就是继承目标类，被关键字<code>final</code>修饰的类，由于不能被继承，所以会基于DKProxy生成代理类。<br/> <img alt=\"13\" src=\"..\\..\\static\\image\\294ca1b568fc4139b2daaebae41456bb.png\"/><br/> SpringAOP的本质就是生成一个目标对象的代理类，当前端传来请求时，不会将请求直接交给目标对象，而是首先代理类进行处理，如果满足一定的条件，才会将请求交给目标对象。</p>\n<p>如果处理请求前需要登录验证，那么代理类会去验证用户账户是否登录，如果用户登录了才会将请求交给目标对象并执行核心业务代码，否则代理类之间返回响应让用户先登录。</p>\n<hr/>\n<p><strong>参考 &amp; 资料</strong></p>\n<p><a href=\"https://www.cnblogs.com/xrq730/p/4919025.html\">Spring3:AOP</a></p>\n<center>\n<font color=\"red\">觉得文章写得不错的老铁们，点赞评论关注走一波！谢谢啦！ </font>\n</center>\n<p><img alt=\"1-99\" height=\"180\" src=\"..\\..\\static\\image\\70dbcef1173945aa9b467ea939621bba.png\" width=\"160\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-06 21:09:03", "summary": "前面的话本篇文章将介绍一种特别重要的思想，，即面向切面编程，可以说是，面向对象编程的补充和完善。把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切"}