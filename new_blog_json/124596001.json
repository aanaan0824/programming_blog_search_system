{"blogid": "124596001", "writerAge": "码龄2年", "writerBlogNum": "5", "writerCollect": "23", "writerComment": "0", "writerFan": "4", "writerGrade": "1级", "writerIntegral": "73", "writerName": "逍遥@明", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124596001.jpg", "writerRankTotal": "146281", "writerRankWeekly": "1007924", "writerThumb": "2", "writerVisitNum": "4252", "blog_read_count": "3277", "blog_time": "已于 2022-05-07 23:16:08 修改", "blog_title": "封装、继承、多态 详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>面向对象的三个基本特征：封装、继承、多态</h2>\n<h3>1.封装</h3>\n<p>（1）封装是实现面向对象的第一步，封装就是将数据或函数等集合在一个单元中（类）。被封装的对象通常被称为抽象数据类型。</p>\n<p>（2）类具有封装性，类能够把数据和算法（操作数据的函数）组合在一起，构成一个不可分割的整体；</p>\n<p>（3）类具有<strong>信息隐藏</strong>的能力，它能够有效地把类的内部数据（即<strong>私有和受保护成员</strong>）隐藏起来，使外部函数只能通过类的<strong>公有成员</strong>才能访问类的内部数据，并且控制访问级别。</p>\n<p>封装使类成为一个具有内部数据的<strong>自我隐藏能力、功能独立</strong>的软件模块</p>\n<p>1）<strong>封装的意义</strong></p>\n<p>a)保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序<strong>直接访问或修改</strong>，只能通过提供的<strong>公共接口访问</strong>（数据封装）</p>\n<p>b)<strong>隐藏方法（实现）细节</strong>，只要接口不变，内容的修改不会影响到外部的调用者（方法封装）</p>\n<p>c)封装可以使对象拥有<strong>完整的属性和方法</strong>（类中的函数）</p>\n<p>d)外部不能直接访问对象的属性，只能通过该属性对应的公有方法访问</p>\n<p>2）<strong>对象封装原则</strong></p>\n<p>a）内聚：指一个<strong>模块（类）内部</strong>各个部分之间的关联程度</p>\n<p>b) 耦合：指各个<strong>模块（类）之间</strong>的关联程度</p>\n<p>总结：用类实现封装，用封装来实现<strong>高内聚，低耦合</strong></p>\n<p><strong>访问级别</strong>：<strong>public,private,protected</strong></p>\n<p><strong>public:</strong></p>\n<p>通常使用public设置<strong>公有成员</strong>，让本类之外的其他函数能够通过公有成员，按照类允许的方法访问类的私有数据，就能起到数据保护的目的。</p>\n<p><strong>private:</strong></p>\n<p>通常使用private把不想让其他程序访问的数据或者函数设置成<strong>私有成员</strong>，可禁止其他程序对这些数据随意修改。</p>\n<p><strong>protected:</strong></p>\n<p>通过protected设置<strong>保护成员</strong>，在封装中没什么用，通常在继承中使用。</p>\n<h3>2.继承</h3>\n<p>继承主要实现重用代码，节省开发时间</p>\n<p>举例：当封装两个类后，第一个类中有一个非常复杂的成员函数，第二个类也需要同样的一个成员函数。如果第二个类重新编写成员函数，会增加开发时间，并且可能会因为一些疏忽，造成BUG，因此出现了继承这种方式，第二个类继承第一个类，那么，第二个类就可直接复用第一个类中的所有成员。（<strong>私有成员，可继承，不可访问）</strong></p>\n<p>1）继承是在已有类的基础上创建新类的过程，已有类称为<strong>基类（父类</strong>），新类称为<strong>派生类（子类）</strong>；</p>\n<p>2）派生类<strong>继承</strong>了<strong>基类</strong>的<strong>功能</strong>，且能够对基类的功能进行扩充、修改或重定义。</p>\n<p>3）派生类复用了基类的<strong>全体数据</strong>和<strong>成员函数</strong>，具有从基类复制而来的<strong>数据成员</strong>和<strong>成员函数</strong>（基类私有成员可被继承，但是无法被访问）</p>\n<p>4）派生类可以从一个或多个基类派生；通过一个基类派生的继承称为<strong>单继承</strong>，多个基类派生的继承为<strong>多重继承</strong></p>\n<p>5）一个类可以作为多个类的基类，一个派生类也可以作为另一个类的基类。</p>\n<p><strong>6）继承可传递</strong> 如果C从B中派生，B又从A中派生，那么C不仅继承了B中声明的成员，同样也继承了A中的成员。Object类作为所有类的基类。</p>\n<p>7）基类中的<strong>构造函数、析构函数、友元函数、静态数据成员、静态成员函数</strong>都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。</p>\n<p>8）基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期</p>\n<p>9）派生类如果定义了与继承而来的成员同名的新成员，就可以覆盖已继承的成员。但这并不因为这派生类删除了这些成员，只是不能再访问这些成员。</p>\n<p><span style=\"color:#fe2c24;\"><strong>继承方式:</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>语法:</strong></span></p>\n<p>class 派生类名：[继承方式]  基类名{<!-- --><br/>         派生类成员声明与定义<br/> }；</p>\n<p><strong>公有继承（public）</strong>：基类成员的访问权限在派生类中保持不变</p>\n<p><strong>私有继承（private）</strong>：基类的private成员在派生类仍是private成员，但是基类的public和protected成员在派生类中会变成private成员。</p>\n<p><strong>保护继承（protected）</strong>：</p>\n<p>a)具有protected权限的数据，在该类没有被继承的情况下，protected访问属性与private完全相同。</p>\n<p>b)在继承结构中，基类的protected成员不能被派生类的外部函数访问，但是可被派生类直接访问</p>\n<p></p>\n<p><img alt=\"\" height=\"361\" src=\"..\\..\\static\\image\\1014161a7bf04a559f04d6e00ce082ac.png\" width=\"1200\"/></p>\n<p></p>\n<h3>多态</h3>\n<p>多态:  指不同对象接收到同一消息时会产生不同的行为（一个接口，多种方法）</p>\n<p>简单来说,就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能</p>\n<p><strong>多态的三个条件：</strong></p>\n<p>a） 继承的存在(继承是多态的基础,没有继承就没有多态).<br/> b） 子类重写父类的方法(多态下调用子类重写的方法).<br/> c） 父类引用变量指向子类对象(子类到父类的类型转换).</p>\n<p>多态性主要体现在：向不同的对象发送同一个消息，不同对象接收到消息时产生不同的行为，即每个对象以自己的方式响应同样的消息。</p>\n<p>多态可以按照实现的时机分为编译时多态，运行时多态</p>\n<p><strong>编译时多态：(静态联编) </strong>指程序在编译时就可确定的多态性，通过<strong>重载</strong>机制实现</p>\n<p><strong>运行时多态：(动态联编) </strong>指必须在运行中才可确定的多态性，通过<strong>继承</strong>和<strong>虚函数</strong></p>\n<p><strong>实现多态方式：</strong></p>\n<p>a)接口多态性</p>\n<p>b)继承多态性</p>\n<p>c)通过抽象类实现的多态性</p>\n<p><strong>多态的好处：</strong></p>\n<p>a)可替换性：多态对已存在的代码具有可替换性</p>\n<p>b)可扩充性：多态对代码具有可扩充性。新增子类不会影响已存在类的各种性质。</p>\n<p>c)灵活性：多态在程序中体现了灵活多样的操作，提高了使用效率（重载函数，重写函数）</p>\n<p>d)简化性：多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要</p>\n<p></p>\n<p style=\"text-align:center;\"></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-07 23:16:08", "summary": "面向对象的三个基本特征：封装、继承、多态封装封装是实现面向对象的第一步，封装就是将数据或函数等集合在一个单元中类。被封装的对象通常被称为抽象数据类型。类具有封装性，类能够把数据和算法操作数据的函数组合"}