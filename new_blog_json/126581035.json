{"blogid": "126581035", "writerAge": "码龄1年", "writerBlogNum": "419", "writerCollect": "1108", "writerComment": "43", "writerFan": "12594", "writerGrade": "5级", "writerIntegral": "4471", "writerName": "心动的偏执", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126581035.jpg", "writerRankTotal": "3711", "writerRankWeekly": "359", "writerThumb": "140", "writerVisitNum": "231301", "blog_read_count": "511", "blog_time": "于 2022-08-29 11:10:46 发布", "blog_title": "Docker（精简版）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_2\"></a>文章目录</h3>\n<ul><li><a href=\"#Docker_6\">Docker初级篇</a></li><li>\n<ul><li>\n<ul><li><a href=\"#1_docker_12\">1. docker是什么</a></li><li><a href=\"#2_docker_34\">2. docker思想</a></li><li><a href=\"#3__77\">3. 安装</a></li><li><a href=\"#4__173\">4. 镜像</a></li><li><a href=\"#4__221\">4. 镜像进阶</a></li><li>\n<ul><li><a href=\"#docker_tag_223\">docker **tag指令**</a></li></ul> </li><li><a href=\"#5__247\">5. 容器</a></li><li><a href=\"#5__342\">5. 容器进阶</a></li><li><a href=\"#6__534\">6. 仓库</a></li><li>\n<ul><li><a href=\"#1__544\">1. 阿里云</a></li><li><a href=\"#2__590\">2. 私有云</a></li><li><a href=\"#3__682\">3. 官方仓库</a></li><li><a href=\"#4__724\">4. 三种方式对比</a></li></ul> </li><li><a href=\"#7__778\">7. 网络</a></li><li>\n<ul><li><a href=\"#_899\">开始自定义网络：</a></li><li>\n<ul><li><a href=\"#_916\">查看我们自定义的网络配置：</a></li><li><a href=\"#_920\">使用我们自定义的网络配置</a></li></ul> </li><li><a href=\"#docker_1005\">docker网络参数说明</a></li></ul> </li><li><a href=\"#8__1025\">8. 数据卷</a></li><li><a href=\"#9__1127\">9. 常用操作</a></li><li><a href=\"#8__1195\">8. 日常实践</a></li><li>\n<ul><li><a href=\"#1_systemd_1197\">1. 启用systemd服务</a></li><li><a href=\"#2__1214\">2. 查看系统自启动程序</a></li><li><a href=\"#3_Docker_1222\">3. Docker安装宝塔</a></li><li><a href=\"#4_ubuntuvim_1264\">4. ubuntu**安装vim**</a></li><li><a href=\"#5vivim_1283\">5.**vi**与vim</a></li><li><a href=\"#6_Docker_1293\">6. Docker可视化</a></li><li><a href=\"#7__1310\">7. 正确启动容器的流程</a></li><li><a href=\"#8_root_1320\">8. 授予容器root权限</a></li><li><a href=\"#9__1330\">9. 容器的宿主机目录</a></li><li><a href=\"#10_mysql_1342\">10. 安装mysql</a></li><li><a href=\"#11_SpringBoot_1401\">11. 运行SpringBoot程序</a></li></ul> </li><li><a href=\"#12__1427\">12. 取消默认截断</a></li></ul> </li></ul> </li><li><a href=\"#Docker_1437\">Docker高级篇</a></li><li>\n<ul><li><a href=\"#Dockerfile_1439\">Dockerfile</a></li><li>\n<ul><li>\n<ul><li><a href=\"#1__1447\">1. 指令诠释</a></li><li><a href=\"#2_centos7_1474\">2. 官方centos7</a></li><li><a href=\"#3_build__1495\">3. build 构建镜像</a></li><li><a href=\"#4_history_1525\">4. history指令</a></li><li><a href=\"#5__1540\">5. 定制化感悟</a></li></ul> </li></ul> </li><li><a href=\"#compose_1613\">compose</a></li><li><a href=\"#swarm_1661\">swarm</a></li></ul> </li><li><a href=\"#0__1671\">0. 帮助文档</a></li></ul>\n<hr/>\n<h1><a id=\"Docker_51\"></a>Docker初级篇</h1>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\95564acbe40322a2d008f2ed30efcb03.jpeg\"/></p>\n<h3><a id=\"1_docker_56\"></a>1. docker是什么</h3>\n<ol><li> <p>docker就是一个容器，可以理解为更进一步的虚拟机。</p> </li><li> <p>理念：Build, Ship and Run Any App, Anywhere.</p> </li><li> <p>网址</p>\n<ul><li> <p>官网：https://docker.com/</p> </li><li> <p>仓库：https://hub.docker.com/</p> </li></ul> </li><li> <p>基本架构</p> <p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p> <p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p> </li></ol>\n<hr/>\n<h3><a id=\"2_docker_77\"></a>2. docker思想</h3>\n<ol><li> <p>docker就是一头载着许多集装箱的<strong>鲸鱼</strong></p> </li><li> <p>一次镜像，到处运行。</p> </li><li> <p><strong>隔离性</strong>：容器之间相互独立，互不相通。</p> </li><li> <p><strong>容器就是进程。</strong></p> </li><li> <p>开发+运维 = Devops，开发运维一体化。</p> </li><li> <p>Docker实质上就是在现有系统内制造了一个隔离的文件环境，它的执行效率几乎等同于宿主机。</p> </li><li> <p>docker为什么这么快**？**</p> <p>因为它是一个极小型的Linux系统，只加载需要的文件，而且容器内的应用直接运行在宿主机的内核上，容器没有自己的内核、也未虚拟我们的硬件系统。</p> </li><li> <p><strong>Docker三件套</strong></p>\n<ol><li>镜像 image：一个镜像可以创建多个容器。</li><li>容器 container：创建一个最小化的Linux环境，需要的就加载、不需要的就不加载。 \n    <ol><li>仓库 repository：存放各种镜像。</li></ol> </li></ol> </li><li> <p>镜像是分层的，里面是UnionFS联合文件系统。</p> </li><li> <p>镜像层 与 容器层</p> </li></ol>\n<ul><li> <p>镜像层为只读，不可修改</p> </li><li> <p>容器层在镜像层之上，可以读写。</p> <img alt=\"image-20220324193021492\" src=\"/Users/thinkstu/Library/Application%20Support/typora-user-images/image-20220324193021492.png\"/> </li></ul>\n<ol start=\"11\"><li>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器</li></ol>\n<hr/>\n<h3><a id=\"3__115\"></a>3. 安装</h3>\n<blockquote>\n<p>安装方式：1. 官方 2. 我的安装</p>\n<p>前提条件：原先未安装Docker</p>\n</blockquote>\n<ol><li> <p>卸载旧版本</p> <p>sudo yum remove docker<br/> docker-client<br/> docker-client-latest<br/> docker-common<br/> docker-latest<br/> docker-latest-logrotate<br/> docker-logrotate<br/> docker-engine</p> </li><li> <p><strong>官方安装</strong></p> </li></ol>\n<blockquote>\n<p>我采用了yum的阿里源（并非第5条提到的docker阿里源），官方的慢。</p>\n</blockquote>\n<pre><code>#安装gcc\nyum -y install gcc\nyum -y install gcc-c++\n\n# 安装 yum-utils 包，并设置稳定存储库，目的：提供安装docker的库\nyum install -y yum-utils\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \n#正式安装docker\nyum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n<ol start=\"2\"><li><strong>我的安装</strong></li></ol>\n<blockquote>\n<p>更胜一筹？</p>\n<p>学了这么久，我竟然现在才知道踩了一个大坑。yum list中排名第一docker版本是2017年的<strong>1.13.1</strong>版本。而最新的是2022年的<strong>20.10.14</strong>版本，我一直用着2017年版的，怪不得好多命令都没有！</p>\n</blockquote>\n<pre><code>#错误的做法，2017版本：yum -y install docker\n\n#正确的做法：安装最新版，ce社区版本\nyum -y install docker-ce.x86_64\n</code></pre>\n<ol start=\"3\"><li> <p>配置docker</p> <p>systemctl start docker<br/> systemctl enable docker</p> </li><li> <p>测试（可省略）</p> <p>docker run hello-world</p> </li><li> <p>docker配置阿里云加速</p>\n<ul><li> <p>说明：每位开发者一个账号</p> </li><li> <p>登录阿里云 — 控制台 — 容器服务 — 容器镜像服务 — 地址</p> </li><li> <p>服务器配置</p> <p>sudo mkdir -p /etc/docker<br/> sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’<br/> {<!-- --><br/> “registry-mirrors”: [“https://xx2ypep6.mirror.aliyuncs.com”]<br/> }<br/> EOF<br/> sudo systemctl daemon-reload<br/> sudo systemctl restart docker</p> </li></ul> </li></ol>\n<hr/>\n<h3><a id=\"4__194\"></a>4. 镜像</h3>\n<ol><li> <p>概念：</p>\n<ul><li>类型：模板</li><li>要求：镜像名强制小写</li></ul> </li><li> <p>显示镜像</p> <p>docker images<br/> #或<br/> docker image ls</p> </li></ol>\n<blockquote>\n<p>镜像名 标签（版本） 镜像id（主键） 创建日期 大小</p>\n</blockquote>\n<p><img alt=\"image-20220324095112805\" src=\"..\\..\\static\\image\\7cba65ab490fb6af2a7e1b51b22e0fbe.png\"/></p>\n<ol start=\"3\"><li> <p>搜索镜像</p> <h2><a id=\"docker_search_xxx%0Adocker_search_limit_5_xxx%09%09limit25head_212\"></a>docker search xxx<br/> docker search --limit 5 xxx #limit默认是25条，不过这里我更愿意用head</h2> <p>docker search xxx |head -6 #但注意：上面这里包括了一行头标题，故-6</p> </li><li> <p>拉取镜像</p> <p>docker pull 镜像文件名 #默认最新版</p> <p>docker pull centos #latest<br/> docker pull centos:7.9.2009</p> </li></ol>\n<blockquote>\n<p>镜像版本信息请到官网查看</p>\n</blockquote>\n<ol start=\"5\"><li> <p>删除镜像</p> <p>docker rmi -f xxx<br/> docker rmi -f $(docker images -qa) #递归删除全部镜像</p> </li></ol>\n<hr/>\n<h3><a id=\"4__236\"></a>4. 镜像进阶</h3>\n<ol><li> <h4><a id=\"docker_tag_238\"></a>docker <strong>tag指令</strong></h4>\n<blockquote>\n<p>docker tag指令标记本地镜像，将其归入某一仓库。</p>\n</blockquote> <pre><code>[root@vm-4-3-centos ~]$ docker tag --help\n\nUsage:  docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]\n\nCreate a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n</code></pre>\n<ul><li>其指令是针对镜像，而commit、export是针对容器，完全不一样。</li><li>作用：推送至远程仓库时需要tag给镜像备注。</li><li>docker tag只起标记作用，相当于给镜像重命名、制作硬链接。</li></ul> <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rN3LTluK-1651739265985)(https://tva1.sinaimg.cn/large/e6c9d24egy1h0xfv6e7o4j213g04gmy5.jpg)]</p> </li></ol>\n<hr/>\n<h3><a id=\"5__258\"></a>5. 容器</h3>\n<blockquote>\n<p>容器只要创建了就会存在，即使退出关闭后也可以再次重启。</p>\n<p>可使用<code>docker system df</code>查看现容器情况</p>\n</blockquote>\n<ol><li> <p>run容器</p> <p>docker run -it -p 80:8080 --name=“myUbuntu” ubuntu bash</p> </li></ol>\n<blockquote>\n<p>参数说明</p>\n</blockquote>\n<pre><code>-p 8080:80\t\t#小p，指定端口映射：宿主机端口:容器内端口\n-P\t\t\t\t\t\t#大P，系统随机分配端口,Publish all exposed ports to random ports\n\n-d\t\t\t\t\t\t#后台运行\n-i\t\t\t\t\t\t#interaction,交互模式\n-t\t\t\t\t\t\t#tty,为容器重新分配一个伪输入终端\n-it\t\t\t\t\t\t#常组合使用\n\n--name\t\t\t\t\t\t\t#指定容器名称\n--privileged=true\t\t#赋予容器root权限，默认不赋予\n</code></pre>\n<ol start=\"2\"><li> <p>退出容器</p>\n<ol><li> <p>ctrl + p + q ：<strong>终端后台挂起</strong></p> </li><li> <p>exit：<strong>终端销毁</strong>（销毁单终端容器，容器暂停）</p> </li></ol> </li><li> <p>再次进入容器</p>\n<ol><li>exec：新建终端并进入</li><li>attach：返回后台终端</li></ol> </li><li> <p>rm 删除容器</p> <pre><code>docker rm -f xxx\n#或者\ndocker stop xxx\ndocker rm xxx\n</code></pre>\n<blockquote>\n<p>删除所有容器</p>\n</blockquote> <pre><code>docker rm -f $(docker ps -aq)\n</code></pre> </li><li> <p>ps指令</p>\n<ul><li> <p>说明：<strong>单纯的ps指令只能查看当前活着的进程（并非所有）。</strong></p> </li><li> <p>使用：</p> <p>docker ps</p> <p>-a #所有，all<br/> -l #最近，latest<br/> -n 5 #指定数量，number<br/> -q #静默模式，queue 只显示容器编号</p> </li></ul> <p><img alt=\"image-20220324121813823\" src=\"..\\..\\static\\image\\c9baae4298f53cce283aa53dcd8df7af.png\"/></p> </li><li> <p><strong>启动、重启、停止、强制停止</strong>容器</p>\n<blockquote>\n<p>容器要处于开启状态才能使用</p>\n</blockquote> <pre><code>docker start xxx\ndocker restart xxx\ndocker stop xxx\t\t#停止\ndocker kill xxx\t\t#强制停止\n</code></pre> </li><li> <p>清除所有处于<strong>终止状态</strong>的容器</p> <pre><code>$ docker container prune\n</code></pre> </li><li> <p>容器的名称是唯一的，不可重复。</p> </li></ol>\n<hr/>\n<h3><a id=\"5__343\"></a>5. 容器进阶</h3>\n<ol><li> <p>容器自动退出机制</p>\n<ul><li> <p>Docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），<strong>就会自动退出。</strong></p> </li><li> <p>例子</p> <p>run -d ubuntu之后却发现后台没有存在ubuntu进程 —&gt; 无事可做，已被关闭。</p> <p>但是像Mysql、Redis之类的就不会被关闭，因为 —&gt; 还有事可做。</p> <p><img alt=\"image-20220324151903595\" src=\"..\\..\\static\\image\\deb7e1e23a810ab773b3e2bd3ba6beeb.png\"/></p> </li><li> <p><strong>解决方案：</strong></p> <p>针对Docker中存在着这个机制的问题，我们就只能按照以下<strong>三步走</strong>。</p>\n<ul><li>前台启动进程 -it</li><li>Ctrl+p+q退出</li><li>docker ps观察是否成功</li></ul> </li></ul> </li><li> <p>logs打印容器日志</p> <pre><code>docker logs -ft xxx\n-f\t\t# 流输出，即持续输出/类似于Linux下的tail\n-t\t\t# 顺带输出时间戳\n-n\t\t# 指定开始输出的行数，-f可破坏此规则\n</code></pre> <p><img alt=\"image-20220324153158897\" src=\"..\\..\\static\\image\\6586f742b2150b4aea2349fc2265657f.png\"/></p> </li><li> <p>top查看容器内运行的进程</p> <pre><code>docker top xxx\n</code></pre> <p>有点长</p> <p><img alt=\"image-20220324153542191\" src=\"..\\..\\static\\image\\21b1b044fff893623151cd9815f9d85f.png\"/></p> <p><img alt=\"image-20220324153556890\" src=\"..\\..\\static\\image\\dff0f8590f28dd0a3bc330971cc2f3d4.png\"/></p> </li><li> <p>inspect显示容器具体信息</p>\n<blockquote>\n<p>**结论：**当容器中的所有终端都被关闭时，容器停止运行。（节省资源）</p>\n</blockquote>\n<ul><li> <p><strong>返回一JSON格式信息</strong></p> <p>docker inspect xxx</p> </li></ul> <p><img alt=\"image-20220324154027341\" src=\"..\\..\\static\\image\\603c20e01ea3bd1c1e80e28d93dd12d8.png\"/></p>\n<hr/> <pre><code>docker exec xxx bash\t\t#exit退出时，容器自动回归后台\n</code></pre> </li><li> <p>diff查看容器内部文件系统变化</p>\n<blockquote>\n<p>**作用：**查看容器内部文件系统的改动记录</p>\n<p>**说明：**A - Add, D - Delete, C - Change</p>\n<p>但是根据我的观测可能不是特别的准确，比如我在根目录下新增了一文件夹a，这里竟然显示D。然后我又在/a里新建文件夹，显示为A，正常。</p>\n</blockquote> <pre><code>[root@VM-4-3-centos ~]# docker diff --help\n\nUsage:  docker diff CONTAINER\n\n\n[root@VM-4-3-centos ~]# docker diff 3fe998f421b4\nD /a\nC /run\nD /run/secrets\nC /var/lib/systemd\nA /var/lib/systemd/a.txt\nD /var/lib/systemd/random-seed\n</code></pre> </li><li> <p>stats：查看容器占用内存</p> <pre><code>docker stats 27dfdb752738\n</code></pre> </li><li> <p>docker cp文件复制</p> <p>作用：将容器内的文件复制到（备份到）宿主的计算机。</p> <p>公式：</p> <pre><code>docker cp 容器id:容器内路径 宿主路径\n</code></pre> <p>实操</p> <pre><code>docker cp 095333dc1a5a:/test/a.txt .\n</code></pre> </li><li> <p>commit成新镜像</p>\n<blockquote>\n<p>慎用commit：https://yeasy.gitbook.io/docker_practice/image/commit</p>\n<p>用作备份还好，当用作制作新镜像就有点糟糕。</p>\n</blockquote>\n<ul><li> <p>思想：将当前容器提交成为新的镜像，产生新的镜像文件（不会覆盖原来的）。</p> </li><li> <p>代码：</p> <pre><code>#--author 是指定修改的作者，而 --message 则是记录本次修改的内容。\ndocker commit -m=\"\" -a=\"\"  容器id  包名/镜像名:版本号\n\n\ndocker commit -a=\"thinkstu\" -m=\"enhance version for vim\"  \n4ccdf283ef3c thinkstu/ubuntu_vim:1.0.1\n</code></pre> <p><img alt=\"image-20220324201118690\" src=\"..\\..\\static\\image\\62d95e552b9ab3c71fca15a09e9b4c34.png\"/></p> </li></ul> </li><li> <p>容器完整备份</p> </li></ol>\n<blockquote>\n<p><strong>思想</strong>：直接将容器打包成一个tar包，需要的时候再导进。</p>\n</blockquote>\n<ul><li> <p>两种命令</p>\n<ul><li>导入：<strong>import</strong></li><li>导出：<strong>export</strong></li></ul> </li><li> <p>export公式</p> <pre><code>docker export xxx &gt; 导出文件名.tar\n\ndocker export 095333dc1a5a &gt; ubuntu222.tar\n</code></pre> </li><li> <p>import公式</p> <pre><code>cat 文件名.tar | docker import - 组织名/镜像名:版本号\n\ncat ubuntu222.tar |docker import - thinkstu/ubuntu_test:1.0.1\n</code></pre>\n<ul><li><strong>注意事项：</strong>\n<ul><li>当我们将一个容器完整容器export导出时，它是<strong>作为一份镜像被导出</strong>。</li><li>所以当我们import导入一个tar包的时候，我们需要手动的填入一些信息，包名、镜像名、版本号，<strong>导入的文件也是一个镜像</strong>，而不是容器.</li></ul> </li></ul> </li></ul>\n<ol start=\"8\"><li> <p>commit与export的理解</p> <p><strong>commit</strong>是在本地直接将容器打包成镜像的操作，属于提交的类型。</p> <p><strong>export</strong>指令则先将容器commit成一个新镜像，然后再使用tar将镜像打包导出到宿主机。</p> <p><img alt=\"image-20220404090539954\" src=\"..\\..\\static\\image\\c276a2a5647962506e8ef319c277faee.jpeg\"/></p> </li></ol>\n<hr/>\n<h3><a id=\"6__499\"></a>6. 仓库</h3>\n<blockquote>\n<p>三种仓库：阿里云、私有云、官方</p>\n<p>**推荐：**阿里云（默认私有）、私有云（默认公开）</p>\n<p>**不推荐：**官方（默认公开、访问速度慢）</p>\n</blockquote>\n<h4><a id=\"1__507\"></a>1. 阿里云</h4>\n<blockquote>\n<p>阿里云Docker镜像仓库（ 个人免费+企业收费 ）</p>\n<p>阿里云仓库默认私有，只有登录才能下载</p>\n<p>可以更改为公共的，让其他人不需要登录就能下载</p>\n</blockquote>\n<ul><li> <p>创建阿里云容器镜像服务、个人实例。</p> </li><li> <p>创建命名空间</p> </li><li> <p>以命名空间为基础创建仓库</p> </li><li> <p>推送至远程仓库</p> <p>#登录、按要求打包、提交至远程仓库<br/> docker login --username=tb174293514 registry.cn-beijing.aliyuncs.com</p> <p>docker tag [ImageId] [阿里云地址]/[命名空间]/[镜像重命名]:[镜像版本号]</p> <p>docker push registry.cn-beijing.aliyuncs.com/thinkstu/uu:1.0</p> </li></ul>\n<blockquote>\n<p>实例</p>\n</blockquote>\n<pre><code>#三段式：登录、打包、上传\ndocker login --username=tb174293514 \negistry.cn-beijing.aliyuncs.com\n\ndocker tag 9b495bdf4db2 registry.cn-beijing.aliyuncs.com/thinkstu/ubuntu_vim:1.0.1\n\ndocker push registry.cn-beijing.aliyuncs.com/thinkstu/ubuntu_vim:1.0.1\n</code></pre>\n<blockquote>\n<p>拉取远程仓库的内容：到阿里云仓库中亲自查询再pull方便些</p>\n</blockquote>\n<pre><code>#两段式：登录、拉取\ndocker login --username=tb174293514 registry.cn-beijing.aliyuncs.com\n\ndocker pull registry.cn-beijing.aliyuncs.com/thinkstu/ubuntu_vim:[镜像版本号]\n</code></pre>\n<h4><a id=\"2__551\"></a>2. 私有云</h4>\n<blockquote>\n<p>私有云自搭建之初就是公有的，任何人都可以拉取的到</p>\n<p>所以我只要将拉取的链接直接发给别人就好</p>\n<p><strong>不过</strong>对方主机要先放开对我服务器域名的安全限制，具体做法与下面本机修改安全协议一样</p>\n</blockquote>\n<ul><li> <p>具体思路：利用Dockerz自建<strong>仓库（ registry ）</strong>，然后开放端口、配置信息。</p> </li><li> <p>搭建私有云服务器</p>\n<ol><li> <p>拉取镜像registry</p> </li><li> <p>运行容器、端口映射</p> </li><li> <p>访问测试（宿主机外网、宿主机内网、docker内网）</p> <p>docker pull registry</p> <p>docker run -d -p 5000:5000<br/> -v ~/myregistry/:/tmp/registry<br/> –privileged=true registry</p> <p>curl -XGET http://42.192.83.9:5000/v2/_catalog<br/> curl -XGET 10.0.4.3:5000/v2/_catalog<br/> curl -XGET 172.17.0.1:5000/v2/_catalog</p> <p>#测试结果：空空如也<br/> {“repositories”:[ ]}</p> </li></ol> </li><li> <p>上传镜像至私有云</p>\n<ol start=\"0\"><li> <p><strong>修改安全协议</strong></p> </li><li> <p>commit提交容器为新镜像</p> </li><li> <p>tag 修改镜像格式</p> </li><li> <p>上传push</p> </li></ol>\n<blockquote>\n<p>提示：如果在第一步就把镜像名规范化，则第二步可以不需要。</p>\n<p>Docker默认不支持http协议，修改配置使push跳过安全机制</p>\n</blockquote> <pre><code>vim /etc/docker/daemon.json\n\n#新增一行，记得在上行加逗号\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,\n\"insecure-registries\": [\"172.17.0.1:5000\"]\n\n#重启docker服务，使服务生效\nsystemctl restart docker\n\n\ndocker commit -m=\"enhance ubuntu for ifconfig\" -a=\"thinkstu\" c4ca8d49a98f myubuntu_ip:1.0.2\n\n#相对于阿里云，这里的命名空间不是必须的\ndocker tag [image_id] [私有云地址]/[命名空间]/[镜像重命名]:[镜像版本号]\ndocker tag myubuntu_ip:1.0.2 172.17.0.1:5000/myubuntu_ip:1.0.2\n\ndocker push 172.17.0.1:5000/mybuntu:1.0.2\n\n#查看是否上传成功\ncurl -XGET 172.17.0.1:5000/v2/_catalog\n{\"repositories\": [\n\"mycentos\",\n\"thinkstu/mycentos\",\n\"thinkstu/mycentos02\"]}\n</code></pre> </li><li> <p>pull从私有云拉取镜像</p> <pre><code>#查看私有云上的软件信息与版本号\n#1. 查看私有云镜像列表\ncurl 172.17.0.1:5000/v2/_catalog\n#2. 根据镜像名寻找版本\ncurl 172.17.0.1:5000/v2/[镜像全名]/tags/list\ncurl 172.17.0.1:5000/v2/thinkstu/mycentos/tags/list\n{\"name\": \"thinkstu/mycentos\",\n\"tags\": [\n\"1.2\",\n\"1.1\"]}\n\ndocker pull 172.17.0.1:5000/mycentos:1.2\n</code></pre> </li></ul>\n<h4><a id=\"3__642\"></a>3. 官方仓库</h4>\n<blockquote>\n<p>上传至官方仓库的镜像<strong>默认公开</strong></p>\n<p>免费版本只能对设置一个镜像为私有</p>\n</blockquote>\n<ol><li> <p>官方网站注册账号</p> </li><li> <p>登录账号</p> </li><li> <p>提交镜像</p> <pre><code>docker login -u thinkstu\n\n\n#1.'tag镜像'：[地址]/[命名空间]/[镜像重命名]:[镜像版本号]\ndocker tag centos04:1.0 thinkstu/centos:9.9\n\n#2. '提交镜像'\ndocker push push thinkstu/centos:9.9\n</code></pre>\n<blockquote>\n<p>这里</p>\n<ol><li>地址可以没有，默认：docker.io/</li><li>命名空间必须是 docker网站的用户名</li></ol>\n</blockquote> </li><li> <p>拉取镜像</p>\n<blockquote>\n<p>用户名（命名空间）/镜像名 : 版本号</p>\n</blockquote> <pre><code>push thinkstu/centos:9.9\n#速度也非常的慢\n</code></pre> <p><img alt=\"image-20220401122744438\" src=\"..\\..\\static\\image\\bb3bb508163b322d4a759aba682c4e69.png\"/></p> </li></ol>\n<h4><a id=\"4__680\"></a>4. 三种方式对比</h4>\n<blockquote>\n<p>都源自在官方提供的接口上进行定制化</p>\n</blockquote>\n<ol><li> <p><strong>登录</strong>：阿里云与官方只有登录之后才能进行push操作，否则会提示未授权。</p> <p>'用法：docker login [OPTIONS] [SERVER]</p> <p>'阿里云’docker login -u=tb174293514 registry.cn-beijing.aliyuncs.com</p> <p>'私有云’无需登录</p> <p>'官方 'docker login -u thinkstu</p> </li><li> <p><strong>tag</strong>：[云地址]/[命名空间]/[镜像重命名]:[镜像版本号]，标记镜像、为push做准备。</p> <p>docker tag 9b495bdf4db2<br/> registry.cn-beijing.aliyuncs.com/thinkstu/ubuntu:1.0.1</p> <p>docker tag 39272891e4b4<br/> 172.17.0.1:5000/myubuntu_ip:1.0.2</p> <p>docker tag centos04:1.0<br/> thinkstu/centos:9.9</p>\n<ol start=\"3\"><li><strong>push</strong></li></ol> </li></ol>\n<blockquote>\n<p>前提：已登录。</p>\n<p>push目标其实由两个因素构成：云地址+命名空间</p>\n<p><strong>云地址</strong>为产商标识、<strong>命名空间</strong>可看作用户标识（用户名）</p>\n</blockquote>\n<pre><code>'阿里云'docker push registry.cn-beijing.aliyuncs.com/thinkstu/ubuntu_vim:1.0.1\n\n'私有云'docker push 172.17.0.1:5000/mybuntu:1.0.2\n\n'官方 'docker push thinkstu/centos:9.9\n'相当 'docker push docker.io/thinkstu/centos:9.9\n</code></pre>\n<ol start=\"4\"><li> <p><strong>pull</strong>公有仓库</p> <p>直接登录事先存在的仓库地址查看版本信息，然后直接pull。</p> </li></ol>\n<hr/>\n<h3><a id=\"7__731\"></a>7. 网络</h3>\n<blockquote>\n<p>docker中所有的网络都是<strong>虚拟的</strong>，转发效率高（内网传递）。</p>\n<p>当创建容器时如没有指定网段，则会被分配到默认网段docker0。</p>\n<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>\n</blockquote>\n<ol><li> <p>原理：<strong>veth-pair技术</strong></p> <p>veth-pair 就是<strong>一对</strong>的虚拟设备接口，和 tap/tun 设备不同的是，它都是<strong>成对出现</strong>的。一端连着协议栈，一端彼此相连着。正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备</p> <p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p> <p><code>https://www.cnblogs.com/bakari/p/10613710.html</code></p> </li><li> <p>宿主机上查看ip信息</p> <p><img alt=\"image-20220401150432810\" src=\"..\\..\\static\\image\\8c58e2bbf706b3e02d911113c2aaeeb2.png\"/></p> <p><strong>三个地址：</strong></p>\n<ul><li>lo：loop，服务器回环地址 127.0.0.1</li><li>eth0：Ethern 0，以太网第一个网卡接口，腾讯云内网地址10.0.4.3</li><li>docker0：docker的第一个网卡接口，地址<strong>172.17.0.1</strong>，为虚拟的路由器，负责转发容器内的网络请求</li></ul> </li><li> <p>容器内查看ip信息</p> <pre><code>yum -y install iproute\n</code></pre> <p><img alt=\"image-20220401151753430\" src=\"..\\..\\static\\image\\98af9685a5805db1be71af41229a85ab.png\"/></p> <p><strong>两个地址：</strong></p>\n<ul><li>容器回环地址</li><li>eth0@if9：172.17.0.2</li></ul> </li><li> <p>docker网络<strong>小结：</strong></p>\n<ol><li>docker使用的是Linux的桥接</li><li>宿主机是一个Docker容器的网桥docker0。</li></ol> <p><img alt=\"img\" src=\"..\\..\\static\\image\\5a81c9a643d3966173b0d161383e750a.png\"/></p> </li><li> <p>–link参数说明</p>\n<blockquote>\n<p><strong>已淘汰，不推荐；</strong></p>\n</blockquote> <p>为什么需要它？</p> <p>想让容器之间通过容器名相互ping通，而不是通过内网ip地址；从而解决docker重启后网络地址随机分配的尴尬。</p> <pre><code># 现在 tomcat03可以直接在内部ping通tomcat02，但是反过来不行\ndocker run -d -P --name tomcat03 --link tomcat02 tomcat\n</code></pre>\n<ul><li><strong>原理：</strong>–link指令在run创建这个容器的时候改写了容器内部的<code>/etc/hosts</code>字段，本质就是改写了映射规则，所以03能直接通过名称找到02。</li><li>**小技巧：**直接查看/etc/hosts文件能看到此容器中的所有映射关系。</li></ul> </li><li> <p><strong>查看docker内部所有的网络配置</strong></p> <pre><code>[root@vm-4-3-centos ~]$ docker network --help\n\nUsage:  docker network COMMAND\n\nCommands:\n  connect     Connect a container to a network\n' create      Create a network\n  disconnect  Disconnect a container from a network\n  inspect     Display detailed information on one or more networks\n' ls          List networks\n  prune       Remove all unused networks\n  rm          Remove one or more networks\n\n\n[root@vm-4-3-centos ~]$ docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\ndf364ea5e865        bridge              bridge              local\n5ef346efe85f        host                host                local\n6b307841d021        none                null                local\n#备注：这里有两列bridge，其中有一列是name名字，另一列是driver驱动类型。\n#\t\t\t并不一样，这一查看方法\n\n[root@vm-4-3-centos ~]$ docker network inspect df364ea5e865\n#返回JSON字符串\n</code></pre> <p><img alt=\"image-20220401164425579\" src=\"..\\..\\static\\image\\acbd8b06de5a4e78e6f052338486348e.png\"/></p> </li><li> <p>自定义网络（容器互联）</p>\n<blockquote>\n<p>取代–link</p>\n</blockquote> <p><strong>网络配置分类 ：</strong></p>\n<ol><li>bridge：桥接 （默认，自己创建也是用的bridge模式）</li><li>none：不配置网络，一般不用</li><li>host：和主机共享网络</li><li>container：容器网络连通（少用，局限性很大）</li></ol> <p><img alt=\"image-20220401173929045\" src=\"..\\..\\static\\image\\de1b241db70cac99faac94a2bbfe5198.png\"/></p> <p><strong>自定义网络优势：</strong></p>\n<blockquote>\n<p>docker为我们自定义的网络维护好了对应的关系，会比docker0更优。</p>\n</blockquote> <p><strong>实现思路：</strong></p> <p>利用docker network create指令创建属于自己的网络，在后续创建容器时指定容器使用该网络。</p> <h4><a id=\"_839\"></a>开始自定义网络：</h4> <pre><code>[root@vm-4-3-centos ~]$ docker network create --help \n#只列出3参数，其实还有其他的许多\nUsage:  docker network create [OPTIONS] NETWORK\nOptions:\n-d --driver      Driver to manage the Network \n   --gateway   IPv4 or IPv6 Gateway for the master subnet\n   --subnet  Subnet in CIDR format that represents a network segment\n\n\n'范例，其中：子网掩码和网关必须配置，--driver默认就是bridge、故可不写。\ndocker network create -d bridge --gateway 192.168.0.1 --subnet 192.168.0.0/16 mynet\n</code></pre>\n<ul><li> <h5><a id=\"_854\"></a>查看我们自定义的网络配置：</h5> <p><img alt=\"image-20220401175239712\" src=\"..\\..\\static\\image\\3eeb08c0b29789cd960fe3add3fc8c58.png\"/></p> </li><li> <h5><a id=\"_858\"></a>使用我们自定义的网络配置</h5> <pre><code>docker run -it --name centos-net-01 --net mynet docker.io/centos:7.9.2009\n</code></pre> </li><li> <p>查看刚运行起来的centos容器配置</p> <pre><code>docker inspect fc2575aa6ea5\n</code></pre> <p><img alt=\"image-20220401175641110\" src=\"..\\..\\static\\image\\389369798a2f852ca59b1cd0d896f85b.png\"/></p> </li></ul>\n<ol start=\"8\"><li>网络互联</li></ol>\n<ul><li>解决问题：网络段之间的互联问题，现在tomcat01与tomcat02因为处于不同的网段，所以它两暂时不能ping通。</li></ul> <p><img alt=\"image-20220401190910614\" src=\"..\\..\\static\\image\\d5bb050f1290f164a7ee3a986fd3110a.png\"/></p> <pre><code>[root@07741f074e88 /]$ ping 192.168.0.2 \nPING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.\n^C\n--- 192.168.0.2 ping statistics ---\n13 packets transmitted, 0 received, 100% packet loss, time 12000ms\n# 100% 的丢包率\n</code></pre>\n<ul><li> <p>解决思路：我们为 tomcat02 再赋予192.168.0.1段的地址即可。</p> </li><li> <p>解释：<strong>相当于</strong>tomcat02<strong>拥有两块网卡</strong>，这两个网络段全部把它接入（当然这是虚拟的）。</p> </li><li> <p>实现：docker network connect</p> </li></ul>\n<blockquote>\n<p>connect将一个网段赋于容器中</p>\n</blockquote> <pre><code>[root@vm-4-3-centos ~]$ docker network connect --help\n\nUsage:  docker network connect [OPTIONS] NETWORK CONTAINER\n'Connect a container to a network\nOptions:\n   --alias \t\t\t\t    Add network-scoped alias for the container\n   --help             Print usage\n   --ip string        IP Address\n   --ip6 string       IPv6 Address\n   --link list        Add link to another container (default [])\n   --link-local-ip    Add a link-local address for the container\n\n\n#不需要参数，直接链接\ndocker network connect mynet test1\n\n#查看mynet网段中的信息\ndocker network ls\ndocker network inspect 6afc49097296\n\n#尝试一下现在能否ping成功：成功！\n[root@07741f074e88 /]$  ping 192.168.0.2\nPING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.\n64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.093 ms\n64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.071 ms\n^C\n--- 192.168.0.2 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1999ms\nrtt min/avg/max/mdev = 0.069/0.077/0.093/0.014 ms\n</code></pre> <p><img alt=\"image-20220401191817565\" src=\"..\\..\\static\\image\\b3e4f97481c44527096ff3129b94d271.png\"/></p>\n<ol start=\"9\"><li>指定容器ip地址==–ip==</li></ol>\n<blockquote>\n<p>前提：跟所在网络的配置相符</p>\n</blockquote> <pre><code>docker run -it --name centos-net-01 --net mynet --ip 192.168.22.03 docker.io/centos:7.9.2009\n</code></pre> </li><li> <h4><a id=\"docker_934\"></a>docker网络参数说明</h4> </li></ol>\n<ul><li> <p><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</p> </li><li> <p>–net=host告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</p> <p>=host 容器直接与主机共享网络、端口；</p> </li><li> <p><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</p> </li><li> <p><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</p> </li></ul>\n<ol start=\"9\"><li> <p>大写P的映射规则：当使用P（大写的）标记时， Docker 会随机映射一个 49000~49900 的端口</p> <p>到内部容器开放的网络端口。（注意其的范围，任意也是有限制的）</p> </li></ol>\n<hr/>\n<h3><a id=\"8__955\"></a>8. 数据卷</h3>\n<ol><li> <p>数据卷是什么？Volumn，一种数据的备份、共享策略。</p> </li><li> <p>底层理解：硬链接。</p> </li><li> <p>在宿主机与容器中存在着一种现象：两个目录共享一份文件系统。<strong>其中</strong>，容器中的这个目录是独立于容器本身的<strong>UnionFS联合文件系统</strong>，所以即使删除该容器，存在于共享目录的文件还是会被保存下来，位于宿主机中。</p> </li><li> <p>作用：</p>\n<ol><li>数据备份：用作容器拷贝的利器。</li><li>共享文件：宿主机与容器之间、容器与容器之间，例如10个redis容器共享一份配置文件。</li></ol> </li><li> <p>数据卷参数-v、–：</p> </li></ol>\n<blockquote>\n<p>可挂载多个volumn</p>\n</blockquote>\n<pre><code>#目录如不存在则新建\ndocker run -it -v ~/myData:/etc/data -v ~/myBin:/bin  \n</code></pre>\n<p>–privileged=true centos</p>\n<ol start=\"6\"><li> <p>查看某容器的数据卷路径</p> <p>docker inspect 容器id</p> </li></ol>\n<p><img alt=\"image-20220404152607502\" src=\"..\\..\\static\\image\\c30dea36efeb1bbfddf1fc0ba324471b.png\"/></p>\n<ol start=\"7\"><li>具名挂载、匿名挂载</li></ol>\n<blockquote>\n<p>数据卷挂载的两种方式</p>\n</blockquote>\n<pre><code>#具名挂载，挂载的路径由用户自定义\ndocker run -d -v ~/mysql/data:/var/lib/mysql mysql\n\n#匿名挂载：未指定宿主机的挂载地址，默认分配到/var/lib/docker/volumn目录\ndocker run -d -v /var/lib/mysql\n</code></pre>\n<ul><li><strong>具名挂载说明</strong>：实名挂载，指定双方相互挂载的路径。</li><li><strong>匿名挂载说明</strong>：宿主机匿名、容器实名，在宿主机上随机生成匿名代号。</li></ul>\n<ol start=\"8\"><li> <p><strong>查看</strong>宿主机上<strong>匿名</strong>挂载的<strong>数据卷</strong></p> <p>cd /var/lib/docker/volumn<br/> cd …<br/> cd _data</p> </li><li> <p>查看volumn指令帮助</p> <p>[root@vm-4-3-centos ~]$ docker volume --help</p> <p>Usage: docker volume COMMAND<br/> Commands:<br/> create Create a volume<br/> inspect Display detailed information on one or more volumes<br/> ls List volumes<br/> prune Remove all unused volumes<br/> rm Remove one or more volumes</p> </li><li> <p>数据卷挂载新需求：<strong>只读权限</strong></p> </li></ol>\n<blockquote>\n<p>在多容器共享数据卷时很有用。</p>\n</blockquote>\n<ul><li> <p>容器内只能读，宿主机能读能写。</p> </li><li> <p>实现：rw：能读能写（<strong>默认值</strong>）、ro：read-only只能读</p> <pre><code>docker run -d -p 5000:5000  -v /thinkstu/myregistry/:/tmp/registry:ro \n</code></pre> </li></ul>\n<p>–privileged=true registry</p>\n<ol start=\"11\"><li>–volumes-from：数据卷继承</li></ol>\n<blockquote>\n<p>便捷实现多个Docker容器之间、宿主机之间数据共享：直接继承即可。</p>\n</blockquote>\n<pre><code>docker run -it --name \"myubuntu100\" --volumes-from [容器id] \n</code></pre>\n<p>–privileged=true ubuntu</p>\n<hr/>\n<h3><a id=\"9__1041\"></a>9. 常用操作</h3>\n<ol><li> <p>system df查看镜像与容器情况</p> <p>docker system df</p> </li></ol>\n<p><img alt=\"image-20220403220136554\" src=\"..\\..\\static\\image\\059307f88e6ba4375795cd9ff42cd9e9.png\"/></p>\n<ol start=\"2\"><li> <p>用完即删</p> <p>docker run -it --rm tomcat</p> </li><li> <p>不进入容器执行指令</p> <p>docker run -d centos ls -l</p> </li><li> <p>清除无主的数据卷、无用的镜像、暂停的容器</p> <p>docker volume prune<br/> docker image prune</p> <p>docker container prune<br/> #prune , Remove all stopped containers</p> </li><li> <p>–restart参数说明</p> <p>–restart = always | unless-stopped | no | on- failure</p> </li><li> <p>容器退出后自动删除</p> <p>–rm=true | false #容器退出后是否自动删除，不能跟 同时使用</p> </li><li> <p>限制容器的内存使用量</p> <p>-m, - -memory = 1g #单位可以是b/k/m/g</p> </li><li> <p>run指令等于先执行create指令再执行start指令。</p> </li><li> <p>docker -itd操作诠释</p> <p>#可以让ubuntu这类的系统直接进入后台运行而不真正的退出<br/> docker run -itd ubuntu</p> </li><li> <p>如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用 <code>docker rm -v</code></p> </li></ol>\n<pre><code>指令来指定同时删除关联的容器。\n</code></pre>\n<hr/>\n<h3><a id=\"8__1098\"></a>8. 日常实践</h3>\n<h4><a id=\"1_systemd_1100\"></a>1. 启用systemd服务</h4>\n<blockquote>\n<p>简介：删删删东西，然后build重构。</p>\n</blockquote>\n<ul><li> <p>解决Docker中CentOS镜像无法使用systemd的问题</p> </li><li> <p>https://developer.aliyun.com/article/688670</p> </li><li> <p>#直接下载作者制作好的镜像：</p> <h1><a id=\"_1108\"></a>下载镜像</h1> <p>docker pull 2233466866/centos-systemd</p> <h1><a id=\"test_1110\"></a>通过镜像运行一个名为test的容器</h1> <p>docker run -dit -v /sys/fs/cgroup:/sys/fs/cgroup:ro --name=test --privileged=true 2233466866/centos-systemd</p> </li></ul>\n<h4><a id=\"2__1114\"></a>2. 查看系统自启动程序</h4>\n<pre><code>systemctl list-unit-files\n</code></pre>\n<h4><a id=\"3_Docker_1119\"></a>3. Docker安装宝塔</h4>\n<ol><li> <p>创建CentOS容器</p> <pre><code>docker run -it --restart=always --name baota \n</code></pre> </li></ol>\n<p>-p 80:80 -p 443:443 -p 888:888 -p 8888:8888<br/> –privileged=true -v /home/www:/www centos7.9.2009</p>\n<ol start=\"2\"><li> <p>参数说明</p> <pre><code>#容器开机自启\n–restart=always\n\n#映射宝塔主要需要的端口，也可以自己添加如3306等端口\n-p 80:80 -p 443:443 -p 888:888 -p 8888:8888\n\n映射本地的/home/www作为容器的/www目录\n-v /home/www:/www\n</code></pre> </li><li> <p>centos内安装宝塔</p> <pre><code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh\n</code></pre> </li><li> <p>关闭宝塔面板的离线模式（否则处于离线状态、无法访问）</p> <pre><code>rm -rf /www/server/panel/data/not_network.pl &amp;&amp; bt reload\n</code></pre> </li><li> <p>设置宝塔程序自启动</p>\n<blockquote>\n<p><strong>注意</strong>：编写脚本——方式多样，实现的效果也多样。</p>\n</blockquote> </li></ol>\n<h4><a id=\"4_ubuntuvim_1155\"></a>4. ubuntu<strong>安装vim</strong></h4>\n<ul><li> <p>Docker原生的ubuntu是精简版本，没有携带vim。</p> </li><li> <p>apt-get指令, 简写：apt。</p> </li><li> <p>安装</p>\n<blockquote>\n<p>Docker 镜像在制作时为了精简清除了 <code>apt</code> 仓库信息，因此需要先执行 <code>apt-get update</code> 命令来更新仓库信息。更新信息后即可成功通过 <code>apt-get</code> 命令来安装软件。</p>\n</blockquote> <pre><code>apt update \t\t\t\t\t\t#更新索引\napt -y install vim\t\t#安装vim\n</code></pre> </li></ul>\n<h4><a id=\"5vivim_1170\"></a>5.<strong>vi</strong>与vim</h4>\n<blockquote>\n<p>注意：centos与ubuntu中虽然无vim，但是有vi啊，也不是不能编辑！节省空间！</p>\n</blockquote>\n<pre><code>vi a.txt\n</code></pre>\n<h4><a id=\"6_Docker_1177\"></a>6. Docker可视化</h4>\n<blockquote>\n<p>两种方案：<strong>portainer</strong>：初级，<strong>Rancher</strong>：企业。</p>\n</blockquote>\n<pre><code># 在此，--restart=always总是自启动，除非被docker stop\ndocker run -d -p 8000:8000 -p 9443:9443 --name portainer \n--restart=always \n-v /var/run/docker.sock:/var/run/docker.sock \n-v portainer_data:/data \nportainer/portainer-ce:2.9.3\n</code></pre>\n<h4><a id=\"7__1189\"></a>7. 正确启动容器的流程</h4>\n<pre><code>docker start xxid\n\ndocker exec -it xxid /bin/bash\n</code></pre>\n<h4><a id=\"8_root_1196\"></a>8. 授予容器root权限</h4>\n<blockquote>\n<p>问题：Docker挂载主机目录访问时出现<strong>cannot ope directory : Permission denied</strong></p>\n</blockquote>\n<pre><code>docker run -it --privileged=true centos\n</code></pre>\n<h4><a id=\"9__1203\"></a>9. 容器的宿主机目录</h4>\n<blockquote>\n<p>我们查看到docker的容器在宿主机上的存放地点</p>\n</blockquote>\n<pre><code>cd /var/lib/docker/containers/\n</code></pre>\n<p><img alt=\"image-20220327110207741\" src=\"..\\..\\static\\image\\11e564ef59a87ba704739df16cbfb4b5.png\"/></p>\n<h4><a id=\"10_mysql_1212\"></a>10. 安装mysql</h4>\n<ol><li> <p>存在的问题：</p>\n<ul><li> <p>5.7版本中文乱码</p> </li><li> <p>数据如何备份</p> <p>.# mysql内部查看mysql现阶段字符集<br/> show variables like ‘character%’</p> </li></ul> </li><li> <p>解决方案</p> <p>#1. 数据备份问题</p> <p>'/var/lib/mysql： 数据<br/> 'var/log/mysql： 日志<br/> 'etc/mysql/conf.d: 配置</p> <p>docker run -d -p 3305:3306 --privileged=true<br/> -v ~/mysql/log:/var/log/mysql<br/> -v ~/mysql/data:/var/lib/mysql<br/> -v ~/mysql/conf:/etc/mysql/conf.d<br/> -e MYSQL_ROOT_PASSWORD=123456 --name mysql_test mysql</p> <p>'-e设置初始参数，这里：mysql初始密码。</p> <p>#2. 5.7版本中文乱码问题</p> <p>[root@VM-4-3-centos /]$ vim /thinkstu/mysql/conf/my.cnf</p> <p>[client]<br/> default_character_set=utf8<br/> [mysqld]<br/> collation_server = utf8_general_ci<br/> character_set_server = utf8</p> <p>#写入以上内容，重启mysql容器服务：docker restart xxx</p> </li><li> <p>后续情境：mysql容器被误删时如何恢复？</p> <p>#再次新建 Mysql for Docker 容器，使用相同的数据卷映射</p> <p>docker run -d -p 3306:3306 --privileged=true<br/> -v /thinkstu/mysql/log:/var/log/mysql<br/> -v /thinkstu/mysql/data:/var/lib/mysql<br/> -v /thinkstu/mysql/conf:/etc/mysql/conf.d<br/> -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7</p> </li></ol>\n<h4><a id=\"11_SpringBoot_1265\"></a>11. 运行SpringBoot程序</h4>\n<blockquote>\n<p>不依赖宝塔，轻量级运行</p>\n</blockquote>\n<ol><li> <p>宿主机拿到jar包+编写Dockerfile（其中<code>FROM JDK8</code>）</p> <p>FROM java:8<br/> COPY *.jar /app.jar<br/> CMD [“–server.port=8080”]<br/> EXPOSE 8080<br/> ENTRYPOINT [“java”,“-jar”,“app.jar”]</p> </li><li> <p>将以上传至服务器，然后使用<code>docker build</code> 构建成镜像、运行</p> <p>docker build -t mySpringboot .</p> </li></ol>\n<p>**注意：**不要傻乎乎的将构建成的镜像文件上传至公共仓库，这样会被别人盗取的！</p>\n<h3><a id=\"12__1285\"></a>12. 取消默认截断</h3>\n<blockquote>\n<p>docker中存在着对长字符串默认截断的参数，我们可以禁止它。</p>\n</blockquote>\n<pre><code>docker ps --no-trunc\n</code></pre>\n<h1><a id=\"Docker_1292\"></a>Docker高级篇</h1>\n<h2><a id=\"Dockerfile_1295\"></a>Dockerfile</h2>\n<blockquote>\n<p><strong>作用</strong>：构建镜像</p>\n<p><strong>解释</strong>：通过编写指令脚本来构建镜像，可以在镜像构建之初就并入部分操作。</p>\n</blockquote>\n<h4><a id=\"1__1302\"></a>1. 指令诠释</h4>\n<blockquote>\n<p>全部大写</p>\n</blockquote>\n<pre><code>FROM\t\t\t\t\t\t'from\t基础镜像'\n\nMAINTAINER\t\t\t'maintainer 镜像维护者：标签已被淘汰'\nLABEL\t\t\t\t\t\t'label 镜像标签：官方现在推荐使用此标签'\n\t\t\t\t\t \nRUN\t\t\t\t\t\t\t'run 镜像构建时需要运行的命令'\n\nADD\t\t\t\t\t\t\t'add：添加镜像、压缩包等，提供自动解压功能\n\nWORKDIR\t\t\t\t\t'workdir 镜像默认的工作目录\n\nVOLUMN\t\t\t\t\t'volumn\t挂载目录（数据卷）\nEXPOSE\t\t\t\t\t'expose 暴露端口\n\nCMD\t\t\t\t\t\t\t'command 指定容器启动时运行的指令，只有最后一个会生效\nENTERPOINT\t\t\t'enterpoint 指定容器启动时运行的指令，可以追加\n \nONBUILD\t\t\t\t\t'onbuild 以当前镜像为基础镜像，构建下一级镜像的时候触发\nCOPY\t\t\t\t\t\t'copy 类似ADD，拷贝宿主机文件到镜像，需指定目录\nENV\t\t\t\t\t\t\t'enviroment 设置构建时的环境变量（持续到容器时期）\n</code></pre>\n<h4><a id=\"2_centos7_1328\"></a>2. 官方centos7</h4>\n<blockquote>\n<p>scratch：这个镜像是虚拟的概念，实际并不存在，它表示一个空白的镜像。</p>\n</blockquote>\n<pre><code>FROM scratch\nADD centos-7-x86_64-docker.tar.xz /\nLABEL \norg.label-schema.schema-version=\"1.0\" \norg.label-schema.name=\"CentOS Base Image\" \norg.label-schema.vendor=\"CentOS\" \norg.label-schema.license=\"GPLv2\" \norg.label-schema.build-date=\"20201113\" \norg.opencontainers.image.title=\"CentOS Base Image\" \norg.opencontainers.image.vendor=\"CentOS\" \norg.opencontainers.image.licenses=\"GPL-2.0-only\" \norg.opencontainers.image.created=\"2020-11-13 00:00:00+00:00\"\nCMD [\"/bin/bash\"]\n</code></pre>\n<h4><a id=\"3_build__1347\"></a>3. build 构建镜像</h4>\n<blockquote>\n<p><strong>步骤：<strong>编写dockerfile脚本文件，build构建</strong>centos</strong>镜像。</p>\n</blockquote>\n<pre><code>vim dockerfile01\n\nROM centos:7.9.2009\nLABEL\n    com.thinkstu.name=\"THINKSTU\"\nENV file /tmp\nWORKDIR $file\nRUN yum -y install vim\nEXPOSE 8081\nCMD /bin/bash\n\n\ndocker build -f dockerfile01 -t centos_02:1.0 .\n\n'命令详解：\n'-f   使用本地的dockerfile文件。\n\t\t  #如果dockerfile文件名就是dockerfile，则可以不需要此参数进行指定\n\t\t  \n'-t   指定名称\n'最后英文句号\".\"告诉docker应该在当前目录中寻找dockerfile01文件\n</code></pre>\n<h4><a id=\"4_history_1373\"></a>4. history指令</h4>\n<blockquote>\n<p>**介绍：**可以查看任意镜像的构建历史（即过程）</p>\n<p>**作用：**为我们模仿编写dockerfile文件提供便利</p>\n</blockquote>\n<pre><code>docker  history eeb6ee3f44bd \n#输出结果倒序查看，或者利用cat的相反数：tac\n\ndocker  history eeb6ee3f44bd | tac\n</code></pre>\n<h4><a id=\"5__1385\"></a>5. 定制化感悟</h4>\n<ol><li> <p>Dockerfile 中<strong>每一个指令都会在镜像中建立一层</strong>，Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。不要让docker镜像拥有过多层级，使用==&amp;&amp;==削减层级。</p> <p><strong>糟糕的写法（五层）：</strong></p> <pre><code>FROM debian:stretch\n\nRUN apt-get update\nRUN apt-get install -y gcc libc6-dev make wget\nRUN mkdir -p /usr/src/redis\nRUN make -C /usr/src/redis\nRUN make -C /usr/src/redis install\n</code></pre> <p><strong>正确的写法（一层）：</strong></p> <pre><code>FROM debian:stretch\n\nRUN set -x; buildDeps='gcc libc6-dev make wget' \n</code></pre> <p>&amp;&amp; apt-get update<br/> &amp;&amp; mkdir -p /usr/src/redis<br/> &amp;&amp; make -C /usr/src/redis<br/> &amp;&amp; make -C /usr/src/redis install</p> </li><li> <p>镜像是多层存储，每一层的东西并不会在下一层真正被删除，<strong>只是会被标记为已删除</strong>、一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该被<strong>及时手动清理掉</strong>，否则多层下来镜像臃肿不堪。</p> <pre><code>#比如最后执行yum清除缓存操作\nyum clean all\n</code></pre> </li><li> <p>关于build指令构建时的那个小点 \" . \"</p> <p><strong>当构建的时候</strong>，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p> <p><strong>有些初学者</strong>在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p> <p><strong>原来如此，所以我们才需要在每一次构建时都新建一空白的目录！</strong></p> </li><li> <p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，<strong>容器内没有后台服务的概念。</strong></p> <p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p> <p><strong>错误范例：</strong></p> <pre><code>#容器中根本就没有systemctl、service这样的概念（但是可以通过一些技巧得到，原此）\nsystemctl start nginx\nservice nginx start\n</code></pre> <p><strong>正确的做法是</strong>直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p> <pre><code>\"nginx -g daemon off\n</code></pre> </li><li> <p>数据卷感悟</p>\n<ol><li>在容器中使用数据卷能够提高容器在运行时的读写效率。（此时数据将直接写入宿主机中而不是容器，减少了一层套壳）</li><li>另外，我在编写Dockerfile的时候就可以编写一些匿名的数据卷，这样就不用怕数据的丢失。而且如果我日后有指定数据卷，那么直接指定即可，匿名的将会失效。</li><li>容器内的数据在容器销毁的时候会丢失，但是数据中的不会。</li></ol> </li></ol>\n<hr/>\n<h2><a id=\"compose_1449\"></a>compose</h2>\n<blockquote>\n<p>美好情境：一份yml文件，一键部署</p>\n</blockquote>\n<ol><li> <p>解释性说明：</p>\n<ul><li>使用yaml文件定义服务</li><li>帮助定义和共享多容器应用程序</li><li>**最大优点：**原先公司启动100个微服务，挨个去启动，现在一键compose部署。</li></ul> </li><li> <p>安装docker compose</p> <p>方式1：<strong>/usr/bin</strong>目录下</p> <p>yum -y install docker-compose</p> <p>#然后刷新配置<br/> source /etc/profile</p> <p>方式2??：<strong>/usr/local/bin</strong>目录下</p> <p>sudo curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-<code>uname -s</code>-<code>uname -m</code> &gt; /usr/local/bin/docker-compose</p> <p>#然后赋予权限即可<br/> sudo chmod +x /usr/local/bin/docker-compose</p> </li></ol>\n<p>说明3：其本质上就是个二进制的文件。</p>\n<ol start=\"3\"><li> <p>运行compose指令</p> <p>docker-compose up</p> <p>#参数<br/> -f, --file 指定使用的模板文件，默认为 docker-compose.yml，可以多次指定。<br/> -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。<br/> –verbose 输出更多调试信息。</p> </li></ol>\n<h2><a id=\"swarm_1491\"></a>swarm</h2>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\54c6fc03eac66cba6d3f5f2502257c1a.png\"/></p>\n<hr/>\n<h1><a id=\"0__1498\"></a>0. 帮助文档</h1>\n<pre><code>docker --help\ndocker images --help\n</code></pre>\n<blockquote>\n<p>范例</p>\n</blockquote>\n<pre><code>#参数有6个，其中两条拥有简写的形式\n[root@VM-4-3-centos]$ docker logs --help\n\nOptions:\n      --details        Show extra details provided to logs\n  -f, --follow         Follow log output\n      --since string   Show logs since timestamp \n  -n, --tail string    Number of lines to show from the end of the logs \n  -t, --timestamps     Show timestamps\n      --until string   Show logs before a timestamp \n                       relative (e.g. 42m for 42 minutes)\n</code></pre>\n<p><img alt=\"Docker\" src=\"..\\..\\static\\image\\4179d301af4020abcf5eb45c237bd7fe.png\"/></p>\n<p><img alt=\"Docker命令图_容器\" src=\"..\\..\\static\\image\\2d22a9bd1f6f8887a8b8051386f09030.png\"/></p>\n<p><img alt=\"image-20220406055821695\" src=\"..\\..\\static\\image\\37eb87644a823de31eb521d4c8e032cf.png\"/></p>\n<p>onvert/37eb87644a823de31eb521d4c8e032cf.png)</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-29 11:10:46", "summary": "文章目录初级篇是什么思想安装镜像镜像进阶指令容器容器进阶仓库阿里云私有云官方仓库三种方式对比网络开始自定义网络：查看我们自定义的网络配置：使用我们自定义的网络配置网络参数说明数据卷常用操作日常实践启用"}