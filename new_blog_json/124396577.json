{"blogid": "124396577", "writerAge": "码龄2年", "writerBlogNum": "58", "writerCollect": "6737", "writerComment": "5577", "writerFan": "20457", "writerGrade": "7级", "writerIntegral": "11819", "writerName": "小威要向诸佬学习呀", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124396577.jpg", "writerRankTotal": "915", "writerRankWeekly": "9", "writerThumb": "4557", "writerVisitNum": "232834", "blog_read_count": "4851", "blog_time": "已于 2022-04-28 09:49:30 修改", "blog_title": "通过栗子来学习MySQL高级知识点（学习，复习，面试都可）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>前言：<br/> <strong>首先很感谢各位小伙伴对我上一篇文章的支持</strong>，<strong>给我的创作带来了很大的动力</strong>。<br/> 其次最近要考试MySQL高级这个课程了，这块内容也是面试中重要的考点，所以正好借此机会看了之前看过的网课笔记和网上的资料，记录一下面试中常问的问题和这个课程里重要的知识点，<strong>以帮助自己和各位小伙伴儿应对期末考试，巩固学习，以后面试用</strong>，在这里先感谢大佬们的支持。<br/> 如果文章中有什么不对的地方或者需要改进的地方，还请大佬们不吝赐教。<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/a70cc3b5661e437ab8ae4abbba8fcfbb.gif#pic_center\"/></p>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#MySQL_8\">MySQL索引</a></li><li><ul><li><a href=\"#_11\">什么是索引</a></li><li><a href=\"#_14\">索引都有哪些数据结构</a></li><li><a href=\"#_16\">索引的原理</a></li><li><a href=\"#_22\">索引底层是怎么实现的</a></li><li><ul><li><a href=\"#Hash_23\">Hash索引</a></li><li><a href=\"#_36\">二叉树索引</a></li><li><a href=\"#_46\">平衡二叉树</a></li><li><a href=\"#B_59\">B树（多路平衡查找树）</a></li><li><a href=\"#B_79\">B+树</a></li></ul>\n</li><li><a href=\"#BB_90\">B+树优于B树原因</a></li><li><a href=\"#_101\">什么是覆盖索引</a></li><li><a href=\"#_121\">什么是聚簇索引</a></li><li><a href=\"#_128\">联合索引</a></li><li><a href=\"#_132\">最左匹配原则</a></li><li><a href=\"#_140\">创建索引的原则</a></li><li><a href=\"#_154\">创建索引的优缺点</a></li></ul>\n</li><li><a href=\"#MySQL_171\">MySQL存储引擎</a></li><li><ul><li><a href=\"#_177\">分类</a></li><li><a href=\"#InnoDB__MylSAM_189\">InnoDB 和 MylSAM存储引擎区别</a></li></ul>\n</li><li><a href=\"#MySQL_204\">MySQL事务</a></li><li><ul><li><a href=\"#_207\">什么是事务</a></li><li><a href=\"#_210\">事务操作</a></li><li><a href=\"#_224\">事务的特性</a></li><li><a href=\"#_232\">事务的隔离级别</a></li></ul>\n</li><li><a href=\"#MySQL__253\">MySQL 锁机制</a></li><li><ul><li><a href=\"#MySQL_265\">MySQL锁的特性</a></li><li><a href=\"#_271\">如何加锁</a></li><li><a href=\"#_295\">死锁</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"MySQL_8\"></a>MySQL索引</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5564c57d4b8647499a8d29982275fbf5.png\"/></p>\n<h2><a id=\"_11\"></a>什么是索引</h2>\n<p><strong>索引是一种数据结构，可以帮助我们快速查找数据</strong><br/> MySQL官方对索引的定义为:索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据 库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数 据结构上实现高级查找算法，这种数据结构就是索引。</p>\n<h2><a id=\"_14\"></a>索引都有哪些数据结构</h2>\n<p>索引可能有三种数据结构哈希表、有序数组和N叉树。MySQL索引使用的是B+树（InnoDB存储引擎）</p>\n<h2><a id=\"_16\"></a>索引的原理</h2>\n<p>索引的原理<br/> 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。<br/> 换句话说，<strong>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数</strong>。<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/07a05fe84b414628bd2a1c580f4a1528.gif#pic_center\"/></p>\n<h2><a id=\"_22\"></a>索引底层是怎么实现的</h2>\n<h3><a id=\"Hash_23\"></a>Hash索引</h3>\n<p>哈希索引是采用一定的哈希算法，将键值换算成新的哈希值，映射到对应的槽位上，然后存储在hash表中。<br/> 如果两个或多个键值，映射到一个相同的槽位上，他们就会产生<strong>Hash冲突</strong>，也叫<strong>Hash碰撞</strong>，可以通过链表来解决。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1e4291f6cdae44dfa5d6dafc6f5c9e44.png\"/><br/> Hash索引特点</p>\n<blockquote>\n<p>优点：<br/> <strong>查询效率高</strong>，在没有产生hash冲突的情况下，通常只需要一次检索就可以了，效率通常要高于B+树索引。<br/> 缺点：<br/> 1.Hash索引只能用于对等比较(=，in)，不支持范围查询(between，&gt;，&lt;,…），<strong>即无法进行大小比较</strong><br/> 2.无法利用索引完成排序操作（Hash索引是<strong>无序排列</strong>的）<br/> 存储引擎支持<br/> 在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能（利用方法将b+树索引转化为hash索引），hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p>\n</blockquote>\n<h3><a id=\"_36\"></a>二叉树索引</h3>\n<p>二叉树索引分为左子树，右子树，根节点，左子树要比根节点小，右子树要比根节点大</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4df0301d57d64d2db2c2886097179d56.png\"/></p>\n<blockquote>\n<p>二叉树缺点：顺序插入时，会形成一个链表（如右图），查询性能大大降低。很多数据量的情况下，层次较深，检索速度慢。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/a80952954a0043a78ed23c05e754f610.gif#pic_center\"/></p>\n<h3><a id=\"_46\"></a>平衡二叉树</h3>\n<p>特点：<br/> 它的左子树和右子树都是平衡二叉树<br/> 左子树比中间小，右子树比中间值大<br/> 左子树和右子树的深度之差的绝对值不超过1<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1eacece6c22b4464a6895ff64ac9d203.png\"/><br/> 缺点</p>\n<blockquote>\n<p>缺点：<br/> a、插入操作需要旋转<br/> b、支持范围查询，但回旋查询效率较低，比如要查找大于8的，会回旋到父节点7、10。<br/> c、如果存放几百条数据的情况下，树高度越高，查询效率会越慢</p>\n</blockquote>\n<h3><a id=\"B_59\"></a>B树（多路平衡查找树）</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4ffaf7ef5e5443d28b04f57c2c3d17ae.png\"/></p>\n<p><strong>B树：叶子节点和非叶子节点都存储数据，数据结构为有序数组+平衡多叉树，也叫b-树。</strong><br/> m为树的叉数<br/> 每个节点最多有m-1个关键字(可以存有的键值对)。<br/> 根节点最少可以只有1个关键字。<br/> 非根节点至少有m/2个关键字。<br/> 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。<br/> 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。每个节点都存有索引和数据，也就是对应的key和value。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a27e0f0bd13a4ce486e656a55263e875.png\"/></p>\n<blockquote>\n<p>b树优点： 二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小<br/> <strong>树的每一个节点都包含key和value</strong>。<br/> 所以，经常访问的元素可能离根节点更近，<strong>把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率</strong>。</p>\n</blockquote>\n<blockquote>\n<p>缺点： 业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及 CPU 高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，<strong>现在却要多次才能加载完</strong>。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/16278dcb8e1946a59dc5de00cf4a9a9c.gif#pic_center\"/></p>\n<h3><a id=\"B_79\"></a>B+树</h3>\n<p>以m阶B+树为例<br/> 一个m阶的B+树具有如下几个特征：<br/> 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），<strong>每个元素不保存数据，只用来索引，所有数据都保存在叶子节点</strong>。<br/> <strong>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，<strong>且叶子结点本身依关键字的大小</strong>自小而大</strong>顺序链接。<br/> 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>\n<blockquote>\n<p>B+树只有叶子节点存储数据(B+数中有两个头指针：<strong>一个指向根节点，另一个指向关键字最小的叶节点</strong>)，叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e51d2c3b51e04e1aa8ef11da0e5bff40.png\"/></p>\n<h2><a id=\"BB_90\"></a>B+树优于B树原因</h2>\n<p>b+树的中间节点不保存数据，<strong>可以容纳更多的节点元素</strong><br/> 所有的叶子结点使用链表相连，<strong>有助于区间查找和遍历</strong><br/> B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会<strong>需要更多的内存置换次数</strong>，因此也就需要花费更多的时间</p>\n<p><strong>B树的话，就需要进行每一层的递归遍历</strong><br/> 相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/82388f58b3d64110949aa8bbd475e997.gif#pic_center\"/></p>\n<h2><a id=\"_101\"></a>什么是覆盖索引</h2>\n<p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。b+索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。</p>\n<blockquote>\n<p>1.覆盖索引是一种数据查询方式，不是索引类型<br/> 2.在索引数据结构中，通过索引值可以直接找到要查询字段的值，而<strong>不需要通过主键值回表查询</strong>，那么就叫覆盖索引<br/> 3.查询的字段被使用到的索引树全部覆盖到</p>\n</blockquote>\n<p>举个栗子：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5d330fb19e614058b11eee748d53c5d7.png\"/><br/> 在上图中，id为主键索引，name为唯一索引<br/> 假如你执行命令</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span>name <span class=\"token keyword\">from</span> eclass <span class=\"token keyword\">where</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>此时由于id和name字段都在索引树中，所以这就是覆盖索引查询</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d2bdf7d2838b44e9979343c462fc9e1b.png\"/></p>\n<h2><a id=\"_121\"></a>什么是聚簇索引</h2>\n<p>聚簇索引是物理索引，数据表就是按顺序存储的，物理上是连续的。<br/> <strong>一般情况下主键会默认创建聚簇索引</strong><br/> 将索引与数据放在一起，当你找到索引后，也就找到对应的数据了。<strong>每张表只能建立一个聚簇索引</strong>，但是该索引可以包含多个列（一般使用的是主键等不经常更新的列）</p>\n<p>非聚簇索引：数据储存于索引分开，叶节点指向了对应的数据行。辅助索引访问数据时需要二次查找。<strong>辅助索引存储的不是行的物理位置，而是主键的值</strong>。而通过辅助索引首先找到的就是主键的值，再通过主键的值找到数据行对应的数据页，最后才能找到对应行。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6711e440890d4e84aabd5d6b0a7249c4.png\"/></p>\n<h2><a id=\"_128\"></a>联合索引</h2>\n<p>我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过<strong>联合索引的健值数量不是一个，而是多个</strong>。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引<strong>最左的字段</strong>来构建B+树。使用联合索引，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。。<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/425f3249821640b1b643d154edfe02a6.gif#pic_center\"/></p>\n<h2><a id=\"_132\"></a>最左匹配原则</h2>\n<p>顾名思义：<strong>最左优先</strong>，以最左边的为起点任何连续的索引都能匹配上。<strong>同时遇到范围查询(&gt;、&lt;、between、like)就会停⽌匹配</strong>。<br/> mysql创建复合索引的规则是⾸先对复合索引最左边的字段的数据进⾏排序，在此基础上，再对后⾯的字段进⾏排序，这样第⼀个字段是绝对有序的，后⾯的字段就是⽆序的了，<strong>⼀般情况下第⼆个字段进⾏条件判断是⽤不到索引的</strong>，可能出现type是index类型的，这就是mysql 最左前缀的原因。<br/> 举个栗子：假设创建了顺序为（a，b，c）的索引<br/> 1.当查询条件为a=1 and b=1 或b=1 and a=1（查询优化器会调换a与b的位置），这时候都可以走索引。<br/> 当查询条件为a=1 and b&gt;1 and c=1 时 ，由于是范围查找，a和b走索引，c不走索引<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/f8e2f4b92968461d9e6ab403a0eddb65.gif#pic_center\"/></p>\n<h2><a id=\"_140\"></a>创建索引的原则</h2>\n<p>创建索引，肯定是有利于我们的查询效率的，如果无效地创建索引，只会浪费我们的内存和执行程序的效率，因此创建索引是有原则的</p>\n<blockquote>\n<p>首先应考虑对where 和 order by 涉及到的列上建立索引<br/> 对一个存在大量更新操作的表，所建索引的数目一般不超过3个，最多不超过5个，<strong>索引虽说提高了访问速度，但太多索引会影响数据的更新操作,并且索引本身会占用存储空间</strong>。<br/> 建立唯一索引。唯一索引能够更快速地帮助我们进行数据定位；<br/> <strong>为经常需要进行查询操作的字段建立索引</strong>；<br/> <strong>更新频繁的列不宜设置索引，索引列不能参与计算</strong><br/> 数据量小的表不要使用索引<br/> <strong>重复数据多的字段不宜设置索引</strong>，如性别男和女。<br/> 在建立索引的时候，要<strong>考虑索引的最左匹配原则</strong>（在使用SQL语句时，如果where部分的条件不符合最左匹配原则，可能导致索引失效，或者不能完全发挥建立的索引的功效）；<br/> 如果建立的单个索引查询数据很多，查询得到的数据的区分度不大，则考虑建立合适的联合索引；<br/> 尽量考虑字段值长度较短的字段建立索引，<strong>如果字段值太长，会降低索引的效率</strong></p>\n</blockquote>\n<h2><a id=\"_154\"></a>创建索引的优缺点</h2>\n<p>优点</p>\n<ol><li>大大加快数据的查询速度</li><li>使用分组和排序进行数据查询时，可以显著减少查询时分组和排序的时间</li><li>创建唯一索引，能够保证数据库表中每一行数据的唯一性</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol>\n<p>缺点</p>\n<ol><li>创建索引和维护索引需要消耗时间并且随着数据量的增加，时间也会增加</li><li>索引需要占据磁盘空间</li><li>对数据表中的数据进行增加，修改，删除时，索引也要动态的维护，降低了维护的速度</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/0832fc8a614f4633b17080b867c68953.gif#pic_center\"/></p>\n<h1><a id=\"MySQL_171\"></a>MySQL存储引擎</h1>\n<p>数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建、查询、更新和删除数据。<br/> 不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。<strong>MySQL的核心就是存储引擎</strong>。<br/> 用户可以根据不同的需求为数据表选择不同的存储引擎<br/> 可以使用 <strong>SHOW ENGINES命令</strong> 可以查看Mysql的所有执行引擎我们 可以到默认的执行引擎是innoDB支持事务，行级锁定和外键。<br/> <strong>MySQL默认的存储引擎是InnoDB</strong>。</p>\n<h2><a id=\"_177\"></a>分类</h2>\n<ol><li>MylSAM：Mysql 5.5之前的默认数据库引擎，最为常用。<strong>拥有较高的插入，查询速度，但不支持事务</strong></li><li>InnoDB：事务型速记的首选引擎，支持ACID事务，支持行级锁定，MySQL5.5成为默认数据库引擎</li><li>Memory:所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在MYSQL重新启动是会丢失。</li><li>Archive：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差</li><li>Federated:将不同的MySQL服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用</li><li>CSV：逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.csv文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引。</li><li>BlackHole：黑洞引擎，写入的任何数据都会消失，一般用于记录 binlog做复制的中继</li><li>ERFORMANCE_SCHEMA存储引擎该引擎主要用于收集数据库服务器性能参数。</li><li>Mrg_Myisam Merge存储引擎，是一组Mylsam的组合，也就是说，他将Mylsam引擎的多个表聚合起来，但是他的内部没有数据，真正的数据依然是Mylsam引擎的表中，但是可以直接进行查询、删除更新等操作。<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/1ec7d14d4a924b9cb5306c078a742e3a.gif#pic_center\"/></li></ol>\n<h2><a id=\"InnoDB__MylSAM_189\"></a>InnoDB 和 MylSAM存储引擎区别</h2>\n<ol><li><strong>InnoDB支持事务，MyISAM不支持</strong>，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</li><li>MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</li><li><strong>InnoDB支持外键，MyISAM不支持</strong></li><li>从MySQL5.5.5以后，InnoDB是默认引擎</li><li>InnoDB不支持FULLTEXT类型的索引</li><li>InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表</li><li>对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引</li><li>清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表</li><li><strong>InnoDB支持行锁</strong>（某些情况下还是锁整表）</li></ol>\n<p>图片表示</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c0e2fba8cf6149e9934b56a708e09bd0.png\"/></p>\n<h1><a id=\"MySQL_204\"></a>MySQL事务</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/2d2b93e2da8245ee8bb7923432b6567c.gif#pic_center\"/></p>\n<h2><a id=\"_207\"></a>什么是事务</h2>\n<p>在MySQL中的事务Transaction是由<strong>存储引擎</strong>实现的，在MySQL中，<strong>只有InnoDB存储引擎才支持事务。</strong><br/> 事务处理可以用来维护数据库的完整性，保证成批的SQL语句<strong>要么全部执行，要么全部不执行</strong>。事务用来管理DDL、DML、DCL操作，比如insert，update，delete语句，默认是自动提交的。</p>\n<h2><a id=\"_210\"></a>事务操作</h2>\n<p><strong>开启事务：Start Transaction</strong><br/> 任何一条DML语句(insert、update、delete)执行，标志事务的开启命令：BEGIN或 START TRANSACTION<br/> <strong>提交事务：Commit Transaction</strong><br/> 成功的结束，将所有的DML语句操作历史记录和底层硬盘数据来一次同步命令：COMMIT<br/> <strong>回滚事务：Rollback Transaction</strong><br/> 失败的结束，将所有的DML语句操作历史记录全部清空<br/> 命令：ROLLBACK</p>\n<blockquote>\n<p>set autocommit =0 禁止自动提交事务<br/> set autocommit =1 开启自动提交事务</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/c33af4c3c34846f4ae450231ba1f44ce.gif#pic_center\"/></p>\n<h2><a id=\"_224\"></a>事务的特性</h2>\n<ol><li>原子性（Atomicity）：事务是一个不可分割的整体，事务开始后的所有操作，要么全部完<br/> 成，要么全部不做</li><li>一致性（Consistency）：系统从一个正确的状态，迁移到另一个正确的状态</li><li>隔离性（Isolation）：每个事务的对象对其他事务的操作对象互相分离，事务提交前对其<br/> 他事务不可见</li><li>持久性（Durability）：事务一旦提交，则其结果是永久性的</li></ol>\n<h2><a id=\"_232\"></a>事务的隔离级别</h2>\n<p>读未提交(Read uncommitted)<br/> 一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证，<strong>会造成脏读</strong>。<br/> 读已提交(Read committed)<br/> 一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生，<strong>会造成不可重复读</strong>。<br/> 可重复读(Repeatable read) I<br/> 就是在开始读取数据(事务开启)时，不再允许修改操作，可避免脏读、不可重复读的发生，<strong>但是会造成幻读</strong>。<br/> 串行(Serializable)<br/> 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，<strong>可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用</strong>。</p>\n<p><strong>Mysql的默认隔离级别是Repeatable read （可重复读）。</strong></p>\n<ol><li>脏读：<strong>强调的是第二个事务读到的数据不够新</strong><br/> 栗子：假设老板今天给你发这个月的工资，本来要给你发2w元，结果手一抖发了20w元，这时老板还没有提交事务，而你查询到你的账户里多了20w元，老板总觉得不对劲，总感觉少了些什么，最后发现后回滚事务，给你发了2w，然后这时你打开账户发现只有2w块钱。</li><li>不可重复读：<strong>同一事务，两次读取到的数据不一样</strong><br/> 栗子：前提同第一个，老板给你发了2w元工资，你看到账户里多了2w块钱，此时老板觉得你这个月做的还不错，给你加了1w块钱奖励金并提交了事务，而此时你再次查询时发现是3w块钱，<strong>这就造成了在一个事务中读取到的事务不一致</strong>。</li><li>幻读：<strong>重点在于新增或删除</strong>，同样的条件，第一次和第二次读出来的记录数不一样<br/> 栗子：和你相同薪资的人有10人，此时读数据读到的事务为10人，此时突然增加了一条工资和你们一样的人，提交事务后记录为11人，因此产生了幻读。</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/a994411a555444d8ade1bd76b129887e.gif#pic_center\"/></p>\n<h1><a id=\"MySQL__253\"></a>MySQL 锁机制</h1>\n<p>锁是计算机协调多个进程或线程并发访问某一资源的机制(<strong>避免争抢</strong>)。<br/> 在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>\n<p>从对数据操作的粒度分：<br/> 1.表锁：<strong>操作时，会锁定整个表</strong>。<br/> 2.行锁：<strong>操作时，会锁定当前操作行</strong>。<br/> 从对数据操作的类型分：<br/> 1.读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br/> 2.写锁(排它锁)：当前操作没有完成之前，它会阻断其他写锁和读锁。</p>\n<p><strong>其中，InnoDB表锁和行锁都支持，而MyISAM只支持表锁</strong></p>\n<h2><a id=\"MySQL_265\"></a>MySQL锁的特性</h2>\n<p>表级锁 <strong>偏向MyISAM存储引擎</strong>，开销小，加锁快不会出现死锁：锁定粒度大，发生锁冲突的概率最高，并发度最低。<br/> 行级锁 <strong>偏向InnoDB存储引擎</strong>，开销大，加锁慢；会出现死；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br/> 从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：<strong>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用</strong>，如Web应用；<br/> 而<strong>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用</strong>，如一些在线事务处理(OLTP)系统。</p>\n<h2><a id=\"_271\"></a>如何加锁</h2>\n<p>MyISAM表锁<br/> MyISAM存储引擎只支持表锁<br/> 如何加表锁<br/> MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，<strong>因此，用户一般不需要直接用LOCK TABLE 命令给MyISAM表显式加锁</strong>。<br/> 加读锁： <code>lock table table_name read;</code><br/> 加写锁：<code>lock table table_name write;</code></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a37cfaa9c0cb4d33ad9db229b779ee81.png\"/></p>\n<p>InnoDB行锁：<br/> 行锁特点：<strong>偏向InnoDB存储引擎</strong>，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br/> <strong>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</strong><br/> 行锁模式：<br/> InnoDB 实现了以下两种类型的行锁。<br/> 共享锁(S) 又称为读锁，简称S锁，<strong>共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</strong><br/> 排他锁（X） 又称为写锁，简称x锁，<strong>排他锁就是不能与其他锁并存</strong>，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。<br/> <strong>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁(X)；</strong><br/> <strong>对于普通SELECT语句，InnoDB不会加任何锁；</strong><br/> 共享锁（S）：<code>SELECT ★ FROM table name WHERE ... LOCK IN SHARE MODE</code><br/> 排他锁（X）：<code>SELECT ★ FROM table name WHERE ... FOR UPDATE</code></p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/547fdefefee74b129fd450f67fdf3eae.gif#pic_center\"/></p>\n<h2><a id=\"_295\"></a>死锁</h2>\n<p>死锁是指<strong>两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</strong><br/> 常见的解决死锁的方法</p>\n<ol><li> <p>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p> </li><li> <p>在同一个事务中，<strong>尽可能做到一次锁定所需要的所有资源</strong>，减少死锁产生概率；</p> </li><li> <p><strong>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率</strong>；</p> </li></ol>\n<p>另外，死锁问题我在最近发布的操作系统文章中也详细记录过，如果想要详细了解的朋友可以去看看哟（附地址：https://blog.csdn.net/qq_53847859/article/details/124286503?spm=1001.2014.3001.5501）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\544d7470ded242158a2e39c045520a1f.png\"/></p>\n<p>文章到这里就先结束了，这里主要记录了<strong>MySQL索引，事务，存储引擎，锁相关的知识点</strong>，以后还会持续更新其他的与MySQL相关的知识点和面试题。<br/> <strong>以上文章中如果有什么不对的，不合理的地方或需要改进的地方，还请大佬留言指正哦</strong>。<br/> 制作不易，还望各位大佬多多支持哟~~<br/> <strong>再次谢谢大家</strong><br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/e8b0f592e0fc4ece8b5ecffb866f96a4.gif#pic_center\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-04-28 09:49:30", "summary": "前言：首先很感谢各位小伙伴对我上一篇文章的支持，给我的创作带来了很大的动力。其次最近要考试高级这个课程了，这块内容也是面试中重要的考点，所以正好借此机会看了之前看过的网课笔记和网上的资料，记录一下面试"}