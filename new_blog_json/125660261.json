{"blogid": "125660261", "writerAge": "码龄1年", "writerBlogNum": "72", "writerCollect": "2074", "writerComment": "3544", "writerFan": "2876", "writerGrade": "6级", "writerIntegral": "6763", "writerName": "快到锅里来呀", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125660261.jpg", "writerRankTotal": "2565", "writerRankWeekly": "159", "writerThumb": "2566", "writerVisitNum": "59036", "blog_read_count": "1267", "blog_time": "于 2022-07-09 09:00:00 发布", "blog_title": "深入理解栈（Stack）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A6%82%E5%BF%B5\">1. 栈（Stack）之概念</a></p>\n<p id=\"2.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#2.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2. 栈（Stack）之模拟实现</a></p>\n<p id=\"3.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8\">3. 栈（Stack）之使用</a></p>\n<p id=\"4.%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">4.栈（Stack）之使用场景</a></p>\n<p id=\"4.1%20%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%20%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97\">4.1 改变元素的序列</a></p>\n<p id=\"4.2%20%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%20%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF\">4.2 将递归转化为循环</a></p>\n<p id=\"4.3%C2%A0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D-toc\" style=\"margin-left:40px;\"><a href=\"#4.3%C2%A0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D\">4.3 括号匹配</a></p>\n<p id=\"4.4%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-toc\" style=\"margin-left:40px;\"><a href=\"#4.4%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC\">4.4 逆波兰表达式求值</a></p>\n<p id=\"4.5%20%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E6%AC%A1%E5%BA%8F%E5%8C%B9%E9%85%8D-toc\" style=\"margin-left:40px;\"><a href=\"#4.5%20%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E6%AC%A1%E5%BA%8F%E5%8C%B9%E9%85%8D\">4.5 出栈入栈次序匹配</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A6%82%E5%BF%B5\"><span style=\"color:#ff9900;\">1. 栈（Stack）之概念</span></h1>\n<p><span style=\"color:#0d0016;\"><strong>首先明确：</strong></span></p>\n<blockquote>\n<p><span style=\"color:#38d8f0;\"><strong>栈是一种</strong></span><span style=\"color:#fe2c24;\"><strong>特殊的线性表</strong></span><span style=\"color:#38d8f0;\"><strong>，它特殊在只能在</strong></span><span style=\"color:#fe2c24;\"><strong>一端进行插入删除操作</strong></span><span style=\"color:#38d8f0;\"><strong>，并且最重要的是</strong></span><span style=\"color:#fe2c24;\"><strong>先进后出</strong></span></p>\n</blockquote>\n<p><img alt=\"\" height=\"358\" src=\"..\\..\\static\\image\\89eb55bf018b4401ad9524f887a2ea31.png\" width=\"881\"/></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>（1）栈顶：进行数据插入和删除操作的一端 </strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>（2）栈顶：栈顶的另一端</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>（3）入栈：栈的插入操作，也叫做压栈/进栈，</strong></span><span style=\"color:#0d0016;\"><strong>入数据在栈顶</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>（4）出站：栈的删除操作，</strong></span><span style=\"color:#0d0016;\"><strong>出数据也在栈顶</strong></span></p>\n</blockquote>\n<p><span style=\"color:#ff9900;\"><strong> 下面理解一下，</strong></span><span style=\"color:#a2e043;\"><strong>先进后出</strong></span><span style=\"color:#ff9900;\"><strong>，看图解</strong></span></p>\n<p><img alt=\"\" height=\"301\" src=\"..\\..\\static\\image\\bec27a5ba4724c7ab2ed630ba182024e.png\" width=\"1200\"/></p>\n<p>分析一下，</p>\n<p><span style=\"color:#ff9900;\"><strong>1. 栈是先进后出的，那么入栈和出栈的时间复杂度是多少</strong></span></p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>因为入栈和出栈的数据都是在栈顶进行操作的 ，所以</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>入栈时间复杂度O（1）  出栈时间复杂度O（1）</strong></span></p>\n</blockquote>\n<p><span style=\"color:#ff9900;\"><strong>2. 前面说的顺序存储的方式，那么栈的链式存储是什么样的</strong></span></p>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><strong> 假设栈是以单向链表存储，那么插入数据有头插和尾插</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>（1）入栈是尾插法，那么时间复杂度就是O（N）</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>         出栈，删除尾结点也是O（N）        </strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>（2）入栈是头插法，那么时间复杂度是O（1）从头结点插入不需要遍历链表</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>          出栈，删除头结点就是O（1）        </strong></span></p>\n<p><span style=\"color:#a2e043;\"><strong>所以当栈的存储方式是链式时，并且是单链表，那么对比下来，</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>入栈就选头插法，出栈就删除头结点</strong></span></p>\n</blockquote>\n<p><span style=\"color:#ff9900;\"><strong>3. 如果是以双向链表来看做栈，那么从哪里入哪里出 </strong></span></p>\n<blockquote>\n<p><span style=\"color:#ff9900;\"><strong>（1）从头入栈，从头出栈</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>（2）从尾入栈，从尾出栈</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>两种时间复杂度都是O（1）因为双向链表有头结点和尾结点，两边入栈出栈都一样</strong></span></p>\n</blockquote>\n<hr/>\n<p></p>\n<h1 id=\"2.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\"><span style=\"color:#a2e043;\">2. 栈（Stack）之模拟实现</span></h1>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>栈继承了Vector，Vector和ArrayList类似，都是动态的顺序表，不过Vector的线程是安全的</strong></span></p>\n</blockquote>\n<p style=\"text-align:center;\"><span style=\"color:#a2e043;\"><img alt=\"\" height=\"400\" src=\"..\\..\\static\\image\\d53dd5de1429498bb5c312b22ca5dc5f.png\" width=\"565\"/></span></p>\n<p><span style=\"color:#956fe7;\"><strong>先写一个栈</strong></span></p>\n<pre><code class=\"language-java\">public int[] elem;\n    public int usedSize;\n\n    public static final int DEFAULT_CAPATI = 10;\n\n    public MyStack() {\n        elem = new int[DEFAULT_CAPATI];\n    }</code></pre>\n<p> <span style=\"color:#956fe7;\"><strong> 1.入栈push()</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>入栈前先要判断栈是否满的isFull()</strong></span></p>\n<pre><code class=\"language-java\">    public boolean isFull() {\n        if (usedSize == elem.length) {\n            return true;\n        }\n    return false;\n    }</code></pre>\n<pre><code class=\"language-java\">    public void push(int val) {\n        //判断栈满\n        if (isFull()) {\n            elem = Arrays.copyOf(elem,2*elem.length);\n        }\n        elem[usedSize] = val;\n        usedSize++;\n    }</code></pre>\n<p><span style=\"color:#956fe7;\"><strong>2.删除栈顶元素pos()</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>删除栈顶元素前，先判断栈空isEmpty()</strong></span></p>\n<pre><code class=\"language-java\">    public boolean isEmpty() {\n        return usedSize == 0;\n    }</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>如果栈是空的，还要写一个异常EmptyStackException</strong></span></p>\n<pre><code class=\"language-java\">public class EmptyStackException extends RuntimeException{\n    public EmptyStackException() {\n\n    }\n    public EmptyStackException(String msg) {\n        super(msg);\n    }\n}</code></pre>\n<pre><code>    public int pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException(\"栈是空的\");\n        }\n        int oldVal = elem[usedSize-1];\n        usedSize--;\n        return oldVal;\n    }</code></pre>\n<p> <span style=\"color:#956fe7;\"><strong>3.获取栈顶元素，不删除peek()</strong></span></p>\n<pre><code class=\"language-java\">    public int peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException(\"栈是空的\");\n        }\n        return elem[usedSize-1];\n    }</code></pre>\n<p><span style=\"color:#956fe7;\"><strong>4.获取中有效元素个数getUsedSize()</strong></span></p>\n<pre><code class=\"language-java\">    public int getUsedSize() {\n        return usedSize;\n    }</code></pre>\n<hr/>\n<p></p>\n<h1 id=\"3.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8\"><span style=\"color:#4da8ee;\">3. 栈（Stack）之使用</span></h1>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n        stack.push(2);\n        stack.push(3);\n        stack.push(4);\n        stack.push(7);\n        System.out.println(stack.size());\n        System.out.println(stack.peek());\n        stack.pop();\n        System.out.println(stack.pop());\n    }</code></pre>\n<hr/>\n<p> </p>\n<h1 id=\"4.%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span style=\"color:#956fe7;\">4.栈（Stack）之使用场景</span></h1>\n<h2 id=\"4.1%20%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97\"><span style=\"color:#fe2c24;\"><strong>4.1 改变元素的序列</strong></span></h2>\n<p><span style=\"color:#fe2c24;\"><strong>（1）先看牛客上的一道题</strong></span></p>\n<p><img alt=\"\" height=\"104\" src=\"..\\..\\static\\image\\43cc35cb78de49418b42bd6cfb7b3c8d.png\" width=\"453\"/> </p>\n<p> 分析一下 ，答案选C<img alt=\"\" height=\"583\" src=\"..\\..\\static\\image\\6c4e451be2964db399d0736210ee0f8b.png\" width=\"861\"/></p>\n<blockquote>\n<p><span style=\"color:#ff9900;\"><strong>（2） 若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（） </strong></span></p>\n<div>\n<span style=\"color:#ff9900;\"><strong>             A: 1,4,3,2      B: 2,3,4,1      C: 3,1,4,2       D: 3,4,2,1 </strong></span>\n</div>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong> 分析一下，答案选C</strong></span></p>\n<p><img alt=\"\" height=\"271\" src=\"..\\..\\static\\image\\b0e3f94a7f024a65a7bc50ee6cfb5e26.png\" width=\"1200\"/> </p>\n<blockquote>\n<div>\n<span style=\"color:#4da8ee;\"><strong>2.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出栈的顺序是（）。 </strong></span>\n</div>\n<div>\n<span style=\"color:#4da8ee;\"><strong>A: 12345ABCDE       B: EDCBA54321      C: ABCDE12345        D: 54321EDCBA </strong></span>\n</div>\n</blockquote>\n<div>\n<span style=\"color:#fe2c24;\"><strong>分析一下，答案选B</strong></span>\n</div>\n<p> <img alt=\"\" height=\"197\" src=\"..\\..\\static\\image\\5de33be05c294395958fafc436cf8ad2.png\" width=\"304\"/></p>\n<hr/>\n<p> </p>\n<h2 id=\"4.2%20%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF\"><span style=\"color:#ff9900;\">4.2 将递归转化为循环</span></h2>\n<p><span style=\"color:#ff9900;\"><strong>写一个逆序打印链表</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>（1）递归</strong></span></p>\n<pre><code class=\"language-java\">public class Demo01 {\n    static class Node{\n        public int val;\n        public Node next;\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n    public Node head;\n    public void printList(Node head) {\n        if (head == null) {\n            return;\n        }\n        if (head.next == null) {\n            System.out.print(head.val + \" \");\n            return;\n        }\n        printList(head.next);\n        System.out.print(head.val + \" \");\n    }\n}</code></pre>\n<p><span style=\"color:#4da8ee;\"><strong>（2）非递归实现</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>既然栈是先进后出的，那么可以将数字依次放进去，然后再pop取出栈顶元素，打印出来，这不就实现了逆序打印</strong></span></p>\n<pre><code class=\"language-java\">    public void printList2(Node head) {\n        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();\n        Node cur = head;\n        //将元素全部依次放入栈中\n        while(cur != null) {\n            stack.push(cur);\n            cur = cur.next;\n        }\n        //给栈pop取出栈顶元素然后拿出val打印\n        while(!stack.empty()) {\n            Node top = stack.pop();\n            System.out.println(top.val + \" \");\n        }\n    }</code></pre>\n<hr/>\n<h2 id=\"4.3%C2%A0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D\"><span style=\"color:#a2e043;\">4.3</span><span style=\"color:#4da8ee;\"> </span><span style=\"color:#a2e043;\">括号匹配</span></h2>\n<p><span style=\"color:#ff9900;\"><strong>链接</strong></span><span style=\"color:#a2e043;\">   </span><a href=\"https://leetcode.cn/problems/valid-parentheses/\" title=\"20. 有效的括号 - 力扣（LeetCode）\">20. 有效的括号 - 力扣（LeetCode）</a></p>\n<p><span style=\"color:#ff9900;\"><strong>题目要求</strong></span></p>\n<p><img alt=\"\" height=\"196\" src=\"..\\..\\static\\image\\454a30e1f20045d4a3fef23931ba49cb.png\" width=\"697\"/></p>\n<p><span style=\"color:#ff9900;\"><strong>分析一下</strong></span></p>\n<p><img alt=\"\" height=\"403\" src=\"..\\..\\static\\image\\5ad6eaf3dc614400b46e40951e289e6e.png\" width=\"949\"/></p>\n<p> <span style=\"color:#ff9900;\"><strong>上代码</strong></span></p>\n<pre><code class=\"language-java\">class Solution {\n    public boolean isValid(String s) {\n        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n        for(int i = 0; i &lt; s.length(); i++ ) {\n            char ch = s.charAt(i);\n            if(ch == '(' || ch == '[' || ch == '{') {\n                stack.push(ch);\n            }else {\n                //此时ch 是右括号\n                //说明走到右边括号了\n                if(stack.empty()) {\n                    //遇到有括号了，但是栈空了，说明1.右括号多\n                    return false;\n                }\n                char top = stack.peek();\n                if(ch == ')' &amp;&amp; top == '(' || ch == ']' &amp;&amp; top == '[' || ch == '}' &amp;&amp; top == '{') {\n                    //说明当前字符是匹配的\n                    stack.pop();\n                }else {\n                    //2.左右括号不匹配\n                    return false;\n                }\n            }\n        }\n        if(stack.empty()) {\n            return true;\n        }else {\n            //3.说明是左括号多\n            return false;\n        }\n    }\n}</code></pre>\n<hr/>\n<p> </p>\n<h2 id=\"4.4%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC\"><span style=\"color:#4da8ee;\">4.4 逆波兰表达式求值</span></h2>\n<p>链接<a href=\"https://leetcode.cn/problems/evaluate-reverse-polish-notation/\" title=\" 150. 逆波兰表达式求值 - 力扣（LeetCode）\"> 150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p>\n<p>在说这道题前先明白<span style=\"color:#fe2c24;\"><strong> 逆波兰表达式又叫做后缀表达式</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>（1）后缀表达式又可以通过中缀表达式来转化出来（考研-选择题）</strong></span></p>\n<p><img alt=\"\" height=\"328\" src=\"..\\..\\static\\image\\066fb4755471490b946b9603cbfb67ae.png\" width=\"440\"/></p>\n<p><span style=\"color:#ff9900;\"><strong> </strong></span><span style=\"color:#956fe7;\"><strong>所以中缀变后缀三步走</strong></span></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>（1）按规则加括号  （2）将运算符放括号外面  （3）去掉所有括号</strong></span></p>\n</blockquote>\n<p><span style=\"color:#ff9900;\"><strong>（2）后缀表达式计算结果（代码题）</strong></span></p>\n<p><img alt=\"\" height=\"523\" src=\"..\\..\\static\\image\\49f1fe4d14e24619ba233f14a75ff7f5.png\" width=\"1055\"/></p>\n<p><span style=\"color:#ff9900;\"><strong>后缀计算4步走</strong></span></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>（1）将数字按顺序依次放入栈中</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>（2）遇到运算符后，拿出栈顶两个元素</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>（3）按这样的规则计算（ 次栈顶元素 运算符  栈顶元素  ）</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>（4）将计算的结果，继续放入栈中，继续执行前面操作</strong></span></p>\n</blockquote>\n<p> 好了，下面看一下这道题</p>\n<p><img alt=\"\" height=\"202\" src=\"..\\..\\static\\image\\47219a0d83f14cff82d5434ae6aa48f5.png\" width=\"566\"/></p>\n<p><span style=\"color:#ff9900;\"><strong>根据前面的后缀计算4步走验证一下这个例子</strong></span></p>\n<p><img alt=\"\" height=\"186\" src=\"..\\..\\static\\image\\988ca94b37014a2187b019b64dc35754.png\" width=\"424\"/></p>\n<p> </p>\n<pre><code class=\"language-java\">class Solution {\n    public int evalRPN(String[] tokens) {\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n        for(String x : tokens) {\n            if(!isOperation(x)) {\n                //不是加减乘除\n                //字符转成整数.放进栈中\n                stack.push(Integer.parseInt(x));\n            }else {\n                int num2 = stack.pop();\n                int num1 = stack.pop();\n                switch(x) {\n                    case \"+\": stack.push(num1 + num2);\n                    break;\n                    case \"-\": stack.push(num1 - num2);\n                    break;\n                    case \"*\": stack.push(num1 * num2);\n                    break; \n                    case \"/\": stack.push(num1 / num2);\n                    break;\n                }\n            }\n        }\n        return stack.pop();\n    }\n\n    private boolean isOperation(String opera) {\n        if(opera.equals(\"+\") || opera.equals(\"-\") || opera.equals(\"*\") || opera.equals(\"/\")) {\n            return true;\n        }\n        return false;\n    }\n}</code></pre>\n<p> </p>\n<hr/>\n<h2 id=\"4.5%20%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E6%AC%A1%E5%BA%8F%E5%8C%B9%E9%85%8D\"><span style=\"color:#956fe7;\">4.5 出栈入栈次序匹配</span></h2>\n<p><span style=\"color:#ff9900;\"><strong>链接</strong></span> <a href=\"https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking\" title=\"栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)\">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a></p>\n<p><span style=\"color:#ff9900;\"><strong>题目要求：</strong></span></p>\n<p><img alt=\"\" height=\"431\" src=\"..\\..\\static\\image\\c0a58d8be1e54551b2e6ca338d606796.png\" width=\"761\"/></p>\n<p><span style=\"color:#ff9900;\"><strong>分析一下</strong></span></p>\n<p><img alt=\"\" height=\"340\" src=\"..\\..\\static\\image\\0c2d1ce262364acabc207c394dd6e030.png\" width=\"437\"/></p>\n<p><span style=\"color:#ff9900;\"><strong> 上代码 </strong></span></p>\n<pre><code class=\"language-java\">import java.util.*;\nimport java.util.ArrayList;\n\npublic class Solution {\n    public boolean IsPopOrder(int [] pushA,int [] popA) {\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n        int j = 0;\n      for(int i = 0; i &lt; pushA.length; i++) {\n          stack.push(pushA[i]);\n          while(j &lt;popA.length &amp;&amp; !stack.empty() &amp;&amp; stack.peek().equals(popA[j])) {\n              stack.pop();\n              j++;\n          }\n      }\n    return stack.empty();\n    }\n}</code></pre>\n<hr/>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-09 09:00:00", "summary": "目录栈之概念栈之模拟实现栈之使用栈之使用场景改变元素的序列将递归转化为循环括号匹配逆波兰表达式求值出栈入栈次序匹配栈之概念首先明确：栈是一种特殊的线性表，它特殊在只能在一端进行插入删除操作，并且最重要"}