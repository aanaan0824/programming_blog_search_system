{"blogid": "124289334", "writerAge": "码龄2年", "writerBlogNum": "19", "writerCollect": "21", "writerComment": "4", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "209", "writerName": "冷练", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124289334.jpg", "writerRankTotal": "112324", "writerRankWeekly": "583953", "writerThumb": "5", "writerVisitNum": "7245", "blog_read_count": "816", "blog_time": "于 2022-04-20 09:22:39 发布", "blog_title": "C# 序列化（Serialize）与反序列化（Deserialize）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>一、序列化的概念 </strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#002060;\"><strong>序列化就是把一个对象保存到一个文件或数据库字段中去，反序列化就是在适当的时候 </strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#002060;\"><strong>把这个文件再转化成原来的对象使用。</strong></span></strong><strong> </strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">需要分清楚的概念：对象的序列化而不是类的序列化。对象的序列化表明C#提供了将 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">运行中的对象（实时数据）写入到硬盘文件或者数据库中，此功能可以运用在需要保留 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">程序运行时状态信息的环境下。 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>使用序列化有两个最重要的原因： </strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">一个原因是将对象的状态永久保存在存储媒体中，以便可以在以后重新创建精确的 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">副本； </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">另一个原因是通过值将对象从一个应用程序域发送到另一个应用程序域中。 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>前提：要将对象的类声明为可以序列化。 </strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">最主要的作用有： </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">1、在进程下次启动时读取上次保存的对象的信息 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">2、在不同的AppDomain或进程之间传递数据 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">3、在分布式应用系统中传递数据 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">序列化是把一个内存中的对象的信息转化成一个可以持久化保存的形式，以便于保存或 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">传输，序列化的主要作用是不同平台之间进行通信，常用的序列化有json、xml、文件 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">等，下面就逐个讲下这三种序列化的方法。 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>1、序列化为json </strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">C#中用于对象和json相互转换的原生类有两个：DataContractJsonSerializer和 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">JavaScriptSerializer，其中JavaScriptSerializer主要用于web的浏览器和服务器之间的通 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">信。这里主要讲DataContractJsonSerializer的使用，要使用 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">DataContractJsonSerializer，先要在项目中引用System.Runtime.Serialization。首先准备一个测试的类Book：</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">1 </span><span style=\"color:#aa5500;\">/* </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">2 </span><span style=\"color:#aa5500;\">[DataContract]指定该类型要定义或实现一个数据协定，并可由序列化程序（如 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#aa5500;\">System.Runtime.Serialization.DataContractSerializer）进行序列化。 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">3 </span><span style=\"color:#aa5500;\">[DataMember]当应用于类型的成员时，指定该成员是数据协定的一部分并可由 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#aa5500;\">System.Runtime.Serialization.DataContractSerializer进行序列化。 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">4 </span><span style=\"color:#aa5500;\">*/ </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">5</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">6 </span><span style=\"color:#000000;\">[DataContract] </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">7</span> <span style=\"color:#770088;\">public</span> <span style=\"color:#770088;\">class </span><span style=\"color:#0000ff;\">Book </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">8</span><span style=\"color:#000000;\"> { </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">9</span><span style=\"color:#000000;\"> [DataMember] </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">10</span> <span style=\"color:#770088;\">public </span><span style=\"color:#000000;\">int ID { </span><span style=\"color:#770088;\">get</span><span style=\"color:#000000;\">; </span><span style=\"color:#770088;\">set</span><span style=\"color:#000000;\">; } </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">11 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">12</span><span style=\"color:#000000;\"> [DataMember] </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">13</span> <span style=\"color:#770088;\">public </span><span style=\"color:#000000;\">string Name { </span><span style=\"color:#770088;\">get</span><span style=\"color:#000000;\">; </span><span style=\"color:#770088;\">set</span><span style=\"color:#000000;\">; } </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">14 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">15</span><span style=\"color:#000000;\"> [DataMember] </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">16</span> <span style=\"color:#770088;\">public </span><span style=\"color:#000000;\">float Price { </span><span style=\"color:#770088;\">get</span><span style=\"color:#000000;\">; </span><span style=\"color:#770088;\">set</span><span style=\"color:#000000;\">; } </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">17</span><span style=\"color:#000000;\"> } </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">然后先创建一个Book对象，实例化一个DataContractJsonSerializer实例，最后用该实例 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">的WriteObject()方法将对象写到流中，代码如下： </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">1 </span><span style=\"color:#770088;\">class </span><span style=\"color:#0000ff;\">Program </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">2 </span><span style=\"color:#000000;\">{ </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">3</span> <span style=\"color:#770088;\">static void </span><span style=\"color:#000000;\">Main(string[] args) </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">4</span><span style=\"color:#000000;\"> { </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">5</span> <span style=\"color:#aa5500;\">//创建一个Book对象 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">6</span><span style=\"color:#000000;\"> Book book = </span><span style=\"color:#770088;\">new </span><span style=\"color:#000000;\">Book() { ID = </span><span style=\"color:#116644;\">101</span><span style=\"color:#000000;\">, Name = </span><span style=\"color:#aa1111;\">\"C#程序设计\"</span><span style=\"color:#000000;\">, Price = </span><span style=\"color:#116644;\">79.5f</span><span style=\"color:#000000;\"> }; </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">7</span> <span style=\"color:#aa5500;\">//序列化json </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">8</span><span style=\"color:#000000;\"> DataContractJsonSerializer formatter= </span><span style=\"color:#770088;\">new </span><span style=\"color:#000000;\">DataContractJsonSerializer(</span><span style=\"color:#770088;\">typeof</span><span style=\"color:#000000;\">(Book)); </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">9</span> <span style=\"color:#770088;\">using</span><span style=\"color:#000000;\"> (MemoryStream stream = </span><span style=\"color:#770088;\">new </span><span style=\"color:#000000;\">MemoryStream()) </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">10</span><span style=\"color:#000000;\"> { </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">11</span><span style=\"color:#000000;\"> formatter.WriteObject(stream, book); </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">12</span><span style=\"color:#000000;\"> string result = </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">System.Text.Encoding.UTF8.GetString(stream.ToArray()); </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">13</span><span style=\"color:#000000;\"> Console.WriteLine(result); </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">14</span><span style=\"color:#000000;\"> } </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">15</span><span style=\"color:#000000;\"> } </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#999999;\">16 </span><span style=\"color:#000000;\">}</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>2、序列化为xml </strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">C#中将对象序列化和反序列化为xml的类是XmlSerializer，要引用 </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">System.Xml.Serialization </span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">先创建一个XmlSerializer对象实例，然后用实例的Serialize的方法将对象写入到文件流中</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">当然也可以将对象转换成对象流，然后转换成xml格式的字符串，</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">将xml文件反序列化的方法是用XmlSerializer实例的Deserialize()方法，</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">我们同样也可以把上面的xml序列化与反序列为封装成泛型方法，这样可以公用</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>3、序列化为文件</strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">C#中将对象序列化和反序列化为二进制文件的类是BinaryFormatter，要引用</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">System.Runtime.Serialization.Formatters.Binary</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">先创建一个BinaryFormatter对象实例，然后用实例的Serialize的方法将对象写入到文件</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">流中，程序执行完成后产生sbinary.txt文件</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">可以通过BinaryFormatter类型实例的Deserialize()方法把二进制文本反序列化为对象</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong><span style=\"color:#000000;\"><strong>4、序列化为文件</strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">C#中将对象序列化和反序列化为 SOAP 格式的类是SoapFormatter，要引用</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">System.Runtime.Serialization.Formatters.Soap</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">先创建一个SoapFormatter对象实例，然后用实例的Serialize的方法将对象写入到文件流</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">中，程序执行完成后产生ssoap.txt文件</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">可以通过SoapFormatter类型实例的Deserialize()方法把Soap反序列化为对象，</span></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#000000;\">我们同样也可以把序列化和反序列化为二进制文件的方法封装成泛型方法</span></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 1, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-04-20 09:22:39", "summary": "一、序列化的概念序列化就是把一个对象保存到一个文件或数据库字段中去，反序列化就是在适当的时候把这个文件再转化成原来的对象使用。需要分清楚的概念：对象的序列化而不是类的序列化。对象的序列化表明提供了将运"}