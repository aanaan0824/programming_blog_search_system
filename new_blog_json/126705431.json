{"blogid": "126705431", "writerAge": "码龄4年", "writerBlogNum": "262", "writerCollect": "481", "writerComment": "139", "writerFan": "889", "writerGrade": "6级", "writerIntegral": "5457", "writerName": "穿条秋裤到处跑", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126705431.jpg", "writerRankTotal": "3270", "writerRankWeekly": "902", "writerThumb": "184", "writerVisitNum": "442117", "blog_read_count": "83", "blog_time": "已于 2022-09-05 15:43:43 修改", "blog_title": "springSecurity认证逻辑调用链源码挖掘", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>springSecurity认证逻辑调用链源码挖掘</h3>\n<ul><li><a href=\"#_2\">引</a></li><li><a href=\"#UsernamePasswordAuthenticationFilter_11\">UsernamePasswordAuthenticationFilter</a></li><li><a href=\"#ProviderManager_22\">ProviderManager</a></li><li><a href=\"#DaoAuthenticationProvider_29\">DaoAuthenticationProvider</a></li><li><a href=\"#InMemoryUserDetailsManager_40\">InMemoryUserDetailsManager</a></li><li><a href=\"#_45\">总结</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_2\"></a>引</h1>\n<p>对应版本为5.7.2，不同版本间可能有或大或小的差异，整体思想应该大同小异。<br/> 先看总结出来的下图</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\da578ad0c67f4c64bbed6a8297824fe7.png\"/><br/> 在前面的内容我们提到，springSecurity是通过一系列的过滤器组成的过滤器链来实现的，而认证对应的UsernamePasswordAuthenticationFilter就是springSecurity核心的一环。<br/> 下面我们再从源码一步一步看具体的实现。</p>\n<h1><a id=\"UsernamePasswordAuthenticationFilter_11\"></a>UsernamePasswordAuthenticationFilter</h1>\n<p>在idea中双击Shift键，搜索并键入AbstractAuthenticationProcessingFilter</p>\n<p><img alt=\"UsernamePasswordAuthenticationFilter\" src=\"..\\..\\static\\image\\f86ba3d16c584227918416eb2eab4152.png\"/><br/> AbstractAuthenticationProcessingFilter类中没有Filter的入口doFilter，在父类AbstractAuthenticationProcessingFilter中。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3145d26586d64be581512e89eab7408a.png\"/><br/> UsernamePasswordAuthenticationFilter中重写了attemptAuthentication方法，将用户名密码封装成UsernamePasswordAuthenticationToken对象再调用ProviderManager的authenticate认证。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\24857de3ad1d4aadab6159db50e17ce9.png\"/></p>\n<h1><a id=\"ProviderManager_22\"></a>ProviderManager</h1>\n<p>ProviderManager实现了AuthenticationManager接口，根据接口的描述，该接口验证会进行身份验证，返回用户身份信息以及被授予的权限。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a413b0665db04da09a89578ec1ff0399.png\"/><br/> 在ProviderManager实现的authenticate中，遍历容器中的AuthenticationProvider，如果返回的result不为空则代表认证通过，再封装并返回认证信息。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c4a34d513f5445319282dc88f734ac3e.png\"/></p>\n<h1><a id=\"DaoAuthenticationProvider_29\"></a>DaoAuthenticationProvider</h1>\n<p>通过idea的提示信息，AuthenticationProvider的实现类中无法直接找到DaoAuthenticationProvider，后者是通过继承AbstractUserDetailsAuthenticationProvider，间接实现了AuthenticationProvider接口。</p>\n<p><img alt=\"AuthenticationProvider实现类\" src=\"..\\..\\static\\image\\304f37d6450f4626968f8efebd9118ef.png\"/><br/> 我们先看下面这段AbstractUserDetailsAuthenticationProvider中实现的逻辑</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0485b456e1a84741a4aa6658942972cb.png\"/><br/> 先通过this.userCache.getUserFromCache(username)查询用户信息，如果查询不到，再通过retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication)来match，实际debug发现是通过后者找到的，而后面这个方法是由DaoAuthenticationProvider实现的。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f33c5982e25642c8a2643c1f8467d434.png\"/></p>\n<h1><a id=\"InMemoryUserDetailsManager_40\"></a>InMemoryUserDetailsManager</h1>\n<p>InMemoryUserDetailsManager的逻辑就比较简单了，实现了UserDetailsService接口，含有成员属性private final Map&lt;String, MutableUserDetails&gt; users = new HashMap&lt;&gt;()，初始化的用户名密码信息就包含其中，其中key为username。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f20ad1c5f6da4496a68f7736926a7f6d.png\"/></p>\n<h1><a id=\"_45\"></a>总结</h1>\n<p>最后再回顾一下文章开头贴出的调用链路图可能会更加清晰一丢丢。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\da578ad0c67f4c64bbed6a8297824fe7.png\"/><br/> 整体来看可以分为三部分</p>\n<ul><li>一个是入口的Filter，UsernamePasswordAuthenticationFilter作为过滤器链的一环，提供了认证逻辑的入口；</li><li>ProviderManager提供了各个Provider来匹配并认证，直到有能够匹配上并认证通过有返回认证结果；</li><li>最后就是Provider提供的认证逻辑了，这部分有默认的，也可以自由发挥自己注入，方便项目中重写个性化的认证逻辑。</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 15:43:43", "summary": "认证逻辑调用链源码挖掘引总结引对应版本为，不同版本间可能有或大或小的差异，整体思想应该大同小异。先看总结出来的下图在这里插入图片描述在前面的内容我们提到，是通过一系列的过滤器组成的过滤器链来实现的，而"}