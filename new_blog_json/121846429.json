{"blogid": "121846429", "writerAge": "码龄5年", "writerBlogNum": "145", "writerCollect": "2227", "writerComment": "69", "writerFan": "26429", "writerGrade": "5级", "writerIntegral": "2710", "writerName": "Terence全栈开发", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121846429.jpg", "writerRankTotal": "8203", "writerRankWeekly": "462", "writerThumb": "1034", "writerVisitNum": "9018364", "blog_read_count": "107157", "blog_time": "于 2021-12-09 23:24:12 发布", "blog_title": "学习Spring框架这一篇就够了", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1. spring概述</h1>\n<p></p>\n<p></p>\n<h2>1.1 Spring是什么（理解）</h2>\n<p>Spring是分层的 Java SE/EE应用 full-stack（全栈的） 轻量级开源框架，以<span style=\"color:#fe2c24;\"> <strong>IOC</strong></span>（Inverse Of Control：控制反转）和 <span style=\"color:#fe2c24;\"><strong>AOP</strong></span>（Aspect Oriented Programming：面向切面编程）为内核。</p>\n<p>提供了<span style=\"color:#fe2c24;\"><strong>展现层 SpringMVC</strong></span>和<strong><span style=\"color:#fe2c24;\">持久层 Spring JDBCTemplate</span></strong>以及<strong><span style=\"color:#fe2c24;\">业务层事务管理</span></strong>等众多的企业应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架<br/>  </p>\n<h2>1.2 Spring发展历程 （了解）</h2>\n<p>1997年，IBM提出了EJB的思想<br/> 1998年，SUN制定开发标准规范EB1.0<br/> 1999年，EB1.1发布<br/> 2001年，EB2.0发布<br/> 2003年，EB2.1发布<br/> 2006年，EB3.0发布</p>\n<p><span style=\"color:#fe2c24;\"><strong>RodJohnson（Spring 之父）</strong></span></p>\n<p>Expert One-to-OneJ2EEDesign and Development（2002)<br/> 阐述了J2EE使用EB开发设计的优点及解决方室<br/> Expert One-to-OneJ2EE Developmentwithout EJB（2004）<br/> 阐述了J2EE开发不使用EJB的解决方式（Spring雏形）</p>\n<p><span style=\"color:#fe2c24;\"><strong>2017 年 9 月份发布了 Spring 的最新版本 Spring5.0 通用版（GA）</strong></span><br/>  </p>\n<h2>1.3 Spring的优势（理解）</h2>\n<h3><span style=\"color:#fe2c24;\"><strong>1.3.1 方便解耦，简化开发</strong></span></h3>\n<p>通过Spring 提供的IOC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用</p>\n<h3><span style=\"color:#fe2c24;\"><strong>1.3.2 AOP 编程的支持</strong></span></h3>\n<p>通过 Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能可以通过AOP轻松实现</p>\n<h3><span style=\"color:#fe2c24;\">1.3.3 声明式事务的支持</span></h3>\n<p>可以将我们从单调烦闷的事务管理代码中解脱出来，通讨声明式方式灵活的进行事务管理，提高开发效率和质量</p>\n<h3><span style=\"color:#fe2c24;\"><strong>1.3.4 方便程序的测试</strong></span></h3>\n<p>可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情</p>\n<h3><span style=\"color:#fe2c24;\"><strong>1.3.5 方便集成各种优秀框架</strong></span></h3>\n<p>Spring对各种优秀框架（Struts、Hibemate、Hessian、Quartz等）的支持</p>\n<h3><span style=\"color:#fe2c24;\"><strong>1.3.6 隆低JavaEE API的使用难度</strong></span></h3>\n<p>Spring对JaveEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低</p>\n<h3><span style=\"color:#fe2c24;\"><strong>1.3.7 Java 源码是经典学习范例</strong></span></h3>\n<p>Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例<br/>  </p>\n<h2>1.4 Spring的体系结构（了解）</h2>\n<p><img alt=\"\" height=\"461\" src=\"..\\..\\static\\image\\0fd8c209a32e40fa88dde97fd9678c14.png\" width=\"639\"/><br/>  </p>\n<h1>2. spring快速入门</h1>\n<h2>2.1 Spring程序开发步骤</h2>\n<p><img alt=\"\" height=\"889\" src=\"..\\..\\static\\image\\00568567fa7c49faac113e0bc7209d68.png\" width=\"1200\"/>①导入Spring 坐标<br/> ②创建Bean<br/> ③创建String核心配置文件 applicationContext.xml<br/> ④在Spring配置文件中配置Bean<br/> ⑤创建ApplicationContext对象，通过getBean方法获得Bean实例</p>\n<p></p>\n<h2>2.2 导入Spring开发的基本包坐标</h2>\n<pre><code class=\"language-XML\">&lt;properties&gt;\n    &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;\n&lt;/properties&gt;\n\n&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;\n&lt;dependencies&gt;\n     &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n       &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n       &lt;version&gt;${spring.version}&lt;/version&gt;\n     &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n<h2><br/> 2.3 编写Dao接口和实现类</h2>\n<pre><code class=\"language-java\">public interface UserDao {\n    public void save();\n}\n\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"UserDao save method running....\");\n    }\n}</code></pre>\n<h2><br/> 2.4 创建Spring核心配置文件</h2>\n<p>在类路径下（resources）创建applicationContext.xml配置文件</p>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n&lt;/beans&gt;</code></pre>\n<h2><br/> 2.5 在Spring配置文件中配置UserDaoImpl</h2>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n    \n    &lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;&lt;/bean&gt;\n    \n&lt;/beans&gt;</code></pre>\n<h2><br/> 2.6 使用Spring的API获得Bean实例</h2>\n<pre><code class=\"language-java\">public class UserDaoDemo {\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\");\n        userDao.save();\n    }\n}</code></pre>\n<h1><br/> 3. Spring配置文件</h1>\n<h2>3.1 Bean标签基本配置</h2>\n<p>用于配置对象交由Spring 来创建。<br/> 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p>\n<p>基本属性：<br/> id：Bean实例在Spring容器中的唯一标识<br/> class：Bean的全限定名称<br/>  </p>\n<h2>3.2 Bean标签范围配置</h2>\n<p>scope:指对象的作用范围，取值如下：</p>\n<table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例的</td></tr><tr><td>prototype</td><td>多例的</td></tr><tr><td>request</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中</td></tr><tr><td>session</td><td>WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中</td></tr><tr><td>global session</td><td>WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session</td></tr></tbody></table>\n<h3>3.2.1 当scope的取值为singleton时</h3>\n<p>Bean的实例化个数：1个<br/> Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</p>\n<p>Bean的生命周期：</p>\n<ul><li>对象创建：当应用加载，创建容器时，对象就被创建了</li><li>对象运行：只要容器在，对象一直活着</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul>\n<h3><strong>3.2.2 当scope的取值为prototype时</strong></h3>\n<p>Bean的实例化个数：多个<br/> Bean的实例化时机：当调用getBean()方法时实例化Bean</p>\n<ul><li>对象创建：当使用对象时，创建新的对象实例</li><li>对象运行：只要对象在使用中，就一直活着</li><li>对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了<br/>  </li></ul>\n<h2>3.3 Bean生命周期配置</h2>\n<p>init-method：指定类中的初始化方法名称</p>\n<p>destroy-method：指定类中销毁方法名称<br/>  </p>\n<h2>3.4 Bean实例化三种方式</h2>\n<h3><strong>3.4.1 使用无参构造方法实例化</strong></h3>\n<p>它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败</p>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;&lt;/bean&gt;</code></pre>\n<h3><strong>3.4.2 工厂静态方法实例化</strong></h3>\n<p>工厂的静态方法返回Bean实例</p>\n<pre><code class=\"language-java\">public class StaticFactory {\n    public static UserDao getUserDao() {\n        return new UserDaoImpl();\n    }\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.factory.StaticFactory\" factory-method=\"getUserDao\" /&gt;</code></pre>\n<h3><strong>3.4.3  工厂实例方法实例化</strong></h3>\n<p>工厂的非静态方法返回Bean实例</p>\n<pre><code class=\"language-java\">public class DynamicFactory {\n    public UserDao getUserDao() {\n        return new UserDaoImpl();\n    }\n}\n</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"factoryBean\" class=\"com.terence.factory.DynamicFactory\"/&gt;\n&lt;bean id=\"userDao\" factory-bean=\"factoryBean\" factory-method=\"getUserDao\"/&gt;</code></pre>\n<h2><br/> 3.5 Bean的依赖注入概念</h2>\n<p>依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p>\n<p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p>\n<p>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p>\n<p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。</p>\n<p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</p>\n<p>如下图：</p>\n<p><img alt=\"\" height=\"1099\" src=\"..\\..\\static\\image\\e09ebc66895c475f9432180df2b88ccf.png\" width=\"1200\"/></p>\n<p></p>\n<h2>3.6 Bean的依赖注入方式</h2>\n<h3><span style=\"color:#0d0016;\"><strong>3.6.1 构造方法</strong></span></h3>\n<p>创建有参构造</p>\n<pre><code class=\"language-java\">public class UserServiceImpl implements UserService {\n    private UserDao userDao;\n\n    public UserServiceImpl(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    @Override\n    public void save() {\n        userDao.save();\n    }\n}</code></pre>\n<p>配置Spring容器调用有参构造时进行注入</p>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"/&gt;\n&lt;bean id=\"userService\" class=\"com.terence.service.impl.UserServiceImpl\"&gt;\n    &lt;constructor-arg name=\"userDao\" ref=\"userDao\"&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;</code></pre>\n<p></p>\n<h3><span style=\"color:#0d0016;\"><strong>3.6.2 set方法</strong></span></h3>\n<p>在UserServiceImpl中添加setUserDao方法</p>\n<pre><code class=\"language-java\">public class UserServiceImpl implements UserService {\n    private UserDao userDao;\n    public void setUserDao(UserDao userDao){\n        this.userDao=userDao;\n    }\n    @Override\n    public void save() {\n        userDao.save();\n    }\n}</code></pre>\n<p>配置Spring容器调用set方法进行注入</p>\n<pre><code class=\"language-XML\">&lt;bean id=\"userService\" class=\"com.terence.service.impl.UserServiceImpl\"&gt;\n    &lt;property name=\"userDao\" ref=\"userDao\"&gt;&lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p>set方法:P命名空间注入</p>\n<p>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：</p>\n<p>首先，需要引入P命名空间：</p>\n<pre><code class=\"language-XML\">xmlns:p=\"http://www.springframework.org/schema/p\"</code></pre>\n<p>其次，需要修改注入方式</p>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"/&gt;\n&lt;bean id=\"userService\" class=\"com.terence.service.impl.UserServiceImpl\" p:userDao-ref=\"userDao\"&gt;&lt;/bean&gt;</code></pre>\n<h2><br/> 3.7 Bean的依赖注入的数据类型</h2>\n<p>上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p>\n<p>注入数据的三种数据类型</p>\n<ul><li>普通数据类型</li><li>引用数据类型</li><li>集合数据类型</li></ul>\n<p>其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p>\n<p><strong>Bean的依赖注入的数据类型</strong></p>\n<h3>3.7.1 普通数据类型的注入</h3>\n<pre><code class=\"language-java\">public class UserDaoImpl implements UserDao {\n    String username;\n    String age;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getAge() {\n        return age;\n    }\n\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"UserDaoImpl{\" +\n                \"username='\" + username + '\\'' +\n                \", age='\" + age + '\\'' +\n                '}';\n    }\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;\n    &lt;property name=\"username\" value=\"传智播客\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"15\"&gt;&lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<h3>3.7.2 集合数据类型（List&lt;String&gt;）的注入</h3>\n<pre><code class=\"language-java\">public class UserDaoImpl implements UserDao {\n\n    List&lt;String&gt; strList;\n    \n    public List&lt;String&gt; getStrList() {\n        return strList;\n    }\n\n    public void setStrList(List&lt;String&gt; strList) {\n        this.strList = strList;\n    }\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;\n    &lt;property name=\"strList\"&gt;\n        &lt;list&gt;\n            &lt;value&gt;aaa&lt;/value&gt;\n            &lt;value&gt;bbb&lt;/value&gt;\n            &lt;value&gt;ccc&lt;/value&gt;\n        &lt;/list&gt;\n     &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<h3>3.7.3 集合数据类型（List&lt;User&gt;）的注入</h3>\n<pre><code class=\"language-java\">public class UserDaoImpl implements UserDao {\n    List&lt;User&gt; userList;\n\n    public List&lt;User&gt; getUserList() {\n        return userList;\n    }\n\n    public void setUserList(List&lt;User&gt; userList) {\n        this.userList = userList;\n    }\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"u1\" class=\"com.terence.domain.User\"/&gt;\n&lt;bean id=\"u2\" class=\"com.terence.domain.User\"/&gt;\n&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;\n    &lt;property name=\"userList\"&gt;\n        &lt;list&gt;\n            &lt;bean class=\"com.terence.domain.User\"/&gt;\n            &lt;bean class=\"com.terence.domain.User\"/&gt;\n            &lt;ref bean=\"u1\"/&gt;\n            &lt;ref bean=\"u2\"/&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<h3>3.7.4 集合数据类型（ Map&lt;String,User&gt; ）的注入</h3>\n<pre><code class=\"language-java\">public class UserDaoImpl implements UserDao {\n    Map&lt;String, User&gt; userMap;\n\n    public Map&lt;String, User&gt; getUserMap() {\n        return userMap;\n    }\n\n    public void setUserMap(Map&lt;String, User&gt; userMap) {\n        this.userMap = userMap;\n    }\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"u1\" class=\"com.terence.domain.User\"&gt;\n    &lt;property name=\"name\" value=\"tom\"/&gt;\n    &lt;property name=\"addr\" value=\"beijing\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"u2\" class=\"com.terence.domain.User\"&gt;\n    &lt;property name=\"name\" value=\"lucy\"/&gt;\n    &lt;property name=\"addr\" value=\"tianjin\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;\n    &lt;property name=\"userMap\"&gt;\n        &lt;map&gt;\n            &lt;entry key=\"user1\" value-ref=\"u1\"&gt;&lt;/entry&gt;\n            &lt;entry key=\"user2\" value-ref=\"u2\"&gt;&lt;/entry&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p></p>\n<h3>3.7.5 集合数据类型（Properties）的注入</h3>\n<pre><code class=\"language-java\">public class UserDaoImpl implements UserDao {\n    Properties properties;\n\n    public Properties getProperties() {\n        return properties;\n    }\n\n    public void setProperties(Properties properties) {\n        this.properties = properties;\n    }\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;bean id=\"userDao\" class=\"com.terence.dao.impl.UserDaoImpl\"&gt;\n    &lt;property name=\"properties\"&gt;\n        &lt;props&gt;\n            &lt;prop key=\"p1\"&gt;aaa&lt;/prop&gt;\n            &lt;prop key=\"p2\"&gt;bbb&lt;/prop&gt;\n            &lt;prop key=\"p3\"&gt;ccc&lt;/prop&gt;\n        &lt;/props&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<h2><br/> 3.8 引入其他配置文件（分模块开发）</h2>\n<p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载</p>\n<pre><code class=\"language-XML\">&lt;import resource=\"applicationContext-xxx.xml\"/&gt;</code></pre>\n<h1>4. spring相关API</h1>\n<h2>4.1 ApplicationContext的继承体系</h2>\n<p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>\n<p style=\"text-align:center;\"><img alt=\"查看源图像\" src=\"..\\..\\static\\image\\68c28ecf080ffa12d21ddf63016822a5.png\"/></p>\n<p></p>\n<p></p>\n<h2>4.2 ApplicationContext的实现类</h2>\n<h3>4.2.1 ClassPathXmlApplicationContext</h3>\n<pre><code class=\"language-java\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");</code></pre>\n<p>它是从类的根路径下加载配置文件 推荐使用这种</p>\n<h3>4.2.2 FileSystemXmlApplicationContext</h3>\n<pre><code>ApplicationContext applicationContext = new FileSystemXmlApplicationContext(\"D:\\\\140-Git\\\\spring\\\\spring_ioc\\\\src\\\\main\\\\resources\\\\applicationContext.xml\");</code></pre>\n<p>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p>\n<h3>4.2.3 AnnotationConfigApplicationContext</h3>\n<p>当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。<br/>  </p>\n<h2>4.3 getBean()方法使用</h2>\n<pre><code class=\"language-java\">public Object getBean(String name) throws BeansException {  \n\tassertBeanFactoryActive();   \n\treturn getBeanFactory().getBean(name);\n}\npublic &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException {   \t\t\t    \tassertBeanFactoryActive();\n\treturn getBeanFactory().getBean(requiredType);\n}</code></pre>\n<p>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p>\n<p>当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</p>\n<p><strong>getBean()方法使用</strong></p>\n<pre><code class=\"language-java\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nUserService userService1 = (UserService) applicationContext.getBean(\"userService\");\nUserService userService2 = applicationContext.getBean(UserService.class);</code></pre>\n<h1><br/> 5.Spring配置数据源</h1>\n<h2>5.1 数据源（连接池）的作用</h2>\n<p>数据源(连接池)是提高程序性能如出现的</p>\n<p>事先实例化数据源，初始化部分连接资源</p>\n<p>使用连接资源时从数据源中获取</p>\n<p>使用完毕后将连接资源归还给数据源</p>\n<p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p>\n<p><strong>开发步骤</strong></p>\n<p>①导入数据源的坐标和数据库驱动坐标</p>\n<p>②创建数据源对象</p>\n<p>③设置数据源的基本连接数据</p>\n<p>④使用数据源获取连接资源和归还连接资源</p>\n<p></p>\n<h2>5.2 数据源的手动创建</h2>\n<p>①导入mysql数据库驱动坐标、导入c3p0和druid的坐标</p>\n<pre><code class=\"language-XML\">&lt;dependencies&gt;\n    &lt;!-- mysql驱动 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;5.1.39&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- C3P0连接池 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;c3p0&lt;/groupId&gt;\n        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;\n        &lt;version&gt;0.9.1.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Druid连接池 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n        &lt;artifactId&gt;druid&lt;/artifactId&gt;\n        &lt;version&gt;1.1.10&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- junit单元测试 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;/groupId&gt;\n        &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;version&gt;4.12&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n<p>②创建C3P0连接池</p>\n<pre><code class=\"language-java\">@Test\npublic void testC3P0() throws Exception {\n    //创建数据源\n    ComboPooledDataSource dataSource = new ComboPooledDataSource();\n    //设置数据库连接参数\n    dataSource.setDriverClass(\"com.mysql.jdbc.Driver\");\n    dataSource.setJdbcUrl(\"jdbc:mysql://192.168.1.55:3306/mysql\");\n    dataSource.setUser(\"root\");\n    dataSource.setPassword(\"646453\");\n    //获得连接对象\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n    connection.close();\n}</code></pre>\n<pre>\n</pre>\n<p>②创建Druid连接池</p>\n<pre><code class=\"language-java\">@Test\npublic void testDruid() throws Exception {\n    //创建数据源\n    DruidDataSource dataSource = new DruidDataSource();\n    //设置数据库连接参数\n    dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n    dataSource.setUrl(\"jdbc:mysql://192.168.1.55:3306/mysql\");\n    dataSource.setUsername(\"root\");\n    dataSource.setPassword(\"646453\");\n    //获得连接对象\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n}</code></pre>\n<p>③提取jdbc.properties配置文件</p>\n<pre><code>jdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://192.168.1.55:3306/mysql\njdbc.username=root\njdbc.password=646453</code></pre>\n<p>④读取jdbc.properties配置文件创建连接池</p>\n<pre><code class=\"language-java\">@Test\npublic void testC3P0ByProperties() throws Exception {\n    //加载类路径下的jdbc.properties\n    ResourceBundle rb = ResourceBundle.getBundle(\"jdbc\");\n    ComboPooledDataSource dataSource = new ComboPooledDataSource();\n    dataSource.setDriverClass(rb.getString(\"jdbc.driver\"));\n    dataSource.setJdbcUrl(rb.getString(\"jdbc.url\"));\n    dataSource.setUser(rb.getString(\"jdbc.username\"));\n    dataSource.setPassword(rb.getString(\"jdbc.password\"));\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n}</code></pre>\n<h3></h3>\n<h2>5.3 Spring配置数据源</h2>\n<p>可以将DataSource的创建权交由Spring容器去完成</p>\n<p>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的</p>\n<p>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入</p>\n<pre><code class=\"language-XML\">&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;\n    &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt;\n    &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://192.168.1.55:3306/mysql\"/&gt;\n    &lt;property name=\"user\" value=\"root\"/&gt;\n    &lt;property name=\"password\" value=\"646453\"/&gt;\n&lt;/bean&gt;</code></pre>\n<p>测试从容器当中获取数据源</p>\n<pre><code class=\"language-java\">@Test\npublic void testSpringDataSource() throws Exception{\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    DataSource dataSource = applicationContext.getBean(DataSource.class);\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n    connection.close();\n}</code></pre>\n<h3></h3>\n<h2>5.4 抽取jdbc配置文件</h2>\n<p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p>\n<p>首先，需要引入context命名空间和约束路径：</p>\n<p>命名空间：</p>\n<pre><code class=\"language-XML\">xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"</code></pre>\n<p>约束路径：</p>\n<pre><code class=\"language-XML\">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</code></pre>\n<pre><code class=\"language-XML\">&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;\n\n&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;\n    &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt;\n    &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt;\n    &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt;\n    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n&lt;/bean&gt;</code></pre>\n<h3></h3>\n<h1>6. Spring注解开发</h1>\n<h2>6.1 Spring原始注解</h2>\n<p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p>\n<p>Spring原始注解主要是替代&lt;Bean&gt;的配置</p>\n<table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td>相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td>使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table>\n<p>注意：</p>\n<p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</p>\n<pre><code class=\"language-XML\">&lt;!--注解的组件扫描--&gt;\n&lt;context:component-scan base-package=\"com.terence\"&gt;&lt;/context:component-scan&gt;</code></pre>\n<p>使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。</p>\n<pre><code class=\"language-java\">//@Component(\"userDao\")\n@Repository(\"userDao\")\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}</code></pre>\n<p>使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化</p>\n<p>使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入</p>\n<pre><code class=\"language-java\">//@Component(\"userService\")\n@Service(\"userService\")\npublic class UserServiceImpl implements UserService {\n    /*@Autowired\n    @Qualifier(\"userDao\")*/\n    @Resource(name=\"userDao\")\n    private UserDao userDao;\n\n    @Override\n    public void save() {\n        userDao.save();\n    }\n}</code></pre>\n<p>使用@Value进行字符串的注入</p>\n<pre><code class=\"language-java\">@Repository(\"userDao\")\npublic class UserDaoImpl implements UserDao {\n    @Value(\"注入普通数据\")\n    private String str;\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n    @Override\n    public void save() {\n        System.out.println(str);\n        System.out.println(driver);\n        System.out.println(\"save running... ...\");\n    }\n}</code></pre>\n<p>使用@Scope标注Bean的范围</p>\n<pre><code class=\"language-java\">//@Scope(\"prototype\")\n@Scope(\"singleton\")\npublic class UserDaoImpl implements UserDao {\n   //此处省略代码\n}</code></pre>\n<p>使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法</p>\n<pre><code class=\"language-java\">@PostConstruct\npublic void init(){\n\tSystem.out.println(\"初始化方法....\");\n}\n@PreDestroy\npublic void destroy(){\n\tSystem.out.println(\"销毁方法.....\");\n}</code></pre>\n<h3></h3>\n<h2>6.2 Spring新注解</h2>\n<p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p>\n<p>非自定义的Bean的配置：&lt;bean&gt;</p>\n<p>加载properties文件的配置：<a title=\"context:property-placeholder\">context:property-placeholder</a></p>\n<p>组件扫描的配置：<a title=\"context:component-scan\">context:component-scan</a></p>\n<p>引入其他文件：&lt;import&gt;</p>\n<table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=\"com.itheima\"/&gt;一样</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td></tr><tr><td>@PropertySource</td><td>用于加载.properties 文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table>\n<pre><code class=\"language-java\">@PropertySource(\"classpath:jdbc.properties\")\npublic class DataSourceConfiguration {\n\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n    @Value(\"${jdbc.url}\")\n    private String url;\n    @Value(\"${jdbc.username}\")\n    private String username;\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n    @Bean(\"dataSource\")  //Spring会将当前方法的返回值以指定名称存储到Spring容器中\n    public DataSource getDataSource() throws PropertyVetoException {\n        ComboPooledDataSource dataSource = new ComboPooledDataSource();\n        dataSource.setDriverClass(driver);\n        dataSource.setJdbcUrl(url);\n        dataSource.setUser(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    }\n\n}</code></pre>\n<pre><code class=\"language-java\">//标志该类是Spring的核心配置类\n@Configuration\n@ComponentScan(\"com.terence\")\n@Import({DataSourceConfiguration.class})\npublic class SpringConfiguration {\n\n}</code></pre>\n<p>测试加载核心配置类创建Spring容器</p>\n<pre><code class=\"language-java\">@Test\npublic void testAnnoConfiguration() throws Exception {\n    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(com.itheima.cofig.SpringConfiguration.class);\n    UserService userService = (UserService)applicationContext.getBean(\"userService\");\n    userService.save();\n    DataSource dataSource = (DataSource)applicationContext.getBean(\"dataSource\");\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n}</code></pre>\n<h2></h2>\n<h1>7. Spring整合Junit</h1>\n<h2>7.1 原始Junit测试Spring的问题</h2>\n<p>在测试类中，每个测试方法都有以下两行代码：</p>\n<pre><code class=\"language-java\">ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nDataSource dataSource = applicationContext.getBean(DataSource.class);</code></pre>\n<p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>\n<h3></h3>\n<h2>7.2 上述问题解决思路</h2>\n<p>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</p>\n<p>将需要进行测试Bean直接在测试类中进行注入</p>\n<h3></h3>\n<h2>7.3 Spring集成Junit步骤</h2>\n<p>①导入spring集成Junit的坐标</p>\n<p>②使用@Runwith注解替换原来的运行期</p>\n<p>③使用@ContextConfiguration指定配置文件或配置类</p>\n<p>④使用@Autowired注入需要测试的对象</p>\n<p>⑤创建测试方法进行测试</p>\n<h3></h3>\n<h2>7.4 Spring集成Junit代码实现</h2>\n<p>①导入spring集成Junit的坐标</p>\n<pre>&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;\n</pre>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>②使用@Runwith注解替换原来的运行期</p>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\npublic class SpringJunitTest {\n}</code></pre>\n<p>③使用@ContextConfiguration指定配置文件或配置类</p>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n//加载spring核心配置文件\n//@ContextConfiguration(value = {\"classpath:applicationContext.xml\"})\n//加载spring核心配置类\n@ContextConfiguration(classes = {SpringConfiguration.class})\npublic class SpringJunitTest {\n}</code></pre>\n<p>④使用@Autowired注入需要测试的对象</p>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n//加载spring核心配置文件\n//@ContextConfiguration(value = {\"classpath:applicationContext.xml\"})\n//加载spring核心配置类\n@ContextConfiguration(classes = {SpringConfiguration.class})\npublic class SpringJunitTest {\n    @Autowired\n    private UserService userService;\n}</code></pre>\n<p>⑤创建测试方法进行测试</p>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n//加载spring核心配置文件\n//@ContextConfiguration(value = {\"classpath:applicationContext.xml\"})\n//加载spring核心配置类\n@ContextConfiguration(classes = {SpringConfiguration.class})\npublic class SpringJunitTest {\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void testUserService(){\n        userService.save();\n    }\n}</code></pre>\n<h2></h2>\n<h1>8.Spring 的 AOP 简介</h1>\n<h2>8.1 什么是 AOP</h2>\n<p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>\n<p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>\n<h3></h3>\n<h2>8.2 AOP 的作用及其优势</h2>\n<p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p>\n<p>优势：减少重复代码，提高开发效率，并且便于维护</p>\n<h3></h3>\n<h2>8.3 AOP 的底层实现</h2>\n<p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>\n<h3></h3>\n<h2>8.4 AOP 的动态代理技术</h2>\n<p>常用的动态代理技术</p>\n<p>JDK 代理 : 基于接口的动态代理技术</p>\n<p>cglib 代理：基于父类的动态代理技术</p>\n<p><img alt=\"\" height=\"305\" src=\"..\\..\\static\\image\\3d4361f1e7f7461e8eea5d25f15f60a3.png\" width=\"1110\"/></p>\n<p></p>\n<h2>8.5 JDK 的动态代理</h2>\n<p>①目标类接口</p>\n<pre><code class=\"language-java\">public interface TargetInterface {\n    public void save();\n}</code></pre>\n<p>②目标类</p>\n<pre><code class=\"language-java\">public class Target implements TargetInterface{\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}</code></pre>\n<p>③增强对象代码</p>\n<pre><code class=\"language-java\">public class Advice {\n    public void before(){\n        System.out.println(\"前置通知\");\n    }\n    public void afterReturning(){\n        System.out.println(\"后置增强\");\n    }\n}</code></pre>\n<p>④动态代理代码</p>\n<pre>// 测试,当调用接口的任何方法时，代理对象的代码都无需修改\n</pre>\n<pre><code class=\"language-java\">public class ProxyTest {\n    public static void main(String[] args) {\n        final Target target = new Target(); //创建目标对象\n        final Advice advice = new Advice(); //创建增强对象\n        //创建代理对象\n        TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args)\n                            throws Throwable {\n                        advice.before();\n                        Object invoke = method.invoke(target, args);\n                        advice.afterReturning();\n                        return invoke;\n                    }\n                }\n        );\n        proxy.save();//执行测试方法\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"323\" src=\"..\\..\\static\\image\\19dd42ea5f53421a941e41f0cbe21673.png\" width=\"1060\"/></p>\n<p></p>\n<h2>8.6 cglib 的动态代理</h2>\n<p>①目标类</p>\n<pre><code class=\"language-java\">public class Target{\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}</code></pre>\n<p> ②增强对象代码</p>\n<pre><code class=\"language-java\">public class Advice {\n    public void before(){\n        System.out.println(\"前置通知\");\n    }\n    public void afterReturning(){\n        System.out.println(\"后置增强\");\n    }\n}</code></pre>\n<p>③动态代理代码</p>\n<pre>//测试,当调用接口的任何方法时，代理对象的代码都无序修改\n</pre>\n<pre><code class=\"language-java\">public class ProxyTest {\n    public static void main(String[] args) {\n        final Target target = new Target(); //创建目标对象\n        final Advice advice = new Advice(); //创建增强对象\n        Enhancer enhancer = new Enhancer();  //创建增强器\n        enhancer.setSuperclass(Target.class); //设置父类\n        enhancer.setCallback(new MethodInterceptor() { //设置回调\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects,MethodProxy methodProxy) throws Throwable {\n                advice.before();\n                Object invoke = method.invoke(target, objects);\n                advice.afterReturning();\n                return invoke;\n            }\n        });\n        Target proxy = (Target) enhancer.create(); //创建代理对象\n        proxy.save();//执行测试方法\n    }\n}</code></pre>\n<pre>\n</pre>\n<p></p>\n<h2><strong>8.7 AOP 相关概念</strong></h2>\n<p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p>\n<p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p>\n<table align=\"left\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px;\"><tbody><tr><td style=\"width:157px;\">Target（目标对象）</td><td style=\"width:541px;\">代理的目标对象</td></tr><tr><td style=\"width:157px;\">Proxy （代理）</td><td style=\"width:541px;\">一个类被 AOP 织入增强后，就产生一个结果代理类</td></tr><tr><td style=\"width:157px;\">Joinpoint（连接点）</td><td style=\"width:541px;\">所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点</td></tr><tr><td style=\"width:157px;\">Pointcut（切入点）</td><td style=\"width:541px;\">所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义</td></tr><tr><td style=\"width:157px;\">Advice（通知/ 增强）</td><td style=\"width:541px;\">所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</td></tr><tr><td style=\"width:157px;\">Aspect（切面）</td><td style=\"width:541px;\">是切入点和通知（引介）的结合</td></tr><tr><td style=\"width:157px;\">Weaving（织入）</td><td style=\"width:541px;\">是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</td></tr></tbody></table>\n<ul><li> <p></p> </li><li></li></ul>\n<h3></h3>\n<h3></h3>\n<h3></h3>\n<h3></h3>\n<h3></h3>\n<h3></h3>\n<p></p>\n<h2>8.8 AOP 开发明确的事项</h2>\n<p>①需要编写的内容</p>\n<ul><li> <p>编写核心业务代码（目标类的目标方法）</p> </li><li> <p>编写切面类，切面类中有通知(增强功能方法)</p> </li><li> <p>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p> </li></ul>\n<p>②AOP 技术实现的内容</p>\n<p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>\n<p>③AOP 底层使用哪种代理方式</p>\n<p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>\n<h2>8.9 知识要点</h2>\n<ul><li> <p>aop：面向切面编程</p> </li><li> <p>aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理</p> </li><li> <p>aop的重点概念：</p> <pre>Pointcut（切入点）：被增强的方法\n​\nAdvice（通知/ 增强）：封装增强业务逻辑的方法\n​\nAspect（切面）：切点+通知\n​\nWeaving（织入）：将切点与通知结合的过程</pre> </li><li> <p>开发明确事项：</p> <pre>谁是切点（切点表达式配置）\n\n谁是通知（切面类中的增强方法）\n\n将切点和通知进行织入配置</pre> </li></ul>\n<h2></h2>\n<h2>8.10 基于 XML 的 AOP 开发</h2>\n<h3><strong>8.10.1 快速入门</strong></h3>\n<p>①导入 AOP 相关坐标</p>\n<pre><code class=\"language-XML\">&lt;!--导入spring的context坐标，context依赖aop--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n  &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- aspectj的织入 --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;\n  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\n  &lt;version&gt;1.8.13&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>②创建目标接口和目标类（内部有切点）</p>\n<pre><code class=\"language-java\">public interface TargetInterface {\n    public void save();\n}\n</code></pre>\n<pre><code class=\"language-java\">public class Target implements TargetInterface {\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}</code></pre>\n<p>③创建切面类（内部有增强方法）</p>\n<pre><code class=\"language-java\">public class MyAspect{\n    //前置增强方法\n    public void before(){\n        System.out.println(\"前置增强...\");\n    }\n}</code></pre>\n<p>④将目标类和切面类的对象创建权交给 spring</p>\n<pre><code class=\"language-XML\">&lt;!--配置目标类--&gt;\n&lt;bean id=\"target\" class=\"com.terence.aop.Target\"&gt;&lt;/bean&gt;\n&lt;!--配置切面类--&gt;\n&lt;bean id=\"myAspect\" class=\"com.terence.aop.MyAspect\"&gt;&lt;/bean&gt;</code></pre>\n<p></p>\n<p>⑤导入aop命名空间</p>\n<pre><code class=\"language-XML\">xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\nhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</code></pre>\n<pre>\n</pre>\n<p>⑥在 applicationContext.xml 中配置织入关系</p>\n<p>配置切点表达式和前置增强的织入关系</p>\n<pre><code class=\"language-XML\">&lt;aop:config&gt;\n    &lt;!--引用myAspect的Bean为切面对象--&gt;\n    &lt;aop:aspect ref=\"myAspect\"&gt;\n        &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;\n        &lt;aop:before method=\"before\" pointcut=\"execution(public void com.terence.aop.Target.save())\"&gt;&lt;/aop:before&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre>\n<p></p>\n<p>⑦测试代码</p>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AopTest {\n    @Autowired\n    private TargetInterface target;\n    @Test\n    public void test1(){\n        target.save();\n    }\n}</code></pre>\n<p>⑧测试结果</p>\n<p><img alt=\"\" height=\"456\" src=\"..\\..\\static\\image\\e51c03fe474145989b99fdd780d5798c.png\" width=\"984\"/></p>\n<p></p>\n<p></p>\n<h3><strong>8.10.2 XML 配置 AOP 详解</strong></h3>\n<p>①切点表达式的写法</p>\n<p>表达式语法：</p>\n<pre>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</pre>\n<ul><li> <p>访问修饰符可以省略</p> </li><li> <p>返回值类型、包名、类名、方法名可以使用星号* 代表任意</p> </li><li> <p>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p> </li><li> <p>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p> </li></ul>\n<p>例如：</p>\n<pre><code class=\"language-XML\">execution(public void com.itheima.aop.Target.method())\t\nexecution(void com.itheima.aop.Target.*(..))\nexecution(* com.itheima.aop.*.*(..))\nexecution(* com.itheima.aop..*.*(..))\nexecution(* *..*.*(..))</code></pre>\n<p>②通知的类型</p>\n<p>通知的配置语法：</p>\n<pre><code class=\"language-XML\">&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式\"&gt;&lt;/aop:通知类型&gt;</code></pre>\n<p><img alt=\"\" height=\"309\" src=\"..\\..\\static\\image\\0e98123e1b234c52bf38a08ce2e7deaf.png\" width=\"923\"/></p>\n<pre><code class=\"language-java\">public class MyAspect {\n\n    public void before(){\n        System.out.println(\"前置增强..........\");\n    }\n\n    public void afterReturning(){\n        System.out.println(\"后置增强..........\");\n    }\n\n    //Proceeding JoinPoint:  正在执行的连接点===切点\n    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n        System.out.println(\"环绕前增强....\");\n        Object proceed = pjp.proceed();//切点方法\n        System.out.println(\"环绕后增强....\");\n        return proceed;\n    }\n\n    public void afterThrowing(){\n        System.out.println(\"异常抛出增强..........\");\n    }\n\n    public void after(){\n        System.out.println(\"最终增强..........\");\n    }\n\n}</code></pre>\n<pre><code class=\"language-XML\">&lt;aop:config&gt;\n    &lt;!-- 声明切面 --&gt;\n    &lt;aop:aspect ref=\"myAspect\"&gt;\n        &lt;!-- 切面：切点+通知 --&gt;\n        &lt;aop:before method=\"before\" pointcut=\"execution(* com.terence.aop.*.*(..))\"/&gt;\n        &lt;aop:after-returning method=\"afterReturning\" pointcut=\"execution(* com.terence.aop.*.*(..))\"/&gt;\n        &lt;aop:around method=\"around\" pointcut=\"execution(* com.terence.aop.*.*(..))\"/&gt;\n        &lt;aop:after-throwing method=\"afterThrowing\" pointcut=\"execution(* com.terence.aop.*.*(..))\"/&gt;\n        &lt;aop:after method=\"after\" pointcut=\"execution(* com.terence.aop.*.*(..))\"/&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre>\n<p><img alt=\"\" height=\"413\" src=\"..\\..\\static\\image\\2ff8aabe58cc48b8955cd2d6323e9723.png\" width=\"894\"/></p>\n<p></p>\n<p>③切点表达式的抽取</p>\n<p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>\n<pre><code class=\"language-XML\">&lt;aop:config&gt;\n    &lt;!-- 声明切面 --&gt;\n    &lt;aop:aspect ref=\"myAspect\"&gt;\n        &lt;!-- 抽取切点表达式 --&gt;\n        &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.terence.aop.*.*(..))\"/&gt;\n        &lt;!-- 切面：切点+通知 --&gt;\n       &lt;aop:around method=\"around\" pointcut-ref=\"myPointcut\"/&gt;\n       &lt;aop:after method=\"after\" pointcut-ref=\"myPointcut\"/&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre>\n<p><img alt=\"\" height=\"388\" src=\"..\\..\\static\\image\\e66c5ce45c534d1ca6657d78d8c621e0.png\" width=\"806\"/></p>\n<h3></h3>\n<h2>8.11 基于注解的 AOP 开发</h2>\n<h3><strong>8.11.1 快速入门</strong></h3>\n<p>基于注解的aop开发步骤：</p>\n<p>①创建目标接口和目标类（内部有切点）</p>\n<pre><code class=\"language-java\">public interface TargetInterface {\n    public void save();\n}</code></pre>\n<pre><code class=\"language-java\">public class Target implements TargetInterface {\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}</code></pre>\n<p>②创建切面类（内部有增强方法)</p>\n<pre><code class=\"language-java\">public class MyAspect {\n    public void before(){\n        System.out.println(\"前置增强..........\");\n    }\n}</code></pre>\n<p>③将目标类和切面类的对象创建权交给 spring</p>\n<pre><code class=\"language-java\">@Component(\"target\")\npublic class Target implements TargetInterface {\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}</code></pre>\n<pre><code class=\"language-java\">@Component(\"myAspect\")\npublic class MyAspect {\n    public void before(){\n        System.out.println(\"前置增强..........\");\n    }</code></pre>\n<p>④在切面类中使用注解配置织入关系</p>\n<pre><code class=\"language-java\">@Component(\"myAspect\")\n@Aspect\npublic class MyAspect {\n    @Before(\"execution(* com.terence.anno.*.*(..))\")\n    public void before(){\n        System.out.println(\"前置增强..........\");\n    }</code></pre>\n<p>⑤在配置文件中开启组件扫描和 AOP 的自动代理</p>\n<pre><code class=\"language-XML\">&lt;!--组件扫描--&gt;\n&lt;context:component-scan base-package=\"com.terence.anno\"/&gt;\n\n&lt;!--aop自动代理--&gt;\n&lt;aop:aspectj-autoproxy/&gt;</code></pre>\n<p>⑥测试代码</p>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext-anno.xml\")\npublic class AopTest {\n    @Autowired\n    private TargetInterface target;\n    @Test\n    public void test1(){\n        target.save();\n    }\n}</code></pre>\n<p>⑦测试结果</p>\n<p><img alt=\"\" height=\"174\" src=\"..\\..\\static\\image\\81fe23dfe1af4377bb7abeaaf1aaff61.png\" width=\"737\"/></p>\n<p></p>\n<p></p>\n<h3><strong>8.11.2 注解配置 AOP 详解</strong></h3>\n<p>①注解通知的类型</p>\n<p>通知的配置语法：@通知注解(“切点表达式\")</p>\n<p><img alt=\"\" height=\"298\" src=\"..\\..\\static\\image\\6fdbec921d3e46ee838b88297e5063cb.png\" width=\"930\"/></p>\n<pre><code class=\"language-java\">@Component(\"myAspect\")\n@Aspect //标注当前MyAspect是一个切面类\npublic class MyAspect {\n    //配置前置通知\n    //@Before(\"execution(* com.terence.anno.*.*(..))\")\n    public void before(){\n        System.out.println(\"前置增强..........\");\n    }\n    //配置后置通知\n    //@AfterReturning(\"execution(* com.terence.anno.*.*(..))\")\n    public void afterReturning(){\n        System.out.println(\"后置增强..........\");\n    }\n    //配置环绕通知\n    @Around(\"execution(* com.terence.anno.*.*(..))\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n        System.out.println(\"环绕前增强....\");\n        Object proceed = pjp.proceed();//切点方法\n        System.out.println(\"环绕后增强....\");\n        return proceed;\n    }\n    //配置异常通知\n    @AfterThrowing(\"execution(* com.terence.anno.*.*(..))\")\n    public void afterThrowing(){\n        System.out.println(\"异常抛出增强..........\");\n    }\n    //配置最终通知\n    @After(\"execution(* com.terence.anno.*.*(..))\")\n    public void after(){\n        System.out.println(\"最终增强..........\");\n    }\n}</code></pre>\n<p>②切点表达式的抽取</p>\n<p>同 xml配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p>\n<pre><code class=\"language-java\">@Component(\"myAspect\")\n@Aspect\npublic class MyAspect {\n    //定义切点表达式\n    @Pointcut(\"execution(* com.terence.anno.*.*(..))\")\n    public void myPoint(){}\n\n    @Before(\"MyAspect.myPoint()\")\n    public void before(){\n        System.out.println(\"前置增强..........\");\n    }\n}</code></pre>\n<p></p>\n<h1>9. JdbcTemplate基本使用</h1>\n<h2>9.1 JdbcTemplate基本使用-概述(了解)</h2>\n<p>JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。</p>\n<p></p>\n<h2>9.2 JdbcTemplate基本使用-开发步骤(理解)</h2>\n<p>①导入spring-jdbc和spring-tx坐标</p>\n<pre><code class=\"language-XML\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;\n    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- mysql驱动 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;5.1.39&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- C3P0连接池 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;c3p0&lt;/groupId&gt;\n    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;\n    &lt;version&gt;0.9.1.2&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>②创建数据库表和实体</p>\n<pre><code class=\"language-sql\">CREATE TABLE `account` (\n  `name` varchar(50) NOT NULL COMMENT '名称',\n  `money` double DEFAULT NULL COMMENT '存款',\n  PRIMARY KEY (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre>\n<p> <img alt=\"\" height=\"266\" src=\"..\\..\\static\\image\\17c1331175b64d43a71b7e650b8e91b4.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-java\">package com.terence.domain;\n\npublic class Account {\n    private String name;\n    private String money;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getMoney() {\n        return money;\n    }\n\n    public void setMoney(String money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"name='\" + name + '\\'' +\n                \", money='\" + money + '\\'' +\n                '}';\n    }\n}\n</code></pre>\n<p>​</p>\n<p>③创建JdbcTemplate对象</p>\n<p>④执行数据库操作</p>\n<pre><code class=\"language-java\">public class JdbcTemplateTest {\n    @Test\n    //测试JdbcTemplate开发步骤\n    public void test1() throws PropertyVetoException {\n        //创建数据源对象\n        ComboPooledDataSource dataSource = new ComboPooledDataSource();\n        dataSource.setDriverClass(\"com.mysql.jdbc.Driver\");\n        dataSource.setJdbcUrl(\"jdbc:mysql://192.168.1.55:3306/terence_db\");\n        dataSource.setUser(\"root\");\n        dataSource.setPassword(\"646453\");\n\n        JdbcTemplate jdbcTemplate = new JdbcTemplate();\n        //设置数据源对象  知道数据库在哪\n        jdbcTemplate.setDataSource(dataSource);\n        //执行操作\n        int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"tom\", 5000);\n        System.out.println(row);\n    }\n}</code></pre>\n<p></p>\n<h2>9.3 JdbcTemplate基本使用-spring产生模板对象</h2>\n<p>我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。</p>\n<p>抽取jdbc.properties：</p>\n<p>将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护</p>\n<pre><code class=\"language-XML\">jdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://192.168.1.55:3306/terence_db\njdbc.username=root\njdbc.password=646453</code></pre>\n<p>配置如下：</p>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n    &lt;!--加载jdbc.properties--&gt;\n    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;\n    &lt;!--数据源对象--&gt;\n    &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;\n        &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt;\n        &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt;\n        &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--jdbc模板对象--&gt;\n    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n<p>测试代码</p>\n<pre><code class=\"language-java\">@Test\n//测试Spring产生jdbcTemplate对象\npublic void test2() throws PropertyVetoException {\n    ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);\n    int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"lisi\", 5000);\n    System.out.println(row);\n}</code></pre>\n<h3></h3>\n<h3>9.7 JdbcTemplate基本使用-常用操作-更新操作(应用)</h3>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class JdbcTemplateCRUDTest {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void testUpdate(){\n        jdbcTemplate.update(\"update account set money=? where name=?\",10000,\"tom\");\n    }\n\n    @Test\n    public void testDelete(){\n        jdbcTemplate.update(\"delete from account where name=?\",\"tom\");\n    }\n\n}</code></pre>\n<p></p>\n<h3>9.8 JdbcTemplate基本使用-常用操作-查询操作(应用)</h3>\n<pre><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class JdbcTemplateCRUDTest {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void testQueryCount(){\n        Long count = jdbcTemplate.queryForObject(\"select count(*) from account\", Long.class);\n        System.out.println(count);\n    }\n\n    @Test\n    public void testQueryOne(){\n        Account account = jdbcTemplate.queryForObject(\"select * from account where name=?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), \"tom\");\n        System.out.println(account);\n    }\n\n    @Test\n    public void testQueryAll(){\n        List&lt;Account&gt; accountList = jdbcTemplate.query(\"select * from account\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class));\n        System.out.println(accountList);\n    }\n\n}</code></pre>\n<h3></h3>\n<h1>10. 编程式事务控制相关对象</h1>\n<h2><strong>10.1 PlatformTransactionManager</strong></h2>\n<p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p>\n<p><img alt=\"\" height=\"214\" src=\"..\\..\\static\\image\\42023939b94e4073a39fccd2067c7c05.png\" width=\"889\"/></p>\n<p>注意：</p>\n<p>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，</p>\n<p>例如：</p>\n<p>Dao 层技术是jdbc 或 mybatis 时：</p>\n<p>org.springframework.jdbc.datasource.DataSourceTransactionManager</p>\n<p>Dao 层技术是hibernate时：</p>\n<p>org.springframework.orm.hibernate5.HibernateTransactionManager</p>\n<p></p>\n<h2>10.2 TransactionDefinition</h2>\n<p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p>\n<p><img alt=\"\" height=\"258\" src=\"..\\..\\static\\image\\c134e3c8493d41289975ff9fb553d588.png\" width=\"853\"/></p>\n<p></p>\n<h3>10.2.1. 事务隔离级别</h3>\n<p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p>\n<ul><li> <p>ISOLATION_DEFAULT 数据库的默认隔离级别</p> </li><li> <p>ISOLATION_READ_UNCOMMITTED 未提交读取，都不能解决</p> </li><li> <p>ISOLATION_READ_COMMITTED 已提交读取，可以解决脏读</p> </li><li> <p>ISOLATION_REPEATABLE_READ 可重复读，可以解决不可重复读</p> </li><li> <p>ISOLATION_SERIALIZABLE 序列化，全部可以解决，但是效率低相当于缩表</p> </li></ul>\n<p></p>\n<h3>10.2.2. 事务传播行为</h3>\n<ul><li> <p><strong>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</strong></p> </li><li> <p><strong>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</strong></p> </li><li> <p>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</p> </li><li> <p>REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</p> </li><li> <p>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p> </li><li> <p>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</p> </li><li> <p>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p> </li><li> <p>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</p> </li><li> <p>是否只读：建议查询时设置为只读</p> </li></ul>\n<h3></h3>\n<h2>10.3 TransactionStatus</h2>\n<p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p>\n<p><img alt=\"\" height=\"254\" src=\"..\\..\\static\\image\\b839de152ba64af7ac0288c499aadc4c.png\" width=\"859\"/></p>\n<p></p>\n<h3></h3>\n<h1>11 基于 XML 的声明式事务控制</h1>\n<h2>11.1 什么是声明式事务控制</h2>\n<p>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p>\n<p><strong>声明式事务处理的作用</strong></p>\n<ul><li> <p>事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</p> </li><li> <p>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p> </li></ul>\n<p><strong>注意：Spring 声明式事务控制底层就是AOP。</strong></p>\n<p></p>\n<h2>11.2 声明式事务控制的实现</h2>\n<p>声明式事务控制明确事项：</p>\n<ul><li> <p>谁是切点？        //被增强的方法</p> </li><li> <p>谁是通知？        //事务</p> </li><li> <p>配置切面？        //将切点和通知进行AOP的配置</p> </li></ul>\n<p>①引入tx命名空间</p>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;\n&lt;/beans&gt;</code></pre>\n<pre><code class=\"language-XML\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;\n    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>②配置事务增强</p>\n<pre><code class=\"language-XML\">&lt;!--平台事务管理器--&gt;\n&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n    &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;!--事务增强配置--&gt;\n&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;\n    &lt;!--设置事务的属性信息--&gt;\n    &lt;tx:attributes&gt;\n        &lt;tx:method name=\"*\"/&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;</code></pre>\n<p>③配置事务 AOP 织入</p>\n<pre><code class=\"language-XML\">&lt;!--事务的aop增强--&gt;\n&lt;aop:config&gt;\n    &lt;!--&lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.terence.service.impl.*.*(..))\"/&gt;--&gt;\n    &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.terence.service.impl.*.*(..))\"/&gt;\n    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:advisor&gt;\n&lt;/aop:config&gt;</code></pre>\n<p>④测试事务控制转账业务代码</p>\n<pre><code class=\"language-java\">@Override\npublic void transfer(String outMan, String inMan, double money) {\n    accountDao.out(outMan,money);\n    int i = 1/0;\n    accountDao.in(inMan,money);\n}</code></pre>\n<pre><code class=\"language-java\">public class AccountController {\n    public static void main(String[] args) {\n        ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        AccountService accountService = app.getBean(AccountService.class);\n        accountService.transfer(\"tom\",\"lucy\",500);\n    }\n}</code></pre>\n<h2></h2>\n<h2>11.3 切点方法的事务参数的配置</h2>\n<pre><code class=\"language-XML\">&lt;!--事务增强配置--&gt;\n&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;\n    &lt;!--设置事务的属性信息--&gt;\n    &lt;tx:attributes&gt;\n        &lt;tx:method name=\"*\"/&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;</code></pre>\n<p>其中，&lt;tx:method&gt; 代表切点方法的事务参数的配置，例如：</p>\n<pre><code class=\"language-XML\">&lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\"/&gt;\n&lt;tx:method name=\"save\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\"/&gt;\n&lt;tx:method name=\"findAll\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\"/&gt;\n&lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\"/&gt;\n&lt;tx:method name=\"*\"/&gt;</code></pre>\n<ul><li> <p>name：切点方法名称</p> </li><li> <p>isolation:事务的隔离级别</p> </li><li> <p>propogation：事务的传播行为</p> </li><li> <p>timeout：超时时间</p> </li><li> <p>read-only：是否只读</p> </li></ul>\n<h2></h2>\n<h2>11.4 知识要点</h2>\n<p><strong>声明式事务控制的配置要点</strong></p>\n<ul><li> <p>平台事务管理器配置</p> </li><li> <p>事务通知的配置</p> </li><li> <p>事务aop织入的配置</p> </li></ul>\n<h1></h1>\n<h1>12 基于注解的声明式事务控制</h1>\n<h2>12.1 使用注解配置声明式事务控制</h2>\n<ol><li> <p>编写 AccoutDao</p> </li></ol>\n<pre><code class=\"language-java\">@Repository(\"accountDao\")\npublic class AccountDaoImpl implements AccountDao {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    public void out(String outMan, double money) {\n        jdbcTemplate.update(\"update account set money=money-? where name=?\",money,outMan);\n    }\n\n    public void in(String inMan, double money) {\n        jdbcTemplate.update(\"update account set money=money+? where name=?\",money,inMan);\n    }\n}</code></pre>\n<ol><li> <p>编写 AccoutService</p> </li></ol>\n<pre><code class=\"language-java\">@Service(\"accountService\")\n@Transactional(isolation = Isolation.REPEATABLE_READ)\npublic class AccountServiceImpl implements AccountService {\n\n    @Autowired\n    private AccountDao accountDao;\n\n    @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)\n    public void transfer(String outMan, String inMan, double money) {\n        accountDao.out(outMan,money);\n        int i = 1/0;\n        accountDao.in(inMan,money);\n    }\n\n    //@Transactional(isolation = Isolation.DEFAULT)\n    public void xxx(){}\n}</code></pre>\n<ol><li> <p>编写 applicationContext.xml 配置文件</p> </li></ol>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n    \n    &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;\n        &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt;\n        &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/test\"/&gt;\n        &lt;property name=\"user\" value=\"root\"/&gt;\n        &lt;property name=\"password\" value=\"root\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--组件扫描--&gt;\n    &lt;context:component-scan base-package=\"com.terence\"/&gt;\n    &lt;!--事物的注解驱动--&gt;\n    &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt;\n\n&lt;/beans&gt;</code></pre>\n<h2></h2>\n<h2>12.2 注解配置声明式事务控制解析</h2>\n<p>①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p>\n<p>②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p>\n<p>③使用在方法上，不同的方法可以采用不同的事务参数配置。</p>\n<p>④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt;</p>\n<p></p>\n<h2>12.3 知识要点</h2>\n<p><strong>注解声明式事务控制的配置要点</strong></p>\n<ul><li> <p>平台事务管理器配置（xml方式）</p> </li><li> <p>事务通知的配置（@Transactional注解配置）</p> </li><li> <p>事务注解驱动的配置 &lt;tx:annotation-driven /&gt;</p> </li></ul>\n<p></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2021-12-09 23:24:12", "summary": "概述是什么理解是分层的应用全栈的轻量级开源框架，以：控制反转和：面向切面编程为内核。提供了展现层和持久层以及业务层事务管理等众多的企业应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用"}