{"blogid": "124102704", "writerAge": "码龄1年", "writerBlogNum": "62", "writerCollect": "1388", "writerComment": "2364", "writerFan": "5823", "writerGrade": "6级", "writerIntegral": "4596", "writerName": "红苹果超好吃", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124102704.jpg", "writerRankTotal": "4480", "writerRankWeekly": "4384", "writerThumb": "1443", "writerVisitNum": "60231", "blog_read_count": "5343", "blog_time": "已于 2022-05-11 11:35:16 修改", "blog_title": "多线程四大经典案例", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p class=\"img-center\"><img alt=\"\" height=\"297\" src=\"..\\..\\static\\image\\7a58a5013676f3ccda698f5d846d04ab.png\" width=\"297\"/></p>\n<h3>本节内容很重要，</h3>\n<h3><span style=\"color:#fe2c24;\">希</span><span style=\"color:#ff9900;\">望</span><span style=\"color:#ffd900;\">大</span><span style=\"color:#a2e043;\">家</span><span style=\"color:#38d8f0;\">可</span><span style=\"color:#956fe7;\">以</span>好<span style=\"color:#cccccc;\">好</span><span style=\"color:#fbd4d0;\">看</span><span style=\"color:#1c7892;\">看</span>，<span style=\"color:#9c8ec1;\">一</span><span style=\"color:#ad720d;\">起</span><span style=\"color:#be191c;\">加</span><span style=\"color:#511b78;\">油~</span></h3>\n<h2 id=\"1.%E5%8D%95%E7%BA%BF%E6%A8%A1%E5%BC%8F\"><strong>目录</strong></h2>\n<p id=\"1.%E5%8D%95%E7%BA%BF%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%8D%95%E7%BA%BF%E6%A8%A1%E5%BC%8F\">1.单线模式</a></p>\n<p id=\"1.1%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#1.1%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F\">1.1饿汉模式</a></p>\n<p id=\"1.2%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#1.2%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">1.2懒汉模式</a></p>\n<p id=\"2.%E9%98%BB%E5%A1%9E%E5%BC%8F%E9%98%9F%E5%88%97-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E9%98%BB%E5%A1%9E%E5%BC%8F%E9%98%9F%E5%88%97\">2.阻塞式队列</a></p>\n<p id=\"2.1%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88-toc\" style=\"margin-left:80px;\"><a href=\"#2.1%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88\">2.1阻塞队列是什么</a></p>\n<p id=\"2.2%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B-toc\" style=\"margin-left:80px;\"><a href=\"#2.2%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B\">2.2生产者消费者模型</a></p>\n<p id=\"2.3%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-toc\" style=\"margin-left:80px;\"><a href=\"#2.3%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\">2.3标准库中的阻塞队列</a></p>\n<p id=\"2.4%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#2.4%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0\">2.4阻塞队列的实现</a></p>\n<p id=\"3.%E5%AE%9A%E6%97%B6%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E5%AE%9A%E6%97%B6%E5%99%A8\">3.定时器</a></p>\n<p id=\"3.1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88-toc\" style=\"margin-left:80px;\"><a href=\"#3.1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88\">3.1定时器是什么</a></p>\n<p id=\"3.2%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#3.2%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8\">3.2标准库中的定时器</a></p>\n<p id=\"3.3%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#3.3%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8\">3.3实现定时器</a></p>\n<p id=\"4.%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E7%BA%BF%E7%A8%8B%E6%B1%A0\">4.线程池</a></p>\n<p id=\"4.1%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:80px;\"><a href=\"#4.1%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0\">4.1什么是线程池</a></p>\n<p id=\"4.2%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:80px;\"><a href=\"#4.2%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\">4.2标准库中的线程池</a></p>\n<p id=\"4.3%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc\" style=\"margin-left:80px;\"><a href=\"#4.3%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0\">4.3实现线程池</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2><span style=\"color:#0d0016;\">1.单线模式</span></h2>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">①什么是单例模式：</span></span></p>\n<div>\n<span style=\"color:#0d0016;\">单例模式是校招中最常考的设计模式之一. </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">②什么是设计模式：</span></span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">设计模式好比象棋中的 \"棋谱\". 红方当头炮, 黑方马来跳. 针对红方的一些走法, 黑方应招的时候有一些固定的套路. 按照套路来走局势就不会吃亏。软件开发中也有很多常见的 \"问题场景\". 针对这些问题场景, 大佬们总结出了一些固定的套路。按照这个套路来实现代码, 也不会吃亏。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">③单例模式的特点：</span></span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">单例模式能保证某个类在程序中只存在唯一一份实例, 而不会创建出多个实例. </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">④单例模式适用场景以及类型：</span></span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">这一点在很多场景上都需要. 比如 JDBC 中的 DataSource 实例就只需要一个。单例模式具体的实现方式, 分成 \"饿汉\" 和 \"懒汉\" 两种。</span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">这里举一个例子来进一步说明饿汉和懒汉这种模式；</span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">家里面每当吃饭就会面临洗碗这一问题，</span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">a.吃完后马上去洗碗的这种行为我们称为“饿汉模式”</span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">b.吃完后放在那不洗，等下次需要几个的时候去对应洗几个的这种行为，我们称为“懒汉模式”</span>\n</div>\n<div>\n<span style=\"color:#0d0016;\">在日常生活中，饿汉模式更为值得肯定，但是对于计算机而言，懒汉这种模式却能够更大程度地提高效率</span>\n</div>\n</blockquote>\n<div></div>\n<div></div>\n<div></div>\n<h3><span style=\"color:#ed7976;\">1.1饿汉模式</span></h3>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">①什么是饿汉模式：</span></span></p>\n<p>饿汉模式是一种比较着急去创建实例的模式</p>\n<p><span style=\"background-color:#ffd900;\">②在我们写代码之前，我们在这里区分一下实例对象和类对象</span></p>\n<p>static修饰的成员，叫做：\"类成员\",\"类属性/类方法\"。不加static修饰的成员，叫做：\"实例成员\",\"实例属性/实例方法\"。在一个java程序中，一个类对象只存在一份（JVM保证的），进一步的也就保证了类的static成员也只有一份</p>\n<p>类对象：</p>\n<p>类对象就是.class文件，被jvm加载到内存后，表现出的模样。类对象里就有.class文件的一切信息，包括：类名是啥，类里有哪些属性，每个属性的名字，每个属性的类型。</p>\n<p>对象：</p>\n<p>而对象是基于一个类的模板可以创建出很多的实例（对象）</p>\n<p><span style=\"background-color:#ffd900;\">③饿汉模式的代码：</span></p>\n<pre><code class=\"language-java\">class Singleton{\n    //1.使用static创建一个实例，并且立即进行实例化\n    //这个instance对用的实例就是这个类的唯一实例\n    private  static  Singleton instance =new Singleton();\n    //2.为了防止在其他地方new这个Singleton，就可以把这个Singleton设为私有的\n    private  Singleton(){}\n    //提供一个方法，让外面能够拿到唯一实例\n   public static Singleton getInstance(){\n        return instance;\n    }\n}\npublic class demo5 {\n    public static void main(String[] args) {\n        Singleton instance=Singleton.getInstance();\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"514\" src=\"..\\..\\static\\image\\ae43e41dfbac423bb3381ae18de28bbb.png\" width=\"844\"/></p>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">1.2懒汉模式</span></h3>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">①什么是懒汉模式：</span></span></p>\n<p><span style=\"color:#0d0016;\">懒汉模式是不那么着急地去创建实例的模式，只是在用的时候，才去创建</span></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">②单例模式的懒汉模式代码：</span></span></p>\n<p><img alt=\"\" height=\"588\" src=\"..\\..\\static\\image\\8bc15a5ab92d4f089b2a3c123e3f67b5.png\" width=\"1121\"/></p>\n<p>a.你会发现，当多线程时，这个样子由于没有原子性是有很大可能存在线程安全的问题的 </p>\n<p>因为我们这里是单例模型，就是这种存在唯一一份实例，而不能存在多份，而在多线程的情况下是会出现多份实例调用的情况的，下面我们举一个双线程的情况进行说明</p>\n<p><img alt=\"\" height=\"638\" src=\"..\\..\\static\\image\\88655426917e4869b480fc2da63faa1b.png\" width=\"1200\"/></p>\n<p>b. 而要解决上述问题，我们就需要对该读改操作加锁，使它具有原子性</p>\n<p><img alt=\"\" height=\"272\" src=\"..\\..\\static\\image\\1845eabdd1a9443fa19b011e364ec9f8.png\" width=\"1059\"/></p>\n<p> 上述提到的线程不安全情况确实改变了，变得安全，但是若是当一个线程已经完成了初始化，已经变得安全了，但是仍然存在着大量的锁的竞争，这样运行效率就大大的降低了，因此我们要改变这种无脑的加锁，所以我们对上面的代码进行改进。</p>\n<p><img alt=\"\" height=\"333\" src=\"..\\..\\static\\image\\2f980ca4dc684004b7b1daa965c5a64f.png\" width=\"704\"/></p>\n<p>而通过了这种改进就实现了，如果为空加锁创建实例，如果不为空直接返回的情况。</p>\n<p>c.但是现在又会出现新的情况，当多个线程都去读判断条件if（instance==null）时，这个时候读取到的内容若是一致的，就有很大的可能会使线程去寄存器上进行内容的读取，为了解决这种内存可读性的问题，我们用volatile关键字对instance进行修饰。</p>\n<p>所以最终完整的代码如下：</p>\n<pre><code class=\"language-java\">class Singleton2 {\n    //1.不是立即进行初始化\n    //使用volatile来解决内存可读性的问题\n   volatile private static Singleton2 instance = null;\n    //2.把构造方法设置为private\n    private Singleton2() {\n    }\n    //3.提供一个方法来获取上述单例的实例；\n    public static Singleton2 getInstance() {\n        //当实例为空真正需要实例的时候才去创建\n        //加锁使得它具有原子性\n        if (instance == null) {\n            synchronized (Singleton2.class) {\n                if (instance == null) {\n                    instance = new Singleton2();\n                }\n            }\n        }\n        return instance;\n    }\n}\n    public class demo5 {\n        public static void main(String[] args) {\n            Singleton2 instance=Singleton2.getInstance();\n        }\n    }</code></pre>\n</blockquote>\n<h2><span style=\"color:#ff9900;\">2.阻塞式队列</span></h2>\n<h3><span style=\"color:#ed7976;\">2.1阻塞队列是什么</span></h3>\n<blockquote>\n<p>阻塞队列及其特点：</p>\n<p><span style=\"color:#0d0016;\">阻塞队列是具有队列本身的特点，除此之外，阻塞还具有自身的一些特点。</span></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#a2e043;\">1.线程安全</span></span></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#a2e043;\">2.产生阻塞效果：</span><br/> a.当队列为空时，这个时候不能够再出队列了，要是尝试出队列，就会发生阻塞，阻塞到队列不为空为止<br/> b.当队列为满时，这个时候不能够再入队列了，要是尝试入队列，就会发生阻塞，阻塞到队列不为满为止</span></p>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">2.2生产者消费者模型</span></h3>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">①基于阻塞队列实现的“生产消费者模型”</span></span></p>\n<p><span style=\"color:#0d0016;\">生产消费者模型，是实际开发中非常有用的一种多线程开发手段，尤其是在服务器开发的场景中（下面通过图例来予以说明）</span></p>\n<p><span style=\"background-color:#a2e043;\">a.优点1：使用生产消费者模型能够让多个服务器之间更充分地解耦合</span></p>\n<p>（解耦合的含义就是：比如服务器B承接了服务器A传来的信息，要是我们这个时候换服务器C来看它是否可以进行接盘。要是像下图这种非生产消费者模型的话，是不能够进行接盘的）</p>\n<p><img alt=\"\" height=\"296\" src=\"..\\..\\static\\image\\cb070c383f8c43a09b66ee71411a2992.png\" width=\"840\"/></p>\n<p>这个时候比如：在开发A代码的时候我们得到了B提供的一些接口，而在开发B代码的时候也得充分知道A是怎么调用的。而一旦把B换成C，A的改动就太大了，而且要是B服务器挂掉了，那么就可能导致A也直接挂掉的情况。</p>\n<p>而使用生产消费者模型是如何降低耦合的呢？</p>\n<p><img alt=\"\" height=\"323\" src=\"..\\..\\static\\image\\1d371f6bb6fd467e962a9b153f0e42ec.png\" width=\"929\"/> 这个时候我们可以发现，A，B通过阻塞队列连接。换句话说阻塞队列就作为了A,B两者交换的场所，那么A，B之间是没有直接关系的，那么要是这个时候，把B换成C，A也完全感知不到（因为C的相关属性也传到了阻塞队列中，这个时候A并不知道自己所获取的实际上是来自谁的），而若B挂掉，对A也没啥影响（阻塞队列里这个时候已经应有尽有了）。</p>\n<p><span style=\"background-color:#a2e043;\">b.优点2： 能够对于请求进行\"削峰填谷\"</span></p>\n<p>先来看看不用生产消费者模型会遇到的情况：（就是A把压力给到了B，而B可能无法承受住，而导致的崩盘）</p>\n<p>若是A作为入口服务器，B作为应用服务器，当某个时刻A的请求暴涨时，对于A而言，计算量很轻，问题不大。但是对于B来说，计算量很大，需要的系统资源也就越多，当请求进一步增加，申请的资源也会进一步增加，如果主机的硬件不够的话，这个时候程序就会挂掉</p>\n<p><img alt=\"\" height=\"275\" src=\"..\\..\\static\\image\\b1b8eb058e9d4b109db2e0ee23cb1c3c.png\" width=\"822\"/></p>\n<p> 而当我们利用了“生产消费者模型”后（A把压力给了阻塞队列来承担，而B的节奏不会改变）</p>\n<p>如图，通过阻塞队列A请求暴涨会直接导致阻塞队列的请求暴涨，但是因为阻塞队列没有什么计算量，只是单纯地存个数据，就能够抗住压力，从而对B不会造成压力，B仍以原来的速度来消费数据，就不会由于请求的波动而引起崩溃</p>\n<p><img alt=\"\" height=\"337\" src=\"..\\..\\static\\image\\906972b00ff04f31a24e07ce734310d4.png\" width=\"989\"/></p>\n<p> <img alt=\"\" height=\"174\" src=\"..\\..\\static\\image\\c48e958a3fe64cd48e9cd54111b8b5e4.png\" width=\"628\"/></p>\n<p>所以，</p>\n<p>所谓的\"削峰\"：很多时候是不连续地暴涨请求，一段时间过去后就恢复了原样</p>\n<p>所谓的\"填谷\"：是指B按照原来的频率来执行任务 </p>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">2.3标准库中的阻塞队列</span></h3>\n<blockquote>\n<p><span style=\"color:#0d0016;\">在 Java 标准库中内置了阻塞队列. 如果我们需要在一些程序中使用阻塞队列, 直接使用标准库中的即可。对其中的某些属性进行一个说明：</span></p>\n<p><span style=\"color:#0d0016;\">a.BlockingQueue 是一个接口，真正实现的类是 LinkedBlockingQueue。<br/> b.put 方法用于阻塞式的入队列, take 用于阻塞式的出队列。<br/> c.BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性。</span></p>\n<p><span style=\"color:#0d0016;\">直接使用标准库中的阻塞队列代码如下：</span></p>\n<pre><code class=\"language-java\">import java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.LinkedBlockingDeque;\npublic class demo4 {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingDeque&lt;Integer&gt;queue=new LinkedBlockingDeque&lt;&gt;();\n        //1.入队列操作\n        queue.put(3);\n        //2.出队操作\n        int b=queue.take();\n        System.out.println(b);\n    }\n}</code></pre>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">2.4阻塞队列的实现</span></h3>\n<blockquote>\n<p><span style=\"color:#0d0016;\">这里是指我们自己来实现上述这个操作。</span></p>\n<p><span style=\"color:#0d0016;\">而我们先要实现一个队列，在队列的基础上加上线程安全，再加上阻塞</span></p>\n<p><span style=\"color:#0d0016;\">而队列可以基于链表，也可以基于顺序表，我们这通过基于顺序表来进行简单的说明。我们这通过来实现循环队列的形式来说明</span></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">①谈到循环队列我们就要判定：队列的满与空</span></span></p>\n<p><span style=\"color:#0d0016;\">（这里我们不详细讲，具体可以通过前面讲过的数据结构Java版队列去看看）</span></p>\n<p><span style=\"color:#0d0016;\">我们可以通过size来对队列进行计数，要是size=0，则说明队列为空；size=array.length的话则说明队列已经满了。注意，当队列为空，或者队列为满时，需要将其位置置于head==0，以便再次进行循环。</span></p>\n<p><span style=\"background-color:#ffd900;\">②我们要支持线程的安全：</span></p>\n<p>入队列调用put,出队列调用take；</p>\n<p>我们可以知道，put和take里面的每一行代码都是在操作公共的变量；既然如此，那么直接给整个方法进行加锁即可（加上synchronized)</p>\n<p><span style=\"background-color:#ffd900;\">③实现阻塞效果：</span><br/> 利用wait和notify;<br/> 对于put来说，阻塞条件就是队列为满，而take的阻塞条件为队列为空。</p>\n<p>我们在对队列的两者情况进行阻塞之后，我们很容易知道，要是对于队列满的进行了阻塞，那么当它队列元素减少了不再为满的时候就阻塞结束了，而对于队列为空进行了阻塞的话，当它队列中放入了新的元素，那么就可以减少，即对应的阻塞就结束了</p>\n<p>完整代码：（里面也有详细解释）</p>\n<pre><code class=\"language-java\">import java.util.Collection;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\nclass MyBlocking {\n    //基于数组来实现阻塞队列\n    private int[] tmp = new int[1000];\n    //队列长度\n    private int size = 0;\n    //队首元素下标\n    private int start = 0;\n    //队尾元素下标\n    private int end = 0;\n    //创建一个对象，以便后续进行锁\n    private  Object locker = new Object();\n    //实现入队列的操作\n    public void put(int val) throws InterruptedException {\n        //队列为满的情况进行阻塞\n        synchronized (locker) {\n            if (size == tmp.length) {\n                locker.wait();\n            }\n            //当队列不为满的时候，每入队一个元素，end向后移一位\n            tmp[end] = val;\n            end++;\n            //当start到达末尾，那么说明该次循环已经结束，就要进入新的循环就需要重新进行指定\n            if (end &gt;= tmp.length) {\n                end = 0;\n            }//每成功入队一个元素，那么，size的个数就要加加\n            size++;\n            //这里的notify（）是用于解锁于队列为空而不能进一步出队列的操作。\n            locker.notify();\n        }\n    }\n    //实现出队的操作\n    public Integer take() throws InterruptedException {\n        synchronized (locker) {\n            //遇到空队列进行阻塞\n            if (size == 0) {\n                locker.wait();\n            }\n            //当队列不为空时，出元素\n            int ret = tmp[start];\n            start++;\n            //要是start到了队尾说明已经结束了,置为0并开始新的循环\n            if (start &gt;= tmp.length) {\n                start = 0;\n            }\n            //每出队一个元素，对应的size--\n            size--;\n            //当size减了之后说明不再是满队列了，可以向里面放入新的元素了，阻塞结束\n            //这里notify解锁用于队列为满而不能进一步入队的操作\n            locker.notify();\n            //返回出队的元素\n            return ret;\n        }\n    }\n}\n    public class demo6 {\n        public static void main(String[] args) {\n            //阻塞队列的创建\n            MyBlocking queue = new MyBlocking();\n            //实现一个生产者消费者模式\n            Thread t = new Thread(() -&gt; {\n                int num = 0;\n                while (true) {\n                    System.out.println(\"生产了：\" + num);\n                    try {\n                        queue.put(num);\n                        //这里保持生产与消费步调的一致\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    num++;\n                }\n            });\n            t.start();\n            Thread t2 = new Thread(() -&gt; {\n                int num = 0;\n                while (true) {\n                    System.out.println(\"消费了：\" + num);\n                    try {\n                        num = queue.take();\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            t2.start();\n        }\n    }</code></pre>\n</blockquote>\n<h2><span style=\"color:#ff9900;\">3.定时器</span></h2>\n<h3><span style=\"color:#ed7976;\">3.1定时器是什么</span></h3>\n<blockquote>\n<div>\n<span style=\"color:#333333;\">定时器也是软件开发中的一个重要组件</span>\n<span style=\"color:#333333;\">. </span>\n<span style=\"color:#333333;\">类似于一个</span>\n<span style=\"color:#333333;\"> \"</span>\n<span style=\"color:#333333;\">闹钟</span>\n<span style=\"color:#333333;\">\". </span>\n<span style=\"color:#333333;\">达到一个设定的时间之后</span>\n<span style=\"color:#333333;\">, </span>\n<span style=\"color:#333333;\">就执行某个指定好的代码</span>\n</div>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">3.2标准库中的定时器</span></h3>\n<blockquote>\n<p><span style=\"background-color:#ffd900;\">①标准库提供的加以说明：</span></p>\n<p><span style=\"color:#0d0016;\">标准库中提供了一个 <code>Timer</code> 类. <code>Timer</code> 内部是有专门的线程,来负责执行注册的任务的，<code>Timer</code> 类的核心方法为 <code>schedule</code> .</span></p>\n<p><span style=\"color:#0d0016;\"><code>schedule</code> 包含两个参数：第一个参数指定即将要执行的任务代码, 第二个参数指定多长时间之后执行 (单位为毫秒)。</span></p>\n<p><span style=\"background-color:#ffd900;\">②代码演示：</span></p>\n<pre><code class=\"language-java\">import java.util.Timer;\nimport java.util.TimerTask;\npublic class demo7 {\n    public static void main(String[] args) {\n        Timer timer=new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"执行一下这个定时器\");\n            }\n        },3000);\n    }\n}\n</code></pre>\n<p>输出结果：</p>\n<p><img alt=\"\" height=\"198\" src=\"..\\..\\static\\image\\74612816e9c84a55986825a9d79596f1.png\" width=\"890\"/></p>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">3.3实现定时器</span></h3>\n<blockquote>\n<p><span style=\"color:#0d0016;\">虽然我们在实际中可以直接调用类似上述代码来对定时器来进行实现，但是这里我们来试着自己实现一个定时器</span></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">①实现定时器的方法步骤：</span></span></p>\n<p><span style=\"background-color:#a2e043;\">a.描述任务</span></p>\n<p>（通过创建一个专门的类来表示一个定时器中的任务）</p>\n<p>注意！！！Mytask并没有指定比较规则，所以需要我们手动去指定，所以我们需要实现Comporable接口，并重写它的CompareTo（）比较方法</p>\n<p><img alt=\"\" height=\"823\" src=\"..\\..\\static\\image\\58ffd9dcb52f45ed8124773a456975bb.png\" width=\"923\"/><span style=\"background-color:#a2e043;\">b. 组织任务</span></p>\n<p>（在描述完任务之后，我们还需要通过一些数据结构，把一些任务放到一起）</p>\n<p>举个例子：</p>\n<p>假设现在有多个任务要去完成，第一件事是20分钟后交作业，第二件事是1个小时后开会，第三件事是30分钟后檫黑板。安排这些任务时是无序的，但是我们却需要有序的进行执行，我们应该把它进行排列，时间最接近的最先执行，这里就引入了数据结构----堆</p>\n<p>因为此处的队列要考虑到线程安全的问题，可能在多个线程里进行注册任务，同时还要有一个线程专门来取任务进行执行，所以此处的队列就需要注意线程安全问题</p>\n<p><img alt=\"\" height=\"119\" src=\"..\\..\\static\\image\\881807d865c54941ba5590aad893bab8.png\" width=\"1085\"/></p>\n<p><span style=\"background-color:#a2e043;\">c.执行时间到了的任务</span></p>\n<p>（因为需要先执行最靠前的任务，所以需要有一个线程，不停地去检查优先队列的队首元素，看看当前最靠前的这个任务的时间到了没）</p>\n<p>具体代码如下：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.PriorityBlockingQueue;\n//创建一个类，表示一个任务\nclass MyTask implements Comparable&lt;MyTask&gt;{ //实现Comparable接口，设定比较规则\n    //任务具体要干什么\n    private Runnable runnable;\n    //任务具体啥时候干，保存任务要执行的毫秒级时间戳\n    private long time;\n\n    //提供一个构造方法\n    public MyTask(Runnable runnable, long delay) { //delay是一个时间间隔，不是绝对的时间戳的值\n        this.runnable = runnable;\n        this.time = System.currentTimeMillis() + delay;\n    }\n\n    public void run(){//这里不是Runnable里面的run方法，这里只是自己定义了一个任务类，这个run指的是任务执行的方法\n        runnable.run();\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    @Override\n    public int compareTo(MyTask o) {//这个方法的实现是在建堆的时候找最小值的比较过程中，并没有通过此处的代码进行实现\n        //让时间小的在前，时间大的在后\n        return (int)(this.time - o.time);\n    }\n}\n\n//定时器\nclass MyTime{\n    private PriorityBlockingQueue&lt;MyTask&gt; queue = new PriorityBlockingQueue&lt;&gt;();\n    //使用schedule方法来注册任务到队列中\n    public void schedule(Runnable runnable,long delay){\n        MyTask task = new MyTask(runnable,delay);\n        queue.put(task);\n        //每次任务插入成功之后，都唤醒一下扫描线程，让线程重新检查一下队首的任务，看是否时间到了要执行\n        synchronized (locker){\n            locker.notify();\n        }\n    }\n    private Object locker = new Object();\n    //创建一个扫描线程\n    public MyTime(){\n        Thread t = new Thread(()-&gt;{\n            while (true){\n                try {\n                    //先取出队首元素\n                    MyTask task = queue.take();\n                    long curTime =  System.currentTimeMillis();\n                    //判断一下时间是否到达\n                    if(curTime &lt; task.getTime()){\n                        //时间没到，把任务塞回到队列中\n                        queue.put(task);\n                        //指定一个等待时间\n                        synchronized (locker){\n                            //当执行任务但没有被notify新插入任务唤醒的时候，阻塞到这里\n                            locker.wait(task.getTime() - curTime);\n                        }\n                    }else {\n                        //时间到了，执行任务\n                        task.run();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        t.start();\n    }\n}\npublic class Test{\n    public static void main(String[] args) {\n        MyTimer myTimer = new MyTimer();\n        myTimer.schedule(new Runnable() {//前面的参数是传入了一个匿名对象\n            @Override\n            public void run() {\n                System.out.println(\"执行\");\n            }\n        },3000);\n        System.out.println(\"main\");\n    }\n}\n</code></pre>\n<p>部分步骤的解释：</p>\n<p><img alt=\"\" height=\"640\" src=\"..\\..\\static\\image\\1b4a430cdd4d4b799a92ab24fe0fab2c.png\" width=\"1200\"/></p>\n<p>  在这个代码中仍有我们值得注意的点：</p>\n<p><span style=\"background-color:#a2e043;\">（1）为什么要用wait()？</span></p>\n<p>因为如果队列的任务是空着的就还好，这个线程就在这里阻塞了。但是就怕时间还没有到，这个时候就属于“忙等”的情况。忙等这种操作是等了，没有闲着，但是却没有实质性的产出，这个样子的话是非常浪费CPU的。</p>\n<p>而当我们把wait()进行了时间限制后，就相当于可控了它的时间，到了指定时间再唤醒，而节省了CPU。</p>\n<p>那就会有人问：为什么不使用sleep</p>\n<p>这里是因为wait()相比于sleep来说，它是可以被唤醒的，因为每插入新的任务时，我们会进行比较，这个时候需要唤醒，所以这个时候就配合notify。每加入新的任务的时候就notify一下来唤醒阻塞的wait，然后继续进行下面代码的执行。</p>\n</blockquote>\n<h2><span style=\"color:#ff9900;\">4.线程池</span></h2>\n<h3><span style=\"color:#ed7976;\">4.1什么是线程池</span></h3>\n<blockquote>\n<p><span style=\"background-color:#ffd900;\">①什么是线程池？</span></p>\n<p>类似于之前我们接触过的常量池那些，线程池就是里面可以容纳很多线程，我们需要的时候可以直接从里面去取，而不需要从去申请</p>\n<p><span style=\"background-color:#ffd900;\">②为什么要引进线程池？</span></p>\n<p>前面我们引进了线程，相对于进程来说，线程确实减少了开销，但是我们也知道要是对线程进行频繁地创建销毁，那么产生的开销也是不小的，所以这个时候我们引进了线程池来解决问题，把线程提前创建好，放到池子里，后面要是需要用线程的话，直接从池子里取，就不必从系统中申请了。线程用完了，也不是还给系统，而是放回池子里，以备下次进行使用。</p>\n<p><span style=\"background-color:#ffd900;\">③为什么放在线程池里就比系统申请来得更快呢？</span></p>\n<p><span style=\"background-color:#a2e043;\">用户态：</span></p>\n<p>因为像我们自己写的代码，就是在最上面这一层来进行运行的，我们把这里的代码都称为\"用户态\"运行的代码。</p>\n<p><span style=\"background-color:#a2e043;\">内核态：</span></p>\n<p>有些代码，需要调用操作系统的API，进一步的逻辑就会在内核中执行。在内核中运行的代码，称为“内核态”运行的代码。<br/> 举几个需要内核态的例子：<br/> （1）调用System.out.printlin本质上要经过write系统调用，进入内核中。<br/> （2）创建线程也需要内核的支持（创建线程的本质是在内核中搞个PCB，然后再加入到链表中）<br/> （3）调用Thread.start其实归根结底，也是进入内核态来运行的</p>\n<p>而把创建好的线程放到“池子里”，就是由于池子是用户态来实现的，这个放到池子/从池子取出是不需要涉及到内核态的，就是纯粹的用户态代码就能完成。</p>\n<p>一般认为，纯用户态的操作，效率要比经过内核态处理的操作更高</p>\n<p>而认为内核态效率低，倒不一定真的就低，而是代码进入了内核态就不可控了，内核啥时候把活干完，啥时候才把结果给你。</p>\n<p>举个例子：当你需要把作业交到办公室时，你要是自己直接去办公室提交，这个可以看做是一个用户态，而你让同桌帮你交，可以看做是内核态，因为你不确定同桌啥时候帮你，可能是马上，也可能是她写完才去，或者她上个厕所才去，等等。</p>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">4.2标准库中的线程池</span></h3>\n<blockquote>\n<p><span style=\"background-color:#ffd900;\">①标准库中的线程池：</span></p>\n<p><span style=\"color:#0d0016;\">标准库中的线程池叫做：<code>ThreadPoolExecutor</code><br/><code>juc(java.util.concurrent）: concurrent</code>并发的意思.Java中很多和多线程相关的组件都在这个<code>concurrent</code>包里.</span></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">②重点罗列一下第四个：</span></span></p>\n<p><img alt=\"\" height=\"107\" src=\"..\\..\\static\\image\\760baa034eea4bbc893920af0192d682.png\" width=\"863\"/></p>\n<p>以及它的各个参数以及含义：</p>\n<p>我们这里把线程池想象成一个公司，公司的员工分为“正式工”和“临时工” </p>\n<p><img alt=\"\" height=\"346\" src=\"..\\..\\static\\image\\361c06a56ebf4a4aacc4f71deda3001b.png\" width=\"1145\"/></p>\n<p><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">③面试问题：</span></span></p>\n<p><span style=\"color:#0d0016;\">有一个程序,这个程序要并发的/多线程的来完成一些任务，<strong>如果使用线程池的话,这里的线程数设为多少合适</strong>? </span></p>\n<p><span style=\"color:#0d0016;\">这要通过<strong>性能测试</strong>的方式,找到合适的值。理由如下：</span></p>\n<p><span style=\"color:#0d0016;\">根据这里不同的线程池的线程数,来观察程序处理任务的速度,程序持有的CPU的占用率。<br/> 当线程数多了,整体的速度是会变快,但是CPU占用率也会高.<br/> 当线程数少了,整体的速度是会变慢,但是CPU占用率也会下降.<br/> 需要找到一个让程序速度能接受,并且CPU占用也合理这样的平衡点。<br/> 不同类型的程序,因为单个任务,里面CPU上计算的时间和阻塞的时间是分布不相同的。</span></p>\n</blockquote>\n<h3><span style=\"color:#ed7976;\">4.3实现线程池</span></h3>\n<blockquote>\n<p><span style=\"background-color:#ffd900;\">①线程池里有什么？</span></p>\n<p>1.先能够描述任务(直接使用<code>Runnable</code>)</p>\n<p>2.需要组织任务(直接使用<code>BlockingQueue</code>)</p>\n<p>3.能够描述工作线程.</p>\n<p>4.还需要组织这些线程.</p>\n<p>5.需要实现,往线程池里添加任务</p>\n<p>其实就是两个问题，一是把队列中存在工作线程的话就去获取里面的内容，执行任务，没有的话就阻塞。然后将这些线程任务存放在同一个数据结构中。二是把任务放在线程池中的过程，每放入一个输出具体的语句</p>\n<p><span style=\"background-color:#ffd900;\">②代码如下：</span></p>\n<pre><code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.LinkedBlockingDeque;\nclass MyThreadPool{\n    //1.描述一个任务，直接使用Runnable\n    //2.使用一个数据结构来组织任务\n    private BlockingDeque&lt;Runnable&gt; queue = new LinkedBlockingDeque&lt;&gt;();\n    //3.描述一个线程，工作线程的功能就是从任务队列中取任务并执行(这里是一个静态内部类)\n    static class Worker extends Thread{\n        //当前线程池中有若干个Worker线程，这些线程内部都持有上述的任务队列\n        private BlockingDeque&lt;Runnable&gt; queue = null;\n        public Worker( BlockingDeque&lt;Runnable&gt; queue) {\n            this.queue = queue;\n        }\n        @Override\n        public void run() {\n            while (true){\n                try {\n                    //我们没有办法直接使用第9行的queue，因为这是另一个类，所以我们在13行安排了这个变量，\n                    // 并且调用worker构造方法把上面第九行的queue给传进来，让worker线程自身持有着这个队列\n                    //循环的去获取任务队列的任务，\n                    //如果队列为空就直接阻塞，如果队列非空，就获取到里面的内容\n                    Runnable runnable = queue.take();\n                    //获取到之后，就执行任务\n                    runnable.run();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    //4.创建一个数据结构来组织若干个线程\n    private List&lt;Thread&gt; workers = new ArrayList&lt;&gt;();\n    public MyThreadPool(int n){\n        //构造方法中创建出若干个线程，放到上述的数组中\n        for (int i = 0; i &lt; n; i++) {\n            Worker worker = new Worker(queue);//把上述的线程任务传到这一个结构数组中\n            workers.add(worker);\n        }\n    }\n    //5.创建一个方法，允许程序员放任务到线程池当中\n    public void submit(Runnable runnable){\n        try {//把这个runnale 任务加到queue中\n            queue.put(runnable);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\npublic class demo7 {\n    public static void main(String[] args) {\n        MyThreadPool myThreadPool = new MyThreadPool(10);\n        for (int i = 0; i &lt; 100; i++) {\n            myThreadPool.submit(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"hello myThreadPool\");\n                }\n            });\n        }\n    }\n}</code></pre>\n</blockquote>\n<p>关于多线程的4个案例就到这里结束了~</p>\n<p>感谢观看~<img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\ab2fa9f5ee964469a340130caae71b6d.png\" width=\"48\"/> </p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-05-11 11:35:16", "summary": "本节内容很重要，希望大家可以好好看看，一起加油目录单线模式饿汉模式懒汉模式阻塞式队列阻塞队列是什么生产者消费者模型标准库中的阻塞队列阻塞队列的实现定时器定时器是什么标准库中的定时器实现定时器线程池什么"}