{"blogid": "126532126", "writerAge": "码龄1年", "writerBlogNum": "30", "writerCollect": "417", "writerComment": "677", "writerFan": "1012", "writerGrade": "5级", "writerIntegral": "1782", "writerName": "whispar", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126532126.jpg", "writerRankTotal": "10501", "writerRankWeekly": "233", "writerThumb": "541", "writerVisitNum": "31045", "blog_read_count": "707", "blog_time": "已于 2022-08-26 17:34:41 修改", "blog_title": "【Java初阶】类和对象", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p class=\"img-center\"><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n<p style=\"text-align:center;\"><strong>  🎈🎈 作者 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href=\"https://blog.csdn.net/m0_56361048?spm=1011.2415.3001.5343\" title=\"whispar\">whispar</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br/> 🎈🎈专栏 ：<strong><strong><strong><strong><strong><strong><strong><a href=\"https://blog.csdn.net/m0_56361048/category_11939682.html\" title=\"Java由浅入深\">Java由浅入深</a></strong></strong></strong></strong></strong></strong></strong></strong></p>\n<p style=\"text-align:center;\">✨矢志不渝✨ </p>\n<p class=\"img-center\"><img alt=\"7abc9c8906564477a6679bb15d368e37.gif\" src=\"https://img-blog.csdnimg.cn/7abc9c8906564477a6679bb15d368e37.gif\"/></p>\n<p></p>\n<hr/>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"Java%20SE%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\"><a href=\"#Java%20SE%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\">Java SE 类和对象</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B\">一、面向对象和面向过程</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\">二、类和对象</a></p>\n<p id=\"%E4%B8%89%E3%80%81this%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%89%E3%80%81this%E5%BC%95%E7%94%A8\">三、this引用</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9B%9B%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">四、构造方法</a></p>\n<p id=\"%E4%BA%94.%20%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%94.%20%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96\">五. 对象初始化</a></p>\n<hr/>\n<h3 id=\"%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B\">一、面向对象和面向过程</h3>\n<ul><li> <p>面向过程 优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗 资源;比如单片机、嵌入式开发、 Linux 等一般采用面向过程开发，性能是 最重要的因素。</p> </li><li> <p>缺点： 没有面向对象易维护、易复用、易扩展</p> </li><li> <p>面向对象 优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特 性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p> </li><li> <p>缺点： 性能比面向过程低</p> </li></ul>\n<h3 id=\"%E4%BA%8C%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\">二、类和对象</h3>\n<blockquote>\n<p>类是一种抽象，而对象是类的实例，对象可以被多次创建</p>\n</blockquote>\n<pre><code class=\"language-java\">/**\n *定义一个宠物狗类\n *\n */\nclass PetDog {\n    public String name;//名字\n    public String color;//颜色\n    // 狗的属性\n    public void barks() {\n        System.out.println(name + \": 旺旺旺~~~\");\n    }\n    public void wag() {\n        System.out.println(name + \": 摇尾巴~~~\");\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n    //对象的构造和初始化\n        PetDog petDog = new PetDog();\n        petDog.color = \"red\";\n        petDog.name  = \"汪汪\"；\n        petDog.barks();\n        petDog.wag();\n    }\n}</code></pre>\n<blockquote>\n<p>一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量</p>\n</blockquote>\n<blockquote>\n<p>✅对象实体和对象引用的区别？</p>\n<p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象 ;一个对象可以有 n 个引用指向它。</p>\n</blockquote>\n<h3 id=\"%E4%B8%89%E3%80%81this%E5%BC%95%E7%94%A8\">三、this引用</h3>\n<blockquote>\n<p>this表示当前对象的引用，（成员方法运行时调用该成员方法的对象)，在成员方法中所有成员变量的操作，都是通过该引用去访问，</p>\n</blockquote>\n<pre><code class=\"language-java\">public class Date {\n    public int year;\n    public int month;\n    public int day;\n    public void setDay(int year, int month, int day){\n        /**\n         * 1.this。成员变量\n         */\n        this.year = year;\n//this.year=year语句表示一个赋值语句，等号左边的this.year是指当前对象具有的变量year，等号右边的year表示参数传递过来的数值。\n        this.month = month;\n        this.day = day;\n    }\n    public void printDate(){\n        System.out.println(this.year + \"/\" + this.month + \"/\" + this.day);\n    }\n    public void changeDate(int year,int month,int day){\n        /**\n         * 2.this.成员方法\n         */\n        this.printDate();\n        System.out.println(\"开始修改\");\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n}</code></pre>\n<blockquote>\n<ul><li> <p><strong>this的类型：对应类类型引用，即哪个对象调用就是哪个对象的引用</strong></p> </li><li> <p><strong>this只能在\"成员方法\"中使用</strong></p> </li><li> <p><strong>在\"成员方法\"中，this只能引用当前对象，不能再引用其他对象</strong></p> </li></ul>\n</blockquote>\n<h3 id=\"%E5%9B%9B%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">四、构造方法</h3>\n<blockquote>\n<p><strong>✅构造方法(也称为构造器)是一个特殊的成员方法</strong></p>\n<ul><li> <p>名字与类名相同，没有返回值类型，设置为void也不行</p> </li><li> <p>一般情况下使用public修饰</p> </li><li> <p>在创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次</p> </li></ul>\n</blockquote>\n<pre><code class=\"language-java\">public class Date {\n    public int year;\n    public int month;\n    public int day;\n    \n    // 重载构造方法\n    public Date(int year, int month, int day){\n        this.year = year;\n        this.month = month;\n        this.day = day;\n        System.out.println(\"Date(int,int,int)方法被调用了\");\n    }\n    /**\n    *3.this.构造方法\n    */\n    public Date(){\n        this(2003,8,9);\n        System.out.println(\"调用无参的构造方法\");\n    }\n    \n    public static void main(String[] args) {\n        Date d1 = new Date();         //构造方法已被重载，原有的构造方法不能再使用\n        Date d2 = new Date(2021,6,9); // 输出Date(int,int,int)方法被调用了\n    }\n    \n}\n/**\n *解决方法\n *public Date(){}\n *再增加一个无参的构造方法\n */\n//上述两个构造方法：名字相同，参数列表不同，因此构成了方法重载</code></pre>\n<blockquote>\n<p>上述Date类中，没有定义任何构造方法，编译器会默认生成一个不,带参数的构造方法。</p>\n<ul><li> <p>注意：一旦用户定义，编译器则不再生成。</p> </li><li> <p>this(...)<strong>必须是构造方法中第一条语句,不能形成环</strong></p> </li></ul>\n</blockquote>\n<h3 id=\"%E4%BA%94.%20%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96\">五. 对象初始化</h3>\n<blockquote>\n<p>成员变量在定义时，并没有给初始值, 为什么就可以使用呢？</p>\n</blockquote>\n<pre><code class=\"language-java\">Student s = new Student():</code></pre>\n<blockquote>\n<p>在程序层面只是简单的一条语句，在JVM层面需要做好多事情，下面简单介绍下：</p>\n<ol><li> <p>检测对象对应的类是否加载了，如果没有加载则加载</p> </li><li> <p>为对象分配内存空间</p> </li><li> <p>处理并发安全问题 , 比如：多个线程同时申请对象，JVM要保证给对象分配的空间不冲突</p> </li><li> <p><strong>初始化所分配的空间 即：对象空间被申请好之后，对象中包含的成员已经设置好了初始值,</strong>如下表</p> </li><li> <p>设置对象头信息(关于对象内存模型后面会介绍)</p> </li><li> <p><strong>调用构造方法，给对象中各个成员赋值</strong></p> </li></ol>\n</blockquote>\n<table><thead><tr><th><strong>数据类型</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>byte</td><td>0</td></tr><tr><td>char</td><td>'\\u0000'</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table>\n<blockquote>\n<p>就地初始化</p>\n</blockquote>\n<pre><code class=\"language-java\">public class Date {\n    public int year = 1900;\n    //定义时即赋值\n    public int month = 1;\n    public int day = 1;\n    public Date(){\n    }\n    public Date(int year, int month, int day) {\n    }\n    public static void main(String[] args) {\n        Date d1 = new Date(2021,6,9);\n        Date d2 = new Date();\n    }\n}</code></pre>\n<p class=\"img-center\"><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n<blockquote>\n<p style=\"text-align:center;\"><strong>         💖如果文章对你有帮助，请多多点赞、收藏、评论、关注支持！！💖       </strong> </p>\n</blockquote>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-26 17:34:41", "summary": "作者专栏：由浅入深由浅入深矢志不渝目录类和对象一、面向对象和面向过程二、类和对象三、引用四、构造方法五对象初始化一、面向对象和面向过程面向过程优点：性能比面向对象高，因为类调用时需要实例化，开销比较大"}