{"blogid": "126717171", "writerAge": "码龄1年", "writerBlogNum": "410", "writerCollect": "365", "writerComment": "20", "writerFan": "9601", "writerGrade": "5级", "writerIntegral": "4329", "writerName": "嗯嗯好的呢！", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126717171.jpg", "writerRankTotal": "4197", "writerRankWeekly": "602", "writerThumb": "54", "writerVisitNum": "186455", "blog_read_count": "32", "blog_time": "于 2022-09-06 08:33:39 发布", "blog_title": "Flink与RabbitMQ Connector", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>RabbitMQ连接器许可证</p>\n<p>Flink下的RabbitMQ连接器位于一个maven依赖” RabbitMQ AMQP Java Clien”上，由Mozilla Public License v1.1 (MPL 1.1) 许可。</p>\n<p>Flink本身不重写” RabbitMQ AMQP Java Clien”中的源码，也不对其进行打包成二进制文件。 用户基于flink的rabbitMQ连接器（即RabbitMQ AMQP Java Clien）创建和发布拓展开的工作，可能会受到Mozilla Public License v1.1 (MPL 1.1)说明的一些限制。<br/> RabbitMQ连接器</p>\n<p>该连接器访问流数据来源RabbitMQ。为使用连接器，请添加如下依赖在你的项目中，</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;\n  &lt;artifactId&gt;flink-connector-rabbitmq_2.10&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>译者注：上述方法是由maven构建项目时使用，当使用sbt构建项目时，需要在build.sbt中的正确子项目中添加如下：</p>\n<pre><code>(\"org.apache.flink\" %% \"flink-connector-rabbitmq\" % flinkVersion).\n              exclude(\"org.apache.flink\",\"flink-shaded-hadoop1_2.10\"),\n如果使用scala2.10，则不需要exclude.\n</code></pre>\n<p>注意的是，流连接器当前都不是二元分布。更多集群执行请看这里。</p>\n<p>Back to top<br/> 安装RabbitMQ</p>\n<p>阅读Rabbitmq下载页的介绍。安装后，服务器会自动启动，应用程序连接rabbitmq将会启动。</p>\n<p>Rabbitmq数据源</p>\n<p>连接器提供一个类RMQSource，以消费源自于rabbitmq队列里的消息。消费RabbitMQ数据源可有三个不同层级保证，取决于flink的配置如何。</p>\n<p>1， <strong>仅有一次</strong>，为实现保证仅有一次消费rabbitmq数据源，如下是需要的–</p>\n<pre><code>可检查点：检查点生效后，在检查点完成后，消息是互相确认的（因此，会把消息从rabbitmq中删除）。\n\n使用相关编号：相关编号是rabbitmq应用的特征，当提交一个消息进rabbitmq时，必须得在消息配置中设置一个相关编号。在检查点恢复是，源利用相关编号去重已经被处理过的数据，\n\n非并行的源：实现仅有一次，源必须非并行（并行度为1）。这个限制是因为rabbitmq是从一个单一队列存在多个消费者的调度消息方式。\n</code></pre>\n<p>2， <strong>至少一次</strong>：当检查点生效，但是没有使用相关编号或者源是并行的，源仅仅提供至少消费一次的保证。</p>\n<p>3， <strong>没有保证</strong>：如果检查点未生效，源没有任何强分发的保证。这种设置下，替代flink的检查点，一旦接收和处理消息后，消息将自动确认。</p>\n<p>如下代码是设置成仅一次消费的例子。注释内容解释哪部分设置可忽略，以得到更多灵活保证。</p>\n<p><strong>Java版本</strong></p>\n<pre><code>   final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n    env.enableCheckpointing(...);// 仅一次或至少一次，检查点是必须的\n    \n    final RMQConnectionConfig connectionConfig = new RMQConnectionConfig.Builder()\n        .setHost(\"localhost\")\n        .setPort(5000)\n        ...\n        .build();\n    \n    final DataStream&lt;String&gt; stream = env\n        .addSource(new RMQSource&lt;String&gt;(\n            connectionConfig,            // rabbitmq连接的配置\n            \"queueName\",                 // rabbitmq的队列名，消费的队列名\n            true,                        // 使用相关编号，至少一次时设置为false\n            new SimpleStringSchema()))   // 反序列化成java的对象\n        .setParallelism(1);              // 非并行是仅一次所必须的\n</code></pre>\n<p><strong>Scala版本</strong></p>\n<pre><code>val env = StreamExecutionEnvironment.getExecutionEnvironment\nenv.enableCheckpointing(...)\n\nval connectionConfig = new RMQConnectionConfig.Builder()\n    .setHost(\"localhost\")\n    .setPort(5000)\n    ...\n    .build\n\nval stream = env\n    .addSource(new RMQSource[String](\n        connectionConfig,            // 配置\n        \"queueName\",                 // 队列名\n        true,                        // 使用相关编号\n        new SimpleStringSchema))     // 反序列化\n    .setParallelism(1)               // 非序列化\n</code></pre>\n<p><strong>Rabbitmq接收</strong></p>\n<p>连接器提供类RMQSink来发送消息到rabbitmq队列里，以下代码是一个rabbitmq接收的配置例子，</p>\n<p><strong>Java版本</strong></p>\n<pre><code>final DataStream&lt;String&gt; stream = ...\n\nfinal RMQConnectionConfig connectionConfig = new RMQConnectionConfig.Builder()\n    .setHost(\"localhost\")\n    .setPort(5000)\n    ...\n    .build();\n\nstream.addSink(new RMQSink&lt;String&gt;(\nconnectionConfig,\n    \"queueName\",\nnew SimpleStringSchema()));  //序列化\nval stream: DataStream[String] = ...\n</code></pre>\n<p><strong>Scala版本</strong></p>\n<pre><code>val connectionConfig = new RMQConnectionConfig.Builder()\n    .setHost(\"localhost\")\n    .setPort(5000)\n    ...\n    .build\n\nstream.addSink(new RMQSink[String](\n    connectionConfig,\n\"queueName\",\n    new SimpleStringSchema))\n</code></pre>\n<p><a href=\"http://www.rabbitmq.com/\">更多rabbitmq可从此了解。</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-06 08:33:39", "summary": "连接器许可证下的连接器位于一个依赖上，由许可。本身不重写中的源码，也不对其进行打包成二进制文件。用户基于的连接器即创建和发布拓展开的工作，可能会受到说明的一些限制。连接器该连接器访问流数据来源。为使用"}