{"blogid": "125577514", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "4574", "writerComment": "4379", "writerFan": "6331", "writerGrade": "7级", "writerIntegral": "13374", "writerName": "@每天都要敲代码", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125577514.jpg", "writerRankTotal": "799", "writerRankWeekly": "90", "writerThumb": "4854", "writerVisitNum": "80946", "blog_read_count": "1574", "blog_time": "已于 2022-07-09 09:33:05 修改", "blog_title": "深入理解面向对象（第二篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href=\"https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421\" title=\"@每天都要敲代码的个人主页\">@每天都要敲代码的个人主页</a><br/> 💬在我们学习的过程中，肯定需要刷题，巩固所学知识点；给大家推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站\">点击跳转刷题网站</a></p>\n<p><img alt=\"\" height=\"991\" src=\"..\\..\\static\\image\\af0db530aa524e3eb4380d6185946d5d.png\" width=\"1200\"/></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%F0%9F%A5%85package%E5%92%8Cimport-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85package%E5%92%8Cimport\">🏀面向对象</a></p>\n<p id=\"%F0%9F%A5%85package%E5%92%8Cimport-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%A5%85package%E5%92%8Cimport\">🥅package和import</a></p>\n<p id=\"%F0%9F%A5%85%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%A5%85%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\">🥅访问控制权限修饰符</a></p>\n<p id=\"%F0%9F%A5%85Object%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%A5%85Object%E7%B1%BB\">🥅Object类</a></p>\n<p id=\"%F0%9F%A5%85%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%A5%85%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\">🥅匿名内部类</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%F0%9F%A5%85package%E5%92%8Cimport\">🏀面向对象</h1>\n<h3>🥅package和import</h3>\n<p><strong>❤️package</strong></p>\n<blockquote>\n<p>1、为什么要使用package?</p>\n<p>    package是java中包机制，包机制的作用是为了方便程序的管理；</p>\n<p>    不同功能的类分别存放在不同的包下（按照功能划分的，不同软件包具有不同的功能）</p>\n<p>2、package是怎么用的？</p>\n<p>    package是一个关键字，后面加包名；例如：<span style=\"color:#0d0016;\"><strong>package com.dlu.javase.day01</strong></span></p>\n<p>    注意：<span style=\"color:#fe2c24;\">package语句只允许出现在java源代码的第一行</span></p>\n<p>3、包名的命名规范？</p>\n<p>    一般采用公司域名倒叙的方式（因为公司域名具有全球唯一性）</p>\n<p>    包名命名规范：公司域名倒序+/名+模块名+功能名</p>\n<p>4、对于带有package的java程序怎么编译？怎么运行？</p>\n<p><strong>   ⭐️以文本编译器为例：</strong></p>\n<p>   1、<strong>编译</strong>：<strong>javac -d . PackageTest01</strong></p>\n<p>   <span style=\"color:#fe2c24;\">    -d表示带包编译</span></p>\n<p><span style=\"color:#fe2c24;\">       .表示编译之后生成的class文件放到当前目录下</span></p>\n<p>   2、<strong>运行</strong>：<span style=\"color:#fe2c24;\">java com.dlu.javase.day01.PackageTest01</span></p>\n<p>   3、解释：实际上在PackageTest01.java文件目录下会生成com文件夹---》com文件夹下生成dlu文件夹---》dlu文件夹下生成javase文件夹---》javase文件夹下生成day01文件夹---》day01文件夹下生成PackageTest01.class文件。运行时还是在PackageTest01.java文件目录下执行：java com.dlu.javase.day01.PackageTest01即可！</p>\n<p><strong>  ⭐️IDEA编译器为例：</strong></p>\n<p>    1、先创建包(Package)；和创建类的时候步骤一致</p>\n<p>    2、创建包之后，在包下面再创建类，生成的类就会自动带上package com.dlu.javase.day01;然后直接运行就行</p>\n<pre><code class=\"language-java\">package com.dlu.javase.day01;\npublic class PackageTest01 {\n    public static void main(String[] args) {\n        System.out.println(\"HelloWorld\");\n    }\n}</code></pre>\n</blockquote>\n<p></p>\n<p><strong>❤️import</strong></p>\n<p><strong>⭐例1：两个类包名相同（包名能省略）</strong></p>\n<pre><code class=\"language-java\">package com.dlu.javase.day01; //包名与PackageTest01包名相同\n\npublic class Test01{\n\tpublic static void main(String[] args){\n\t\t// 创建PackageTest01对象\n\t\t//PackageTest01的完整类名是：com.dlu.javase.day01.PackageTest01（这是带包的情况下类名）\n\t\tcom.dlu.javase.day01.PackageTest01 hw = new com.dlu.javase.day01.PackageTest01();\n\t\tSystem.out.println(hw);//com.dlu.javase.day01.PackageTest01@15db9742\n\n\t\t//包名省略？---也没问题\n\t\t//这里的包名之所以可以省略，是因为PackageTest01和Test01在同一个Package(包)下\n\t\tPackageTest01 hw1 = new PackageTest01();\n\t\tSystem.out.println(hw1);//com.dlu.javase.day01.PackageTest01@6d06d69c\n\t}\n}</code></pre>\n<p><strong>⭐例2：两个类包名不同（包名不能省略，可以用import进行导包）</strong></p>\n<blockquote>\n<p>1、import什么时候使用？例如：A类中使用B类：<br/>         A和B类都在同一个包下；不需要import!<br/>         A和B类不在同一个包下；需要使用import!</p>\n<p>       <span style=\"color:#fe2c24;\"><strong>默认java.lang.*；这个包下的类(直接子类)都不需要使用import导入 </strong></span>    </p>\n<p>2、import怎么用？<br/>         <strong>import语句只能出现在package语句下，class声明语句之前。</strong><br/>     <strong>    import语句也可以采用星号(*)的方式，星号省略的是当前类名，不能多省略</strong></p>\n</blockquote>\n<pre><code class=\"language-java\">package com; //包名与PackageTest01包名不相同\n\n//import com.dlu.javase.day01.PackageTest01;//导如需要的包\nimport com.dlu.javase.day01.*;//采用星号的方式也是可以的\n\npublic class Test02{\n\tpublic static void main(String[] args){\n\t\t// 创建PackageTest01对象\n\t\tcom.dlu.javase.day01.PackageTest01 hw = new com.dlu.javase.day01.PackageTest01();\n\t\tSystem.out.println(hw);//com.dlu.javase.day01.PackageTest01@15db9742\n\n\t\t//这里包名就不能省略:\n\t\t/*\n\t\t  Test02在com包下\n\t\t  PackageTest01在com.dlu.javase.day01下\n\t\t  不在同一个包下，包名不能省略\n\t\t*/\n\t\t/*\n\t\t但是我们每次创建PackageTest01对象又很麻烦，那么长的类名；所以这就需要import\n\t\tPackageTest01 hw1 = new PackageTest01();\n\t\tSystem.out.println(hw1); //err\n\t\t*/\n\n\t\t//import com.dlu.javase.day01.PackageTest01导入包以后，就可以省略包了\n\t\tPackageTest01 hw2 = new PackageTest01();\n\t\tSystem.out.println(hw2);//com.dlu.javase.day01.PackageTest01@6d06d69c\n\t}\n}</code></pre>\n<p></p>\n<p><strong>❤️解释遗留问题Scanner</strong></p>\n<pre><code class=\"language-java\">package com.dlu.javase.day01;\nimport java.util.Scanner;//导包\n//import java.util.*;//也可以\n\npublic class Test03{\n\tpublic static void main(String[] args){\n\t\t//为什么这样写？\n\t\t//Test03类和Scanner类不在同一个包下；java.util就是Scanner的包名\n\t\t//java.util.Scanner s = new java.util.Scanner(System.in);\n\n\t\t//import导包的形式\n\t\tScanner s = new Scanner(System.in);\n\n\t\tString str = s.next();\n\t\tSystem.out.println(\"您输入的字符串是：\"+str);\n\n\t\t//String为什么不需要导包呢？\n\t\t//因为在lang包下的直接之类都不要导入（在比如：System）\n\t\tjava.lang.String name = \"张三\";\n\t\tString username = \"李四\";\n\t\tSystem.out.println(name);\n\t\tSystem.out.println(username);\n\t}\n}</code></pre>\n<p></p>\n<p><strong> ❤️总结</strong></p>\n<blockquote>\n<p><strong>⭐package（对于文本编译器）</strong><br/>      第一：package出现在java源文件第一行。<br/>      第二：带有包名怎么编译？javac -d . xxx.java<br/>      第三：怎么运行？java 完整类名<br/>      补充：以后说类名的时候，如果带着包名描述，表示完整类名。如果没有带包，描述的话，表示简类名。例如：<br/>         （1）java.util.Scanner 完整类名。<br/>         （2）Scanner 简类名</p>\n<p></p>\n<p><strong>⭐import（对于文本编译器）</strong><br/>       1、import什么时候不需要？<br/>            <span style=\"color:#fe2c24;\"> java.lang下的不需要，同包下不需要</span>；其它一律都需要！</p>\n<p>      2、怎么用？<br/>            （1）import 完整类名;</p>\n<p>                 import java.util.Scanner; // 完整类名。</p>\n<p>           （2）或者import 包名.*</p>\n<p>                  import java.util.*;</p>\n<p>                  编译器在编译的时候，会自动<span style=\"color:#fe2c24;\">把*变成具体的类名</span>。</p>\n<p>           （3）想省但也不能太省了。<br/>                   import java.*;</p>\n<p>                  这是不允许的，因为在java语言中规定，这里的<span style=\"color:#fe2c24;\">*只代表某些类的名字</span>。</p>\n<p>      3、<strong>不同包名下的相同类名不会冲突；例如：org.Test和com.Test不会冲突</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"%F0%9F%A5%85%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\">🥅访问控制权限修饰符</h3>\n<blockquote>\n<p>1、访问控制权限都有哪些？4个。<br/>         private       私有</p>\n<p>        protected   受保护<br/>         public        公开<br/>         默认（什么都没有）</p>\n</blockquote>\n<blockquote>\n<p>2、以上的4个访问控制权限：控制的范围是什么？<br/>        <span style=\"color:#fe2c24;\"><strong>（1）private 表示私有的，只能在本类中访问</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>       （2）protected表示只能在本类、同包、子类中访问。</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>       （3）public 表示公开的，在任何位置都可以访问<br/>        （4）“默认”表示只能在本类，以及同包下访问。<br/>        </strong></span></p>\n<pre><code>   访问控制修饰符            本类            同包            子类            任意位置\n        ---------------------------------------------------------------------------\n        public              可以            可以            可以            可以\n        protected           可以            可以            可以            不行\n        默认                可以            可以            不行            不行\n        private             可以            不行            不行            不行</code></pre>\n<p><strong>范围从大到小排序：public(4) &gt; protected(3) &gt; 默认(2) &gt; private(1)</strong></p>\n</blockquote>\n<blockquote>\n<p>3、访问控制权限修饰符可以修饰什么？<br/>         <strong>属性（4个都能用）<br/>         方法（4个都能用）<br/>         类（public和默认能用，其它不行。）<br/>         接口（public和默认能用，其它不行。）</strong></p>\n</blockquote>\n<p><strong>❤️例：在com.dlu包下的User类</strong></p>\n<pre><code>package com.dlu;\n\npublic class User{\n\t// 私有的\n\tprivate int id;\n\t// 受保护的\n\tprotected int age;\n\t// 公开的\n\tpublic int weight;\n\t//什么也没有,默认的\n\tString name;\n}</code></pre>\n<p><strong>⭐【包没变】在User类(com.dlu)相同包下的Test(com.dlu)类：只有private修饰的不能访问；区分出来第一个private</strong></p>\n<pre><code>package com.dlu;\n\npublic class Test{\n\tpublic static void main(String[] args){\n\t\tUser u = new User();\n\t\t//System.out.println(u.id); // private私有的不可以访问\n\t\tSystem.out.println(u.age); //protected可以访问\n\t\tSystem.out.println(u.weight); //public可以访问\n\t\tSystem.out.println(u.name); //默认的可以访问\n\t}\n}</code></pre>\n<p><strong>⭐【包变了】在User类(com.dlu)不同包下的Test01(com.dlu01)类：只有public能访问；区分出来第二个public</strong></p>\n<pre><code>package com.dlu01; //包变了\nimport com.dlu.User; //导包\n\npublic class Test01{\n\tpublic static void main(String[] args){\n\t\tUser u = new User();\n\t  System.out.println(u.id); // private私有的不可以访问\n\t   //System.out.println(u.age); //protected不可以访问\n\t\tSystem.out.println(u.weight); //public修饰的可以访问\n\t  //System.out.println(u.name); //默认的不可以访问\n\t}\n}</code></pre>\n<p><strong>⭐【包变了】在User类(com.dlu)不同包下的Test02(com.dlu02)类，并且Test02继承User类；区分出protected</strong></p>\n<pre><code class=\"language-java\">package com.dlu02; //包变了\nimport com.dlu.User; //导包\n\n//User在com.dlu包下；Test在com.dlu02包下；User和Test不在同一个包\n//但是Test02是User的子类\npublic class Test02 extends User{\n\tpublic static void main(String[] args){\n\t\tTest02 t = new Test02();\n\n\t\tSystem.out.println(t.age); // protected修饰的可以访问\n\t\t//System.out.println(t.name); //默认的不能访问\n\t}\n\t\n}</code></pre>\n<p></p>\n<h3 id=\"%F0%9F%A5%85Object%E7%B1%BB\">🥅Object类</h3>\n<blockquote>\n<p><strong>JDK类库的根类：Object</strong></p>\n<p>⭐这个老祖宗类中的方法我们需要先研究一下，因为这些方法都是所有子类通用的。<br/>     <span style=\"color:#fe2c24;\">任何一个类默认继承Object</span>。就算没有直接继承，最终也会间接继承。</p>\n<p>⭐Object类当中有哪些常用的方法？我们去哪里找这些方法呢？<br/>             第一种方法：去源代码当中；但是这种方式比较麻烦，源代码也比较难；</p>\n<p>            C:\\Program Files\\Java\\jdk-13.0.2\\lib\\src\\java.base\\java\\lang包下的Object类<br/>             第二种方法：去查阅java的类库的帮助文档。</p>\n<p>            例如我安装的：jdk1.8：C:\\Java学习\\javaSE学习\\6.JDK帮助文档\\jdk8-oracle官方英文-帮助文档\\jdk8帮助文档\\java\\lang下的Object.html<br/> ⭐什么是API？<br/>             应用程序编程接口。（Application Program Interface）<br/>             整个JDK的类库(src)就是一个javase的API。<br/>             每一个API都会配置一套API帮助文档。<br/>             SUN公司提前写好的这套类库就是API。(一般每一份API都对应一份API帮助文档。)</p>\n<p>⭐目前为止我们只需要知道这几个方法即可：<br/>         </p>\n<pre><code class=\"language-java\">    protected Object clone()   // 负责对象克隆的(以后接触再讲)。\n    int hashCode()    // 获取对象哈希值的一个方法。\n    boolean equals(Object obj)  // 判断两个对象是否相等\n    String toString()  // 将对象转换成字符串形式\n    protected void finalize()  // 垃圾回收器负责调用的方法</code></pre>\n</blockquote>\n<p><strong>❤️例1：Object类的toString方法</strong></p>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\">1、源代码</p>\n<pre><code class=\"language-java\">public String toString() {\n return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); \n} </code></pre>\n<p style=\"margin-left:0;text-align:justify;\"><strong>toString()方法默认实现是：类名+@+对象的内存地址转换为十六进制的形式</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">2、Sun公司设计toString()方法的目的是什么？ 通过调用这个方法可以将一个“java对象”转换成“字符串表示形式”</p>\n<p style=\"margin-left:0;text-align:justify;\">3、<span style=\"color:#fe2c24;\">建议所有的子类都去重写toString()方法</span>，toString()方法应该是一个简洁的、详实的、易阅读的 </p>\n</blockquote>\n<pre><code class=\"language-java\">public class ObjectToString {\n    public static void main(String[] args) {\n        MyTime mt = new MyTime(2022,1,1);\n        //重写toString()方法之前\n        System.out.println(mt); //MyTime@4554617c；默认会调用toString方法\n        //重写toString()方法之后\n        System.out.println(mt); //2022年1月1月(简洁的、详实的、易阅读的)\n    }\n}\n\nclass MyTime{ //默认继承Object类\n    private int year;\n    private int month;\n    private int day;\n    //构造方法\n    public MyTime() {\n    }\n    public MyTime(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n\n    //重写toString()方法\n    public String toString(){\n        return this.year+\"年\"+this.month+\"月\"+this.day+\"月\";\n    }\n}\n</code></pre>\n<p></p>\n<p><strong>❤️例2：Object类的equals方法</strong></p>\n<blockquote>\n<p>1、源代码</p>\n<pre><code class=\"language-java\">public boolean equals(Object obj) {\n    return (this == obj);\n}</code></pre>\n<p>2、Sun公司设计equals方法的目的是什么？ 通过equals方法来判断两个对象是否相等<br/> 3、我们需要研究一下Object类给的这个默认equals方法够不够用？（不够用） 在Object类当中的equals方法当中，默认采用的是“==”判断两个java对象是否相等； 而<strong><span style=\"color:#fe2c24;\">“==”判断的是两个java对象的内存地址</span></strong>，<strong>我们应该判断两个java对象的内容是否相等；要使用equals方法！</strong></p>\n</blockquote>\n<pre><code class=\"language-java\">public class ObjectEquals {\n    public static void main(String[] args) {\n    //1.判断两个基本数据类型是否相等，直接用“==”\n        // \"==\"是判断a中保存的100和b中保存的100是否相等\n        int a = 10;\n        int b = 10;\n        System.out.println(a == b);// true\n    //2.判断两个java对象是否相等呢？（直接用==）\n        // 这里的“==”判断的是t1中保存的对象内存地址和t2中保存的对象内存地址是否相等\n        MyTime01 t1 = new MyTime01(2008,8,8);\n        MyTime01 t2 = new MyTime01(2008,8,8);\n        System.out.println(t1 == t2);// false；\n        // 但实际上这两个对象表示的时间是一样的，所以这两个对象应该是相同的true，\n        // 所以不能用\"==\"来直接判断两个对象是否相等\n\n    //3.判断两个java对象是否相等呢？（调用equals方法）\n        //---重写equals方法之前，默认调用的是Object类的equals方法\n        boolean bool = t1.equals(t2);//多态\n        System.out.println(bool);\n        //---重写equals方法之后\n        System.out.println(t1.equals(t2));\n\n    //4.目前程序有bug嘛，如果为空呢？（没有,但是效率低，进行改良）\n        MyTime01 t3 = null;\n        System.out.println(t1.equals(t3));\n        //没有bug，因为下面有instanceof进行判断，空指针直接就return false\n    }\n}\n\nclass MyTime01 { //默认继承Object类\n    private int year;\n    private int month;\n    private int day;\n\n    public MyTime01() {\n    }\n\n    public MyTime01(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n\n    //-----------重写equals方法\n    public boolean equals(Object obj) {\n        //当年、月、日都相同，表示日期相同\n\n        //获取第一个日期的年月日\n        int year1 = this.year;\n        int month1 = this.month;\n        int day1 = this.day;\n\n        //obj访问不到年月日，要想访问子类型中特有的东西，所以要进行向下转型\n        if(obj instanceof MyTime01){ //判断\n            MyTime01 mt = (MyTime01)obj;\n            int year2 = mt.year;\n            int month2 = mt.month;\n            int day2 = mt.day;\n\n            if(year1 == year2 &amp;&amp; month1 == month2 &amp;&amp; day1 == day2){\n                return true;\n            }\n        }\n        return false;\n    }\n\n   /* ------------------代码优化\n   public boolean equals(Object obj) {\n        //1.先判断空\n        if(obj == null){\n            return false;\n        }\n        //2.判断是不是MyTime01对象\n        if(!(obj instanceof MyTime01)){\n            return false;\n        }\n        //3.判断内存地址是否相等，内存地址相等，肯定是同一个对象\n        if(this == obj){\n            return true;\n        }\n        //4.直接进行比较\n        MyTime01 tt = (MyTime01)obj;\n        if(this.year == tt.year &amp;&amp; this.month == tt.month &amp;&amp; this.day == tt.day){\n            return true;\n        }\n        return false;\n    }\n    */\n\n   /* -------------------代码再次优化\n   public boolean equals(Object obj) {\n        if(obj == null || !(obj instanceof MyTime01)){\n            return false;\n        }\n        if(this == obj){\n            return true;\n        }\n        MyTime01 tt = (MyTime01)obj;\n        return this.year == tt.year &amp;&amp; this.month == tt.month &amp;&amp; this.day == tt.day;\n    }\n    */\n\n\n   /*-----------------也可以利用IDEA自动生成\n    public String toString() {\n        return \"MyTime01{\" +\n                \"year=\" + year +\n                \", month=\" + month +\n                \", day=\" + day +\n                '}';\n    }\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        MyTime01 myTime01 = (MyTime01) o;\n        return year == myTime01.year &amp;&amp;\n                month == myTime01.month &amp;&amp;\n                day == myTime01.day;\n    }\n\n    */\n\n}\n</code></pre>\n<p></p>\n<p><strong>⭐比较字符串的大小</strong></p>\n<blockquote>\n<p>1、java语言中的字符串String已经重写toString方法和重写equals方法</p>\n<p>2、比较两个两个字符串也不能使用\"==\";必须调用equals方法</p>\n<p>3、对于字符串比较大小，如果是直接写出来的，例如：String s = \"abc\"可以直接用\"==\"进行比较；如果是new出来的，例如：String s = new String(\"abc\")就必须使用equals方法进行比较；所以我们平时就<span style=\"color:#fe2c24;\">使用equals方法来判断引用数据类型</span>，更加的通用</p>\n<p>4、<strong>总结</strong>：<span style=\"color:#fe2c24;\">java中基本数据类型比较是否相等，使用\"==\"</span></p>\n<p><span style=\"color:#fe2c24;\">                java中引用数据类型比较是否相等，统一使用equals方法进行判断</span></p>\n</blockquote>\n<pre><code class=\"language-java\">public class ObjectEquals02 {\n    public static void main(String[] args) {\n    //大部分情况下，采用这样的方式创建字符串对象\n    String s1 = \"hello\";\n    String s2 = \"abc\";\n\n    //实际上String也是一个类，不属于基本数据类型，既然是一个类一定有构造方法\n    String s3 = new String(\"Test1\");\n    String s4 = new String(\"Test1\");\n    System.out.println(s3 == s4);//false,因为比较的是内存的地址\n\n    //比较两个两个字符串也不能使用\"==\";必须调用重写的equals方法\n    //对于String类已经重写了String和toString方法\n    System.out.println(s3.equals(s4));// true\n    //也重写了toString方法\n    System.out.println(s3);// Test1\n    }\n}\n</code></pre>\n<p></p>\n<p><strong>⭐一个综合的例题</strong></p>\n<pre><code class=\"language-java\">\npublic class ObjectEquals03 {\n    public static void main(String[] args) {\n        Student s1 = new Student(1234,\"六盘水\");\n        Student s2 = new Student(1234,\"六盘水\");\n        System.out.println(s1.equals(s2)); // 多态\n    }\n}\n\nclass Student{\n    private int id;\n    private String school;\n    //构造方法\n    public Student() {\n    }\n    public Student(int id, String school) {\n        this.id = id;\n        this.school = school;\n    }\n\n    //当学号和学校相同，表示是同一个学生\n    public boolean equals(Object obj){\n        if(obj == null || !(obj instanceof Student)){\n            return false;\n        }\n        if(this == obj){\n            return true;\n        }\n        Student s = (Student)obj; // 向下转型\n        return this.id == s.id &amp;&amp; this.school.equals(s.school);\n    }\n}</code></pre>\n<p></p>\n<p><strong>⭐equals方法深层次理解（重点掌握）</strong></p>\n<blockquote>\n<p>对于equals方法我们重写要彻底！</p>\n</blockquote>\n<pre><code class=\"language-java\">//equals方法重写要彻底\npublic class ObjectEquals04 {\n    public static void main(String[] args) {\n        /*Address1 addr = new Address1(\"安徽\",\"西城区\",\"1111\");\n        User1 u = new User1(\"张三\",addr);*/\n\n        //就等价于\n        User1 u1 = new User1(\"张三\",new Address1(\"安徽\",\"西城区\",\"1111\"));\n        User1 u2 = new User1(\"张三\",new Address1(\"安徽\",\"西城区\",\"1111\"));\n        System.out.println(u1.equals(u2));\n    }\n}\n\nclass User1{\n    String name;\n    Address1 addr;\n    //构造方法\n    public User1() {\n    }\n    public User1(String name, Address1 addr) {\n        this.name = name;\n        this.addr = addr;\n    }\n    //重写equals\n    //规则：当一个用户的用户名和家庭住址都相同，表示同一个用户\n    public boolean equals(Object obj){\n        if(obj == null || !(obj instanceof User1)){\n            return false;\n        }\n        if(this == obj){\n            return true;\n        }\n        User1 u = (User1)obj;\n        return this.name.equals(u.name) &amp;&amp; this.addr.equals(u.addr);\n    }\n}\n\nclass Address1{\n    String city;\n    String street;\n    String zipcode;\n    //构造方法\n    public Address1() {\n    }\n    public Address1(String city, String street, String zipcode) {\n        this.city = city;\n        this.street = street;\n        this.zipcode = zipcode;\n    }\n\n    // 注意：这里如果没有重写equals方法；调用的是Object的equals方法，比较的是addr内存的地址\n    // 这里的equals方法判断的是：Address对象和Address对象是否相等\n    //所以这里也要重写equals，重写必须彻底！\n    //前面String我们没有进行重写是因为默认String类已经重写了equals方法\n    public boolean equals(Object obj) {\n       if(obj == null || !(obj instanceof Address1)){\n           return false;\n       }\n       if(this == obj){\n           return true;\n       }\n       Address1 address = (Address1)obj;\n       return this.city.equals(address.city) &amp;&amp; this.street.equals(address.street) &amp;&amp; this.zipcode.equals(address.zipcode);\n    }\n}</code></pre>\n<p></p>\n<p><strong>❤️例3：Object的finalize方法（了解）</strong></p>\n<blockquote>\n<p>1、在Object类中的源代码：</p>\n<pre><code class=\"language-java\">   protected void finalize() throws Throwable { }\n   // GC：负责调用finalize()方法</code></pre>\n<p>2、<span style=\"color:#fe2c24;\">finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的</span></p>\n<p>3、这个<strong>方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。</strong></p>\n<p>   不像equals、toString方法是需要程序员手动调用的；finalize只需要重写，重写完成后自动会有程序来调用</p>\n<p>4、finalize执行的时机：</p>\n<p>   <strong>当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用finalize()方法</strong></p>\n<p>5、<strong>finalize()方法</strong>实际上是SUN公司为java程序员准备的一个时机，<strong>垃圾销毁时机</strong>。</p>\n<p>   如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法中</p>\n<p>6、回顾：静态代码块的作用是什么？static{....}</p>\n<p> <strong><span style=\"color:#fe2c24;\">  静态代码块在类加载时刻执行，并且只执行一次；这是一个SUN准备的类加载时机</span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\">   finalize()方法同样也是SUN为程序员准备的一个时机，这个时机是垃圾回收时机</span></strong></p>\n<p>7、java中的垃圾回收器不是轻易启动的，垃圾太少，或者时间没到等，也有可能不启动 </p>\n</blockquote>\n<pre><code class=\"language-java\">public class ObjectFinalize {\n    public static void main(String[] args) {\n        /*Person1 p = new Person1();\n        // 怎么把Person对象变成垃圾？\n        p = null; // 这里可能就没有启动\n\n        //多造点垃圾，就可以启动\n        for(int i=0;i&lt;1000000;i++){\n            Person1 p1 = new Person1();\n            p1 = null;\n        }*/\n\n        //有一段代码可以建议垃圾回收器启动\n        Person1 p = new Person1();\n        p = null;\n        System.gc();// 建议启动垃圾回收器(知识启动的可能性增大了)\n\n    }\n}\n\nclass Person1{\n    // 重写finalize方法\n    // Person类型的对象被垃圾回收器回收的时候，垃圾回收器负责调用p.finalize();\n    protected void finalize() throws Throwable {\n        System.out.println(this+\"即将被销毁！\");\n    }\n}</code></pre>\n<p></p>\n<p><strong>❤️例4：Object的hashCode方法</strong></p>\n<blockquote>\n<p>1、在Object中的hashCode方法是怎样的？     </p>\n<pre><code class=\"language-java\"> public native int hashCode();\n // 这个方法不是抽象方法，带有native关键字，底层调用C++程序。</code></pre>\n<p>2、hashCode()方法返回的是哈希码：</p>\n<p>      <strong>实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值</strong>。</p>\n<p>      所以<span style=\"color:#fe2c24;\">hashCode()方法的执行结果可以等同看做一个java对象的内存地址</span>。</p>\n</blockquote>\n<pre><code class=\"language-java\">public class ObjectHashCode{\n    public static void main(String[] args){\n        Object o = new Object();\n        int hashCodeValue = o.hashCode();\n        // 对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。\n        System.out.println(hashCodeValue); //1163157884\n\n        MyClass mc = new MyClass();\n        int hashCodeValue2 = mc.hashCode();\n        System.out.println(hashCodeValue2); //1956725890\n\n    }\n}\n\nclass MyClass\n{\n}\n</code></pre>\n<p></p>\n<h3 id=\"%F0%9F%A5%85%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\">🥅匿名内部类</h3>\n<p><strong>❤️内部类概述</strong></p>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>匿名内部类：</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">       1、什么是内部类？</p>\n<p style=\"margin-left:0;text-align:justify;\">           内部类：在类的内部又定义了一个新的类。被称为内部类。</p>\n<p style=\"margin-left:0;text-align:justify;\">       2、内部类的分类：</p>\n<p style=\"margin-left:0;text-align:justify;\">              静态内部类：类似于静态变量</p>\n<p style=\"margin-left:0;text-align:justify;\">              实例内部类：类似于实例变量</p>\n<p style=\"margin-left:0;text-align:justify;\">              局部内部类：类似于局部变量</p>\n<p style=\"margin-left:0;text-align:justify;\">      3、使用内部类编写的代码，可读性很差。能不用尽量不用。</p>\n<p style=\"margin-left:0;text-align:justify;\">      4、<strong>匿名内部类是局部内部类的一种</strong>。</p>\n<p style=\"margin-left:0;text-align:justify;\">            因为这个类没有名字而得名，叫做匿名内部类。</p>\n<p style=\"margin-left:0;text-align:justify;\">      5、学习匿名内部类主要是以后在阅读别人代码的时候，能够理解。</p>\n<p style=\"margin-left:0;text-align:justify;\">       并不代表以后都要这样写。因为匿名内部类有两个缺点：</p>\n<p style=\"margin-left:0;text-align:justify;\">           缺点1：太复杂，太乱，可读性差。</p>\n<p style=\"margin-left:0;text-align:justify;\">           缺点2：类没有名字，以后想重复使用，不能用。</p>\n</blockquote>\n<pre><code class=\"language-java\">public class InnerTest01{\n\n    // 静态变量\n    static String country;\n    //1. 静态内部类\n    static class Inner1{\n    }\n    // 实例变量\n    int age;\n    //2. 实例内部类。\n    class Inner2{\n    }\n    // 方法\n    public void doSome(){\n        // 局部变量\n        int i = 100;\n        //3. 局部内部类。\n        class Inner3{\n        }\n    }\n    \n    public void doOther(){\n        // doSome()方法中的局部内部类Inner3，在doOther()中不能用。\n    }\n    \n//--------------------------------------------------------------------    \n    \n    // main方法，入口\n    public static void main(String[] args){\n        // 调用MyMath中的mySum方法。\n        MyMath001 mm = new MyMath001();\n\t\t/*\n\t\tCompute c = new ComputeImpl();\n\t\tmm.mySum(c, 100, 200);\n\t\t*/\n\n        //代码合并\n        //我们调用的时候里面传的是接口Compute c：mySum(Compute c, int x, int y)；\n        //所以这里调用应该需要new一个接口传进去，又因为接口是抽象类，不能new对象，\n        //所以要写一个类ComputeImpl去实现接口，用来new对象\n        mm.mySum(new ComputeImpl(), 100, 200); \n\n    }\n\n}\n\n// 负责计算的接口\ninterface Compute{\n    // 抽象方法\n    int sum(int a, int b);\n}\n\n// 编写一个Compute接口的实现类ComputeImpl\nclass ComputeImpl implements Compute{\n\t// 对方法的实现\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n}\n\n// 数学类\nclass MyMath001{\n    // 数学求和方法\n    public void mySum(Compute c, int x, int y){ //Compute c 把这个接口看成String name更好理解\n        int retValue = c.sum(x, y);\n        System.out.println(x + \"+\" + y + \"=\" + retValue);\n    }\n}\n</code></pre>\n<p><strong>❤️内部类的使用</strong></p>\n<blockquote>\n<p>使用匿名内部类，下面那个ComputeImpl类实现Compute接口就不需要写了！对于匿名内部类能看懂代码就行，可读性差，且不能重复使用！</p>\n</blockquote>\n<pre><code class=\"language-java\">public class InnerTest02{\n\n    // main方法，入口\n    public static void main(String[] args){\n        // 调用MyMath中的mySum方法。\n        MyMath001 mm = new MyMath001();\n        //我们不使用Compute接口的实现类ComputeImpl；使用匿名内部类实现\n        //mm.mySum(new ComputeImpl(), 100, 200);\n\n        //使用匿名内部类，记住语法；以后能看懂就行\n        mm.mySum(new Compute() {\n            public int sum(int a, int b) {\n                return a+b;\n            }\n        },100,200);\n\n    }\n\n}\n\n// 负责计算的接口\ninterface Compute{\n    // 抽象方法\n    int sum(int a, int b);\n}\n\n//-------使用匿名内部类，接口的实现就不需要了\n/*// 编写一个Compute接口的实现类ComputeImpl\nclass ComputeImpl implements Compute{\n    // 对方法的实现\n    public int sum(int a, int b){\n        return a + b;\n    }\n}*/\n\n// 数学类\nclass MyMath001{\n    // 数学求和方法\n    public void mySum(Compute c, int x, int y){ //Compute c 把这个接口看成String name更好理解\n        int retValue = c.sum(x, y);\n        System.out.println(x + \"+\" + y + \"=\" + retValue);\n    }\n}\n\n</code></pre>\n<h1></h1>\n<h1>结束语</h1>\n<blockquote>\n<p>今天的分享就到这里，想要提升编程思维的，快快去注册牛客网开始刷题吧！各种大厂面试真题在等你哦！</p>\n<p> 💬刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站\">点击跳转刷题网站</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"511\" src=\"..\\..\\static\\image\\184068dc41e94efbb14e555f972eaa17.png\" width=\"1200\"/></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-09 09:33:05", "summary": "作者简介：大家好我是每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！个人主页：每天都要敲代码的个人主页每天都要敲代码的个人主页在我们学习的过程中，肯定需要刷题，巩固所学知识点；给大家推荐"}