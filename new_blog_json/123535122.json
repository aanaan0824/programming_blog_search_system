{"blogid": "123535122", "writerAge": "码龄4年", "writerBlogNum": "546", "writerCollect": "181", "writerComment": "4", "writerFan": "40", "writerGrade": "6级", "writerIntegral": "5527", "writerName": "anieoo", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123535122.jpg", "writerRankTotal": "5473", "writerRankWeekly": "17563", "writerThumb": "45", "writerVisitNum": "103713", "blog_read_count": "6288", "blog_time": "已于 2022-03-18 17:51:56 修改", "blog_title": "动态规划：01背包问题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、什么是01背包问题？</h1>\n<p>        举个例子，你要去一个水果摊拿水果，每种水果都有对应的两种属性：占用的体积V和蕴含的价值W。而你的背包体积为N。老板说：每种水果只能拿一个！因此对于咱们肯定得想一种搭配方式使得拿的水果总体积不超过背包容积，但是价值总和达到最大！</p>\n<p>       <strong> 核心思想：</strong></p>\n<p><img alt=\"\" height=\"648\" src=\"..\\..\\static\\image\\cb8d227add3a45a985ee6441e76ce38c.png\" width=\"1200\"/></p>\n<p>      <strong> f[i][j]:</strong>表示所有选法集合中,只从前i个物品中选,并且总体积不大于j的选法的集合,它的值是这个集合中每一个选法的最大值。</p>\n<p>        对于01背包问题选择方法的集合可以分成2种：<br/> ①不选第i个物品，并且总体积不大于j的集合所达到的最大值:<strong>f[i-1][j]</strong><br/> ②选择1~i个物品，并且总体积不大于j的集合所达到的最大值<strong>f[i][j]</strong></p>\n<p>        对于第二种情况我们很难计算，因此需要思考从另一个角度解决问题。当选择1~i个物品，总体积不大于j的集合的最大值可以<strong>转化</strong>成选择1~i-1个物品，总体积不大于j-V[i]的集合+最后一个物品的价值：<strong>f[i-1][j-V[i]]+w[i]</strong></p>\n<h3><span style=\"color:#fe2c24;\"><strong>因此总结</strong>：f[i][j]= <strong>Max</strong>{f[i-1][j],f[i-1][j-v[i]]+w[i]}!!!</span></h3>\n<h1><strong>二、01背包例题</strong></h1>\n<p><strong>        #ACWing 2</strong></p>\n<p><img alt=\"\" height=\"695\" src=\"..\\..\\static\\image\\52d6f896e5494db3ab1ee2db913cd31a.png\" width=\"827\"/><br/>  </p>\n<p><strong> 代码：</strong></p>\n<p><strong>二维数组：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N=1010;\nint v[N],w[N],f[N][N];\nint n,m;\n\nint main()\n{\n  scanf(\"%d%d\",&amp;n,&amp;m);\n  \n  for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]);\n  \n  for(int i=1;i&lt;=n;i++)\n    for(int j=1;j&lt;=m;j++)\n    {\n      f[i][j]=f[i-1][j];\n      if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);\n    }    \n\n  printf(\"%d\",f[n][m]); \n  return 0;\n}</code></pre>\n<p><strong>##注意 ：为什么i和j从1开始遍历，因为如果i或j不管哪个为0,f[i][j]其实都等于0！！</strong></p>\n<p><strong>一维数组： 优化版</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N=1010;\nint v[N],w[N],f[N];\nint n,m;\n\nint main()\n{\n  scanf(\"%d%d\",&amp;n,&amp;m);\n  \n  for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]);\n  \n  for(int i=1;i&lt;=n;i++)\n    for(int j=m;j&gt;=v[i];j--)\n    {\n      f[j]=max(f[j],f[j-v[i]]+w[i]);\n    }\n    \n  printf(\"%d\",f[m]);\n  return 0;\n}</code></pre>\n<p> 如何优化:</p>\n<p>        从二维做法中可以看出<span style=\"color:#fe2c24;\">f[i] [j]</span>最大值的更新只用到了 <span style=\"color:#fe2c24;\">f[i-1] [j]</span>，即 <span style=\"color:#fe2c24;\">f[i-2][j]</span> 到 <span style=\"color:#fe2c24;\">f[0][j]</span> 是没有用的。</p>\n<p>所以第二层循环可以直接从<span style=\"color:#fe2c24;\">v[i] </span>开始。</p>\n<pre><code class=\"language-cpp\">for (int i = 1; i &lt;= n; i++) {\n    for (int j = v[i]; j &lt;= m; j++) {\n        f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);\n    }\n}</code></pre>\n<p>二维优化到一维后：</p>\n<p>        如果删掉f[i]这一维，结果如下：如果j层循环时递增的，则是错误的</p>\n<pre><code class=\"language-cpp\">for (int i = 1; i &lt;= n; i++) {\n    for (int j = v[i]; j &lt;= m; j++) {\n        f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n}</code></pre>\n<p><strong>模拟结果：</strong></p>\n<p><img alt=\"\" height=\"708\" src=\"..\\..\\static\\image\\70b9d60c22ac4d8193d792fff51c10e5.png\" width=\"1200\"/></p>\n<p>        可以看出处于 i == 1 这一层，即物品只有一件，不存在单件物品满足价值为6,8,10的，所以已经出错了。</p>\n<p>      <strong>  为什么一维情况下枚举背包容量需要逆序？</strong><br/>         在二维情况下，状态<span style=\"color:#fe2c24;\">f[i][j]</span>是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。</p>\n<p>        例如，一维状态第i轮对体积为 <span style=\"color:#fe2c24;\">3</span> 的物品进行决策，则<span style=\"color:#fe2c24;\">f[7]</span>由<span style=\"color:#fe2c24;\">f[4]</span>更新而来，这里的<span style=\"color:#fe2c24;\">f[4]</span>正确应该是<span style=\"color:#fe2c24;\">f[i - 1][4]</span>，但从小到大枚举j这里的f[4]在第i轮计算却变成了<span style=\"color:#fe2c24;\">f[i][4]</span>。当逆序枚举背包容量j时，我们求<span style=\"color:#fe2c24;\">f[7]</span>同样由<span style=\"color:#fe2c24;\">f[4]</span>更新，但由于是逆序，这里的<span style=\"color:#fe2c24;\">f[4]</span>还没有在第i轮计算，所以此时实际计算的<span style=\"color:#fe2c24;\">f[4]</span>仍然是<span style=\"color:#fe2c24;\">f[i - 1][4]</span>。</p>\n<p>   <strong>  如果 j 层循环是逆序的：</strong></p>\n<pre><code class=\"language-cpp\">for (int i = 1; i &lt;= n; i++) {\n        for (int j = m; j &gt;= v[i]; j--) {\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n        }\n    }</code></pre>\n<p><strong>模拟结果： </strong></p>\n<p><img alt=\"\" height=\"547\" src=\"..\\..\\static\\image\\0b29a3069c884955b5612aca066359fc.png\" width=\"732\"/></p>\n<p>模拟一下发现没有错误，即逆序就可以解决这个优化的问题了 </p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-18 17:51:56", "summary": "一、什么是背包问题？举个例子，你要去一个水果摊拿水果，每种水果都有对应的两种属性：占用的体积和蕴含的价值。而你的背包体积为。老板说：每种水果只能拿一个！因此对于咱们肯定得想一种搭配方式使得拿的水果总体"}