{"blogid": "125218622", "writerAge": "码龄4年", "writerBlogNum": "410", "writerCollect": "3111", "writerComment": "196", "writerFan": "2226", "writerGrade": "7级", "writerIntegral": "9051", "writerName": "前端技术栈", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125218622.jpg", "writerRankTotal": "1504", "writerRankWeekly": "804", "writerThumb": "412", "writerVisitNum": "770993", "blog_read_count": "9114", "blog_time": "已于 2022-08-11 14:28:11 修改", "blog_title": "2022最新Web前端经典面试试题及答案-史上最全前端面试题(含答案)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>程序员面试题库分享</h1>\n<h3><strong>1、前端面试题库 （</strong>面试必备）<strong>            <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://mp.weixin.qq.com/s?__biz=MzU5NzA0NzQyNg==&amp;mid=2247485824&amp;idx=3&amp;sn=70cd26a7c0c683de64802f6cb9835003&amp;scene=21#wechat_redirect\" title=\"前端面试题库\">前端面试题库</a></p>\n<h3><strong>2、前端技术导航大全      <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://webstatic-3g8wm74b420bf334-1301145096.tcloudbaseapp.com/webclass/index.html#/\" title=\"前端技术导航大全\">前端技术导航大全</a></p>\n<h3>3、开发者颜色值转换工具   <strong>推荐：★★★★★</strong></h3>\n<p>地址 ：<a href=\"https://color-4gr069g4ea217b7a-1301145096.tcloudbaseapp.com/color/index.html\" title=\"开发者颜色值转换工具\">开发者颜色值转换工具</a></p>\n<p></p>\n<h3>1、为什么typeof null 是object？</h3>\n<p>不同的数据类型在底层都是通过二进制表示的，二进制前三位为<code>000</code>则会被判断为<code>object</code>类型，</p>\n<p>而null底层的二进制全都是0，那前三位肯定也是<code>000</code>，所以被判断为<code>object</code></p>\n<h3>2、0.1 + 0.2 === 0.3，对吗？不对</h3>\n<p>JavaScript的计算存在精度丢失问题</p>\n<ul><li>原因：JavaScript中小数是浮点数，需转二进制进行运算，有些小数无法用二进制表示，所以只能取近似值，所以造成误差</li><li>解决方法： \n  <ul><li>先变成整数运算，然后再变回小数</li><li>toFixed() 性能不好，不推荐</li></ul></li></ul>\n<h3>3、addEventListence的第三个参数是干嘛的？</h3>\n<pre>xxx.addEventListence('click', function(){}, false)</pre>\n<p>第三个变量传一个布尔值，需不需要阻止冒泡，默认是false，不阻止冒泡</p>\n<h3>4、Ajax、Axios、Fetch有啥区别？</h3>\n<ul><li>Ajax：是对XMLHttpRequest对象（XHR）的封装</li><li>Axios：是基于Promise对XHR对象的封装</li><li>Fetch：是window的一个方法，也是基于Promise，但是与XHR无关，不支持IE</li></ul>\n<h3>5、load、$(document).ready、DOMContentLoaded的区别？</h3>\n<p>DOM文档加载的步骤为：</p>\n<ul><li>1、解析HTML结构。</li><li>2、加载外部脚本和样式表文件。</li><li>3、解析并执行脚本代码。</li><li>4、DOM树构建完成。// <code>DOMContentLoaded</code>触发、<code>$(document).ready</code>触发</li><li>5、加载图片等外部文件。</li><li>6、页面加载完毕。// <code>load</code>触发</li></ul>\n<h3>6、如何实现数组去重？</h3>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/1d7953a7680823971471a0d5eb9c3de8.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">// 使用 Map 去重\nfunction quchong1(arr) {\n  const newArr = []\n  arr.reduce((pre, next) =&gt; {\n    if (!pre.get(next)) {\n      pre.set(next, 1)\n      newArr.push(next)\n    }\n    return pre\n  }, new Map())\n  return newArr\n}\n\n// 使用 Set 去重\nfunction quchong (arr) {\n    return [...new Set(arr)]\n}</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9b1157c35032b6ecbaf69d4d756febbf.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<h3>7、call、apply、bind改变this</h3>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/1d7953a7680823971471a0d5eb9c3de8.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">const obj1 = {\n  name: '林三心',\n  sayName: function() {\n    console.log(this.name)\n  }\n}\nconst obj2 = {\n  name: 'Sunshin_Lin'\n}\n// 改变sayName的this指向obj2\nobj1.sayName.call(obj2) // Sunshin_Lin\n// 改变sayName的this指向obj2\nobj1.sayName.apply(obj2) // Sunshin_Lin\n// 改变sayName的this指向obj2\nconst fn = obj1.sayName.bind(obj2)\nfn() // Sunshin_Lin</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/d5b35101ee1e59f477a48aa4dd055b90.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<h3>8、BOM 和 DOM 的关系</h3>\n<p><strong>BOM</strong>全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。</p>\n<p>DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。</p>\n<p>JS是通过访问<strong>BOM</strong>（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于<strong>BOM</strong>的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，</p>\n<p>因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。</p>\n<p>可以说，BOM包含了DOM(对象)，浏览器提供出来<strong>给予访问的是BOM对象，从BOM对象再访问到DOM对象</strong>，从而js可以操作浏览器以及浏览器读取到的文档。</p>\n<h3>9、JS中的substr()和substring()函数有什么区别</h3>\n<p>substr() 函数的形式为substr(startIndex,length)。 它从startIndex返回子字符串并返回'length'个字符数。</p>\n<pre><code class=\"language-javascript\">var s = \"hello\";\n( s.substr(1,4) == \"ello\" ) // true</code></pre>\n<p>substring() 函数的形式为substring(startIndex,endIndex)。 它返回从startIndex到endIndex - 1的子字符串。</p>\n<pre><code class=\"language-javascript\">var s = \"hello\";\n( s.substring(1,4) == \"ell\" ) // true</code></pre>\n<h3>10、Object和Map的区别</h3>\n<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/2dcdc617589ed33141a30a15e3fcf1d0.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">const m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/2dcdc617589ed33141a30a15e3fcf1d0.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p>  将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/a843e2a9a49a0b58b7c0ebf9a632ab37.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">const map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/05c90b765387f3bd0a1152f367462338.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p>  Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<pre><code class=\"language-javascript\">const map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined</code></pre>\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/0ab5d5fe6f3bbb2c8a82aae25ec3d69e.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">const map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/89831112d65af81ebf9c5695969c0699.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</p>\n<p>这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<pre><code class=\"language-javascript\">let map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');</code></pre>\n<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>\n<h3>11、weakMap</h3>\n<p><code>WeakMap</code>只接受<strong>对象作为键名</strong>（<code>null</code>除外），不接受其他类型的值作为键名</p>\n<p>用途：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/49d975417392978c2ae5cd0ff1613403.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">let myWeakmap = new WeakMap();\n\nmyWeakmap.set(\n  document.getElementById('logo'),\n  {timesClicked: 0})\n;\n\ndocument.getElementById('logo').addEventListener('click', function() {\n  let logoData = myWeakmap.get(document.getElementById('logo'));\n  logoData.timesClicked++;\n}, false);</code></pre>\n<p>上面代码中，<code>document.getElementById('logo')</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。</p>\n<p>我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>\n<h3>12、(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3) 有可能是 true 吗？</h3>\n<p>当两个类型不同时进行==比较时，会将一个类型转为另一个类型，然后再进行比较。</p>\n<p>比如<code>Object</code>类型与<code>Number</code>类型进行比较时，<code>Object</code>类型会转换为<code>Number</code>类型。</p>\n<p><code>Object</code>转换为<code>Number</code>时，会尝试调用<code>Object.valueOf()</code>和<code>Object.toString()</code>来获取对应的数字基本类型。</p>\n<pre><code class=\"language-javascript\">var a = {\n    i: 1,\n    toString: function () {\n        return a.i++;\n    }\n}\nconsole.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) // true</code></pre>\n<h3>13、函数的length是多少？</h3>\n<p>可以看出，<code>function</code>有多少个形参，<code>length</code>就是多少；</p>\n<p>但是如果有默认参数，就是<code>第一个具有默认值之前的参数个数；剩余参数是不算进<code>length</code>的计算之中的</code></p>\n<pre><code class=\"language-javascript\">function fn1 (name) {}\n\nfunction fn2 (name = '仙人掌') {}\n\nfunction fn3 (name, age = 22) {}\n\nfunction fn4 (name, age = 22, gender) {}\n\nfunction fn5(name = '仙人掌', age, gender) { }\n\nconsole.log(fn1.length) // 1\nconsole.log(fn2.length) // 0\nconsole.log(fn3.length) // 1\nconsole.log(fn4.length) // 1\nconsole.log(fn5.length) // 0\n//剩余参数\nfunction fn6(name, ...args) {}\nconsole.log(fn6.length) // 1</code></pre>\n<h3>14、includes 比 indexOf好在哪？</h3>\n<p>includes可以检测<code>NaN</code>，indexOf不能检测<code>NaN</code>，includes内部使用了<code>Number.isNaN</code>对<code>NaN</code>进行了匹配</p>\n<h3>15、map、object和set的区别</h3>\n<p>map:对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数<code>Map</code>可以接受一个数组作为参数。</p>\n<p>object：</p>\n<ul><li>一个<code>Object</code> 的键只能是字符串或者 <code>Symbols</code>，但一个<code>Map</code> 的键可以是任意值。</li><li><code>Map</code>中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li><code>Map</code>的键值对个数可以从 size 属性获取，而 <code>Object</code> 的键值对个数只能手动计算。</li><li><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul>\n<p>set:对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。 </p>\n<p>总结：</p>\n<ul><li>初始化需要的值不一样，Map需要的是一个二维数组，而Set 需要的是一维 Array 数组</li><li> Map 和 Set 都不允许键重复</li><li>Map的键是不能修改，但是键对应的值是可以修改的；Set不能通过迭代器来改变Set的值，因为Set的值就是键。</li><li>Map 是键值对的存在，值也不作为健；而 Set 没有 value 只有 key，value 就是 key；</li></ul>\n<h3> 16、vue和react的diff算法的区别</h3>\n<p>vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。</p>\n<p>1. vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性</p>\n<p>2. vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效。</p>\n<p><strong>虚拟dom</strong>：一个用来标识真实DOM的对象</p>\n<pre><code class=\"language-html\">&lt;ul id=\"list\"&gt;\n    &lt;li class=\"item\"&gt;哈哈&lt;/li&gt;\n    &lt;li class=\"item\"&gt;呵呵&lt;/li&gt;\n    &lt;li class=\"item\"&gt;嘿嘿&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<p>对应的虚拟dom为：</p>\n<pre><code class=\"language-javascript\">let oldVDOM = { // 旧虚拟DOM\n        tagName: 'ul', // 标签名\n        props: { // 标签属性\n            id: 'list'\n        },\n        children: [ // 标签子节点\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['哈哈']\n            },\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['呵呵']\n            },\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['嘿嘿']\n            },\n        ]\n    }</code></pre>\n<p>这时候，我修改一个<code>li标签</code>的文本：</p>\n<pre><code class=\"language-html\">&lt;ul id=\"list\"&gt;\n    &lt;li class=\"item\"&gt;哈哈&lt;/li&gt;\n    &lt;li class=\"item\"&gt;呵呵&lt;/li&gt;\n    &lt;li class=\"item\"&gt;哈哈哈哈&lt;/li&gt; // 修改\n&lt;/ul&gt;</code></pre>\n<p>这就是咱们平常说的<code>新旧两个虚拟DOM</code>，这个时候的<code>新虚拟DOM</code>是数据的最新状态，那么我们直接拿<code>新虚拟DOM</code>去渲染成<code>真实DOM</code>的话，效率真的会比直接操作真实DOM高吗？那肯定是不会的，看下图：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\604b530497b6f9ba139f3097d9937bfe.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p></p>\n<p> 由上图，一看便知，肯定是第2种方式比较快，因为第1种方式中间还夹着一个<code>虚拟DOM</code>的步骤，所以<strong>虚拟DOM比真实DOM快</strong>这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？<strong>虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM</strong>，<code>虚拟DOM</code>和<code>虚拟DOM算法</code>是两种概念。<code>虚拟DOM算法 = 虚拟DOM + Diff算法</code></p>\n<p>什么是Diff算法</p>\n<p>上面说了<code>虚拟DOM</code>，也知道了只有<code>虚拟DOM + Diff算法</code>才能真正的提高性能，那讲完<code>虚拟DOM</code>，我们再来讲讲<code>Diff算法</code>吧，还是上面的例子</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\569ded23233d0074bd4a70e2c33cc6a9.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p style=\"text-align:center;\"> </p>\n<p>上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。</p>\n<p>总结：<strong>Diff算法是一种对比算法</strong>。对比两者是<code>旧虚拟DOM和新虚拟DOM</code>，对比出是哪个<code>虚拟节点</code>更改了，找出这个<code>虚拟节点</code>，并只更新这个虚拟节点所对应的<code>真实节点</code>，而不用更新其他数据没发生改变的节点，实现<code>精准</code>地更新真实DOM，进而<code>提高效率</code>。</p>\n<p><code>使用虚拟DOM算法的损耗计算</code>：总损耗 = 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘</p>\n<p><code>直接操作真实DOM的损耗计算</code>：总损耗 = 真实DOM完全增删改+（可能较多的节点）排版与重绘</p>\n<p>Diff算法的原理</p>\n<p><strong>Diff同层对比</strong></p>\n<p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。所以Diff算法是:<code>广度优先算法</code>。 时间复杂度:<code>O(n)</code></p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\e8eed9d84089c77ef7fe17dd36df2e0a.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p> <strong> Diff对比流程</strong></p>\n<p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，订阅者们就会调用<code>patch方法</code>，给真实DOM打补丁，更新相应的视图</p>\n<h3> 17、如何遍历输出页面上的所有元素</h3>\n<p>使用<strong>createNodeIterator</strong></p>\n<pre><code class=\"language-javascript\">const body = document.getElementByTagName(\"body\")[0]\nconst it = document.createNodeIterator(body)\nlet root = it.nextNode()\nwhile(root){\n      console.log(root)\n      root = it.nextNode()    \n}</code></pre>\n<h3>18、判断元素是否在可视区域内</h3>\n<p>使用getBoundingClientRect</p>\n<p><code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置。返回的是一个对象，</p>\n<p>对象里有这8个属性：<code>left，right，top，bottom，width，height，x，y</code></p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\56571402b5aabf0fe690899c0f2b20f7.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p></p>\n<p></p>\n<p>根据这个用处，咱们可以实现：<strong>懒加载和无限滚动</strong></p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/69b02c7e8244d47c5d52ae60d9afa543.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">&lt;div id=\"box\"&gt;&lt;/div&gt;\n\nbody {\n       height: 3000px;\n       width: 3000px;\n      }\n\n#box {\n       width: 300px;\n       height: 300px;\n       background-color: red;\n       margin-top: 300px;\n       margin-left: 300px;\n    }\n    \n// js\nconst box = document.getElementById('box')\n        window.onscroll = function () {\n            // box完整出现在视口里才会输出true，否则为false\n            console.log(checkInView(box))\n        }\n\nfunction checkInView(dom) {\n        const { top, left, bottom, right } = dom.getBoundingClientRect()\n        console.log(top, left, bottom, right)\n        console.log(window.innerHeight, window.innerWidth)\n        return top &gt;= 0 &amp;&amp;\n                left &gt;= 0 &amp;&amp;\n                bottom &lt;= (window.innerHeight || document.documentElement.clientHeight) &amp;&amp;\n                right &lt;= (window.innerWidth || document.documentElement.clientWidth)\n        }</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/4ebe4516dbb9efc9d71e4da36e4d380f.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<h3>19、getComputedStyle</h3>\n<p><code>Window.getComputedStyle()</code>方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。</p>\n<pre>window.getComputedStyle(element, pseudoElement)</pre>\n<ul><li><code>element</code>: 必需，要获取样式的元素。</li><li><code>pseudoElement</code>: 可选，伪类元素，当不查询伪类元素的时候可以忽略或者传入 null。</li></ul>\n<p>搭配<code>getPropertyValue</code>可以获取到具体样式</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9a61c804760c7f0b21f5d8d9e68533b8.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">// html\n#box {\n            width: 300px;\n            height: 300px;\n            background-color: yellow;\n    }\n    \n&lt;div id=\"box\"&gt;&lt;/div&gt;\n\nconst box = document.getElementById('box')\nconst styles = window.getComputedStyle(box)\n// 搭配getPropertyValue可以获取到具体样式\nconst height = styles.getPropertyValue(\"height\")\nconst width = styles.getPropertyValue(\"width\")\nconsole.log(height, width) // ’300px‘ '300px'</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/86d51d0f5869712c373382e537a56109.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<h3>20、DOMContentLoaded</h3>\n<p><strong>是什么：</strong></p>\n<p>当初始的 <strong>HTML</strong> 文档被完全加载和解析完成之后，<strong><code>DOMContentLoaded</code></strong> 事件被触发，而无需等待样式表、图像和子框架的完全加载。</p>\n<p>这时问题又来了，“HTML 文档被加载和解析完成”是什么意思呢？或者说，HTML 文档被加载和解析完成之前，浏览器做了哪些事情呢？那我们需要从浏览器渲染原理来谈谈。</p>\n<p>浏览器向服务器请求到了 HTML 文档后便开始解析，产物是 DOM（文档对象模型），到这里 HTML 文档就被加载和解析完成了。如果有 CSS 的会根据 CSS 生成 CSSOM（CSS 对象模型），然后再由 DOM 和 CSSOM 合并产生渲染树。有了渲染树，知道了所有节点的样式，下面便根据这些节点以及样式计算它们在浏览器中确切的大小和位置，这就是布局阶段。有了以上这些信息，下面就把节点绘制到浏览器上。所有的过程如下图所示：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\133ef4d9449af05b66e57abd51c085df.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p></p>\n<p> 现在你可能了解 HTML 文档被加载和解析完成前浏览器大概做了哪些工作，但还没完，因为我们还没有考虑现在前端的主角之一 JavaScript。</p>\n<p>JavaScript 可以阻塞 DOM 的生成，也就是说当浏览器在解析 HTML 文档时，如果遇到</p>\n<p>当 HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。过程如下图</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\a67acfba875c21856b66ca7a59afbc1d.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p></p>\n<p> defer 脚本：</p>\n<p>当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关。过程如下图：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\49a66eaccf8891b7e87deb79e7b5fcfc.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p>async 脚本：</p>\n<p>当 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析。过程如下图：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\0591a7bff4c46e918f9a1fa94a546dfb.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p></p>\n<p> async 和 defer 对 DOMContentLoaded 事件触发的影响：</p>\n<p><strong>defer 与 DOMContentLoaded</strong></p>\n<p>如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。所以这意味着什么呢？HTML 文档解析不受影响，等 DOM 构建完成之后 defer 脚本执行，但脚本执行之前需要等待 CSSOM 构建完成。在 DOM、CSSOM 构建完毕，defer 脚本执行完成之后，DOMContentLoaded 事件触发。</p>\n<p><strong>async 与 DOMContentLoaded</strong></p>\n<p>如果 script 标签中包含 async，则 HTML 文档构建不受影响，解析完毕后，DOMContentLoaded 触发，而不需要等待 async 脚本执行、样式表加载等等。</p>\n<p><strong>DOMContentLoaded和load</strong></p>\n<p>当 HTML 文档解析完成就会触发 DOMContentLoaded，而所有资源加载完成之后，load 事件才会被触发。</p>\n<p>另外需要提一下的是，我们在 jQuery 中经常使用的</p>\n<p>(document).ready(function()//...代码...);其实监听的就是DOMContentLoaded事件</p>\n<p>而 ((document).load(function() { // ...代码... }); 监听的是 load 事件。</p>\n<p><strong> 使用：</strong></p>\n<pre>document.addEventListener(\"DOMContentLoaded\", function(event) {\n      console.log(\"DOM fully loaded and parsed\");\n  });</pre>\n<h3>21、 webpack配置中的3种hash值</h3>\n<p>事先准备3个文件(main.js、main.css、console.js)</p>\n<p>在main.js中引入main.css</p>\n<pre><code class=\"language-javascript\">import './main.css'\nconsole.log('我是main.js')</code></pre>\n<p>webpack.config.js</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/cf75f539d58367e1e66dfbbf9ed9a793.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">// 多入口打包\nentry: {\n    main: './src/main.js',\n    console: './src/console.js'\n  },\n// 输出配置\noutput: {\n    path: path.resolve(__dirname, './dist'),\n    // 这里预设为hash\n    filename: 'js/[name].[hash].js',\n    clean: true\n  },\nplugins: [\n      // 打包css文件的配置\n      new MiniCssExtractPlugin({\n      // 这里预设为hash\n      filename: 'styles/[name].[hash].css'\n    })\n]</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9104e5bbd340f54acbc0360ba3343895.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p><strong>1、全局hash</strong></p>\n<p>打包后，所有文件的文件名hash值都是一致的，修改一下<code>main.css</code>这个文件，重新打包，所有文件的hash值跟着变</p>\n<p>结论：整个项目文件是一致的，修改其中一个会导致所有跟着一起改。</p>\n<p><strong>2、chunkhash</strong></p>\n<p>consfig中把输出文件名规则修改为<code>chunkhash</code></p>\n<p>hash值会根据<strong>入口文件的不同</strong>而分出两个阵营：</p>\n<ul><li><code>main.js、main.css</code>一个阵营，都属于<strong>main.js</strong>入口文件</li><li><code>console.js</code>一个阵营，属于<strong>console.js</strong>入口文件</li></ul>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\0b48170cb280a362b5d08e7044f3c7db.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p><strong> 3、contenthash</strong></p>\n<p> 每个文件hash值都不一样，每个文件的hash值都是根据自身的内容去生成的</p>\n<p>当某个文件内容修改时，打包只会修改其本身的hash值，不会影响其他文件的hash值</p>\n<h3>22、package.lock.json的作用</h3>\n<p><strong>锁定安装模块的版本</strong></p>\n<p>比如在package.json中，vue的版本是^2.6.14</p>\n<p>^的意思是，加入过几天vue在大版本2下更新了小版本2.6.15，那么当npm install的时候vue会自动升级为2.16.5</p>\n<p>引起的问题：</p>\n<p>比如有A\\B两个开发者</p>\n<ul><li>程序员A:接手项目时vue版本时2.16.4，并一直使用这个版本</li><li>程序员B：一个月后加入项目，这时vue已经升级到了2.9.14，npm install的时候会自动升级</li></ul>\n<p>这时候会导致两个开发时vue版本不一致，从而导致合作中产生一些问题和错误</p>\n<p><strong>package.lock.json解决该问题</strong></p>\n<p>比如现在有A、B两个开发者</p>\n<p>A:接手项目时vue的版本时2.6.14，此版本被所在了package-lock.json中</p>\n<p>B:一个月后加入该项目，这时vue已经升级到了2.9.14，npm install的时候，按理说会自动升级，但是由于package-lock.json中锁着2.6.14这个版本，所以阻止了自动升级，保证版本还是2.6.14</p>\n<h3>23、MutationObserver</h3>\n<p>作用：<strong>监控DOM元素的变化</strong></p>\n<p>例子：添加水印，使用MutationObserver阻止用户恶意破坏水印，因为在控制台修改水印的background-image或者将水印的div删掉，都会引起MutationObserver的监控触发</p>\n<ul><li>observer:开启监控DOM的变化</li><li>disconnect:停止检测DOM的变化</li></ul>\n<p>代码：</p>\n<p>1、定义画水印的函数</p>\n<pre><code class=\"language-javascript\">import type { Directive, App } from 'vue'\n\ninterface Value {\n  font?: string\n  textColor?: string\n  text?: string\n}\n\nconst waterMarkId = 'waterMark'\nconst canvasId = 'can'\n\nconst drawWatermark = (el, value: Value) =&gt; {\n  const {\n    font = '16px Microsoft JhengHei',\n    textColor = 'rgba(180, 180, 180, 0.3)',\n    text = 'nlf大菜鸟',\n  } = value\n  // 创建一个canvas标签\n  const canvas = document.getElementById(canvasId) as HTMLCanvasElement\n  // 如果已有则不再创建\n  const can = canvas || document.createElement('canvas')\n  can.id = canvasId\n  el.appendChild(can)\n  // 设置宽高\n  can.width = 400\n  can.height = 200\n  // 不可见\n  can.style.display = 'none'\n  const ctx = can.getContext('2d')!\n  // 设置画布的样式\n  ctx.rotate((-20 * Math.PI) / 180)\n  ctx.font = font\n  ctx.fillStyle = textColor\n  ctx.textAlign = 'left'\n  ctx.textBaseline = 'middle'\n  ctx.fillText(text, can.width / 3, can.height / 2)\n\n  // 水印容器\n  const waterMaskDiv = document.createElement('div')\n  waterMaskDiv.id = waterMarkId\n  // 设置容器的属性样式\n  // 将刚刚生成的canvas内容转成图片，并赋值给容器的 background-image 样式\n  const styleStr = `\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    z-index: -1;\n    top: 0;\n    left: 0;\n    pointer-events: none;\n    background-image: url(${can.toDataURL('image/png')})\n  `\n  waterMaskDiv.setAttribute('style', styleStr)\n\n  // 将水印容器放到目标元素下\n  el.appendChild(waterMaskDiv)\n\n  return styleStr\n}\n//不使用监测\nconst watermarkDirective: Directive = {\n  mounted(el, { value }) {\n    // 接收styleStr，后面可以用来对比\n    el.waterMarkStylestr = drawWatermark(el, value)\n  }\n}</code></pre>\n<p></p>\n<p>使用的时候直接以<code>v-watermark</code>来使用：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/09570efdda9d1cf796ede251b7806744.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-html\">&lt;div \n    v-watermark=\"\n    { \n    text: '水印名称',\n    textColor: 'rgba(180, 180, 180, 0.3)' \n    }\n    \"\n  &gt;\n&lt;/div&gt;</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/15bc000c4eff317d1ab052d910e39244.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p>2、使用监控</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9948b4502970054b2d7037a720abb8f9.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">const watermarkDirective: Directive = {\n  mounted(el, { value }) {\n    // 接收styleStr，后面可以用来对比\n    el.waterMarkStylestr = drawWatermark(el, value)\n    // 先定义一个MutationObserver\n    el.observer = new MutationObserver(() =&gt; {\n      const instance = document.getElementById(waterMarkId)\n      const style = instance?.getAttribute('style')\n      const { waterMarkStylestr } = el\n      // 修改样式 || 删除div\n      if ((instance &amp;&amp; style !== waterMarkStylestr) || !instance) {\n        if (instance) {\n          // div还在，说明只是修改style\n          instance.setAttribute('style', waterMarkStylestr)\n        } else {\n          // div不在，说明删除了div\n          drawWatermark(el, value)\n        }\n      }\n    })\n    // 启动监控\n    el.observer.observe(document.body, {\n      childList: true,\n      attributes: true,\n      subtree: true,\n    })\n  },\n  unmounted(el) {\n    // 指定元素销毁时，记得停止监控\n    el.observer.disconnect()\n    el.observer = null\n  },\n}</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/eac233d20dbc54852f57f9a57dbe033a.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p>现在，控制台修改<code>style</code>或者<code>删除容器div</code>，都会重新生成水印，这样恶意用户就无法得逞</p>\n<h3> 24、HTTPS加密的过程</h3>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\ae5cd5fa548c41a9b743f419bae2eeab.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<p></p>\n<p>1、首先，客户端发起握手请求，以明文传输请求信息</p>\n<p>2、服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<code>这套证书其实就是一对公钥和私钥。</code>如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>\n<p>3、服务端返回证书、加密算法等信息给客服端</p>\n<p>4、客户端验证证书的合法性，包括可信性，是否吊销，过期时间和域名，如果异常，弹框提示，没有异常则生成一串随机数</p>\n<p>5、客户端使用公匙对对称密匙加密，发送给服务端。</p>\n<p>6、服务器用私钥解密，拿到对称加密的密匙</p>\n<h3>25、性能优化</h3>\n<p>代码层面：</p>\n<ul><li>防抖和节流（resize，scroll，input）。</li><li>减少回流（重排）和重绘。</li><li>事件委托。</li><li>css 放 ，js 脚本放 最底部。</li><li>使用字体图标iconfont代替图片</li><li>降低css选择器的复杂性</li><li>减少 DOM 操作。</li><li>尽量使用css而不是强制加载和卸载组件</li><li>按需加载，比如 React 中使用 <code>React.lazy</code> 和 <code>React.Suspense</code> ，通常需要与 webpack 中的 <code>splitChunks</code> 配合。</li></ul>\n<p>构建方面：</p>\n<ul><li><strong>压缩代码文件</strong>，在 webpack 中使用 <code>terser-webpack-plugin</code> 压缩 Javascript 代码；使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS 代码；使用 <code>html-webpack-plugin</code> 压缩 html 代码。</li><li><strong>开启 gzip 压缩</strong>，webpack 中使用 <code>compression-webpack-plugin</code> ，node 作为服务器也要开启，使用 <code>compression</code>。</li><li><strong>常用的第三方库使用 CDN 服务</strong>，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。</li></ul>\n<p>webpack性能优化：</p>\n<ul><li><strong>优化构建速度：</strong></li></ul>\n<ol><li>缩小文件搜索范围：resolve字段告诉webpack怎么去搜索文件，所以首先要重视<strong>resolve字段的配置</strong>（设置 resolve.modules:[path.resolve(__dirname, 'node_modules')] 避免层层查找）</li><li>配置oneOf（每个不同类型的文件在load转换时，会遍历module中rules所有的loader，即使匹配到某个规则后也会继续向下匹配。如果将规则放在oneOf中，一旦匹配到某个规则后就停止匹配）</li><li>使用DllPlugin减少基础模块编译次数（原理是<strong>把网页依赖的基础模块抽离出来打包到dll文件中</strong>，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。为什么会提升构建速度呢？原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次）</li><li> <p>使用HappyPack或者thread-load开启多进程Loader转换（在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是<strong>单线程模型</strong>的，也就是只能一个一个文件进行处理，不能并行处理。<strong>HappyPack可以将任务分解给多个子进程，最后将结果发给主进程</strong>。JS是单线程模型，只能通过这种多进程的方式提高性能）</p> </li><li> <p>使用ParallelUglifyPlugin开启多进程压缩JS文件（使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间）</p> </li></ol>\n<ul><li><strong>优化输出质量-压缩文件体积</strong></li></ul>\n<ol><li>区分环境-减少生产环境代码体积（代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用<strong>DefinePlugin</strong>插件来定义配置文件适用的环境，用来支持process.env.NODE_ENV === 'production' 语句）</li><li>压缩js、es、css</li><li>使用tree-shaking剔除js死代码</li></ol>\n<ul><li><strong>优化输出质量-加速网络请求</strong></li></ul>\n<ol><li> <p>使用CDN加速静态资源的加载</p> </li><li>多页面应用提取页面间公共代码，以利用缓存（把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次。）</li><li>分割代码按需加载<br/> 例如：一个最简单的例子：网页首次只加载main.js，网页展示一个按钮，点击按钮时加载分割出去的show.js，加载成功后执行show.js里的函数 \n  <div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/4961903710f38319e7d89b176ab5c600.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div> <pre><code class=\"language-javascript\">//main.js\ndocument.getElementById('btn').addEventListener('click',function(){\n    import(/* webpackChunkName:\"show\" */ './show').then((show)=&gt;{\n        show('Webpack');\n    })\n})\n\n//show.js\nmodule.exports = function (content) {\n    window.alert('Hello ' + content);\n}</code></pre>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/89831112d65af81ebf9c5695969c0699.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div> <p>import(/* webpackChunkName:show */ './show').then() 是实现按需加载的关键</p> </li></ol>\n<p>其它：</p>\n<ul><li>使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。</li><li>使用服务端渲染。</li><li>图片压缩。</li><li>使用 http 缓存，比如服务端的响应中添加 <code>Cache-Control / Expires</code></li></ul>\n<h3>26、loader和plugin的区别</h3>\n<ul><li>两者都是扩展webpack的功能，loader只专注于转化文件，完成压缩、打包和语言翻译；而plugin只局限在打包，资源加载上，还可以打包优化和压缩，重新定义环境变量等</li><li>loader是运行在打包文件之前，plugins在整个编译周期都起作用</li><li>一个loader的职责是单一的，只需要完成一种转换，一个loader其实就是一个node.js模块。当需要多个loader去转换一个文件时，每个loader会链式的顺序执行</li><li>webpack运行的生命周期中广播出许多事件，plugins会监听这些事件，在合适的时机通过webpack提供的API改变输出结果</li></ul>\n<p><strong>　　原理：</strong></p>\n<p><strong>　　　　loader</strong> loader 的作用是用来处理<code>非js文件</code>，它是一个函数，实现原理是：将所需处理的文件内容使用相应的转换插件转成<code>AST(抽象语法树)</code>，然后按照loader规则对于这个 AST 进行处理，处理之后再转成原本的内容格式，然后输出，达到了处理内容的效果</p>\n<p><strong>　　　　plugin</strong> plugin 的作用是拓展webpack的打包功能。它是一个类，使用方式是new Plugin(option)，这个类内部有一个<code>apply</code>方法，打包时会执行这个方法，且这个<code>apply</code>方法接收的参数中有一个<code>plugin</code>方法，此方法中有许多钩子函数，使用这些钩子函数可以在不同的打包阶段做一些事，例如修改文件，新增文件，删除文件等等</p>\n<h3> 27、vue中不需要响应式的数据如何处理</h3>\n<p>vue中，会有一些数据，从始至终都未曾改变，这种死数据，既然不会改变，也不需要对其做响应式处理了，不然会消耗性能。</p>\n<p>比如一些写死的下拉框</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/a768d42075d5f55e6be39d441e15b5a7.gif\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<pre><code class=\"language-javascript\">//方法1:将数据定义在data之外\ndata(){\n  this.list = {xxxx}\n  return {}    \n}\n//方法2、Object.freeze()\ndata(){\n  return {\n    list:Object.freeze({xxxx})\n  }  \n}</code></pre>\n<p></p>\n<h3>28、父子组件生命周期的顺序</h3>\n<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p>\n<h3>29、computed和watch的区别</h3>\n<ul><li><code>computed</code>是依赖已有的变量来计算一个目标变量，大多数情况都是<code>多个变量</code>凑在一起计算出<code>一个变量</code>，并且<code>computed</code>具有<code>缓存机制</code>，依赖值不变的情况下其会直接读取缓存进行复用，<code>computed</code>不能进行<code>异步操作</code></li><li><code>watch</code>是监听某一个变量的变化，并执行相应的回调函数，通常是<code>一个变量</code>的变化决定<code>多个变量</code>的变化，<code>watch</code>可以进行<code>异步操作</code></li><li>简单记就是：一般情况下<code>computed</code>是<code>多对一</code>，<code>watch</code>是<code>一对多</code></li></ul>\n<h3>30、 vue的修饰符</h3>\n<div>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\ae174708c74e1d8edc4b4452da514212.png\"/><span title=\"点击并拖拽以改变尺寸\">​</span></p>\n</div>\n<h3> 31、使用vite为什么会变快</h3>\n<ul><li>1、esbuild预构建依赖：代码分为<code>依赖</code>和<code>源码</code>，<code>依赖</code>就是那些npm包，一般不会变，缓存起来；<code>源码</code>是会频繁更改的那一部分代码</li><li>2、利用浏览器可以运行<code>ES Module</code>，将代码转成<code>ES Module</code>后交给浏览器，把压力放在浏览器那边，从而提高项目启动速度</li><li>3、按需加载：浏览器根据<code>ES Module</code>去使用http请求，按需加载所需页面</li><li>4、利用协商缓存，缓存文件，无变化的文件不需要重新加载</li></ul>\n<h3> 32、webpack babel vue都用到了AST，对抽象语法树的理解</h3>\n<p>现在的很多工具，例如webpack、vite、eslint、babel等等都离不开一个东西——AST。</p>\n<p>AST是正常代码，使用工具，根据不用的代码节点类型，转化成的一个<strong>JSON格式</strong>的数据</p>\n<pre>const a = 5;\n// 转换成AST\n[{value: 'const', type: 'keyword'}, {value: 'a', type: 'identifier'}, ...]</pre>\n<h3> 33、TCP/UDP的区别</h3>\n<p>都属于TCP/IP协议族</p>\n<ul><li>TCP是面向连接的，UDP是面向无连接的</li><li>TCP是可靠的，UDP是不可靠的</li><li>TCP是面向字节流，UDP是面向报文的</li><li>TCP只有一对一的传输方式，而UDP不仅可以一对一，还可以一对多，多对多</li></ul>\n<p> TCP拥塞控制：若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，这种情况叫做网络拥塞</p>\n<p>TCP的4种拥塞控制算法：慢开始、拥塞控制、快重传、快恢复</p>\n<p>TCP和http的区别</p>\n<p>http：超文本传输协议，是运行TCP之上的</p>\n<p>TCP：传输控制协议，用来控制传输的，为了在不可靠的互联网上提供可靠的端到端字节流，作用范围比HTTP大</p>\n<h3>34、跨域</h3>\n<p>意思：协议、域名和端口不一致均会导致跨域</p>\n<p>产生的原因：</p>\n<p>　　1、基于浏览器的同源策略限制</p>\n<p>　　2、同源策略是一种约定，它是浏览器核心也是最基本的安全功能，它会组织一个域的js脚本和另外一个域的内容进行交互。如果缺少了同源策略，浏览器很容易受到XSS、CSRF的攻击。</p>\n<p>　　3、同源就是两个页面具有相同的协议、域名和端口</p>\n<h3>35、get和post的区别</h3>\n<p>相同：都是http协议请求，tcp连接</p>\n<p>不同：</p>\n<p>get：</p>\n<ol><li>get不安全，参数在url中</li><li>参数有长度限制</li><li>能被缓存，可以收藏为书签，参数保留在浏览器历史中</li><li>只发送1个tcp数据包，即http header和data共同发送给服务器</li></ol>\n<p>post：</p>\n<ol><li>安全，参数在request body</li><li>参数没有长度限制</li><li>不会被缓存</li><li>发送2个tcp数据包，第一次发送http header，如果服务器响应100，则发送第二个数据包data</li></ol>\n<h3> 36、requestAnimationFrame </h3>\n<p>requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：</p>\n<p>1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</p>\n<p>2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</p>\n<p>requestAnimationFrame 动画原理：</p>\n<p>　　假设某图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？</p>\n<p>　　刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。</p>\n<p> setTimeOut卡顿的原因：</p>\n<p>1、setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。</p>\n<p>2、刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</p>\n<p>　　以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？</p>\n<p>　　原因：setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。</p>\n<h3> 37、Cookies中的SameSite</h3>\n<p>SameSite可以让Cookie在跨站请求时不会被发送，从而组织跨站请求伪造攻击CSRF</p>\n<p>设置：</p>\n<ol><li>客户端发送 HTTP 请求到服务器</li><li>当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段</li><li>浏览器收到响应后保存下 Cookie</li><li>之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。</li></ol>\n<p>SameSite 可以有下面三种值：</p>\n<ol><li><strong>Strict</strong> 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li><li><strong>Lax</strong> 允许部分第三方请求携带 Cookie</li><li><strong>None</strong> 无论是否跨站都会发送 Cookie</li></ol>\n<p>之前默认是 None 的，Chrome80 后默认是 Lax。</p>\n<p>主要用于3个方面：</p>\n<ol><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ol>\n<h3>38、事件冒泡和事件捕获</h3>\n<p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p>\n<p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是</p>\n<p><strong>p -&gt; div -&gt; body -&gt; html -&gt; document</strong></p>\n<p>另一种事件流名为<strong>事件捕获</strong>(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p>\n<p>上面的例子在事件捕获的概念下发生click事件的顺序应该是 </p>\n<p><strong>document -&gt; html -&gt; body -&gt; div -&gt; p</strong></p>\n<h3> 39、BFC：块级格式化上下文</h3>\n<p>触发的条件：</p>\n<p>·body根元素</p>\n<p>·设置浮动，不包括none</p>\n<p>·设置定位，absoulte或者fixed</p>\n<p>·行内块显示模式，inline-block</p>\n<p>·设置overflow，即hidden，auto，scroll</p>\n<p>·表格单元格，table-cell</p>\n<p>·弹性布局，flex</p>\n<p>一个BFC区域只包含其子元素，不包括其子元素的子元素。</p>\n<p>并不是所有的元素都能成为一块BFC区域，只有当这个元素满足上面条件之一的时候才会成为一块BFC区域。</p>\n<p>不同的BFC区域之间是相互独立的，互不影响的。利用这个特性我们可以让不同BFC区域之间的布局不产生影响。</p>\n<h3> 40、箭头函数的this</h3>\n<p>this：表示当前对象的一个引用</p>\n<p>箭头函数没有自己的this，所以内部的this就是外层代码块的this，它的this是继承而来的，默认指向在定义时所处的宿主对象</p>\n<p></p>\n<p></p>\n<h1>程序员面试题库分享</h1>\n<h3><strong>1、前端面试题库 （</strong>面试必备）<strong>            <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://mp.weixin.qq.com/s?__biz=MzU5NzA0NzQyNg==&amp;mid=2247485824&amp;idx=3&amp;sn=70cd26a7c0c683de64802f6cb9835003&amp;scene=21#wechat_redirect\" title=\"前端面试题库\">前端面试题库</a></p>\n<h3><strong>2、前端技术导航大全      <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://webstatic-3g8wm74b420bf334-1301145096.tcloudbaseapp.com/webclass/index.html#/\" title=\"前端技术导航大全\">前端技术导航大全</a></p>\n<h3>3、开发者颜色值转换工具   <strong>推荐：★★★★★</strong></h3>\n<p>地址 ：<a href=\"https://color-4gr069g4ea217b7a-1301145096.tcloudbaseapp.com/color/index.html\" title=\"开发者颜色值转换工具\">开发者颜色值转换工具</a></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-08-11 14:28:11", "summary": "程序员面试题库分享、前端面试题库面试必备推荐：地址：前端面试题库前端面试题库、前端技术导航大全推荐：地址：前端技术导航大全前端技术导航大全、开发者颜色值转换工具推荐：地址：开发者颜色值转换工具开发者颜"}