{"blogid": "124042390", "writerAge": "码龄1年", "writerBlogNum": "64", "writerCollect": "1515", "writerComment": "1452", "writerFan": "3587", "writerGrade": "5级", "writerIntegral": "4126", "writerName": "是小鱼儿哈", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124042390.jpg", "writerRankTotal": "5725", "writerRankWeekly": "7705", "writerThumb": "1310", "writerVisitNum": "57742", "blog_read_count": "3337", "blog_time": "已于 2022-05-19 21:40:24 修改", "blog_title": "Java中的抽象类和接口", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB\">什么是抽象类</a></p>\n<p id=\"%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%86%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%86%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%C2%A0\">抽象类再实现多态中的意义 </a></p>\n<p id=\"%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88\">接口是什么</a></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p> <strong>各位铁汁们大家好呀😊</strong>！</p>\n<p>😎<strong>今天让我们继续学习java，看看java中的抽象类和接口到底是什么</strong>🤔？ </p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/2f1f179b78844f31bf5d078b4a3db38c.gif\"/></p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB\">什么是抽象类</h1>\n<p>🍑我们之前学过什么是类，那么抽象类是不是也是类的一种呢？</p>\n<p><strong>听名字就感觉好抽象呀！说对了，他就是抽象的，不是具体的。在类中没有包含足够的信息来描绘一个具体的对象，这样的类称为抽象类。</strong></p>\n<p></p>\n<p>🌰来看一个抽象类的例子</p>\n<pre><code class=\"language-java\">// 抽象类和抽象方法需要被 abstract 关键字修饰\nabstract class Shape {\n    // 抽象类中的方法一般要求都是抽象方法，抽象方法没有方法体\n    abstract void draw();\n}</code></pre>\n<p><strong>大家觉得这个抽象类是不是什么也没干，他唯一的方法draw()还是空的。</strong></p>\n<p><span style=\"background-color:#38d8f0;\">像这样的类是不是就没有包含足够的信息来描绘一个具体的对象，自然也就不能实例化对象了。不信你看：</span></p>\n<p></p>\n<p><img alt=\"\" height=\"331\" src=\"..\\..\\static\\image\\b2eb8ea7565e4515bb0b3df9abaf6970.png\" width=\"742\"/></p>\n<p></p>\n<p>🍑那既然一个类不能实例化，那这种抽象类存在的意义是什么呀🤔？别急，存在即合理，听我慢慢道来。</p>\n<p></p>\n<p></p>\n<hr/>\n<h2 id=\"%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%86%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%C2%A0\">抽象类在实现多态中的意义 </h2>\n<p><strong>🍑抽象类存在的一个最大意义就是被继承，当被继承后就可以利用抽象类实现多态。</strong></p>\n<p>来看一段代码</p>\n<pre><code class=\"language-java\">// 抽象类和抽象方法需要被 abstract 关键字修饰\nabstract class Shape {\n    // 抽象类中的方法一般要求都是抽象方法，抽象方法没有方法体\n    abstract void draw();\n}\n// 当一个普通类继承一个抽象类后，这个普通类必须重写抽象类中的方法\nclass Cycle extends Shape {\n    @Override\n    void draw() {  // 重写抽象类中的draw方法\n        System.out.println(\"画一个圆圈\");\n    }\n}\n\npublic class Test4 {\n    public static void main(String[] args) {\n        //Shape shape = new Shape();  抽象类虽然不能直接实例化\n        // 但可以把一个普通类对象传给一个抽象类的引用呀，即父类引用指向子类对象\n        Shape shape = new Cycle(); // 这称作：向上转型\n        \n        /*Cycle cycle = new Cycle();\n          Shape shape = cycle // 这是向上转型的另一种写法\n         */\n        shape.draw();         // 通过父类引用调用被子类重写的方法\n    }\n}\n</code></pre>\n<p>运行之后你就会发现神奇的一幕：</p>\n<p> <img alt=\"\" height=\"190\" src=\"..\\..\\static\\image\\1f785815548d45d3ba841d21432bf29e.png\" width=\"633\"/></p>\n<p><img alt=\"\" height=\"260\" src=\"https://img-blog.csdnimg.cn/16bdec42b22e46faacdfc9889f0a416e.gif\" width=\"258\"/></p>\n<p><span style=\"background-color:#38d8f0;\">大家在看完了代码可能会有很多疑问，别急咱们一个一个的说，</span></p>\n<p>📝<span style=\"color:#fe2c24;\">什么是向上转型：一句话总结就是“父类引用指向子类对象”</span></p>\n<p></p>\n<p><strong>向上转型后的变化</strong></p>\n<ol><li><strong>🏀关于方法：父类引用可以<u>调用子类和父类</u>公用的方法（<u>如果子类重写了父类的方法，则调用子类的方法</u>），但子类特有的方法无法调用。</strong></li><li><strong>🏀关于属性: 父类引用可以调用父类的属性，不可以调用子类的属性</strong></li></ol>\n<p></p>\n<p><strong>向上转型的作用</strong></p>\n<ol><li><strong>🐟减少一些重复性的代码</strong></li><li><strong>🐟对象实例化的时候可以根据不同需求实例化不同的对象</strong></li></ol>\n<p></p>\n<p></p>\n<p>🌰<strong>这样的话就我们上面的代码就可以理解了</strong></p>\n<p><img alt=\"\" height=\"591\" src=\"..\\..\\static\\image\\976f878d8ee04e5a8406d06be2562e8d.png\" width=\"762\"/>​ </p>\n<p></p>\n<p>📝<span style=\"background-color:#a2e043;\">看来，我们可以通过子类对抽象类的继承和重写，抽象类还真有点用呀！</span></p>\n<p>🍑<strong>但这和多态有什么关系呢，抽象类用起来这么麻烦，我还不如直接用普通类，也能达到这样的效果，还不用再写一个子类呢😫？</strong></p>\n<p>🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟</p>\n<p><span style=\"color:#fe2c24;\">🌰那行，你再看看下面的代码，你就知道抽象类在实现多态时的好处了。 </span></p>\n<pre><code class=\"language-java\">abstract class Shape {\n    public abstract void draw(); // 抽象方法不能里有具体的语句\n}\n// 当一个普通类继承一个抽象类的时候，再这个子类中必须重写抽象类中的抽象方法\nclass Cycle extends Shape {  \n    @Override              // 如果不重写会报错，但如果继承的是普通类则不会报错，用抽象类更安全\n    public void draw() {\n        System.out.println(\"画一个圆圈\");\n    }\n}\nclass Flower extends Shape { // 不同的子类对父类的draw方法进行了不同的重写\n    @Override\n    public void draw() {\n        System.out.println(\"画一朵花\");\n    }\n}\nclass Square extends Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"画一个正方形\");\n    }\n}\n\npublic class Test4 {\n    public static void main(String[] args) {\n        Cycle cycle = new Cycle();   // 子类引用cycle\n        Flower flower = new Flower(); // 子类引用flower\n        Square square = new Square();\n        \n        // 数组的类型是Shape,即数组中每一个元素都是一个父类引用\n        // 在这个过程其实也发生了向上转型，对抽象类中的方法进行了重写\n        Shape[] shapes = {cycle, flower, square};  // 父类引用引用不同的子类对象\n        for (int i = 0; i &lt; shapes.length; i++) {\n            Shape shape = shapes[i]; // 父类引用shape指向—&gt;当前所对应的子类对象\n\n            shape.draw();  // 通过父类引用调用子类重写的draw方法\n        }\n\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"236\" src=\"..\\..\\static\\image\\658babc05d354e388ae06cc0b16df038.png\" width=\"592\"/></p>\n<p><strong><span style=\"color:#fe2c24;\">🍑调用同一个方法竟然打印出了不同的结果😮，这难道就是所谓的多态🤔 </span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\"><img alt=\"\" height=\"178\" src=\"https://img-blog.csdnimg.cn/38964490898e4439904407878f4e9d0b.gif\" width=\"184\"/></span></strong></p>\n<p><strong> 是不是有点懵😂，下面我们来解释一下😉</strong></p>\n<pre><code>// 对上面的代码补充一下\n// 可能你对 Shape[] shapes = {cycle, flower, square};不太理解\n// 但上面的代码就相当于 \n\n Shape[] shapes1 = new Shape[3]; // 有三个不同的子类对象呀！数组大小为3\n\n// (将指向-&gt;子类对象)的子类引用赋值给父类对象，不就相当于该夫类引用指向-&gt;所对应的子类对象吗\n//这是向上转型的另一种写法，应为前面已经实例化了子类对象  Cycle cycle = new Cycle();   \n shapes1[0] = cycle;  // 如果前面没实例化子类对象，就要写成shape1[0] = new Cycle\n shapes1[1] = flower;\n shapes1[2] = square;</code></pre>\n<p></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\">对于多态来说，他有这三个要素</span></p>\n<ol><li><strong>继承（我们刚才的Cycle类继承Shape抽象类）</strong></li><li><strong>重写（我们子类对draw方法的重写）</strong></li><li><strong>父类指向子类对象（就是shape1[0] = cycle --&gt;也可以称作向上转型)</strong> </li></ol>\n<p>🍑<span style=\"background-color:#38d8f0;\">回头再看一下我们的代码，是不是就刚好符合了多态的三要素😉。</span></p>\n<p></p>\n<p><strong>📝当我们的父类引用指向不同的子类对象时，当我们调用同一个draw方法时却输出了不同的结果。（其实就是该方法再子类中被重写成了不同形式）这就叫做多态 。</strong></p>\n<p>嘻嘻😂，其实只要只要结合着例子来看，多态也没那么难理解呀😎</p>\n<p> <img alt=\"\" height=\"151\" src=\"https://img-blog.csdnimg.cn/73621895e6d8430e9886a236ec575c35.gif\" width=\"160\"/> </p>\n<p></p>\n<p>🍑<strong>那为啥一定要用抽象类呢😂？我一个普通类继承普通类来实现多态不可以吗🤔</strong></p>\n<p>🌰当然可以，但不太安全有风险；</p>\n<p>  <img alt=\"\" height=\"273\" src=\"..\\..\\static\\image\\d1efb5b5f62b4483958709c175164098.png\" width=\"808\"/>   </p>\n<p><strong>但如果是抽象类的话，就不一样了😉 </strong></p>\n<p> <img alt=\"\" height=\"331\" src=\"..\\..\\static\\image\\3c69b4647eb443b2b9a68bf4da242515.png\" width=\"920\"/> </p>\n<p>🍑<span style=\"background-color:#a2e043;\">从这我们也可以看出，当用抽象类的时候，编译器自动就对我们是否重写进行了校验，而充分利用编译器的校验, 在实际开发中是非常有意义的 。所以说抽象类还是有用的，嘻嘻😉</span></p>\n<p></p>\n<p>📝<span style=\"color:#fe2c24;\">好了，相信到这里你对抽象类也有了一个大概的认识😊，下面我们来简单做一下总结</span></p>\n<ol><li><strong>使用abstract修饰的类或方法，就抽象类或者抽象方法</strong></li><li><strong>抽象类是不能具体的描述一个对象，不能用抽象类直接实例化对象</strong></li><li><strong>抽象类里面的成员变量和成员方法，都是和普通类一样的，只不过就是不能进行实例化了</strong></li><li><strong>当一个普通类继承这个抽象类后，那么这个普通类必须重写抽象类当中的所有的抽象方法🤔（我们之前说过抽象类是不具体的，没有包含足够的信息来描述一个对象，所以我们需要把他补充完整）</strong><img alt=\"\" height=\"300\" src=\"https://img-blog.csdnimg.cn/6cc36cbb03cb4539ae75e42de4d58f48.gif\" width=\"300\"/>\n<hr/></li><li><strong>但当一个抽象类A继承了抽象类B，这是抽象类A就可以不重写抽象类B当中的抽象方法</strong></li><li><strong>final不能修饰抽象类和抽象方法（因为抽象类存在的最大意义就是被继承，而被final修饰的不能被继承，final和抽象，他们两个是天敌😂）</strong></li><li><strong>抽象方法不能被private修饰（抽象方法一般都是要被重写的，你被private修饰了，还怎么重写😫）</strong></li><li><strong>抽象类当中不一定有抽象方法，但如果一个类中有抽象方法，那么这个类一定是抽象类</strong>。</li></ol>\n<p></p>\n<p>🌰哈哈，上面的8条总结是不是臭长臭长的，大家也不用专门去记（用的多了，自然就记住了😉）</p>\n<p>🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟🐟</p>\n<hr/>\n<p></p>\n<h1 id=\"%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88\">接口是什么</h1>\n<p>🍑<strong>抽象类是从多个类中抽象出来的模板，如果将这种抽象进行的更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（Interface）🤔。</strong></p>\n<p>📝<span style=\"background-color:#38d8f0;\">接口是Java中最重要的概念之一，它可以被理解为一种特殊的类，不同的是接口的成员没有执行体，是由全局常量和公共的抽象方法所组成😎。</span></p>\n<p>如何定义一个接口呢？下面我们来看一个栗子🌰</p>\n<pre><code class=\"language-java\">//接口的定义格式与定义类的格式基本相同，将class关键字换成 interface 关键字，就定义了一个接口\n\npublic interface 接口名称{\n// 定义变量\nint a = 10;      // 接口当中的成员变量默认都是public static final\n\n// 抽象方法\npublic abstract void method1(); // public abstract 是固定搭配，可以不写\nvoid method2();  //  接口当中的成员方法默认都是public abstract, 更推荐用第二种来定义方法 \n}</code></pre>\n<p></p>\n<p>可以看到接口和类其实还是有很多相似点：</p>\n<p><strong>📝</strong><span style=\"color:#fe2c24;\">接口中也包含抽象方法，所以也不能直接实例化接口🤔，那么我们怎么用接口呢？</span></p>\n<p></p>\n<p>🍑<strong>哈哈，很简单😉，我们再用一个普通类实现这个接口不就行了吗😂，不同的是抽象类是被子类来继承而实现的，而接口与类之间则是用关键字implements来实现</strong>。</p>\n<p>📝<strong>就像普通类实现实现抽象类一样，一个类实现某个接口则必须实现该接口中的抽象方法，否则该类必须被定义为抽象类🤔。</strong></p>\n<hr/>\n<p></p>\n<h2> 通过接口实现多态</h2>\n<p>🍑铁汁们！刚才我们是用抽象类来实现多态，那么现在我们可以尝试用接口来实现多态，嘻嘻😎</p>\n<pre><code class=\"language-java\">接口可以看成是一种特殊的类，只能用 interface 关键字修饰\ninterface IShape {\n    int a = 10;   接口当中的成员变量默认都是public static final\n    int b = 23;\n    void draw();  接口当中的成员方法一般只能是抽象方法，默认是public abstract（JDK1.8以前）\n  \n    default void show() {\n        System.out.println(\"接口中的其他方法\");//接口中的其他方法也可以实现，但要用default修饰\n    }\n    public static void test() {\n        System.out.println(\"这是接口当中的一个静态的方法\");\n    }\n}\n\n// 一个普通的类要想实现接口，可以用implement, \n//因为接口也是抽象方法的，所以实现接口的这个类也要重写抽象方法\nclass Cycle implements IShape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"画一个圆圈\");\n    }\n}\nclass Square implements IShape {\n    @Override\n    public void draw() {\n        System.out.println(\"画一个正方形\");\n    }\n}\nclass Flower implements IShape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"画一朵花\");\n    }\n}\npublic class Test4 {\n    public static void main(String[] args) {\n        // IShape iShape = new IShape(); 接口也不能直接实例化\n        Cycle cycle = new Cycle();\n        Square square = new Square();\n        Flower flower = new Flower();\n        // 这里的IShape接口就相当与抽象类中父类，接口类型也是一种引用类型\n\n        IShape[] iShapes = {cycle, square, flower}; // 这个过程其实就发生了向上转型\n\n        for (IShape iShape : iShapes) { // 增强型的for—each循环，也可以写成普通的for循环形式\n            iShape.draw();              // 通过重写实现了多态\n        }\n    }\n}\n引用变量cycle和square都赋值给了Shape类型的引用变量shape,\n但当执行shape.draw()时，java虚拟机到底要调用谁重写的的draw方法，\n就看此时接口引用的是那个对象的，是shape的、还是cycle的</code></pre>\n<p></p>\n<p><span style=\"color:#fe2c24;\"><strong> 😎看一下运行结果😎</strong></span></p>\n<p><img alt=\"\" height=\"308\" src=\"..\\..\\static\\image\\23f215d365ec41d7a573d27888e6ad6d.png\" width=\"681\"/></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"300\" src=\"https://img-blog.csdnimg.cn/58ed7902d15d4bc2aa2e1bd9c77763cf.gif\" width=\"300\"/></p>\n<p> 看完代码你可能有点晕😫，但没关系。一般接口咱也不这么用，直接使用抽象类不就好了😉（我只是演示一下用接口也能实现多态😂）</p>\n<p>🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑🍑</p>\n<p>📝<strong>下面我们来总结一下Java中接口的几个主要特点</strong></p>\n<ol><li><strong>🌰接口中可以包含变量和方法，变量被隐式指定为 public static final，方法被隐式指定为 public abstract（JDK 1.8 d</strong><strong>一个类可以同时实现多个接口，一个类实现某个接口则必须实现该接口中的抽象方法，否则该类必须被定义为抽象类</strong></li><li><strong>🌰接口支持多继承，即一个接口可以继承（extends）多个接口，间接解决了 Java 中类不能多继承的问题。</strong></li></ol>\n<p></p>\n<p></p>\n<p><span style=\"color:#fe2c24;\"><strong>🍑那么接口一般用在什么地方呢？</strong></span></p>\n<ul><li><span style=\"color:#0d0016;\"><span style=\"background-color:#a2e043;\">一般情况下，实现类和它的抽象类之前具有 \"is-a\" 的关系，但是如果我们想达到同样的目的，但是又不存在这种关系时，使用接口。</span></span></li><li><span style=\"background-color:#38d8f0;\">由于 Java 中单继承的特性，导致一个类只能继承一个类，但是可以实现一个或多个接口，此时可以使用接口。</span></li></ul>\n<p></p>\n<p><strong>🌰下面就让我们来看看接口的正确用法：帮助java实现“ 多继承 ”😎</strong></p>\n<pre><code class=\"language-java\">由于 Java 中单继承的特性，导致一个类只能继承一个类，但是可以实现一个或多个接口，此时可以使用接口。\nclass Animal {\n    String name;        // 不能使用private,后面的子类也要用\n\n    public Animal(String name) { // 父类的自定义的构造方法\n        this.name = name;\n    }\n}\ninterface IFlying {   // 自定义多种接口\n    void fly();\n}\ninterface IRunning {\n    void run();\n}\ninterface ISwimming {\n    void swimming();\n}\n// 小鸭子，不仅会跑，还会游泳、飞行\n一个类继承父类，并实现多个接口，间接的解决java中不能多继承的问题\nclass Duck extends Animal implements IRunning, ISwimming, IFlying {\n\n    public Duck(String name) {  // 子类构造方法\n        super(name);            // 必须在子类构造方法的第一行\n        // 在给实现子类的构造方法前，先要用super()调用实现父类的构造方法，比较先有父后有子呀！\n        // 因为父类自己定义了构造方法，编译器不会自动给给子类构造方法中添加super();来实现父类的构造方法，需要我们自己实现\n    }\n    // 对接口中的抽象方法进行重写\n    @Override\n    public void fly() {\n        System.out.println(this.name + \"正在用翅膀飞\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(this.name + \"正在用两条腿跑\");\n    }\n\n    @Override\n    public void swimming() {\n        System.out.println(this.name + \"正在漂在水上\");\n    }\n\n}\n\npublic class 接口的使用 {  // 不用学我用中文名作为类名，我只是为演示方便\n    public static void main(String[] args) {\n        Duck duck = new Duck(\"第一个小鸭子\");  // 实例化鸭子对象\n        duck.fly();  // 通过引用 变量名.方法名 输出重写后的方法\n        duck.run();\n        duck.swimming();\n    }\n}\n有人可能会说干嘛用接口，我直接在父类Animal中实现fly、run、swimming这些属性，\n然后不同的动物子类再继承父类这些方法不行吗？\n\n但问题是，鸭子会fly、swimming，那猫会飞和游泳吗？你再写个其他动物的子类是不是就不行了\n而用接口呢？我们只是把这种飞、游泳的行为给抽象出来了，\n\n只要一个子类有这种行为，他就可以实现相对应的接口，接口是更加灵活的\n\n</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"257\" src=\"..\\..\\static\\image\\998392d95fad4ef4901523596bdd6f6c.png\" width=\"618\"/></p>\n<p> 📝<strong>上面的代码展示了 Java 面向对象编程中最常见的用法</strong>: 一<span style=\"color:#fe2c24;\"><strong>个类继承一个父类, 同时实现多个接口。</strong></span></p>\n<h1></h1>\n<p> 📝<strong>继承表达的含义是 is - a 语义, 而接口表达的含义是 具有 xxx 特性 ，能实现接口的类和该接口并不一定有is_a的关系，只要该类有这个接口的特性就行</strong></p>\n<blockquote>\n<p>猫是一种动物, 具有会跑的特性.</p>\n<p>青蛙也是一种动物, 既能跑, 也能游泳</p>\n<p>鸭子也是一种动物, 既能跑, 也能游, 还能飞</p>\n</blockquote>\n<p></p>\n<p> 🍑<span style=\"background-color:#38d8f0;\">这样设计有什么好处呢? 时刻牢记多态的好处, 让程序猿忘记类型. 有了接口之后, 类的使用者就不必关注具体类型，只要这个类有有这个特性就好。</span></p>\n<p>举个栗子🌰</p>\n<pre><code class=\"language-java\">class Robot implements IRunning {\n    private String name;\n    public Robot(String name) {\n        this.name = name;\n    }\n    // 对run方法进行重写\n    @Override\n    public void run() {\n        System.out.println(\"机器人\" + this.name + \"正在跑\");\n    }\n}\npublic class Test4 {\n    public static void main(String[] args) {\n        Robot robot1 = new Robot(\"图图\");\n        robot1.run();\n    }\n}\n// 执行结果\n机器人图图正在跑</code></pre>\n<p></p>\n<p>😎<strong>只要能跑就行，管他是机器人还是动物呢😂，接口是不是很灵活呀！</strong></p>\n<p><span style=\"background-color:#a2e043;\">同时在实际的开发过程中，一般来说，一个类是一个Java文件，一个接口也是一个Java文件。大家也要在平时就养成这个好习惯呀！</span></p>\n<p></p>\n<p><strong>哈哈，不知道现在你对抽象类和接口的认识是不是又上升了一个高度呢？嘻嘻，我们下篇博客再见了，下篇让我们瞅瞅Java中常用的接口有哪些😉</strong></p>\n<p style=\"text-align:center;\"><strong><img alt=\"\" src=\"..\\..\\static\\image\\ecaccbd87933487380bd534b4e2f4f38.png\"/></strong></p>\n<p><span style=\"background-color:#38d8f0;\"> <strong>每天进步一点点，铁汁们，一起加油😎😎😎</strong></span></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-05-19 21:40:24", "summary": "目录什么是抽象类抽象类再实现多态中的意义接口是什么各位铁汁们大家好呀！今天让我们继续学习，看看中的抽象类和接口到底是什么？什么是抽象类我们之前学过什么是类，那么抽象类是不是也是类的一种呢？听名字就感觉"}