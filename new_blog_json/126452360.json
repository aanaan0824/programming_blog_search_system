{"blogid": "126452360", "writerAge": "码龄2年", "writerBlogNum": "31", "writerCollect": "253", "writerComment": "326", "writerFan": "653", "writerGrade": "5级", "writerIntegral": "1614", "writerName": "还小给个面子", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126452360.jpg", "writerRankTotal": "12243", "writerRankWeekly": "319", "writerThumb": "633", "writerVisitNum": "12211", "blog_read_count": "88", "blog_time": "已于 2022-09-06 17:04:50 修改", "blog_title": "［Linux］进程信号（阻塞信号 | 信号集操作函数 | 信号捕捉 | 可重入函数 | volatile关键字）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5ee93720470047a8b769945644e0cb03.png\"/></p>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_6\">信号的三个阶段</a></li><li><a href=\"#_11\">信号产生中</a></li><li><ul><li><a href=\"#_22\">阻塞信号</a></li><li><a href=\"#sigset_t_37\">sigset_t</a></li><li><a href=\"#_46\">信号集操作函数</a></li></ul>\n</li><li><a href=\"#_191\">信号产生后</a></li><li><ul><li><a href=\"#_193\">内核态和用户态</a></li><li><a href=\"#_234\">内核如何实现信号的捕捉</a></li><li><a href=\"#sigaction_256\">sigaction函数</a></li></ul>\n</li><li><a href=\"#_326\">可重入函数</a></li><li><a href=\"#volatile_340\">volatile关键字</a></li><li><ul><li><a href=\"#GCC_373\">GCC优化</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_6\"></a>信号的三个阶段</h1>\n<p>学习信号需要学习信号产生前、信号产生中和信号产生后三个阶段。今天我们探讨后两个阶段。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\07c5e79b5d324bf3b61245b9fa3ca0e9.png\"/></p>\n<h1><a id=\"_11\"></a>信号产生中</h1>\n<p><strong>信号相关概念：</strong></p>\n<ul><li>实际执行信号的处理动作称为<strong>信号递达(Delivery)</strong>，信号递达后有三种处理方式：默认，忽略和自定义。</li><li>信号从产生到递达之间的状态,称为<strong>信号未决(Pending)。</strong></li><li>进程可以选择阻塞 (Block )某个信号。</li><li>被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作.</li><li>阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。</li><li>信号可选的处理动作有三种：<strong>默认(SIG_DFL)，忽略(SIG_IGN)和自定义</strong>。</li></ul>\n<h2><a id=\"_22\"></a>阻塞信号</h2>\n<p><strong>进程在收到信号后，对于信号的处理并不是立刻做出反应，这与进程的优先级有关，进程有可能在执行优先级更高的工作，信号就需要被暂时保存下来，进程的信号会被暂时保存在进程的task_struct中。</strong></p>\n<p><strong>信号在内核中的表示图：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9df4d246e9984946a2570d464f940aca.png\"/></p>\n<ul><li><strong>每个信号都有两个标志位分别表示阻塞(block)和未决(pending)，还有一个函数指针表示处理动作。信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志。</strong></li><li><strong>如果在进程解除对某信号的阻塞之前这种信号产生过多次，Linux会将常规信号在递达之前产生多次只计一次，而实时信号在递达之前产生多次可以依次放在一个队列里。</strong></li><li>在上图的例子中,SIGHUP信号未阻塞也未产生过,当它递达时执行默认处理动作。</li><li>SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。</li><li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数handler。</li></ul>\n<hr/>\n<h2><a id=\"sigset_t_37\"></a>sigset_t</h2>\n<ul><li><strong>每个信号只有一个bit的未决标志，非0即1，不记录该信号产生了多少次，阻塞标志也是这样表示的。</strong></li><li><strong>因此，未决和阻塞标志可以用相同的数据类型sigset_t来存储，sigset_t称为信号集，这个类型可以表示每个信号的“有效”或“无效”状态，在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞，而在未决信号集中“有效”和“无效”的含义是该信号是否处于未决状态。</strong></li><li><strong>阻塞信号集也叫做当前进程的信号屏蔽字(Signal Mask)，这里的“屏蔽”应该理解为阻塞而不是忽略。</strong></li></ul>\n<hr/>\n<h2><a id=\"_46\"></a>信号集操作函数</h2>\n<p>sigset_t类型对于每种信号用一个bit表示“有效”或“无效”状态，至于这个类型内部如何存储这些bit则依赖于系统实现，从使用者的角度是不必关心的，使用者只能调用以下函数来操作sigset_ t变量，而不应该对它的内部数据做任何解释，比如用printf直接打印sigset_t变量是没有意义的。</p>\n<p><strong><kbd>sigemptyset</kbd>函数</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigemptyset</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n功能：\n\t函数sigemptyset初始化set所指向的信号集<span class=\"token punctuation\">,</span>使其中所有信号的对应bit清零<span class=\"token punctuation\">,</span>\n\t表示该信号集不包含任何有效信号。\n</code></pre>\n<p><strong><kbd>sigfillset</kbd>函数</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigfillset</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n功能：\n\t函数sigfillset初始化set所指向的信号集<span class=\"token punctuation\">,</span>使其中所有信号的对应bit置位<span class=\"token punctuation\">,</span>\n\t表示该信号集的有效信号包括系统支持的所有信号。\n</code></pre>\n<p><strong><kbd>sigaddset</kbd>函数</strong> <strong>和<kbd>sigdelset</kbd>函数</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigaddset</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigdelset</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n功能：\n\t调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。\n</code></pre>\n<p><strong><kbd>sigismember</kbd>函数</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> sigismember（<span class=\"token keyword\">const</span> <span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n功能：\n\tsigismember是一个布尔函数<span class=\"token punctuation\">,</span>用于判断一个信号集的有效信号中是否包含某种信号<span class=\"token punctuation\">,</span>\n\t若包含则返回<span class=\"token number\">1</span><span class=\"token punctuation\">,</span>不包含则返回<span class=\"token number\">0</span><span class=\"token punctuation\">,</span>出错返回<span class=\"token operator\">-</span><span class=\"token number\">1</span>。 \n</code></pre>\n<p><strong><kbd>sigprocmask</kbd>函数</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigprocmask</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> how<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">,</span> <span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>oset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n功能：\n\t可以读取或更改进程的信号屏蔽字<span class=\"token punctuation\">(</span>阻塞信号集<span class=\"token punctuation\">)</span>\n返回值<span class=\"token operator\">:</span>\n\t若成功则为<span class=\"token number\">0</span><span class=\"token punctuation\">,</span>若出错则为<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n</code></pre>\n<ul><li>如果oset是非空指针,则读取进程的当前信号屏蔽字通过oset参数传出。</li><li>如果set是非空指针,则 更改进程的信号屏蔽字,参数how指示如何更改。</li><li>如果oset和set都是非空指针,则先将原来的信号 屏蔽字备份到oset里,然后根据set和how参数更改信号屏蔽字。</li></ul>\n<p>假设当前的信号屏蔽字为mask,下表说明了how参数的可选值：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\db1fa65e873347e685e0d381d36fa314.png\"/></p>\n<p><strong><kbd>sigpending</kbd>函数</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigpending</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n功能：\n\t读取当前进程的未决信号集<span class=\"token punctuation\">,</span>通过set参数传出。\n返回值：\n\t调用成功则返回<span class=\"token number\">0</span><span class=\"token punctuation\">,</span>出错则返回<span class=\"token operator\">-</span><span class=\"token number\">1</span>。\n</code></pre>\n<hr/>\n<p>下面利用这些信号集操作函数打印信号集，测试代码：</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">show_pending</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">sigset_t</span> <span class=\"token operator\">*</span>pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"process pending: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">int</span> sig <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> sig <span class=\"token operator\">&lt;=</span> <span class=\"token number\">31</span><span class=\"token punctuation\">;</span> sig<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">sigismember</span><span class=\"token punctuation\">(</span>pending<span class=\"token punctuation\">,</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n           <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token keyword\">else</span><span class=\"token punctuation\">{<!-- --></span>\n           <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span>\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d信号可被递达\\n\"</span><span class=\"token punctuation\">,</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token class-name\">sigset_t</span> iset<span class=\"token punctuation\">,</span> oset<span class=\"token punctuation\">;</span>\n   <span class=\"token function\">sigemptyset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>iset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将信号集全设置为0</span>\n   <span class=\"token function\">sigemptyset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>oset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将2号信号的处理方式设为自定义</span>\n   <span class=\"token function\">sigaddset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>iset<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置iset中的二号信号</span>\n   <span class=\"token function\">sigprocmask</span><span class=\"token punctuation\">(</span>SIG_SETMASK<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>iset<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>oset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 屏蔽进程的二号信号</span>\n   \n   <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n   <span class=\"token class-name\">sigset_t</span> pending<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n       <span class=\"token function\">sigemptyset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n       <span class=\"token function\">sigpending</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取进程的信号位图</span>\n\n       <span class=\"token function\">show_pending</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 打印进程的信号位图</span>\n       <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n           <span class=\"token function\">sigprocmask</span><span class=\"token punctuation\">(</span>SIG_SETMASK<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>oset<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span>\n\n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>运行结果：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\efb26074cbbe4bca85275ce3d353a65f.png\"/></p>\n<hr/>\n<h1><a id=\"_191\"></a>信号产生后</h1>\n<h2><a id=\"_193\"></a>内核态和用户态</h2>\n<ul><li><strong>内核态：执行操作系统OS的代码和数据的时候所处的状态叫做内核态，操作系统的代码全都是在内核态执行的。</strong></li><li><strong>用户态：用户代码和数据被访问或者执行的时候所处的状态就叫用户态，我们用户自己写的代码全部都是在用户态被执行的。</strong></li><li><strong>主要区别：权限</strong></li></ul>\n<p><strong>感性认识：</strong></p>\n<p><strong>当我们调用open系统调用时，除了会进入操作系统的open函数的具体实现，还会发生身份的变化，从用户态转化为内核态。</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5402112e17e848f7b524892d4cbcc2ee.png\"/></p>\n<hr/>\n<p><strong>理性认识：</strong></p>\n<p><strong>每一个进程都有一个4G的进程地址空间，进程地址空间分为用户空间和内核空间，用户的代码和数据通过用户级页表映射到物理内存中，用户的代码要能运行就必须被加载到内存中，内核的代码和数据同理，也要被加载到内存中，开机就是在加载内核的代码和数据到内存中，内核空间和同样拥有一份页表，叫做内核级页表。进程为了维护进程的独立性，每个进程都有自己的进程地址空间，也有自己的用户级页表，但是内核级页表只有一份，被所有的进程共享。</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\62b3227d660547d49cf49cd2b8aa7bc2.png\"/></p>\n<p>这样就保证了每个进程都能访问到自己用户的代码和内核的代码，但是能访问到内核的代码就可以执行内核的代码吗？</p>\n<p><strong>所以在进程中就必须要有一种身份认证来辨别自己的工作模式，是访问用户的代码还是访问内核的代码，这种工作模式在进程中有相关的数据去标识，这个数据会被加载到CPU中。CPU中有一个寄存器叫做CR3，CR3为0表示内核态，CR3为3表示用户态就有权限执行内核的代码，进程就可以通过这个寄存器辨别是用户态还是内核态。</strong></p>\n<p><strong>总结：</strong></p>\n<ul><li><strong>用户态使用的是用户级页表，只能访问用户的代码和数据。</strong></li><li><strong>内核态使用的是内核级页表，只能访问内核的代码和数据。</strong></li><li><strong>CPU内有寄存器保存进程的状态。</strong></li><li><strong>进程无论如何切换，都能保证找到同一个操作系统，因为每个进程都有进程地址空间使用同一份内核级页表。</strong></li><li><strong>系统调用的本质是进程的身份从用户态变成内核态，通过内核级页表找到系统函数的实现执行。</strong></li></ul>\n<hr/>\n<h2><a id=\"_234\"></a>内核如何实现信号的捕捉</h2>\n<p>信号在被操作系统发送给进程时，进程会先把信号保存在pending位图里，进程有可能在做优先级更高的工作，信号会在合适的时候被延时处理，这取决于操作系统和进程，那么信号被处理的合适的时候是什么时候呢？</p>\n<p><strong>信号被保存在进程的task_struct里的pending位图里，当进程从内核态返回用户态的时候，进行信号的检测和处理工作 – 递达信号(默认，忽略和自定义)。</strong></p>\n<p><strong>如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数,这称为捕捉信号。由于信号处理函数的代码是在用户空间的,处理过程比较复杂,举例如下: 用户程序注册了SIGQUIT信号的处理函数sighandler。 当前正在执行main函数,这时发生中断或异常切换到内核态。 在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。 内核决定返回用户态后不是恢复main函数的上下文继续执行,而是执行sighandler函 数,sighandler和main函数使用不同的堆栈空间,它们之间不存在调用和被调用的关系,是 两个独立的控制流程。 sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。 如果没有新的信号要递达,这次再返回用户态就是恢复main函数的上下文继续执行了。</strong></p>\n<p><strong>信号捕捉示意图：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\92387f5a95d0404e867301f31c1995a3.png\"/><br/> <strong>精简图：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\df7fbeeca4ab4bc1a463d07c0ac675f3.png\"/></p>\n<hr/>\n<p>为什么一定要切换成用户态才能执行信号的自定义捕捉方法呢？</p>\n<p><strong>信号的自定义捕捉方法是用户的代码和数据，操作系统（内核态）理论上是可以直接执行用户的代码的，但是因为操作系统的权限很大，不相信任何用户，不会去执行用户的代码，比如说如果在信号的自定义捕捉函数有<kbd>rm -rf /</kbd>，强制删除根目录，后果将不堪设想。操作系统为了防止执行恶意代码，不以内核态执行信号的捕捉函数，而是切换到用户态执行。</strong></p>\n<hr/>\n<h2><a id=\"sigaction_256\"></a>sigaction函数</h2>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n原型：\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">sigaction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sigaction</span> <span class=\"token operator\">*</span>act<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sigaction</span> <span class=\"token operator\">*</span>ocat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n功能：\n\t信号自定义捕捉\n返回值：\n\t调用成功返回<span class=\"token number\">0.</span>出错返回<span class=\"token operator\">-</span><span class=\"token number\">1.</span>\n</code></pre>\n<ul><li><strong>sigaction函数可以读取和修改与指定信号相关联的处理动作。调用成功则返回0,出错则返回- 1。signo是指定信号的编号。若act指针非空,则根据act修改该信号的处理动作。若oact指针非空,则通过oact传出该信号原来的处理动作。act和oact指向sigaction结构体。</strong></li></ul>\n<p><strong>sigaction结构体：</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sigaction</span> <span class=\"token punctuation\">{<!-- --></span>\n\n\t<span class=\"token keyword\">void</span>     <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>sa_handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">void</span>     <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>sa_sigaction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">siginfo_t</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">sigset_t</span>   sa_mask<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span>        sa_flags<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">void</span>     <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>sa_restorer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li><strong>将sa_handler赋值为常数SIG_IGN传给sigaction表示忽略信号，赋值为常数SIG_DFL表示执行系统默认动作，赋值为一个函数指针表示用自定义函数捕捉信号，或者说向内核注册了一个信号处理函数，该函数返回值为void，可以带一个int参数，通过参数可以得知当前信号的编号，这样就可以用同一个函数处理多种信号。显然,这也是一个回调函数，不是被main函数调用,而是被系统所调用。</strong></li><li><strong>如果在调用信号处理函数时,除了当前信号被自动屏蔽之外,还希望自动屏蔽另外一些信号,则用sa_mask字段说明这些需要额外屏蔽的信号,当信号处理函数返回时自动恢复原来的信号屏蔽字。</strong></li><li><strong>sa_flags字段包含一些选项,本章的代码都把sa_flags设为0,sa_sigaction是实时信号的处理函数。</strong></li></ul>\n<p><strong>测试代码：</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get a %d signal\\n\"</span><span class=\"token punctuation\">,</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sigaction</span> act<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>act<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>act<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    act<span class=\"token punctuation\">.</span>sa_handler <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">sigaction</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>act<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n运行结果：\n<span class=\"token punctuation\">[</span>cwx@VM<span class=\"token operator\">-</span><span class=\"token number\">20</span><span class=\"token operator\">-</span><span class=\"token number\">16</span><span class=\"token operator\">-</span>centos signal<span class=\"token punctuation\">]</span>$ <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>mytest \nhello world\nhello world\n<span class=\"token operator\">^</span>Cget a <span class=\"token number\">2</span> signal\nhello world\n</code></pre>\n<hr/>\n<h1><a id=\"_326\"></a>可重入函数</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\68cea4e490714304adf39e0605a8c055.png\"/></p>\n<ul><li>main函数调用insert函数向一个链表head中插入节点node1，插入操作分为两步，刚做完第一步的时候，因为硬件中断使进程切换到内核，再次回用户态之前检查到有信号待处理，于是切换到sighandler函数，sighandler也调用insert函数向同一个链表head中插入节点node2，插入操作的两步都做完之后从sighandler返回内核态，再次回到用户态就从main函数调用的insert函数中继续往下执行，先前做第一步之后被打断，现在继续做完第二步。结果是main函数和sighandler先后向链表中插入两个节点，而最只有一个节点真正插入链表中。</li><li><strong>insert函数被不同的控制流程调用，有可能在第一次调用还没返回时就再次进入该函数，这称<br/> 为重入，insert函数访问一个全局链表，有可能因为重入而造成错乱，像这样的函数称为不可重入函数，反之，如果一个函数只访问自己的局部变量或参数，则称为可重入(Reentrant) 函数。</strong></li></ul>\n<p>如果一个函数符合以下条件之一则是不可重入的:</p>\n<ul><li><strong>调用了malloc或free，因为malloc也是用全局链表来管理堆的。</strong></li><li><strong>调用了标准I/O库函数。标准I/O库的很多实现都以不可重入的方式使用全局数据结构。</strong></li></ul>\n<hr/>\n<h1><a id=\"volatile_340\"></a>volatile关键字</h1>\n<p>请看以下这个程序：</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n<span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">void</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get a signo: %d, flag 0 to 1\\n\"</span><span class=\"token punctuation\">,</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"process normal quit..\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n运行结果：\n<span class=\"token punctuation\">[</span>cwx@VM<span class=\"token operator\">-</span><span class=\"token number\">20</span><span class=\"token operator\">-</span><span class=\"token number\">16</span><span class=\"token operator\">-</span>centos <span class=\"token keyword\">volatile</span><span class=\"token punctuation\">]</span>$ <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>test_volatile \n<span class=\"token operator\">^</span>Cget a signo<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> flag <span class=\"token number\">0</span> to <span class=\"token number\">1</span>\nprocess normal quit<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre>\n<p>程序对2号信号进行捕捉，键入 CTRL-C ，2号信号被捕捉，执行自定义动作，修改 flag＝1，while 条件不满足，退出循环，进程退出。</p>\n<hr/>\n<h2><a id=\"GCC_373\"></a>GCC优化</h2>\n<ul><li>O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。</li><li>O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。</li><li>O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。</li></ul>\n<hr/>\n<p>我们对之前的程序进行优化：</p>\n<p><strong>Makefile文件：</strong></p>\n<pre><code class=\"prism language-c\">test_volatile<span class=\"token operator\">:</span>test_volatile<span class=\"token punctuation\">.</span>c\n\tgcc <span class=\"token operator\">-</span>o $@ $<span class=\"token operator\">^</span> <span class=\"token operator\">-</span>O3\n\t\n<span class=\"token punctuation\">.</span>PHONY<span class=\"token operator\">:</span>clean \nclean<span class=\"token operator\">:</span>\n\trm <span class=\"token operator\">-</span>rf test_volatile\n</code></pre>\n<pre><code class=\"prism language-c\">运行结果：\n<span class=\"token punctuation\">[</span>cwx@VM<span class=\"token operator\">-</span><span class=\"token number\">20</span><span class=\"token operator\">-</span><span class=\"token number\">16</span><span class=\"token operator\">-</span>centos <span class=\"token keyword\">volatile</span><span class=\"token punctuation\">]</span>$ make\ngcc <span class=\"token operator\">-</span>o test_volatile test_volatile<span class=\"token punctuation\">.</span>c <span class=\"token operator\">-</span>O3\n<span class=\"token punctuation\">[</span>cwx@VM<span class=\"token operator\">-</span><span class=\"token number\">20</span><span class=\"token operator\">-</span><span class=\"token number\">16</span><span class=\"token operator\">-</span>centos <span class=\"token keyword\">volatile</span><span class=\"token punctuation\">]</span>$ <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>test_volatile \n<span class=\"token operator\">^</span>Cget a signo<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> flag <span class=\"token number\">0</span> to <span class=\"token number\">1</span>\n<span class=\"token operator\">^</span>Cget a signo<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> flag <span class=\"token number\">0</span> to <span class=\"token number\">1</span>\n<span class=\"token operator\">^</span>Cget a signo<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> flag <span class=\"token number\">0</span> to <span class=\"token number\">1</span>\n<span class=\"token operator\">^</span>Cget a signo<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> flag <span class=\"token number\">0</span> to <span class=\"token number\">1</span>\n</code></pre>\n<p>我们会发现键入 CTRL-C进程并不会退出，但是理论上flag变量已经被由0置1了，这是为什么？</p>\n<p>while 循环检查的flag，并不是内存中最新的flag，这就存在了数据二异性的问题。 while 检测的flag其实已经因为优化，被放在了CPU寄存器当中。这就需要volatile关键字解决这个问题：</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;signal.h&gt;</span></span>\n\n<span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 保持内存的可见性</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get a signo: %d, flag 0 to 1\\n\"</span><span class=\"token punctuation\">,</span> signo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"process normal quit..\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n运行结果：\n<span class=\"token punctuation\">[</span>cwx@VM<span class=\"token operator\">-</span><span class=\"token number\">20</span><span class=\"token operator\">-</span><span class=\"token number\">16</span><span class=\"token operator\">-</span>centos <span class=\"token keyword\">volatile</span><span class=\"token punctuation\">]</span>$ <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>test_volatile \n<span class=\"token operator\">^</span>Cget a signo<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> flag <span class=\"token number\">0</span> to <span class=\"token number\">1</span>\nprocess normal quit<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre>\n<p><strong><kbd>volatile</kbd>作用：保持内存的可见性，告知编译器，被该关键字修饰的变量，不允许被优化，对该变量的任何操作，都必须在真实的内存中进行操作。</strong></p>\n<hr/>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 17:04:50", "summary": "在这里插入图片描述文章目录信号的三个阶段信号产生中阻塞信号信号集操作函数信号产生后内核态和用户态内核如何实现信号的捕捉函数可重入函数关键字优化信号的三个阶段学习信号需要学习信号产生前、信号产生中和信号"}