{"blogid": "120089521", "writerAge": "码龄15年", "writerBlogNum": "136", "writerCollect": "164", "writerComment": "40", "writerFan": "230", "writerGrade": "4级", "writerIntegral": "1490", "writerName": "龙赤子", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120089521.jpg", "writerRankTotal": "12897", "writerRankWeekly": "6522", "writerThumb": "58", "writerVisitNum": "55678", "blog_read_count": "3239", "blog_time": "于 2021-09-03 20:29:04 发布", "blog_title": "Illegal instruction 问题处理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>Illegal (iLLegal) instruction 直观解释----非法指令。表面看是CPU在执行指令过程中，发现指令非法，也就是不认识的指令或者无权限的指令。如果只是沿着这个思路，很容易陷入对编译器的信任上。其实，这个问题，也很可能是程序自己造成的。比如使用了嵌入汇编，那么编写者要对使用的指令负责。还比如堆栈、内存出错，此时，访问的指令可能是内存随机的数据或者非指令数据，这同样会导致CPU无法识别。网上看到一篇比较全的分析文章，放在这里供参考：</p>\n<p><a href=\"https://www.cnblogs.com/arnoldlu/p/10815908.html\" title=\"非法指令(Illegal Instruction)问题定位 - ArnoldLu - 博客园\">非法指令(Illegal Instruction)问题定位 - ArnoldLu - 博客园</a></p>\n<p>关于这个问题需要再补充一下：</p>\n<p>之前没有经过认真思考，就做出了上述论断，后来仔细想了想，感觉没有那么简单。对于第一种情况，使用嵌入汇编，实际测试，发现如果使用了错误的汇编指令，编译器是不认的。想想也是，嵌入汇编也是一种格式，也有很多种扩展写法，编译器并不是按照类似宏定义的方式，直接信任和使用的，而是需要进行二次处理，保留基本处理流程，重新生成不影响上下文的汇编指令（寄存器使用通盘考虑）。这样一来，想通过嵌入汇编轻松欺骗机器是行不通的。关于嵌入汇编，简单的例子可参考下面的链接：</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI0ODU0NDI1Mg==&amp;mid=2247518130&amp;idx=1&amp;sn=14d8506dffb65a9654c902e761521442&amp;chksm=e99de921deea6037319eeef5a181b949e7fb494f299835d5360c4996b4dc0f193dbead7c12d6&amp;mpshare=1&amp;scene=23&amp;srcid=090652gI4Y2nK3OF4vZcI0dz&amp;sharer_sharetime=1630926476654&amp;sharer_shareid=4885b6c37fd0e81ce770cbe6e8518ef1#rd\" title=\"内联汇编很可怕吗？看完这篇文章，终结它！\">内联汇编很可怕吗？看完这篇文章，终结它！</a></p>\n<p>继续，对于第二种情况，修改代码指令，也不是简单轻松的事情。现代操作系统都是用了虚拟内存机制，进一步的，大部分都采用了分页机制。那么，对于程序的代码段，操作系统在映射内存页面的时候，会标记这类页面为只读，所以，尝试对代码直接修改，也是行不通的。</p>\n<p>对于这一点，也不是绝对的。可以通过mprotect调用，修改页面的读写属性，参考文章：</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652680039&amp;idx=1&amp;sn=577948fef6dc6709ff2de16a9906aec1&amp;chksm=810fe9fab67860ec60ca23a0d4f0c1d2609b67d77a2e6143a22c03bd3faa51ca9be731d3ee31&amp;mpshare=1&amp;scene=23&amp;srcid=1008RFTbsXqLPN1CxRuAj7pd&amp;sharer_sharetime=1633671192103&amp;sharer_shareid=4885b6c37fd0e81ce770cbe6e8518ef1#rd\" title=\"内核热补丁，真的安全么？\">内核热补丁，真的安全么？</a></p>\n<p>综合上述两点，人为产生非法指令，还需要再思考思考。</p>\n<p><strong>第三次补充：在X86下尝试多次均失败后，终于在arm下人为成功产生了上述错误指令提示。具体过程如下：</strong></p>\n<p>首先，对程序做了简单处理，增加了如下的异常信号捕获</p>\n<pre><code>void signal_handler(int signum) {\n   printf(\"Signal %d (number) captured \\n\", signum);\n}\n\nsignal(SIGILL , signal_handler);</code></pre>\n<p><br/> 上述代码期望在非法指令产生时，由应用捕获，并进一步处理。</p>\n<p>然后对于x86，因为简单的错误指令会被编译器识别，所以主要尝试了call和jmp指令。在这两个指令后都附带一个随机地址，可以编译通过。但是，实际运行，都是类似段错误，也就是主要是内存错误。<br/> call因为是类似函数调用，有入栈出栈等操作，段错误还是可以理解的，但是jmp指令是无条件跳转，跳转到的地址包含的内容可能不是有效的代码，比如无法译码。但是，多次尝试，仍然也是报段错误。x86下放弃。</p>\n<p>尝试ARM平台。找到了一个跟CPU版本相关的指令，swpb，这是一个存在于早期ARM CPU上的指令，感兴趣的读者可以搜索了解一下。<br/> 使用如下嵌入汇编代码</p>\n<pre><code>asm volatile(\"swpb %0,%2,[%3]\"\n             : \"=&amp;r\"(ret), \"=m\" (*ptr)\n             : \"r\"(newval), \"r\"(ptr)\n             : \"cc\", \"memory\");    //memory == no cache  |  cc == status register update</code></pre>\n<p>编译通过。执行程序，报非法指令。<br/> gdb跟踪调试，发现报非法指令时，的确在swpb指令处。如下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\20210907185612810.png\"/></p>\n<p></p>\n<p>Program received signal SIGILL, Illegal instruction.    成功产生非法指令。<br/> 这说明，在嵌入式平台上，可能会因为嵌入汇编、编译器版本、连接库等导致出现运行时非法指令。</p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-09-03 20:29:04", "summary": "直观解释非法指令。表面看是在执行指令过程中，发现指令非法，也就是不认识的指令或者无权限的指令。如果只是沿着这个思路，很容易陷入对编译器的信任上。其实，这个问题，也很可能是程序自己造成的。比如使用了嵌入"}