{"blogid": "123762215", "writerAge": "码龄2年", "writerBlogNum": "8", "writerCollect": "170", "writerComment": "52", "writerFan": "2065", "writerGrade": "2级", "writerIntegral": "158", "writerName": "武大人民泌外I科人工智能团队", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123762215.jpg", "writerRankTotal": "127421", "writerRankWeekly": "8429", "writerThumb": "26", "writerVisitNum": "25229", "blog_read_count": "13334", "blog_time": "已于 2022-03-29 15:03:24 修改", "blog_title": "Yolov5 + Deepsort 重新训练自己的数据（保姆级超详细）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>从下面github库中拿代码：</p>\n<p><a class=\"has-card\" href=\"https://github.com/mikel-brostrom/Yolov5_DeepSort_Pytorch\" title=\"https://github.com/mikel-brostrom/Yolov5_DeepSort_Pytorch\"><span class=\"link-card-box\"><span class=\"link-title\">https://github.com/mikel-brostrom/Yolov5_DeepSort_Pytorch</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://github.com/mikel-brostrom/Yolov5_DeepSort_Pytorch</span></span></a><a class=\"has-card\" href=\"https://github.com/Sharpiless/Yolov5-Deepsort\" title=\"GitHub - Sharpiless/Yolov5-Deepsort: 最新版本yolov5+deepsort目标检测和追踪，能够显示目标类别，支持5.0版本可训练自己数据集\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - Sharpiless/Yolov5-Deepsort: 最新版本yolov5+deepsort目标检测和追踪，能够显示目标类别，支持5.0版本可训练自己数据集</span><span class=\"link-desc\">最新版本yolov5+deepsort目标检测和追踪，能够显示目标类别，支持5.0版本可训练自己数据集 - GitHub - Sharpiless/Yolov5-Deepsort: 最新版本yolov5+deepsort目标检测和追踪，能够显示目标类别，支持5.0版本可训练自己数据集</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/Sharpiless/Yolov5-Deepsort</span></span></a></p>\n<p><strong>下载好匹配的deeosort和yolov5代码很重要，题主折腾了一天，坑在版本上了！！</strong></p>\n<p><strong>题主用的deeosort v3.0和yolov5 5.0版本，master似乎还不完善，没跑通，要是跑通了的读者希望可以交流一下。</strong></p>\n<p>直接进入正题：</p>\n<h2>一.目标追踪整体代码</h2>\n<p><img alt=\"\" height=\"566\" src=\"..\\..\\static\\image\\fb48ae0d45564f8e848ee86266292f76.png\" width=\"275\"/></p>\n<p> 分别主体是yolov5和deep_sort。</p>\n<h2>二.训练自己的数据集</h2>\n<p>yolov5和deep_sort分开训练。首先训练yolov5，这个不难，超链接如下。</p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/weixin_53711236/article/details/123766920\" title=\"Yolov5 超详细教程_武大人民泌外I科人工智能团队的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">Yolov5 超详细教程_武大人民泌外I科人工智能团队的博客-CSDN博客</span><span class=\"link-desc\">首先github拿代码：GitHub - ultralytics/yolov5: YOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLiteYOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite. Contribute to ultralytics/yolov5 development by creating an account on GitHub.https://github.com/ultralyt</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/weixin_53711236/article/details/123766920</span></span></a></p>\n<h2>三.训练deep_sort</h2>\n<p>准备deep_sort的数据集，和yolov5不一样，这是一个分类的数据集。</p>\n<p>我们用代码把图像中的检测目标扣出来，作为我们的数据集。</p>\n<p>代码如下：</p>\n<pre><code>import cv2\nimport xml.etree.ElementTree as ET\nimport numpy as np\n\nimport xml.dom.minidom\nimport os\nimport argparse\n\n\ndef main():\n    # JPG文件的地址\n    img_path = '/home/zqy/Desktop/yolov5-master/nxm_data/images_all/'\n    # XML文件的地址\n    anno_path = '/home/zqy/Desktop/yolov5-master/nxm_data/labels_xml/'\n    # 存结果的文件夹\n\n    cut_path = '/home/zqy/Desktop/yolov5-master/nxm_data/crops/'\n    if not os.path.exists(cut_path):\n        os.makedirs(cut_path)\n    # 获取文件夹中的文件\n    imagelist = os.listdir(img_path)\n    # print(imagelist\n    for image in imagelist:\n        image_pre, ext = os.path.splitext(image)\n        img_file = img_path + image\n        img = cv2.imread(img_file)\n        xml_file = anno_path + image_pre + '.xml'\n        # DOMTree = xml.dom.minidom.parse(xml_file)\n        # collection = DOMTree.documentElement\n        # objects = collection.getElementsByTagName(\"object\")\n\n        tree = ET.parse(xml_file)\n        root = tree.getroot()\n        # if root.find('object') == None:\n        #     return\n        obj_i = 0\n        for obj in root.iter('object'):\n            obj_i += 1\n            print(obj_i)\n            cls = obj.find('name').text\n            xmlbox = obj.find('bndbox')\n            b = [int(float(xmlbox.find('xmin').text)), int(float(xmlbox.find('ymin').text)),\n                 int(float(xmlbox.find('xmax').text)),\n                 int(float(xmlbox.find('ymax').text))]\n            img_cut = img[b[1]:b[3], b[0]:b[2], :]\n            path = os.path.join(cut_path, cls)\n            # 目录是否存在,不存在则创建\n            mkdirlambda = lambda x: os.makedirs(x) if not os.path.exists(x) else True\n            mkdirlambda(path)\n            try:\n                cv2.imwrite(os.path.join(cut_path, cls, '{}_{:0&gt;2d}.jpg'.format(image_pre, obj_i)), img_cut)\n            except:\n                continue\n\n            print(\"&amp;&amp;&amp;&amp;\")\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>注意：这里数据集可能会存在负样本，导致img_cut为空，我在这里修改了代码，加了try判断，只算入了正样本。</p>\n<p>上述代码在自己的数据集上生成了crops文件夹，目录如下：</p>\n<p><img alt=\"\" height=\"620\" src=\"..\\..\\static\\image\\416c145fe4a44585886f4eae7cf8307f.png\" width=\"1093\"/></p>\n<p>接着要把这些数据分为训练集和验证集，跟类别有关系，注意类别和目标是两个概念。</p>\n<p>我在这检测的目标只有一个，但是可以有不同的类别，在这里的类别有112个，因此训练集和测试集下边的类别就应该有112个。可以自己整理，也可以用代码分，代码如下：</p>\n<pre><code>import os\nfrom PIL import Image\nfrom shutil import copyfile, copytree, rmtree, move\n\nPATH_DATASET = '/home/zqy/Desktop/yolov5-master/nxm_data/crops'  # 需要处理的文件夹\nPATH_NEW_DATASET = '/home/zqy/Desktop/yolov5-master/nxm_data/stitches'  # 处理后的文件夹\nPATH_ALL_IMAGES = PATH_NEW_DATASET + '/all_images'\nPATH_TRAIN = PATH_NEW_DATASET + '/train'\nPATH_TEST = PATH_NEW_DATASET + '/test'\n\n\n# 定义创建目录函数\ndef mymkdir(path):\n    path = path.strip()  # 去除首位空格\n    path = path.rstrip(\"\\\\\")  # 去除尾部 \\ 符号\n    isExists = os.path.exists(path)  # 判断路径是否存在\n    if not isExists:\n        os.makedirs(path)  # 如果不存在则创建目录\n        print(path + ' 创建成功')\n        return True\n    else:\n        # 如果目录存在则不创建，并提示目录已存在\n        print(path + ' 目录已存在')\n        return False\n\n\nclass BatchRename():\n    '''\n    批量重命名文件夹中的图片文件\n    '''\n\n    def __init__(self):\n        self.path = PATH_DATASET  # 表示需要命名处理的文件夹\n\n    # 修改图像尺寸\n    def resize(self):\n        for aroot, dirs, files in os.walk(self.path):\n            # aroot是self.path目录下的所有子目录（含self.path）,dir是self.path下所有的文件夹的列表.\n            filelist = files  # 注意此处仅是该路径下的其中一个列表\n            # print('list', list)\n\n            # filelist = os.listdir(self.path) #获取文件路径\n            total_num = len(filelist)  # 获取文件长度（个数）\n\n            for item in filelist:\n                if item.endswith('.jpg'):  # 初始的图片的格式为jpg格式的（或者源文件是png格式及其他格式，后面的转换格式就可以调整为自己需要的格式即可）\n                    src = os.path.join(os.path.abspath(aroot), item)\n\n                    # 修改图片尺寸到128宽*256高\n                    im = Image.open(src)\n                    out = im.resize((128, 256), Image.ANTIALIAS)  # resize image with high-quality\n                    out.save(src)  # 原路径保存\n\n    def rename(self):\n\n        for aroot, dirs, files in os.walk(self.path):\n            # aroot是self.path目录下的所有子目录（含self.path）,dir是self.path下所有的文件夹的列表.\n            filelist = files  # 注意此处仅是该路径下的其中一个列表\n            # print('list', list)\n\n            # filelist = os.listdir(self.path) #获取文件路径\n            total_num = len(filelist)  # 获取文件长度（个数）\n\n            i = 1  # 表示文件的命名是从1开始的\n            for item in filelist:\n                if item.endswith('.jpg'):  # 初始的图片的格式为jpg格式的（或者源文件是png格式及其他格式，后面的转换格式就可以调整为自己需要的格式即可）\n                    src = os.path.join(os.path.abspath(aroot), item)\n\n                    # 根据图片名创建图片目录\n                    dirname = str(item.split('_')[0])\n                    # 为相同车辆创建目录\n                    # new_dir = os.path.join(self.path, '..', 'bbox_all', dirname)\n                    new_dir = os.path.join(PATH_ALL_IMAGES, dirname)\n                    if not os.path.isdir(new_dir):\n                        mymkdir(new_dir)\n\n                    # 获得new_dir中的图片数\n                    num_pic = len(os.listdir(new_dir))\n\n                    dst = os.path.join(os.path.abspath(new_dir),\n                                       dirname + 'C1T0001F' + str(num_pic + 1) + '.jpg')\n                    # 处理后的格式也为jpg格式的，当然这里可以改成png格式    C1T0001F见mars.py filenames 相机ID，跟踪指数\n                    # dst = os.path.join(os.path.abspath(self.path), '0000' + format(str(i), '0&gt;3s') + '.jpg')    这种情况下的命名格式为0000000.jpg形式，可以自主定义想要的格式\n                    try:\n                        copyfile(src, dst)  # os.rename(src, dst)\n                        print('converting %s to %s ...' % (src, dst))\n                        i = i + 1\n                    except:\n                        continue\n            print('total %d to rename &amp; converted %d jpgs' % (total_num, i))\n\n    def split(self):\n        # ---------------------------------------\n        # train_test\n        images_path = PATH_ALL_IMAGES\n        train_save_path = PATH_TRAIN\n        test_save_path = PATH_TEST\n        if not os.path.isdir(train_save_path):\n            os.mkdir(train_save_path)\n            os.mkdir(test_save_path)\n\n        for _, dirs, _ in os.walk(images_path, topdown=True):\n            for i, dir in enumerate(dirs):\n                for root, _, files in os.walk(images_path + '/' + dir, topdown=True):\n                    for j, file in enumerate(files):\n                        if (j == 0):  # test dataset；每个车辆的第一幅图片\n                            print(\"序号：%s  文件夹： %s  图片：%s 归为测试集\" % (i + 1, root, file))\n                            src_path = root + '/' + file\n                            dst_dir = test_save_path + '/' + dir\n                            if not os.path.isdir(dst_dir):\n                                os.mkdir(dst_dir)\n                            dst_path = dst_dir + '/' + file\n                            move(src_path, dst_path)\n                        else:\n                            src_path = root + '/' + file\n                            dst_dir = train_save_path + '/' + dir\n                            if not os.path.isdir(dst_dir):\n                                os.mkdir(dst_dir)\n                            dst_path = dst_dir + '/' + file\n                            move(src_path, dst_path)\n        rmtree(PATH_ALL_IMAGES)\n\n\nif __name__ == '__main__':\n    demo = BatchRename()\n    demo.resize()\n    demo.rename()\n    demo.split()\n\n</code></pre>\n<p>分好后train和test下各有112个文件夹，代表着112个类别。</p>\n<p>将train和test移动到deep_sort/deep目录下。</p>\n<p>修改train.py中train dataset的预处理如下：</p>\n<pre><code>transform_train = torchvision.transforms.Compose([\n    torchvision.transforms.Resize((128, 64)),\n    torchvision.transforms.RandomCrop((128, 64), padding=4),\n    torchvision.transforms.RandomHorizontalFlip(),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize(\n        [0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n])\n</code></pre>\n<p> 接着修改147行，以免权重保存覆盖原始权重：</p>\n<pre><code>        torch.save(checkpoint, './checkpoint/ckpt1.t7')</code></pre>\n<p>接着在model.py中修改类别，这类是112个类别：</p>\n<pre><code>\nclass Net(nn.Module):\n    def __init__(self, num_classes= 112 ,reid=False):\n        super(Net,self).__init__()\n        # 3 128 64\n        self.conv = nn.Sequential(\n            nn.Conv2d(3,64,3,stride=1,padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True),\n            # nn.Conv2d(32,32,3,stride=1,padding=1),\n            # nn.BatchNorm2d(32),\n            # nn.ReLU(inplace=True),\n            nn.MaxPool2d(3,2,padding=1),\n        )\n</code></pre>\n<p>然后在deep_sort/deep目录下打开终端，运行：</p>\n<pre><code>python train.py --data-dir data/</code></pre>\n<p>得到结果如下：</p>\n<p><img alt=\"\" height=\"430\" src=\"..\\..\\static\\image\\faae92d146c64555b5941623b4f0d16e.png\" width=\"665\"/></p>\n<p> 权重结果保存在deep/checkpoint中。</p>\n<h2>四.测试结果</h2>\n<pre><code>python track.py --yolo_weights 你的权重 --source 你的视频 --deep_sort_weights 你的权重 --device 0 --save-vid\n</code></pre>\n<p> --save-vid要调用，否则不会保存结果。</p>\n<p>结束！</p>\n<p>ps:如果报错</p>\n<pre><code> File \"/home/zqy/Desktop/Yolov5_DeepSort_Pytorch-3.0/deep_sort_pytorch/deep_sort/deep/feature_extractor.py\", line 37, in _resize\n    return cv2.resize(im.astype(np.float32)/255., size)\ncv2.error: OpenCV(4.5.5) /io/opencv/modules/imgproc/src/resize.cpp:4052: error: (-215:Assertion failed) !ssize.empty() in function 'resize'</code></pre>\n<p>原因，track.py里的iou和nms调太低了，如果仍然报错，建议加个try跳过这些空的im。</p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-29 15:03:24", "summary": "从下面库中拿代码：最新版本目标检测和追踪，能够显示目标类别，支持版本可训练自己数据集最新版本目标检测和追踪，能够显示目标类别，支持版本可训练自己数据集最新版本目标检测和追踪，能够显示目标类别，支持版本"}