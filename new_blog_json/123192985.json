{"blogid": "123192985", "writerAge": "码龄7年", "writerBlogNum": "7", "writerCollect": "79", "writerComment": "4", "writerFan": "5", "writerGrade": "2级", "writerIntegral": "113", "writerName": "刃星辰", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123192985.jpg", "writerRankTotal": "170273", "writerRankWeekly": "977475", "writerThumb": "16", "writerVisitNum": "9657", "blog_read_count": "4088", "blog_time": "已于 2022-03-14 14:31:06 修改", "blog_title": "基于Unity的C#中各类函数使用方法及示例", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><em><strong>以下笔记和示例内容是基于目前自学总结的经验以及观看教学视频的结论和示例，仅记录了较为常用且自认为不好记的方法和小技巧，内容暂时不全待我后期学习慢慢完善，用于学习记录，内容仅作参考，如有错误还请帮忙指正谢谢咯！</strong></em></p>\n<h2><a id=\"_5\"></a>【创建变量】</h2>\n<p>（1）void Awake()<em>【无论脚本script是否启用，都在点击开始时运行，Unity预制的函数，而void Start是只有启用了该脚本后，才会执行一次】</em><br/> （2）public class PlayerController ：MonoBehaviour*【class后面的PlayerCountroller是这个C#的文件代码的名称，MonoBehaviour是它所调用的类的库，里面包含很多函数和方法，所有的unity脚本的驱动都要调用它】*<br/> （3）public GameObject player【<em>GameObject是Unity自带的变量类型，所以所有在Hierarchy里出现的东西都叫gameobject，是一个项目】</em></p>\n<h2><a id=\"_12\"></a>【启动和禁用组件】</h2>\n<p>（1）例：A.enable=!A.enable;<em>【!A.enable意思是将它设为非当前值，不是true就是false，该处代码可以在每次执行时支持反复开关而不需要各种判断语句】</em></p>\n<h2><a id=\"Transform_17\"></a>【Transform】</h2>\n<p>（1）transform.position=new vector2(xx,xx)<em>【unity默认写法，更改一个坐标值的时候要给他一个新的值】</em></p>\n<h2><a id=\"Function_22\"></a>【函数Function】</h2>\n<p>（1）void Start(){}<em>【void是一个无任何返回值的函数，Start代表函数名】</em><br/> （2）int Start(){return;}<em>【在有返回值的情况下一定要在后面加上return，不然会报错，其中返回的值保存在Start函数，在调用时直接写上Start这个函数名即可】</em><br/> （2）FixedUpdate(){}<em>【物理运动；在每帧当中都会执行，同时大概每0.02秒执行一次，可以在unity设置中调节，通常使用物理运动或物理刚体中使用】</em></p>\n<h2><a id=\"UnityScriptLifecycle_29\"></a>【Unity中代码的生命周期ScriptLifecycle】</h2>\n<p>（1）代码执行周期和顺序：https://docs.unity3d.com/Manual/ExecutionOrder.html<br/> （2）常用方法执行循序，与代码摆放位置无关：Awake()最先执行—&gt;到OnEnable()<em>【当脚本启用时执行】</em>—&gt;到Start()—&gt;到FixedUpdate()—&gt;到OnTrigger系列()—&gt;到OnCollision系列()—&gt;到OnMouse系列()—&gt;到Update()—&gt;到LateUpdate【在当前帧执行完成后才执行，比Update晚】—&gt;到OnGUI()【渲染图形用户界面，界面按钮啥的】—&gt;到OnDestroy()<em>【会在代码最后部分执行】</em></p>\n<h2><a id=\"Array_35\"></a>【数组Array】【方便管理代码中相同类型的数据】</h2>\n<p>（1）基本写法：type[] name = new type[number];<em>【在定义变量的时候，在变量类型后接上中括号，代表它是一个数组变量，然后在接上它的名字，第一种写法就是可以让它等于新的变量类型，然后中括号里记录这个变量类型的数组有多少个数据】</em><br/> （2）另一种写法：type[] name=(data1;data2);<em>【大括号里直接写上想要保存的数据，用分号隔开】</em><br/> （3）第三种写法：Public type[] name;<em>【用public生成一个数组的类型变量，不给他赋值，在unity中赋值】</em><br/> （4）例1：int[] num=new int[3]<em>【代表数组里可以存储三个数据】</em>，输入数据：num[0]=4,num[1]=10;…<em>【最多可以输入三个数据】</em><br/> （5）例2：public string[] name={“zhao”,“cai”,“bo”}<em>【创建一个字符型的数组，系统会自动判断多少个数据，为3个】</em>，输出数组的数据个数(长度)：name.Length<br/> （6）例3：public GameObject[] cubes;<em>【生成一个类型为gameobject来存放方块，在unity中来输入长度，并拖入gameobject到element】</em><br/> 【同时数组也可以用来检测游戏中某一个物体的总个数：cubes=GameObject.FindGameObjectsWithTag(“cube”);，之后系统会检测到物体的个数并设置为这个数组的个数(长度)】</p>\n<h2><a id=\"List_45\"></a>【List】</h2>\n<p>（1）List与数组最大的不同是：数组长度是固定的，而List在使用的时候长度是可变的<br/> （2）定义时：List itemList = new List();<br/> （3）添加元素：itemList.Add(XXX);【不断添加元素长度会不停的变化】<br/> （4）移除元素：itemList.Remove(itemList[itemIndex]);【比如删除了中间的元素后，后面的元素会自动补上原先被删除的序列号并自动排序】<br/> （5）查找元素：itemList.Contains(XXX);【通过输入项目的名字来查找列表中是否有该元素，有则返回true】<br/> （6）查询列表长度：itemList.Count;</p>\n<h2><a id=\"foreach_55\"></a>【foreach遍历数组】</h2>\n<p>（1）例：foreach(Transform item in test){}【Transfrom是变量类型，（自定名称）item是变量，test是需要循环读取的数组名】<br/> （2）foreach(var item in test){}【循环test里面的每一个数据并保存到item中，直到结束】</p>\n<h2><a id=\"varvariable_61\"></a>【var：variable可变的】</h2>\n<p>（1）会自动识别所需要的类型：var Data ={ “阿巴阿巴阿巴”};，等同于string[] Data={“阿巴阿巴阿巴”};</p>\n<h2><a id=\"Coroutine_66\"></a>【Coroutine协程】</h2>\n<p>（1）协程处理需要与yield return new WaitForSeconds(时间/秒)配合使用，当使用时，协程会通过你设置的秒数来暂停后续代码的执行，例如对话打字系统，可以通过协程来实现一字一字的显示效果<br/> （2）协程定义代码：IEnumerator 协程名(){yield return new WaitForSeconds(0.3);}【执行该协程时，会暂停0.3秒后执行后续语句，update不受影响<br/> （3）协程调用代码：StartCoroutine( 协程名());</p>\n<h2><a id=\"UI_72\"></a>【UI调整】</h2>\n<p>（1）UI界面中的Rect Transform居中对其方法，按住Alt健+鼠标左键点击相关的对其图片即可自动对其<br/> （2）ctrl+D可以快速复制一个物体</p>\n<h2><a id=\"ScriptableObject_79\"></a>【ScriptableObject】</h2>\n<p>（1）与MonoBehaviour类似，ScriptableObject是一个特殊的类，它不需要挂载在任何一个gameobject上，可以直接存储在文件夹当中，可以用来保存游戏数据<br/> （2）通常与CreateAssetMenu配合起来一起工作，用于创建右键菜单来创建Asset文件，而Asset文件就是用来保存游戏数据的数据库，例如：[CreateAssetMenu(fileName =“itemData”,menuName = “Datas/itemData”)]，【其中itemData是创建出来的默认文件名（可修改），而Datas/itemData是右键菜单的路径】</p>\n<h2><a id=\"Sorting_Layers_85\"></a>【Sorting Layers】</h2>\n<p>（1）排序越靠下的越在镜头前面显示，越上面的反之】</p>\n<h2><a id=\"Gravity_Scale_89\"></a>【Gravity Scale】</h2>\n<p>（1）RigidBody中的Gravity Scale重力比例是由一个基数乘以Unity系统设置中的默认重力-9.81<br/> （2）修改系统重力方法：Edit—》Project Settings—》Physics2D</p>\n<h2><a id=\"_94\"></a>【方法重载的方法需要有返回值】</h2>\n<p>（1）专门为一个方法创建方法函数来添加我想要的值，例如：RaycastHit2D Raycast(XXX,XXX,XXX,XXX){ }</p>\n<h2><a id=\"return_98\"></a>【return函数】</h2>\n<p>（1）在一个函数后面加上return后，return后面的函数将不会执行，这个方法会不断return，直到跳过它才会执行后面的函数</p>\n<h2><a id=\"_102\"></a>【&amp;与&amp;&amp;】</h2>\n<p>（1）&amp;与&amp;&amp;都是“与”的意思，区别在于如果&amp;&amp;前一个条件判断为false，那么&amp;&amp;则不用去判断第二个（即短路），但是&amp;不论真或假都需要全部判断。<br/> （2）如果&amp;&amp;两边表达式计算的结果都是true，那么&amp;&amp;的结果就是true，否则就是false。<br/> （3）&amp;是位运算，按位与，参与运算的一半是两个整数。例如：5 &amp; 3，由于5的二进制码是0101，3的二进制码0011，那么0101 &amp; 0011 = 0001，所以结果就是1。<br/> （4）&amp;也可以用作两个bool型数据的运算，同样，当两边都是ture，结果才是true，不过&amp;在bool型数据运算时，不存在快速运算法则。</p>\n<h2><a id=\"Polygon_Collider_2D_109\"></a>【Polygon Collider 2D】</h2>\n<p>（1）要删除无用顶点可以按住ctrl后，将鼠标移动至边界线上，出现红色即可删除</p>\n<h2><a id=\"_113\"></a>【获得父级组件方法】</h2>\n<p>（1）XXX=GetComponentInParent();</p>\n<h2><a id=\"Audio_117\"></a>【Audio系列】</h2>\n<p>（1）引用命名空间：using UnityEngine.Audio; 组件介绍：Audio Listener：相当于耳朵，接收声音，由摄像机挂载。Audio Source：相当于播放器，用来播放音频。Audio Clips：音源，也就是声音片段。<br/> （2）添加Audio Source后如果左边出现蓝条，代表这个组件还没有保存到预制体中，是临时的。若要保存，可以点击右上角的Overrides进行添加<br/> （3）为了方便管理很多音频，可以专门创建一个空项目GameObject来管理所有的音效，之后为其创建一个音频管理脚本来控制播放。<br/> （4）在音频管理脚本中为了方便其他脚本的调用，而不用反复在其他脚本中生成示例去调用这个音频管理脚本，可以让音频管理脚本的这个类进行原地实例化，这样就可以通过这个实例化后的实体来访问这个脚本中的所有函数<br/> （5）实例化方法：static 类名 实体名(自定名称); 之后在Awake函数中(一开始就执行)，让实体名=this; ，因为你创建的这个类是无法为它赋值的，所以只能让这个实例的变量等于这个类的本身，也就是this，之后就可以在其他脚本中通过这个实体名来调用音频管理脚本中的所有函数（类名.实体名.函数名()）<br/> 例如：<br/> public class Audio : MonoBehaviour<br/> {<!-- --><br/> public static Audio GameAudios;<br/> public void footAudio()<br/> {<!-- --><br/> XXX;<br/> }<br/> }</p>\n<p>调用时：Audio.GameAudios.footAudio();即可</p>\n<p>（6）代码添加组件方法：先定义：AudioSource Sound;-------》初始化并赋值Sound=gameObject.AddComponent();</p>\n<h2><a id=\"SerializeField_139\"></a>【SerializeField序列化】</h2>\n<p>（1）如果你想设置某一函数为private，又想在Unity中可以进行拖拽操作赋值，就可以在你想这么做的函数前写上头命令：[SerializeField]</p>\n<h2><a id=\"DontDestroyOnLoad_143\"></a>【DontDestroyOnLoad】</h2>\n<p>（1）如果你不希望当前的某个项目在场景重新加载时被销毁，可以用DontDestroyOnLoad(GameObject);<em>【GameObjet为当前项目，可以用于背景音乐的组件管理，避免音乐被暂停】</em></p>\n<h2><a id=\"RandomRange_147\"></a>【Random.Range范围界定】</h2>\n<p>（1）当Range的参数是float时，返回一个随机浮点数，在min（包含）和max（包含）之间，此时包括临界值<br/> （2）当Range的参数是int时，返回一个随机整数，在min（包含）和max（排除）之间，是一个左闭右开的，只包含最小值，不包含最大值，例如：Random.Range(1,4);这个结果就是随机一个1,2,3不含4</p>\n<h2><a id=\"Cull_Transparent_Mesh_153\"></a>【Cull Transparent Mesh】</h2>\n<p>（1）Canvas Renderer中的Cull Transparent Mesh，具体功能是说当UI组件完全透明的时候是否剔除，如果不勾选，完全透明的物体也会参与渲染计算，占用一个批次，如果勾选，则将其忽略；</p>\n<h2><a id=\"ToString_157\"></a>【ToString()】</h2>\n<p>（1）使用ToString可以将数值型int，float等转为字符型，用来将游戏数据以字符型的形式保存在UI界面中的text文本中</p>\n<h2><a id=\"gameObjectGameObject_161\"></a>【理解脚本中gameObject和GameObject的区别】</h2>\n<p>（1）Gameobject不是对象，通常需要获取一个对象，就像你定义一个public GameObject A；<br/> 那么属性里就会出现一个可托选的框，那就是Unity告诉你，你定义的这个物体是哪个物体要你选择，无论你拖拽也好，脚本里获取也好，都是要给A赋予对象的。它是一个类型，所有的游戏物件都是这个类型的对象。<br/> （2）而gameobject是一个对象，指的是这个脚本所附着的游戏物件</p>\n<h2><a id=\"_167\"></a>【游戏时间统计】</h2>\n<p>（1）如果单纯使用Time.time，它只会显示几点几秒而不是正常的几时几分几秒，因此要将秒数换算成分钟<br/> （2）方法：<br/> 1、int Minutes= (int)(time.time/60);【通过对时间强制转换为整数秒后除以60可得分钟数】<br/> 2、int Seconds= Time.time % 60;【通过对运行时间取余60可得以60为最大值的秒数，例如119秒对60取余可得59秒，当运行时间到120秒时，对60取余将为0，而显示的秒数将不会超出60】<br/> （3）输出：text = Minute.ToString(“00”)+\":\"+ Seconds.ToString(“00”);【这样就会输出00：00的格式，其中ToString(“00”)代表输出格式，为两位数的分钟，三个0同理】</p>\n<h2><a id=\"Rigidbody_175\"></a>【Rigidbody系列】</h2>\n<p>(1)如果想要改变rigibody中的bodytype让游戏角色静止，可以用：<br/> Rigi.bodyType = RigidbodyType2D.Dynamic;或者Rigi.bodyType = RigidbodyType2D.Static;</p>\n<h2><a id=\"_180\"></a>【游戏暂停】</h2>\n<p>（1）Time.timeScale=0f时，可以使游戏的运算速度为0，那么游戏将会暂停。【这可用于慢动作效果或加快应用程序速度。当设置时间刻度为 1.0 时，时间流逝的速度与实时一样快。当时间刻度为 0.5 时，时间比实时慢 2 倍，‎当 timeScale 设置为零时，如果所有函数都与帧速率无关，则应用程序的行为就像暂停一样。负值将被忽略】<br/> 【注意：‎FixedUpdate 函数和具有 ‎‎WaitForSeconds 的‎‎挂起的协程在 timeScale 设置为零时不会调用】</p>\n<h2><a id=\"Audio_Mixerslider_185\"></a>【Audio Mixer，通过slider调节游戏声音】</h2>\n<p>（1）先在project视图中创建audiomixer，之后双击创建好的mixer，在groups面板下可以为游戏创建多个混音器，之后单机某一个混音器，在inspector窗口中右键volume项，为这个混音器expose一下，设置为脚本可编辑模式—》之后可以在exposed parameter项更改参数名，这个参数名就作为之后代码中SetFloat的“string name“。<br/> （2）在代码中添加一个公共变量：public AudioMixerGroup XXX;，这个可以为audiosource的outputmixer赋值，记得在unity中对其进行赋值。<br/> （3）之后再创建一个：public AudioMixer VolumeControl;用来通过外部组件控制mxier中各混音器的音量大小。<br/> （4）最后创建一个函数：<br/> public void BGMControl(float Mix)<br/> {<!-- --><br/> VolumeControl.SetFloat(“BGM”, Mix);<br/> }<br/> 【其中Mix用来接收从slider中的数值，记得在slider中选择dynamic float中的Mix来通过滑动条动态的调节音量，如果不使用dynamic float，就只能通过手动赋值才能调节音量】</p>\n<p></p>\n<p><strong>哔哩哔哩Unity中文课堂课程预告片笔记</strong></p>\n<p><strong>【矢量数学】</strong><br/> （1）Vector3.Dot(VectorA,VectorB)<em>【点积用于判断两向量是否垂直，若两向量的x1</em>x2+y1<em>y2+z1</em>z2之和等于0，则说明两向量垂直。以飞机飞行姿态为例：若两向量点积为正，则两向量角为锐角，飞行阻力增大；若为负，则为钝角，机头朝下，速度加快】*<br/> （2）Vector3.Cross(VectorA,VectorB)<em>【叉积可以计算出另一个向量，例如对A和B向量进行叉积运算，可以得出一个与这两个向量都垂直的向量C。以坦克为例：若已知目标朝向A，炮台朝向B，则可以求出垂直的轴C，转动C轴就可以转动炮台指向目标】</em></p>\n<p><strong>【Translate和Rotate】</strong><br/> (1)通常在平移操作时速度乘上Time.deltaTime意味着它会按照每秒多少米的速度移动而不是每帧多少米，可以使移动更流畅，因为每一帧的时间不是固定的，而deltatime可以让其在固定的时间内移动，这样可以让我们更改每秒的速度而不是每帧的速度<br/> （2）前后移动可以用transform.translate(±vector3.forward<em>Speed</em>Time.deltaTime)；<br/> （3）左右旋转可以用transform.Rotate(±Vector3.up,turnSpeed*Time.deltaTime);</p>\n<p><strong>【LookAt】</strong><br/> （1）transform.LookAt(target);可用于让游戏的正向指向世界中的另一个transform【若将改脚本应用于摄像机，则可以实现摄像机跟踪物体的效果】</p>\n<p><strong>【Destroy】</strong><br/> （1）Destroy(GetComponent());可用于移除组件<br/> （2）创建延时：Destroy(XXX,3f);<em>【3f作为另一个参数，则将会延时3秒后移除对象】</em></p>\n<p><strong>【GetButton和GetKey】【返回布尔值】</strong><br/> （1）当持续按下按钮或松开按钮时，GetButtonDown和GetButtonUp都只在第一帧时返回结果true，到第二帧时就会返回默认的false<br/> （2）GetButton可以检测持续按下的按钮，一直返回true，直到松开才返回false</p>\n<p><strong>【GetAxis返回浮点值，值介于-1到1之间】，【GetAxisRaw返回-1，0，1整数】</strong><br/> （1）Unity的input设置中的gravity决定归零速度的快慢，越高则归零速度越快<br/> （2）Unity的input设置中的Sensitivity控制着输入的返回值到达1或-1的速度有多块，值越大，反应速度就越快，越小，则移动越流畅<br/> （3)若使用操纵杆控制时，Unity的input设置中的Dead盲区可以避免操纵杆轻微移动造成的影响，Dead值越大，盲区越大，操纵杆的移动幅度也就越大<br/> （4）Unity的input设置中的Snap的作用是同时按下正负按钮时归零</p>\n<p><strong>【GetComponent】</strong><br/> （1）对其他脚本的引用就是以脚本名称为类型的变量：private AnotherScript script；，而在下面还需要在Awake函数中进行变量初始化：AnotherScript=GetComponent();<em>【尖括号的作用是让类型成为参数，GetComponent会返回调用它的游戏对象中任意指定类型组件的引用】【注意：相互引用脚本只能在同个gameobject（物体对象）中引用，想要跨对象引用只能通过设置公共类型后拖拽另一个物体进去后才能引用】</em></p>\n<p><strong>【instantiate】</strong><br/> （1）用于克隆游戏对象，也就是对象实例化</p>\n<p><strong>【Invoke】</strong><br/> （1）将函数调用安排在指定延迟后发生：Invoke(“generateobject”,2);<em>【由两部分组成，generateobject是一个字符串，用于输入我们想要调用的方法名称，另一个数字2是以秒为单位的延时时长，则它会在两秒后才会调用generateobject方法】</em><br/> （2）注意：只有不包含参数且返回值为void的方法才能被Invoke调用：void generateobject(){}</p>\n<p><strong>【InvokeRepeating】</strong><br/> （1）InvokeRepeating(“geneobject”,2,1);<em>【由三部分组成，geneobject是我们想调用的方法名称，2是调用方法的延时，1是后续方法调用的延时，也就是刚开始先延时两秒调用后，每过一秒重新调用一次】</em><br/> （2）停止的方法：CancelInvoke(“geneobject”);<em>【输入一个字符串，，其中包含我们想要暂停的方法名称】</em></p>\n<p><strong>【枚举】</strong><br/> （1）enum，这是一种特殊的数据类型，有特定的子集；枚举也可以在一个class类内或类外创建，也可以单独创建只包含枚举的c#脚本，然后就可以在其他的脚本中使用它<br/> （2）例：enum Direction{North, East ,South ,West};<em>【用于表示方位，注意！枚举类型的花括号结尾需要加上分号；而这个枚举中声明的每个常量都有一个默认的值，从0开始往上数的整数，因此North的值为0，West的值为3】</em><br/> （3）同时也可以声明枚举的规定：enum Direction {North=12, East=14 ,South=22 ,West=28};以此类推<br/> （4）也可以更改枚举中的常量类型，常量可以更改为任意整数类型，如需要更改，则在枚举名称后添加一个冒号，然后在后面输入类型即可，例如更改为短整型：enum Direction : short{North, East ,South ,West};<br/> （5）声明好枚举后，接着设定枚举类型的变量：Direction dir; ，之后为变量赋值：dir=Direction.North等等枚举中的常量</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-14 14:31:06", "summary": "以下笔记和示例内容是基于目前自学总结的经验以及观看教学视频的结论和示例，仅记录了较为常用且自认为不好记的方法和小技巧，内容暂时不全待我后期学习慢慢完善，用于学习记录，内容仅作参考，如有错误还请帮忙指正"}