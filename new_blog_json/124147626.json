{"blogid": "124147626", "writerAge": "码龄14年", "writerBlogNum": "15", "writerCollect": "2", "writerComment": "0", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "161", "writerName": "DarcyZ_SSM", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124147626.jpg", "writerRankTotal": "112871", "writerRankWeekly": "152894", "writerThumb": "1", "writerVisitNum": "6719", "blog_read_count": "1564", "blog_time": "已于 2022-04-15 15:01:22 修改", "blog_title": "Rust基础-错误处理-自定义错误之一", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>先说最简单的Rust自定义错误。本文基于Rust1.59。</p>\n<p>实现一个最基本的自定义错误只需要实现下面两个trait，这两个都是关于把错误信息输出的。</p>\n<ul><li>手动实现impl std::fmt::Debug的trait，一般直接添加注解即可：#[derive(Debug)]</li><li>手动实现impl std::fmt::Display的trait,，用于自定义输出错误文本信息。</li></ul>\n<p>Talk is cheap show the code:</p>\n<pre><code class=\"language-rust\">use std::fmt;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match &amp;self.kind as &amp;str {\n            \"404\" =&gt; write!(f,\"程序出错:{<!-- -->{错误类型: {}, 错误原因: {}}}\",self.kind, self.message),\n            _ =&gt; write!(f,\"Sorry, something is wrong! Please Try Again!\"),\n        }\n    }\n}\n\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        kind: String::from(\"404\"),\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main()\n {\n    match produce_error(){\n       Err(err) =&gt; println!(\"{}\",err),\n       _ =&gt; println!(\"No error\"),\n  }\n  Ok(())\n}\n</code></pre>\n<p>输出 ：</p>\n<p><img alt=\"\" height=\"76\" src=\"..\\..\\static\\image\\234077e1d76a4450b7e75a1c8af49e42.png\" width=\"564\"/></p>\n<p> 解释：</p>\n<p>先定义一个自定义错误类型的Struct，然后为这个Struct实现Display Trait，就是怎么输出的问题。</p>\n<p>代码没什么好说的。但问题来了</p>\n<p><strong>问题1：</strong> println!(\"{}\",err)，但为什么不是<code>{:?} 或 {:#?}那种(</code>pretty-print<code>)把err结构打印出来?</code></p>\n<p>解决方法1：导入Debug</p>\n<pre><code class=\"language-rust\">#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}</code></pre>\n<p>输出：</p>\n<p><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\0cdf5da0bdac4e84bba4606e7a9a55bb.png\" width=\"464\"/></p>\n<p>还是不满意？</p>\n<p>解决方法2：把#[derive(Debug)]去掉，换自己的</p>\n<pre><code class=\"language-rust\">impl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(\n            f,\n            \"AppError {<!-- -->{ 错误类型1: {}, 错误原因1: {} }}\",\n            self.kind, self.message\n        )\n    }\n}</code></pre>\n<p>输出：</p>\n<p><img alt=\"\" height=\"67\" src=\"..\\..\\static\\image\\0ccc2ba3db904f228f94834bc52143fe.png\" width=\"541\"/></p>\n<p>完美。</p>\n<p>解决问题1的完整代码如下</p>\n<pre><code class=\"language-rust\">use std::fmt;\n//#[derive(Debug)]   //要使用默认Debug trait则把自定义的部分去掉\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match &amp;self.kind as &amp;str {\n            \"404\" =&gt; write!(f,\"程序出错:{<!-- -->{错误类型: {}, 错误原因: {}}}\",self.kind, self.message),\n            _ =&gt; write!(f,\"Sorry, something is wrong! Please Try Again!\"),\n        }\n    }\n}\nimpl fmt::Debug for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(\n            f,\n            \"AppError {<!-- -->{ 错误类型1: {}, 错误原因1: {} }}\",\n            self.kind, self.message\n        )\n    }\n}\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        kind: String::from(\"404\"),\n        message: String::from(\"Page not found\"),\n    })\n}\nfn main() {\n    match produce_error(){\n        Err(err) =&gt; println!(\"{:#?}\",err),\n        _ =&gt; println!(\"No error\"),\n    }\n}\n</code></pre>\n<p></p>\n<p> 但又有问题了，</p>\n<p><strong>问题2：</strong>如果类似IO，Parse之类的系统错误怎么办？</p>\n<p>先上代码：</p>\n<pre><code class=\"language-rust\">use std::fs::File;\nuse std::io::{self, Read};\nuse std::{num, error};\nuse std::fmt;\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match &amp;self.kind as &amp;str {\n            \"404\" =&gt; write!(\n                f,\n                \"程序出错:{<!-- -->{错误类型: {}, 错误原因: {}}}\",\n                self.kind, self.message\n            ),\n            _ =&gt; write!(f, \"Sorry, something is wrong! Please Try Again!\"),\n        }\n    }\n}\n//为AppError实现From::from&lt;io::Error&gt;的trait，这样AppError就能接住io::Error类型的error\nimpl From&lt;io::Error&gt; for AppError {\n    fn from(error: io::Error) -&gt; Self {\n        AppError {\n            kind: String::from(\"io_error\"),\n            message: error.to_string(),\n        }\n    }\n}\n//为AppError实现From::from&lt;num::ParseIntError&gt;的trait\nimpl From&lt;num::ParseIntError&gt; for AppError {\n    fn from(error: num::ParseIntError) -&gt; Self {\n        AppError {\n            kind: String::from(\"parse_error\"),\n            message: error.to_string(),\n        }\n    }\n}\nfn produce_error() -&gt; Result&lt;(), AppError&gt; {\n    Err(AppError {\n        kind: String::from(\"404\"),\n        message: String::from(\"Page not found\"),\n    })\n}\n\nfn main() {\n    match produce_error(){\n        Err(err) =&gt; println!(\"{:#?}\",err),\n        _ =&gt; println!(\"No error\"),\n    }\n     let mut content = String::new();\n    match File::open(\"aaa.txt\") {\n        Err(err) =&gt; {\n            let er:AppError= std::convert::From::from(err);//调用From&lt;io::Error&gt;\n            println!(\"{:#?}\", er);\n        }\n        Ok(mut e) =&gt; {\n            match e.read_to_string(&amp;mut content) {\n                Err(err) =&gt; println!(\"{:#?}\", err),\n                Ok(_) =&gt; {\n                    let number: usize = match content.parse() {\n                        Ok(num) =&gt; {\n                            println!(\"double num is:{}\",num*2);\n                            num\n                        },\n                        Err(err) =&gt; {\n                            let er:AppError= std::convert::From::from(err);//调用From&lt;num::ParseIntError&gt;\n                            println!(\"{:#?}\", er);\n                            0\n                        }\n                    };\n                },\n            };\n        }\n    };\n}</code></pre>\n<p>为了让AppError\"接住\"io::Error和num::ParseIntError这样的系统错误，需要为AppError实现From&lt;T&gt;，那么当程序遇到io::Error时，通过match-&gt;Err(e)接住这个错误。所以定义了两个Trait</p>\n<p>1、<strong>impl From&lt;io::Error&gt; for AppError</strong></p>\n<p>2、<strong>impl From&lt;num::ParseIntError&gt; for AppError</strong></p>\n<p>另外要实现上面match的操作输出自定义的AppError，就要让io::Error转换为AppError，否则就会输出默认的Error信息，那么就要<strong> let er:AppError= std::convert::From::from(err)</strong>这样转换，这样就把AppError给“挂”上去了。</p>\n<p>试一下：当把文件名改为abc.txt这个不存在的文件后，结果如下：</p>\n<p><img alt=\"\" height=\"155\" src=\"..\\..\\static\\image\\e7abf8fab7f3447385346cfaf0396d30.png\" width=\"775\"/></p>\n<p>但存在2个问题</p>\n<p>1、match的嵌套太销魂了。</p>\n<p>2、error的返回每次都要转换，无法标准化。</p>\n<p>下一篇介绍如何标准化自定义错误。</p>\n<p>相关文章：</p>\n<p><a href=\"https://blog.csdn.net/DarcyZ_SSM/article/details/124167965\" title=\"Rust基础-错误处理-自定义错误之二_DarcyZ_SSM的博客-CSDN博客\">Rust基础-错误处理-自定义错误之二_DarcyZ_SSM的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/DarcyZ_SSM/article/details/124193534\" title=\"Rust基础-错误处理-自定义错误之三-snafu方案_DarcyZ_SSM的博客-CSDN博客\">Rust基础-错误处理-自定义错误之三-snafu方案_DarcyZ_SSM的博客-CSDN博客</a> </p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-15 15:01:22", "summary": "先说最简单的自定义错误。本文基于。实现一个最基本的自定义错误只需要实现下面两个，这两个都是关于把错误信息输出的。手动实现的，一般直接添加注解即可：手动实现的，用于自定义输出错误文本信息。程序出错错误类"}