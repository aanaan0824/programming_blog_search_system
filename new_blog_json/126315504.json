{"blogid": "126315504", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5474", "writerComment": "4194", "writerFan": "7302", "writerGrade": "7级", "writerIntegral": "13155", "writerName": "三分苦", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126315504.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4504", "writerVisitNum": "116737", "blog_read_count": "160", "blog_time": "于 2022-09-04 20:38:55 发布", "blog_title": "【 C++ 】红黑树", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">1、红黑树的概念</a></p>\n<p id=\"2%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\">2、红黑树的性质</a></p>\n<p id=\"3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89\">3、红黑树节点的定义</a></p>\n<p id=\"4%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84\">4、红黑树结构</a></p>\n<p id=\"5%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:80px;\"><a href=\"#5%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\">5、红黑树的插入操作</a></p>\n<p id=\"6%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81-toc\" style=\"margin-left:80px;\"><a href=\"#6%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81\">6、红黑树的验证</a></p>\n<p id=\"7%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:80px;\"><a href=\"#7%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4\">7、红黑树的删除</a></p>\n<p id=\"8%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:80px;\"><a href=\"#8%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83\">8、红黑树与AVL树的比较</a></p>\n<p id=\"9%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#9%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">9、红黑树的应用</a></p>\n<p id=\"10%E3%80%81%E6%BA%90%E7%A0%81%E9%93%BE%E6%8E%A5-toc\" style=\"margin-left:80px;\"><a href=\"#10%E3%80%81%E6%BA%90%E7%A0%81%E9%93%BE%E6%8E%A5\">10、源码链接</a></p>\n<hr/>\n<h3>1、红黑树的概念</h3>\n<blockquote>\n<p>红黑树，是一种<span style=\"color:#956fe7;\">二叉搜索树</span>，但在每个结点上增加一个存储位表示结点的颜色，可以是<span style=\"color:#fe2c24;\">Red</span>或<span style=\"color:#fe2c24;\">Black</span>。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保<span style=\"color:#fe2c24;\">没有一条路径会比其他路径长出俩倍</span><span style=\"color:#0d0016;\">（</span><span style=\"color:#956fe7;\">最长路径不超过最短路径的2倍</span><span style=\"color:#0d0016;\">）</span>，因而是<span style=\"color:#fe2c24;\">接近平衡</span>的。</p>\n<p><img alt=\"\" height=\"282\" src=\"..\\..\\static\\image\\4af5017ef29d428c9057f3439d7e6df6.png\" width=\"641\"/></p>\n<p>同是二叉搜索平衡树，但是<span style=\"color:#956fe7;\">AVL树控制的比红黑树严格的多</span>，AVL树要是每个节点的平衡因子绝对值不超过1，就会导致不断的去旋转调整，付出相对较高的代价，而这里红黑树更像是一种近似平衡，条件没有这么苛刻。</p>\n<p>如下一棵树，站在红黑树的角度看是平衡的，站在AVL树的角度看就是不平衡的，需要旋转调整：</p>\n<p><img alt=\"\" height=\"199\" src=\"..\\..\\static\\image\\dc029d8c0507475b800c78135153958c.png\" width=\"492\"/></p>\n<p>但是从搜索效率的角度看<span style=\"color:#956fe7;\">AVL树还是好一点</span>，因为它的<span style=\"color:#956fe7;\">平衡标准高</span>，就导致其更加平衡，相同数量的节点情况下AVL树的高度会更低，加上存100w个数据，AVL树大概有20层（log100w），而红黑树最坏就能达到40层，显然AVL树的搜索效率高。但是在内存里找20次和找40次没有什么区别，因为CPU足够的快，这里简单提一下。</p>\n</blockquote>\n<hr/>\n<h3 id=\"2%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\">2、红黑树的性质</h3>\n<blockquote>\n<ul><li>1、每个结点不是红色就是黑色</li><li>2、<span style=\"color:#fe2c24;\">根节点必须是黑色的</span></li><li>3、如果一个节点是红色的，则它的两个孩子结点是黑色的（<span style=\"color:#fe2c24;\">没有连续的红色节点</span>）</li><li>4、对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<span style=\"color:#fe2c24;\">每条路径都包含相同数量的黑色节点</span>）</li><li>5、每个叶子结点都是黑色的(此处的叶子结点指的是<span style=\"color:#fe2c24;\">空结点 </span><span style=\"color:#0d0016;\">-》</span><span style=\"color:#956fe7;\">NIL节点</span>)</li></ul>\n<p><span style=\"color:#956fe7;\"><strong>根据这些规则，红黑树是如何保证最长路径不超过最短路径的2倍的呢？</strong></span></p>\n<p>首先我们根据规则分析得知，我们假设一条路径的黑色节点的个数为N个，则最长路径和最短路径的情况如下：</p>\n<ul><li>最短路径：<span style=\"color:#fe2c24;\">全黑</span></li></ul>\n<p><img alt=\"\" height=\"185\" src=\"..\\..\\static\\image\\e1d3a4f27334493ea1eea5c5263f030a.png\" width=\"514\"/></p>\n<ul><li>最长路径：<span style=\"color:#fe2c24;\">一黑一红间隔</span></li></ul>\n<p><img alt=\"\" height=\"408\" src=\"..\\..\\static\\image\\805cf66398854de196e5dde040110ff7.png\" width=\"592\"/></p>\n<p>而这里一黑一红间隔的原因在于红黑树不允许出现连续的红节点，为了能最大程度的保证最长节点数，唯有一黑一红间隔的方式才能达到最长，综上当黑节点个数固定为N时，最短路径节点个数为N，最长路径节点个数为2N</p>\n</blockquote>\n<hr/>\n<h3 id=\"3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89\">3、红黑树节点的定义</h3>\n<blockquote>\n<p>这里节点的实现相较于AVL树我们依旧是创建成<span style=\"color:#956fe7;\">KV模型</span>、<span style=\"color:#956fe7;\">三叉链结构</span>，唯一有所改变的是这里要通过枚举的方式把红色和黑色定义好，并在节点类内部定义变量_col表示<span style=\"color:#956fe7;\">节点颜色</span>，最后记得写上<span style=\"color:#956fe7;\">构造函数</span>。</p>\n<pre><code class=\"language-cpp\">enum Colour\n{\n\tRed,\n\tBlack,\n};\n//节点类\ntemplate &lt;class K, class V&gt;\nstruct RBTreeNode\n{\n\t//三叉链结构\n\tRBTreeNode&lt;K, V&gt;* _left;\n\tRBTreeNode&lt;K, V&gt;* _right;\n\tRBTreeNode&lt;K, V&gt;* _parent;\n\t//存储的键值对\n\tpair&lt;K, V&gt; _kv;\n\t//节点的颜色\n\tColour _col;\n\t//构造函数\n\tRBTreeNode(const pair&lt;K, V&gt;&amp; kv)\n\t\t:_left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t\t, _kv(kv)\n\t\t, _col(Red)\n\t{}\n};</code></pre>\n<p><span style=\"color:#956fe7;\"><strong>为什么插入的节点在构造函数这里要处理成红色？</strong></span></p>\n<ul><li>如果处理成黑色，则一定导致新插入节点的那条路径多出一个黑色节点，不再满足各个路径黑色节点个数相同的性质，一定破坏性质4，此时很难维护。</li><li>如果处理成红色，则可能父亲节点也是红色，此时就出现了连续的红色节点，破坏性质3，不过此时我们向上调整即可，但如果父亲节点是黑色，那就无需操作了，不违反任何性质。</li></ul>\n<p>综合利弊，插入黑色节点<span style=\"color:#fe2c24;\">一定</span>会破坏性质4，而插入红色节点<span style=\"color:#fe2c24;\">可能</span>破坏性质3，因此处理成红色为宜。</p>\n</blockquote>\n<hr/>\n<h3 id=\"4%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84\">4、红黑树类的基本框架</h3>\n<blockquote>\n<p>此模板类主要是用于红黑树的插入、旋转、调整、验证等等操作，基本框架如下：</p>\n<pre><code class=\"language-cpp\">//红黑树的类\ntemplate &lt;class K, class V&gt;\nclass RBTree\n{\n\ttypedef RBTreeNode&lt;K, V&gt; Node;\npublic:\n    //……\nprivate:\n\tNode* _root = nullptr;\n};</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"5%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\">5、红黑树的插入操作</h3>\n<blockquote>\n<p>红黑树的插入操作主要分为这几大步骤：</p>\n<ul><li>1、一开始为空树，直接new新节点</li><li>2、一开始非空树，寻找插入的合适位置</li><li>3、找到插入的合适位置后，进行父亲与孩子的双向链接</li><li>4、检测新节点插入后，红黑树的性质是否造到破坏</li></ul>\n<p>接下来对其进行逐个分析：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、一开始为空树，直接new新节点：</span></li></ul>\n<p>因为树为空的，所以直接new一个新插入的节点，将其作为根_root即可，接着更新颜色_col为黑色。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、一开始非空树，寻找插入的合适位置：</span></li></ul>\n<p>这里和二叉搜索树的寻找合适的插入位置的思想一样，都要遵循以下几步：</p>\n<ol><li>插入的值 &gt; 节点的值，更新到右子树查找</li><li>插入的值 &lt; 节点的值，更新到左子树查找</li><li>插入的值 = 节点的值，数据冗余插入失败，返回false</li></ol>\n<p>当循环结束的时候，就说明已经找到插入的合适位置，即可进行下一步链接。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">3、找到插入的合适位置后，进行父亲与孩子的双向链接：</span></li></ul>\n<p>注意这里节点的构成为三叉链，因此最后链接后端孩子和父亲是双向链接，具体操作如下：</p>\n<ol><li>插入的值 &gt; 父亲的值，把插入的值链接在父亲的右边</li><li>插入的值 &lt; 父亲的值，把插入的值链接在父亲的左边</li><li>因为是三叉连，插入后记得双向链接（孩子链接父亲）</li></ol>\n<p>走到这，说明节点已经插入完毕，接下来就要对红黑树的颜色进行调整了</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">4、检测新节点插入后，红黑树的性质是否造到破坏：</span></li></ul>\n<p>不是所有的情况都是需要进行调整的，当插入节点的父亲为黑色（新节点的默认颜色是红色），那么就不需要进行调整，因为没有破坏红黑树的任何一条性质。</p>\n<p>只有当插入节点的父亲为红色时（新节点的默认颜色也是是红色），才需要进行调整，因为此时插入的节点和父亲都是红色节点，但是红黑树不允许出现连续的红色节点，此时就要进行调整。</p>\n<p>注意这里既然插入节点cur的父亲p是红色，那么根据红黑树的性质（根结点是黑色的），其父亲的父亲g也就是祖父必然存在且一定是黑色，那么其父亲的兄弟节点u（可能不存在）也就是新插入节点cur的叔叔。因此我们约定：<span style=\"color:#fe2c24;\">cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点</span><span style=\"color:#494949;\">。</span></p>\n<p><img alt=\"\" height=\"248\" src=\"..\\..\\static\\image\\e227e85b9a7f4fe9a25b7d5e875a884a.png\" width=\"472\"/></p>\n<p><span style=\"color:#494949;\">这里调整的办法主要是看叔叔节点的颜色如何，叔叔节点的不同，会导致三种不同的情况需要调整：</span></p>\n<ul><li>情况一：cur为红，p为红，g为黑，<span style=\"color:#fe2c24;\">u存在且为红</span></li><li>情况二：cur为红，p为红，g为黑，<span style=\"color:#956fe7;\">u不存在</span></li><li>情况三：cur为红，p为红，g为黑，<span style=\"color:#fe2c24;\">u存在且为黑</span></li></ul>\n<p>接下来分别进行讨论：</p>\n<ul><li><span style=\"background-color:#edf6e8;\">情况一：cur为红，p为红，g为黑，u存在且为红</span></li></ul>\n<p>为了避免出现连续的红色节点，我们可以把父节点p变黑，但是为了保证每条路径的黑色节点个数相同，我们需要把祖父节g点变红（不影响其它路径黑节点的个数），再把叔叔节点u变黑。</p>\n<p><img alt=\"\" height=\"210\" src=\"..\\..\\static\\image\\d601659faa834bc6ae98acabaa25fc92.png\" width=\"609\"/></p>\n<p>调整并未结束，此时祖父节点g为红色，但是<span style=\"color:#fe2c24;\">如果这棵树本就是一颗完整的树呢</span>？也就是g为根节点，那么<span style=\"color:#956fe7;\">只需要把节点g变成黑色</span>即可。</p>\n<p><span style=\"color:#fe2c24;\">如果这棵树是一棵树的子树</span>，那么刚好<span style=\"color:#956fe7;\">把祖父节点g作为新插入的节点cur向上继续调整</span>（继续判断父亲、叔叔如何……），直至调整结束。</p>\n<p><img alt=\"\" height=\"282\" src=\"..\\..\\static\\image\\718a417fdd404e51bf18686cf00aced1.png\" width=\"670\"/></p>\n<ul><li>补充<strong>：</strong>情况一<span style=\"color:#956fe7;\">不关心左右关系</span>，<span style=\"color:#956fe7;\">只变色不旋转</span>，所以<span style=\"color:#494949;\"> p、u是g的左或右是无所谓的，cur是p的左或右也是无所谓的。</span></li></ul>\n<p><span style=\"color:#494949;\">接下来分析情况2：</span></p>\n<p></p>\n<ul><li><span style=\"background-color:#edf6e8;\">情况二：cur为红，p为红，g为黑，u不存在</span></li></ul>\n<p><img alt=\"\" height=\"195\" src=\"..\\..\\static\\image\\fe97dfc91de34038b44a450d8a4a4e1f.png\" width=\"494\"/></p>\n<p>如果节点u不存在，则cur一定是新插入节点，因为如果cur不是新插入节点，则cur和p一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。</p>\n<p>此时就是一个很经典的<span style=\"color:#fe2c24;\">右单旋</span>结构（<span style=\"color:#956fe7;\">新节点插入较高左子树的左侧</span>）我们可以先对其进行一个右单旋，<span style=\"color:#fe2c24;\">再来更新颜色</span>。具体步骤如下：</p>\n<ol><li>让祖父g变成父亲p的右子树</li><li>父亲p作为根节点</li><li>更新父亲节点p为黑色</li><li>更新祖父g为红色</li></ol>\n<p><img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\4367a4a80fcc4538b9ee769628c553ef.png\" width=\"610\"/></p>\n<ul><li><strong>补充：</strong></li></ul>\n<p>如若p为g的右孩子，cur为p的右孩子，则针对p做左单旋转，示例：</p>\n<p><img alt=\"\" height=\"148\" src=\"..\\..\\static\\image\\f222c4d1a0bb464a931cf207deb7f554.png\" width=\"608\"/></p>\n<p>如若祖孙三代的关系是<span style=\"color:#956fe7;\">折线</span>（cur、parent、grandfather这三个结点为一条折现），则我们需要先进行<span style=\"color:#fe2c24;\">双旋操作</span>，再进行<span style=\"color:#fe2c24;\">颜色调整</span>，颜色调整后这棵被旋转子树的根是黑色的，因此无需继续往上进行处理。示例：</p>\n<p><img alt=\"\" height=\"334\" src=\"..\\..\\static\\image\\fb459798fe03471c87a5c6ab5374dff0.png\" width=\"473\"/></p>\n<p>综上：</p>\n<ol><li>p为g的左，cur为p的左，则进行<span style=\"color:#956fe7;\">右单旋</span> + p变黑，g变红</li><li>p为g的右，cur为p的右，则进行<span style=\"color:#956fe7;\">左单旋 </span>+ p变黑，g变红</li><li>p是g的左，cur是p的右，则进行<span style=\"color:#fe2c24;\">左右双旋</span> + cur变黑， g变红</li><li>p是g的右，cur是p的左，则进行<span style=\"color:#fe2c24;\">右左双旋</span> + cur变黑， g变红</li></ol>\n<p>下面进入情况三</p>\n<ul><li><span style=\"background-color:#edf6e8;\">情况三：cur为红，p为红，g为黑，</span><span style=\"color:#0d0016;\"><span style=\"background-color:#edf6e8;\">u存在且为黑</span></span></li></ul>\n<p>此情况<span style=\"color:#956fe7;\">绝非单独存在</span>，绝不可能是真的新节点cur插入，然后还会出现p为红，g为黑，<span style=\"color:#494949;\">u存在且为黑的情况，如果存在，那么只能说明先前插入节点或者构造函数就有问题，因为</span><span style=\"color:#956fe7;\">插入前就不符合红黑树的性质</span><span style=\"color:#494949;\">啊（</span><span style=\"color:#fe2c24;\">每个路径的黑节点个数均相同</span><span style=\"color:#494949;\">）</span></p>\n<p><span style=\"color:#494949;\">既然情况三出现了，那么一定是合理的，它就是建立在情况一的基础上继续往上调整从而出现的一种特殊情况，具体咱就是画图演示：</span></p>\n<p><img alt=\"\" height=\"311\" src=\"..\\..\\static\\image\\d89085794b164623982acbdc518e1c42.png\" width=\"896\"/></p>\n<p>此时就是很明显的一个情况3了，cur为红，pp为红，gg为黑，u存在且为黑，由此证明，<span style=\"color:#956fe7;\">情况三是通过情况一向上继续调整演化出来的</span>。并且此新节点一定是从p和x任意一颗左右子树插入或演化上来的，才引发后续的cur从黑变红。</p>\n<p>此时就是一个很经典的<span style=\"color:#fe2c24;\">右单旋</span>结构（<span style=\"color:#956fe7;\">cur在较高左子树的左侧</span>）我们可以先对其进行一个右单旋，<span style=\"color:#fe2c24;\">再来更新颜色</span>。具体步骤如下：</p>\n<ol><li>让p的右子树变成g的左子树</li><li>让p变成根节点位置</li><li>p的右子树指向g</li><li>更新p的颜色为黑色</li><li>更新g的颜色为红色</li></ol>\n<p><img alt=\"\" height=\"307\" src=\"..\\..\\static\\image\\332cfa3d7fdd42aca08b2944bed7a8f0.png\" width=\"1065\"/></p>\n<ul><li><strong>补充：</strong></li></ul>\n<p>如若p为g的右孩子，cur为p的右孩子，则进行左单旋 + 调色，示例：</p>\n<p><img alt=\"\" height=\"532\" src=\"..\\..\\static\\image\\361bb0cbe2634f1395e50e9b764d1bc2.png\" width=\"752\"/></p>\n<p>若祖孙三代的关系是折现（cur、parent、grandfather这三个结点为一条<span style=\"color:#956fe7;\">折线</span>），则我们需要先进行<span style=\"color:#fe2c24;\">双旋操作</span>，再进行<span style=\"color:#fe2c24;\">颜色调整</span>，颜色调整后这棵被旋转子树的根是黑色的，因此<span style=\"color:#956fe7;\">无需继续往上进行处理</span>。示例：</p>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\1a378bda5f5941d3936c29840004c45d.png\" width=\"601\"/></p>\n<p>综上：</p>\n<ol><li>p为g的左，cur为p的左，则进行<span style=\"color:#956fe7;\">右单旋</span> + p变黑，g变红</li><li>p为g的右，cur为p的右，则进行<span style=\"color:#956fe7;\">左单旋</span> + p变黑，g变红</li><li>p是g的左，cur是p的右，则进行<span style=\"color:#fe2c24;\">左右双旋</span> + cur变黑， g变红</li><li>p是g的右，cur是p的左，则进行<span style=\"color:#fe2c24;\">右左双旋</span> + cur变黑， g变红</li></ol>\n<p>情况二和情况三旋转 + 变色后，这颗子树不违反红黑树规则，相比插入前，且黑色节点的数量不变，不会影响上层，处理结束了。</p>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">bool Insert(const pair&lt;K, V&gt;&amp; kv)\n{\n\t//1、一开始为空树，直接new新节点\n\tif (_root == nullptr)\n\t{\n\t\t_root = new Node(kv);\n\t\t_root-&gt;_col = Black;//新插入的节点处理成黑色\n\t\treturn true;\n\t}\n\t//2、寻找插入的合适位置\n\tNode* cur = _root;\n\tNode* parent = nullptr;\n\twhile (cur)\n\t{\n\t\tif (cur-&gt;_kv.first &lt; kv.first)\n\t\t{\n\t\t\tparent = cur;\n\t\t\tcur = cur-&gt;_right;//插入的值 &gt; 节点的值，更新到右子树查找\n\t\t}\n\t\telse if (cur-&gt;_kv.first &gt; kv.first)\n\t\t{\n\t\t\tparent = cur;\n\t\t\tcur = cur-&gt;_left;//插入的值 &lt; 节点的值，更新到左子树查找\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;//插入的值 = 节点的值，数据冗余插入失败，返回false\n\t\t}\n\t}\n\t//3、找到了插入的位置，进行父亲与插入节点的链接\n\tcur = new Node(kv);\n\tcur-&gt;_col = Red;//插入的节点处理成红色\n\tif (parent-&gt;_kv.first &lt; kv.first)\n\t{\n\t\tparent-&gt;_right = cur;//插入的值 &gt; 父亲的值，链接在父亲的右边\n\t}\n\telse\n\t{\n\t\tparent-&gt;_left = cur;//插入的值 &lt; 父亲的值，链接在父亲的左边\n\t}\n\tcur-&gt;_parent = parent;//三叉链，要双向链接\n\n//4、检测新节点插入后，红黑树的性质是否造到破坏\n\twhile (parent &amp;&amp; parent-&gt;_col == Red)//存在连续的红色节点\n\t{\n\t\tNode* grandfather = parent-&gt;_parent;\n\t\tassert(grandfather);\n\t\t//先确保叔叔的位置\n\t\tif (grandfather-&gt;_left == parent)\n\t\t{\n\t\t\tNode* uncle = grandfather-&gt;_right;\n\t\t\t//情况一：cur为红，p为红，g为黑，u存在且为红\n\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == Red)\n\t\t\t{\n\t\t\t\t//变色\n\t\t\t\tparent-&gt;_col = uncle-&gt;_col = Black;\n\t\t\t\tgrandfather-&gt;_col = Red;\n\t\t\t\t//继续往上处理\n\t\t\t\tcur = grandfather;\n\t\t\t\tparent = cur-&gt;_parent;\n\t\t\t}\n\t\t\t//情况二+情况三：叔叔不存在，或者叔叔存在且为黑\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cur == parent-&gt;_left)//p为g的左，cur为p的左，则进行右单旋 + p变黑，g变红\n\t\t\t\t{\n\t\t\t\t\t//\t\t  g\n\t\t\t\t\t//     p\n\t\t\t\t\t// cur\n\t\t\t\t\tRotateR(grandfather);\n\t\t\t\t\tparent-&gt;_col = Black;\n\t\t\t\t\tgrandfather-&gt;_col = Red;\n\t\t\t\t}\n\t\t\t\telse//p是g的左，cur是p的右，则进行左右双旋 + cur变黑， g变红\n\t\t\t\t{\n\t\t\t\t\t//\t\t  g\n\t\t\t\t\t//\t p\n\t\t\t\t\t//\t     cur\n\t\t\t\t\tRotateLR(grandfather);\n\t\t\t\t\tcur-&gt;_col = Black;\n\t\t\t\t\tgrandfather-&gt;_col = Red;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse//grandfather-&gt;_right == parent\n\t\t{\n\t\t\tNode* uncle = grandfather-&gt;_left;\n\t\t\t//情况一：cur为红，p为红，g为黑，u存在且为红\n\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == Red)\n\t\t\t{\n\t\t\t\t//变色\n\t\t\t\tparent-&gt;_col = uncle-&gt;_col = Black;\n\t\t\t\tgrandfather-&gt;_col = Red;\n\t\t\t\t//继续往上处理\n\t\t\t\tcur = grandfather;\n\t\t\t\tparent = cur-&gt;_parent;\n\t\t\t}\n\t\t\t//情况二+情况三：叔叔不存在，或者叔叔存在且为黑\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cur == parent-&gt;_right)//p为g的右，cur为p的右，则进行左单旋 + p变黑，g变红\n\t\t\t\t{\n\t\t\t\t\t//\tg\n\t\t\t\t\t//\t   p\n\t\t\t\t\t//\t     cur\n\t\t\t\t\tRotateL(grandfather);\n\t\t\t\t\tparent-&gt;_col = Black;\n\t\t\t\t\tgrandfather-&gt;_col = Red;\n\t\t\t\t}\n\t\t\t\telse//p是g的右，cur是p的左，则进行右左双旋 + cur变黑， g变红\n\t\t\t\t{\n\t\t\t\t\t//   g\n\t\t\t\t\t//\t      p\n\t\t\t\t\t//\tcur\n\t\t\t\t\tRotateRL(grandfather);\n\t\t\t\t\tcur-&gt;_col = Black;\n\t\t\t\t\tgrandfather-&gt;_col = Red;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_root-&gt;_col = Black;//暴力处理把根变成黑色\n\treturn true;\n}\n//1、左单旋\nvoid RotateL(Node* parent)\n{\n\tNode* subR = parent-&gt;_right;\n\tNode* subRL = subR-&gt;_left;\n\tNode* ppNode = parent-&gt;_parent;//提前保持parent的父亲\n\t//1、建立parent和subRL之间的关系\n\tparent-&gt;_right = subRL;\n\tif (subRL)//防止subRL为空\n\t{\n\t\tsubRL-&gt;_parent = parent;\n\t}\n\t//2、建立subR和parent之间的关系\n\tsubR-&gt;_left = parent;\n\tparent-&gt;_parent = subR;\n\t//3、建立ppNode和subR之间的关系\n\tif (parent == _root)\n\t{\n\t\t_root = subR;\n\t\t_root-&gt;_parent = nullptr;\n\t}\n\telse\n\t{\n\t\tif (parent == ppNode-&gt;_left)\n\t\t{\n\t\t\tppNode-&gt;_left = subR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tppNode-&gt;_right = subR;\n\t\t}\n\t\tsubR-&gt;_parent = ppNode;//三叉链双向链接关系\n\t}\n}\n//2、右单旋\nvoid RotateR(Node* parent)\n{\n\tNode* subL = parent-&gt;_left;\n\tNode* subLR = subL-&gt;_right;\n\tNode* ppNode = parent-&gt;_parent;\n\t//1、建立parent和subLR之间的关系\n\tparent-&gt;_left = subLR;\n\tif (subLR)\n\t{\n\t\tsubLR-&gt;_parent = parent;\n\t}\n\t//2、建立subL和parent之间的关系\n\tsubL-&gt;_right = parent;\n\tparent-&gt;_parent = subL;\n\t//3、建立ppNode和subL的关系\n\tif (parent == _root)\n\t{\n\t\t_root = subL;\n\t\t_root-&gt;_parent = nullptr;\n\t}\n\telse\n\t{\n\t\tif (parent == ppNode-&gt;_left)\n\t\t{\n\t\t\tppNode-&gt;_left = subL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tppNode-&gt;_right = subL;\n\t\t}\n\t\tsubL-&gt;_parent = ppNode;//三叉链双向关系\n\t}\n}\n//3、左右双旋\nvoid RotateLR(Node* parent)\n{\n\tRotateL(parent-&gt;_left);\n\tRotateR(parent);\n}\n//4、右左双旋\nvoid RotateRL(Node* parent)\n{\n\tRotateR(parent-&gt;_right);\n\tRotateL(parent);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"6%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81\">6、红黑树的验证</h3>\n<blockquote>\n<p>红黑树的验证主要分为两大步骤：</p>\n<ul><li>1、检测其是否满足二叉搜索树(<span style=\"color:#fe2c24;\">中序遍历是否为有序序列</span>)</li><li>2、检测其是否满足<span style=\"color:#fe2c24;\">红黑树</span>的性质</li></ul>\n<p>接下来分别演示：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、检测其是否满足二叉搜索树(<span style=\"color:#0d0016;\">中序遍历是否为有序序列</span>)：</span></li></ul>\n<p>这里只需要递归写一个中序遍历，并判断测试用例的结果是否为一个有序序列即可判断二叉搜索树：</p>\n<pre><code class=\"language-cpp\">//验证是否为一颗搜索二叉树\nvoid InOrder()\n{\n\t_InOrder(_root);//调用中序遍历子树\n\tcout &lt;&lt; endl;\n}\n//中序遍历的子树\nvoid _InOrder(Node* root)\n{\n\tif (root == nullptr)\n\t\treturn;\n\t_InOrder(root-&gt;_left);\n\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; \" \";\n\t_InOrder(root-&gt;_right);\n}</code></pre>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、检测其是否满足</span><span style=\"color:#0d0016;\"><span style=\"background-color:#fbd4d0;\">红黑树</span></span><span style=\"background-color:#fbd4d0;\">的性质：</span></li></ul>\n<p>这里只要判断是否满足红黑树的5大规则即可，具体操作如下：</p>\n<ul><li>1、根节点是否为黑色</li><li>2、任意一条路径黑色节点数是否相同（递归每一条和确定的一条比较是否相同）</li><li>3、递归检测是否违反性质三从而出现连续的红节点</li></ul>\n<pre><code class=\"language-cpp\">bool IsBalanceTree()\n{\n\tNode* pRoot = _root;\n\t// 空树也是红黑树\n\tif (pRoot == nullptr)\n\t\treturn true;\n\t// 检测根节点是否满足情况\n\tif (pRoot-&gt;_col != Black)\n\t{\n\t\tcout &lt;&lt; \"违反红黑树性质二：根节点必须为黑色\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t// 获取任意一条路径中黑色节点的个数--&gt;拿最左路径作为比较基准值\n\tsize_t blackCount = 0;\n\tNode* pCur = pRoot;\n\twhile (pCur)\n\t{\n\t\tif (pCur-&gt;_col == Black)\n\t\t\tblackCount++;\n\t\tpCur = pCur-&gt;_left;\n\t}\n\t// 检测是否满足红黑树的性质，k用来记录路径中黑色节点的个数\n\tsize_t k = 0;\n\treturn _IsValidRBTree(pRoot, k, blackCount);\n}\nbool _IsValidRBTree(Node* pRoot, size_t k, const size_t blackCount)\n{\n\t//走到null之后，判断k和black是否相等\n\tif (pRoot == nullptr)\n\t{\n\t\tif (k != blackCount)\n\t\t{\n\t\t\tcout &lt;&lt; \"违反性质四：每条路径中黑色节点的个数必须相同\" &lt;&lt; endl;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t// 统计黑色节点的个数\n\tif (pRoot-&gt;_col == Black)\n\t\tk++;\n\t// 检测当前节点与其双亲是否都为红色\n\tNode* pParent = pRoot-&gt;_parent;\n\tif (pParent &amp;&amp; pParent-&gt;_col == Red &amp;&amp; pRoot-&gt;_col == Red)\n\t{\n\t\tcout &lt;&lt; \"违反性质三：没有连在一起的红色节点，而这里出现了\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\treturn _IsValidRBTree(pRoot-&gt;_left, k, blackCount) &amp;&amp; _IsValidRBTree(pRoot-&gt;_right, k, blackCount);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"7%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4\">7、红黑树的删除</h3>\n<blockquote>\n<p>红黑树的删除这里和AVL树一样就不做过多演示了，具体可参考《算法导论》或者《STL源码剖析》，也可参考此大佬的博文：<a class=\"link-info\" href=\"http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html\" title=\"红黑树的插入删除操作\">红黑树的插入删除操作</a></p>\n</blockquote>\n<hr/>\n<blockquote>\n<h3 id=\"8%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83\">8、红黑树与AVL树的比较</h3>\n</blockquote>\n<blockquote>\n<p>红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是<span style=\"color:#fe2c24;\">O(logN)</span>，红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。</p>\n</blockquote>\n<hr/>\n<h3 id=\"9%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">9、红黑树的应用</h3>\n<blockquote>\n<ul><li>1、C++ STL库 -- map/set、mutil_map/mutil_set</li><li>2、Java 库</li><li>3、linux内核</li><li>4、其他一些库</li></ul>\n</blockquote>\n<hr/>\n<h3 id=\"10%E3%80%81%E6%BA%90%E7%A0%81%E9%93%BE%E6%8E%A5\">10、源码链接</h3>\n<blockquote>\n<p>链接直达：<a class=\"link-info\" href=\"https://gitee.com/bit-zy/xzy--c/blob/master/RBTree/RBTree/RBTree.h\" title=\"红黑树的模拟实现完整版\">红黑树的模拟实现完整版</a></p>\n</blockquote>\n</div>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-04 20:38:55", "summary": "目录、红黑树的概念、红黑树的性质、红黑树节点的定义、红黑树结构、红黑树的插入操作、红黑树的验证、红黑树的删除、红黑树与树的比较、红黑树的应用、源码链接、红黑树的概念红黑树，是一种二叉搜索树，但在每个结"}