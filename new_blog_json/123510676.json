{"blogid": "123510676", "writerAge": "码龄1年", "writerBlogNum": "2", "writerCollect": "64", "writerComment": "0", "writerFan": "2", "writerGrade": "1级", "writerIntegral": "41", "writerName": "Mxxxx12", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123510676.jpg", "writerRankTotal": "194988", "writerRankWeekly": "92216", "writerThumb": "8", "writerVisitNum": "12433", "blog_read_count": "7875", "blog_time": "于 2022-03-15 19:57:38 发布", "blog_title": "粒子群优化算法（PSO）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"PSO_0\"></a>粒子群优化算法（PSO）</h1>\n<p>粒子群优化算法（PSO）是一种进化计算技术，源于对鸟群捕食行为的研究。该算法最初是受到飞鸟集群活动的规律性启发，进而利用群体智能建立的一个简化模型。粒子群算法在对动物及群活动行为观察的基础上，利用群体中的个体对信息的共享使整个群体的运动在问题求解空间中产生从无序到有序的演化过程，从而获得最优解。</p>\n<h2><a id=\"_4\"></a>什么是粒子群算法</h2>\n<h3><a id=\"_6\"></a>官方说法</h3>\n<p>粒子群算法，也称粒子群优化算法或鸟群觅食算法，缩写为PSO，是一种新的进化算法。PSO算法属于进化算法中的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，通过适应度来评价解的品质，但是比遗传算法规则更为简单，并没有遗传算法的”交叉“和”变异“操作，它通过追随当前搜索到的最优质来寻找全局最优。这种算法以其容易实现、精度高、收敛快等优点引起重视，并在解决实际问题中展示了其优越性。粒子群算法是一种并行算法。</p>\n<h3><a id=\"_10\"></a>粒子群算法通俗描述</h3>\n<p>PSO模拟的是鸟群的捕食行为。设想场景：一群鸟在随机搜索食物。在这个区域里只有一块食物。所有鸟都不知道食物在哪里。但是他们知道当前的位置距离食物还有多远。那么找到食物的最优策略是什么？最简单有效的就是搜寻目前离食物最近的鸟的周围区域。</p>\n<p>鸟群在整个搜寻过程中，通过相互传递各自的信息，让其他鸟知道自己当前的位置，通过这样的协作来判断自己找到的是不是最优解，同时也将最优解的信息传递给整个鸟群，最终整个鸟群都能聚集在食物源的周围，即找到了最优解。</p>\n<p>PSO中，每个优化问题的解都是搜索空间的一只鸟，我们称之为“粒子”。所有的粒子都有一个被优化的函数决定的适应值，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。</p>\n<p>PSO初始化为一群随机粒子（随机解）。然后通过迭代找到最优解，在每一次迭代中，粒子通过跟踪两个“极值”来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值。另一个极值是整个种群目前找到的最优解，这个极值是全局机制。另外也可以不用整个种群而只是用其中一部分作为粒子的邻居，那么在所有邻居中的极值就是局部极值。</p>\n<h3><a id=\"_20\"></a>再通俗描述</h3>\n<p>粒子群算法的基本思想是通过群体中个体之间的协作和信息共享来寻找最优解。试想一群鸟在寻找食物，在这个区域中只有一种虫子，所有鸟都不知道虫子在哪。但是它们知道自己的当前位置距离食物有多远，同时他们知道离食物最近的鸟的位置。那么这时候会发生什么？<strong>鸟群中每只鸟都会朝距离虫子最近的鸟的方向移动</strong>。同时各只鸟在位置不停变化的时候离食物的距离也不断变化，所以每个鸟一定有过离食物最近的位置，这是他们的一个参考。</p>\n<p>所以粒子群算法就是把鸟看成一个个粒子，并且他们拥有位置和速度两个属性，然后根据自身已经找到的离食物最近的解和参考整个共享于整个集群中找到的最近的解去改变自己的飞行方向，最后我们会发现，整个集群大致向同一个方向聚集。而这个地方是离食物最近的区域，条件好的话就会找到食物。</p>\n<h2><a id=\"_26\"></a>粒子抽象</h2>\n<h3><a id=\"_28\"></a>关于速度和位置</h3>\n<p>粒子群算法统领给设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅有两个属性：速度和位置，速度代表移动的快慢，粒子代表移动的方向。</p>\n<p>鸟被抽象为没有质量和体积的微粒（点），并延伸到N维空间，粒子i在N维空间的位置表示为矢量Xi = （x1，x2，…，xn），飞行速度表示为矢量Vi=（v1，v2，…，vn）。每个粒子都有一个由目标函数决定的适应值，并且知道自己到目前为止发现的最好位置（pbest）和现在的位置Xi。这个可以看作是粒子自己的飞行经验。除此之外，每个粒子还知道到目前为止整个群体中所有粒子发现的最好的位置（gbest），这个可以看作是粒子同伴的经验。粒子就是通过自己的经验和同伴中最好的经验来决定下一步运动。</p>\n<h3><a id=\"_34\"></a>速度和位置的更新</h3>\n<p>PSO初始化为一群随机粒子（随机解）。然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个“极值（pbest和gbest）”来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。</p>\n<p><img alt=\"img\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC0zMWM3NGNhOWRhMTdiNjRiLmpwZw?x-oss-process=image/format,png\"/></p>\n<p>对于公式（1）：</p>\n<ul><li>公式（1）中的第一部分称为<strong>记忆项</strong>，表示上次速度大小和方向的影响；</li><li>公式（1）中的第二部分称为<strong>自身认知项</strong>，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；</li><li>公式（1）中的第三部分称为<strong>群体认知项</strong>，是一个从当前点指向种群最好点的矢量，反映了粒子间的协调合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。</li></ul>\n<p><img alt=\"img\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC0yYzg3MzdkMTc4NTBlNDM4LmpwZw?x-oss-process=image/format,png\"/></p>\n<h2><a id=\"PSO_48\"></a>标准PSO算法流程</h2>\n<ol><li>初始化一群微粒（群体规模为N），包括随机位置和速度；</li><li>评价每个微粒的适应度；</li><li>对每个微粒，将其适应值与其经过的最好位置pbest作比较，如果较好，则将其作为当前的最好位置pbest；</li><li>对每个微粒，将其适应值与其经过的最好位置gbest作比较，如果较好，则将其作为当前的最好位置gbest；</li><li>根据公式（2）、（3）调整微粒的速度和位置；</li><li>未达到结束条件则转到第二步。</li></ol>\n<p>迭代终止条件根据具体问题一般选为最大迭代次数Gk或微粒群迄今为止搜索到的最优位置满足预定最小适应阈值。</p>\n<h4><a id=\"PSO_59\"></a>PSO流程图解</h4>\n<p><img alt=\"img\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC0xMTQ2NmEwYTdjOGZiYWViLmpwZw?x-oss-process=image/format,png\"/></p>\n<h4><a id=\"c1c2_63\"></a>学习因子c1、c2分析</h4>\n<p>公式（2）、（3）中pbest和gbest分别表示微粒群的局部和全局最优位置。</p>\n<ul><li> <p>当C1 = 0 时，则粒子没有了认知能力，变为只有社会的模型（social-only）：</p> <p><img alt=\"img\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDM4Njk0MC0xMTQ0NGE5ZDNmZDcyZTQxLmpwZw?x-oss-process=image/format,png\"/></p> <p>称为<strong>全局PSO算法</strong>。粒子有扩展搜索空间的能力，具有较快的收敛速度，但由于缺少局部搜索，对复杂问题比标准PSO更易陷入局部最优。</p> <p><em><strong>c1 = 0 表示与单粒子本身的pbest无关了</strong></em></p> </li><li> <p>当C2 = 0 时，则粒子之间没有社会信息，模型变为只有认知（cognition-only）模型。</p> <p>此时称为<strong>局部PSO算法</strong>。由于个体之间没有信息交流，整个群体相当于多个粒子进行盲目的随机搜索，收敛速度满，因而得到最优解的可能性小。</p> </li></ul>\n<h3><a id=\"_79\"></a>操作思路</h3>\n<p>在D维空间中，有N个粒子；</p>\n<p>粒子i的速度：<strong>xi</strong> = （xi1，xi2，…，xiD），将xi带入**适应函数f（xi）**求适应值；</p>\n<p>粒子i的速度：<strong>vi</strong> = （vi1，vi2，…，viD）</p>\n<p>粒子i个体经历的最好位置：<strong>pbest</strong> = （pi1，pi2，…，piD）</p>\n<p>种群所经历的最好位置：<strong>gbest</strong> = （g1，g2，…，gD）</p>\n<p>通常，在第d（1&lt;=d&lt;=D）维的位置变化范围限定在（Xmin d，Xmax d）内，速度变化范围限定在（-Vmax d，Vmax d）内（即在迭代中若超出了边界值，则该维的速度或位置被限制维该维最大速度或边界位置）</p>\n<h4><a id=\"id_93\"></a>粒子i的第d维速度更新公式：</h4>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\20201007075119295.png\"/></p>\n<h4><a id=\"id_97\"></a>粒子i的第d维位置更新公式：</h4>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\20201102191936866.png\"/></p>\n<h4><a id=\"_101\"></a>粒子其运动的过程受到三方面影响：粒子先前的速度、粒子认知部分、粒子社会部分</h4>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\20201007081231961.png\"/></p>\n<h3><a id=\"_105\"></a>算法流程</h3>\n<ol><li>Initial：初始化例子群体（群体规模为N），包括随机位置和速度。</li><li>Evaluation：根据fitness function，评价每个粒子的适应度。</li><li>Find the Pbest：对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值做比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest。</li><li>Find the Gbest：对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值进行比较，如果当前的适应值更高，则将用当前的粒子位置更新全局最佳位置gbest。</li><li>Update the Velocity：根据公式更新每个粒子的速度与位置。</li><li>如为满足条件，返回步骤二。</li></ol>\n<p><strong>通常算法达到最大迭代次数或者最佳适应度值的增量小于某个给定的阈值时算法停止。</strong></p>\n<h3><a id=\"_116\"></a>算法应用</h3>\n<h4><a id=\"m_118\"></a>种群大小m</h4>\n<p>m很小容易陷入局部最优；m很大，PSO的优化能力很好，当种群数目增长到一定水平时，再增长将不再有显著的作用。</p>\n<h4><a id=\"_122\"></a>权重因子</h4>\n<p>对于粒子的速度更新的三部分：</p>\n<ol><li>惯性因子w=1表示基本的粒子群算法，w=0表示失去对粒子本身的速度的记忆；</li><li>自我认知部分的学习因子C1 = 0 表示无私型的粒子群算法，只有社会，没有自我，这样会使群体丧失多样性，从而导致容易陷入局部最优而无法跳出；</li><li>社会经验部分的学习因子C2=0表示自我型的粒子群算法，只有自我没有社会，这样导致没有信息的社会共享，算法收敛速度较慢。</li></ol>\n<p>这三个参数的选择非常重要，如何调整这三个参数使得算法避免早熟又可以较快收敛，对于解决实际问题的意义较大。</p>\n<h4><a id=\"_132\"></a>最大速度</h4>\n<p>速度限制作用为：维护算法的探索能力与开发能力的平衡。</p>\n<p>Vm较大时，探索能力强，但是粒子容易飞过最优解；</p>\n<p>Vm较小时，开发能力强，但是粒子容易陷入局部最优解；</p>\n<p>Vm一般设定为每维变量变化范围的10%–20%。</p>\n<h4><a id=\"_142\"></a>停止准则</h4>\n<p>最大迭代次数；</p>\n<p>可以接受的满意解（通过fitness function判断是否满意）</p>\n<h4><a id=\"_148\"></a>粒子空间的初始化</h4>\n<p>较好地选择粒子的初始化空间，将大大缩短收敛时间。初始化空间根据具体问题的不同而不同，根据具体问题进行设定。该算法为数不多的关键参数的设置却对算法的精度和效率有着显著影响。</p>\n<h4><a id=\"_152\"></a>线性递减权值（未测）</h4>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\20201007090018420.png\"/></p>\n<p>Wmax最大惯性权重，Wmin为最小惯性权重，run为当前迭代次数，runmax为算法迭代总次数。</p>\n<p>较大的w有较好的全局收敛能力，较小的w则有较强的局部收敛能力。因此随着迭代次数的增加，惯性权重w应不断减少，从而使得粒子群算法在初期具有较强的全局收敛能力，而晚期具有较强的局部收敛能力。</p>\n<h4><a id=\"_160\"></a>收缩因子法（未测）</h4>\n<p>1999年，引入收缩因子以保证算法的收敛性，因此更改速度公式：</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\2020100709025448.png\"/></p>\n<p>K为收缩因子，φ1 φ2 限制的w。φ1 φ2是需要预先设定的模型参数。</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\20201007090347690.png\"/></p>\n<p>收缩因子法控制系统行为最终收敛，且可以有效搜索不同区域，该法能得到较高质量的解。</p>\n<h4><a id=\"_172\"></a>算法的邻域拓扑结构（未测）</h4>\n<p>粒子群算法的邻域拓扑结构包括两种：一种是将群体内所有个体都作为粒子的邻域，另一种是只将群体中的部分个体作为粒子的邻域。邻域拓扑结构决定群体历史最优位置，因此该算法分为全局粒子群算法和局部粒子群算法。</p>\n<p>全局粒子群算法：</p>\n<ol><li>粒子自己历史最优值；</li><li>粒子群体的全局最优值。</li></ol>\n<p>局部粒子群算法：</p>\n<ol><li>粒子自己历史最优值；</li><li>粒子邻域内粒子的最优值。</li></ol>\n<p>邻域随迭代次数的增加先行增大，最后邻域扩展至整个粒子群。</p>\n<p>实践证明：全局版本的粒子群算法收敛速度快,但是容易陷入局部最优。局部最优的粒子群算法收敛速度慢，但是很难陷入局部最优。现在粒子群算法大都在收敛速度与摆脱局部最优这两个方面下功夫。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-15 19:57:38", "summary": "粒子群优化算法粒子群优化算法是一种进化计算技术，源于对鸟群捕食行为的研究。该算法最初是受到飞鸟集群活动的规律性启发，进而利用群体智能建立的一个简化模型。粒子群算法在对动物及群活动行为观察的基础上，利用"}