{"blogid": "125446002", "writerAge": "码龄5年", "writerBlogNum": "82", "writerCollect": "164", "writerComment": "18", "writerFan": "14", "writerGrade": "4级", "writerIntegral": "1180", "writerName": "我们一直在路上", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125446002.jpg", "writerRankTotal": "17611", "writerRankWeekly": "223007", "writerThumb": "45", "writerVisitNum": "67309", "blog_read_count": "2669", "blog_time": "于 2022-06-24 16:18:36 发布", "blog_title": "redis淘汰策略", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h5><a id=\"_0\"></a>一、最大内存设置</h5>\n<p>redis 默认的最大的内存设置为0，相当于基于物理机的最大值<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3e2ada671b754be7919ed13d46716191.png\"/></p>\n<h5><a id=\"_4\"></a>二、淘汰策略</h5>\n<h6><a id=\"1_8_5\"></a>1. 8种策略</h6>\n<ol><li>volatile-lru，针对设置了过期时间的key，使用lru算法进行淘汰。</li><li>allkeys-lru，针对所有key使用lru算法进行淘汰。</li><li>volatile-lfu，针对设置了过期时间的key，使用lfu算法进行淘汰。</li><li>allkeys-lfu，针对所有key使用lfu算法进行淘汰。</li><li>volatile-random，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。</li><li>allkeys-random，针对所有的key使用随机淘汰机制进行淘汰。</li><li>volatile-ttl，删除生存时间最近的一个键。</li><li>noeviction(默认)，不删除键，值返回错误。</li></ol>\n<p>主要是4种算法，针对不同的key,形成的策略。<br/> 算法：</p>\n<ol><li>lru 最近很好的使用的key（根据时间，最不常用的淘汰）</li><li>lfu 最近很好的使用的key (根据计数器，用的次数最少的key淘汰)</li><li>random 最难淘汰</li><li>ttl 快要过期的先淘汰</li></ol>\n<p>key ：</p>\n<ol><li>volatile 有过期的时间的那些key</li><li>allkeys 所有的key</li></ol>\n<h6><a id=\"2_27\"></a>2.内存淘汰算法的具体工作原理是：</h6>\n<ul><li>客户端执行一条新命令，导致数据库需要增加数据（比如set key value）</li><li>Redis会检查内存使用，如果内存使用超过 maxmemory，就会按照置换策略删除一些 key</li><li>新的命令执行成功</li></ul>\n<h5><a id=\"lrulfu_34\"></a>三、lru和lfu算法</h5>\n<h6><a id=\"1lru_35\"></a>1.lru</h6>\n<p>LRU是Least Recently Used的缩写，也就是表示最近很少使用，也可以理解成最久没有使用。也就是说当内存不够的时候，每次添加一条数据，都需要抛弃一条最久时间没有使用的旧数据。标准的LRU算法为了降低查找和删除元素的时间复杂度，一般采用Hash表和双向链表结合的数据结构，hash表可以赋予链表快速查找到某个key是否存在链表中，同时可以快速删除、添加节点，如图所示。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c797832ff06e40ea9d461e052c2c81d4.png\"/><br/> 双向链表的查找时间复杂度是O(n)，删除和插入是O(1)，借助HashMap结构，可以使得查找的时间复杂度变成O(1),Hash表用来查询在链表中的数据位置，链表负责数据的插入.<br/> 当新数据插入到链表头部时有两种情况</p>\n<ol><li>当链表中没有这个key,且链表满了，把链表尾部的数据丢弃掉，新加入的缓存直接加入到链表头中。</li><li>当链表中的某个缓存被命中时，直接把数据移到链表头部，原本在头节点的缓存就向链表尾部移动</li></ol>\n<p>这样，经过多次Cache操作之后，最近被命中的缓存，都会存在链表头部的方向，没有命中的，都会在链表尾部方向，当需要替换内容时，由于链表尾部是最少被命中的，我们只需要淘汰链表尾部的数据即可。</p>\n<h6><a id=\"2redislru_46\"></a>2.redis中的lru算法</h6>\n<p>实际上，Redis使用的LRU算法其实是一种不可靠的LRU算法，它实际淘汰的键并不一定是真正最少使用的数据，它的工作机制是：</p>\n<ul><li>随机采集淘汰的key，每次随机选出5个key</li><li>然后淘汰这5个key中最少使用的key</li></ul>\n<p>这5个key是默认的个数，具体的数值可以在redis.conf中配置</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\586381e5b9664624a828c340c243ac23.png\"/><br/> 当近似LRU算法取值越大的时候就会越接近真实的LRU算法，因为取值越大获取的数据越完整，淘汰中、的数据就更加接近最少使用的数据。这里其实涉及一个权衡问题，<br/> 如果需要在所有的数据中搜索最符合条件的数据，那么一定会增加系统的开销，Redis是单线程的，所以耗时的操作会谨慎一些。为了在一定成本内实现相对的LRU，早期的Redis版本是基于采样的LRU，也就是放弃了从所有数据中搜索解改为采样空间搜索最优解。Redis3.0版本之后，Redis作者对于基于采样的LRU进行了一些优化：</p>\n<ul><li>Redis中维护一个大小为16的候选池，当第一次随机选取采用数据时，会把数据放入到候选池中，并且候选池中的数据会更具时间进行排序。</li><li>当第二次以后选取数据时，只有小于候选池内最小时间的才会被放进候选池。</li><li>当候选池的数据满了之后，那么时间最大的key就会被挤出候选池。当执行淘汰时，直接从候选池中选取最近访问时间小的key进行淘汰。<br/> 如图4-22所示，首先从目标字典中采集出maxmemory-samples个键，缓存在一个samples数组中，然后从samples数组中一个个取出来，和回收池中以后的键进行键的空闲时间，从而更新回收池。<img alt=\"\" src=\"..\\..\\static\\image\\fb278048858d45e9a36bdb2211ce4fcb.png\"/></li><li>回收池满了，并且当前插入的key的空闲时间最小（也就是回收池中的所有key都比当前插入的key的空闲时间都要大），则不作任何操作。</li><li>回收池未满，并且插入的位置x没有键，则直接插入即可</li><li>回收池未满，且插入的位置x原本已经存在要淘汰的键，则把第x个以后的元素都往后挪一个位置，然后再执行插入操作。</li><li>回收池满了，将当前第x个以前的元素往前挪一个位置（实际就是淘汰了），然后执行插入操作。<br/> 这样做的目的是能够选出最真实的最少被访问的key，能够正确不常使用的key。因为在Redis3.0之前是随机选取样本，这样的方式很有可能不是真正意义上的最少访问的key。<br/> <strong>缺点：</strong><br/> LRU算法有一个弊端，加入一个key值访问频率很低，但是最近一次被访问到了，那LRU会认为它是热点数据，不会被淘汰。同样，<br/> 经常被访问的数据，最近一段时间没有被访问，这样会导致这些数据被淘汰掉，导致误判而淘汰掉热点数据，于是在Redis 4.0中，新加了一种LFU算法。</li></ul>\n<h6><a id=\"2lfu_72\"></a>2.lfu</h6>\n<p>LFU（Least Frequently Used），表示最近最少使用，它和key的使用次数有关，其思想是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰，反之则保留。<br/> LRU的原理是使用计数器来对key进行排序，每次key被访问时，计数器会增大，当计数器越大，意味着当前key的访问越频繁，也就是意味着它是热点数据。 <strong>它很好的解决了LRU算法的缺陷：一个很久没有被访问的key，偶尔被访问一次，导致被误认为是热点数据的问题</strong>。<br/> LFU的实现原理如图4-23所示<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\111b10612b144705ab9bf361e7ceed46.png\"/><br/> LFU维护了两个链表，<strong>横向组成的链表用来存储访问频率，每个访问频率的节点下存储另外一个具有相同访问频率的缓存数据</strong>。具体的工作原理是：</p>\n<ul><li>当添加元素时，找到相同访问频次的节点，然后添加到该节点的数据链表的头部。如果该数据链表满了，则移除链表尾部的节点当获取元素或者修改元素是，都会增加对应key的访问频次，并把当前节点移动到下一个频次节点。</li><li>添加元素时，访问频率默认为1，随着访问次数的增加，频率不断递增。而当前被访问的元素也会随着频率增加进行移动。</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-24 16:18:36", "summary": "一、最大内存设置默认的最大的内存设置为，相当于基于物理机的最大值在这里插入图片描述二、淘汰策略种策略，针对设置了过期时间的，使用算法进行淘汰。，针对所有使用算法进行淘汰。，针对设置了过期时间的，使用算"}