{"blogid": "125020258", "writerAge": "码龄8年", "writerBlogNum": "793", "writerCollect": "1153", "writerComment": "172", "writerFan": "18756", "writerGrade": "6级", "writerIntegral": "8585", "writerName": "菊头蝙蝠", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125020258.jpg", "writerRankTotal": "1693", "writerRankWeekly": "613", "writerThumb": "495", "writerVisitNum": "251063", "blog_read_count": "1202", "blog_time": "于 2022-05-28 18:46:35 发布", "blog_title": "shared_ptr循环引用问题以及解决方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-dracula\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>shared_ptr循环引用问题以及解决方法</h3>\n<ul><li><a href=\"#shared_ptr_3\">一、shared_ptr循环引用问题</a></li><li><ul><li><a href=\"#_7\">例子一</a></li><li><a href=\"#_67\">例子二</a></li><li><a href=\"#_84\">例子三</a></li></ul>\n</li><li><a href=\"#weak_ptr_99\">二、weak_ptr解决循环引用问题</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"shared_ptr_3\"></a>一、shared_ptr循环引用问题</h1>\n<p>什么是循环引用，两个对象相互使用shared_ptr指向对方。造成的后果是：内存泄漏</p>\n<h2><a id=\"_7\"></a>例子一</h2>\n<p>下面是循环引用的例子</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;memory&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">&gt;</span> bptr<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"A is deleted\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 析构函数后，才去释放成员变量</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">&gt;</span> aptr<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"B is deleted\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 析构函数后，才去释放成员变量</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">&gt;</span> pa<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">&gt;</span> <span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">&gt;</span> <span class=\"token function\">bp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ap<span class=\"token operator\">-&gt;</span>bptr <span class=\"token operator\">=</span> bp<span class=\"token punctuation\">;</span>\n        bp<span class=\"token operator\">-&gt;</span>aptr <span class=\"token operator\">=</span> ap<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>这种状态下，它们的引用计数为均为2</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token punctuation\">{<!-- --></span>\n\t   std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">&gt;</span> <span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t   std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">&gt;</span> <span class=\"token function\">bp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t   ap<span class=\"token operator\">-&gt;</span>bptr <span class=\"token operator\">=</span> bp<span class=\"token punctuation\">;</span>\n\t   bp<span class=\"token operator\">-&gt;</span>aptr <span class=\"token operator\">=</span> ap<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在作用域内ap和bp的引用计数都为2，但是当它们退出循环的时候，ap的引用计数减1，bp的引用计数也减1，但它们依旧不为0，引用计数均为1。<br/> <strong>对ap来说</strong>：只有调用了A的析构函数，才会去释放它的成员变量bptr。何时会调用A的析构函数呢？就是ap的引用计数为0<br/> <strong>对于bp来说</strong>，只有调用了B的析构函数，才会去释放它的成员变量aptr。同样是bp的引用计数都为0的时候才能析构。</p>\n<p>现在，对于ap和bp来说，它们都拿着对方的share_ptr(有点类似于死锁的现象)，没法使得ab和bp的引用计数为0。那么A和B的对象均无法析构。于是造成了内存泄漏。</p>\n<p><strong>ap和bp退出作用域了，为什么不会调用析构函数呢？</strong><br/> ap和bp是创建在栈上的，而不是A或者B对象的本身，ap、bp退出作用域，只是ap和bp本身释放了，只会使得，A、B对象的引用计数-1，调用析构函数，是要A或B的对象，的引用计数为0才能执行析构函数。</p>\n<h2><a id=\"_67\"></a>例子二</h2>\n<p>如果将例子一，改成了下面这样，A对象的引用计数为1，B对象的引用计数为2<br/> 当ap和bp退出作用域时，<br/> 首先栈上的bp会被释放，那么B对象的引用计数-1，从2变为 1<br/> 然后栈上的ap会释放，那么A对象的引用计数-1，变成0。那么会调用A对象的析构函数，那么A对象中的成员bptr也会被释放，那么B对象的引用计数-1，也变成0，就会调用B对象的析构函数。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token punctuation\">{<!-- --></span>\n\t   std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">&gt;</span> <span class=\"token function\">ap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t   std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">&gt;</span> <span class=\"token function\">bp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t   ap<span class=\"token operator\">-&gt;</span>bptr <span class=\"token operator\">=</span> bp<span class=\"token punctuation\">;</span>\n\t   <span class=\"token comment\">//bp-&gt;aptr = ap;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>执行结果<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\260c54fa172749e39151e468f1441b3b.png\"/><br/> （注意，顺序是反着的，先释放栈上的bp，然后再是ap）</p>\n<h2><a id=\"_84\"></a>例子三</h2>\n<p>由于ap和bp都拿着对方的shared_ptr,导致循环引用。那么可以手动释放成员变量，比如将ap-&gt;bptr释放，那么此时B对象的引用计数为1，A对象的引用计数为2。</p>\n<p>就是跟例子二类似的情况了，A对象和B对象都能够成功析构，不会造成内存泄漏。</p>\n<pre><code class=\"prism language-c\"><span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token operator\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">&gt;</span> <span class=\"token function\">ap</span><span class=\"token punctuation\">(</span>new A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token operator\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">&gt;</span> <span class=\"token function\">bp</span><span class=\"token punctuation\">(</span>new B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ap<span class=\"token operator\">-&gt;</span>bptr <span class=\"token operator\">=</span> bp<span class=\"token punctuation\">;</span>\n        bp<span class=\"token operator\">-&gt;</span>aptr <span class=\"token operator\">=</span> ap<span class=\"token punctuation\">;</span>\n\n        ap<span class=\"token operator\">-&gt;</span>bptr<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 手动释放成员变量才行</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h1><a id=\"weak_ptr_99\"></a>二、weak_ptr解决循环引用问题</h1>\n<p>shared_ptr采用引用计数的方式，为0的时候就会去析构对象。<br/> 可以发现weak_ptr，不影响引用计数，是一种不控制对象生命周期的智能指针。</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">sp</span><span class=\"token punctuation\">(</span>new <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>sp<span class=\"token punctuation\">.</span><span class=\"token function\">use_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//输出1</span>\n    weak_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> wp1<span class=\"token operator\">=</span>sp<span class=\"token punctuation\">;</span>\n    weak_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> wp2<span class=\"token operator\">=</span>sp<span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>sp<span class=\"token punctuation\">.</span><span class=\"token function\">use_count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//输出1</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>因此只要将例子一中，类成员从shared_ptr改为weak_ptr，即可解决循环引用问题</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-28 18:46:35", "summary": "循环引用问题以及解决方法一、循环引用问题例子一例子二例子三二、解决循环引用问题一、循环引用问题什么是循环引用，两个对象相互使用指向对方。造成的后果是：内存泄漏例子一下面是循环引用的例子析构函数后，才去"}