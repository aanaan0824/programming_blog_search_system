{"blogid": "125455921", "writerAge": "码龄5年", "writerBlogNum": "137", "writerCollect": "1265", "writerComment": "164", "writerFan": "140", "writerGrade": "6级", "writerIntegral": "5532", "writerName": "zxy2847225301", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125455921.jpg", "writerRankTotal": "8235", "writerRankWeekly": "19491", "writerThumb": "316", "writerVisitNum": "617718", "blog_read_count": "1015", "blog_time": "已于 2022-06-25 10:42:57 修改", "blog_title": "利用C#实现Pdf转图片", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>        这周碰到一个需求，由于公司系统框架的原因，不能直接显示第三方回传回来的pdf(说明一下，第三方回传的pdf是带上了签章信息(即在pdf中加入了签名图片))，需要把pdf转成图片进行显示，但在做的过程中踩了不少雷。最后使用第三方插件PDFRender4NET</p>\n<p>1   第三方的插件PdfiumViewer(缺点，丢失签章信息)</p>\n<p>          首先试了第三方的插件PdfiumViewer，代码很简单，网上也有很多demo，把代码拷贝过来修改一下，三两下就搞定了，试了一下，确实是可以实现pdf传图片，但当我把业务代码写完了，在业务系统上运行时，发现，妈的，大意了，转换完毕的图片丢失了签章信息。下面是我略作修改后的部分代码：</p>\n<pre><code class=\"language-cs\">public class PdfToImageHelper\n    {\n        /// &lt;summary&gt;\n        /// pdf转图片(base64格式的字符串)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"pdfBase64String\"&gt;pdf对应的base64字符串&lt;/param&gt;\n        /// &lt;returns&gt;Pdf如果有多页，就返回多张图片(base64字符串集合)&lt;/returns&gt;\n        public static List&lt;string&gt; GetBase64StringArray(string pdfBase64String)\n        {\n            if (pdfBase64String==null|| pdfBase64String.Length==0) return null;\n            List&lt;string&gt; base64StringList = new List&lt;string&gt;();\n            byte[] buffer=Convert.FromBase64String(pdfBase64String);\n            if (buffer == null || buffer.Length == 0) return base64StringList;\n            MemoryStream ms = new MemoryStream(buffer);\n            var pdfDocument = PdfiumViewer.PdfDocument.Load(ms);\n            for (int index = 0; index &lt;pdfDocument.PageCount; index++)\n            {\n                Image image = pdfDocument.Render(index, (int)pdfDocument.PageSizes[index].Width, (int)pdfDocument.PageSizes[index].Height, 300, 300, false);\n                string base64Str=ImageToBase64String(image);\n                if (base64Str != null &amp;&amp; base64Str.Length &gt; 0)\n                {\n                    base64StringList.Add(base64Str);\n                }\n            }\n            //释放流资源\n            return base64StringList;\n        }\n\n        /// &lt;summary&gt;\n        /// Image对象转base64字符串\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"Picture\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private static string ImageToBase64String(Image Picture)\n        {\n            MemoryStream ms = new MemoryStream();\n            if (Picture == null)\n                return null;\n            Picture.Save(ms, System.Drawing.Imaging.ImageFormat.Jpeg);\n            byte[] BPicture = new byte[ms.Length];\n            BPicture = ms.GetBuffer();\n            //释放流资源\n            return Convert.ToBase64String(BPicture);\n        }\n    }</code></pre>\n<p>调用：List&lt;string&gt;  imageBase64StringList=PdfToImageHelper.GetBase64StringArray(\"pdf对应的base64字符串\");</p>\n<p></p>\n<p>2  第三方插件Spire.pdf (缺点：收费，有免费版的，但是pdf转换为图片有页数限制(最多3页) ，且转换后的图片很模糊)</p>\n<p>使用PdfiumViewer不行后，开始使用Spire.pdf，通过vistual studio的nuget就可以拿到dll，如下图：</p>\n<p><img alt=\"\" height=\"558\" src=\"..\\..\\static\\image\\4503583e5afa4725886c1a442e366ddc.png\" width=\"1010\"/></p>\n<p>第一个Spire.PDF是收费的，转换后的图片左上角会带上如下图的水印信息</p>\n<p><img alt=\"\" height=\"95\" src=\"..\\..\\static\\image\\8ff612dacd6f4abc8831cc77559c43f8.png\" width=\"619\"/></p>\n<p> 第二个FreeSpire.PDF是免费的，但是pdf如果超过3页，只能转前3页，后面的转换的都是空白页</p>\n<p>代码就不贴了，网上有很多demo</p>\n<p></p>\n<p>3   第三方插件PDFRender4NET(O2S.Components.PDFRender4NET.dll,版本信息如下图)</p>\n<p><img alt=\"\" height=\"407\" src=\"..\\..\\static\\image\\2ee42d7ed0d14b798c7455ca4f2dc969.png\" width=\"434\"/></p>\n<p> 下面贴出我略做修改后的代码：</p>\n<pre><code class=\"language-cs\">using O2S.Components.PDFRender4NET;\nusing System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace iih.gdrmh.ca.PatientSign.bp\n{\n    public class PdfToImageHelper\n    {\n        public static List&lt;string&gt; GetBase64StringArrayByPdfPath(string pdfPath)\n        {\n            if (pdfPath == null || pdfPath.Length == 0) return null;\n            List&lt;string&gt; base64StringList = new List&lt;string&gt;();\n            PDFFile pdfFile = PDFFile.Open(pdfPath);\n            for (int index =0; index &lt;pdfFile.PageCount; index++)\n            {\n                Bitmap pageImage = pdfFile.GetPageImage(index, 56 * 10);\n                string base64Str = BitmapToBase64String(pageImage);\n                if (base64Str != null &amp;&amp; base64Str.Length &gt; 0)\n                {\n                    base64StringList.Add(base64Str);\n                }\n            }\n            pdfFile.Dispose();\n            return base64StringList;\n        }\n\n        private static string ImageToBase64String(Image Picture)\n        {\n            MemoryStream ms = new MemoryStream();\n            if (Picture == null)\n                return null;\n            Picture.Save(ms, System.Drawing.Imaging.ImageFormat.Jpeg);\n            byte[] BPicture = new byte[ms.Length];\n            BPicture = ms.GetBuffer();\n            return Convert.ToBase64String(BPicture);\n        }\n\n\n        private static string BitmapToBase64String(Bitmap bitmap)\n        {\n            // 1.先将BitMap转成内存流\n            MemoryStream ms = new MemoryStream();\n            bitmap.Save(ms, ImageFormat.Png);\n            ms.Seek(0, SeekOrigin.Begin);\n            // 2.再将内存流转成byte[]并返回\n            byte[] bytes = new byte[ms.Length];\n            ms.Read(bytes, 0, bytes.Length);\n            ms.Flush();\n            ms.Close();\n            ms.Dispose();\n            return Convert.ToBase64String(bytes);\n        }\n\n\n    }\n}\n</code></pre>\n<p>调用：List&lt;string&gt;  imageBase64StringList=PdfToImageHelper.GetBase64StringArrayByPdfPath(\"pdf对应的文件路径\");</p>\n<p></p>\n<p>最后发现，转换后的图片，签章信息还在，转换后的图片清晰度比FreeSpire.PDF还高</p>\n<p></p>\n<p>拓展：</p>\n<p>去stack overflow搜索发现，pdf转换图片的方案有很多,但推荐最多的是<strong>Ghostscript.NET. </strong>github地址为：<a href=\"https://github.com/jhabjan/Ghostscript.NET\" title=\"https://github.com/jhabjan/Ghostscript.NET\">https://github.com/jhabjan/Ghostscript.NET</a>   demo代码：<a href=\"https://github.com/jhabjan/Ghostscript.NET/blob/master/Ghostscript.NET.Samples/Samples/RasterizerSample1.cs\" title=\"https://github.com/jhabjan/Ghostscript.NET/blob/master/Ghostscript.NET.Samples/Samples/RasterizerSample1.cs\">https://github.com/jhabjan/Ghostscript.NET/blob/master/Ghostscript.NET.Samples/Samples/RasterizerSample1.cs</a></p>\n<p></p>\n<p>stack overflow参考链接：</p>\n<p>1  <a href=\"https://stackoverflow.com/questions/72710331/convert-pdf-to-image-c-sharp-net\" title=\"Convert Pdf to Image C# .NET - Stack Overflow\">Convert Pdf to Image C# .NET - Stack Overflow</a></p>\n<p>2  <a href=\"https://stackoverflow.com/questions/38301843/converting-pdf-to-image-using-c-sharp-and-ghostscript\" title=\"Converting pdf to image using c# and Ghostscript - Stack Overflow\">Converting pdf to image using c# and Ghostscript - Stack Overflow</a></p>\n<p>3  <a href=\"https://stackoverflow.com/questions/3492129/convert-pdf-file-to-images-using-c-sharp\" title=\"asp.net - Convert PDF file to images using C# - Stack Overflow\">asp.net - Convert PDF file to images using C# - Stack Overflow</a></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-25 10:42:57", "summary": "这周碰到一个需求，由于公司系统框架的原因，不能直接显示第三方回传回来的说明一下，第三方回传的是带上了签章信息即在中加入了签名图片，需要把转成图片进行显示，但在做的过程中踩了不少雷。最后使用第三方插件第"}