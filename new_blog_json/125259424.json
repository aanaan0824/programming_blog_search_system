{"blogid": "125259424", "writerAge": "码龄159天", "writerBlogNum": "29", "writerCollect": "57", "writerComment": "7", "writerFan": "1622", "writerGrade": "3级", "writerIntegral": "639", "writerName": "m0_68949064", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125259424.jpg", "writerRankTotal": "26470", "writerRankWeekly": "3253", "writerThumb": "46", "writerVisitNum": "144207", "blog_read_count": "7932", "blog_time": "已于 2022-07-19 11:02:23 修改", "blog_title": "js中blob对象介绍和实现切片上传", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、js中blob对象介绍</h2>\n<p><code>Blob</code><strong> </strong>对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\" title=\"ReadableStream\">ReadableStream</a> 来用于数据操作。 </p>\n<p>Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>\n<p>要从其他非 blob 对象和数据构造一个 <code>Blob</code>，请使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob\" title=\"Blob()\">Blob()</a> 构造函数。要创建一个 blob 数据的子集 blob，请使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\" title=\"slice()\">slice()</a> 方法。要获取用户文件系统上的文件对应的 <code>Blob</code> 对象，请参阅 File 文档。</p>\n<p>接受 <code>Blob</code> 对象的 API 也被列在 File 文档中。</p>\n<p><strong>注意：</strong><code>slice()</code> 方法原本接受 <code>length</code> 作为第二个参数，以表示复制到新 <code>Blob</code> 对象的字节数。如果设置的参数使 <code>start + length</code> 超出了源 <code>Blob</code> 对象的大小，则返回从开始到结尾的所有数据。</p>\n<p><strong>注意：</strong><code>slice()</code> 方法在某些浏览器和版本上带有浏览器引擎前缀：比如 Firefox 12 及更早版本的<code>blob.mozSlice()</code> 和 Safari 中的<code>blob.webkitSlice()</code>。没有浏览器引擎前缀的老版本 <code>slice()</code> 方法有不同的语义，并且已过时。Firefox 30 取消了对 <code>blob.mozSlice()</code> 的支持。</p>\n<h3 id=\"构造函数\">构造函数</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob\" title=\"Blob(blobParts[, options])\">Blob(blobParts[, options])</a></p>\n<pre>标准语法：var aBlob = new Blob(<em> array</em>, <em>options</em> );\n</pre>\n<ul><li><em>array</em> 是一个由<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" title=\"ArrayBuffer\">ArrayBuffer</a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" title=\"ArrayBufferView\">ArrayBufferView</a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\" title=\"Blob\">Blob</a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString\" title=\"DOMString\">DOMString</a> 等对象构成的 Array，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings 会被编码为 UTF-8。</li><li><em>option</em><em>s</em> 是一个可选的<code>BlobPropertyBag</code>字典，它可能会指定如下两个属性： \n  <ul><li><code>type</code>，默认值为 <code>\"\"</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li><li><code>endings</code>，默认值为<code>\"transparent\"</code>，用于指定包含行结束符<code>\\n</code>的字符串如何被写入。 它是以下两个值中的一个： <code>\"native\"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>\"transparent\"</code>，代表会保持 blob 中保存的结束符不变</li></ul></li></ul>\n<p>返回一个新创建的 <code>Blob</code> 对象，其内容由参数中给定的数组串联组成。</p>\n<h3 id=\"属性\">属性</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size\" title=\"Blob.size\">Blob.size</a> 只读</p>\n<p><code>Blob</code> 对象中所包含数据的大小（字节）。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type\" title=\"Blob.type\">Blob.type</a> 只读</p>\n<p>一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p>\n<h3 id=\"方法\">方法</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\" title=\"Blob.slice([start[, end[, contentType]]])\">Blob.slice([start[, end[, contentType]]])</a></p>\n<p>返回一个新的 <code>Blob</code> 对象，包含了源 <code>Blob</code> 对象中指定范围内的数据。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream\" title=\"Blob.stream()\">Blob.stream()</a></p>\n<p>返回一个能读取 blob 内容的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\" title=\"ReadableStream\">ReadableStream</a>。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text\" title=\"Blob.text()\">Blob.text()</a></p>\n<p>返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/USVString\" title=\"USVString\">USVString</a>。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer\" title=\"Blob.arrayBuffer()\">Blob.arrayBuffer()</a></p>\n<p>返回一个 promise 且包含 blob 所有内容的二进制格式的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" title=\"ArrayBuffer\">ArrayBuffer</a> </p>\n<h3 id=\"blob_构造函数用法举例\">Blob 构造函数用法举例</h3>\n<p>Blob 构造函数允许通过其它对象创建 Blob 对象。比如，用字符串构建一个 blob：</p>\n<pre><code>var debug = {hello: \"world\"};\nvar blob = new Blob([JSON.stringify(debug, null, 2)], {type : 'application/json'});</code></pre>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/BlobBuilder\" title=\"BlobBuilder\">BlobBuilder</a> 接口提供了另外一种创建<code>Blob</code> 对象的方式，但该方式现在已经废弃，不应继续使用：</p>\n<pre><code>var builder = new BlobBuilder();\nvar fileParts = ['&lt;a id=\"a\"&gt;&lt;b id=\"b\"&gt;hey!&lt;/b&gt;&lt;/a&gt;'];\nbuilder.append(fileParts[0]);\nvar myBlob = builder.getBlob('text/xml');\n</code></pre>\n<h3><strong>使用 Blob 创建一个指向类型化数组的 URL</strong></h3>\n<h3 id=\"示例：使用_blob_创建一个指向类型化数组的url\"></h3>\n<p>参考下面的代码：</p>\n<pre><code>var typedArray = GetTheTypedArraySomehow();\nvar blob = new Blob([typedArray.buffer], {type: 'application/octet-stream'}); // 传入一个合适的 MIME 类型\nvar url = URL.createObjectURL(blob);\n// 会产生一个类似 blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的 URL 字符串\n// 你可以像使用普通 URL 那样使用它，比如用在 img.src 上。\n</code></pre>\n<h3 id=\"示例：从_blob_中提取数据\"><strong>从 Blob 中提取数据</strong></h3>\n<p>一种从 Blob 中读取内容的方法是使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\" title=\"FileReader\">FileReader</a>。以下代码将 Blob 的内容作为类型数组读取：</p>\n<pre><code>var reader = new FileReader();\nreader.addEventListener(\"loadend\", function() {\n   // reader.result 包含被转化为类型数组 typed array 的 blob\n});\nreader.readAsArrayBuffer(blob);</code></pre>\n<p>另一种读取 Blob 中内容的方式是使用 Response 对象。下述代码将 Blob 中的内容读取为文本：</p>\n<pre><code>var text = await (new Response(blob)).text();\n</code></pre>\n<p>通过使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\" title=\"FileReader\">FileReader</a> 的其它方法可以把 Blob 读取为字符串或者数据 URL</p>\n<p></p>\n<h2> 二、php+js 实现切片上传</h2>\n<p>前端代码（upload.html）：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n\t&lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"&gt;\n&lt;body&gt;\n&lt;input type=\"file\" id=\"file\" name=\"file\"&gt;\n&lt;button&gt;切片上传&lt;/button&gt;\n&lt;/body&gt;\n&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n    $(\"button\").click(function(){\n    \tvar cur_time = new Date(); //开始执行时间\n    \tvar BYTES_PER_CHUNK = 1024 * 1024; // 每个文件切片大小定为1MB .\n\t\tvar file = document.getElementById(\"file\").files[0];\n\t\tvar file_info = document.getElementById(\"file\").value;\n\t\tvar file_info_arr = file_info.split(\"\\\\\");\n\t\tvar file_name = file_info_arr[file_info_arr.length-1];\n\n\t\tvar start = 0;\n\t\tvar blobs = [];\n\t\tvar file_num = Math.ceil(file.size / BYTES_PER_CHUNK);\n\n\t\tfor (var i = 0; i &lt; file_num; i++) {\n\t\t    var end = start + BYTES_PER_CHUNK;\n\t\t    blobs[i] = file.slice(start, end);\n\t\t    start = end;\n\t   }\n\t\tconsole.log(file_num)\n\t\t$.each(blobs, function(key, value){\n\t\t\tconsole.log(key);\n\n\t\t\tvar fd = new FormData();\n\t\t\tfd.append('file_num', file_num); //切片总数\n\t\t\tfd.append('index', key+1); //切片份数\n \t\t\tfd.append('file', value); //切片分成的blob对象\n\t\t\tfd.append('file_name', file_name); //文件名称\n\t\t\t$.ajax({\n                type: 'POST',\n\t\t\t\turl: './upload.php',\n\t\t\t\tdata: fd,\n\t\t\t\tprocessData: false,\n\t\t\t\tcontentType: false,\n                dataType: \"json\",   // 预期返回一个 json 类型数据\n                success: function (data) {   // data是形参名，代表返回的数据\n                    console.log(data.code);\n\n\t\t\t\t\tif(data.code == 1){\n\t\t\t\t\t\tvar old_time = new Date();\n\t\t\t\t\t\tvar difftime = (old_time - cur_time) / 1000; //秒\n\t\t\t\t\t\talert('文件上传完成，使用时间 '+difftime+'s');\n\t\t\t\t\t}\n                }\n            });\n\t\t})\n    })\n\n    &lt;/script&gt;\n\n    &lt;script type=\"text/javascript\"&gt;\n    \t\n\n    &lt;/script&gt;\n\n&lt;/html&gt;</code></pre>\n<p>后端代码（upload.php）：</p>\n<pre><code>&lt;?php\nheader('content-type:text/html;charset=utf-8');\nini_set('memory_limit', -1);\nini_set('max_execution_time', 0);\n\n\n$file = $_FILES['file'];\n$data = $_POST;\n\n$index = $data['index'];\n$file_num = $data['file_num'];\n$file_name = $data['file_name'];\n\n$file_path = './file/';\n\n//判断切片份数与切片总数相等后，将切片生成上传文件\nif($index != $file_num){\n\tmove_uploaded_file($file['tmp_name'], $file_path.$file_name.'_'.$index);\n\techo json_encode(['code'=&gt;2, 'msg'=&gt;'切片上传成功']);\n\texit;\n}else{\n\tmove_uploaded_file($file['tmp_name'], $file_path.$file_name.'_'.$index);\n\n\t$newData = '';\n\tfor($i=1; $i&lt;=$file_num; $i++){\n\t\t$newData .= file_get_contents($file_path.$file_name.'_'.$i);\n\t\tunlink($file_path.$file_name.'_'.$i);\n\t}\n\tfile_put_contents($file_path.$file_name, $newData);\n\techo json_encode(['code'=&gt;1, 'msg'=&gt;'切片全部上传完毕，并生成文件']);\n\texit;\n}</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 1, "time": "2022-07-19 11:02:23", "summary": "一、中对象介绍对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成来用于数据操作。表示的不一定是原生格式的数据。接口基于，继承了的功能并将其扩展使其支持用户"}