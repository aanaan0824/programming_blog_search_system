{"blogid": "121639962", "writerAge": "码龄1年", "writerBlogNum": "12", "writerCollect": "274", "writerComment": "57", "writerFan": "1225", "writerGrade": "2级", "writerIntegral": "340", "writerName": "噜噜噜噜鲁先生", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121639962.jpg", "writerRankTotal": "39646", "writerRankWeekly": "5248", "writerThumb": "109", "writerVisitNum": "13322", "blog_read_count": "5783", "blog_time": "已于 2022-06-14 09:58:29 修改", "blog_title": "Java链表详解--通俗易懂(超详细,含源码)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB\">链表的分类</a></p>\n<p id=\"%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84\">链表的结构</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8\">代码实现链表</a></p>\n<p id=\"1.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%B1%BB\">1.创建节点类</a></p>\n<p id=\"2.%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8\">2.创建链表</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%95%A5%E7%AE%80%E5%8D%95%EF%BC%8C%E7%95%A5low%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%95%A5%E7%AE%80%E5%8D%95%EF%BC%8C%E7%95%A5low%EF%BC%89\">方法一：枚举法</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95public%20void%20addFirst(int%20data)-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95public%20void%20addFirst%28int%20data%29\">方法二：头插法public void addFirst(int data)</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95public%20void%20addLast(int%20data)-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95public%20void%20addLast%28int%20data%29\">方法三：尾插法public void addLast(int data)</a></p>\n<p id=\"3.%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20display()-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20display%28%29\">3.打印链表：public void display()</a></p>\n<p id=\"4.%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97key%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%93%E4%B8%AD%EF%BC%9Apublic%20boolean%20contains(int%20key)-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97key%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%93%E4%B8%AD%EF%BC%9Apublic%20boolean%20contains%28int%20key%29\">4.查找是否包含关键字key是否在单链表当中：public boolean contains(int key)</a></p>\n<p id=\"5.%E5%BE%97%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9Apublic%20int%20Size()-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E5%BE%97%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9Apublic%20int%20Size%28%29\">5.得到单链表的长度：public int Size()</a></p>\n<p id=\"6.%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%2C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%B8%BA0%E5%8F%B7%E4%B8%8B%E6%A0%87%EF%BC%9Apublic%20boolean%20addIndex(int%20index%2Cint%20data)-toc\" style=\"margin-left:40px;\"><a href=\"#6.%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%2C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%B8%BA0%E5%8F%B7%E4%B8%8B%E6%A0%87%EF%BC%9Apublic%20boolean%20addIndex%28int%20index%2Cint%20data%29\">6.任意位置插入,第一个数据节点为0号下标：public boolean addIndex(int index,int data)</a></p>\n<p id=\"7.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20remove(int%20key)-toc\" style=\"margin-left:40px;\"><a href=\"#7.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20remove%28int%20key%29\">7.删除第一次出现关键字为key的节点：public void remove(int key)</a></p>\n<p id=\"8.%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20removeAllKey(int%20key)-toc\" style=\"margin-left:40px;\"><a href=\"#8.%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20removeAllKey%28int%20key%29\">8.删除所有值为key的节点：public void removeAllKey(int key)</a></p>\n<p id=\"9.%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20clear()-toc\" style=\"margin-left:40px;\"><a href=\"#9.%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20clear%28%29\">9.清空链表：public void clear()</a></p>\n<p id=\"%E6%BA%90%E7%A0%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%BA%90%E7%A0%81\">源码</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E6%A6%82%E5%BF%B5\">概念</h1>\n<p>链表(linked list)：是一种物理存储结构上非连续<strong><span style=\"background-color:#ff9900;\">存储结构</span></strong>，数据元素的逻辑顺序是通过链表中的引用链接次序实现的.</p>\n<p>链表由一系列<strong>结点</strong>（<span style=\"background-color:#ff9900;\">链表中每一个元素称为结点</span>）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的<strong><span style=\"color:#fe2c24;\">数据域</span></strong>，另一个是存储下一个结点地址的<strong><span style=\"color:#fe2c24;\">指针域</span></strong>。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>\n<h1 id=\"%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB\">链表的分类</h1>\n<ul><li>单向链表，双向链表</li><li>带头链表，不带头链表</li><li>循环的，非循环的</li></ul>\n<p>排列组合后一共有</p>\n<p style=\"text-align:center;\"><img alt=\"C_{2}^{1}*C_{2}^{1}*C_{2}^{1}=8\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?C_%7B2%7D%5E%7B1%7D*C_%7B2%7D%5E%7B1%7D*C_%7B2%7D%5E%7B1%7D%3D8\"/></p>\n<p>即一共8种链表，其中单向、不带头、非循环以及双向、不带头、非循环的链表最为重要，也是本文主要介绍的链表类型。</p>\n<h1 id=\"%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84\">链表的结构</h1>\n<p>对于链表的结构，可以用如下这个图来<span style=\"background-color:#a2e043;\">模拟</span>。</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"412\" src=\"..\\..\\static\\image\\d3c011b6cbf949c1b701c89801f4efb2.png\" width=\"379\"/></p>\n<p>图中所示的为链表的一个节点，value是这个节点的所存储的数据值，next为下一节点的地址。</p>\n<p>下面是一个5个节点的链表。</p>\n<p><img alt=\"\" height=\"355\" src=\"..\\..\\static\\image\\6b4b9911dfe24e5fb57a57dfddc37f60.png\" width=\"1200\"/></p>\n<p>接下来，我们来实现这样的链表的<strong><span style=\"background-color:#a2e043;\">增删查改</span></strong>：</p>\n<p><img alt=\"\" height=\"474\" src=\"..\\..\\static\\image\\af841ac2e5bf455994f6f2471893081d.png\" width=\"1200\"/></p>\n<p>第一个节点，地址假设是0x999，存储的数据是11，next存储的是下一个节点的地址(假设是0x888)</p>\n<p>第二个节点，地址假设是0x888，存储的数据是22，next存储的是下一个节点的地址(假设是0x777)</p>\n<p>第三个节点，地址假设是0x777，存储的数据是33，next存储的是下一个节点的地址(假设是0x666)</p>\n<p>第四个节点，地址假设是0x666，存储的数据是44，next存储的是下一个节点的地址(假设是0x555)</p>\n<p>第五个节点，地址假设是0x555，存储的数据是55，由于没有后续节点，next存储的是空指针null</p>\n<p>定义一个head，存储头节点（第一个节点）的地址（假设为0x999）。</p>\n<h1 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8\">代码实现链表</h1>\n<h2 id=\"1.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%B1%BB\">1.创建节点类</h2>\n<p>节点由val域(<span style=\"color:#fe2c24;\"><strong>数据域</strong></span>)，以及next域(<strong><span style=\"color:#fe2c24;\">指针域</span></strong>)组成，对于next域，其是引用类型，存放下一个节点的地址，故</p>\n<p> 用public ListNode next来创建next。</p>\n<p>同时设置构造函数，方便对val进行初始化。</p>\n<pre><code class=\"language-java\">//ListNode代表一个节点\nclass ListNode{\n    public int val;\n    public ListNode next;\n\n    //构造函数\n    public ListNode(int a){\n        this.val = a;\n    }\n}</code></pre>\n<h2 id=\"2.%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8\">2.创建链表</h2>\n<ul><li> <h3 id=\"%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%95%A5%E7%AE%80%E5%8D%95%EF%BC%8C%E7%95%A5low%EF%BC%89\">方法一：枚举法（略简单，略low）</h3> </li></ul>\n<pre><code class=\"language-java\">public class MyLinkedList {\n\n    public ListNode head;//链表的头\n\n    public void creatList(){\n        ListNode listNode1 = new ListNode(11);\n        ListNode listNode2 = new ListNode(22);\n        ListNode listNode3 = new ListNode(33);\n        ListNode listNode4 = new ListNode(44);\n        ListNode listNode5 = new ListNode(55);\n\n        this.head = listNode1;\n\n        listNode1.next = listNode2;\n        listNode2.next = listNode3;\n        listNode3.next = listNode4;\n        listNode4.next = listNode5;\n\n    }\n}</code></pre>\n<p>直接进行val的赋值以及对next的初始化。</p>\n<p><strong>注意</strong>：不用对最后一个节点的next进行赋值，因为next是引用类型，不赋值则默认为null。</p>\n<ul><li> <h3 id=\"%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95public%20void%20addFirst(int%20data)\">方法二：头插法public void addFirst(int data)</h3> </li></ul>\n<p>头插法是指在链表的头节点的位置插入一个新节点，定义一个node表示该节点，然后就是对node的next进行赋值，用node.next = this.head即可完成（注意：head应指向新节点）</p>\n<p>代码实现</p>\n<pre><code class=\"language-java\">    public void addFirst(int data){\n        ListNode node = new ListNode(data);\n        node.next = this.head;\n        this.head = node;\n    }</code></pre>\n<ul><li> <h3 id=\"%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95public%20void%20addLast(int%20data)\">方法三：尾插法public void addLast(int data)</h3> </li></ul>\n<p>尾插法是指在链表的尾节点的位置插入一个新节点，定义一个node表示该节点，然后就是对原来最后一个节点的next进行赋值，先将head移动至原来最后一个节点，用head.next = node进行赋值（<strong>注意</strong>，如果链表不为空，需要定义cur来代替head）</p>\n<p>代码实现</p>\n<pre><code class=\"language-java\">    public void addLast(int data){\n        ListNode node = new ListNode(data);\n        if(this.head == null){\n            this.head = node;\n        }else {\n            ListNode cur = this.head;\n            while(cur.next != null){\n                cur = cur.next;\n            }\n            cur.next = node;\n        }\n    }</code></pre>\n<h2 id=\"3.%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20display()\">3.打印链表：public void display()</h2>\n<p>认识了链表的结构，我们可以知道，节点与节点之间通过next产生联系。并且我们已将创建了head，即头节点的地址，通过head的移动来实现链表的打印。</p>\n<p><strong>注意</strong>：为了使head一直存在且有意义，我们在display()函数中定义一个cur：ListNode cur = this.head;来替代head。</p>\n<p>对于head的移动，可用head = head.next来实现。</p>\n<p>代码实现：</p>\n<pre><code class=\"language-java\">    public void display(){\n        ListNode cur = this.head;\n        while(cur != null){\n            System.out.print(cur.val+\" \");\n            cur = cur.next;\n        }\n        System.out.println();\n    }</code></pre>\n<h2 id=\"4.%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97key%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%93%E4%B8%AD%EF%BC%9Apublic%20boolean%20contains(int%20key)\">4.查找是否包含关键字key是否在单链表当中：public boolean contains(int key)</h2>\n<p>查找key，可以利用head移动，实现对于key的查找（<strong>注意</strong>：同样要定义一个cur来代替head）</p>\n<p>代码实现</p>\n<pre><code class=\"language-java\">    public boolean contains(int key){\n        ListNode cur = this.head;\n        while(cur != null){\n            if(cur.val == key){\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }</code></pre>\n<h2 id=\"5.%E5%BE%97%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9Apublic%20int%20Size()\">5.得到单链表的长度：public int Size()</h2>\n<p>定义计数器count = 0，通过head的移动来判断链表长度（<strong>注意</strong>：同样要定义一个cur来代替head）</p>\n<p>代码实现</p>\n<pre><code class=\"language-java\">    public int Size(){\n        int count = 0;\n        ListNode cur = this.head;\n        while(cur != null){\n            count++;\n            cur = cur.next;\n        }\n        return count;\n    }</code></pre>\n<h2 id=\"6.%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%2C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%B8%BA0%E5%8F%B7%E4%B8%8B%E6%A0%87%EF%BC%9Apublic%20boolean%20addIndex(int%20index%2Cint%20data)\">6.任意位置插入,第一个数据节点为0号下标：public boolean addIndex(int index,int data)</h2>\n<p>比如，我们把一个值为1314，地址是0x520（设为node引用）的节点，即val域值为1314，next域为null，地址是520，将该节点插入至3号位置，</p>\n<p><img alt=\"\" height=\"632\" src=\"..\\..\\static\\image\\86742d9d78d1402abc9d0ce4de8490b0.png\" width=\"865\"/></p>\n<p></p>\n<p>经过分析，<strong><span style=\"background-color:#a2e043;\">需要将head先移至2号位置</span></strong>（<strong>注意</strong>：用cur代替head，防止head丢失），然后</p>\n<p><strong><span style=\"background-color:#a2e043;\">node.next = cur.next使该节点的next域改为下一节点的地址</span></strong>，再cur.next = node.next使前一节点</p>\n<p>的next域改为该节点的地址。</p>\n<pre><code class=\"language-java\">    public void addIndex(int index,int data){\n        if(index &lt; 0 ||index &gt; Size()){   //对index位置的合法性进行判断\n            return;\n        }\n        if(index == 0){          //相当于头插法\n            addFirst(data);\n            return;\n        }\n        if(index = Size()){      //相当于尾插法\n            addLast(data);\n            return;\n        }\n        ListNode cur = findIndex(index);//找到index位置前一位置的地址\n        ListNode node = new ListNode(data);//初始化node\n        node.next = cur.next;\n        cur.next = node;\n    }</code></pre>\n<h2 id=\"7.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20remove(int%20key)\">7.删除第一次出现关键字为key的节点：public void remove(int key)</h2>\n<p>对于删除第一次出现的key值的节点，若不是头节点，我们只需将key值对应的节点的前一节点的next的域改为key值对应的节点的next域即可。</p>\n<p>对于头节点，直接head = head.next即可。</p>\n<p>对于key值对应的节点的前一节点，我们可以写一个函数来找到它，方便后续的代码书写。</p>\n<pre><code class=\"language-java\">    //找到key的前驱（前一节点）\n    public ListNode searchPrev(int key){\n        ListNode cur = this.head;\n        while(cur.next != null){\n            if(cur.next.val == key){\n                return cur;\n            }\n            cur = cur.next;\n        }\n        return null;\n    }\n    //删除第一次出现关键字为key的节点\n    public void remove(int key){\n        if(this.head == null){\n            return;\n        }\n        if(this.head.val == key){\n            this.head = this.head.next;\n            return;\n        }\n        ListNode cur = searchPrev(key);\n        if(cur == null){\n            return;             //没有要删除的节点\n        }\n        ListNode del = cur.next;//定义要删除的节点\n        cur.next = del.next;\n    }</code></pre>\n<h2 id=\"8.%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20removeAllKey(int%20key)\">8.删除所有值为key的节点：public void removeAllKey(int key)</h2>\n<p>若要删除所有值为key的节点，其实我们只需<strong>多次调用</strong>上面所写的remove函数即可完成，<strong>但是，</strong></p>\n<p>若要达到面试难度，那么要求就是<span style=\"background-color:#ff9900;\">遍历一遍链表，删除所有值为key的节点。</span></p>\n<p></p>\n<p>情况一:key连续,如下(1,2,3节点)</p>\n<p><img alt=\"\" height=\"399\" src=\"..\\..\\static\\image\\9f1523fb4ea945ac904a83b86980369f.png\" width=\"898\"/></p>\n<p></p>\n<p>情况二:key不连续,如下(1,3节点)</p>\n<p><img alt=\"\" height=\"385\" src=\"..\\..\\static\\image\\6ae965510abe4fbfa2273df1c0c3aed6.png\" width=\"866\"/></p>\n<p>代码实现:</p>\n<pre><code class=\"language-java\">    public ListNode removeAllKey(int key){\n        if(this.head = null){\n            return null;\n        }\n        ListNode prev = this.head;\n        ListNode cur = this.head.next;\n        while(cur != null){\n            if(cur.val == key){\n                prev.next = cur.next;\n                cur = cur.next;\n            }else {\n                prev = cur;\n                cur = cur.next;\n            }\n        }\n        if(this.head.val == key){\n            this.head = this.head.next;\n        }\n        return this.head;\n    }</code></pre>\n<p></p>\n<h2 id=\"9.%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20clear()\">9.清空链表：public void clear()</h2>\n<p>1.简单粗暴的方法：将头节点置为空head = null；即可</p>\n<p>2.细腻温柔的做法：将每一个节点都置为空</p>\n<pre><code class=\"language-java\">    public void clear(){\n        while(this.head != null){\n            ListNode curNext = this.head.next;\n            this.head.next = null;\n            this.head = curNext;\n        }\n    }</code></pre>\n<h1 id=\"%E6%BA%90%E7%A0%81\">源码</h1>\n<pre><code class=\"language-java\">import java.util.List;\n\n\n//ListNode代表一个节点\nclass ListNode{\n    public int val;\n    public ListNode next;\n\n    //构造函数\n    public ListNode(int a){\n        this.val = a;\n    }\n}\npublic class MyLinkedList {\n\n    public ListNode head;//链表的头\n\n    public void creatList() {\n        ListNode listNode1 = new ListNode(11);\n        ListNode listNode2 = new ListNode(22);\n        ListNode listNode3 = new ListNode(33);\n        ListNode listNode4 = new ListNode(44);\n        ListNode listNode5 = new ListNode(55);\n\n        this.head = listNode1;\n\n        listNode1.next = listNode2;\n        listNode2.next = listNode3;\n        listNode3.next = listNode4;\n        listNode4.next = listNode5;\n\n    }\n\n    //头插法\n    public void addFirst(int data) {\n        ListNode node = new ListNode(data);\n        node.next = this.head;\n        this.head = node;\n        /*if(this.head == null){\n            this.head = node;\n        }else{\n            node.next = this.head;\n            this.head = node;\n        }*/\n    }\n\n    //尾插法\n    public void addLast(int data) {\n        ListNode node = new ListNode(data);\n        if (this.head == null) {\n            this.head = node;\n        } else {\n            ListNode cur = this.head;\n            while (cur.next != null) {\n                cur = cur.next;\n            }\n            cur.next = node;\n        }\n    }\n\n    //打印顺序表\n    public void display() {\n        ListNode cur = this.head;\n        while (cur != null) {\n            System.out.print(cur.val + \" \");\n            cur = cur.next;\n        }\n        System.out.println();\n    }\n\n    //查找是否包含关键字key是否在单链表当中\n    public boolean contains(int key) {\n        ListNode cur = this.head;\n        while (cur != null) {\n            if (cur.val == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    //得到单链表的长度\n    public int Size() {\n        int count = 0;\n        ListNode cur = this.head;\n        while (cur != null) {\n            count++;\n            cur = cur.next;\n        }\n        return count;\n    }\n\n    //找到index位置的前一位置的地址\n    public ListNode findIndex(int index) {\n        ListNode cur = head.next;\n        while (index - 1 != 0) {\n            cur = cur.next;\n            index--;\n        }\n        return cur;\n    }\n\n    //任意位置插入,第一个数据节点为0号下标\n    public void addIndex(int index, int data) {\n        if (index &lt; 0 || index &gt; Size()) {\n            return;\n        }\n        if (index == 0) {          //相当于头插法\n            addFirst(data);\n            return;\n        }\n        if (index == Size()) {      //相当于尾插法\n            addLast(data);\n            return;\n        }\n        ListNode cur = findIndex(index);//找到index位置前一位置的地址\n        ListNode node = new ListNode(data);//初始化node\n        node.next = cur.next;\n        cur.next = node;\n    }\n\n    //找到key的前驱（前一节点）\n    public ListNode searchPrev(int key) {\n        ListNode cur = this.head;\n        while (cur.next != null) {\n            if (cur.next.val == key) {\n                return cur;\n            }\n            cur = cur.next;\n        }\n        return null;\n    }\n\n    //删除第一次出现关键字为key的节点\n    public void remove(int key) {\n        if (this.head == null) {\n            return;\n        }\n        if (this.head.val == key) {\n            this.head = this.head.next;\n            return;\n        }\n        ListNode cur = searchPrev(key);\n        if (cur == null) {\n            return;             //没有要删除的节点\n        }\n        ListNode del = cur.next;//定义要删除的节点\n        cur.next = del.next;\n    }\n\n    //删除所有值为key的节点\n    public ListNode removeAllKey(int key) {\n        if (this.head = null) {\n            return null;\n        }\n        ListNode prev = this.head;\n        ListNode cur = this.head.next;\n        while (cur != null) {\n            if (cur.val == key) {\n                prev.next = cur.next;\n                cur = cur.next;\n            } else {\n                prev = cur;\n                cur = cur.next;\n            }\n        }\n        if (this.head.val == key) {\n            this.head = this.head.next;\n        }\n        return this.head;\n    }\n\n    //清空链表\n    public void clear() {\n        while (this.head != null) {\n            ListNode curNext = this.head.next;\n            this.head.next = null;\n            this.head = curNext;\n        }\n    }\n}\n</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-06-14 09:58:29", "summary": "目录概念链表的分类链表的结构代码实现链表创建节点类创建链表方法一：枚举法方法二：头插法方法三：尾插法打印链表：查找是否包含关键字是否在单链表当中：得到单链表的长度：任意位置插入第一个数据节点为号下标："}