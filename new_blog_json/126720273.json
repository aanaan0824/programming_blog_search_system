{"blogid": "126720273", "writerAge": "码龄4年", "writerBlogNum": "214", "writerCollect": "217", "writerComment": "44", "writerFan": "120", "writerGrade": "5级", "writerIntegral": "2877", "writerName": "没枕头我咋睡觉", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126720273.jpg", "writerRankTotal": "7448", "writerRankWeekly": "127843", "writerThumb": "104", "writerVisitNum": "116438", "blog_read_count": "105", "blog_time": "于 2022-09-06 11:25:36 发布", "blog_title": "Go语言学习日记【三十二】golang代码错误处理【error，defer，recover】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3>前言：</h3>\n<p>        代码异常处理是学习任何编程语言都需要考虑的一个重要话题。比如C++，python都引入exception的概念和try_catch  try_except的引入。golang自然也有自己独特的异常处理方式。漂亮的异常处理方式也是golang语言最大的亮点之一，下面重点解析一下golang错误处理方式。</p>\n<h3>一、error接口</h3>\n<p>       Go语言引入了一个关于错误处理的标准模式，即 error 接口，该接口的定义如下：</p>\n<pre><code class=\"language-Go\">type error interface {\n    Error() string\n}</code></pre>\n<p>         在golang代码中，对于大多数函数，如果要返回错误，大致上都可以定义为如下模式</p>\n<pre><code class=\"language-Go\">func myFunc(param string)(str string, err error) {\n    // ...\n}</code></pre>\n<p>         将 error 作为多种返回值中的最后一个，但这并非是强制要求</p>\n<p>         调用时的代码建议按如下方式处理错误情况        </p>\n<pre><code class=\"language-Go\">_, err := myTest(\"test\")\nif err != nil {\n    // 错误处理\n} else {\n    // ......\n}</code></pre>\n<p>        同时，在代码中，我们可以自定义error类型，举例如下</p>\n<pre><code class=\"language-Go\">type DefineError struct {\n    Define string\n    Err error\n}\n\n// 定义Error函数\nfunc (d *DefineError) Error() string {\n    return d.Define + d.Err.Error()\n}\n\n</code></pre>\n<p>       这样，当函数调用失败返回 err 时，将该 err 包装到一个 DefineError 对象中返回</p>\n<pre><code class=\"language-Go\">func Stat() (err error) {\n    err = myFunc()\n    if err != nil {\n        return nil, &amp;DefineError{\"define\", err}\n    }\n    // ......\n}</code></pre>\n<h3>二、defer</h3>\n<p>        在函数编写过程中，有时引入异常会导致代码异常退出，但是，之前打开的诸如文件句柄这些操作如果不关闭，会导致程序在运行过程中出现问题。而在golang语言中，通过defer关键字轻轻松松的解决了这个问题。</p>\n<p>        代码示例：</p>\n<pre><code class=\"language-Go\">package main\n\nimport \"fmt\"\n\nfunc main()  {\n    defer fmt.Println(\"main defer:1\")\n    defer fmt.Println(\"main defer:2\")\n    fmt.Println(\"main --:1\")\n    panic(\"--- error ---\")\n    fmt.Println(\"main --:2\")\n    defer fmt.Println(\"main defer:5\")\n    defer fmt.Println(\"main defer:6\")\n}\n\n\n/*\nmain --:1\nmain defer:2\nmain defer:1\npanic: --- error ---\n\ngoroutine 1 [running]:\nmain.main()\n*/</code></pre>\n<p>        通过代码测试可以看出，当程序出现异常时，程序异常部分下面的代码将不再执行，而异常上面部分的defer代码，将在异常抛出后逆序执行。因此，当我们把要执行的句柄操作通过defer放在函数起始位置，无论程序执行是否异常，句柄关闭操作都能在程序里安全执行。</p>\n<h3>三、panic与recover</h3>\n<p>        <strong>panic</strong>：在函数中如果书写并触发了panic语句，会终止其后要执行的代码。在panic所在函数内如果存在要执行的defer函数列表，则按照defer书写顺序的逆序执行，同时，如果该函数被其他函数调用，则调用函数在调用代码后面的代码都不会执行，如果存在defer语句，一样逆序执行。在代码最后，则抛出panic异常。代码示例：</p>\n<pre><code class=\"language-Go\">package main\n\nimport \"fmt\"\n\nfunc main()  {\n    defer fmt.Println(\"main defer:1\")\n    defer fmt.Println(\"main defer:2\")\n    fmt.Println(\"main --:1\")\n    myTest()\n    fmt.Println(\"main --:2\")\n    defer fmt.Println(\"main defer:5\")\n    defer fmt.Println(\"main defer:6\")\n}\n\nfunc myTest() {\n    defer fmt.Println(\"myTest defer:1\")\n    defer fmt.Println(\"myTest defer:2\")\n    fmt.Println(\"myTest --:1\")\n    panic(\"manaual error\")\n    defer fmt.Println(\"myTest defer:4\")\n    defer fmt.Println(\"myTest defer:5\")\n}\n\n/*\nmain --:1\nmyTest --:1\nmyTest defer:2\nmyTest defer:1\nmain defer:2\nmain defer:1\npanic: manaual error\n\ngoroutine 1 [running]:\nmain.myTest()\n\tD:/code/go/go/01-错误演示.go:19 +0x165\nmain.main()\n\tD:/code/go/go/01-错误演示.go:9 +0x173\n\nProcess finished with exit code 2\n*/</code></pre>\n<p>      recover:</p>\n<ol><li>recover的作用是捕获panic，从而恢复正常代码执行；</li><li>recover必须配合defer使用；</li><li>recover没有传入参数，但是有返回值，返回值就是panic传递的值</li></ol>\n<p>     代码示例：</p>\n<pre><code class=\"language-Go\">package main\n\nimport \"fmt\"\n\nfunc main()  {\n    defer fmt.Println(\"main defer:1\")\n    defer fmt.Println(\"main defer:2\")\n    fmt.Println(\"main --:3\")\n    myTest()\n    fmt.Println(\"main --:4\")\n    defer fmt.Println(\"main defer:5\")\n    defer fmt.Println(\"main defer:6\")\n}\n\nfunc myTest() {\n    defer fmt.Println(\"---------------\")\n    defer func() {\n        if msg := recover(); msg != nil {\n            fmt.Println(\"panic信息:\", msg, \"---recover恢复---\")\n        }\n    }()\n    defer fmt.Println(\"myTest defer:1\")\n    defer fmt.Println(\"myTest defer:2\")\n    fmt.Println(\"myTest --:1\")\n    panic(\"manaual error\")\n    defer fmt.Println(\"myTest defer:4\")\n    defer fmt.Println(\"myTest defer:5\")\n}\n\n/*\nProcess finished with exit code 0\n\n*/</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 1, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 11:25:36", "summary": "前言：代码异常处理是学习任何编程语言都需要考虑的一个重要话题。比如，都引入的概念和的引入。自然也有自己独特的异常处理方式。漂亮的异常处理方式也是语言最大的亮点之一，下面重点解析一下错误处理方式。一、接"}