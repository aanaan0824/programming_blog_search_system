{"blogid": "124062485", "writerAge": "码龄2年", "writerBlogNum": "18", "writerCollect": "348", "writerComment": "136", "writerFan": "273", "writerGrade": "3级", "writerIntegral": "503", "writerName": "背锅切图仔", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124062485.jpg", "writerRankTotal": "78914", "writerRankWeekly": "361946", "writerThumb": "102", "writerVisitNum": "33403", "blog_read_count": "26970", "blog_time": "已于 2022-04-12 11:58:38 修改", "blog_title": "2022年第十三届蓝桥杯省赛C/C++B组个人题解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>2022年第十三届蓝桥杯省赛C/C++B组个人题解</h3>\n<ul><li><a href=\"#_A__1\">试题 A: 九进制转十进制（数学）</a></li><li><a href=\"#_B__14\">试题 B: 顺子日期（语文）</a></li><li><a href=\"#_C__63\">试题 C: 刷题统计（模拟）</a></li><li><ul><li><ul><li><a href=\"#_65\">【样例输入】</a></li><li><a href=\"#_69\">【样例输出】</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_D__126\">试题 D: 修剪灌木（找规律）</a></li><li><ul><li><a href=\"#_128\">【样例输入】</a></li><li><a href=\"#_132\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_E_X__226\">试题 E: X 进制减法（数学）</a></li><li><ul><li><a href=\"#_228\">【样例输入】</a></li><li><a href=\"#_236\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_F____293\">试题 F: 统计子矩阵（前缀和 + 双指针）</a></li><li><ul><li><a href=\"#_295\">【样例输入】</a></li><li><a href=\"#_302\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_G__398\">试题 G: 积木画（动态规划）</a></li><li><ul><li><a href=\"#_400\">【样例输入】</a></li><li><a href=\"#_404\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_H_BFS_448\">试题 H: 扫雷（BFS）</a></li><li><ul><li><a href=\"#_450\">【样例输入】</a></li><li><a href=\"#_457\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_I_DP___550\">试题 I: 李白打酒加强版（三维DP / 回溯）</a></li><li><ul><li><a href=\"#_552\">【样例输入】</a></li><li><a href=\"#_556\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_J__649\">试题 J: 砍竹子</a></li><li><ul><li><a href=\"#_651\">【样例输入】</a></li><li><a href=\"#_656\">【样例输出】</a></li></ul>\n</li><li><a href=\"#_664\">总结</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_A__1\"></a>试题 A: 九进制转十进制（数学）</h1>\n<p><img alt=\"A\" src=\"..\\..\\static\\image\\0d6ee64a4ce64c3aba2ca067cb2f4262.png\"/></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; \nusing namespace std;\n\nint main() {\n\tcout &lt;&lt; 2 * pow(9, 0) + 2 * pow(9, 1) + 0 * pow(9, 2) + 2 * pow(9, 3) &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<p>答案：1478</p>\n<h1><a id=\"_B__14\"></a>试题 B: 顺子日期（语文）</h1>\n<p><img alt=\"B\" src=\"..\\..\\static\\image\\c4f22219423b4478b39e77cc1a120f5f.png\"/><br/> 目前有很多争议，分为 3 种答案：4，5，14<br/> 我考试时写的答案是 5<br/> 不过我观察到网友更多的答案是 4<br/> 而比赛后当天晚上的蓝桥云课说的是 14（非官方）</p>\n<p>我来总结一下：</p>\n<p>第一种答案：5<br/> 看题，在说明 20220123时，说它出现了一个顺子：123。<br/> 所以可以认为是只有 123 这一个顺子，而 012 是不算顺子的。<br/> 然后在说明 20221023 时又涉及到了 210 这个逆着的顺子，但它说这不是一个顺子日期。因此认为这里更明确了 0 不可以被包括进去，而逆序的可以算是顺子。</p>\n<pre><code>20220123\n20220321\n20221123\n20221230\n20221231\n</code></pre>\n<p>第二种答案：4<br/> 即认为 012 和逆序的顺子（如 210）都不算是顺子，因此把上面的 20220321 去掉</p>\n<pre><code>20220123\n20221123\n20221230\n20221231\n</code></pre>\n<p>第三种答案：14<br/> 题目说的顺子是：连续的三个数字，并不是三位数。所以 012 也算是顺子。再由第二个例子 20221023 得知：210 这种逆序的不算顺子。<br/> <strong>如果要算上 012，那么第二个例子就把 210 这种逆序的给否掉啦</strong></p>\n<pre><code>20220120\n20220121\n20220122\n20220123\n20220124\n20220125\n20220126\n20220127\n20220128\n20220129\n20221012\n20221123\n20221230\n20221231\n</code></pre>\n<p>我目前也不知道正确答案，只能等官方解释吧<br/> orz</p>\n<h1><a id=\"_C__63\"></a>试题 C: 刷题统计（模拟）</h1>\n<p><img alt=\"C1\" src=\"..\\..\\static\\image\\94861c26039e48c6a59d0cb9f0f930a6.png\"/></p>\n<h3><a id=\"_65\"></a>【样例输入】</h3>\n<pre><code>10 20 99\n</code></pre>\n<h3><a id=\"_69\"></a>【样例输出】</h3>\n<pre><code>8\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4b324abf484e4e118bdcc14e5521432a.png\"/></p>\n<p>陷阱：注意 a, b, n 要用 long long 存<br/> 考试时写的代码：只考虑到了 n 要用 long long 存，竟然没用 long long 存 a, b，还没考虑到时间可能还会超限</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint cnt = 1;\n\tlong long n;\n\tint a, b;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; n;\n\tlong long sum = 0;\n\twhile (sum &lt; n) {\n\t\tif (cnt % 7 == 0 || cnt % 7 == 6) {\n\t\t\tsum += b;\n\t\t}\n\t\telse {\n\t\t\tsum += a;\n\t\t}\n\t\tcnt++;\n\t}\n\t// 当超出时退出while循环，所以答案需要减一。\n\tcout &lt;&lt; cnt - 1 &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<p>赛后优化代码：先取余再暴力</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tlong long a, b, n;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; n;\n\tint week = 5 * a + 2 * b;\n\tlong long ans = n / week * 7;\n\tn %= week;\n\tint sum = 0;\n\tfor (int i = 1; i &lt;= 7 &amp;&amp; sum &lt; n; i++) {\n\t\tif (i % 7 == 6 || i % 7 == 0) {\n\t\t\tsum += b;\n\t\t}\n\t\telse {\n\t\t\tsum += a;\n\t\t}\n\t\tans++;\n\t}\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n} \n</code></pre>\n<h1><a id=\"_D__126\"></a>试题 D: 修剪灌木（找规律）</h1>\n<p><img alt=\"D1\" src=\"..\\..\\static\\image\\63187f3649ed44dfa012b37223f6af0a.png\"/></p>\n<h2><a id=\"_128\"></a>【样例输入】</h2>\n<pre><code>3\n</code></pre>\n<h2><a id=\"_132\"></a>【样例输出】</h2>\n<pre><code>4\n2\n4\n</code></pre>\n<p><img alt=\"D2\" src=\"..\\..\\static\\image\\34d72c95588e4e6bac9d120f29b6fab2.png\"/><br/> 首先用暴力找规律，然后再根据规律简化代码</p>\n<pre><code>// 暴力代码：来回走两次。注意回的时候要把两个边界去掉。\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nconst int maxn = 1e4 + 100;\nint a[maxn];\nint maxHeight[maxn];\n\nint main() {\n\tint n;\n\twhile (cin &gt;&gt; n) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(maxHeight, 0, sizeof(maxHeight));\n\t\t\n\t\t// 来回走两次\n\t\tfor (int today = 0; today &lt; n; today++) {\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\ta[i]++;\n\t\t\t\tif (a[i] &gt; maxHeight[i]) {\n\t\t\t\t\tmaxHeight[i] = a[i];\n\t\t\t\t}\n\t\t\t\tif (i == today) {\n\t\t\t\t\ta[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int today = n - 2; today &gt; 0; today--) {\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\ta[i]++;\n\t\t\t\tif (a[i] &gt; maxHeight[i]) {\n\t\t\t\t\tmaxHeight[i] = a[i];\n\t\t\t\t}\n\t\t\t\tif (i == today) {\n\t\t\t\t\ta[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int today = 0; today &lt; n; today++) {\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\ta[i]++;\n\t\t\t\tif (a[i] &gt; maxHeight[i]) {\n\t\t\t\t\tmaxHeight[i] = a[i];\n\t\t\t\t}\n\t\t\t\tif (i == today) {\n\t\t\t\t\ta[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int today = n - 2; today &gt; 0; today--) {\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\ta[i]++;\n\t\t\t\tif (a[i] &gt; maxHeight[i]) {\n\t\t\t\t\tmaxHeight[i] = a[i];\n\t\t\t\t}\n\t\t\t\tif (i == today) {\n\t\t\t\t\ta[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tcout &lt;&lt; maxHeight[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl &lt;&lt; endl;\n\t}\n\treturn 0;\n}\n</code></pre>\n<p>结果如下：<br/> <img alt=\"D2\" src=\"..\\..\\static\\image\\0fb0527075c74992bf699c8c23a0d805.png\"/><br/> 通过找规律可以简化代码：</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin &gt;&gt; n;\n\tfor (int i = 0; i &lt; n; i++) {\n\t\tcout &lt;&lt; max(i, n - i - 1) * 2 &lt;&lt; endl; \n\t}\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"_E_X__226\"></a>试题 E: X 进制减法（数学）</h1>\n<p><img alt=\"E1\" src=\"..\\..\\static\\image\\0bffd8430fbd4a8da9b9612bc7869f2a.png\"/></p>\n<h2><a id=\"_228\"></a>【样例输入】</h2>\n<pre><code>11\n3\n10 4 0\n3\n1 2 0\n</code></pre>\n<h2><a id=\"_236\"></a>【样例输出】</h2>\n<pre><code>94\n</code></pre>\n<p><img alt=\"E2\" src=\"..\\..\\static\\image\\e13bd284fd3e46d69ca2de820fbedc51.png\"/><br/> 比赛时看了一个小时，读不懂题 <strong>orz…</strong><br/> 这题十分的抽象，很难理解</p>\n<p>这里先说明一下问题描述中的 321 是如何转换为 65 的<br/> 由题：个位是 2 进制，十位是 10 进制，百位是 8 进制。<br/> 题目第一行就说了：进制规定了数字在数位上逢几进一。意思是：<strong>个位每数 2 个，十位进 1，十位每数 10 个，百位进 1。</strong><br/> 首先定义结果 sum = 0<br/> ① 看个位：个位为 1，那么只需数一次即可到 1，然后让结果加上 1，即 <strong>sum += 1</strong><br/> ② 看十位：十位为 2，因为个位是二进制，所以十位要到 2 的话，就需要经过这样的变换：00 -&gt; 01 -&gt; 10 -&gt; 11 -&gt; 20。可以看出：十位每加 1，个位就需要变换 2 次，所以要使十位变成 2，则一共<strong>需要变换 2（十位的值） * 2（个位的进制） 次</strong>。然后让结果再加上它，即 <strong>sum += 2 * 2</strong><br/> ③ 看百位：百位为 3，根据十位的分析，同理得：要使百位变成 3，则<strong>需要变换 3（百位的值） * 10（十位的进制） * 2（个位的进制）次</strong>。然后让结果再加上它，即 <strong>sum += 3 * 10 * 2</strong><br/> 综上：321 转换为了 <strong>sum = 1 + 2 * 2 + 3 * 10 * 2 = 65</strong></p>\n<p>公式：<br/> A = ( a[n - 1] * X[n - 2] * X[n - 3] * … * X[0] ) + ( a[n - 2] * X[n - 3] * X[n - 4] * … * X[0] ) + … + a[0]<br/> B = ( b[n - 1] * X[n - 2] * X[n - 3] * … * X[0] ) + ( b[n - 2] * X[n - 3] * X[n - 4] * … * X[0] ) + … + b[0]<br/> A - B = (( a[n - 1] - b[n - 1] ) * X[n - 2] * X[n - 3] * … * X[0] ) + (( a[n - 2] - b[n - 2] ) * X[n - 3] * X[n - 4] * … * X[0] ) + ( a[0] - b[0] )<br/> 优化：（秦九韶算法）<br/> 设 d[n - 1] = a[n - 1] - b[n - 1]<br/> A - B = ((( d[n - 1] * X[n - 2] + d[n - 2] ) * X[n - 3] + d[n - 3] ) * X[n - 4] + … d[0] ) …</p>\n<p>代码：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int maxn = 1e5 + 100;\nint a[maxn];\nint b[maxn];\n\nint main() {\n\tint n, m1, m2, m;\n\tscanf(\"%d\", &amp;n);\n\tscanf(\"%d\", &amp;m1);\n\t// 逆序来存，确保让个位对齐，多余位置的值都是 0 \n\tfor (int i = m1 - 1; i &gt;= 0; i--) {\n\t\tscanf(\"%d\", &amp;a[i]);\n\t}\n\tscanf(\"%d\", &amp;m2);\n\tfor (int i = m2 - 1; i &gt;= 0; i--) {\n\t\tscanf(\"%d\", &amp;b[i]);\n\t}\n\tm = max(m1, m2);\n\tint res = 0;\n\tfor (int i = m - 1; i &gt;= 0; i--) {\n\t\tres = (res * max({ 2, a[i] + 1, b[i] + 1 }) % MOD + a[i] - b[i]) % MOD;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"_F____293\"></a>试题 F: 统计子矩阵（前缀和 + 双指针）</h1>\n<p><img alt=\"F1\" src=\"..\\..\\static\\image\\76881b800090400cad58f9dec3079fa1.png\"/></p>\n<h2><a id=\"_295\"></a>【样例输入】</h2>\n<pre><code>3 4 10\n1 2 3 4\n5 6 7 8\n9 10 11 12\n</code></pre>\n<h2><a id=\"_302\"></a>【样例输出】</h2>\n<pre><code>19\n</code></pre>\n<p><img alt=\"F2\" src=\"..\\..\\static\\image\\7cfed83172034c519ca96613be641f5d.png\"/><br/> <img alt=\"F3\" src=\"..\\..\\static\\image\\d9290607a3da4fca86c8c74949ea4409.png\"/><br/> <s>注意 k 已经超了 int 范围（虽然我到不了那就已经超时了，但还是要注意的）</s> 看错了看错了，k 的值是 2.5 * 10 ^ 8，而 int 的范围是 -21 4748 3648 ～ 21 4748 3647 (21 * 10 ^ 8)</p>\n<p>方法①：前缀和 + 双指针<br/> 首先求出每一列的前缀和，然后利用双指针将若干行切割开</p>\n<table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>\n<p><img alt=\"F4\" src=\"..\\..\\static\\image\\773a353886b8452ca6f380c259a88884.png\"/><br/> <img alt=\"F5\" src=\"..\\..\\static\\image\\d036f04957294a66bd699aceffdff1d3.png\"/></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int maxn = 505;\nint s[maxn][maxn];\n\nint main() {\n\tmemset(s, 0, sizeof(s));\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\n\tfor (int i = 1; i &lt;= n; i++) {\n\t\tfor (int j = 1; j &lt;= m; j++) {\n\t\t\tscanf(\"%d\", &amp;s[i][j]);\n\t\t\ts[i][j] += s[i - 1][j];\n\t\t}\n\t}\n\tint res = 0;\n\t// 上下边界\n\tfor (int up = 1; up &lt;= n; up++) {\n\t\tfor (int down = up; down &lt;= n; down++) {\n\t\t\tint sum = 0;\n\t\t\t// 左右边界\n\t\t\tfor (int left = 1, right = 1; right &lt;= m; right++) {\n\t\t\t\tsum += s[down][right] - s[up - 1][right];\n\t\t\t\twhile (sum &gt; k) {\n\t\t\t\t\tsum -= s[down][left] - s[up - 1][left];\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tres += right - left + 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n</code></pre>\n<p>方法②：暴力（过30%数据，比赛时不会做直接暴力 6 个 for！随便看看就好啦）</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint mat[550][550];\n\nint main() {\n\tint n, m;\n\tlong long k;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\tfor (int i = 1; i &lt;= n; i++) {\n\t\tfor (int j = 1; j &lt;= m; j++) {\n\t\t\tcin &gt;&gt; mat[i][j];\n\t\t}\n\t}\n\tlong long sum = 0;\n\tlong long cnt = 0;\n\tfor (int h1 = 1; h1 &lt;= n; h1++) {\n\t\tfor (int h2 = h1; h2 &lt;= n; h2++) {\n\t\t\tfor (int l1 = 1; l1 &lt;= m; l1++) {\n\t\t\t\tfor (int l2 = l1; l2 &lt;= m; l2++) {\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (int h = h1; h &lt;= h2; h++) {\n\t\t\t\t\t\tfor (int l = l1; l &lt;= l2; l++) {\n\t\t\t\t\t\t\tsum += mat[h][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sum &lt;= k) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout &lt;&lt; cnt &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"_G__398\"></a>试题 G: 积木画（动态规划）</h1>\n<p><img alt=\"G1\" src=\"..\\..\\static\\image\\1e03fe04814e40fdbfdb5ceca90703b8.png\"/></p>\n<h2><a id=\"_400\"></a>【样例输入】</h2>\n<pre><code>3\n</code></pre>\n<h2><a id=\"_404\"></a>【样例输出】</h2>\n<pre><code>5\n</code></pre>\n<p><img alt=\"G2\" src=\"..\\..\\static\\image\\da6a0593f88d4ed199b040e6d4e759c7.png\"/><br/> 陷阱：注意要<strong>取模取模取模</strong>，经常有人忘记这回事！！！<br/> （是的，比如说，我倒数第二题就忘记取模了。。。。。<br/> 这道题足足用了我三张白纸，我从 n = 1 画到了 n = 6，写了一个小时。<br/> 我认为 dp 就是找规律，可是，该死的是我 n = 6 的时候漏画了一种情况（三列横着的摆放），导致一直找不到规律。。。</p>\n<p>这道题的规律是，第 n 列可以通过前面的排列，再加上那几种基础的排列得到。<br/> 第一种情况：<br/> dp[n] 可以通过 dp[n - 1] 加上普通的一列得到<br/> 第二种情况：<br/> dp[n] 可以通过 dp[n - 2] 加上两块横的得到<br/> 第三种情况：<br/> dp[n] 可以通过 dp[n - 3] 加上两个三角形的堆起来得到，但要注意的是，<strong>这两个三角形的堆叠方式有两种</strong>，所以要加上两倍的 dp[n - 3]<br/> <strong>第四种情况：</strong>（我考试的时候给漏掉了555，<strong>不过我现在还是没考虑完整，待完善…</strong><br/> dp[n]可以通过 dp[n - 4] 加上由左右两个各一个三角形，中间若干个横块的组合得到，同第三种情况，这个组合可以倒过来，即有两种堆叠方式，因此要加上两倍的 dp[n - 4]<br/> 综上：dp[n] = dp[n - 1] + dp[n - 2] + dp[n - 3] * 2 + dp[n - 4] * 2 <strong>（错解，待完善）</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nconst int maxn = 1e7 + 100;\nlong long dp[maxn];\n\nint main() {\n\tint n;\n\tcin &gt;&gt; n;\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tdp[2] = 2;\n\tdp[3] = 5;\n\tfor (int i = 4; i &lt;= n; i++) {\n\t\t// 注意每次相加后都要取余\n\t\tdp[i] = (((((dp[i - 1] + dp[i - 2]) % MOD) + dp[i - 3] * 2) % MOD) + dp[i - 4] * 2) % MOD;\n\t}\n\tcout &lt;&lt; dp[n] &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"_H_BFS_448\"></a>试题 H: 扫雷（BFS）</h1>\n<p><img alt=\"H1\" src=\"..\\..\\static\\image\\26e8a6c9961047efb4a61db2b50d01e2.png\"/></p>\n<h2><a id=\"_450\"></a>【样例输入】</h2>\n<pre><code>2 1\n2 2 4\n4 4 2\n0 0 5\n</code></pre>\n<h2><a id=\"_457\"></a>【样例输出】</h2>\n<pre><code>2\n</code></pre>\n<p><img alt=\"H2\" src=\"..\\..\\static\\image\\6e2c7a6b040e43a08e60890eeecf63a8.png\"/><br/> 赛前半小时又专门看了眼 BFS，用上了！<br/> 陷阱①：一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。<br/> 陷阱②：有 m 个排雷火箭，但只要求在最后输出一个整数表示答案（我比赛时就输出了 m 次答案…）</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;cmath&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nconst int maxn = 50100;\n// 记录坐标和半径\nint x_pos[maxn];\nint y_pos[maxn];\nint radius[maxn];\nbool vis[maxn]; // 用来记录这个点爆炸了没有\n\n// 用于 bfs 的 struct，更方便处理\nstruct point {\n\tint x, y, r;\n\t// 将结构体放入 map 中，需要自己写一个 operator 来排序，因为 map 本身是有序的\n\tbool operator &lt; (const point&amp; p) const {\n\t\tif (x == p.x) {\n\t\t\tif (y == p.y) {\n\t\t\t\treturn r &lt; p.y;\n\t\t\t}\n\t\t\treturn y &lt; p.y;\n\t\t}\n\t\treturn x &lt; p.x;\n\t}\n};\n\nmap&lt;point, int&gt; all;\n\ndouble getDis(int x1, int y1, int x2, int y2) {\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint bfs(point begin, int n) {\n\tint cnt = 0;\n\tqueue&lt;point&gt; q;\n\tq.push(begin);\n\twhile (!q.empty()) {\n\t\tpoint cur = q.front();\n\t\tq.pop();\n\t\t// 遍历以 2 倍半径为边长的正方形，找到其爆炸所涉及到的炸雷\n\t\tfor (int i = cur.y - cur.r; i &lt;= cur.y + cur.r; i++) {\n\t\t\tfor (int j = cur.x - cur.r; j &lt;= cur.x + cur.r; j++) {\n\t\t\t\tif (getDis(j, i, cur.x, cur.y) &gt; cur.r) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpoint temp;\n\t\t\t\ttemp.y = i, temp.x = j;\n\t\t\t\tfor (int k = 0; k &lt; n; k++) {\n\t\t\t\t\tif (!vis[k] &amp;&amp; x_pos[k] == temp.x &amp;&amp; y_pos[k] == temp.y) {\n\t\t\t\t\t\ttemp.r = radius[k];\n\t\t\t\t\t\tq.push(temp);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tall[temp]--;\n\t\t\t\t\t\tvis[k] = true; // 标记为已爆炸\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i = 0; i &lt; n; i++) {\n\t\tcin &gt;&gt; x_pos[i] &gt;&gt; y_pos[i] &gt;&gt; radius[i];\n\t\tvis[i] = false; // 初始化都还没有爆炸\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i &lt; m; i++) {\n\t\tpoint p;\n\t\tcin &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.r;\n\t\t// 我比赛时输出了 m 次结果，裂开了\n\t\t// int cnt = 0;\n\t\tcnt += bfs(p, n);\n\t\t// cout &lt;&lt; cnt &lt;&lt; endl;\n\t}\n\tcout &lt;&lt; cnt &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"_I_DP___550\"></a>试题 I: 李白打酒加强版（三维DP / 回溯）</h1>\n<p><img alt=\"I1\" src=\"..\\..\\static\\image\\cc5f80bbfc844c94bd18d08470f90b79.png\"/></p>\n<h2><a id=\"_552\"></a>【样例输入】</h2>\n<pre><code>5 10\n</code></pre>\n<h2><a id=\"_556\"></a>【样例输出】</h2>\n<pre><code>14\n</code></pre>\n<p><img alt=\"I2\" src=\"..\\..\\static\\image\\834f4c0ce28549b8ba901fc10e717469.png\"/><br/> <img alt=\"I3\" src=\"..\\..\\static\\image\\aa7a2fab8ec64d66aa759be715346b1c.png\"/><br/> 泪目了，写题解发现 我 竟 然 <strong>忘记取模了忘记取模了忘记取模了</strong>5555555555<br/> <strong>大家一定要记得取模！！！</strong></p>\n<p>做法一：三维dp（赛后学习的优化方法）</p>\n<p>三个维度分别对应：走了多少步、经过了多少家酒馆，酒壶中还剩多少酒<br/> 在走到第 n 步时，他可能是从花走来的，也有可能是从酒馆走来的，所以要加上上一步遇到花的所有可能走法，再加上上一步遇到酒馆的所有可能走法。</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int maxn = 105; \nlong long dp[maxn][maxn][maxn] = { 0 };\n\nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\t// 初始化 dp\n\tdp[0][0][2] = 1;\n\tfor (int i = 1; i &lt;= n + m; i++) {\n\t\tfor (int j = 0; j &lt;= i; j++) {\n\t\t\tfor (int k = 0; k &lt;= 100; k++) {\n\t\t\t\t// 遇到了花后抵达第 i 步\n\t\t\t\tdp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k + 1]) % MOD;\n\t\t\t\t// 遇到了酒馆后抵达第 i 步\n\t\t\t\t// 当 k % 2 == 0 时才有可能是从酒馆走来的，因为经过酒馆后酒就加倍了\n\t\t\t\tif (j != 0 &amp;&amp; k % 2 == 0) {\n\t\t\t\t\tdp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - 1][k / 2]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout &lt;&lt; dp[n + m - 1][n][1] &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<p>做法二：回溯法（比赛时用的方法）</p>\n<p>年前和年后都练了一段时间的回溯，觉得特别有意思。<br/> 赛前半小时还专门看了一眼！！然后考试最后半个小时花了 20min 就写出来了。<br/> 本来一下子就写出框架了，不过太着急了，很多题目条件没看清楚，导致找了好久错误，不过还好，这题答案错了的话就是比正确答案大一些，很容易发现错误。</p>\n<p>主要错误如下：<br/> ① 一共必须要且仅要经过 N 次店，M 次花<br/> ② 最后一次遇到的必须是花<br/> ③ 最后遇到花后，酒必须喝光<br/> ④ 在中途遇到花时，酒不能为空</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvoid backTrack(vector&lt;char&gt;&amp; temp, vector&lt;vector&lt;char&gt; &gt;&amp; ans, int n, int m, int nn, int mm, int jiu) {\n\tif (jiu &lt; 0) return; // 如果遇到花却没酒了，则不符合条件\n\tif (nn &gt; n || mm &gt; m) return; // 如果经过了多于 N 次店、M 次花，则不符合条件\n\tif (temp.size() == n + m) {\n\t\tif (jiu == 0 &amp;&amp; temp.back() == '0') { // 如果最后到达的是店也不符合条件\n\t\t\tans.push_back(temp);\n\t\t}\n\t\treturn;\n\t}\n\t\n\ttemp.push_back('0');\n\tbackTrack(temp, ans, n, m, nn, mm + 1, jiu - 1);\n\ttemp.pop_back();\n\ttemp.push_back('1');\n\tbackTrack(temp, ans, n, m, nn + 1, mm, jiu * 2);\n\ttemp.pop_back();\n}\n\nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tint jiu = 2;\n\tvector&lt;char&gt; temp;\n\tvector&lt;vector&lt;char&gt; &gt; ans;\n\tbackTrack(temp, ans, n, m, 0, 0, jiu);\n\tcout &lt;&lt; ans.size() % MOD &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"_J__649\"></a>试题 J: 砍竹子</h1>\n<p><img alt=\"J1\" src=\"..\\..\\static\\image\\e5236704ebca4e07ad7ca8577d01995d.png\"/></p>\n<h2><a id=\"_651\"></a>【样例输入】</h2>\n<pre><code>6\n2 1 4 2 6 7\n</code></pre>\n<h2><a id=\"_656\"></a>【样例输出】</h2>\n<pre><code>5\n</code></pre>\n<p><img alt=\"J2\" src=\"..\\..\\static\\image\\c4da0fafb6cd47e884444d478cf57fd3.png\"/><br/> <img alt=\"J3\" src=\"..\\..\\static\\image\\b43587cd39b544bfa79984f3b2f2a502.png\"/><br/> 还剩最后十分钟，没时间做了，看了眼题也确实不会做。</p>\n<h1><a id=\"_664\"></a>总结</h1>\n<p>① 注意题目要求，记得取模！<br/> ② 注意范围，可能要用 long long<br/> ③ 不要在一道题卡太长时间，比如我在 E 题卡了一个小时都没看懂题，就应该早早换题，最后换换思路再回来看或许反而能看懂了</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-12 11:58:38", "summary": "年第十三届蓝桥杯省赛组个人题解试题九进制转十进制数学试题顺子日期语文试题刷题统计模拟样例输入样例输出试题修剪灌木找规律样例输入样例输出试题进制减法数学样例输入样例输出试题统计子矩阵前缀和双指针样例输入"}