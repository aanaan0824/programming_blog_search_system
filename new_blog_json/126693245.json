{"blogid": "126693245", "writerAge": "码龄7年", "writerBlogNum": "163", "writerCollect": "569", "writerComment": "242", "writerFan": "662", "writerGrade": "5级", "writerIntegral": "2055", "writerName": "tt姐", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126693245.jpg", "writerRankTotal": "9465", "writerRankWeekly": "253", "writerThumb": "255", "writerVisitNum": "60332", "blog_read_count": "364", "blog_time": "于 2022-09-04 19:35:16 发布", "blog_title": "嵌入式分享合集48", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>一、LCD驱动开发</p>\n<p>STM32开发板有很多配套LCD例程，如下图就是开发板上最常见的一种TFTLCD屏。商家会给封装好一些LCD函数，大家能学会如何点亮一个LCD。</p>\n<p><img alt=\"\" height=\"456\" src=\"..\\..\\static\\image\\3150f62005f84a5fbc88cd3658936a8e.png\" width=\"1004\"/></p>\n<p> </p>\n<p>    在主函数中加入上述代码就可以轻松实现下面输出字符串、画矩形块、清屏等效果。</p>\n<p>    但是这些例程代码或许有下面的问题：</p>\n<ul><li> <p>分层不清晰，通俗讲就是模块化太差</p> </li><li> <p>接口乱，只要接口不乱，分层就会好很多了</p> </li><li> <p>可移植性差</p> </li><li> <p>通用性差</p> </li></ul>\n<p>    为什么这样说呢？如果你已经了解了LCD的操作，请思考如下情景：</p>\n<ul><li> <p>代码空间不够，只能保留9341的驱动，其他LCD驱动全部删除。能一键（一个宏定义）删除吗？删除后要改多少地方才能编译通过？</p> </li><li> <p>有一个新产品，收银设备。系统有两个LCD，都是OLED，驱动IC相同，但是一个是128x64，另一个是128x32像素，一个叫做主显示，收银员用；一个叫顾显，顾客看金额。怎么办？这些例程代码要怎么改才能支持两个屏幕？全部代码复制粘贴然后改函数名称？这样确实能完成任务，只不过程序从此就进入恶性循环了。</p> </li><li> <p>一个OLED，原来接在这些IO，后来改到别的IO，容易改吗？</p> </li><li> <p>原来只是支持中文，现在要卖到南美，要支持多米尼加语言，好改吗？</p> </li></ul>\n<h2><strong>LCD种类概述</strong></h2>\n<p>    在讨论怎么写LCD驱动之前，我们先大概了解一下嵌入式常用LCD。概述一些跟驱动架构设计有关的概念，在此不对原理和细节做深入讨论，会有专门文章介绍，或者参考网络文档。</p>\n<p><strong>TFT lcd</strong></p>\n<p>    TFT LCD，也就是我们常说的彩屏。通常像素较高，例如常见的2.8寸，320X240像素。4.0寸的，像素800X400。这些屏通常使用并口，也就是8080或6800接口（STM32 的FSMC接口）；或者是RGB接口，STM32F429等芯片支持。其他例如手机上使用的有MIPI接口。</p>\n<p>    总之，接口种类很多。也有一些支持SPI接口的。除非是比较小的屏幕，否则不建议使用SPI接口，速度慢，刷屏闪屏。玩STM32常用的TFT lcd屏幕驱动IC通常有：ILI9341/ILI9325等。</p>\n<p>tft lcd：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\91ae5dbb5aecbcde26129e94e61041a4.png\"/></p>\n<p>IPS：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\1d2549c43acd91cc8398bdc85a4e8d19.jpeg\"/></p>\n<p>COG lcd</p>\n<p>    很多人可能不知道COG LCD是什么，我觉得跟现在开发板销售方向有关系，大家都出大屏，玩酷炫界面，对于更深的技术，例如软件架构设计，都不涉及。使用单片机的产品，COG LCD其实占比非常大。COG是Chip On Glass的缩写，就是驱动芯片直接绑定在玻璃上，透明的。实物像下图：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\3e8192553c1a49cb82b1d838bf3ad19d.jpeg\"/></p>\n<p>    这种LCD通常像素不高，常用的有128X64，128X32。一般只支持黑白显示，也有灰度屏。</p>\n<p>    接口通常是SPI，I2C。也有号称支持8位并口的，不过基本不会用，3根IO能解决的问题，没必要用8根吧？常用的驱动IC：STR7565。</p>\n<p><strong>OLED lcd</strong></p>\n<p>    买过开发板的应该基本用过。新技术，大家都感觉高档，在手环等产品常用。OLED目前屏幕较小，大一点的都很贵。在控制上跟COG LCD类似，区别是两者的显示方式不一样。从我们程序角度来看，最大的差别就是，OLED LCD，不用控制背光。。。。。实物如下图：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\dac0ca363533070e9635cf2306ac5deb.png\"/></p>\n<p>    常见的是SPI跟I2C接口。常见驱动IC：SSD1615。</p>\n<h2><strong>硬件场景</strong></h2>\n<p>    接下来的讨论，都基于以下硬件信息：</p>\n<p>1、有一个TFT屏幕，接在硬件的FSMC接口，什么型号屏幕？不知道。</p>\n<p>2、有一个COG lcd，接在几根普通IO口上，驱动IC是STR7565，128X32像素。</p>\n<p>3、有一个COG LCD，接在硬件SPI3跟几根IO口上，驱动IC是STR7565，128x64像素。</p>\n<p>4、有一个OLED LCD，接在SPI3上，使用CS2控制片选，驱动IC是SSD1315。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\2a39cf794e18c9f3674c5b2bcd339c76.jpeg\"/></p>\n<h2><strong>预备知识</strong></h2>\n<p>    在进入讨论之前，我们先大概说一下下面几个概念，对于这些概念，如果你想深入了解，请自行搜索，也可以加微信hplwbs拉你进群交流。</p>\n<p><strong>面向对象</strong></p>\n<p>    面向对象，是编程界的一个概念。什么叫面向对象呢？编程有两种要素：程序（方法），数据（属性）。例如：一个LED，我们可以点亮或者熄灭它，这叫方法。LED什么状态？亮还是灭？这就是属性。我们通常这样编程：</p>\n<pre><code>u8 ledsta = 0;</code><code>void ledset(u8 sta)</code><code>{<!-- --></code><code>}</code></pre>\n<p>    这样的编程有一个问题，假如我们有10个这样的LED，怎么写？这时我们可以引入面向对象编程，将每一个LED封装为一个对象。可以这样做：</p>\n<pre><code>/*</code><code>定义一个结构体，将LED这个对象的属性跟方法封装。</code><code>这个结构体就是一个对象。</code><code>但是这个不是一个真实的存在，而是一个对象的抽象。</code><code>*/</code><code>typedef struct{<!-- --></code><code>    u8 sta;</code><code>    void (*setsta)(u8 sta);</code><code>}LedObj;</code>\n<code>/*  声明一个LED对象，名称叫做LED1，并且实现它的方法drv_led1_setsta*/</code><code>void drv_led1_setsta(u8 sta)</code><code>{<!-- --></code><code>}</code>\n<code>LedObj LED1={<!-- --></code><code>        .sta = 0,</code><code>        .setsta = drv_led1_setsta,</code><code>    };</code>\n<code>/*  声明一个LED对象，名称叫做LED2，并且实现它的方法drv_led2_setsta*/</code><code>void drv_led2_setsta(u8 sta)</code><code>{<!-- --></code><code>}</code>\n<code>LedObj LED2={<!-- --></code><code>        .sta = 0,</code><code>        .setsta = drv_led2_setsta,</code><code>    };</code><code>    </code><code>/*  操作LED的函数，参数指定哪个led*/</code><code>void ledset(LedObj *led, u8 sta)</code><code>{<!-- --></code><code>    led-&gt;setsta(sta);</code><code>}</code></pre>\n<p>    是的，在C语言中，实现面向对象的手段就是结构体的使用。上面的代码，对于API来说，就很友好了。操作所有LED，使用同一个接口，只需告诉接口哪个LED。大家想想，前面说的LCD硬件场景。4个LCD，如果不面向对象，「显示汉字的接口是不是要实现4个」？每个屏幕一个？</p>\n<p><strong>驱动与设备分离</strong></p>\n<p>    如果要深入了解驱动与设备分离，请看LINUX驱动的书籍。</p>\n<p>    什么是设备？我认为的设备就是「属性」，就是「参数」，就是「驱动程序要用到的数据和硬件接口信息」。那么驱动就是「控制这些数据和接口的代码过程」。</p>\n<p>    通常来说，如果LCD的驱动IC相同，就用相同的驱动。有些不同的IC也可以用相同的，例如SSD1315跟STR7565，除了初始化，其他都可以用相同的驱动。例如一个COG lcd:</p>\n<blockquote>\n ❝ \n <p>驱动IC是STR7565 128 * 64 像素用SPI3背光用PF5 ,命令线用PF4 ,复位脚用PF3</p> ❞\n</blockquote>\n<p>    上面所有的信息综合，就是一个设备。驱动就是STR7565的驱动代码。</p>\n<p>    为什么要驱动跟设备分离，因为要解决下面问题：</p>\n<blockquote>\n ❝ \n <p>有一个新产品，收银设备。系统有两个LCD，都是OLED，驱动IC相同，但是一个是128x64，另一个是128x32像素，一个叫做主显示，收银员用；一个叫顾显，顾客看金额。</p> ❞\n</blockquote>\n<p>    这个问题，「两个设备用同一套程序控制」才是最好的解决办法。驱动与设备分离的手段：</p>\n<blockquote>\n ❝ \n <p>在驱动程序接口函数的参数中增加设备参数，驱动用到的所有资源从设备参数传入。</p> ❞\n</blockquote>\n<p>    驱动如何跟设备绑定呢？通过设备的驱动IC型号。</p>\n<p><strong>模块化</strong></p>\n<p>    我认为模块化就是将一段程序封装，提供稳定的接口给不同的驱动使用。不模块化就是，在不同的驱动中都实现这段程序。例如字库处理，在显示汉字的时候，我们要找点阵，在打印机打印汉字的时候，我们也要找点阵，你觉得程序要怎么写？把点阵处理做成一个模块，就是模块化。非模块化的典型特征就是「一根线串到底，没有任何层次感」。</p>\n<h2><strong>LCD到底是什么</strong></h2>\n<p>    前面我们说了面向对象，现在要对LCD进行抽象，得出一个对象，就需要知道LCD到底是什么。问自己下面几个问题：</p>\n<ul><li> <p>LCD能做什么？</p> </li><li> <p>要LCD做什么？</p> </li><li> <p>谁想要LCD做什么？</p> </li></ul>\n<p>    刚刚接触嵌入式的朋友可能不是很了解，可能会想不通。我们模拟一下LCD的功能操作数据流。APP想要在LCD上显示 一个汉字。</p>\n<p>    1、首先，需要一个显示汉字的接口，APP调用这个接口就可以显示汉字，假设接口叫做lcd_display_hz。</p>\n<p>    2、汉字从哪来？从点阵字库来，所以在lcd_display_hz函数内就要调用一个叫做find_font的函数获取点阵。</p>\n<p>    3、获取点阵后要将点阵显示到LCD上，那么我们调用一个ILL9341_dis的接口，将点阵刷新到驱动IC型号为ILI9341的LCD上。</p>\n<p>    4、ILI9341_dis怎么将点阵显示上去？调用一个8080_WRITE的接口。</p>\n<p>好的，这个就是大概过程，我们从这个过程去抽象LCD功能接口。汉字跟LCD对象有关吗？无关。在LCD眼里，无论汉字还是图片，都是一个个点。那么前面问题的答案就是：</p>\n<ul><li> <p>LCD可以一个点一个点显示内容。</p> </li><li> <p>要LCD显示汉字或图片-----就是显示一堆点</p> </li><li> <p>APP想要LCD显示图片或文字。</p> </li></ul>\n<p>    结论就是：所有LCD对象的功能就是显示点。「那么驱动只要提供显示点的接口就可以了，显示一个点，显示一片点。」 抽象接口如下：​​​​​​​</p>\n<pre><code>/*</code><code>    LCD驱动定义</code><code>*/</code><code>typedef struct  </code><code>{<!-- --></code><code>    u16 id;</code>\n<code>    s32 (*init)(DevLcd *lcd);</code><code>    s32 (*draw_point)(DevLcd *lcd, u16 x, u16 y, u16 color);</code><code>    s32 (*color_fill)(DevLcd *lcd, u16 sx,u16 ex,u16 sy,u16 ey, u16 color);</code><code>    s32 (*fill)(DevLcd *lcd, u16 sx,u16 ex,u16 sy,u16 ey,u16 *color);</code><code>    s32 (*onoff)(DevLcd *lcd, u8 sta);</code><code>    s32 (*prepare_display)(DevLcd *lcd, u16 sx, u16 ex, u16 sy, u16 ey);</code><code>    void (*set_dir)(DevLcd *lcd, u8 scan_dir);</code><code>    void (*backlight)(DevLcd *lcd, u8 sta);</code><code>}_lcd_drv;</code></pre>\n<p>    上面的接口，也就是对应的驱动，包含了一个驱动id号。</p>\n<ul><li> <p>id，驱动型号</p> </li><li> <p>初始化</p> </li><li> <p>画点</p> </li><li> <p>将一片区域的点显示某种颜色</p> </li><li> <p>将一片区域的点显示某些颜色</p> </li><li> <p>显示开关</p> </li><li> <p>准备刷新区域（主要彩屏直接DMA刷屏使用）</p> </li><li> <p>设置扫描方向</p> </li><li> <p>背光控制</p> </li></ul>\n<p>    显示字符，划线等功能，不属于LCD驱动。应该归类到GUI层。</p>\n<h2><strong>LCD驱动框架</strong></h2>\n<p>    我们设计了如下的驱动框架：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\3b68a3ce567932524a93bcbbc1511eaf.jpeg\"/></p>\n<p>    设计思路：</p>\n<p>    1、中间显示驱动IC驱动程序提供统一接口，接口形式如前面说的_lcd_drv结构体。</p>\n<p>    2、各显示IC驱动根据设备参数，调用不同的接口驱动。例如TFT就用8080驱动，其他的都用SPI驱动。SPI驱动只有一份，用IO口控制的我们也做成模拟SPI。</p>\n<p>    3、LCD驱动层做LCD管理，例如完成TFT LCD的识别。并且将所有LCD接口封装为一套接口。</p>\n<p>    4、简易GUI层封装了一些显示函数，例如划线、字符显示。</p>\n<p>    5、字体点阵模块提供点阵获取与处理接口。</p>\n<p>    由于实际没那么复杂，在例程中我们将GUI跟LCD驱动层放到一起。TFT LCD的两个驱动也放到一个文件，但是逻辑是分开的。OLED除初始化，其他接口跟COG LCD基本一样，因此这两个驱动也放在一个文件。</p>\n<h2><strong>代码分析</strong></h2>\n<p>    代码分三层：</p>\n<p>    1、GUI和LCD驱动层 dev_lcd.c dev_lcd.h</p>\n<p>    2、显示驱动IC层 dev_str7565.c &amp; dev_str7565.h dev_ILI9341.c &amp; dev_ILI9341.h</p>\n<p>    3、接口层 mcu_spi.c &amp; mcu_spi.h stm324xg_eval_fsmc_sram.c &amp; stm324xg_eval_fsmc_sram.h</p>\n<p><strong>GUI和LCD层</strong></p>\n<p>    这层主要有3个功能 ：</p>\n<p><strong>「1、设备管理」</strong></p>\n<p>    首先定义了一堆LCD参数结构体，结构体包含ID，像素。并且把这些结构体组合到一个list数组内。</p>\n<p><span style=\"background-color:#f3f4f5;color:#000000;font-family:'Source Code Pro', 'DejaVu Sans Mono', 'Ubuntu Mono', 'Anonymous Pro', 'Droid Sans Mono', Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;\">/* 各种LCD的规格参数*/</span></p>\n<pre><code>_lcd_pra LCD_IIL9341 ={<!-- --></code><code>        .id   = 0x9341,</code><code>        .width = 240,   //LCD 宽度</code><code>        .height = 320,  //LCD 高度</code><code>};</code><code>...</code><code>/*各种LCD列表*/</code><code>_lcd_pra *LcdPraList[5]=</code><code>            {<!-- --></code><code>                &amp;LCD_IIL9341,       </code><code>                &amp;LCD_IIL9325,</code><code>                &amp;LCD_R61408,</code><code>                &amp;LCD_Cog12864,</code><code>                &amp;LCD_Oled12864,</code><code>            };</code></pre>\n<p>    然后定义了所有驱动list数组，数组内容就是驱动，在对应的驱动文件内实现。​​​​​​​</p>\n<pre><code>/*  所有驱动列表</code><code>    驱动列表*/</code><code>_lcd_drv *LcdDrvList[] = {<!-- --></code><code>                    &amp;TftLcdILI9341Drv,</code><code>                    &amp;TftLcdILI9325Drv,</code><code>                    &amp;CogLcdST7565Drv,</code><code>                    &amp;OledLcdSSD1615rv,</code><code>                    }</code></pre>\n<p>    定义了设备树，即是定义了系统有多少个LCD，接在哪个接口，什么驱动IC。如果是一个完整系统，可以做成一个类似LINUX的设备树。​​​​​​​</p>\n<pre><code>/*设备树定义*/</code><code>#define DEV_LCD_C 3//系统存在3个LCD设备</code><code>LcdObj LcdObjList[DEV_LCD_C]=</code><code>{<!-- --></code><code>    {\"oledlcd\", LCD_BUS_VSPI, 0X1315},</code><code>    {\"coglcd\", LCD_BUS_SPI,  0X7565},</code><code>    {\"tftlcd\", LCD_BUS_8080, NULL},</code><code>};</code></pre>\n<p><strong>「2 、接口封装」</strong>​​​​​​​</p>\n<pre><code>void dev_lcd_setdir(DevLcd *obj, u8 dir, u8 scan_dir)</code><code>s32 dev_lcd_init(void)</code><code>DevLcd *dev_lcd_open(char *name)</code><code>s32 dev_lcd_close(DevLcd *dev)</code><code>s32 dev_lcd_drawpoint(DevLcd *lcd, u16 x, u16 y, u16 color)</code><code>s32 dev_lcd_prepare_display(DevLcd *lcd, u16 sx, u16 ex, u16 sy, u16 ey)</code><code>s32 dev_lcd_display_onoff(DevLcd *lcd, u8 sta)</code><code>s32 dev_lcd_fill(DevLcd *lcd, u16 sx,u16 ex,u16 sy,u16 ey,u16 *color)</code><code>s32 dev_lcd_color_fill(DevLcd *lcd, u16 sx,u16 ex,u16 sy,u16 ey,u16 color)</code><code>s32 dev_lcd_backlight(DevLcd *lcd, u8 sta)</code></pre>\n<p>    大部分接口都是对驱动IC接口的二次封装。有区别的是初始化和打开接口。初始化，就是根据前面定义的设备树，寻找对应驱动，找到对应设备参数，并完成设备初始化。打开函数，根据传入的设备名称，查找设备，找到后返回设备句柄，后续的操作全部需要这个设备句柄。</p>\n<p><strong>「3 、简易GUI层」</strong></p>\n<p>    目前最重要就是显示字符函数。</p>\n<pre><code>s32 dev_lcd_put_string(DevLcd *lcd, FontType font, int x, int y, char *s, unsigned colidx)</code></pre>\n<p>    其他划线画圆的函数目前只是测试，后续会完善。</p>\n<p><strong>驱动IC层</strong></p>\n<p>    驱动IC层分两部分：</p>\n<p><strong>「1 、封装LCD接口」</strong></p>\n<p>    LCD有使用8080总线的，有使用SPI总线的，有使用VSPI总线的。这些总线的函数由单独文件实现。但是，除了这些通信信号外，LCD还会有复位信号，命令数据线信号，背光信号等。我们通过函数封装，将这些信号跟通信接口一起封装为「LCD通信总线」， 也就是buslcd。BUS_8080在dev_ILI9341.c文件中封装。BUS_LCD1和BUS_lcd2在dev_str7565.c 中封装。</p>\n<p><strong>「2 驱动实现」</strong></p>\n<p>    实现_lcd_drv驱动结构体。每个驱动都实现一个，某些驱动可以共用函数。​​​​​​​</p>\n<pre><code>_lcd_drv CogLcdST7565Drv = {<!-- --></code><code>                            .id = 0X7565,</code>\n<code>                            .init = drv_ST7565_init,</code><code>                            .draw_point = drv_ST7565_drawpoint,</code><code>                            .color_fill = drv_ST7565_color_fill,</code><code>                            .fill = drv_ST7565_fill,</code><code>                            .onoff = drv_ST7565_display_onoff,</code><code>                            .prepare_display = drv_ST7565_prepare_display,</code><code>                            .set_dir = drv_ST7565_scan_dir,</code><code>                            .backlight = drv_ST7565_lcd_bl</code><code>                            };</code></pre>\n<p><strong>接口层</strong></p>\n<p>    8080层比较简单，用的是官方接口。SPI接口提供下面操作函数，可以操作SPI，也可以操作VSPI。​​​​​​​</p>\n<pre><code>extern s32 mcu_spi_init(void);</code><code>extern s32 mcu_spi_open(SPI_DEV dev, SPI_MODE mode, u16 pre);</code><code>extern s32 mcu_spi_close(SPI_DEV dev);</code><code>extern s32 mcu_spi_transfer(SPI_DEV dev, u8 *snd, u8 *rsv, s32 len);</code><code>extern s32 mcu_spi_cs(SPI_DEV dev, u8 sta);</code></pre>\n<p>    至于SPI为什么这样写，会有一个单独文件说明。</p>\n<p><strong>总体流程</strong></p>\n<p>    前面说的几个模块时如何联系在一起的呢？请看下面结构体：<span style=\"background-color:#f3f4f5;color:#000000;font-family:'Source Code Pro', 'DejaVu Sans Mono', 'Ubuntu Mono', 'Anonymous Pro', 'Droid Sans Mono', Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:14px;\">/* 初始化的时候会根据设备数定义，</span></p>\n<pre><code>    并且匹配驱动跟参数，并初始化变量。</code><code>    打开的时候只是获取了一个指针 */</code><code>struct _strDevLcd</code><code>{<!-- --></code><code>    s32 gd;//句柄，控制是否可以打开</code>\n<code>    LcdObj   *dev;</code><code>    /* LCD参数，固定，不可变*/</code><code>    _lcd_pra *pra;</code>\n<code>    /* LCD驱动 */</code><code>    _lcd_drv *drv;</code>\n<code>    /*驱动需要的变量*/</code><code>    u8  dir;    //横屏还是竖屏控制：0，竖屏；1，横屏。</code><code>    u8  scandir;//扫描方向</code><code>    u16 width;  //LCD 宽度</code><code>    u16 height; //LCD 高度</code>\n<code>    void *pri;//私有数据，黑白屏跟OLED屏在初始化的时候会开辟显存</code><code>};</code></pre>\n<p>    每一个设备都会有一个这样的结构体，这个结构体在初始化LCD时初始化。</p>\n<ul><li> <p>成员dev指向设备树，从这个成员可以知道设备名称，挂在哪个LCD总线，设备ID。</p> </li></ul>\n<pre><code>typedef struct</code><code>{<!-- --></code><code>    char *name;//设备名字</code><code>    LcdBusType bus;//挂在那条LCD总线上</code><code>    u16 id;</code><code>}LcdObj;</code></pre>\n<ul><li> <p>成员pra指向LCD参数，可以知道LCD的规格。</p> </li></ul>\n<pre><code>typedef struct</code><code>{<!-- --></code><code>    u16 id;</code><code>    u16 width;  //LCD 宽度  竖屏</code><code>    u16 height; //LCD 高度    竖屏</code><code>}_lcd_pra;</code></pre>\n<ul><li> <p>成员drv指向驱动，所有操作通过drv实现</p> </li></ul>\n<pre><code>typedef struct  </code><code>{<!-- --></code><code>    u16 id;</code>\n<code>    s32 (*init)(DevLcd *lcd);</code>\n<code>    s32 (*draw_point)(DevLcd *lcd, u16 x, u16 y, u16 color);</code><code>    s32 (*color_fill)(DevLcd *lcd, u16 sx,u16 ex,u16 sy,u16 ey, u16 color);</code><code>    s32 (*fill)(DevLcd *lcd, u16 sx,u16 ex,u16 sy,u16 ey,u16 *color);</code>\n<code>    s32 (*prepare_display)(DevLcd *lcd, u16 sx, u16 ex, u16 sy, u16 ey);</code>\n<code>    s32 (*onoff)(DevLcd *lcd, u8 sta);</code><code>    void (*set_dir)(DevLcd *lcd, u8 scan_dir);</code><code>    void (*backlight)(DevLcd *lcd, u8 sta);</code><code>}_lcd_drv;</code></pre>\n<ul><li> <p>成员dir、scandir、 width、 height是驱动要使用的通用变量。因为每个LCD都有一个结构体，一套驱动程序就能控制多个设备而互不干扰。</p> </li><li> <p>成员pri是一个私有指针，某些驱动可能需要有些比较特殊的变量，就全部用这个指针记录，通常这个指针指向一个结构体，结构体由驱动定义，并且在设备初始化时申请变量空间。目前主要用于COG LCD跟OLED LCD显示缓存。</p> </li></ul>\n<p>    整个LCD驱动，就通过这个结构体组合在一起。</p>\n<p>    1、初始化，根据设备树，找到驱动跟参数，然后初始化上面说的结构体。</p>\n<p>    2、要使用LCD前，调用dev_lcd_open函数。打开成功就返回一个上面的结构体指针。</p>\n<p>    3、显示字符，接口找到点阵后，通过上面结构体的drv，调用对应的驱动程序。</p>\n<p>    4、驱动程序根据这个结构体，决定操作哪个LCD总线，并且使用这个结构体的变量。</p>\n<h2><strong>用法和好处</strong></h2>\n<ul><li> <p>好处1</p> </li></ul>\n<p>    请看测试程序:​​​​​​​</p>\n<pre><code>void dev_lcd_test(void)</code><code>{<!-- --></code><code>    DevLcd *LcdCog;</code><code>    DevLcd *LcdOled;</code><code>    DevLcd *LcdTft;</code>\n<code>    /*  打开三个设备 */</code><code>    LcdCog = dev_lcd_open(\"coglcd\");</code><code>    if(LcdCog==NULL)</code><code>        uart_printf(\"open cog lcd err\\r\\n\");</code>\n<code>    LcdOled = dev_lcd_open(\"oledlcd\");</code><code>    if(LcdOled==NULL)</code><code>        uart_printf(\"open oled lcd err\\r\\n\");</code>\n<code>    LcdTft = dev_lcd_open(\"tftlcd\");</code><code>    if(LcdTft==NULL)</code><code>        uart_printf(\"open tft lcd err\\r\\n\");</code>\n<code>    /*打开背光*/</code><code>    dev_lcd_backlight(LcdCog, 1);</code><code>    dev_lcd_backlight(LcdOled, 1);</code><code>    dev_lcd_backlight(LcdTft, 1);</code>\n<code>    dev_lcd_put_string(LcdOled, FONT_SONGTI_1212, 10,1, \"ABC-abc，\", BLACK);</code><code>    dev_lcd_put_string(LcdOled, FONT_SIYUAN_1616, 1, 13, \"这是oled lcd\", BLACK);</code><code>    dev_lcd_put_string(LcdOled, FONT_SONGTI_1212, 10,30, \"www.wujique.com\", BLACK);</code><code>    dev_lcd_put_string(LcdOled, FONT_SIYUAN_1616, 1, 47, \"屋脊雀工作室\", BLACK);</code>\n<code>    dev_lcd_put_string(LcdCog, FONT_SONGTI_1212, 10,1, \"ABC-abc，\", BLACK);</code><code>    dev_lcd_put_string(LcdCog, FONT_SIYUAN_1616, 1, 13, \"这是cog lcd\", BLACK);</code><code>    dev_lcd_put_string(LcdCog, FONT_SONGTI_1212, 10,30, \"www.wujique.com\", BLACK);</code><code>    dev_lcd_put_string(LcdCog, FONT_SIYUAN_1616, 1, 47, \"屋脊雀工作室\", BLACK);</code>\n<code>    dev_lcd_put_string(LcdTft, FONT_SONGTI_1212, 20,30, \"ABC-abc，\", RED);</code><code>    dev_lcd_put_string(LcdTft, FONT_SIYUAN_1616, 20,60, \"这是tft lcd\", RED);</code><code>    dev_lcd_put_string(LcdTft, FONT_SONGTI_1212, 20,100, \"www.wujique.com\", RED);</code><code>    dev_lcd_put_string(LcdTft, FONT_SIYUAN_1616, 20,150, \"屋脊雀工作室\", RED);</code>\n<code>    while(1);</code><code>}</code></pre>\n<p>    使用一个函数dev_lcd_open，可以打开3个LCD，获取LCD设备。然后调用dev_lcd_put_string就可以在不同的LCD上显示。其他所有的gui操作接口都只有一个。这样的设计对于APP层来说，就很友好。显示效果：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\985c59d8f25569ad2529abbb7fdde42e.jpeg\"/></p>\n<ul><li> <p>好处2</p> </li></ul>\n<p>    现在的设备树是这样定义的:​​​​​​​</p>\n<pre><code>LcdObj LcdObjList[DEV_LCD_C]=</code><code>{<!-- --></code><code>    {\"oledlcd\", LCD_BUS_VSPI, 0X1315},</code><code>    {\"coglcd\", LCD_BUS_SPI,  0X7565},</code><code>    {\"tftlcd\", LCD_BUS_8080, NULL},</code><code>};</code></pre>\n<p>    某天，oled lcd要接到SPI上，只需要将设备树数组里面的参数改一下，就可以了，当然，在一个接口上不能接两个设备。​​​​​​​</p>\n<pre><code>LcdObj LcdObjList[DEV_LCD_C]=</code><code>{<!-- --></code><code>    {\"oledlcd\", LCD_BUS_SPI, 0X1315},</code><code>    {\"tftlcd\", LCD_BUS_8080, NULL},</code><code>};</code></pre>\n<h2><strong>字库</strong></h2>\n<p>    暂时不做细说，例程的字库放在SD卡中，各位移植的时候根据需要修改。具体参考font.c。</p>\n<p></p>\n<p>二、多层PCB</p>\n<p>内部什么样呢 今天来说一下</p>\n<p>硬件工程师刚接触多层PCB的时候，很容易看晕。动辄十层八层的，线路像蜘蛛网一样。</p>\n<p>    画了几张多层PCB电路板内部结构图，用立体图形展示各种叠层结构的PCB图内部架构。</p>\n<p><strong>高密度互联板(HDI)的核心 在过孔</strong></p>\n<p>    多层PCB的线路加工，和单层双层没什么区别，最大的不同在过孔的工艺上。</p>\n<p>    线路都是蚀刻出来的，过孔都是钻孔再镀铜出来的，这些做硬件开发的大家都懂，就不赘述了。</p>\n<p>    多层电路板，通常有通孔板、一阶板、二阶板、二阶叠孔板这几种。更高阶的如三阶板、任意层互联板平时用的非常少，价格贼贵，先不多讨论。</p>\n<p>    一般情况下，8位单片机产品用2层通孔板；32位单片机级别的智能硬件，使用4层-6层通孔板；Linux和Android级别的智能硬件，使用6层通孔至8一阶HDI板；智能手机这样的紧凑产品，一般用8层一阶到10层2阶电路板。</p>\n<p><strong>最常见的通孔</strong></p>\n<p>    只有一种过孔，从第一层打到最后一层。不管是外部的线路还是内部的线路，孔都是打穿的，叫做通孔板。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\d595d865afb8ceb8169d4f1ee41aa358.png\"/></p>\n<p>    通孔板和层数没关系，平时大家用的2层的都是通孔板，而很多交换机和军工电路板，做20层，还是通孔的。</p>\n<p>    用钻头把电路板钻穿，然后在孔里镀铜，形成通路。</p>\n<p>    这里要注意，通孔内径通常有0.2mm、0.25mm和0.3mm，但一般0.2mm的要比0.3mm的贵不少。因为钻头太细容易断，钻的也慢一些。多耗费的时间和钻头的费用，就体现在电路板价格上升上了。</p>\n<p><strong>高密度板(HDI板)的激光孔</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\91bd180d70f2dd77b12f095227176dd6.png\"/></p>\n<p>    这张图是6层1阶HDI板的叠层结构图，表面两层都是激光孔，0.1mm内径。内层是机械孔，相当于一个4层通孔板，外面再覆盖2层。</p>\n<p>    激光只能打穿玻璃纤维的板材，不能打穿金属的铜。所以外表面打孔不会影响到内部的其他线路。</p>\n<p>    激光打了孔之后，再去镀铜，就形成了激光过孔。</p>\n<p><strong>2阶HDI板 两层激光孔</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f06cdd43f85a1ea99977c2c65f457994.png\"/></p>\n<p>    上面这张图是一个6层2阶错孔HDI板。平时大家用6层2阶的少，大多是8层2阶起。这里更多层数，跟6层是一样的道理。</p>\n<p>    所谓2阶，就是有2层激光孔。</p>\n<p>    所谓错孔，就是两层激光孔是错开的。</p>\n<p>    为什么要错开呢？因为镀铜镀不满，孔里面是空的，所以不能直接在上面再打孔，要错开一定的距离，再打上一层的空。</p>\n<p>    6层二阶=4层1阶外面再加2层。</p>\n<p>    8层二阶=6层1阶外面再加2层。</p>\n<p><strong>叠孔板 工艺复杂价格更高</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\bd79e0b7e4028369ce6440de88140c36.png\"/></p>\n<p>    错孔板的两层激光孔重叠在一起。线路会更紧凑。</p>\n<p>    需要把内层激光孔电镀填平，然后在做外层激光孔。价格比错孔更贵一些。</p>\n<p><strong>超贵的任意层互联板 多层激光叠孔</strong></p>\n<p>    就是每一层都是激光孔，每一层都可以连接在一起。想怎么走线就怎么走线，想怎么打孔就怎么打孔。</p>\n<p>    Layout工程师想想就觉得爽！再也不怕画不出来了！</p>\n<p>    采购想想就想哭，比普通的通孔板贵10倍以上！</p>\n<p>    所以，也就只有iPhone这样的产品舍得用了。其他手机品牌，没听说谁用过任意层互联板。</p>\n<p><strong>总结</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\be566ada925c02a3c2a8951ca88ffccd.png\"/></p>\n<p>    最后放张图，再仔细对比一下吧。</p>\n<p>    请注意观察孔的大小，以及孔的焊盘是封闭的还是开放的</p>\n<p></p>\n<p>三、ESP8266无人机</p>\n<p>有点丑 有点low哈 哈哈 不要笑话</p>\n<p><strong>所需部件</strong></p>\n<p>    让我们先来看看制作无人机需要的东西：</p>\n<p>​​​​​​​       ESP8266</p>\n<ul><li> <p>MPU6050 Acc/Gyro模块</p> </li><li> <p>有刷电机</p> </li><li> <p>螺旋桨</p> </li><li> <p>500 mAh lipo3.7v</p> </li><li> <p>Si2302mosfet (5x)</p> </li><li> <p>铅笔</p> </li><li> <p>电烙铁</p> </li></ul>\n<p>    如果你是电子爱好者，你会发现下面列出的所有部件你都有。</p>\n<p>    一架无人机需要有机架、电机、螺旋桨、电动马达、飞行控制器、电池组成。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f7738a5f554eff629a0cd0eba7e0bba2.png\"/></p>\n<p><br/><strong>飞行控制器</strong><br/>     飞行控制器（又称FC）是飞机的大脑。它是一块电路板，上面有一系列的传感器，可以检测无人机的运动，以及用户的命令。如果你告诉它往前走，飞行控制器将调整后部电机的转速，使它往前走。<br/><strong>ESP8266模块</strong><br/>     为了与无人机通信，我们需要蓝牙或WIFI连接，所以我们使用ESP8266 Wi-Fi模块，因为它有内置的Wi-Fi，我们可以使用它进行通信。<br/>     ESP8266开源、互动、可编程、低成本、简单、智能、最低成本的Wi-Fi硬件。<br/>     至于无人机的飞行范围。测试已经得到了范围大约是70米，使用三星手机充当WiFi热点和远程控制器。<br/><strong>MPU6050</strong><br/>     MPU6050 IMU，一个低成本的设备，包含陀螺仪和加速计。<br/>     我们将使用MPU-6050和ESP8266模块来做一个无人机。<br/><strong>无铁芯电机</strong><br/>     无铁芯电机是用于四旋翼飞机和无人机的微型电机，这些电机是无铁芯的，即在转子中没有金属芯，无铁芯电机可以在较小的负载下达到较高的转速。这些电机适用于微型无人机、四旋翼飞机或迷你项目。<br/><strong>螺旋桨</strong><br/>     螺旋桨的目的是产生推力和扭矩以保持无人机飞行。<br/>     ESP8266无人机飞行控制器的原理图：<br/><br/>     如上，基于ESP12e（ESP8266）的接收器控制模块示意图。</p>\n<p></p>\n<p><strong>组装无人机</strong></p>\n<p><strong>电路连接</strong><br/>     按照上图中的原理图连接电路，注意每个部件的连接细节。<img alt=\"\" height=\"612\" src=\"..\\..\\static\\image\\7911e543a3e64bb7b508155980f56b83.png\" width=\"928\"/></p>\n<p> <br/><br/><strong>机架</strong><br/>     机架提供了结构和刚度，它是所有部件的安装位置。<br/>     这里选择了木制的铅笔，然后给了它四轴飞行器的形状。<br/>     如果你有3D打印机，可以打印一个更好的机架。<br/><br/>     这边是用铅笔做的无人机框架，请看照片。<br/>     为了连接电机，我们需要把电机放在机架臂上。<br/><strong>安装所有电机</strong><br/><br/>     两个马达按顺时针方向旋转，两个马达按逆时针方向旋转（参考图），如果一个马达没有按正确的方向旋转，只需切换一下马达的极性。</p>\n<ul><li> <p>检查电池和电压</p> </li><li> <p>检查所有的螺旋桨是否连接紧密</p> </li><li> <p>检查所有的马达固定装置</p> </li></ul>\n<p>    飞行后一定要记得拔掉电池，在飞行前再装上电池。<br/><br/><strong>软件部分</strong><br/>     建议使用Arduino IDE：如果你想编辑（即WiFi网络的SSID和密码 - Android热点）</p>\n<ul><li> <p>安装Arduino IDE</p> </li><li> <p>安装ESP8266板</p> </li><li> <p>安装ESP8266WiFi.h库</p> </li></ul>\n<p>    复制代码并在代码中修改自己的WIFI SSID和密码（代码可以在文末打包下载）：​​​​​​​</p>\n<pre><code>#include&lt;Wire.h&gt;</code><code>#include &lt;ESP8266WiFi.h&gt;</code><code>#include &lt;WiFiUdp.h&gt;</code><code>//代码太长了，为了方便阅读就不贴上了，可以在文末下载</code></pre>\n<p>    以上的Drone_FInal.ino文件，可以在文末打包下载。<br/>     打开Arduino IDE，从Drone_FInal.ino中复制代码并将其粘贴到Arduino IDE中。<br/>     通过编辑以下两行，在代码中编辑你的网络的SSID和密码。</p>\n<pre><code>WiFi.begin(\"Diyprojectslab\", \"romeooo\"); //ssid or pass</code></pre>\n<ul><li> <p>在Arduino IDE中，进入\"工具\"&gt;\"开发板\"&gt;选择\"NODEMCU 1.0（ESP - 12E模块）\"</p> </li><li> <p>转到工具，选择端口</p> </li><li> <p>从上面的代码中改变WI-FI名称和密码</p> </li><li> <p>现在点击上传按钮，上传上面的代码</p> </li><li> <p>如果一切顺利，可以看到ESP8266上的蓝色LED每隔一秒就开始闪烁。</p> </li></ul>\n<p><strong>安卓APP设置和 ESP8266无人机测试</strong><img alt=\"\" height=\"692\" src=\"..\\..\\static\\image\\fcfdbae2bf7c44089cf3b044c0b20231.png\" width=\"1028\"/></p>\n<p> ​​​​​​​<br/><img alt=\"\" height=\"692\" src=\"..\\..\\static\\image\\5b6575b1e9f943a3835515e8736da0fb.png\" width=\"1056\"/><br/> whaosoft aiot <a href=\"http://143ai.com/\" title=\"http://143ai.com\">http://143ai.com</a><br/>     这个安卓应用是使用Processing for Android App开发的。</p>\n<p> </p>\n<p><br/> ​​​​​​​</p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-04 19:35:16", "summary": "一、驱动开发开发板有很多配套例程，如下图就是开发板上最常见的一种屏。商家会给封装好一些函数，大家能学会如何点亮一个。在主函数中加入上述代码就可以轻松实现下面输出字符串、画矩形块、清屏等效果。但是这些例"}