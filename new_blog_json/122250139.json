{"blogid": "122250139", "writerAge": "码龄10年", "writerBlogNum": "10", "writerCollect": "88", "writerComment": "10", "writerFan": "7", "writerGrade": "2级", "writerIntegral": "258", "writerName": "周綝", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122250139.jpg", "writerRankTotal": "209688", "writerRankWeekly": "249071", "writerThumb": "16", "writerVisitNum": "18921", "blog_read_count": "3255", "blog_time": "于 2021-12-31 10:45:59 发布", "blog_title": "C# winform 通过Matrix实现图像的自由平移、缩放、旋转", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3><strong>1.先上样图</strong></h3>\n<p style=\"text-align:center;\"><strong><img alt=\"\" src=\"https://img-blog.csdnimg.cn/8021487404a34ab498ae78db699cd543.gif\"/></strong></p>\n<p> </p>\n<p>软件在用户交互方面未做完善 ，后续会逐步完善。</p>\n<p>代码已经同步到Github，欢迎下载使用，但是请注明出处。</p>\n<p>Github地址：<a class=\"link-info\" href=\"https://github.com/zhouchen/zhouchen.chart\" title=\"https://github.com/zhouchen/zhouchen.chart\">https://github.com/zhouchen/zhouchen.chart</a></p>\n<h3>2.软件基本构想</h3>\n<p>软件加载图片后，先做计算，给matrix赋值，使得图片大小适合窗口，然后居中显示。图片大小适合窗口，是对图像进行第一次缩放，代码如下：</p>\n<pre><code class=\"language-cs\">        // 缩放图片到窗口能刚好展示完全\n        public void AdaptView()\n        {\n            if (_bitmap == null)\n            {\n                return;\n            }\n\n            using (var graphPath = new GraphicsPath())\n            {\n                graphPath.AddRectangle(_rcImg);\n                graphPath.Transform(_matrix);\n                PointF[] pointFs = graphPath.PathPoints;\n                float fxmin = pointFs[0].X;\n                float fymin = pointFs[0].Y;\n                float fxmax = pointFs[0].X;\n                float fymax = pointFs[0].Y;\n\n                foreach (var pt in pointFs)\n                {\n                    if (pt.X &lt; fxmin)\n                    {\n                        fxmin = pt.X;\n                    }\n                    else if (pt.X &gt; fxmax)\n                    {\n                        fxmax = pt.X;\n                    }\n                    if (pt.Y &lt; fymin)\n                    {\n                        fymin = pt.Y;\n                    }\n                    else if (pt.Y &gt; fymax)\n                    {\n                        fymax = pt.Y;\n                    }\n                }\n\n                float fWidth = fxmax - fxmin;\n                float fHeight = fymax - fymin;\n\n                if (fWidth * rcBgArea.Height &lt; fHeight * rcBgArea.Width)\n                {\n                    DScale = rcBgArea.Height / fHeight;\n                }\n                else\n                {\n                    DScale = rcBgArea.Width / fWidth;\n                }\n                _matrix.Scale((float)DScale, (float)DScale, MatrixOrder.Append);\n            }\n        }</code></pre>\n<p>先计算图像进行矩阵变换后的最小外接矩形(图片刚加载的时候，其实外接矩形就是图片本身的尺寸，这里未了考虑之后图片进行矩阵变换后，想要重新恢复到能窗口显示，所以要进行矩阵变换的计算)，然后计算相应的缩放比例，并设置到变换矩阵中。</p>\n<p>缩放之后就要对图像进行第一次平移，这样能实现在窗口居中，代码如下：</p>\n<pre><code class=\"language-cs\">        // 平移图片到窗口的中间\n        public void TranslationCenter()\n        {\n            if(_bitmap == null)\n            {\n                return;\n            }\n            Matrix matrixinv = _matrix.Clone();\n            matrixinv.Invert();\n\n            Point[] ptViewCenter = new Point[] { new Point(rcBgArea.Left + rcBgArea.Width / 2, rcBgArea.Top + rcBgArea.Height / 2) };\n            matrixinv.TransformPoints(ptViewCenter);\n\n            _matrix.Translate(ptViewCenter[0].X - _rcImg.Width / 2, ptViewCenter[0].Y - _rcImg.Height / 2);\n            this.Refresh();\n\n        }</code></pre>\n<p>这里的思路就要和缩放有点逆向，因为平移是平移图片，显示窗口的中心坐标要先换算成图片坐标系的点的坐标，所以要先将窗口中心点的坐标通过逆矩阵，计算出相对与图片坐标系的坐标，然后进行相应的计算赋值，才可以完成图像的平移。</p>\n<p>缩放平移后，就是需要展示。展示采用GDI+的双缓冲技术。代码如下：</p>\n<pre><code class=\"language-cs\">        private void ChartView_Paint(object sender, PaintEventArgs e)\n        {\n            Graphics graph = e.Graphics;\n            graph.SmoothingMode = SmoothingMode.HighQuality;\n            // 双缓冲绘图\n            Bitmap bmpChartView = new Bitmap(this.Width, this.Height);\n            Graphics bmpChartView_g = Graphics.FromImage(bmpChartView);\n            bmpChartView_g.SmoothingMode = SmoothingMode.HighQuality;\n\n            DrawView(bmpChartView_g);\n            graph.DrawImage(bmpChartView, 0, 0);\n\n            bmpChartView_g.Dispose();\n            bmpChartView.Dispose();\n        }</code></pre>\n<p>因为之前设置好了_matrix,所以绘图就变得简单多了，只需要将矩阵设置到Graphics即可，代码如下：</p>\n<pre><code class=\"language-cs\">        // 绘图\n        private void DrawView(Graphics graph)\n        {\n            DrawMainView(graph);\n            DrawScrollV(graph);\n            DrawScrollH(graph);\n        }\n\n        // 绘制图片展示区\n        private void DrawMainView(Graphics graph)\n        {\n            // 填充背景\n            graph.FillRectangle(_ImgBg, rcBgArea);\n            if (_bitmap == null)\n            {\n                return;\n            }\n\n            Bitmap bitImg = new Bitmap(_rcImg.Width, _rcImg.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);\n            Graphics bitImg_g = Graphics.FromImage(bitImg);\n            bitImg_g.Transform = _matrix;\n            bitImg_g.DrawImage(_bitmap, 0, 0);\n\n            graph.DrawImage(bitImg, rcBgArea.Left, rcBgArea.Top);\n\n            foreach(var chart in LstChart)\n            {\n                chart.DrawChart(graph, _matrix);\n            }\n\n            bitImg_g.Dispose();\n            bitImg.Dispose();\n        }</code></pre>\n<p>值得注意的是，我还会在图片上绘制一些图形，如果在绘制图片之后，然后在图片上绘制图形，那么图形的线条宽度会随着图片的缩放进行相应的缩放，但是如果是在绘图Graphics上绘制的话，那就不会了，这个主要看实际的情况需要。比如PhotoShop就是要编辑图片，那么自然就是要对线条进行相应缩放，又比如Visio所画的图形，这就不要随着缩放而缩放。我在这里选择后者。</p>\n<h3>3.鼠标实现平移</h3>\n<p>这个比较简单，鼠标点击的时候，记录下点击的坐标(鼠标点击获取到的e.location是相对于视图窗口的坐标，需要通过逆矩阵换算出图片实际的坐标)，鼠标移动到新的坐标的时候，两两进行相减，然后把结果赋值到_matrix中即可</p>\n<pre><code class=\"language-cs\"> _matrix.Translate((points[0].X - _LastPt.X), (points[0].Y - _LastPt.Y));</code></pre>\n<h3>4.鼠标实现旋转</h3>\n<p>这个和平移很相似，该有的换算都得算上，这里需要把平移需要的坐标，改成角度即可，角度的计算代码如下，这里都是相对于图像的中心点旋转，需要重新设置旋转点，修改对应的旋转中心点就可以了：</p>\n<pre><code class=\"language-cs\">double corrb = Math.Atan2(_LastPt.Y - _rcImg.Height / 2, _LastPt.X - _rcImg.Width / 2);\ndouble corre = Math.Atan2(points[0].Y - _rcImg.Height / 2, points[0].X - _rcImg.Width / 2);\n_matrix.RotateAt((float)((corre -corrb) *180.0f/Math.PI), new Point(_rcImg.Width / 2, _rcImg.Height / 2));\nDRoute += (Double)((corre - corrb) * 180.0f / Math.PI);</code></pre>\n<h3>5.鼠标实现缩放</h3>\n<p>缩放实际上要实现两步，第一步是缩放，缩放后鼠标所在的坐标相对与图片来说发生了变化，所以还需要一步进行图像的平移，代码如下：</p>\n<pre><code class=\"language-cs\">        private void ChartView_MouseWheel(object sender, MouseEventArgs e)\n        {\n            Point[] points = new Point[] { e.Location };\n            Matrix matrix_Invert = _matrix.Clone();\n            matrix_Invert.Invert();\n            matrix_Invert.TransformPoints(points);\n            Console.WriteLine(points[0]);\n            if (_rcImg.Contains(points[0]))\n            {\n                double step = 1.2;\n                if (e.Delta &lt; 0)\n                {\n                    step = 1.0 / 1.2;\n                }\n                DScale *= step;\n                _matrix.Scale((float)step, (float)step);\n\n                Point[] pointse = new Point[] { e.Location };\n                matrix_Invert = _matrix.Clone();\n                matrix_Invert.Invert();\n                matrix_Invert.TransformPoints(pointse);\n                _matrix.Translate((pointse[0].X - points[0].X), (pointse[0].Y - points[0].Y));\n\n                Refresh();\n            }\n        }</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2021-12-31 10:45:59", "summary": "先上样图软件在用户交互方面未做完善，后续会逐步完善。代码已经同步到，欢迎下载使用，但是请注明出处。地址：软件基本构想软件加载图片后，先做计算，给赋值，使得图片大小适合窗口，然后居中显示。图片大小适合窗"}