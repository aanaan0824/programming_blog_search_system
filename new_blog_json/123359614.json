{"blogid": "123359614", "writerAge": "码龄2年", "writerBlogNum": "156", "writerCollect": "9133", "writerComment": "2473", "writerFan": "22571", "writerGrade": "7级", "writerIntegral": "13219", "writerName": "柠檬叶子C", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123359614.jpg", "writerRankTotal": "785", "writerRankWeekly": "635", "writerThumb": "6776", "writerVisitNum": "500618", "blog_read_count": "3719", "blog_time": "已于 2022-03-29 18:34:01 修改", "blog_title": "【C++要笑着学】类的默认成员函数详解 | 构造函数 | 析构函数 | 构造拷贝函数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p> 🔥 🔥 🔥 🔥 🔥  火速猛戳订阅 👉  <a href=\"https://blog.csdn.net/weixin_50502862/category_11602059.html\" title=\"《C++要笑着学》\">《C++要笑着学》</a>   👈 趣味教学博客 🔥 🔥 🔥 🔥 🔥</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\b53338b09e69459b894fa4840fc02f40.png\"/></p>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\c52b4035e4864f4ba6cbbd9070bc53cd.png\" width=\"324\"/>  <strong> <span style=\"color:#e6b223;\"><em>[ 本篇博客热榜最高排名：7 ]</em></span></strong></p>\n<p></p>\n<h3>写在前面</h3>\n<p><img alt=\"\" height=\"51\" src=\"..\\..\\static\\image\\aad595a3c2c24739aba93262084123b9.png\" width=\"61\"/> 朋友们好啊，今天终于更新了。我是<span style=\"color:#e6b223;\"><strong>柠檬</strong></span><span style=\"color:#1c7331;\"><strong>叶子</strong></span><span style=\"color:#0d0016;\"><strong>C</strong></span>，本章将继续讲解C++中的面向对象的知识点，本篇主要讲解默认成员函数中的构造函数、析构函数和拷贝构造函数。还是和以前一样，我们将由浅入深地去讲解，<span style=\"background-color:#fbd4d0;\">以 \"初学者\" 的角度去探索式地学习。</span>会一步步地推进讲解，而不是直接把枯燥的知识点倒出来，应该会有不错的阅读体验。如果觉得不错，可以 \"一键三连\" 支持一下博主！你们的关注就是我更新的最大动力！Thanks ♪ (･ω･)ﾉ</p>\n<p></p>\n<hr/>\n<h2 id=\"%E2%85%A0.%20%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">Ⅰ.  默认成员函数</h2>\n<p><img alt=\"\" height=\"225\" src=\"..\\..\\static\\image\\11842e8c36ca4ec28a486a6512bac44f.png\" width=\"320\"/></p>\n<p>如果一个类中什么成员都没有，我们称之为 \"空类\" 。</p>\n<p>❓ 但是空类中真的什么都没有吗？</p>\n<p><img alt=\"\" height=\"111\" src=\"..\\..\\static\\image\\52ba0d6feb53441d8f09d6a6cdda555a.png\" width=\"151\"/> 并不是的……</p>\n<p></p>\n<p><span style=\"background-color:#f9eda6;\">类有六个默认成员函数</span>，特殊的点非常多，后面我们会壹壹学习。</p>\n<p><img alt=\"\" height=\"271\" src=\"..\\..\\static\\image\\5e1ba242ab8a45fa91b2318b25a34c39.png\" width=\"414\"/></p>\n<p><img alt=\"\" height=\"642\" src=\"..\\..\\static\\image\\3c26cc0116a74612a33c950ef4bb7080.png\" width=\"1200\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"61\" src=\"..\\..\\static\\image\\4690005f605449e8bfbffa51ceaaab0e.png\" width=\"72\"/> 对于默认成员函数，如果我们不主动实现，编译器会自己生成一份。</p>\n<p></p>\n<p>❓ 他们有什么用呢？举个例子：</p>\n<p>比如我们在上一章里举过的一个 <strong>Stack </strong>的例子，</p>\n<p>如果需要初始化和清理，\"构造函数\" 和 \"析构函数\" 就可以帮助我们完成。</p>\n<p>构造函数就类似于<span style=\"color:#956fe7;\"> Init</span>，而析构函数就类似于 <span style=\"color:#956fe7;\">Destroy</span>。</p>\n<p><img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\c0336c99a116421eab25dc67da0cef35.png\" width=\"217\"/></p>\n<p>还是和以前一样，我们将先由浅入深地进行学习，我们先从 \"构造函数\" 开始讲起。</p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A1.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">Ⅱ. 构造函数</h2>\n<h3 id=\"0x00%20%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5\">0x00 引入</h3>\n<p><img alt=\"\" height=\"158\" src=\"..\\..\\static\\image\\bf279f94cc94473e98690246720e494f.png\" width=\"176\"/>打开宇宙第一编辑器，一起敲一敲看看 ~</p>\n<p>📚 为了能够更好地讲解，我们来写一个简单的日期类，通过日期类来讲解。</p>\n<p>💬 Date.cpp</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    void SetDate(int year, int month, int day) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;\n    d1.SetDate(2022, 3, 8);\n    d1.Print();\n\n    Date d2;\n    d2.SetDate(2022, 3, 12);\n    d2.Print();\n\n    return 0;\n}</code></pre>\n<p>💡 对于 <strong>Date</strong> 类，我们可以通过我们写的成员函数 <span style=\"color:#e6b223;\">SetDate </span>给对象设置内容。</p>\n<p><img alt=\"\" height=\"114\" src=\"..\\..\\static\\image\\b1eaf3ddca98458282018ba6360c70f8.png\" width=\"106\"/> 但是每次创建对象都要调用这个 SetDate ，是不是太鸡儿烦了？</p>\n<p></p>\n<p>❓ 那有没有什么办法能在创建对象时，自动将我们要传递的内容放置进去呢？</p>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\649aa8f01696497cbfc791ca45b3a25e.png\" width=\"46\"/> 有！下面我们来隆重介绍一下 <strong>构造函数</strong>！</p>\n<p></p>\n<p></p>\n<h3 id=\"0x01%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5\">0x01 构造函数的概念</h3>\n<p><img alt=\"\" height=\"116\" src=\"..\\..\\static\\image\\659e5ad7ab31443c971a75a0913a1b0b.png\" width=\"109\"/></p>\n<p>📚 <span style=\"background-color:#f9eda6;\">构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用。</span></p>\n<p>能够保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。</p>\n<p></p>\n<p><img alt=\"\" height=\"52\" src=\"..\\..\\static\\image\\1937ef1085f74c4e9de35231ec04ea82.png\" width=\"52\"/> 构造函数的意义：能够保证对象被初始化。</p>\n<p>构造函数是特殊的成员函数，主要任务是初始化，而不是开空间。（虽然构造函数的名字叫构造）</p>\n<p></p>\n<h3 id=\"0x02%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7\">0x02 构造函数的特性</h3>\n<p>📚 构造函数是特殊的成员函数，主要特征如下：</p>\n<p>① 构造函数的函数名和类名是相同的</p>\n<p>② 构造函数无返回值</p>\n<p>③ 构造函数可以重载</p>\n<p>③ 会在对象实例化时自动调用对象定义出来。</p>\n<p>比如下面的代码只要 <img alt=\"\" height=\"20\" src=\"..\\..\\static\\image\\4c6d810245c6457a9470a58d1e1c23ea.png\" width=\"71\"/> 就会自动调用，保证了对象一定是被初始化过的。</p>\n<p></p>\n<p><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\4fd59d90b6084894b80204781b2bd42a.png\" width=\"66\"/> 我们直接来看看它是怎么用的！ </p>\n<p>💬 构造函数的用法：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    /* 无参构造函数 */\n    Date() {\n        _year = 0;\n        _month = 1;\n        _day = 1;\n    }\n    /* 带参构造函数 */\n    Date(int year, int month, int day) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;   // 对象实例化，此时触发构造，调用无参构造函数\n    d1.Print();\n\n    Date d2(2022, 3, 9);   // 对象实例化，此时触发构造，调用带参构造函数\n    d2.Print();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"118\" src=\"..\\..\\static\\image\\dfc30469a28f4515a1b5be584109212c.png\" width=\"544\"/></p>\n<p> 🔑 解读：不给参数时就会调用无参构造函数，给参数则会调用带参构造函数。</p>\n<p></p>\n<p><img alt=\"\" height=\"110\" src=\"..\\..\\static\\image\\54a3a77a338f47f58774b5613c7d3b4a.png\" width=\"604\"/></p>\n<p></p>\n<p>📌 注意事项：</p>\n<p>① 构造函数是特殊的，不是常规的成员函数，不能直接调 <img alt=\"\" height=\"25\" src=\"..\\..\\static\\image\\2aae57abea39420a851a895702e57c3b.png\" width=\"105\"/> 。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    Date(int year = 1, int month = 0, int day = 0) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;\n    d1.Date(); // 不能这么去调，构造函数是特殊的，不是常规的成员函数！\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果：（报错）</p>\n</blockquote>\n<p><img alt=\"\" height=\"216\" src=\"..\\..\\static\\image\\8d0d20c7ae1c42ffaf35199cd320fd04.png\" width=\"610\"/></p>\n<p></p>\n<p>② 如果通过无参构造函数创建对象，对象后面不用跟括号，否则就成了函数声明。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    Date(int year = 1, int month = 0, int day = 0) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    //带参这么调：加括号()，在括号中加参数列表\n    Date d2(2022, 3, 9);\n\n    Date d3();   // 这样可以吗？ \n                 // 既然代参的调用加括号，在括号中加参数列表。\n                 // 那我不带参，可不可以加括号呢？\n                 ❌ 仍然不可以。\n                 // 这个对象实际上没有被定义出来，这里会报错。 \n                 // 编译器不会识别，所以不传参数就老老实实地  \n                 // Date d3; 不要 Date d3();   \n    // 主要是编译器没法识别，所以这里记住不能这么干就行了。\n\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"255\" src=\"..\\..\\static\\image\\371c6a4a508344c18dfccd40ddf0532f.png\" width=\"562\"/></p>\n<p></p>\n<p>③ 这里如果调用带参构造函数，我们需要传递三个参数（这里我们没设缺省） 。</p>\n<p><img alt=\"\" height=\"230\" src=\"..\\..\\static\\image\\9e3b84d4d8674465addf5a1dd3ecf9c6.png\" width=\"631\"/></p>\n<p></p>\n<p>④ 如果你没有自己定义构造函数（类中未显式定义），C++ 编译器会自动生成一个无参的默认构造函数。当然，如果你自己定义了，编译器就不会帮你生成了。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    /* 如果用户显式定义了构造函数，编译器将不再生成\n    Date(int year, int month, int day) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n    */\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;  // 这里调用的是默认生成的无参的构造函数\n    d1.Print();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"184\" src=\"..\\..\\static\\image\\79cef0783975456a94ed2cfddd9965c9.png\" width=\"1013\"/></p>\n<p>🔑 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器默认生成的构造函数。</p>\n<p><img alt=\"\" height=\"181\" src=\"..\\..\\static\\image\\1ef1d58f8c8e4ed0b52313b8c80b14a5.png\" width=\"650\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"0x03%20%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">0x03 默认构造函数</h3>\n<p><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\4b7d9ed114ea4d90853496b1d5da635f.png\" width=\"66\"/> 无参构造函数、全缺省构造函数都被称为默认构造函数。</p>\n<p>并且默认构造函数只能有一个！</p>\n<pre><code class=\"language-cpp\">class Date {\npublic:\n    /* 全缺省构造函数 - 默认构造函数 */\n    Date(int year = 1970, int month = 1, int day = 1) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};</code></pre>\n<p></p>\n<p>📌 注意事项：</p>\n<p>① 无参构造函数、全缺省构造函数、我们没写编译器默认生成的无参构造函数，都可以认为是默认成员函数。</p>\n<p>② 语法上无参和全缺省可以同时存在，但如果同时存在会引发二义性：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    Date() {\n        _year = 1970;\n        _month = 1;\n        _day = 1;\n    }\n    Date(int year = 1970, int month = 1, int day = 1) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n    \nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1; ❌\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：（报错）</p>\n</blockquote>\n<p>🔑 解读：无参的构造函数和全缺省的构造函数都成为默认构造函数，并且默认构造参数只能有一个，语法上他们两个可以同时存在，但是如果有对象定义去调用就会报错。</p>\n<p><img alt=\"\" height=\"383\" src=\"..\\..\\static\\image\\801ea12a4a0e49c186d7d6d87e5ff0c1.png\" width=\"607\"/></p>\n<p></p>\n<p> <img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\e35df21f34074bbf8e81b203003808ee.png\" width=\"66\"/> 推荐实现全缺省或者半缺省，因为真的很好用：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\n    public:\n        /* 全缺省 */\n        Date(int year = 0, int month = 1, int day = 1) {\n            _year = year;\n            _month = month;\n            _day = day;\n        }\n    \n        void Print() {\n            printf(\"%d-%d-%d\\n\", _year, _month, _day);\n        } \n    private:\n        int _year;\n        int _month;\n        int _day;\n};\n\nint main(void)\n{\n    Date d1; // 如果不传，就是缺省值\n    Date d2(2022, 1, 15);\n    Date d3(2009);\n    Date d4(2012, 4);\n\n    d1.Print();  // 0-1-1\n    d2.Print();  // 2022-1-15\n    d3.Print();  // 2009-1-1\n    d4.Print();  // 2012-4-1\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"147\" src=\"..\\..\\static\\image\\a55ebd7aa4e54bbbb8de25ff2cb12b13.png\" width=\"522\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"0x04%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E7%9A%84%E6%B5%8B%E8%AF%95\">0x04 构造函数的特性的测试</h3>\n<p><img alt=\"\" height=\"186\" src=\"..\\..\\static\\image\\3e3692c130d848d799df1fa6c077ad6e.png\" width=\"292\"/></p>\n<p>📚 任何一个类的默认构造函数，只有三种：</p>\n<p>① 无参的构造函数</p>\n<p>② 全缺省的构造函数</p>\n<p>③ 我们不写，编译器自己生成的构造函数</p>\n<p></p>\n<p>💬 如果你没有自己定义构造函数（类中未显式定义），</p>\n<p>C++ 编译器会自动生成一个无参的默认构造函数。</p>\n<p>当然，如果你自己定义了，编译器就不会帮你生成了。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    // 让编译器自己生成一个\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;  // 这里调用的是默认生成的无参的构造函数\n    d1.Print();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"95\" src=\"..\\..\\static\\image\\79cef0783975456a94ed2cfddd9965c9.png\" width=\"521\"/></p>\n<p> <img alt=\"\" height=\"72\" src=\"..\\..\\static\\image\\430db65bb33f4ffcbbeb08cc3e371d05.png\" width=\"113\"/> 好了，我们来好好探讨探讨这个问题！</p>\n<p>在我们不是先构造函数的情况下，编译器生成的默认构造函数。</p>\n<p>似乎这看起来没有什么鸟用啊，这不就是一堆随机值嘛……</p>\n<p><strong>d1 </strong>对象调用了编译器生成的默认函数，但<strong> d1</strong> 对象 year / month / day 依旧是随机值，</p>\n<p>也就是说这里编译器生成的默认构造函数好像并没有什么卵用。</p>\n<p><img alt=\"\" height=\"189\" src=\"..\\..\\static\\image\\7d322a9ddfff4f9a92bd822a6d911aaf.png\" width=\"270\"/></p>\n<p></p>\n<p>🔑 解答：C++ 把类型分成内置类型（基本类型）和自定义类型。</p>\n<p>内置类型就是语法已经定义好的类型：如 <span style=\"color:#e6b223;\">int</span> / <span style=\"color:#e6b223;\">char</span>...，</p>\n<p>自定义类型就是我们使用<span style=\"color:#e6b223;\"> </span><span style=\"color:#956fe7;\">class</span> / <span style=\"color:#956fe7;\">struct</span> / <span style=\"color:#956fe7;\">union</span> / <span style=\"color:#956fe7;\">自己定义的类型</span>。</p>\n<p>💬 看看下面的程序，就会发现。编译器生成默认的构造函数会对自定类型成员<strong> aa</strong> 调用的它的默认成员函数：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Time {\npublic:\n\tTime()\n\t{\n\t\tcout &lt;&lt; \"Time()\" &lt;&lt; endl;\n\t\t_hour = 0;\n\t\t_minute = 0;\n\t\t_second = 0;\n\t}\nprivate:\n\tint _hour;\n\tint _minute;\n\tint _second;\n};\n\nclass Date {\nprivate:\n\t// 基本类型（内置类型）\n\tint _year;\n\tint _month;\n\tint _day;\n\n\t// 自定义类型\n\tTime _t;\n};\n\nint main()\n{\n\tDate d;\n\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下： </p>\n</blockquote>\n<p><img alt=\"\" height=\"121\" src=\"..\\..\\static\\image\\1e9a65d3d12b45d5a50392df5fce430f.png\" width=\"522\"/></p>\n<p></p>\n<p>💬 测试：对自定义类型处理，会调用默认构造函数（不用参数就可以调的函数）</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    // 默认构造函数（不用参数就可以调的）\n    A() {\n        cout &lt;&lt; \" A() \" &lt;&lt; endl;\n        _a = 0;\n    }\n\nprivate:\n    int _a;\n};\n\nclass Date {\npublic:\nprivate:\n    int _year;\n    int _month;\n    int _day;\n\n    A _aa;   // 对自定义类型处理，此时会调用默认构造函数 A() {...}\n};\n\nint main(void)\n{\n    Date d1;\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"120\" src=\"..\\..\\static\\image\\cc765fd27d03430788e664d44786f627.png\" width=\"531\"/></p>\n<p>C++ 里面把类型分为两类：<span style=\"color:#e6b223;\"><strong>内置类型</strong></span>（基本类型）和 <span style=\"color:#956fe7;\"><strong>自定义类型</strong></span>。</p>\n<p><img alt=\"\" height=\"208\" src=\"..\\..\\static\\image\\cad3cfd3386642e29d16bb0841414ab4.png\" width=\"286\"/></p>\n<p>C++ 规定：我们不写编译器默认生成构造函数，对于内置类型的成员变量，不做初始化处理。</p>\n<p>但是对于自定义类型的成员变量会去调用它的默认构造函数（不用参数就可以调的）初始化。</p>\n<p>如果没有默认构造函数（不用参数就可以调用的构造函数）<span style=\"color:#ed7976;\">就会报错！</span></p>\n<p></p>\n<p>💬 为了验证，这里我们故意写个带参的默认构造函数，让编译器不默认生成：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    // 如果没有默认的构造函数，会报错。\n    A(int a) {    // 故意给个参\n        cout &lt;&lt; \" A() \" &lt;&lt; endl;\n        _a = 0;\n    }\nprivate:\n    int _a;\n};\n\nclass Date {\npublic:\nprivate:\n    // 如果没有默认构造函数就会报错\n\n    int _year;\n    int _month;\n    int _day;\n\n    A _aa;\n};\n\nint main(void)\n{\n    Date d1;\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下（报错）</p>\n</blockquote>\n<p><img alt=\"\" height=\"52\" src=\"..\\..\\static\\image\\4c41b0d175a345d7bf5a2122c9606319.png\" width=\"605\"/></p>\n<p></p>\n<p>💬 我们不写，让编译器默认生成一个：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    // 让编译器默认生成\nprivate:\n    int _a;\n};\n\nclass Date {\npublic:\nprivate:\n    int _year;\n    int _month;\n    int _day;\n\n    A _aa;\n};\n\nint main(void)\n{\n    Date d1;\n\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\cafc426be24945fba8f5046522d01d73.png\" width=\"458\"/></p>\n<p><img alt=\"\" height=\"64\" src=\"..\\..\\static\\image\\048d54b172e94d3bb30a9c17b8ac9c16.png\" width=\"87\"/> 是随机值没错，但是这是一种对自定义类型的 \"处理\" 。</p>\n<p></p>\n<p><img alt=\"\" height=\"46\" src=\"..\\..\\static\\image\\691f45ceea694367a5a2fc87a3e72f1d.png\" width=\"55\"/> 这里说个题外话，个人认为 C++里，我们不写构造函数编译器会默认生成的这个特性设计得不好（狗头保命）……因为没有对内置类型和自定义类型统一处理，不处理内置类型成员变量，只处理自定义类型成员变量。</p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A2.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">Ⅲ. 析构函数</h2>\n<h3 id=\"0x00%20%E5%BC%95%E5%85%A5\">0x00 引入</h3>\n<p><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\9c493c63b5c7485d8bafc45d6b4f53fd.png\" width=\"66\"/> 通过前面构造函数的学习，我们知道了一个对象是怎么来的了，</p>\n<p>❓ 那一个对象又是怎么没的呢？既然构造函数的本质是初始化，那清理的工作交给谁来干呢？</p>\n<p>💡 交给专门擦屁股的 —— <span style=\"color:#956fe7;\"><strong>析构函数</strong></span>！</p>\n<p></p>\n<p>以前我们玩数据结构的时候经常忘记调用 <span style=\"color:#4da8ee;\">destroy</span> 函数，但是现在我们有析构函数了！！！</p>\n<p><img alt=\"\" height=\"438\" src=\"..\\..\\static\\image\\c91e123a79db4f71bc36206cdb6d41ec.png\" width=\"541\"/></p>\n<p><span style=\"color:#ff9900;\"><em>多么振奋人心啊！话不多说让我们开始讲解！！！ </em></span></p>\n<p></p>\n<p></p>\n<h3 id=\"0x01%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5\">0x01 析构函数的概念</h3>\n<p><img alt=\"\" height=\"120\" src=\"..\\..\\static\\image\\29de6102b88b4c66b7a989dde9d5a266.png\" width=\"116\"/> 析构函数与构造函数的功能相反。</p>\n<p>构造函数是特殊的成员函数，主要任务是初始化，而不是开空间；</p>\n<p>析构函数也一样，<span style=\"background-color:#f9eda6;\">主要任务是清理，而不是做对象销毁的工作。</span></p>\n<p>（局部对象销毁工作是由编译器完成的）</p>\n<p>📚 概念：<span style=\"background-color:#f9eda6;\">对象在销毁时会自动调用析构函数，完成对象的一些资源清理工作。</span></p>\n<p></p>\n<h3>0x02 析构函数的特性</h3>\n<p><img alt=\"\" height=\"101\" src=\"..\\..\\static\\image\\3a1bcce09f92437391772b477d5d0653.png\" width=\"67\"/> 构造函数是特殊的成员函数，主要特征如下：</p>\n<p>① 析构函数名是在类名前面加上字符 <img alt=\"~\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?~\"/><img alt=\"\" height=\"26\" src=\"..\\..\\static\\image\\f9bc458a44584587a9f28c5a9032213c.png\" width=\"16\"/></p>\n<p>② 析构函数既没有参数也没有返回值（因为没有参数，所以也不会构成重载问题）</p>\n<p>③ 一个类的析构函数有且仅有一个（如果不写系统会默认生成一个析构函数）</p>\n<p>④ 析构函数在对象生命周期结束后，会自动调用。</p>\n<p>（和构造函数是对应的构造函数是在对象实例化的时候自动调用）</p>\n<p></p>\n<p>💬 为了演示自动调用，我们来让析构函数被调用时 \"吱\" 一声：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Date {\npublic:\n    Date(int year = 1, int month = 0, int day = 0) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\n    ~Date() {\n        // Date 类没有资源需要清理，所以Date不实现析构函都是可以的\n        cout &lt;&lt; \"~Date() 吱~ \" &lt;&lt; endl;  // 测试一下，让他吱一声\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;\n    Date d2(2022, 3, 9);\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果：</p>\n</blockquote>\n<p><img alt=\"\" height=\"281\" src=\"..\\..\\static\\image\\ece1a5c7e1634ced8175924c09185d28.png\" width=\"582\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"92\" src=\"..\\..\\static\\image\\b2582f7559734e30b94366fc20a5c554.png\" width=\"123\"/>额，之前举得日期类的例子没法很好地展示析构函数的 \"魅力\" ……</p>\n<p>就像本段开头说情景，我们拿 <strong>Stack </strong>来举个例子，这就很贴切了。</p>\n<p>我们知道，栈是需要<span style=\"color:#956fe7;\"> destroy</span> 清理开辟的内存空间的。</p>\n<p></p>\n<p><img alt=\"\" height=\"57\" src=\"https://img-blog.csdnimg.cn/f082b9c6b0fa4873a8740244ad8fd041.gif\" width=\"57\"/> 这里我们让析构函数来干这个活，简直美滋滋！</p>\n<p>💬 析构函数的用法：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\n\ntypedef int StackDataType;\nclass Stack {\npublic:\n    /* 构造函数 - StackInit */\n    Stack(int capacity = 4) {  // 这里只需要一个capacity就够了，默认给4（利用缺省参数）\n        _array = (StackDataType*)malloc(sizeof(StackDateType) * capacity);\n        if (_array == NULL) {\n            cout &lt;&lt; \"Malloc Failed!\" &lt;&lt; endl;\n            exit(-1);\n        }\n        _top = 0;\n        _capacity = capacity;\n    }\n\n    /* 析构函数 - StackDestroy */\n    ~Stack() {   // 这里就用的上析构函数了，我们需要清理开辟的内存空间（防止内存泄漏）\n        free(_array);\n        _array = nullptr;\n        _top = _capacity = 0;\n    }\n\nprivate:\n    int* _array;\n    size_t _top;\n    size_t _capacity;\n};\n\nint main(void)\n{\n    Stack s1;\n    Stack s2(20); // s2 栈 初始capacity给的是20（可以理解为\"客制化\"）\n\n    return 0;\n}\n</code></pre>\n<p>🔑 解读：我们在设置栈的构造函数时，定义容量<strong> capacity </strong>时利用缺省参数默认给个4的容量，这样用的时候默认就是4，如果不想要4可以自己传。</p>\n<p>如此一来，就可以保证了栈被定义出来就一定被初始化，用完后会自动销毁。以后就不会有忘记调用 <span style=\"color:#956fe7;\">destroy</span> 而导致内存泄露的惨案了，这里的析构函数就可以充当销毁的作用。</p>\n<p></p>\n<p>❓ 问一个比较有意思的问题，这里是先析构<strong> s1 </strong>还是先析构 <strong>s2</strong>？</p>\n<p><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\41357a5718824b0e80a45ab3007af9f2.png\" width=\"66\"/> 既然都这样问了，应该是先析构 <strong>s2 </strong>了 ~</p>\n<p>析构的顺序在局部的栈中是相反的，栈帧销毁清理资源时 <strong>s2</strong> 先清理，然后再清理<strong> s1 </strong>。</p>\n<p><span style=\"color:#a5a5a5;\">（不信的话可以去监视一下 this 观察下成员变量）</span></p>\n<p></p>\n<p></p>\n<h3 id=\"0x03%C2%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E7%9A%84%E6%B5%8B%E8%AF%95\">0x03 析构函数的特性的测试</h3>\n<p><img alt=\"\" height=\"118\" src=\"..\\..\\static\\image\\9020620a49254ff392d07c5a1afa5fd9.png\" width=\"197\"/>又到了测试环节，上号！</p>\n<p>我们知道，如果没写析构函数编译器会自动生成一个。</p>\n<p>那生成的析构函数会做什么事情呢？它会帮我们 <span style=\"color:#956fe7;\">destroy</span> 嘛？</p>\n<p><img alt=\"\" height=\"140\" src=\"..\\..\\static\\image\\dcbcb0d9e0aa4d4a814d25489934be2b.png\" width=\"142\"/> 想屁吃？哪有这种好事。</p>\n<p>如果我们不写默认生成的析构函数，结果和构造函数类似，</p>\n<p>对于自定义类型的成员变量不作处理，对于自定义类型的成员变量会去调用它的析构函数。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\ntypedef int StackDataType;\n\nclass Stack {\npublic:\n    Stack(int capacity = 4) {\n        _array = (StackDataType*)malloc(sizeof(int*) * capacity);\n        if (_array == NULL) {\n            cout &lt;&lt; \"Malloc Failed!\" &lt;&lt; endl;\n            exit(-1);\n        }\n        _top = 0;\n        _capacity = capacity;\n    }\n    // ~Stack() {\n    //     free(_array);\n    //     _array = nullptr;\n    //     _top = _capacity = 0;\n    // }\n\nprivate:\n    int* _array;\n    size_t _top;\n    size_t _capacity;\n};\n\nint main(void)\n{\n    Stack s1;\n    Stack s2(20);\n\n\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"135\" src=\"..\\..\\static\\image\\4a0c84c0d7184a2d8b4fbfffe808b8f2.png\" width=\"200\"/>难道就不能帮我把这些事都干了吗？帮我都销毁掉不就好了？</p>\n<p></p>\n<p>不不不，举个最简单的例子，迭代器，析构的时候是不释放的，因为不需要他来管，</p>\n<p>所以默认不对内置类型处理是正常的，万一误杀了怎么办，对吧。 </p>\n<p><img alt=\"\" height=\"165\" src=\"..\\..\\static\\image\\6141b050aa8741b2a8d79f62d15e9106.png\" width=\"156\"/></p>\n<p>有人可能又要说了，这么一来默认生成的析构函数不就没有用了吗？</p>\n<p>有用！他对内置类型的成员类型不作处理，会在一些情况下非常的有用！</p>\n<p>比如说：   两个栈实现一个队列（LeetCode232） ，用C++可以非常的爽。</p>\n<p></p>\n<p>💬 自定义类型的成员变量调用它的析构函数：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass String {\npublic:\n\tString(const char* str = \"jack\") {\n\t\t_str = (char*)malloc(strlen(str) + 1);\n\t\tstrcpy(_str, str);\n\t}\n\t~String() {\n\t\tcout &lt;&lt; \"~String()\" &lt;&lt; endl;\n\t\tfree(_str);\n\t}\nprivate:\n\tchar* _str;\n};\n\nclass Person {\nprivate:\n\tString _name;\n\tint _age;\n};\n\nint main()\n{\n\tPerson p;\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"101\" src=\"..\\..\\static\\image\\fba4fe23a9c84c0f802f22f2739e22f5.png\" width=\"521\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A3.%C2%A0%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">Ⅳ.  拷贝构造函数</h2>\n<h3>0x00 引入</h3>\n<p><img alt=\"\" height=\"241\" src=\"..\\..\\static\\image\\458225ab34844a9884734d81de00bda2.png\" width=\"533\"/></p>\n<p>我们在创建对象的时候，能不能创建一个与某一个对象一模一样的新对象呢？</p>\n<pre><code class=\"language-cpp\">Date d1(2022, 3, 9);    \nd1.Print();\n\nDate d2(d1);    // 照着d1的模子做一个d2\nd2.Print();</code></pre>\n<p>当然可以，这时我们就可以用拷贝构造函数。</p>\n<p><img alt=\"\" height=\"287\" src=\"..\\..\\static\\image\\2e2cac346b3c4d57a643086f0bf10621.png\" width=\"617\"/></p>\n<p></p>\n<h3 id=\"0x01%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5\">0x01 拷贝构造函数的概念</h3>\n<p><img alt=\"\" height=\"142\" src=\"..\\..\\static\\image\\c7bbae49c7b44de2bd984880b90e2d09.png\" width=\"215\"/></p>\n<p>📚 拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用<span style=\"color:#956fe7;\"> const </span>修饰），在用已存在的类类型对象创建新对象时由编译器自动调用。</p>\n<p></p>\n<h3 id=\"0x02%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7\">0x02 拷贝构造函数的特性</h3>\n<p><img alt=\"\" height=\"194\" src=\"..\\..\\static\\image\\0e8ad27b057c48019edd4db991826271.png\" width=\"202\"/>它也是一个特殊的成员函数，所以他符合构造函数的一些特性：</p>\n<p>① 拷贝构造函数是构造函数的一个重载形式。函数名和类名相同，没有返回值。</p>\n<p>② 拷贝构造函数的参数只有一个，并且必须要使用引用传参！</p>\n<p>     <img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\d9d87c6c3dc24260b9fee91ef1b3682a.png\" width=\"240\"/> 使用传值方式会引发无穷递归调用！</p>\n<p></p>\n<p>💬 拷贝构造函数的用法：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nclass Date {\npublic:\n    Date(int year = 0, int month = 1, int day = 1) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n\n    /* Date d2(d1); */\n    Date(Date&amp; d) {         // 这里要用引用，否则就会无穷递归下去\n        _year = d._year;\n        _month = d._month;\n        _day = d._day;\n    }\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1(2022, 3, 9);\n    Date d2(d1);          // 拷贝复制\n\n    // 看看拷贝成功没\n    d1.Print();\n    d2.Print();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"128\" src=\"..\\..\\static\\image\\9d6ef494314d4e2c8db76bac63157f50.png\" width=\"532\"/></p>\n<p></p>\n<p>❓ 为什么必须使用引用传参呢？</p>\n<p>调用拷贝构造，需要先穿参数，传值传参又是一个拷贝构造。</p>\n<p>调用拷贝构造，需要先穿参数，传值传参又是一个拷贝构造。</p>\n<p>调用拷贝构造，需要先穿参数，传值传参又是一个拷贝构造。</p>\n<p>……</p>\n<p>一直在传参这里出不去了，所以这个递归是一个无穷无尽的。</p>\n<p></p>\n<p>💬 我们来验证一下：</p>\n<p><img alt=\"\" height=\"426\" src=\"..\\..\\static\\image\\b8ca5dcd31e74606b361dbdf0ad20a0d.png\" width=\"430\"/></p>\n<p><span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">error: invalid constructor; you probably meant 'Date (const Date&amp;)'</span></span></p>\n<p><img alt=\"\" height=\"404\" src=\"..\\..\\static\\image\\dafe45d28d1740c49848add2cf3efe6f.png\" width=\"586\"/></p>\n<p>这里不是加不加 <span style=\"color:#956fe7;\">const </span>的问题，而是没有用引用导致的问题。</p>\n<p>不用引用，他就会在传参那无线套娃递归。至于为什么我们继续往下看。</p>\n<p></p>\n<p>💬 拷贝构造函数加<span style=\"color:#956fe7;\"> const </span>：</p>\n<p>如果函数内不需要改变，建议把<span style=\"color:#956fe7;\"> const</span> 也给它加上</p>\n<pre><code class=\"language-cpp\">class Date {\npublic:\n    Date(int year = 0, int month = 1, int day = 1) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n\n    /* Date d2(d1); */\n    Date(const Date&amp; d) {    // 如果内部不需要改变，建议加上const\n        _year = d._year;\n        _month = d._month;\n        _day = d._day;\n    }\n\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};</code></pre>\n<p><strong>第一个原因：</strong>怕出错，万一你一不小心写反了怎么办？</p>\n<pre><code class=\"language-cpp\">/* Date d2(d1); */\nDate(Date&amp; d) {\n    d._year = _year;\n    d._month = _month;\n    d._day = _day;\n}</code></pre>\n<p>这样会产生一个很诡异的问题，这一个可以被编译出来的 BUG ，结果会变为随机值。</p>\n<p>所以，这里加一个<span style=\"color:#956fe7;\"> const </span>就安全多了，这些错误就会被检查出来了。</p>\n<p></p>\n<p><strong>第二个原因：</strong>以后再讲，因为涉及一些临时对象的概念。</p>\n<p>🔺 反正，不想深究的话就记住：<span style=\"background-color:#f9eda6;\">如果函数体内不需要改变，建议把</span><span style=\"color:#956fe7;\"><span style=\"background-color:#f9eda6;\"> const </span></span><span style=\"background-color:#f9eda6;\">加上</span>就完事了。</p>\n<p></p>\n<p></p>\n<h3 id=\"0x03%20%E5%85%B3%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0\">0x03 关于默认生成的拷贝构造</h3>\n<p><img alt=\"\" height=\"110\" src=\"..\\..\\static\\image\\baca864b292e42edb1e4363b4746d530.png\" width=\"109\"/> 这里比较特殊，我们单独领出来讲。 </p>\n<p></p>\n<p>📚 默认生成拷贝构造：</p>\n<p>① <span style=\"background-color:#f9eda6;\">内置类型的成员，会完成按字节序的拷贝</span>（把每个字节依次拷贝过去）。</p>\n<p>② 自定义类型成员，会再调用它的拷贝构造。</p>\n<p>💬 拷贝构造我们不写生成的默认拷贝构造函数，对于内置类型和自定义类型都会拷贝处理。但是处理的细节是不一样的，这个跟构造和析构是不一样的！</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Date {\n    public:\n        Date(int year = 0, int month = 1, int day = 1) {\n            _year = year;\n            _month = month;\n            _day = day;\n        }\n\n        // Date(Date&amp; d) {\n        //     _year = d._year;\n        //     _month = d._month;\n        //     _day = d._day;\n        // }\n\n        void Print() {\n            printf(\"%d-%d-%d\\n\", _year, _month, _day);\n        } \n    \n    private:\n        int _year;\n        int _month;\n        int _day;\n};\n\nint main(void)\n{\n    Date d1(2002, 4, 8);\n\n    // 拷贝复制\n    Date d2(d1);\n\n    // 没有写拷贝构造，但是也拷贝成功了\n    d1.Print();\n    d2.Print();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"120\" src=\"..\\..\\static\\image\\3bbb3b3273604b7ab4990e1843ee9fa8.png\" width=\"515\"/></p>\n<p>🔑 他这和之前几个不同了，这个他还真给我解决了。</p>\n<p>所以为什么要写拷贝构造？写他有什么意义？没有什么意义。</p>\n<p><img alt=\"\" height=\"38\" src=\"..\\..\\static\\image\\69a4d7d238d741c1a1ab62fb3e6cd376.png\" width=\"38\"/> 默认生成的一般就够用了！</p>\n<p></p>\n<p><img alt=\"\" height=\"46\" src=\"..\\..\\static\\image\\487032e9759a498b87423c35b61efb3f.png\" width=\"52\"/> 当然，这并不意味着我们都不用写了，有些情况还是不可避免要写的</p>\n<p>比如实现栈的时候，栈的结构问题，导致这里如果用默认的 拷贝构造，会翻车。</p>\n<p>按字节把所有东西都拷过来会产生问题，如果<span style=\"color:#e6b223;\"> Stack</span> <strong>st1</strong> 拷贝出另一个 <span style=\"color:#e6b223;\">Stack</span><strong> st2</strong>(<strong>st1</strong>) </p>\n<p>会导致他们都指向那块开辟的内存空间，导致他们指向的空间被析构两次，导致程序崩溃</p>\n<p>然而问题不止这些……</p>\n<p><img alt=\"\" height=\"98\" src=\"https://img-blog.csdnimg.cn/5ce4e887e192427f89c32d72d9e450fa.gif\" width=\"98\"/> 其实这里的字节序拷贝是浅拷贝，下面几章我会详细讲一下深浅拷贝，这里的深拷贝和浅拷贝先做一个大概的了解。</p>\n<p></p>\n<p>🔺 总结：对于常见的类，比如日期类，默认生成的拷贝构造能用。但是对于栈这样的类，默认生成的拷贝构造不能用。</p>\n<p></p>\n<h2 id=\"%E2%85%A4.%C2%A0%20%E4%B8%89%E7%A7%8D%E6%9E%84%E9%80%A0%E7%9A%84%E6%80%BB%E7%BB%93\">Ⅴ.  总结</h2>\n<p><img alt=\"\" height=\"126\" src=\"..\\..\\static\\image\\2b2034afa08142ddbb2c07fb62943967.png\" width=\"459\"/></p>\n<p>默认成员函数有六只，本篇只介绍了三只，剩下的我们后面讲。</p>\n<p>类和对象部分知识很重要，所以我们来做一个简单的总结 ~</p>\n<p></p>\n<h3 id=\"0x00%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">0x00 构造函数 </h3>\n<p><img alt=\"\" height=\"87\" src=\"..\\..\\static\\image\\0802eb38b3dc447bb9ed7babdf7e3c3d.png\" width=\"78\"/>初始化，在对象实例化时候自动调用，保证实例化对象一定被初始化。</p>\n<p>构造函数是默认成员函数，我们不写编译器会自己生成一份，我们写了编译器就不会生成。</p>\n<p>我们不写内置类型成员变量不处理。</p>\n<p>对于内置类型成员变量不处理。</p>\n<p>对于自定义类型的成员变量会调用它的默认构造函数。</p>\n<pre><code class=\"language-cpp\">// 我们需要自己实现构造函数\nclass Date {\n    int _year;\n    int _month;\n    int _day;\n};\n        \n// 我们不需要自己实现构造函数，默认生成的就可以\nclass MyQueue {\n    Stack _pushST;\n    Stack _popST;\n};</code></pre>\n<p></p>\n<p></p>\n<h3 id=\"0x01%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">0x01 析构函数</h3>\n<p><img alt=\"\" height=\"90\" src=\"..\\..\\static\\image\\2120e1dfd65f4b3c92909bb8a605cb91.png\" width=\"83\"/> 完成对象中自愿的清理。如果类对象需要资源清理，才需要自己实现析构函数。</p>\n<p>析构函数在对象生命周期到了以后自动调用，如果你正确实现了析构函数，保证了类对象中的资源被清理。</p>\n<p>什么时候生命周期到了？如果是局部变量，出了作用域。全局和静态变量，整个程序结束。</p>\n<p>我们不写编译器会默认生成析构函数，我们实现了，编译器就不会实现了。</p>\n<p>对于内置类型成员变量不处理。</p>\n<p>对于自定义类型的成员变量会调用它的析构函数。</p>\n<pre><code class=\"language-cpp\">// 没有资源需要清理，不徐需要自己实现析构函数\nclass Date {\n    int _year;\n    int _month;\n    int _day;\n};\n\n// 需要自己实现析构函数，清理资源。\nclass Stack {\n    int* _a;\n    int  _top;\n    int  _capacity;\n};</code></pre>\n<p></p>\n<h3 id=\"0x02%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0\">0x02 拷贝构造</h3>\n<p><img alt=\"\" height=\"113\" src=\"..\\..\\static\\image\\c90553d71b2c4a0ab0f90daf97457fc8.png\" width=\"166\"/>使用同类型的对象去初始化实例对象。</p>\n<p>参数必须是引用！不然会导致无穷递归。</p>\n<p></p>\n<p>如果我们不实现，编译器会默认生成一份默认的拷贝构造函数。</p>\n<p>默认生成的拷贝构造：</p>\n<p>① 内置类型完成按子继续的值拷贝。 —— 浅拷贝</p>\n<p>② 自定义类型的成员变量，会去调用它的拷贝构造。</p>\n<pre><code class=\"language-cpp\">// 不需要自己实现，默认生成的拷贝构造，完成浅拷贝就能满足需求\nclass Date {\n    int _year;\n    int _month;\n    int _day;\n};\n\n// 需要自己实现，因为默认生成的浅拷贝不能满足需求。\n// 我们需要自己实现深拷贝的拷贝构造，深拷贝我们后面会用专门的章节去讲解。        \nclass Stack {\n    int* _a;\n    int  _top;\n    int  _capacity;\n};</code></pre>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Date {\npublic:\n    Date(int year = 1, int month = 0, int day = 0) {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n\n    void Print() {\n        printf(\"%d-%d-%d\\n\", _year, _month, _day);\n    }\n\n    ~Date() {\n        cout &lt;&lt; \"&amp;Date()\" &lt;&lt; endl;\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n\nint main(void)\n{\n    Date d1;\n    d1.Print();\n\n    Date d2(2002);\n    d2.Print();\n\n    Date d3(2022, 3);\n    d3.Print();\n\n    Date d4(2022, 3, 9);\n    d4.Print();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p> 🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"213\" src=\"..\\..\\static\\image\\d3768872beb641cd9e88ae021c0cd870.png\" width=\"509\"/></p>\n<p></p>\n<p></p>\n<hr/>\n<p><strong>参考资料：</strong></p>\n<p><span style=\"color:#a5a5a5;\">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p>\n<p><span style=\"color:#a5a5a5;\">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p>\n<p><span style=\"color:#a5a5a5;\">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p>\n<blockquote>\n<p>📌 笔者：王亦优</p>\n<p>📃 更新： 2022.3.15</p>\n<p>❌ 勘误：Star丶北辰：拿栈举例时malloc空间 sizeof 有误【已修正】</p>\n<p>📜 声明： 由于作者水平有限，本文有错误和不准确之处在所难免，本人也很想知道这些错误，恳望读者批评指正！</p>\n</blockquote>\n<p></p>\n<p>本章完。</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-29 18:34:01", "summary": "火速猛戳订阅《要笑着学》《要笑着学》趣味教学博客本篇博客热榜最高排名：写在前面朋友们好啊，今天终于更新了。我是柠檬叶子，本章将继续讲解中的面向对象的知识点，本篇主要讲解默认成员函数中的构造函数、析构函"}