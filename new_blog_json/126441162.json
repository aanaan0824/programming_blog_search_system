{"blogid": "126441162", "writerAge": "码龄2年", "writerBlogNum": "32", "writerCollect": "368", "writerComment": "763", "writerFan": "720", "writerGrade": "5级", "writerIntegral": "2749", "writerName": "即将秃头的菜鸟", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126441162.jpg", "writerRankTotal": "7225", "writerRankWeekly": "629", "writerThumb": "880", "writerVisitNum": "25758", "blog_read_count": "873", "blog_time": "已于 2022-09-04 21:45:18 修改", "blog_title": "七大排序算法（插排，希尔，选择排序，堆排，冒泡，快排，归并）--图文详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BC%95%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E8%A8%80\">引言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">一、直接插入排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</a></p>\n<p id=\"1%E3%80%81%E8%B5%B7%E5%A7%8B%E7%8A%B6%E6%80%81-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E8%B5%B7%E5%A7%8B%E7%8A%B6%E6%80%81\">1、起始状态</a></p>\n<p id=\"%C2%A02%E3%80%81%E5%BE%AA%E7%8E%AF%E6%97%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A02%E3%80%81%E5%BE%AA%E7%8E%AF%E6%97%B6\"> 2、循环时</a></p>\n<p id=\"3%E3%80%81%E6%9C%80%E5%90%8E%E7%BB%86%E8%8A%82-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81%E6%9C%80%E5%90%8E%E7%BB%86%E8%8A%82\">3、最后细节</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></p>\n<p id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6\">复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">二、希尔排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</a></p>\n<p id=\"1%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\">1、算法实现</a></p>\n<p id=\"2%E3%80%81%E8%AE%BE%E7%BD%AE%E5%A2%9E%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81%E8%AE%BE%E7%BD%AE%E5%A2%9E%E9%87%8F\">2、设置增量</a></p>\n<p id=\"%C2%A03%E3%80%81%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A03%E3%80%81%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2\"> 3、进行交换</a></p>\n<p id=\"4%E3%80%81%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F\">4、缩小增量</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">三、直接选择排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</a></p>\n<p id=\"1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96\">1、初始化</a></p>\n<p id=\"%C2%A02%E3%80%81%E4%BA%A4%E6%8D%A2-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A02%E3%80%81%E4%BA%A4%E6%8D%A2\"> 2、交换</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F\">四、堆排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">五、冒泡排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">六、快速排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</a></p>\n<p id=\"Hoare%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#Hoare%E6%B3%95\">Hoare法</a></p>\n<p id=\"%E6%8C%96%E5%9D%91%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8C%96%E5%9D%91%E6%B3%95\">挖坑法</a></p>\n<p id=\"%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95\">前后指针法</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"Hoare%E6%B3%95%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#Hoare%E6%B3%95%E4%BB%A3%E7%A0%81\">Hoare法代码</a></p>\n<p id=\"%E6%8C%96%E5%9D%91%E6%B3%95%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8C%96%E5%9D%91%E6%B3%95%E4%BB%A3%E7%A0%81\">挖坑法代码</a></p>\n<p id=\"%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95%E4%BB%A3%E7%A0%81\">前后指针法代码</a></p>\n<p id=\"%E5%BF%AB%E6%8E%92%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BF%AB%E6%8E%92%E4%BC%98%E5%8C%96\">快排优化</a></p>\n<p id=\"%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E6%B3%95\">三数取中法</a></p>\n<p id=\"%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E4%BB%A3%E7%A0%81\">三数取中代码</a></p>\n<p id=\"%E5%8A%A0%E5%85%A5%E6%8F%92%E6%8E%92-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8A%A0%E5%85%A5%E6%8F%92%E6%8E%92\">加入插排</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<p id=\"%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">七、归并排序</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></p>\n<p id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</a></p>\n<p id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%BC%95%E8%A8%80\">引言</h1>\n<p>排序算法，或许是我们日常最常见也是使用频率最多的算法。比如你在电商网站买东西，推荐商品往往基于相似度或者基于销售量等维度排序。我们每日接收的邮件是程序中按照时间进行排序好的，我们点外卖时候推送的列表是按照评分和地理位置进行排序的。搜索引擎检索内容也是按照一定的相似度算法进行排序好才呈现给你的，所以搜索引擎实际上就是一个排序引擎。</p>\n<p>本篇文章通过图例的方式逐一讲解最常使用的七大排序算法。<br/>  </p>\n<p><img alt=\"\" height=\"730\" src=\"..\\..\\static\\image\\ba86219f26244b8ba8f82f3bf77bc1e4.png\" width=\"1065\"/></p>\n<p><span style=\"color:#4da8ee;\">我下面所写的排序都按从小到达排</span></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">一、直接插入排序</h1>\n<h2 id=\"%E6%A6%82%E5%BF%B5\">概念</h2>\n<p>插入排序是一种原址（in-place）排序，<strong>原址的意思就是对于任何的输入数据序列都可以在不占用或者只占用常量的额外存储空间的情况下完成排序</strong>。插入排序对于已经排序好的数据可以实现O(n)的最佳排序时间，对于逆序的数据序列排序运行时间最差O(n^2).</p>\n<p><strong>总结</strong>：插入排序就是把待排序的每条记录按照值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。</p>\n<p>插入排序的理解，我们可以想象一下，我们与朋友一起玩扑克牌。在摸牌阶段，从牌堆中一张张的取牌，为了保持手里面一副牌一直保持有序状态，每次都会把新取得的扑克牌与手头的牌进行比较，比较的方式是从右向左，找到合适的位置，插入即可，这就是一种典型的插入排序。唯一需要注意的是，排序算法中的插入实际上是一种逐个交换实现的，而不是直接插到指定的位置。</p>\n<p>图片来自于百度图片。<br/><img alt=\"\" height=\"619\" src=\"..\\..\\static\\image\\c46ce3c11e4e471b9bde6e9567b5131f.png\" width=\"732\"/></p>\n<h2 id=\"%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90\">图文解析</h2>\n<h3 id=\"1%E3%80%81%E8%B5%B7%E5%A7%8B%E7%8A%B6%E6%80%81\"><strong>1、起始状态</strong></h3>\n<p>最开始的时候<img alt=\"\" height=\"293\" src=\"..\\..\\static\\image\\2a242443384f4431aaca2f2920ff3324.png\" width=\"1148\"/></p>\n<h3 id=\"%C2%A02%E3%80%81%E5%BE%AA%E7%8E%AF%E6%97%B6\"> <strong>2、循环时</strong></h3>\n<p>将 arr[i] 放到 tmp 里，让 arr[j] 和 tmp 中的值比较大小，要是 arr[j] &gt; tmp，那么就交换值，要      是小于的话就跳出这次循环。例如下图：（请大家比对最开始的图片想一下）</p>\n<p><img alt=\"\" height=\"568\" src=\"..\\..\\static\\image\\730ee574575f42f4ba3cfcac25ac6590.png\" width=\"1178\"/></p>\n<p></p>\n<h3 id=\"3%E3%80%81%E6%9C%80%E5%90%8E%E7%BB%86%E8%8A%82\"><strong>3、最后细节</strong></h3>\n<p>一直这样慢慢的比下去，到最后还需要把tmp里的值放回 arr[j+1]。如下图需要放回。</p>\n<p><img alt=\"\" height=\"324\" src=\"..\\..\\static\\image\\a28f68ac5a3644f19845f81404dc9422.png\" width=\"1194\"/></p>\n<h2 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</h2>\n<h3 id=\"%E4%BB%A3%E7%A0%81\">代码</h3>\n<pre><code class=\"language-java\">    public static void insertSort(int[] arr) {\n        for (int i = 1; i &lt; arr.length; i++) {\n            int tmp = arr[i];\n            for (int j = i - 1; j &gt;= 0; j--) {\n                if (arr[j] &gt; tmp) {\n                    arr[j+1] = arr[j];\n                }else {\n                    break;\n                }\n                arr[j+1] = tmp;\n            }\n        }\n    }</code></pre>\n<h3 id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6\">复杂度</h3>\n<p>时间复杂度：</p>\n<ol><li>最好  O(n)  有序</li><li>最好  O(n^2)  逆序</li><li>结论：对于直接插入排序，数据越有序越快。</li><li>应用场景：当数据基本上是有序的时候，使用直接插入排序。</li></ol>\n<p>空间复杂度：</p>\n<p>O(1)</p>\n<h3 id=\"%E7%A8%B3%E5%AE%9A%E6%80%A7\">稳定性</h3>\n<p>稳定的排序</p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">二、希尔排序</h1>\n<h2>概念</h2>\n<p>希尔排序是把序列按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量的逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个序列恰好被分为一组，算法便终止。</p>\n<h2>图文解析</h2>\n<h3 id=\"1%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\">1、算法实现</h3>\n<p>希尔排序需要定义一个增量，这里选择增量为 gap = length / 2，缩小增量以 gap = gap / 2 的方式，这个增量可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列，这个增量是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。</p>\n<h3 id=\"2%E3%80%81%E8%AE%BE%E7%BD%AE%E5%A2%9E%E9%87%8F\">2、设置增量</h3>\n<p></p>\n<p>对于一个无序序列[8，9，1，7，2，3，5，4，6，0]来说，我们初始增量为 gap = length / 2 =&gt; 5，所以这个序列要被分为5组，分别是[8，3]，[9，5]，[1，4]，[7，6]，[2，0]，对这5组分别进行直接插入排序，则小的元素就被调换到了前面，然后再缩小增量 gap = gap / 2 =&gt; 2。</p>\n<p><img alt=\"\" height=\"450\" src=\"..\\..\\static\\image\\6200025ab2354ca081a03c36485e74d0.png\" width=\"1032\"/></p>\n<h3 id=\"%C2%A03%E3%80%81%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2\"> 3、进行交换</h3>\n<p>下图是第一次交换后的结果，大家观察，希尔排序的一次交换能交换几个值，就不是直接插入排序那样需要一个个的去交换，这样就节省了时间。</p>\n<p><img alt=\"\" height=\"465\" src=\"..\\..\\static\\image\\3e9de7a0f6d74b9c8757691ecf2cf0ac.png\" width=\"1048\"/></p>\n<h3 id=\"4%E3%80%81%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F\">4、缩小增量</h3>\n<p>缩小增量后第二次交换：</p>\n<p>序列再次被分为2组，分别是 [3，1，0，9，7] 和 [5，6，8，4，2]，再对这两组进行直接插入排序，那么序列就更加有序了。</p>\n<p> <img alt=\"\" height=\"281\" src=\"..\\..\\static\\image\\7f6d8f3eb2c742d092fd2b1596848522.png\" width=\"1035\"/></p>\n<p> <img alt=\"\" height=\"186\" src=\"..\\..\\static\\image\\a9fdb47d90a34220ae83ac0b1f92fc9e.png\" width=\"1017\"/></p>\n<p> 然后再缩小增量，gap = gap / 2  =&gt; 1，这时整个序列就被分为一组即 [0，2，1，4，3，5，7，6，9，8]，最后再进行调整，就得到了有序序列 [0，1，2，3，4，5，6，7，8，9]。</p>\n<p><img alt=\"\" height=\"563\" src=\"..\\..\\static\\image\\a73b20390a934a26873c1f8e67ec1940.png\" width=\"1057\"/></p>\n<h2>代码实现</h2>\n<h3>代码</h3>\n<p>确定增量代码</p>\n<pre><code class=\"language-java\">    public static void shellSort(int[] arr) {\n        int gap = arr.length;\n        while (gap &gt; 1) {\n            shell(arr,gap);\n            gap /= 2;\n        }\n        shell(arr,1);\n    }</code></pre>\n<p>排序代码</p>\n<pre><code class=\"language-java\">    public static void shell(int[] arr, int gap) {\n        for (int i = gap; i &lt; arr.length; i++) {\n            int tmp = arr[i];\n            for (int j = i - gap; j &gt;= 0; j -= gap) {\n                //加上等号 就是不稳定\n                if(arr[j] &gt; tmp) {\n                    arr[j+gap] = arr[j];\n                }else {\n                    break;\n                }\n                arr[j+gap] = tmp;\n            }\n        }\n    }</code></pre>\n<h3 id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</h3>\n<p>        参考资料：《数据结构(C语言版)》--- 严蔚敏</p>\n<p>        希尔排序的分析是一个复杂的问题,因为它的时间是所取“增量”序列的函数,这涉及一些数学上尚未解决的难题。因此,到目前为止尚未有人求得-种最好的增量序列,但大量的研究已得出一-些局部的结论。如有人指出,当增量序列为 dlta[k] = 2^(-k+1) -1时,希尔排序的时间复杂度为 O(n^3/2) 其中 t 为排序趟数, 1 ≤ k ≤ t ≤ [log2(n+1)]。还有人在大量的实验基础上推出，当n在某个特定范围内,希尔排序所需的比较和移动次数约为n^1.3,当n→∞时,可减少到n(log2n)2。 增量序列可以有各种取法中,但需注意:应使增量序列中的值没有除1之外的公因子,并且最后一个增量值必须等于1。</p>\n<p>总结来说就是经过很多大佬的计算，希尔排序的时间复杂度没有一个确定的值，确定的大概范围是：O(N^1.3 - N^1.5)</p>\n<h3 id=\"%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">空间复杂度</h3>\n<p>O(1)</p>\n<h3>稳定性</h3>\n<p>不稳定的排序</p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">三、直接选择排序</h1>\n<h2>概念</h2>\n<p>        直接选择排序是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零，选择排序是一种不稳定的排序方法。</p>\n<h2>图文解析</h2>\n<h3 id=\"1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96\">1、初始化</h3>\n<p>假设 arr[0] 是数组最小值，然后分别与其他几个数进行比较，如果遇到比其小的就与其交换，经过一轮循环后最小的数就在最始端。重复上述操作直至剩余最后一个数。<img alt=\"\" height=\"174\" src=\"..\\..\\static\\image\\54a171e449314ec984e4622818bb656f.png\" width=\"755\"/></p>\n<h3 id=\"%C2%A02%E3%80%81%E4%BA%A4%E6%8D%A2\"> 2、交换</h3>\n<p>设 minIndex 是最小值的下标，让 arr[minIndex] 和 arr[j] 比较，寻找 arr[i] 后面的最小值，来放到前面。</p>\n<p>第一次交换：</p>\n<p><img alt=\"\" height=\"312\" src=\"..\\..\\static\\image\\3da043a8b3fd4bde912e7fa8d2f52449.png\" width=\"802\"/> 第二次交换：</p>\n<p><img alt=\"\" height=\"326\" src=\"..\\..\\static\\image\\54d52c7f7dbe40309d8fd52312dc2915.png\" width=\"785\"/></p>\n<p> 重复上述操作，直至最后一个数。</p>\n<h2>代码实现</h2>\n<h3>代码</h3>\n<p>特点: 当数组趋于有序的时候,运行速度就会很快.</p>\n<pre><code class=\"language-java\">    public static void selectSort(int[] arr) {\n        for (int i = 0; i &lt; arr.length; i++) {\n            int minIndex = i;\n            for (int j = i+1; j &lt; arr.length; j++) {\n                if (arr[minIndex] &gt; arr[j]) {\n                    minIndex = j;\n                }\n            }\n            swap(arr,minIndex,i);\n        }\n    }\n\n    //交换函数\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }</code></pre>\n<h3>时间复杂度</h3>\n<p>根据代码就能看出有两层循环，不管是无序数组还是有序数组。所以</p>\n<p>时间复杂度：O(n^2)</p>\n<h3>空间复杂度</h3>\n<p>O(1)</p>\n<h3>稳定性</h3>\n<p>不稳定的排序</p>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F\">四、堆排序</h1>\n<h2>概念</h2>\n<p>关于堆排大家可以看看我这篇关于堆的博客: <a href=\"https://blog.csdn.net/qq_52592775/article/details/126469817\" title=\"堆--图文详解_即将秃头的菜鸟的博客-CSDN博客\">堆--图文详解_即将秃头的菜鸟的博客-CSDN博客</a></p>\n<h2>代码实现</h2>\n<h3>代码</h3>\n<pre><code class=\"language-java\">    public static void heapSort(int[] arr) {\n        createHeap(arr);\n        int end = arr.length-1;\n        while (end &gt;= 0) {\n            swap(arr,0,end);\n            shiftDown(arr,0,end);\n            end--;\n        }\n    }\n\n    public static void createHeap(int[] arr) {\n        for (int parent = (arr.length-1-1)/2; parent &gt;= 0; parent--) {\n            shiftDown(arr, parent, arr.length);\n        }\n    }\n\n    public static void shiftDown(int[] arr, int parent, int len) {\n        int child = parent*2 + 1;\n        //保证有左孩子\n        while (child &lt; len) {\n            if (child &lt; len &amp;&amp; arr[child] &lt; arr[child+1]) {\n                child++;\n            }\n            if (arr[child] &gt; arr[parent]) {\n                swap(arr, child, parent);\n                parent = child;\n                child = parent*2 + 1;\n            }else {\n                break;\n            }\n        }\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }</code></pre>\n<h3>时间复杂度</h3>\n<p>O(n*logn)</p>\n<h3>空间复杂度</h3>\n<p>O(1)</p>\n<h3>稳定性</h3>\n<p>不稳定的</p>\n<p></p>\n<h1 id=\"%E4%BA%94%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">五、冒泡排序</h1>\n<h2>概念</h2>\n<p>冒泡排序的英文<strong>Bubble Sort</strong>，是一种最基础的<strong>交换排序</strong>。之所以叫做冒泡排序，因为每一个元素都可以像小气泡一样，根据自身大小一点一点向<a href=\"https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020\" title=\"数组\">数组</a>的一侧移动。</p>\n<h2>图文解析</h2>\n<p>原理:</p>\n<p>每一趟只能确定将一个数归位。即第一趟只能确定将末位上的数归位，第二趟只能将倒数第 2 位上的数归位，依次类推下去。如果有 n 个数进行排序，只需将 n-1 个数归位，也就是要进行 n-1 趟操作。而 “每一趟 ” 都需要从第一位开始进行相邻的两个数的比较，将较大的数放后面，比较完毕之后向后挪一位继续比较下面两个相邻的两个数大小关系，重复此步骤，直到最后一个还没归位的数。<br/> 冒泡排序就懒得画图了,从C语言写到现在.</p>\n<p>就有一点优化, 在每一层循环中间可以检查是否还需要交换,不需要交换直接进入下一躺循环.</p>\n<h2>代码实现</h2>\n<h3>代码</h3>\n<pre><code class=\"language-java\">    public static void bubbleSort(int[] arr) {\n        for (int i = 0; i &lt; arr.length-1; i++) {\n            boolean flg = false;\n            for (int j = 0; j &lt; arr.length-1-i; j++) {\n                if (arr[j] &gt; arr[j+1]) {\n                    swap(arr, j, j+1);\n                    flg = true;\n                }\n            }\n            if (!flg) {\n                break;\n            }\n        }\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }</code></pre>\n<h3>时间复杂度</h3>\n<p>O(n^2)</p>\n<h3>空间复杂度</h3>\n<p>O(1)</p>\n<h3>稳定性</h3>\n<p>稳定的排序</p>\n<p></p>\n<h1 id=\"%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">六、快速排序</h1>\n<h2>概念</h2>\n<p><a href=\"https://so.csdn.net/so/search?q=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;spm=1001.2101.3001.7020\" title=\"快速排序\">快速排序</a>之所以快，是相对于冒泡排序，不再是只有相邻的数之间交换，它是可以<code>跳跃式</code>的交换，交换的距离会变得大的多，所以速度就提高了，当然也会存在最坏的结果，仍然是跟冒泡一样是相邻的两数之间进行了交换，所以它最差的<a href=\"https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1001.2101.3001.7020\" title=\"时间复杂度\">时间复杂度</a>和冒泡排序是一样的.</p>\n<p></p>\n<h2>图文解析</h2>\n<h3 id=\"Hoare%E6%B3%95\">Hoare法</h3>\n<p>快速排序是<strong>Hoare</strong>于1962年提出的<strong>一种二叉树结构的交换排序方法</strong>，其基本思想为：<strong>任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</strong></p>\n<p>数组最开始的状态:</p>\n<p><img alt=\"\" height=\"271\" src=\"..\\..\\static\\image\\4bfffc4bff2d46b0beaeb784e286c7c3.png\" width=\"980\"/></p>\n<p>每次由 right 先走, 遇到比 key 小的停下, 然后 left 走, 遇到比 key 大的停下, 交换两值,如下图:</p>\n<p><img alt=\"\" height=\"438\" src=\"..\\..\\static\\image\\a986ec90fe464f849e71e8bb3d9246f5.png\" width=\"993\"/></p>\n<p> 然后呢, right 继续往前走, left 继续往后走, 直到两个相遇:</p>\n<p><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\e8d547d4ebf042eeabdf332dc8c70473.png\" width=\"1057\"/></p>\n<p> 这个时候再让 key 和 left 交换, 就达到了目的, 使得 key 左边是比 key 小的数字, key 右边是比 key 大的数字,效果如下:</p>\n<p><img alt=\"\" height=\"225\" src=\"..\\..\\static\\image\\7c534be92ac341c78dbbd3f331006929.png\" width=\"1028\"/></p>\n<p> 然后再以 key 为基准, 将 6 的左右两边继续排序,有点类似于二叉树.</p>\n<p><img alt=\"\" height=\"356\" src=\"..\\..\\static\\image\\25acc5e6fe0e4b699905908df0c8a20d.png\" width=\"1144\"/></p>\n<p>继续让 right 先走, 碰到比 key 小的停下, 再让 left 走, 碰到比 key 大的停下, 然后交换.</p>\n<p>这样一步步走下来, 最后就能得到有序的数列:</p>\n<p><img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\af002ab8432b47659fae999296387437.png\" width=\"1009\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 注意:</strong></span></p>\n<p>左边做 key , 为啥右边先走呢?</p>\n<p>假设左边先走, 那么就会出现这样的情况:</p>\n<p><img alt=\"\" height=\"717\" src=\"..\\..\\static\\image\\9d830696032b4cf79a78038f90f23950.png\" width=\"1046\"/></p>\n<p> 如上图所示,最后 6 和 9 交换,但是当 9 换到前面去了数组还是无序的状态,所以这样是不行的. 只能从右边开始走.</p>\n<p></p>\n<h3 id=\"%E6%8C%96%E5%9D%91%E6%B3%95\">挖坑法</h3>\n<p>最开始的时候把 key-6 当作坑位,  把 6 取出来, 此时当作坑位里面没放数据,</p>\n<p><img alt=\"\" height=\"284\" src=\"..\\..\\static\\image\\798f937ee8d44cc0aa2459c3448ad219.png\" width=\"993\"/></p>\n<p> 让 right 向左先走, 遇到比 key 小的数字就把 right  的值拿出来放进坑位中去,  right 变成新的坑位, 然后让 left 向后走, 找到比 6 大的数字放进坑位中, 然后 left 位置又空出来变成一个坑位.</p>\n<p><img alt=\"\" height=\"495\" src=\"..\\..\\static\\image\\f3f72cdfeaaa4b108ad783e3720f422a.png\" width=\"962\"/></p>\n<p> <img alt=\"\" height=\"302\" src=\"..\\..\\static\\image\\b887349b668d40b6add9f153553d82e8.png\" width=\"957\"/></p>\n<p> 最后就是这样的情况 : 需要把开始拿出来的 6 给补进去.</p>\n<p><img alt=\"\" height=\"231\" src=\"..\\..\\static\\image\\2f869a0543e54ec5832c62de38e9baec.png\" width=\"990\"/></p>\n<h3 id=\"%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95\">前后指针法</h3>\n<p><img alt=\"\" height=\"281\" src=\"..\\..\\static\\image\\185da208cb4a4ef3b9a516c9009c2281.png\" width=\"982\"/></p>\n<p> 还是将第一个数字作为基准, 设置两个指针, cur 在前先走, prev 在后,  当 cur 位置的值不等于 key 位置的值, 那么就让 cur 和 prev 交换, 这样一步步走下去.</p>\n<p><img alt=\"\" height=\"603\" src=\"..\\..\\static\\image\\65b302d094e24ebd83bb48e0450b7e30.png\" width=\"993\"/></p>\n<p> 注意这个时候:</p>\n<p><img alt=\"\" height=\"265\" src=\"..\\..\\static\\image\\f5181cc2442b49569178ce9c0f145120.png\" width=\"987\"/></p>\n<p> 下面 cur 后一直往后走, 因为后面没有比 6 小的值, 所以后面就是 5 和 6 换.</p>\n<p><img alt=\"\" height=\"310\" src=\"..\\..\\static\\image\\caaddb87c0c6432fa4bdf323b1b95621.png\" width=\"1117\"/></p>\n<p></p>\n<h2>代码实现</h2>\n<h3 id=\"Hoare%E6%B3%95%E4%BB%A3%E7%A0%81\">Hoare法代码</h3>\n<pre><code class=\"language-java\">    public static void quickSort(int[] array) {\n        quick(array,0,array.length-1);\n    }\n    \n    public static void quick(int[] arr, int left, int right) {\n        //只有一个节点 大于号 -&gt;有可能没有子树\n        if (left &gt;= right) {\n            return;\n        }\n\n        int pivot = partitionHoare(arr,left,right);\n\n        quick(arr,left,pivot-1);\n        quick(arr,pivot+1,right);\n    }\n\n    /**\n     * Hoare法  找基准\n     * @param arr\n     * @param start\n     * @param end\n     * @return\n     */\n    private static int partitionHoare(int[] arr,int start,int end) {\n        int i = start; //事先储存好 start 下标\n        int key = arr[start];\n        while (start &lt; end) {\n            while (start &lt; end &amp;&amp; arr[end] &gt;= key) {\n                end--;\n            }\n            while (start &lt; end &amp;&amp; arr[start] &lt;= key) {\n                start++;\n            }\n            swap(arr, end, start);\n        }\n        swap(arr, start, i);\n        return start;\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>细节</strong></span></p>\n<p><span style=\"color:#0d0016;\">1.要事先存储好 start 的下标.</span></p>\n<p><span style=\"color:#0d0016;\">2.这里为什么能加等号?</span></p>\n<p><img alt=\"\" height=\"404\" src=\"..\\..\\static\\image\\65c09587653d4cf58e26979e239cb179.png\" width=\"698\"/></p>\n<p></p>\n<p> 假设数组是这种情况:</p>\n<p><img alt=\"\" height=\"231\" src=\"..\\..\\static\\image\\2a3724d4696f49b580508aa948003aad.png\" width=\"968\"/></p>\n<p> 要是没有 = 的话, 6 就不大于 6 , 这里就会一直死循环.</p>\n<h3 id=\"%E6%8C%96%E5%9D%91%E6%B3%95%E4%BB%A3%E7%A0%81\">挖坑法代码</h3>\n<pre><code class=\"language-java\">    public static void quickSort(int[] array) {\n        quick(array,0,array.length-1);\n    }\n\n    public static void quick(int[] arr, int left, int right) {\n        //只有一个节点 大于号 -&gt;有可能没有子树\n        if (left &gt;= right) {\n            return;\n        }\n\n        int pivot = partitionHole(arr,left,right);\n\n        quick(arr,left,pivot-1);\n        quick(arr,pivot+1,right);\n    }\n\n    /**\n     * 挖坑法\n     * @param arr\n     * @param start\n     * @param end\n     * @return\n     */\n    private static int partitionHole(int[] arr, int start, int end) {\n        int key = arr[start];\n\n        while (start &lt; end) {\n            while (start &lt; end &amp;&amp; arr[end] &gt;= key) {\n                end--;\n            }\n            arr[start] = arr[end];\n\n            while (start &lt; end &amp;&amp; arr[start] &lt;= key) {\n                start++;\n            }\n            arr[end] = arr[start];\n        }\n        arr[start] = key;\n        return start;\n    }</code></pre>\n<h3 id=\"%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95%E4%BB%A3%E7%A0%81\">前后指针法代码</h3>\n<pre><code class=\"language-java\">    /**\n     * 前后指针法\n     * @param arr\n     * @param start\n     * @param end\n     * @return\n     */\n    private static int partitionPointer(int[] arr, int start, int end) {\n        int prev = start;\n        int cur = start + 1;\n\n        while (start &lt; end) {\n            if (arr[cur] &lt; arr[start] &amp;&amp; arr[++prev] != arr[cur]) {\n                swap(arr, cur, prev);\n            }\n            cur++;\n        }\n        swap(arr, prev, start);\n        return prev;\n    }</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>注意</strong></span></p>\n<p>下图是Hoare法代码</p>\n<p><img alt=\"\" height=\"152\" src=\"..\\..\\static\\image\\a4123ba18222435984b29f320714f3ec.png\" width=\"544\"/></p>\n<p> 下图是挖坑法代码</p>\n<p><img alt=\"\" height=\"129\" src=\"..\\..\\static\\image\\e1f0143026344864b4a99e0fed7ec26c.png\" width=\"483\"/></p>\n<p></p>\n<p>家人们,咱们看着代码说哦, 由代码我们可以知道这里是在进行递归, 那么在数组较大的时候,很大可能会发生栈溢出的情况,就像这种, 我创建数组来进行测试快排运行的时间和是否会造成栈溢出的情况 :</p>\n<pre><code class=\"language-java\">//无序数组\n    public static void initArrayNotOrder(int[] array) {\n        Random random = new Random();\n        for (int i = 0; i &lt; array.length; i++) {\n            array[i] = random.nextInt(1000_0000);\n        }\n    }\n\n    //有序数组\n    public static void initArrayOrder(int[] array) {\n        for (int i = 0; i &lt; array.length; i++) {\n            array[i] = array.length-i;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = new int[100_0000];\n        initArrayOrder(array);//有序\n        //initArrayNotOrder(array);//无序\n\n        testQuickSort(array);\n    }\n\n    public static void testQuickSort(int[] array) {\n        array = Arrays.copyOf(array,array.length);\n        long startTime = System.currentTimeMillis();\n\n        QuickSort.quickSort(array);\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"快速排序耗时：\"+(endTime-startTime));\n    }</code></pre>\n<p>无序状态下:</p>\n<p><img alt=\"\" height=\"465\" src=\"..\\..\\static\\image\\9eed5f7380324f689f08f977164ac40a.png\" width=\"1124\"/></p>\n<p> 有序状态下:</p>\n<p><img alt=\"\" height=\"543\" src=\"..\\..\\static\\image\\76a313852ec748849e44080a727453ce.png\" width=\"1200\"/></p>\n<p></p>\n<p> 在有序状态下, 当数据较多的情况下, 就出现了<span style=\"color:#fe2c24;\">栈溢出</span>的情况, 这个时候就说明代码需要进行优化,并且说明<span style=\"color:#fe2c24;\">快排在无序环境下更加适用</span>.</p>\n<p>所以我们就对快排进行了优化:</p>\n<h2 id=\"%E5%BF%AB%E6%8E%92%E4%BC%98%E5%8C%96\">快排优化</h2>\n<h3 id=\"%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E6%B3%95\">三数取中法</h3>\n<p><img alt=\"\" height=\"419\" src=\"..\\..\\static\\image\\8be210cca6dc435f84896a2d3cd8b2c6.png\" width=\"464\"/></p>\n<p> 如上图, 三数取中的意思就是, 在 left mid right 三个数之中选取中间的那个数作为基准, 以此来进行排序. </p>\n<p>总的说来, 三数取中就是 <span style=\"color:#fe2c24;\">解决递归深度问题</span> 基本上 有了三数取中 你的待排序序列 基本上每次都是二分N*logn</p>\n<h3 id=\"%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E4%BB%A3%E7%A0%81\">三数取中代码</h3>\n<pre><code class=\"language-java\">    /**\n     * 三数取中法\n     * @param array\n     * @param left\n     * @param right\n     * @return\n     */\n    private static int midNumIndex(int[] array,int left,int right) {\n        int mid = (left + right) / 2 ;\n\n        if (array[left] &lt; array[right]) {\n            if (array[mid] &lt; array[left]) {\n                return left;\n            }else if (array[mid] &gt; array[right]) {\n                return right;\n            }else {\n                return mid;\n            }\n        }else {\n            if (array[mid] &lt; array[right]) {\n                return right;\n            }else if (array[mid] &gt; array[left]) {\n                return left;\n            }else {\n                return mid;\n            }\n        }\n    }</code></pre>\n<h3 id=\"%E5%8A%A0%E5%85%A5%E6%8F%92%E6%8E%92\">加入插排</h3>\n<p>因为快排是递归进行的, 类似于二叉树最后几个元素的时候, 我们这个时候在进行递归其实是耗时的一件事情, 那么就想到了, 在数据较少的情况下, 插入排序更加适用于这种情况, 所以我们可以在最后元素较少的时候, 进行插入排序, 就能使得我们的运算更快.</p>\n<pre><code class=\"language-java\">    private static void quick(int[] arr, int left, int right) {\n        //这里代表 只要一个节点了 大于号：有可能没有子树  有序  逆序\n        if(left &gt;= right) {\n            return;\n        }\n\n        //小区间使用直接插入排序： 主要 优化了递归的深度\n        if(right - left + 1 &lt;= 7) {\n            //使用直接插入排序\n            insertSort(arr,left,right);\n            return;\n        }\n\n        //三数取中：解决递归深度问题 基本上 有了三数取中  你的待排序序列 基本上每次都是二分N*logn\n        int index = midNumIndex(arr,left,right);\n        swap(arr,left,index);\n\n        int pivot = partitionHoare(arr,left,right);\n\n        quick(arr,left,pivot-1);\n        quick(arr,pivot+1,right);\n    }\n\n    public static void insertSort(int[] array, int start, int end) {\n        for (int i = start+1; i &lt;= end; i++) {\n            int tmp = array[i];\n            int j = i-1;\n            for (; j &gt;= start; j--) {\n                //加上等号 就是不稳定\n                if (array[j] &gt; tmp) {\n                    array[j+1] = array[j];\n                }else {\n                    break;\n                }\n            }\n            array[j+1] = tmp;\n        }\n    }</code></pre>\n<h3>时间复杂度</h3>\n<p>O(N*logN)    理想 -&gt; 每次都是均分待排序序列</p>\n<h3>空间复杂度</h3>\n<p>最好：O(logN)</p>\n<p>最坏：O(N)  当N 足够大的时候 ，递归的深度就大</p>\n<h3>稳定性</h3>\n<p>不稳定的排序</p>\n<p></p>\n<h1 id=\"%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">七、归并排序</h1>\n<h2>概念</h2>\n<p><span style=\"color:#fe2c24;\"><strong>核心思想：分治</strong></span></p>\n<p><span style=\"color:#0d0016;\">当</span><span style=\"color:#fe2c24;\">数据量很大的时候</span>  <span style=\"color:#0d0016;\">nlogn 的优势将会比 n^2 越来越大，当 n=10^5 的时候，nlogn 的算法要比n^2 的算法快6000倍，那么6000倍是什么概念呢，就是如果我们要处理一个数据集，用 nlogn 的算法要处理一天的话，用 n^2 的算法将要处理 6020 天。这就基本相当于是15年。一个优化改进的算法可能比一个比一个笨的算法速度快了许多，这个时候归并排序就应运而生.</span></p>\n<h2>图文解析</h2>\n<p><img alt=\"\" height=\"550\" src=\"..\\..\\static\\image\\3200813dab4d42699c28aa15231b8f00.png\" width=\"718\"/></p>\n<p>看归并排序, 要是学了二叉树的话会更号理解一点.</p>\n<p>假设数组最开始是这样的情况:<img alt=\"\" height=\"236\" src=\"..\\..\\static\\image\\b1f0b8601dee45f092165b3d57348b58.png\" width=\"831\"/></p>\n<p> 下面开始进行分治, 我取一半来画图, 大家应该就懂了.</p>\n<p></p>\n<p>也是设置了 left  mid  right  三个指针来更好的表示, 每次都递归下去, 这样一层一层的就会很简单了</p>\n<h2>代码实现</h2>\n<h3>代码</h3>\n<pre><code class=\"language-java\">    public static void mergerSort(int[] array) {\n        mergeSortFunc(array,0,array.length-1);\n    }\n\n    private static void mergeSortFunc(int[] array,int left,int right) {\n        if(left &gt;= right) {\n            return;\n        }\n        int mid = (left+right) / 2;\n        //1、分解左边\n        mergeSortFunc(array,left,mid);\n        //2、分解右边\n        mergeSortFunc(array,mid+1,right);\n        //3、进行合并\n        merge(array,left,right,mid);\n    }\n\n    private static void merge(int[] array, int start, int end, int midIndex) {\n\n        int[] tmpArr = new int[end-start+1];\n        int k = 0;//tmpArr数组的下标\n\n        int s1 = start;\n        int s2 = midIndex+1;\n\n        //两个归并段 都有数据\n        while (s1 &lt;= midIndex &amp;&amp; s2 &lt;= end) {\n            if(array[s1] &lt;= array[s2]) {\n                tmpArr[k++] = array[s1++];\n            }else {\n                tmpArr[k++] = array[s2++];\n            }\n        }\n\n        //当走到这里的时候 说明 有个归并段 当中 没有了数据 ，拷贝另一半的全部 到tmpArr数组当中\n        while (s1 &lt;= midIndex) {\n            tmpArr[k++] = array[s1++];\n        }\n\n        while (s2 &lt;= end) {\n            tmpArr[k++] = array[s2++];\n        }\n        //把排好序的数字  拷贝回 原数组\n        for (int i = 0; i &lt; k; i++) {\n            array[i+start] = tmpArr[i];\n        }\n    }</code></pre>\n<h3>时间复杂度</h3>\n<p>O(n*logn)</p>\n<h3>空间复杂度</h3>\n<p>O(n)</p>\n<h3>稳定性</h3>\n<p>稳定的排序</p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-04 21:45:18", "summary": "目录引言一、直接插入排序概念图文解析、起始状态、循环时、最后细节代码实现代码复杂度稳定性二、希尔排序概念图文解析、算法实现、设置增量、进行交换、缩小增量代码实现代码时间复杂度空间复杂度稳定性三、直接选"}