{"blogid": "126049127", "writerAge": "码龄5年", "writerBlogNum": "152", "writerCollect": "331", "writerComment": "51", "writerFan": "783", "writerGrade": "5级", "writerIntegral": "1875", "writerName": "ViperL1", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126049127.jpg", "writerRankTotal": "10046", "writerRankWeekly": "1944", "writerThumb": "64", "writerVisitNum": "75843", "blog_read_count": "655", "blog_time": "于 2022-07-29 17:40:57 发布", "blog_title": "C#的架构、框架、设计模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>建立层务必使用<span style=\"color:#fe2c24;\"><strong>类库</strong></span>选项，不要使用文件夹（没错，说的就是我自己）</p>\n<h1>一、两层架构</h1>\n<h2>        1.架构概述</h2>\n<p>                两层架构适合<strong>小型 / 中小型</strong>项目</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>名称</td><td>标识</td><td>用途</td></tr><tr><td>数据访问对象</td><td>DAL</td><td>模型服务，需要添加Models引用</td></tr><tr><td>实体对象</td><td>Models</td><td>模型</td></tr><tr><td>用户界面</td><td>UI</td><td>交互界面，需要添加DAL和Models引用</td></tr></tbody></table>\n<p class=\"img-center\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\e7c5905efe53413ea8cca391c929e492.png\" width=\"435\"/></p>\n<h2>         2.实体对象的序列化</h2>\n<p>                <strong>序列化</strong>：将对象状态转换为可保持/传输的格式，会<strong>转换为字节流</strong></p>\n<p>                <strong>反序列化</strong>：将<strong>流转换为对象</strong></p>\n<p>                <strong>实现</strong>：在类中加入可序列化标记<strong>[Serializable]</strong></p>\n<h1>二、三层架构</h1>\n<h2>        1.架构概述</h2>\n<p>                适合<strong>大 / 中型</strong>应用开发</p>\n<p class=\"img-center\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\6ea456b0cb714f709274947dc46d8598.png\" width=\"554\"/></p>\n<p class=\"img-center\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\eaee34d6ffd24113a16f5ad883f48305.png\" width=\"268\"/></p>\n<h2>         2.命名规范（通用）</h2>\n<p class=\"img-center\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\f0f468a46a1442a18ce365d3ad917314.png\" width=\"577\"/></p>\n<h2>         3.DAL与BLL</h2>\n<pre><code class=\"language-cs\">//BLL\npublc class StudentManager\n{\n    private StudentSeiver objStu = new StudentSeiver ();    //创建数据访问对象\n\n    public List&lt;Student&gt; GetAllStu()\n    {\n        return objStu.GetAllStu();    //仅起数据传递作用\n    }\n\n    public List&lt;Student&gt; GetStuByClass(string className)\n    {\n        if(className == null || className.lenght == 0)\n            return objStu.GetStu();\n        else\n            return ibjStu.GetStuByClass(className);    //根据不同查询条件实现数据访问\n    }\n}\n</code></pre>\n<p>                在主程序中，<strong>仅需调用BLL中的接口</strong>，而无需去处理DAL中的具体方法（进一步分离）</p>\n<p>                相当于<strong>将原来位于UI层的业务逻辑处理<span style=\"color:#fe2c24;\">下移到了BLL层</span></strong></p>\n<h2>        4.特征</h2>\n<p>                <strong>优点</strong>：分离开发人员关注的内容；        项目需求变化时，程序模组可以无损替换；        提高代码的可复用性；</p>\n<p>                <strong>缺点</strong>：代码量大；        实现复杂；</p>\n<h1>三、通用控制层的扩展</h1>\n<h2>        1.通用层的概念</h2>\n<p>                用以<strong>复用一些共用技术</strong>，如：通用的辅助类和工具方法；数据校验方法；缓存处理、加密方法</p>\n<p>                以<strong>Common</strong>为标识</p>\n<p class=\"img-center\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\1dd0855a9e44407b828c65f58995bce7.png\" width=\"568\"/></p>\n<h1> 四、接口与多态</h1>\n<h2>        1.软件设计中的接口</h2>\n<p>                .Net中的接口定义规范：①使用关键字<span style=\"color:#956fe7;\"><strong>interface</strong></span>定义，接口类一般以<span style=\"color:#4da8ee;\"><strong> I</strong> </span>开头</p>\n<p>                                                       ②接口中的属性、方法<strong>只做声明而不具体实现</strong></p>\n<p>                                                       ③<strong>均为public</strong></p>\n<p class=\"img-center\"><img alt=\"\" height=\"150\" src=\"..\\..\\static\\image\\c0eac741481b45e5ab0e71c134b4919f.png\" width=\"394\"/></p>\n<p>                 接口的<strong>实现</strong></p>\n<p class=\"img-center\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\f7b4054a4b50447e93734f43dc6e4fe2.png\" width=\"616\"/></p>\n<p>                 <strong>特点</strong>：①接口具有<strong>强制性</strong>，实现接口的类必须实现接口的所有成员</p>\n<p>                            ②一个类即可以实现多个接口，<strong>也可以同时继承其他类</strong></p>\n<p class=\"img-center\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\cd015f11e5dc413cbf64aba26f433ed2.png\" width=\"434\"/></p>\n<h2>         2.应用多态实现多态</h2>\n<p>                前提条件：①一个接口必须被 两个/以上 的类实现</p>\n<p>                                  ②接口实现类必须转换成接口类型去使用</p>\n<p class=\"img-center\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\8e876c06fff94fb5b33b0af7fa5bb074.png\" width=\"461\"/></p>\n<p>                 与<strong>继承多态</strong>的比较</p>\n<table cellspacing=\"0\" style=\"width:389.27pt;\"><tbody><tr><td style=\"text-align:center;vertical-align:middle;width:54pt;\"></td><td style=\"text-align:center;vertical-align:middle;width:170.25pt;\"><span style=\"color:#000000;\">抽象类</span></td><td style=\"text-align:center;vertical-align:middle;width:165pt;\"><span style=\"color:#000000;\">接口</span></td></tr><tr><td rowspan=\"4\" style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">异</span></td><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">使用</span><span style=\"color:#fe2c24;\"><strong>abstract</strong></span></td><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">实用</span><span style=\"color:#fe2c24;\"><strong>interface</strong></span></td></tr><tr><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">只能继承一个类</span></td><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">可以实现多个接口</span></td></tr><tr><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">非抽象派生类必须实现抽象方法</span></td><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">实现接口的类必须实现所有成员</span></td></tr><tr><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">使用</span><strong><span style=\"color:#fe2c24;\">override</span></strong><span style=\"color:#000000;\">实现</span></td><td style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">直接实现</span></td></tr><tr><td rowspan=\"3\" style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">同</span></td><td colspan=\"2\" style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">都不能用于实例化</span></td></tr><tr><td colspan=\"2\" style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">都未包含实现方法</span></td></tr><tr><td colspan=\"2\" style=\"text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">子类/“接口实现类”都必须实现为实现的方法</span></td></tr></tbody></table>\n<h1>五、设计模式</h1>\n<h2>        1.概述</h2>\n<p>                <strong>常见的设计模式</strong>：        <strong>①简单工厂</strong>(单一对象创建的扩展)       <strong> </strong></p>\n<p><strong>                                                     ②抽象工厂</strong>(多找那个类型数据库访问问题/不同业务逻辑)       </p>\n<p><strong>                                                      ③单例模式</strong>(Web中设计购物车需要使用)</p>\n<h2>        2.简单工厂</h2>\n<p class=\"img-center\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\c712667844ce4a25989f08ecafa1d79d.png\" width=\"551\"/></p>\n<p>                 <strong>原理</strong>：①工厂可以通过“选择”的方法来指定创建哪个“接口实现的类”</p>\n<p>                            ②工厂实际是一个对象创建的方法，让<strong>对象延迟创建</strong>(取代原来new的作用)</p>\n<p>                <strong>实现</strong>：①<strong>接口</strong>（产品原型）</p>\n<p>                           ②<strong>工厂类</strong>（产品生产）</p>\n<p class=\"img-center\"><img alt=\"\" height=\"100\" src=\"..\\..\\static\\image\\f4391311e122482aa0b394cb727f5c75.png\" width=\"374\"/></p>\n<pre><code class=\"language-cs\">using System.Configuration;    //同时需要在项目中引用\n\nclass Facotory\n{\n    //1.定义接口变量\n    staitc IReport objReport = null;\n\n    //2.读取配置文件(添加App.config)\n    static string reportType = congfigurationManager.AppSettings[\"ReportType\"].ToString();\n\n    //3.根据用户要求创建对象\n    public static IReport ChooseRepType()\n    {\n        switch(reportType)\n        {\n            case \"ExcelReport\":    objReport = new ExcelReport(); break;\n            case \"WordReport\":    objReport = new WordReport();    break;\n        }\n        return objReport;\n    }\n}</code></pre>\n<p>                           ③<strong>仓库</strong>（产品输出）：具体的接口实现（多种实现）</p>\n<p>                在主程序中的<strong>调用</strong></p>\n<pre><code class=\"language-cs\">IReport objRep = Factory.ChooseRepType();    //工厂动态新建\n\n//等价于IReport objRep = new ExcelReport();  IReport objRep = new WordReport();</code></pre>\n<h3>                基于反射技术的简单工厂改进</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"100\" src=\"..\\..\\static\\image\\ba67ff89c4694601bd115fe8d7e9a5c6.png\" width=\"820\"/></p>\n<pre><code class=\"language-cs\">static string reportType = congfigurationManager.AppSettings[\"ReportType\"].ToString();\n\npublic static IReport ChooseRepType()\n{\n    return (IReport)Assembly.Load(\"UseFactory\").CreateInstance(\"Report.\"+reportType);\n}</code></pre>\n<h2>        3.抽象工厂设计模式</h2>\n<p>                同时开发不同数据库访问的DAL，<strong>集成在一个系统中</strong>，根据用户的需求配置不同的DAL和UI、BLL结合即可</p>\n<p>                <strong>优势</strong>：只需要维护一套系统，维护和开发成本较低且部署灵活</p>\n<p>               <strong> 设计DAL方案</strong>：（任选其一）</p>\n<p class=\"img-center\"><img alt=\"\" height=\"250\" src=\"..\\..\\static\\image\\c191f792e14d43589edae2cf01af9f42.png\" width=\"309\"/></p>\n<p>                         BLL依赖“<strong>开关</strong>”与DAL隔离。</p>\n<p>                抽象工厂的<strong>依赖关系</strong></p>\n<p class=\"img-center\"><img alt=\"\" height=\"230\" src=\"..\\..\\static\\image\\45a75088535843f1a8c1acd3a187a88d.png\" width=\"498\"/></p>\n<p>                 <strong>框架实现</strong>：<strong>DAL</strong>（接口实现）、<strong>IDAL</strong>（接口）、<strong>DALFactory</strong>（抽象工厂）互相独立</p>\n<p>                         使用的配置文件：</p>\n<p class=\"img-center\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\2034b7918df4410a9c12d473db9c20d9.png\" width=\"567\"/></p>\n<pre><code class=\"language-cs\">//DALFctory的实现\n\n//1.读取数据库类型\nstatic dbType = configurationManager.AppSetting[\"dbType\"].ToString();\n\n//2.读取DAL所在的程序集名称\nstatic dalAssemblyName = configurationManager.AppSetting[\"DalAssemblyName\"].ToString();\n\n//3.组合要创建的对象的命名空间\nstatic string path = dalAssemblyName + \".\" + dbType;\n\n//4.使用反射来实现\npublic static IDAL.IStudentService CreateStudentService()\n{\n    return (IDAL.IStudentService)Assembly.Load(dalAssemblyName).CreateInstance(path + \".StudentService\");\n}</code></pre>\n<p>               <strong>BLL中的引用</strong>：</p>\n<pre><code class=\"language-cs\">public class ClassManager\n{\n    //通过抽象工厂创建DAL，实现DAL动态替换\n    IDAL.IStuService objSer = DALFactory.DataAcess.CreateStuSerObj();\n\n    //抽象构造方法\n    public List&lt;Stu&gt; GetAllStu()\n    {\n        return objStu.GetAllStu\n    }\n}</code></pre>\n<h1>六、反射技术</h1>\n<h2>        1.概念</h2>\n<p>                通过反射，可以在运行时<strong>获得某个类型的各种信息</strong>，包括方法、属性、事件、构造函数等，还可以获取每个成员的名称等信息</p>\n<p>                反射是在<strong>程序运行时进行</strong>的（动态创建对象、调用方法、设置属性、激发事件），并非在编译时完成</p>\n<h2>        2.应用</h2>\n<p>                ①系统需要基于插件开发的时候，必须使用反射</p>\n<p>                ②简单工厂&amp;抽象工厂中将使用反射</p>\n<p>                ③一般<strong>配合接口使用</strong></p>\n<p>                ④反射<strong>会降低系统性能</strong>，除非必要否则不宜过多使用</p>\n<h2>        3.实现</h2>\n<pre><code class=\"language-cs\">using System.Reflection;    //引入反射命名空间\nusing ICal;    //引入接口库\n\n//动态加载程序集并创建对象\nICalculator objCal = (ICalculator)Assembly.LoadFrom(\"CalDLL.dll\").CreateInstance(\"CalDLL.Calcuator\");\n//调用反射，需要引入类文件 + 完全限定名(同时返回的是Objcet型，需要强制转换)\n\nint Result = objCal.Add(num1,num2);  //通过接口运算\n</code></pre>\n<h2>        4.优势</h2>\n<p>                使用反射后，不再需要添加接口实现类的引用，<strong>降低了模块之间的耦合</strong>,可以直接使用外部调用（随意替换文件）</p>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-29 17:40:57", "summary": "建立层务必使用类库选项，不要使用文件夹没错，说的就是我自己一、两层架构架构概述两层架构适合小型中小型项目名称标识用途数据访问对象模型服务，需要添加引用实体对象模型用户界面交互界面，需要添加和引用实体对"}