{"blogid": "123432413", "writerAge": "码龄2年", "writerBlogNum": "55", "writerCollect": "242", "writerComment": "38", "writerFan": "26", "writerGrade": "3级", "writerIntegral": "652", "writerName": "麦子穗", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123432413.jpg", "writerRankTotal": "26156", "writerRankWeekly": "280529", "writerThumb": "60", "writerVisitNum": "45862", "blog_read_count": "10062", "blog_time": "已于 2022-09-06 13:57:32 修改", "blog_title": "QT实现串口通信", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>要实现串口通信，需要知道串口通信需要的信息</p>\n<p>主要参数有：波特率、校验位、数据位、停止位、控制流</p>\n<p>主要操作有：串口的打开和关闭、刷新设备串口、接发数据、开关显示灯等。</p>\n<p>实现效果如图：</p>\n<p><img alt=\"\" height=\"597\" src=\"..\\..\\static\\image\\ebde0c4f6b59473d81a194446c06023a.png\" width=\"799\"/></p>\n<p>界面设计如下：</p>\n<p>每个控件类名如下：</p>\n<p></p>\n<p>LED灯是QLable控件，设置它的长宽都是24px，然后鼠标右击，选择“样式表”，在样式表中添加代码。</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"946\" src=\"..\\..\\static\\image\\68328bdd537a4105a5185a9e6529d977.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\d8c430a39c5549258f5e57aab0384e9a.png\" width=\"1200\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"309\" src=\"..\\..\\static\\image\\b46e6e166ebe413fb9b38c83f852fddf.png\" width=\"404\"/></p>\n<p>最后附赠完整源码。</p>\n<p>第一步：在头文件中引入 QtSerialPort 类的两个头文件（必须引入）</p>\n<pre><code>// 引入串口通信的两个头文件(第一步)\n#include &lt;QtSerialPort/QSerialPort&gt;         // 提供访问串口的功能\n#include &lt;QtSerialPort/QSerialPortInfo&gt;     // 提供系统中存在的串口信息</code></pre>\n<p>第二步：在工程文件中添加以下代码</p>\n<pre><code># 引入串口工程类型（第二步）\nQT       += serialport</code></pre>\n<p>第三步：在头文件中定义全局的串口对象</p>\n<pre><code>QSerialPort     *serial;                            // 定义全局的串口对象（第三步）</code></pre>\n<p>第四步：参数设置，在头文件中定义初始化参数的函数和参数变量名，在.cpp文件中实现函数</p>\n<pre><code>public:\nvoid        SerialPortInit();                      // 串口初始化（参数配置）\n\nprivate:\n// 参数配置\n    QStringList     baudList;                           //波特率\n    QStringList     parityList;                         //校验位\n    QStringList     dataBitsList;                       //数据位\n    QStringList     stopBitsList;                       //停止位\n    QStringList     flowControlList;                    //控制流</code></pre>\n<pre><code>// 串口初始化（参数配置）\nvoid MainWindow::SerialPortInit()\n{\n    serial = new QSerialPort;                       //申请内存,并设置父对象\n\n    // 获取计算机中有效的端口号，然后将端口号的名称给端口选择控件\n    foreach(const QSerialPortInfo &amp;info,QSerialPortInfo::availablePorts())\n    {\n        serial-&gt;setPort(info);                      // 在对象中设置串口\n        if(serial-&gt;open(QIODevice::ReadWrite))      // 以读写方式打开串口\n        {\n            ui-&gt;PortBox-&gt;addItem(info.portName());  // 添加计算机中的端口\n            serial-&gt;close();                        // 关闭\n        } else\n        {\n            qDebug() &lt;&lt; \"串口打开失败，请重试\";\n        }\n    }\n\n    // 参数配置\n    // 波特率，波特率默认选择57600 ，禁止用户点击\n    ui-&gt;BaudBox-&gt;addItem(\"57600\");\n    serial-&gt;setBaudRate(QSerialPort::Baud57600);\n    ui-&gt;BaudBox-&gt;setDisabled(true);\n\n    // 校验，校验默认选择无\n    ui-&gt;ParityBox-&gt;addItem(\"无\");\n    serial-&gt;setParity(QSerialPort::NoParity);\n\n    // 数据位，数据位默认选择8位\n    ui-&gt;BitBox-&gt;addItem(\"8\");\n    serial-&gt;setDataBits(QSerialPort::Data8);\n\n    // 停止位，停止位默认选择1位\n    ui-&gt;StopBox-&gt;addItem(\"1\");\n    serial-&gt;setStopBits(QSerialPort::OneStop);\n\n    // 控制流，默认选择无\n    ui-&gt;ControlBox-&gt;addItem(\"无\");\n    serial-&gt;setFlowControl(QSerialPort::NoFlowControl);\n\n    // 刷新串口\n    RefreshSerialPort(0);\n\n    // 信号\nconnect(serial,&amp;QSerialPort::readyRead,this,&amp;MainWindow::DataReceived);      // 接收数据\nconnect(ui-&gt;SendWordOrder,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend); // 发送数据\nconnect(ui-&gt;SendButton,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);    // 发送数据\nconnect(ui-&gt;SendEditBtn1,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);  // 发送数据\nconnect(ui-&gt;SendEditBtn2,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);  // 发送数据\nconnect(ui-&gt;SendEditBtn3,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);  // 发送数据\n}</code></pre>\n<p>第五步：刷新串口，及时更新可用的串口</p>\n<pre><code>// 刷新串口\nvoid MainWindow::RefreshSerialPort(int index)\n{\n    QStringList portNameList;                                        // 存储所有串口名\n    if(index != 0)\n    {\n        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());             //设置串口号\n    }\n    else\n    {\n        ui-&gt;PortBox-&gt;clear();                                        //关闭串口号\n        ui-&gt;PortBox-&gt;addItem(\"刷新\");                                //添加刷新\n        foreach(const QSerialPortInfo &amp;info,QSerialPortInfo::availablePorts()) //添加新串口\n        {\n            portNameList.append(info.portName());\n        }\n        ui-&gt;PortBox-&gt;addItems(portNameList);\n        ui-&gt;PortBox-&gt;setCurrentIndex(1);                             // 当前串口号为COM1\n        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());             //设置串口号\n   }\n}</code></pre>\n<p>第六步：发送数据和接收数据</p>\n<pre><code>// 接收数据,使用read () / readLine () / readAll ()\nvoid MainWindow::DataReceived()\n{\n    char BUF[512] = {0};                                       // 存储转换类型后的数据\n    QByteArray data = serial-&gt;readAll();                      // 读取数据\n\n    if(!data.isEmpty())                                 // 接收到数据\n    {\n        QString str = ui-&gt;DataReceived-&gt;toPlainText();  // 返回纯文本\n        str += tr(data);                         // 数据是一行一行传送的，要保存所有数据\n        ui-&gt;DataReceived-&gt;clear();                      // 清空之前的数据\n        ui-&gt;DataReceived-&gt;append(str);                  // 将数据放入控件中\n        qDebug() &lt;&lt; \"str info: \" &lt;&lt; ui-&gt;DataReceived-&gt;toPlainText();\n\n         // 清除之前的数据，防止追加，因为每次获取的数据不一样\n        int index = str.indexOf(\"\\r\\n\");                // 找到，返回索引值，找不到，返回-1\n        if(index != -1)\n        {\n            snprintf(BUF,500,\"%s\", str.left(index + 2).toUtf8().data()); // QString转为char * 类型\n            qDebug() &lt;&lt; \"BUF info: \" &lt;&lt; BUF;        // 数据类型转换成功\n            str.remove(0,index + 2); \n\n            // 处理获取到的数据，将其放入对应的控件中\n            // .....\n                             \n        }\n    }\n}\n\n// 发送数据，write ()\nvoid MainWindow::DataSend()\n{\n    serial-&gt;write(ui-&gt;DataSend-&gt;toPlainText().toLatin1());      // 串口发送数据\n}</code></pre>\n<p>第七步：打开串口和关闭串口，当打开串口后，显示绿灯；关闭串口后，显示红灯</p>\n<pre><code>// 串口开关\nvoid MainWindow::on_OpenSerialButton_clicked()\n{\n    if(serial-&gt;isOpen())                                  // 如果串口打开了，先给他关闭\n    {\n        serial-&gt;clear();\n        serial-&gt;close();\n        // 关闭状态，按钮显示“打开串口”\n        ui-&gt;OpenSerialButton-&gt;setText(\"打开串口\");\n        // 关闭状态，允许用户操作\n        ui-&gt;BaudBox-&gt;setDisabled(false);\n        ui-&gt;ParityBox-&gt;setDisabled(false);\n        ui-&gt;BitBox-&gt;setDisabled(false);\n        ui-&gt;StopBox-&gt;setDisabled(false);\n        ui-&gt;ControlBox-&gt;setDisabled(false);\n        // 禁止操作“发送字符操作”\n        ui-&gt;SendWordOrder-&gt;setDisabled(true);\n        ui-&gt;SendButton-&gt;setDisabled(true);\n        // 关闭状态，颜色为绿色\n        ui-&gt;OpenSerialButton-&gt;setStyleSheet(\"color: green;\");\n        // 关闭，显示灯为红色\n        LED(true);\n        // 清空数据\n        ui-&gt;DataReceived-&gt;clear();\n        ui-&gt;DataSend-&gt;clear();\n    }\n    else                                             // 如果串口关闭了，先给他打开\n    {\n        //当前选择的串口名字\n        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());\n        //用ReadWrite 的模式尝试打开串口，无法收发数据时，发出警告\n        if(!serial-&gt;open(QIODevice::ReadWrite))\n        {\n            QMessageBox::warning(this,tr(\"提示\"),tr(\"串口打开失败!\"),QMessageBox::Ok);\n            return;\n         }\n        // 打开状态，按钮显示“关闭串口”\n        ui-&gt;OpenSerialButton-&gt;setText(\"关闭串口\");\n        // 打开状态，禁止用户操作\n        ui-&gt;BaudBox-&gt;setDisabled(true);\n        ui-&gt;ParityBox-&gt;setDisabled(true);\n        ui-&gt;BitBox-&gt;setDisabled(true);\n        ui-&gt;StopBox-&gt;setDisabled(true);\n        ui-&gt;ControlBox-&gt;setDisabled(true);\n        // 允许操作“发送字符操作”\n        ui-&gt;SendWordOrder-&gt;setDisabled(false);\n        ui-&gt;SendButton-&gt;setDisabled(false);\n        // 打开状态，颜色为红色\n        ui-&gt;OpenSerialButton-&gt;setStyleSheet(\"color: red;\");\n        // 打开，显示灯为绿色\n        LED(false);\n    }\n}\n\n// 开关显示灯\nvoid  MainWindow::LED(bool changeColor)\n{\n    if(changeColor == false)\n    {\n        // 显示绿色\n        ui-&gt;LED-&gt;setStyleSheet(\"background-color: qradialgradient(spread:pad, cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 rgba(0, 229, 0, 255), stop:1 rgba(255, 255, 255, 255));border-radius:12px;\");\n    }\n    else\n    {\n        // 显示红色\n        ui-&gt;LED-&gt;setStyleSheet(\"background-color: qradialgradient(spread:pad, cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 rgba(255, 0, 0, 255), stop:1 rgba(255, 255, 255, 255));border-radius:12px;\");\n    }\n}</code></pre>\n<p>第八步：相关槽函数</p>\n<pre><code>// 控件中添加 指令“###”\nvoid MainWindow::on_SendButton_clicked()\n{\n    on_ClearButton_clicked();\n    ui-&gt;DataSend-&gt;append(\"###\");\n}\n// 清空控件\nvoid MainWindow::on_ClearButton_clicked()\n{\n    ui-&gt;DataSend-&gt;setText(\"\");\n}\n// 清空接收到的数据\nvoid MainWindow::on_ClearShowButton_clicked()\n{\n    ui-&gt;DataReceived-&gt;setText(\"\");\n}\n// 点击发送后，获取串口信息并展示在接受控件中\nvoid MainWindow::on_SendEditBtn1_clicked()\n{\n    on_ClearButton_clicked();\n    QString EditText = ui-&gt;Edit1-&gt;text();               //获取发送框内容\n    ui-&gt;DataSend-&gt;setText(EditText);                     //将文本内容放在发送栏中\n}\n\nvoid MainWindow::on_SendEditBtn2_clicked()\n{\n    on_ClearButton_clicked();\n    QString EditText = ui-&gt;Edit2-&gt;text();               //获取发送框内容\n\n    // qDebug() &lt;&lt; \"Edit1 text: \" &lt;&lt; EditText;\n\n    ui-&gt;DataSend-&gt;append(EditText);                     //将文本内容放在发送栏中\n}\n\nvoid MainWindow::on_SendEditBtn3_clicked()\n{\n    on_ClearButton_clicked();\n    QString EditText = ui-&gt;Edit3-&gt;text();               //获取发送框内容\n\n    // qDebug() &lt;&lt; \"Edit1 text: \" &lt;&lt; EditText;\n\n    ui-&gt;DataSend-&gt;append(EditText);                     //将文本内容放在发送栏中\n}\n\n\n\nvoid MainWindow::on_SendWordOrder_clicked()\n{\n    on_SendButton_clicked();\n}\n</code></pre>\n<p>源码：</p>\n<p>工程文件.pro文件源码：</p>\n<pre><code>QT       += core gui\n# 引入串口工程类型（第二步）\nQT       += serialport\n\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n\nCONFIG += c++11\n\n# The following define makes your compiler emit warnings if you use\n# any Qt feature that has been marked deprecated (the exact warnings\n# depend on your compiler). Please consult the documentation of the\n# deprecated API in order to know how to port your code away from it.\nDEFINES += QT_DEPRECATED_WARNINGS\n\n# You can also make your code fail to compile if it uses deprecated APIs.\n# In order to do so, uncomment the following line.\n# You can also select to disable deprecated APIs only up to a certain version of Qt.\n#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0\n\nSOURCES += \\\n    main.cpp \\\n    mainwindow.cpp\n\nHEADERS += \\\n    mainwindow.h\n\nFORMS += \\\n    mainwindow.ui\n\n# Default rules for deployment.\nqnx: target.path = /tmp/$${TARGET}/bin\nelse: unix:!android: target.path = /opt/$${TARGET}/bin\n!isEmpty(target.path): INSTALLS += target\n</code></pre>\n<p>头文件源码：</p>\n<pre><code>#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include &lt;QMainWindow&gt;\n// 引入串口通信的两个头文件(第一步)\n#include &lt;QtSerialPort/QSerialPort&gt;         // 提供访问串口的功能\n#include &lt;QtSerialPort/QSerialPortInfo&gt;     // 提供系统中存在的串口信息\n\nQT_BEGIN_NAMESPACE\nnamespace Ui { class MainWindow; }\nQT_END_NAMESPACE\n\nclass MainWindow : public QMainWindow\n{\n    Q_OBJECT\n\npublic:\n    MainWindow(QWidget *parent = nullptr);\n    ~MainWindow();\n\n    // 串口功能\n    void        SerialPortInit();                      // 串口初始化（参数配置）\n    void        RefreshSerialPort(int index);          // 刷新串口\n\npublic slots:\n    // 串口槽函数\n    void        DataReceived();                        // 接收数据\nprivate slots:\n    // 串口槽函数\n    void        DataSend();                            // 发送数据\n\n    void        on_OpenSerialButton_clicked();         // 串口开关\n\n    void        on_SendButton_clicked();               // 控件中添加 #\n\n    void        on_ClearButton_clicked();              // 清空控件中的所有 #\n\n    void        on_ClearShowButton_clicked();          // 清空接收到的数据\n\n    void        LED(bool changeColor);                 // 开关显示灯\n\n    // 点击发送，接收数据\n    void        on_SendEditBtn1_clicked();\n\n    void        on_SendEditBtn2_clicked();\n\n    void        on_SendEditBtn3_clicked();\n\n\n    void on_SendWordOrder_clicked();\n\nprivate:\n    Ui::MainWindow *ui;\n\n    // 串口变量\n    QSerialPort     *serial;                            // 定义全局的串口对象（第三步）\n    // 参数配置\n    QStringList     baudList;                           //波特率\n    QStringList     parityList;                         //校验位\n    QStringList     dataBitsList;                       //数据位\n    QStringList     stopBitsList;                       //停止位\n    QStringList     flowControlList;                    //控制流\n};\n#endif // MAINWINDOW_H\n</code></pre>\n<p>.cpp文件源码：</p>\n<pre><code>#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include &lt;QDebug&gt;\n#include &lt;QMessageBox&gt;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui-&gt;setupUi(this);\n\n    SerialPortInit();\n}\n\n// 串口初始化（参数配置）\nvoid MainWindow::SerialPortInit()\n{\n    serial = new QSerialPort;                       //申请内存,并设置父对象\n\n    // 获取计算机中有效的端口号，然后将端口号的名称给端口选择控件\n    foreach(const QSerialPortInfo &amp;info,QSerialPortInfo::availablePorts())\n    {\n        serial-&gt;setPort(info);                      // 在对象中设置串口\n        if(serial-&gt;open(QIODevice::ReadWrite))      // 以读写方式打开串口\n        {\n            ui-&gt;PortBox-&gt;addItem(info.portName());  // 添加计算机中的端口\n            serial-&gt;close();                        // 关闭\n        } else\n        {\n            qDebug() &lt;&lt; \"串口打开失败，请重试\";\n        }\n    }\n\n    // 参数配置\n    // 波特率，波特率默认选择57600 ，禁止用户点击\n    ui-&gt;BaudBox-&gt;addItem(\"57600\");\n    serial-&gt;setBaudRate(QSerialPort::Baud57600);\n    ui-&gt;BaudBox-&gt;setDisabled(true);\n\n    // 校验，校验默认选择无\n    ui-&gt;ParityBox-&gt;addItem(\"无\");\n    serial-&gt;setParity(QSerialPort::NoParity);\n\n    // 数据位，数据位默认选择8位\n    ui-&gt;BitBox-&gt;addItem(\"8\");\n    serial-&gt;setDataBits(QSerialPort::Data8);\n\n    // 停止位，停止位默认选择1位\n    ui-&gt;StopBox-&gt;addItem(\"1\");\n    serial-&gt;setStopBits(QSerialPort::OneStop);\n\n    // 控制流，默认选择无\n    ui-&gt;ControlBox-&gt;addItem(\"无\");\n    serial-&gt;setFlowControl(QSerialPort::NoFlowControl);\n\n    // 刷新串口\n    RefreshSerialPort(0);\n\n    // 信号\n    connect(serial,&amp;QSerialPort::readyRead,this,&amp;MainWindow::DataReceived);         // 接收数据\n    connect(ui-&gt;SendWordOrder,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);    // 发送数据\n    connect(ui-&gt;SendButton,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);       // 发送数据\n    connect(ui-&gt;SendEditBtn1,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);    // 发送数据\n    connect(ui-&gt;SendEditBtn2,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);    // 发送数据\n    connect(ui-&gt;SendEditBtn3,&amp;QPushButton::clicked,this,&amp;MainWindow::DataSend);    // 发送数据\n\n}\n// 刷新串口\nvoid MainWindow::RefreshSerialPort(int index)\n{\n    QStringList portNameList;                                        // 存储所有串口名\n    if(index != 0)\n    {\n        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());             //设置串口号\n    }\n    else\n    {\n        ui-&gt;PortBox-&gt;clear();                                        //关闭串口号\n        ui-&gt;PortBox-&gt;addItem(\"刷新\");                                //添加刷新\n        foreach(const QSerialPortInfo &amp;info,QSerialPortInfo::availablePorts()) //添加新串口\n        {\n            portNameList.append(info.portName());\n        }\n       \n        ui-&gt;PortBox-&gt;addItems(portNameList);\n        ui-&gt;PortBox-&gt;setCurrentIndex(1);                             // 当前串口号为COM1\n        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());             //设置串口号\n   }\n}\n\n// 接收数据,使用read () / readLine () / readAll ()\nvoid MainWindow::DataReceived()\n{\n    char BUF[512] = {0};                                       // 存储转换类型后的数据\n    QByteArray data = serial-&gt;readAll();                      // 读取数据\n\n    if(!data.isEmpty())                                 // 接收到数据\n    {\n        QString str = ui-&gt;DataReceived-&gt;toPlainText();  // 返回纯文本\n        str += tr(data);                                // 数据是一行一行传送的，要保存所有数据\n        ui-&gt;DataReceived-&gt;clear();                      // 清空之前的数据\n        ui-&gt;DataReceived-&gt;append(str);                  // 将数据放入控件中\n        qDebug() &lt;&lt; \"str info: \" &lt;&lt; ui-&gt;DataReceived-&gt;toPlainText();\n\n         // 清除之前的数据，防止追加，因为每次获取的数据不一样\n        int index = str.indexOf(\"\\r\\n\");                // 找到，返回索引值，找不到，返回-1\n        if(index != -1)\n        {\n            snprintf(BUF,500,\"%s\", str.left(index + 2).toUtf8().data()); // QString转为char * 类型\n            qDebug() &lt;&lt; \"BUF info: \" &lt;&lt; BUF;\n            str.remove(0,index + 2);\n\n            // 处理获取到的数据，将其放入对应的控件中\n            // ....\n        }\n    }\n}\n// 发送数据，write ()\nvoid MainWindow::DataSend()\n{\n    serial-&gt;write(ui-&gt;DataSend-&gt;toPlainText().toLatin1());      // 串口发送数据\n}\n\n// 开关显示灯\nvoid  MainWindow::LED(bool changeColor)\n{\n    if(changeColor == false)\n    {\n        // 显示绿色\n        ui-&gt;LED-&gt;setStyleSheet(\"background-color: qradialgradient(spread:pad, cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 rgba(0, 229, 0, 255), stop:1 rgba(255, 255, 255, 255));border-radius:12px;\");\n    }\n    else\n    {\n        // 显示红色\n        ui-&gt;LED-&gt;setStyleSheet(\"background-color: qradialgradient(spread:pad, cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 rgba(255, 0, 0, 255), stop:1 rgba(255, 255, 255, 255));border-radius:12px;\");\n    }\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n// 串口开关\nvoid MainWindow::on_OpenSerialButton_clicked()\n{\n    if(serial-&gt;isOpen())                                        // 如果串口打开了，先给他关闭\n    {\n        serial-&gt;clear();\n        serial-&gt;close();\n        // 关闭状态，按钮显示“打开串口”\n        ui-&gt;OpenSerialButton-&gt;setText(\"打开串口\");\n        // 关闭状态，允许用户操作\n        ui-&gt;BaudBox-&gt;setDisabled(false);\n        ui-&gt;ParityBox-&gt;setDisabled(false);\n        ui-&gt;BitBox-&gt;setDisabled(false);\n        ui-&gt;StopBox-&gt;setDisabled(false);\n        ui-&gt;ControlBox-&gt;setDisabled(false);\n        // 禁止操作“发送字符操作”\n        ui-&gt;SendWordOrder-&gt;setDisabled(true);\n        ui-&gt;SendButton-&gt;setDisabled(true);\n        // 关闭状态，颜色为绿色\n        ui-&gt;OpenSerialButton-&gt;setStyleSheet(\"color: green;\");\n        // 关闭，显示灯为红色\n        LED(true);\n        // 清空数据\n        ui-&gt;DataReceived-&gt;clear();\n        ui-&gt;DataSend-&gt;clear();\n    }\n    else                                                        // 如果串口关闭了，先给他打开\n    {\n        //当前选择的串口名字\n        serial-&gt;setPortName(ui-&gt;PortBox-&gt;currentText());\n        //用ReadWrite 的模式尝试打开串口，无法收发数据时，发出警告\n        if(!serial-&gt;open(QIODevice::ReadWrite))\n        {\n            QMessageBox::warning(this,tr(\"提示\"),tr(\"串口打开失败!\"),QMessageBox::Ok);\n            return;\n         }\n        // 打开状态，按钮显示“关闭串口”\n        ui-&gt;OpenSerialButton-&gt;setText(\"关闭串口\");\n        // 打开状态，禁止用户操作\n        ui-&gt;BaudBox-&gt;setDisabled(true);\n        ui-&gt;ParityBox-&gt;setDisabled(true);\n        ui-&gt;BitBox-&gt;setDisabled(true);\n        ui-&gt;StopBox-&gt;setDisabled(true);\n        ui-&gt;ControlBox-&gt;setDisabled(true);\n        // 允许操作“发送字符操作”\n        ui-&gt;SendWordOrder-&gt;setDisabled(false);\n        ui-&gt;SendButton-&gt;setDisabled(false);\n        // 打开状态，颜色为红色\n        ui-&gt;OpenSerialButton-&gt;setStyleSheet(\"color: red;\");\n        // 打开，显示灯为绿色\n        LED(false);\n    }\n}\n// 控件中添加 #\nvoid MainWindow::on_SendButton_clicked()\n{\n    on_ClearButton_clicked();\n    ui-&gt;DataSend-&gt;append(\"###\");\n}\n// 清空控件\nvoid MainWindow::on_ClearButton_clicked()\n{\n    ui-&gt;DataSend-&gt;setText(\"\");\n}\n// 清空接收到的数据\nvoid MainWindow::on_ClearShowButton_clicked()\n{\n    ui-&gt;DataReceived-&gt;setText(\"\");\n}\n// 点击发送后，获取串口信息并展示在接受控件中\nvoid MainWindow::on_SendEditBtn1_clicked()\n{\n    on_ClearButton_clicked();\n    QString EditText = ui-&gt;Edit1-&gt;text();               //获取发送框内容\n    ui-&gt;DataSend-&gt;setText(EditText);                     //将文本内容放在发送栏中\n}\n\nvoid MainWindow::on_SendEditBtn2_clicked()\n{\n    on_ClearButton_clicked();\n    QString EditText = ui-&gt;Edit2-&gt;text();               //获取发送框内容\n\n    // qDebug() &lt;&lt; \"Edit1 text: \" &lt;&lt; EditText;\n\n    ui-&gt;DataSend-&gt;append(EditText);                     //将文本内容放在发送栏中\n}\n\nvoid MainWindow::on_SendEditBtn3_clicked()\n{\n    on_ClearButton_clicked();\n    QString EditText = ui-&gt;Edit3-&gt;text();               //获取发送框内容\n\n    // qDebug() &lt;&lt; \"Edit1 text: \" &lt;&lt; EditText;\n\n    ui-&gt;DataSend-&gt;append(EditText);                     //将文本内容放在发送栏中\n}\n\n\nvoid MainWindow::on_SendWordOrder_clicked()\n{\n    on_SendButton_clicked();\n}\n</code></pre>\n<p>运行后效果：</p>\n<p><img alt=\"\" height=\"597\" src=\"..\\..\\static\\image\\58d0fa09b15849008ed99551062299ab.png\" width=\"799\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 13:57:32", "summary": "要实现串口通信，需要知道串口通信需要的信息主要参数有：波特率、校验位、数据位、停止位、控制流主要操作有：串口的打开和关闭、刷新设备串口、接发数据、开关显示灯等。实现效果如图：界面设计如下：每个控件类名"}