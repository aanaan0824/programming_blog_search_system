{"blogid": "125816247", "writerAge": "码龄2年", "writerBlogNum": "25", "writerCollect": "1669", "writerComment": "913", "writerFan": "9222", "writerGrade": "5级", "writerIntegral": "2785", "writerName": "石原里美的微笑", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125816247.jpg", "writerRankTotal": "7270", "writerRankWeekly": "781", "writerThumb": "1063", "writerVisitNum": "94634", "blog_read_count": "5083", "blog_time": "已于 2022-07-22 10:01:53 修改", "blog_title": "java中的线程如何理解——精简", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BC%95%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E8%A8%80\">引言</a></p>\n<p id=\"%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0\">多线程的创建 </a></p>\n<p id=\"%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB%C2%A0\">方式一：继承Thread类 </a></p>\n<p id=\"%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%C2%A0%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%C2%A0%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\">方式二： 实现Runnable接口</a></p>\n<p id=\"%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%C2%A0\">方式三：实现Callable接口 </a></p>\n<p id=\"%E6%80%BB%E7%BB%93%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BB%93%C2%A0\">总结 </a></p>\n<p id=\"%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%C2%A0\">常用方法 </a></p>\n<p id=\"Thread%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#Thread%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%C2%A0\">Thread获取和设置线程名称 </a></p>\n<p id=\"Thread%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E6%96%B9%E6%B3%95%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#Thread%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E6%96%B9%E6%B3%95%C2%A0\">Thread类的线程休眠方法 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%BC%95%E8%A8%80\">引言</h1>\n<blockquote>\n<p>        经过前面的学习，我们已经了解到了IO流的知识，那么今天我们就将要开始学习Java中的线程，首先我们应该理解“线程”是什么意思？线程（thread）是一个程序内部的一条执行路径，我们所熟悉的main方法其实就是一条单独执行路径，若程序中只有一条执行路径那么这个程序就是<span style=\"color:#fe2c24;\">单线程程序</span>；既然有单线程，那么也相对的会有多线程，字面意思可以理解为“相对单线程从软硬件上多条执行流程的技术”，多线程的好处是<span style=\"color:#fe2c24;\"><strong>提高CPU的利用率</strong></span>。 在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，大大提高程序的效率。好了，废话不多说开始今天的学习吧！</p>\n<p> <img alt=\"\" height=\"387\" src=\"..\\..\\static\\image\\7320bc6b7f2342dab0c7452f8a434e0f.png\" width=\"689\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0\">多线程的创建 </h1>\n<h2 id=\"%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB%C2%A0\">方式一：继承Thread类 </h2>\n<blockquote>\n<p><span style=\"background-color:#a2e043;\">方式一创建过程：</span></p>\n<ol><li>定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法；</li><li>创建MyThread类的对象；</li><li>调用线程对象的start()方法启动线程（启动后仍然执行run()方法）；  <pre><code class=\"language-java\">public class ThreadDemo01 {\n    public static void main(String[] args) {\n        MyThread myThread1 = new MyThread();\n        myThread1.start();\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(\"主线程正在执行~~\");\n        }\n    }\n}\nclass MyThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(\"子线程正在执行~~\");\n        }\n\n    }\n}\n//输出结果（不唯一）：\n//主线程正在执行~~\n//主线程正在执行~~\n//主线程正在执行~~\n//子线程正在执行~~\n//子线程正在执行~~\n//子线程正在执行~~</code></pre> <p>在以上代码中共有两个线程在执行，分别是main方法的主线程和线程对象mythread调用start()启动的子线程。不过输出结果为什么会不唯一的呢？原因是因为两个线程在执行过程中会发生CPU的抢占，谁先抢到谁将优先执行。</p> <p class=\"img-center\"><img alt=\"\" height=\"244\" src=\"..\\..\\static\\image\\9739ae0fbd854369b4ada797b63faee7.jpeg\" width=\"258\"/></p> <p></p> </li></ol>\n</blockquote>\n<blockquote>\n<p>那么我们为什么不直接使用线程对象调用run()方法呢？若直接调用run()则只是普通的调用方法，即单线程，而start()方法则是用来启动的子线程的，由此才能出现多线程。</p>\n<p><span style=\"background-color:#a2e043;\">方式一优缺点：</span></p>\n<ul><li><span style=\"background-color:#a2e043;\">优点：</span>编码简单；</li><li><span style=\"background-color:#a2e043;\">缺点：</span>线程类已经继承Thread，无法继承其他类，不利于扩展； </li></ul>\n</blockquote>\n<h2 id=\"%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%C2%A0%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\">方式二： 实现Runnable接口</h2>\n<blockquote>\n<p><span style=\"background-color:#38d8f0;\">方式二创建过程：</span></p>\n<p>1、定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法；</p>\n<p>2、创建MyRunnable对象；</p>\n<p>3、把MyRunnable任务对象交给Thread处理；</p>\n<p>4、调用线程对象的start()方法启动线程；</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>Thread构造器</td><td>方法</td></tr><tr><td>public Thread (String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public Thread (Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread (Runnable target ，String name)</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">public class ThreadDemo02 {\n    public static void main(String[] args) {\n        MyRunnable target = new MyRunnable();\n        Thread thread = new Thread(target);\n        thread.start();\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(\"主线程正在执行~~\");\n        }\n    }\n}\nclass MyRunnable implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(\"子线程正在执行~~\");\n        }\n\n    }\n}\n//输出结果（不唯一）：\n//主线程正在执行~~\n//子线程正在执行~~\n//子线程正在执行~~\n//子线程正在执行~~\n//主线程正在执行~~\n//主线程正在执行~~</code></pre>\n<p>该代码与方式一的不同之处在于需要将MyRunnable任务对象封装在Thread中，其他的地方是基本上是没有变化的。</p>\n<p><span style=\"background-color:#38d8f0;\">方式二优缺点：</span></p>\n<p><span style=\"background-color:#38d8f0;\">优点：</span>线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；</p>\n<p><span style=\"background-color:#38d8f0;\">缺点：</span>编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"188\" src=\"https://img-blog.csdnimg.cn/dc1e6e1c1aa0415abe8828bbd57c5448.gif\" width=\"232\"/></p>\n<p></p>\n</blockquote>\n<blockquote>\n<p>接下来我们同样使用<span style=\"background-color:#38d8f0;\">实现Runnable接口（匿名内部类形式）</span>来实现多线程的创建：</p>\n<p>1、创建Runnable匿名内部类对象；</p>\n<p>2、交给Thread处理；</p>\n<p>3、调用线程对象的start()启动线程；</p>\n<pre><code class=\"language-java\">//正常版：\npublic class ThreadDemo01 {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i &lt; 3; i++) {\n                    System.out.println(\"子线程正在执行~~\");\n                }\n            }\n        });\n        thread.start();\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(\"主线程正在执行~~\");\n        }\n    }\n}\n\n//lambda简化版：\nnew Thread(()-&gt; {\n                for (int i = 0; i &lt; 3; i++) {\n                    System.out.println(\"子线程正在执行~~\");\n                }\n        }).start();</code></pre>\n<p> 该种方法从本质上其实并没有太大的区别只不过是一个需要创建线程对象，而另一个则是通过匿名内部类实现的多线程。并且该块代码也可以通过lambda表达式进行精简，不知道大家是否还对这个知识点有印象呢？若忘记了可以看一下这篇文章：<a class=\"link-info\" href=\"http://t.csdn.cn/fRevg\" title=\"Java中的lambda表达式如何理解——精简\">Java中的lambda表达式如何理解——精简</a></p>\n</blockquote>\n<h2 id=\"%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%C2%A0\">方式三：实现Callable接口 </h2>\n<blockquote>\n<p>在学习过前面两种创建多线程的方式以后，我们会发现存在一个问题：1、重写的run()方法不能直接返回结果；2、不适合需要返回线程执行结果的业务场景。因此，我们需要第三种方式来解决这些问题。 </p>\n<p><span style=\"background-color:#faa572;\">方式三创建过程：</span></p>\n<p>1、定义类实现Callable接口，重写call()方法，封装要做的事情；</p>\n<p>2、用FutureTask把Callable对象封装成线程任务对象；</p>\n<p>3、把线程任务对象交给Thread处理；</p>\n<p>4、调用Thread的start()方法启动线程，执行任务；</p>\n<p>5、线程执行完毕后，通过FutureTask的get()方法获取任务执行的结果。</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法名称</td><td>说明</td></tr><tr><td>public FutureTask&lt;&gt;(Callable call)</td><td>把Callable对象封装成FutureTask对象</td></tr><tr><td>public V get() throws Exception</td><td>获取线程执行call方法返回的结果</td></tr></tbody></table>\n<pre><code class=\"language-java\">public class ThreadDemo03 {\n    public static void main(String[] args) throws Exception {\n        MyCallable myCallable = new MyCallable();\n        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myCallable);\n        Thread thread = new Thread(futureTask);\n        thread.start();\n        int sum= 0;\n        for (int i = 0; i &lt; 3; i++) {\n            sum+=i;\n        }\n        System.out.println(sum);\n        String s =futureTask.get();\n        System.out.println(s);\n    }\n}\nclass MyCallable implements Callable&lt;String &gt; {\n    @Override\n    public String call(){\n        int sum=0;\n        for (int i = 0; i &lt; 3; i++) {\n            sum+=i;\n        }\n        return \"子线程计算结果：\"+sum;\n    }\n}\n//输出结果：\n//3\n//子线程计算结果：3</code></pre>\n<p><span style=\"background-color:#faa572;\">方式三优缺点：</span></p>\n<p><span style=\"background-color:#faa572;\">优点：</span></p>\n<p>线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；</p>\n<p>可以在线程执行完毕后去获取 线程执行的结果；</p>\n<p><span style=\"background-color:#faa572;\">缺点：</span></p>\n<p>编码复杂一点；</p>\n<p class=\"img-center\"><img alt=\"\" height=\"176\" src=\"https://img-blog.csdnimg.cn/30eb0fed70234c5c9d199efb19a8d671.gif\" width=\"203\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%E6%80%BB%E7%BB%93%C2%A0\">总结 </h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方式</td><td>优点</td><td>缺点</td></tr><tr><td>继承Thread类</td><td>编程比较简单，可以直接使用Thread类中的方法</td><td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td></tr><tr><td>实现Runnable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类</td><td>编程相对复杂，不能返回线程执行的结果</td></tr><tr><td>实现Callable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类，可以得到线程的执行结果</td><td>编程相对复杂</td></tr></tbody></table>\n<h1 id=\"%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%C2%A0\">常用方法 </h1>\n<h2 id=\"Thread%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%C2%A0\">Thread获取和设置线程名称 </h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法名称</td><td>说明</td></tr><tr><td>String getName()</td><td>获取当前线程的名称，默认线程名称是Thread-索引</td></tr><tr><td>void setName(String name)</td><td> <p>将此线程更改为指定的名称，通过构造器也可以设置线程名称</p> </td></tr></tbody></table>\n<blockquote>\n<p> 简单地通过一段代码让大家能够清晰地了解这个代码该如何使用：</p>\n<pre><code class=\"language-java\">public class ThreadDemo04 {\n    public static void main(String[] args) throws Exception {\n        thread thread1 = new thread();\n        thread1.setName(\"1号子线程\");\n        thread1.start();\n        thread thread2 = new thread();\n        thread2.setName(\"2号子线程\");\n        thread2.start();\n    }\n}\nclass thread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(this.getName()+\"正在执行任务\"+i);\n        }\n    }\n}\n//输出结果：\n//2号子线程正在执行任务0\n//1号子线程正在执行任务0\n//2号子线程正在执行任务1\n//1号子线程正在执行任务1\n//2号子线程正在执行任务2\n//1号子线程正在执行任务2</code></pre>\n<p></p>\n</blockquote>\n<h2 id=\"Thread%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E6%96%B9%E6%B3%95%C2%A0\">Thread类的线程休眠方法 </h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法名称</td><td>说明</td></tr><tr><td>public static void sleep(long time) </td><td>让当前线程休眠指定的时间后再继续执行，单位为毫秒</td></tr></tbody></table>\n<pre><code class=\"language-java\">public class ThreadDemo05 {\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(i);\n            if (i==3){\n                Thread.sleep(5000);\n            }\n        }\n    }\n}\n//输出结果：\n//1\n//2\n//3\n//在输出过3以后，等待5秒之后再进行输出\n//4</code></pre>\n<p style=\"text-align:center;\"> <s><span style=\"background-color:#ffd900;\">创作不易，给个三连</span></s></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"206\" src=\"https://img-blog.csdnimg.cn/269c7e14f305478d9cf14bff16d62560.gif\" width=\"215\"/></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-22 10:01:53", "summary": "目录引言多线程的创建方式一：继承类方式二：实现接口方式三：实现接口总结常用方法获取和设置线程名称类的线程休眠方法引言经过前面的学习，我们已经了解到了流的知识，那么今天我们就将要开始学习中的线程，首先我"}