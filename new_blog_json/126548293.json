{"blogid": "126548293", "writerAge": "码龄3年", "writerBlogNum": "86", "writerCollect": "2391", "writerComment": "2111", "writerFan": "4710", "writerGrade": "6级", "writerIntegral": "6412", "writerName": "赵四司机", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126548293.jpg", "writerRankTotal": "2434", "writerRankWeekly": "19", "writerThumb": "2122", "writerVisitNum": "210186", "blog_read_count": "74", "blog_time": "于 2022-09-07 10:02:41 发布", "blog_title": "【Spring Cloud】新闻头条微服务项目：实时创建ES索引并引入MongoDB实现搜索历史记录及关键词联想", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"8420b26844034fab91b6df661ae68671.png\" src=\"..\\..\\static\\image\\8420b26844034fab91b6df661ae68671.png\"/></p>\n<p><strong>个人简介： </strong></p>\n<blockquote>\n<p>&gt; 📦个人主页：<a href=\"https://blog.csdn.net/weixin_45750572?type=blog\" title=\"赵四司机\">赵四司机</a><br/> &gt; 🏆学习方向：JAVA后端开发 <br/> &gt; ⏰往期文章：<a href=\"https://blog.csdn.net/weixin_45750572/article/details/125534014\" title=\"SpringBoot项目整合微信支付\">SpringBoot项目整合微信支付</a><br/> &gt; 🔔博主推荐网站：<a href=\"https://www.nowcoder.com/link/pc_csdncpt_zssj_sf\" title=\"牛客网 刷题|面试|找工作神器\">牛客网 刷题|面试|找工作神器</a><br/> &gt; 📣种一棵树最好的时间是十年前，其次是现在！<br/> &gt; 💖喜欢的话麻烦点点关注喔，你们的支持是我的最大动力。</p>\n</blockquote>\n<p><strong>前言：</strong></p>\n<blockquote>\n<p>最近在做一个基于SpringCloud+Springboot+Docker的新闻头条微服务项目，用的是黑马的教程，现在项目开发进入了尾声，我打算通过写文章的形式进行梳理一遍，并且会将梳理过程中发现的Bug进行修复，有需要改进的地方我也会继续做出改进。这一系列的文章我将会放入微服务项目专栏中，这个项目适合刚接触微服务的人作为练手项目，假如你对这个项目感兴趣你可以订阅我的专栏进行查看，需要资料可以私信我，当然要是能给我点个小小的关注就更好了，你们的支持是我最大的动力。</p>\n<p>如果你想要一个可以系统学习的网站，那么我推荐的是牛客网，个人感觉用着还是不错的，页面很整洁，而且内容也很全面，语法练习，算法题练习，面试知识汇总等等都有，论坛也很活跃，传送门链接：<a href=\"https://www.nowcoder.com/link/pc_csdncpt_zssj_sf\" title=\"牛客刷题神器\">牛客刷题神器</a></p>\n</blockquote>\n<h1>一：文章自动构建索引</h1>\n<h2>1.需求分析</h2>\n<p>        在上一篇文章中我们完成了利用Elastic Search来对文章进行检索，在一开始时候我们先是创建了一个映射表，然后就是对以前提交的文章进行批量创建索引。但是对于后面发布的文章我们就不应该再像前面那样批量创建索引了，会存在一个时间差问题，我们应该针对发布的文章实时创建一个ES索引。</p>\n<h2>2.实现思路</h2>\n<p><img alt=\"\" height=\"357\" src=\"..\\..\\static\\image\\098e95ed1574475b9ea7904ae5280f48.png\" width=\"1151\"/></p>\n<p>        实现思路是在文章微服务将审核成功的文章保存之前就将其装入消息队列中，然后让搜索微服务进行消息的拉取并消费。为什么不选择直接在文章审核成功之后在自媒体端就将消息放入队列呢？要知道我们创建的映射表中是有文章静态URL（即MinIO中的路径）的，这个URL只有在文章微服务中成功将文章保存值MinIO中才能生成，因此需要在文章微服务中进行消息的发送。 </p>\n<h2>3.代码实现</h2>\n<p>①在ArticleFreemarkerServiceImpl中改造代码如下：</p>\n<pre><code class=\"language-java\">/**\n * 异步生成静态页面到Minio\n * @param apArticle\n * @param apArticleContent\n */\n@Override\n@Async\npublic void buildArticleToMinIO(ApArticle apArticle, String apArticleContent) {\n    StringWriter out = new StringWriter();\n    if(StringUtils.isNotBlank(apArticleContent)){\n        //3.修改ap_article表，保存static_url字段\n        ApArticle article = new ApArticle();\n        article.setId(apArticle.getId());\n        article.setStaticUrl(path);\n        apArticleMapper.updateById(article);\n\n        //4.创建索引，发送消息\n        createArticleESIndex(article,apArticleContent,path);\n    }\n}\n\n@Autowired\nprivate KafkaTemplate&lt;String,String&gt; kafkaTemplate;\n\n/**\n * 创建索引，发送消息\n * @param article\n * @param apArticleContent\n * @param path\n */\nprivate void createArticleESIndex(ApArticle article, String apArticleContent, String path) {\n    SearchArticleVo searchArticleVo = new SearchArticleVo();\n    BeanUtils.copyProperties(apArticleContent,searchArticleVo);\n    searchArticleVo.setContent(apArticleContent);\n    searchArticleVo.setStaticUrl(path);\n\n    //发送消息\n    kafkaTemplate.send(ArticleConstas.ARTICLE_ES_SYNC_TOPIC, JSON.toJSONString(searchArticleVo));\n}</code></pre>\n<p>②在文章微服务的nacos的配置中心添加如下配置</p>\n<pre><code class=\"language-java\">kafka:\n    bootstrap-servers: 12.8.10.10:9092\n    producer:\n      retries: 10\n      key-serializer: org.apache.kafka.common.serialization.StringSerializer\n      value-serializer: org.apache.kafka.common.serialization.StringSerializer</code></pre>\n<p>③搜索微服务中添加kafka的配置,nacos配置如下</p>\n<pre><code class=\"language-java\">spring:\n  kafka:\n    bootstrap-servers: 19.1.20.30:9092\n    consumer:\n      group-id: ${spring.application.name}\n      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</code></pre>\n<p>④定义监听队列进行消息的消费</p>\n<pre><code class=\"language-java\">package com.my.search.listener;\n\nimport com.alibaba.fastjson.JSON;\nimport com.baomidou.mybatisplus.core.toolkit.StringUtils;\nimport com.my.common.constans.ArticleConstas;\nimport com.my.model.search.vos.SearchArticleVo;\nimport lombok.extern.slf4j.Slf4j;\nimport org.elasticsearch.action.index.IndexRequest;\nimport org.elasticsearch.client.RequestOptions;\nimport org.elasticsearch.client.RestHighLevelClient;\nimport org.elasticsearch.common.xcontent.XContentType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.kafka.annotation.KafkaListener;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\n\n\n@Slf4j\n@Component\npublic class SyncArticleListener {\n    @Autowired\n    private RestHighLevelClient restHighLevelClient;\n\n    @KafkaListener(topics = ArticleConstas.ARTICLE_ES_SYNC_TOPIC)\n    public void onMessage(String message) {\n        if(StringUtils.isNotBlank(message)) {\n            log.info(\"接收到消息:{}\",message);\n\n            SearchArticleVo vo = JSON.parseObject(message, SearchArticleVo.class);\n            IndexRequest indexRequest = new IndexRequest(\"app_info_article\");\n            indexRequest.id(vo.getId().toString());\n            indexRequest.source(message, XContentType.JSON);\n            try {\n                restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<h1>二：搜索记录</h1>\n<h2>1.需求分析</h2>\n<p>        在移动端进行搜索时候，我们应该记录每个用户的搜索记录，并且还要进行回显。这时候你可能会想到用MySQL对每个用户都建立一张搜索记录表，当用户量不大时候这样做确实可以，但是随着用户量的增加，就需要创建成千上万张表，而且我们一般只记录用户的有限条搜索记录，这样就会存在表很多但是每张表存储的数据很少的情况，容易造成资源浪费，而且效率不高，维护困难，这时候用MongoDB进行存储就比较合适。</p>\n<h2>2.实现思路</h2>\n<p>        前面我们在用户输入关键词进行搜索时可以发送一个异步请求将搜索关键字进行保存，保存之前需要判断该搜索记录是否存在，若存在则更新搜索时间，否则还要判断数据量是否超过10条，逻辑如下图所示：</p>\n<p><img alt=\"\" height=\"521\" src=\"..\\..\\static\\image\\263f94d123ef48d8aa260792b4162f79.png\" width=\"1185\"/></p>\n<h2>3.代码实现</h2>\n<p>在tbug-headlines-search中新增ApUserSearchService并增加insert方法</p>\n<pre><code class=\"language-java\">@Autowired\nprivate MongoTemplate mongoTemplate;\n/**\n * 保存搜索记录\n * @param keyWord\n * @param userId\n */\n@Override\n@Async\npublic void insert(String keyWord, Integer userId) {\n    log.info(\"保存搜索历史...\");\n    //1.查询当前用户搜索关键词\n    Query query = Query.query(Criteria.where(\"userId\").is(userId).and(\"keyword\").is(keyWord));\n    ApUserSearch apUserSearch = mongoTemplate.findOne(query,ApUserSearch.class);\n\n    //2.存在该关键词，更新时间\n    if(apUserSearch != null) {\n        log.info(\"关键词{}已存在，更新时间\",keyWord);\n        apUserSearch.setCreatedTime(new Date());\n        mongoTemplate.save(apUserSearch);\n        return;\n    }\n\n    //3.不存在关键词\n    log.info(\"不存在该关键词\");\n    apUserSearch = new ApUserSearch();\n    apUserSearch.setUserId(userId);\n    apUserSearch.setKeyword(keyWord);\n    apUserSearch.setCreatedTime(new Date());\n\n    Query query1 = Query.query(Criteria.where(\"userId\").is(userId));\n    query1.with(Sort.by(Sort.Direction.DESC,\"createdTime\"));\n\n    List&lt;ApUserSearch&gt; userSearchList = mongoTemplate.find(query1, ApUserSearch.class);\n    //3.1搜索记录条数不大于10\n    if(userSearchList == null || userSearchList.size() &lt; 10) {\n        log.info(\"搜索记录数不大于10，保存关键词{}\",keyWord);\n        mongoTemplate.save(apUserSearch);\n    } else {\n        //3.2搜索记录条数大于10\n        //3.2.1获取时间最旧的数据\n        ApUserSearch apUserSearch1 = userSearchList.get(userSearchList.size() - 1);\n        log.info(\"关键词{}替换成{}\",apUserSearch1.getKeyword(),keyWord);\n        //3.2.2替换最后一条记录\n        mongoTemplate.findAndReplace(Query.query(Criteria.where(\"id\").is(apUserSearch1.getId())),apUserSearch);\n    }\n\n}</code></pre>\n<p>在ArticleSearchServiceImpl的search方法中增加异步调用方法：</p>\n<pre><code class=\"language-java\">//异步调用保存历史记录\nApUser user = AppThreadLocalUtils.getUser();\n//用户信息不为空并且为首页搜索才进行保存\nif(user != null &amp;&amp; dto.getFromIndex() == 0) {\n    apUserSearchService.insert(dto.getSearchWords(),user.getId());\n}</code></pre>\n<p>回显搜索历史记录</p>\n<pre><code class=\"language-java\">/**\n * 加载历史记录\n * @return\n */\n@Override\npublic ResponseResult loadHistory() {\n    log.info(\"加载用户历史搜索记录...\");\n    //1.获取当前用户id\n    ApUser user = AppThreadLocalUtils.getUser();\n    if(user != null) {\n        Integer userId = user.getId();\n\n        //2.查询该用户历史搜索记录\n        Query query = Query.query(Criteria.where(\"userId\").is(userId));\n        query.with(Sort.by(Sort.Direction.DESC,\"createdTime\"));\n        List&lt;ApUserSearch&gt; searchList = mongoTemplate.find(query, ApUserSearch.class);\n        \n        //3.返回结果\n        return ResponseResult.okResult(searchList);\n    } else {\n        return ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);\n    }\n}</code></pre>\n<p>至于删除历史搜索记录这里就不放代码了，可以自己尝试实现一下。</p>\n<h1>三：关键词联想</h1>\n<h2>1.需求分析</h2>\n<p>相信大家都有用过百度搜索，当我们输入关键字之后会有搜索提示，如下图：</p>\n<p><img alt=\"\" height=\"437\" src=\"..\\..\\static\\image\\09f2d3867c9e402180591673d39eb362.png\" width=\"742\"/></p>\n<p> 而我们也要在移动端实现这个效果。</p>\n<h2>2.实现思路</h2>\n<p>        其实能够实现关键字的联想，主要还是要靠维护一个搜索词数据库，当用户在搜索框输入关键字时候就会不断发送请求到该数据库进行查询并返回，数据库中存储的一般是搜索频率比较高的一些词，通常在企业中有两部分来源：</p>\n<ul><li>自己维护搜索词，通过分析用户搜索频率较高的词，按照排名作为搜索词</li><li>第三方获取，关键词规划师（百度）、5118、爱站网</li></ul>\n<h2>3. 代码实现</h2>\n<p>前面说到当检测到用户输入的关键字有发生变化时候就会发送查询请求，而我们需要快速响应这个请求，因此使用MongoDB比较合适，其接口定义如下：</p>\n<table><thead><tr><th></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>接口路径</td><td>/api/v1/associate/search</td></tr><tr><td>请求方式</td><td>POST</td></tr><tr><td>参数</td><td>UserSearchDto</td></tr><tr><td>响应结果</td><td>ResponseResult</td></tr></tbody></table>\n<p>新增ApAssociateWordsService并增加如下方法：</p>\n<pre><code class=\"language-java\">@Autowired\nprivate MongoTemplate mongoTemplate;\n\n/**\n * 获取联想词\n * @param dto\n * @return\n */\n@Override\npublic ResponseResult getAssociationWord(UserSearchDto dto) {\n    if(dto == null || StringUtils.isBlank(dto.getSearchWords())) {\n        return  ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);\n    }\n\n    //分页查询\n    if(dto.getPageSize() &gt; 20) {\n        dto.setPageSize(20);\n    }\n\n    //模糊查询\n    Query query = Query.query(Criteria.where(\"associateWords\").regex(\".*\\\\\" + dto.getSearchWords() + \".*\"));\n    query.limit(dto.getPageSize());\n    List&lt;ApAssociateWords&gt; apAssociateWords = mongoTemplate.find(query, ApAssociateWords.class);\n    return ResponseResult.okResult(apAssociateWords);\n}\n</code></pre>\n<p></p>\n<p>下篇预告：Kafka Stream实现文章热度实时计算</p>\n<p> 友情链接： <a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_zssj_sf\" title=\"牛客网  刷题|面试|找工作神器\">牛客网  刷题|面试|找工作神器</a></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-09-07 10:02:41", "summary": "个人简介：个人主页：赵四司机赵四司机学习方向：后端开发往期文章：项目整合微信支付项目整合微信支付博主推荐网站：牛客网刷题面试找工作神器牛客网刷题面试找工作神器种一棵树最好的时间是十年前，其次是现在！喜"}