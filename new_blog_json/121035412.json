{"blogid": "121035412", "writerAge": "码龄3年", "writerBlogNum": "57", "writerCollect": "1288", "writerComment": "46", "writerFan": "146", "writerGrade": "4级", "writerIntegral": "1333", "writerName": "上进的鹏多多", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121035412.jpg", "writerRankTotal": "13495", "writerRankWeekly": "21278", "writerThumb": "358", "writerVisitNum": "78453", "blog_read_count": "28829", "blog_time": "于 2021-11-01 09:42:48 发布", "blog_title": "助你上手Vue3全家桶之Vue3教程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>目录</h3>\n<ul><li><a href=\"#_1\">前言</a></li><li><a href=\"#1setup_8\">1，setup</a></li><li><ul><li><a href=\"#11_14\">1.1，返回值</a></li><li><a href=\"#12_21\">1.2，注意点</a></li><li><a href=\"#13_35\">1.3，语法</a></li><li><a href=\"#14setup_58\">1.4，setup的参数</a></li></ul>\n</li><li><a href=\"#2ref__68\">2，ref 创建响应式数据</a></li><li><a href=\"#3reactive__86\">3，reactive 创建响应式数据</a></li><li><a href=\"#4computed__103\">4，computed 计算属性</a></li><li><a href=\"#5watch__135\">5，watch 监听</a></li><li><a href=\"#6watchEffect__188\">6，watchEffect 监听回调</a></li><li><a href=\"#7_204\">7，生命周期</a></li><li><ul><li><a href=\"#71_209\">7.1，改变</a></li><li><a href=\"#72_223\">7.2，语法</a></li></ul>\n</li><li><a href=\"#8toRef_ref_234\">8，toRef 创建ref</a></li><li><a href=\"#9toRefs__257\">9，toRefs 响应式转换</a></li><li><a href=\"#10shallowReactive__274\">10，shallowReactive 响应式外层转换</a></li><li><a href=\"#11shallowRef__290\">11，shallowRef 基本数据响应式</a></li><li><a href=\"#12readonly__303\">12，readonly 响应式变只读</a></li><li><a href=\"#13shallowReadonly__319\">13，shallowReadonly 响应式变只读</a></li><li><a href=\"#14toRaw__335\">14，toRaw 响应式变非响应式</a></li><li><a href=\"#15markRaw__348\">15，markRaw 标记永远不响应式</a></li><li><a href=\"#16customRef__364\">16，customRef 依赖更新控制</a></li><li><a href=\"#17provide__inject__406\">17，provide &amp; inject 通信</a></li><li><a href=\"#18_427\">18，响应式数据的判断</a></li><li><ul><li><a href=\"#181isRef_431\">18.1，isRef</a></li><li><a href=\"#182isReactive_443\">18.2，isReactive</a></li><li><a href=\"#183isReadonly_455\">18.3，isReadonly</a></li><li><a href=\"#184isProxy_468\">18.4，isProxy</a></li></ul>\n</li><li><a href=\"#19teleport_dom_481\">19，teleport 移动dom组件</a></li><li><a href=\"#20Suspense__509\">20，Suspense 异步渲染组件</a></li><li><a href=\"#21API_540\">21，全局API调整</a></li><li><a href=\"#22api_554\">22，移除api</a></li><li><a href=\"#23Ref_DOM_569\">23，Ref 获取DOM</a></li><li><ul><li><a href=\"#231ref_574\">23.1，单个ref</a></li><li><a href=\"#232ref_598\">23.2，循环中的ref</a></li></ul>\n</li><li><a href=\"#24emits__633\">24，emits 自定义事件</a></li><li><a href=\"#25nextTick__665\">25，$nextTick 异步更新</a></li><li><a href=\"#26hook__678\">26，hook 生命周期事件</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>前言</h1>\n<p>这些内容是博主在学习过程中记录下来的，有一些不重要的点就跳过了，需要时自行查询文档。其实<code>V2</code>到<code>V3</code>的学习成本不高，熟悉<code>V2</code>的话，看完这篇文章就可以上手<code>V3</code>。</p>\n<p><a href=\"https://v3.cn.vuejs.org/\">Vue3官网</a></p>\n<p><a href=\"https://vue-next-template-explorer.netlify.app/\">在线源码编译地址</a></p>\n<h1><a id=\"1setup_8\"></a>1，setup</h1>\n<hr/>\n<p><code>setup</code>是所有<code>Composition API</code>的容器，值为一个函数。组件中所用到的数据、方法等等，均要配置在<code>setup</code>中，它会在<code>beforeCreate</code>之前执行一次，注意：<code>V3</code>里<code>this</code>不再是指向<code>Vue</code>实例，访问<code>this</code>会是<code>undefined</code></p>\n<h2><a id=\"11_14\"></a>1.1，返回值</h2>\n<hr/>\n<ul><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。</li><li>若返回一个渲染函数：则可以自定义渲染内容。</li></ul>\n<h2><a id=\"12_21\"></a>1.2，注意点</h2>\n<hr/>\n<p><strong>尽量不要与V2配置混用</strong></p>\n<p><code>V2</code>配置（<code>data</code>、<code>methos</code>、<code>computed</code>…）中可以访问到<code>setup</code>中的属性、方法。<br/> 但在<code>setup</code>中不能访问到<code>V2</code>配置（<code>data</code>、<code>methods</code>、<code>computed</code>…）。<br/> 如果有重名, <code>setup</code>优先。</p>\n<p><strong>setup不能是一个async函数</strong></p>\n<p>因为返回值不再<code>return</code>的对象, 而是<code>promise</code>, 模板看不到<code>return</code>对象中的属性。（后期也可以返回一个<code>Promise</code>实例，但需要<code>Suspense</code>和异步组件的配合）</p>\n<h2><a id=\"13_35\"></a>1.3，语法</h2>\n<hr/>\n<pre><code class=\"prism language-JavaScript\">&lt;script&gt;\nimport { ref, reactive } from 'vue'\n\nexport default {\n\tname: 'Home',\n\tsetup(props, context) {\n\t\tconst title = ref('标题')\n\t\tconst data = reactive({\n\t\t\tvalue: '哈哈哈'\n\t\t})\n\t\treturn {\n\t\t  title,\n\t\t  data\n\t\t}\n\t}\n}\n&lt;/script&gt;\n</code></pre>\n<h2><a id=\"14setup_58\"></a>1.4，setup的参数</h2>\n<hr/>\n<ul><li> <p>props：值为对象，包含组件外部传递过来，且组件内部声明接收了的属性</p> </li><li> <p>context：上下文对象</p>\n<ul><li>attrs: 值为对象，包含组件外部传递过来，但没有在<code>props</code>配置中声明的属性, 相当于<code>this.$attrs</code></li><li>slots: 收到的插槽内容, 相当于<code>this.$slots</code></li><li>emit: 分发自定义事件的函数, 相当于<code>this.$emit</code></li></ul> </li></ul>\n<h1><a id=\"2ref__68\"></a>2，ref 创建响应式数据</h1>\n<hr/>\n<p>使用<code>ref</code>可以创建一个包含响应式数据的引用对象（reference对象，简称ref对象），可以是基本类型、也可以是对象。</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">// 创建\nconst xxx = ref(value)\n\n// 使用\nxxx.value\n\n// 在模板中\n&lt;div&gt;{<!-- -->{xxx}}&lt;/div&gt;\n</code></pre>\n<h1><a id=\"3reactive__86\"></a>3，reactive 创建响应式数据</h1>\n<hr/>\n<p>定义一个对象类型的响应式数据，内部基于<code>ES6</code>的<code>Proxy</code>实现，通过代理对象操作源对象内部数据进行操作</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">// 创建\nconst xxx = reactive({\n    xxx: ''\n})\n\n// 使用\nxxx.xxx\n</code></pre>\n<h1><a id=\"4computed__103\"></a>4，computed 计算属性</h1>\n<hr/>\n<p>与<code>V2</code>中<code>computed</code>配置功能一致</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">import { computed } from 'vue'\n\nsetup(){\n\t// 简写语法\n    let fullName = computed(() =&gt; {\n        return person.firstName + '-' + person.lastName\n    })\n    \n    // 完整语法\n    let fullName = computed({\n        get(){\n            return person.firstName + '-' + person.lastName\n        },\n        set(value){\n            const nameArr = value.split('-')\n            person.firstName = nameArr[0]\n            person.lastName = nameArr[1]\n        }\n    })\n    \n    return fullName\n}\n</code></pre>\n<h1><a id=\"5watch__135\"></a>5，watch 监听</h1>\n<hr/>\n<p>与<code>V2</code>中<code>watch</code>配置功能一致，语法有点改动</p>\n<p><strong>语法</strong></p>\n<ul><li>情况一：监视<code>ref</code>定义的响应式数据</li></ul>\n<pre><code class=\"prism language-JavaScript\">watch(sum, (newValue, oldValue) =&gt; {\n\tconsole.log('sum变化了', newValue, oldValue)\n}, {immediate:true})\n</code></pre>\n<ul><li>情况二：监视多个<code>ref</code>定义的响应式数据</li></ul>\n<pre><code class=\"prism language-JavaScript\">watch([sum, msg], (newValue,oldValue) =&gt; {\n\tconsole.log('sum或msg变化了', newValue,oldValue)\n}) \n</code></pre>\n<ul><li>情况三：监视<code>reactive</code>定义的响应式数据</li></ul>\n<pre><code class=\"prism language-JavaScript\">// 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue\n// 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视\nwatch(person, (newValue, oldValue) =&gt; {\n\tconsole.log('person变化了', newValue, oldValue)\n}, { immediate:true, deep:false }) // 此处的deep配置不再奏效\n</code></pre>\n<ul><li>情况四：监视<code>reactive</code>定义的响应式数据中的某个属性</li></ul>\n<pre><code class=\"prism language-JavaScript\">watch(() =&gt; person.job, (newValue, oldValue) =&gt; {\n\tconsole.log('person的job变化了', newValue, oldValue)\n}, { immediate:true, deep:true }) \n</code></pre>\n<ul><li>情况五：监视<code>reactive</code>定义的响应式数据中的某些属性</li></ul>\n<pre><code class=\"prism language-JavaScript\">watch([() =&gt; person.job, () =&gt; person.name], (newValue, oldValue) =&gt; {\n\tconsole.log('person的job变化了', newValue, oldValue)\n}, { immediate:true, deep:true })\n</code></pre>\n<ul><li>特殊情况：此处由于监视的是<code>reactive</code>素定义的对象中的某个属性，所以deep配置有效</li></ul>\n<pre><code class=\"prism language-JavaScript\">watch(() =&gt; person.job, (newValue, oldValue) =&gt; {\n    console.log('person的job变化了', newValue, oldValue)\n}, { deep:true })\n</code></pre>\n<h1><a id=\"6watchEffect__188\"></a>6，watchEffect 监听回调</h1>\n<hr/>\n<p>和<code>watch</code>的区别是，<code>watch</code>既要指明监视的属性，也要指明监视的回调。而<code>watchEffect</code>，不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性，不用写返回值。</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">// 回调中用到的数据只要发生变化，则直接重新执行回调\nwatchEffect(() =&gt; {\n    const x1 = sum.value\n    const x2 = person.age\n    console.log('watchEffect配置的回调执行了')\n})\n</code></pre>\n<h1><a id=\"7_204\"></a>7，生命周期</h1>\n<hr/>\n<p>生命周期全都写在<code>setup</code>中</p>\n<h2><a id=\"71_209\"></a>7.1，改变</h2>\n<hr/>\n<ul><li>beforeDestroy 改名为 beforeUnmount</li><li>destroyed 改名为 unmounted</li><li>beforeCreate =&gt; setup</li><li>created =&gt; setup</li><li>beforeMount =&gt; onBeforeMount</li><li>mounted =&gt; onMounted</li><li>beforeUpdate =&gt; onBeforeUpdate</li><li>updated =&gt; onUpdated</li><li>beforeUnmount =&gt; onBeforeUnmount</li><li>unmounted =&gt; onUnmounted</li></ul>\n<h2><a id=\"72_223\"></a>7.2，语法</h2>\n<hr/>\n<pre><code class=\"prism language-JavaScript\">setup() {\n    onMounted(() =&gt; {\n      console.log('mounted')\n    })\n}\n</code></pre>\n<h1><a id=\"8toRef_ref_234\"></a>8，toRef 创建ref</h1>\n<hr/>\n<p>创建一个<code>ref</code>对象，其<code>value</code>值指向另一个对象中的某个属性</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const state = reactive({\n  foo: 1,\n  bar: 2\n})\n\nconst fooRef = toRef(state, 'foo')\n\n// 传递props\nexport default {\n  setup(props) {\n    useSomeFeature(toRef(props, 'foo'))\n  }\n}\n</code></pre>\n<h1><a id=\"9toRefs__257\"></a>9，toRefs 响应式转换</h1>\n<hr/>\n<p>将响应式对象转换为普通对象，其中结果对象的每个<code>property</code>都是指向原始对象相应<code>property</code>的<code>ref</code></p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const state = reactive({\n  foo: 1,\n  bar: 2\n})\n\nconst stateAsRefs = toRefs(state)\n// 此时state和stateAsRefs是关联的\n</code></pre>\n<h1><a id=\"10shallowReactive__274\"></a>10，shallowReactive 响应式外层转换</h1>\n<hr/>\n<p>只处理对象最外层属性的响应式（浅响应式）。适用于：一个对象数据，结构比较深, 但变化时只是外层属性变化</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const state = shallowReactive({\n  foo: 1,\n  nested: {\n    bar: 2\n  }\n})\n</code></pre>\n<h1><a id=\"11shallowRef__290\"></a>11，shallowRef 基本数据响应式</h1>\n<hr/>\n<p>只处理基本数据类型的响应式, 不进行对象的响应式处理。适用于：一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const shallow = shallowRef({\n  greet: 'Hello, world'\n})\n</code></pre>\n<h1><a id=\"12readonly__303\"></a>12，readonly 响应式变只读</h1>\n<hr/>\n<p>让一个响应式数据变为只读的（深只读），应用于不希望数据被修改时</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const shallow = shallowRef({\n  greet: 'Hello, world', // 只读\n  nested: {\n    bar: 2 // 只读\n  }\n})\n</code></pre>\n<h1><a id=\"13shallowReadonly__319\"></a>13，shallowReadonly 响应式变只读</h1>\n<hr/>\n<p>让一个响应式数据变为只读的（浅只读），应用于不希望数据被修改时</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const shallow = shallowReadonly({\n  foo: 1, // 只读\n  nested: {\n    bar: 2 // 非只读\n  }\n})\n</code></pre>\n<h1><a id=\"14toRaw__335\"></a>14，toRaw 响应式变非响应式</h1>\n<hr/>\n<p>将一个由reactive生成的响应式对象转为普通对象，对这个普通对象的所有操作，不会引起页面更新。</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const foo = {}\nconst Foo = reactive(foo)\nconsole.log(toRaw(Foo) === foo) // true\n</code></pre>\n<h1><a id=\"15markRaw__348\"></a>15，markRaw 标记永远不响应式</h1>\n<hr/>\n<p>标记一个对象，使其永远不会再成为响应式对象，有些值不应被设置为响应式的，例如复杂的第三方类库等，当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const foo = markRaw({})\nconsole.log(isReactive(reactive(foo))) // false\n\n// 嵌套在其他响应式对象中时也可以使用\nconst bar = reactive({ foo })\nconsole.log(isReactive(bar.foo)) // false\n</code></pre>\n<h1><a id=\"16customRef__364\"></a>16，customRef 依赖更新控制</h1>\n<hr/>\n<p>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收<code>track</code>和<code>trigger</code>函数作为参数，并且应该返回一个带有<code>get</code>和<code>set</code>的对象。</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">&lt;script&gt;\nimport { customRef } from 'vue'\n\nexport default {\n\tname: 'Home',\n\tsetup() {\n\t    // 实现防抖函数\n\t\tconst fn = function(value, delay = 500) {\n\t\t\tlet timeout\n\t\t\treturn customRef((track, trigger) =&gt; {\n\t\t\t\treturn {\n\t\t\t\t\tget() {\n\t\t\t\t\t\ttrack()\n\t\t\t\t\t\treturn value\n\t\t\t\t\t},\n\t\t\t\t\tset(newValue) {\n\t\t\t\t\t\tclearInterval(timeout)\n\t\t\t\t\t\ttimeout = setTimeout(() =&gt; {\n\t\t\t\t\t\t\tconsole.log(newValue)\n\t\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t\t\ttrigger()\n\t\t\t\t\t\t}, delay)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst keyword = fn('', 500)\n\t\treturn {\n\t\t\tkeyword\n\t\t}\n\t}\n}\n&lt;/script&gt;\n</code></pre>\n<h1><a id=\"17provide__inject__406\"></a>17，provide &amp; inject 通信</h1>\n<hr/>\n<p>实现祖与后代组件间通信，父组件有一个<code>provide</code>选项来提供数据，后代组件有一个<code>inject</code>选项来开始使用这些数据</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">// 祖组件\nsetup(){\n    let car = reactive({ name:'奔驰', price:'40万' })\n    provide('car', car)\n}\n\n// 后代组件\nsetup(props, context){\n    const car = inject('car')\n    return { car }\n}\n</code></pre>\n<h1><a id=\"18_427\"></a>18，响应式数据的判断</h1>\n<hr/>\n<h2><a id=\"181isRef_431\"></a>18.1，isRef</h2>\n<hr/>\n<p>检查一个值是否为一个<code>ref</code>对象</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const val = ref('xxx')\nisRef(val) // true\n</code></pre>\n<h2><a id=\"182isReactive_443\"></a>18.2，isReactive</h2>\n<hr/>\n<p>检查一个值是否为一个<code>isReactive</code>对象</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const val = isReactive({})\nisRef(val) // true\n</code></pre>\n<h2><a id=\"183isReadonly_455\"></a>18.3，isReadonly</h2>\n<hr/>\n<p>检查一个对象是否是由<code>readonly</code>创建的只读代理</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const state = reactive({\n  name: 'John'\n})\nconsole.log(isReactive(state)) // true\n</code></pre>\n<h2><a id=\"184isProxy_468\"></a>18.4，isProxy</h2>\n<hr/>\n<p>检查对象是否是由<code>reactive</code>或<code>readonly</code>创建的<code>proxy</code></p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">const state = reactive({\n  name: 'John'\n})\nconsole.log(isProxy(state)) // true\n</code></pre>\n<h1><a id=\"19teleport_dom_481\"></a>19，teleport 移动dom组件</h1>\n<hr/>\n<p><code>Teleport</code>提供了一种干净的方法，允许我们控制在<code>DOM</code>中哪个父节点下渲染了<code>HTML</code>，而不必求助于全局状态或将其拆分为两个组件。</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">&lt;teleport to=\"移动位置\"&gt;\n\t&lt;div v-if=\"isShow\" class=\"mask\"&gt;\n\t\t&lt;div class=\"dialog\"&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;/h3&gt;\n\t\t\t&lt;button @click=\"isShow = false\"&gt;关闭弹窗&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t&lt;/div&gt;\n&lt;/teleport&gt;\n\n\n// to的格式\n&lt;teleport to=\"#some-id\" /&gt;\n&lt;teleport to=\".some-class\" /&gt;\n&lt;teleport to=\"[data-teleport]\" /&gt;\n\n// disabled的格式\n&lt;teleport to=\"#popup\" :disabled=\"displayVideoInline\"&gt;\n  &lt;video src=\"./my-movie.mp4\"&gt;\n&lt;/teleport&gt;\n</code></pre>\n<h1><a id=\"20Suspense__509\"></a>20，Suspense 异步渲染组件</h1>\n<hr/>\n<p>等待异步组件时先渲染一些额外内容，让应用有更好的用户体验</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">&lt;template&gt;\n\t&lt;div class=\"app\"&gt;\n\t\t&lt;h3&gt;我是App组件&lt;/h3&gt;\n\t\t&lt;Suspense&gt;\n\t\t\t&lt;template #default&gt;\n\t\t\t\t&lt;Child/&gt;\n\t\t\t&lt;/template&gt;\n\t\t\t&lt;template #fallback&gt;\n\t\t\t\t&lt;h3&gt;加载中.....&lt;/h3&gt;\n\t\t\t&lt;/template&gt;\n\t\t&lt;/Suspense&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n\n\nimport { defineAsyncComponent } from 'vue'\nconst Child = defineAsyncComponent(() =&gt; import('./components/Child.vue'))\n\ncomponents: {\n    Child\n}\n</code></pre>\n<h1><a id=\"21API_540\"></a>21，全局API调整</h1>\n<hr/>\n<p>将全局的API，即：Vue.xxx调整到应用实例（app）上</p>\n<table><thead><tr><th>V2的api</th><th>V3的api</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table>\n<h1><a id=\"22api_554\"></a>22，移除api</h1>\n<hr/>\n<table><thead><tr><th>名称</th><th>现状</th></tr></thead><tbody><tr><td>Vue.config.productionTip</td><td>已移除</td></tr><tr><td>config.keyCodes</td><td>已移除</td></tr><tr><td>$children</td><td>已移除</td></tr><tr><td>$listeners</td><td>已移除</td></tr><tr><td>$on</td><td>已移除</td></tr><tr><td>$off</td><td>已移除</td></tr><tr><td>$once</td><td>已移除</td></tr><tr><td>filters</td><td>已移除</td></tr><tr><td>.native</td><td>已移除</td></tr></tbody></table>\n<h1><a id=\"23Ref_DOM_569\"></a>23，Ref 获取DOM</h1>\n<hr/>\n<p>由于<code>V3</code>中不在存在<code>this</code>，所以<code>ref</code>的获取调整了</p>\n<h2><a id=\"231ref_574\"></a>23.1，单个ref</h2>\n<hr/>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">&lt;div ref=\"Qrcode\" class=\"qr_codeode_url\" /&gt;\n\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const Qrcode = ref(null)\n    // 挂载后\n\tonMounted(() =&gt; {\n\t\tconsole.log(Qrcode.value)\n\t})\n    return {\n      Qrcode\n    }\n  }\n}\n</code></pre>\n<h2><a id=\"232ref_598\"></a>23.2，循环中的ref</h2>\n<hr/>\n<p><code>V3</code>中在<code>for</code>循环元素上绑定<code>ref</code>将不再自动创建<code>$ref</code>数组。要从单个绑定获取多个<code>ref</code>，请将<code>ref</code>绑定到一个更灵活的函数上</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">&lt;div v-for=\"item in list\" :ref=\"setItemRef\"&gt;&lt;/div&gt;\n\nimport { onBeforeUpdate, onUpdated } from 'vue'\n\nexport default {\n  setup() {\n    let itemRefs = []\n    const setItemRef = el =&gt; {\n      if (el) {\n        itemRefs.push(el)\n      }\n    }\n    onBeforeUpdate(() =&gt; {\n      itemRefs = []\n    })\n    onUpdated(() =&gt; {\n      console.log(itemRefs)\n    })\n    return {\n      setItemRef\n    }\n  }\n}\n</code></pre>\n<ul><li><code>itemRefs</code>不必是数组：它也可以是一个对象，其<code>ref</code>可以通过迭代的<code>key</code>被设置</li><li>如有需要，<code>itemRef</code>也可以是响应式的，且可以被侦听</li></ul>\n<h1><a id=\"24emits__633\"></a>24，emits 自定义事件</h1>\n<hr/>\n<p>定义一个组件可以向其父组件触发的事件</p>\n<pre><code class=\"prism language-JavaScript\">// 在子组件中\n&lt;h1 @click=\"father\"&gt;{<!-- -->{ msg }}&lt;/h1&gt;\n\nexport default {\n\tname: 'HelloWorld',\n\tprops: {\n\t\tmsg: {\n\t\t\ttype: String,\n\t\t\tdefault: ''\n\t\t}\n\t},\n\temits: ['close'],\n\tsetup(props, { emit }) {\n\t\tconst father = function() {\n\t\t\temit('close', 'child')\n\t\t}\n\t\treturn {\n\t\t\tfather\n\t\t}\n\t}\n}\n\n// 在父组件中\n&lt;HelloWorld :msg=\"msg\" @click=\"fn\" @close=\"fn2\" /&gt;\n</code></pre>\n<h1><a id=\"25nextTick__665\"></a>25，$nextTick 异步更新</h1>\n<hr/>\n<p>使用方式修改</p>\n<pre><code class=\"prism language-JavaScript\">import { nextTick } from 'vue'\n\nnextTick(() =&gt; {\n  // ...\n})\n</code></pre>\n<h1><a id=\"26hook__678\"></a>26，hook 生命周期事件</h1>\n<hr/>\n<p>通过事件来监听组件生命周期中的关键阶段</p>\n<p><strong>语法</strong></p>\n<pre><code class=\"prism language-JavaScript\">// V2的语法\n&lt;template&gt;\n  &lt;child-component @hook:updated=\"onUpdated\"&gt;\n&lt;/template&gt;\n\n// V3的语法\n&lt;template&gt;\n  &lt;child-component @vnode-updated=\"onUpdated\"&gt;\n&lt;/template&gt;\n\n// 驼峰写法\n&lt;template&gt;\n  &lt;child-component @vnodeUpdated=\"onUpdated\"&gt;\n&lt;/template\n</code></pre>\n<hr/>\n<p><strong>如果看了觉得有帮助的，我是@鹏多多i，欢迎 点赞 关注 评论；END</strong></p>\n<p><code>PS：在本页按F12，在console中输入document.querySelectorAll('.tool-item-href')[0].click()，有惊喜哦~</code></p>\n<p><a href=\"https://qm.qq.com/cgi-bin/qm/qr?k=Rik8--eP5pNr5CQawsb5PLXx1RiX205I&amp;jump_from=webapi\" rel=\"noopener noreferrer\" target=\"_blank\"><img alt=\"面向百度编程\" border=\"0\" src=\"//pub.idqqimg.com/wpa/images/group.png\" title=\"面向百度编程\"/></a></p>\n<p><mark>公众号</mark></p>\n<p><img alt=\"公众号\" src=\"..\\..\\static\\image\\20210720095734229.png\"/></p>\n<p><mark>往期文章</mark></p>\n<ul><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/121036684\">助你上手Vue3全家桶之Vue-Router4教程</a></li><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/121036145\">助你上手Vue3全家桶之VueX4教程</a></li><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/113563786\">超详细！Vue的九种通信方式</a></li><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/118677514\">超详细！Vuex手把手教程</a></li><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/119386246\">超详细！Vue-Router手把手教程</a></li><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/115981856\">使用nvm管理node.js版本以及更换npm淘宝镜像源</a></li><li><a href=\"https://blog.csdn.net/pdd11997110103/article/details/116002824\">vue中利用.env文件存储全局环境变量，以及配置vue启动和打包命令</a></li></ul>\n<p><mark>个人主页</mark></p>\n<ul><li><a href=\"https://blog.csdn.net/pdd11997110103?spm=1010.2135.3001.5421\">CSDN</a></li><li><a href=\"https://github.com/wp993080086\">GitHub</a></li><li><a href=\"https://www.jianshu.com/u/b7a8536bff06\">简书</a></li><li><a href=\"https://www.cnblogs.com/-pdd/\">博客园</a></li><li><a href=\"https://juejin.cn/user/747323639737191\">掘金</a></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2021-11-01 09:42:48", "summary": "目录前言，，返回值，注意点，语法，的参数，创建响应式数据，创建响应式数据，计算属性，监听，监听回调，生命周期，改变，语法，创建，响应式转换，响应式外层转换，基本数据响应式，响应式变只读，响应式变只读，"}