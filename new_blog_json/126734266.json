{"blogid": "126734266", "writerAge": "码龄4年", "writerBlogNum": "453", "writerCollect": "481", "writerComment": "138", "writerFan": "229", "writerGrade": "6级", "writerIntegral": "5014", "writerName": "cheems~", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126734266.jpg", "writerRankTotal": "3850", "writerRankWeekly": "2112", "writerThumb": "341", "writerVisitNum": "218952", "blog_read_count": "35", "blog_time": "已于 2022-09-07 10:27:34 修改", "blog_title": "C++文件服务器项目—Nginx—3", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>C++文件服务器项目—Nginx—3</h3>\n<ul><li><a href=\"#_2\">前言</a></li><li><a href=\"#1_Nginx_10\">1. Nginx一些基本概念</a></li><li><ul><li><a href=\"#11_Nginx_11\">1.1 Nginx初步认识</a></li><li><a href=\"#12__57\">1.2 正向代理概念理解</a></li><li><a href=\"#13__66\">1.3 反向代理概念理解</a></li></ul>\n</li><li><a href=\"#2_Nginx_103\">2. Nginx的安装与配置</a></li><li><ul><li><a href=\"#21_Nginx_104\">2.1 Nginx与相关依赖库的安装</a></li><li><a href=\"#22_Nginx_187\">2.2 Nginx相关的指令</a></li><li><a href=\"#23_Nginx_246\">2.3 Nginx的配置</a></li><li><a href=\"#24_location_318\">2.4 location指令的提取</a></li></ul>\n</li><li><a href=\"#3_Nginx_423\">3. Nginx的使用</a></li><li><ul><li><a href=\"#31__424\">3.1 部署静态网页</a></li><li><a href=\"#32_httpipportloginhtml_440\">3.2 访问http://ip:port/login.html</a></li><li><a href=\"#33_httpipporthelloreghtml_482\">3.3 访问http://ip:port/hello/reg.html</a></li><li><a href=\"#34_httpipportupload_521\">3.4 访问http://ip:port/upload/</a></li></ul>\n</li><li><a href=\"#4_Nginx_548\">4. Nginx作为反向代理服务器</a></li><li><ul><li><a href=\"#41__549\">4.1 准备实验环境</a></li><li><a href=\"#42__564\">4.2 反向代理设置</a></li><li><a href=\"#43__606\">4.3 反向代理总结与测试</a></li></ul>\n</li><li><a href=\"#5_Nginx_612\">5. Nginx实现负载均衡</a></li><li><ul><li><a href=\"#51__613\">5.1 分析反向代理的缺陷</a></li><li><a href=\"#52__626\">5.2 负载均衡设置</a></li><li><a href=\"#53__703\">5.3 负载均衡总结与测试</a></li></ul>\n</li><li><a href=\"#6__714\">6. 需要了解的知识</a></li><li><ul><li><a href=\"#61_IP_715\">6.1 IP和域名的关系</a></li><li><a href=\"#62_URLURI_744\">6.2 URL和URI</a></li><li><a href=\"#63_DNS_774\">6.3 DNS解析过程</a></li><li><a href=\"#64_http_812\">6.4 http协议报文分析</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_2\"></a>前言</h1>\n<p>  本文重点介绍nginx的安装与配置，实现反向代理和负载均衡。源码地址：<a href=\"https://github.com/gopherWxf/c-c-linux-LearningCode/tree/master/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE\">gopherWxf git </a></p>\n<p>  本专栏知识点是通过<strong>零声教育</strong>的线上课学习，进行梳理总结写下文章，对c/c++linux课程感兴趣的读者，可以点击链接 <a href=\"https://ke.qq.com/course/417774?flowToken=1010783\">C/C++后台高级服务器课程介绍</a> 详细查看课程的服务。</p>\n<h1><a id=\"1_Nginx_10\"></a>1. Nginx一些基本概念</h1>\n<h2><a id=\"11_Nginx_11\"></a>1.1 Nginx初步认识</h2>\n<p>  Nginx介绍：又名engine x，是一个框架，作者是俄罗斯人，开源的框架，C语言编写，淘宝基于nginx开源出了Tengine。</p>\n<p>  Nginx能干什么：1. 作为web服务器(-解析http协议)、2. 反向代理服务器（实现web服务器的负载均衡） 、3.邮件服务器(解析邮件相关的协议: pop3/smtp/imap)。</p>\n<p>  Nginx的优势：</p>\n<blockquote>\n<ul><li> <p>更快</p>\n<ul><li>高峰期(数以万计的并发时)nginx可以比其它web服务器更快的响应请求</li></ul> </li><li> <p>高扩展</p>\n<ul><li><strong>低耦合</strong>设计的模块组成,丰富的第三方模块支持</li></ul> </li><li> <p>高可靠</p>\n<ul><li>经过大批网站检验 \n     <ul><li>www.sina.com.cn</li><li>www.xunlei.com</li><li>www.163.com</li></ul> </li><li>每个worker进程相对独立, 出错之后可以快速开启新的worker \n     <ul><li>worker进程是在后台干活的进程</li><li>worker进程的个数是可以控制的</li></ul> </li></ul> </li><li> <p>低内存消耗</p>\n<ul><li>一般情况下,10000个非活跃的HTTP Keep-Alive连接在nginx中仅消耗 2.5M内存</li></ul> </li><li> <p>单机支持10万以上的并发连接</p>\n<ul><li>取决于内存,10万远未封顶</li></ul> </li><li> <p>热部署</p>\n<ul><li>master和worker的分离设计,可实现7x24小时不间断服务的前提下升级nginx可执行文件</li></ul> </li><li> <p>最自由的BSD许可协议</p>\n<ul><li>BSD许可协议允许用户免费使用nginx, 修改nginx源码,然后再发布 \n     <ul><li>淘宝: tengine</li></ul> </li></ul> </li></ul>\n</blockquote>\n<h2><a id=\"12__57\"></a>1.2 正向代理概念理解</h2>\n<p>  正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cd3111ba8c8e4deca9eee0c670b20ba3.png\"/></p>\n<p>  正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径，最具代表性的就是<code>学校的校园网</code>，通常需要账号密码登陆才能访问外网；<code>挂vpn</code>访问github，谷歌等。可以看到，正向代理是为用户服务的，比较偏向于客户端。</p>\n<h2><a id=\"13__66\"></a>1.3 反向代理概念理解</h2>\n<p>  反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配。</p>\n<p>  举个例子：三个客户端想要同时访问服务器，会给服务器造成一定的压力。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fe98faa77bec4e3dacfb411644edee4b.png\"/><br/>   即使增加了服务器，但是我们也无法限制客户端去访问那一台服务器，这就操作了服务器的请求分配不均匀。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e1ace7c3dd0d4a6183878971d7fe4676.png\"/></p>\n<p>  这个时候，如果能有一个代理出现，客户端先走到代理，再由代理去分配具体走到哪个服务器上，这样，服务器接收到的请求就比较均匀了。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b9364848327c4ab49d4759b64ce1b0f5.png\"/>  <br/>   这么中间这个代理就是反向代理服务器！</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ea45ed62e6154ed69046462427f855d2.png\"/></p>\n<p>下面来总结一下反向代理服务器：</p>\n<ol><li>客户端给服务器发送请求, 连接服务器, 用户不知道服务器地址, 只有反向代理服务器的地址是公开的</li><li>那么客户端只能将请求直接发给反向代理服务器</li><li>反向代理服务器将请求转发给后边的web服务器</li><li>web服务器 N 台，那么反向代理服务器转发请求会轮询分配请求(当然也可以设置权重，后续介绍)</li><li>web服务器收到请求进行处理, 得到结果</li><li>web服务器将处理结果发送给反向代理服务器</li><li>反向代理服务器将拿到的结果转发给客户端</li></ol>\n<h1><a id=\"2_Nginx_103\"></a>2. Nginx的安装与配置</h1>\n<h2><a id=\"21_Nginx_104\"></a>2.1 Nginx与相关依赖库的安装</h2>\n<p>  对应的安装包已经放在前言的源码链接中，需要的自取。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\13751eda3839444ba0c986551adb23b6.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d38864f9f9d24694bcb0cb18e423fc9e.png\"/></p>\n<p>  Nginx依赖openssl，zlib，pcre这些库。所以首先我们要把这三个库给安装好</p>\n<blockquote>\n<p>Nginx官方地址: <a href=\"http://nginx.org/\">http://nginx.org/</a><br/> Nginx相关依赖:</p>\n<ul><li>OpenSSL: <a href=\"http://www.openssl.org/\">http://www.openssl.org/</a>\n<ul><li>密码库</li><li>使用https进行通信的时候使用</li></ul> </li></ul>\n</blockquote>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">tar</span> -zxvf openssl-1.1.1g.tar.gz \n<span class=\"token builtin class-name\">cd</span> openssl-1.1.1g\n./config \n<span class=\"token function\">make</span>\n<span class=\"token function\">make</span> <span class=\"token function\">install</span>\nldconfig\n</code></pre>\n<blockquote>\n<ul><li>ZLib下载: <a href=\"http://www.zlib.net/\">http://www.zlib.net/</a>\n<ul><li>数据压缩</li><li>安装:</li></ul> </li></ul>\n</blockquote>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">tar</span> -zxvf zlib-1.2.11.tar.gz \n<span class=\"token builtin class-name\">cd</span> zlib-1.2.11\n./configure \n<span class=\"token function\">make</span>\n<span class=\"token function\">make</span> <span class=\"token function\">install</span>\nldconfig\n</code></pre>\n<blockquote>\n<ul><li>PCRE下载: <a href=\"http://www.pcre.org/\">http://www.pcre.org/</a>\n<ul><li>解析正则表达式</li><li>安装</li></ul> </li></ul>\n</blockquote>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">tar</span> -zxvf pcre-8.44.tar.gz \n<span class=\"token builtin class-name\">cd</span> pcre-8.44\n<span class=\"token function\">ls</span>\n./configure \n<span class=\"token function\">make</span>\n<span class=\"token function\">make</span> <span class=\"token function\">install</span>\nldconfig\n</code></pre>\n<p>  三个依赖库安装好之后，就可以进行nginx的安装了，这三个库对应的源码安装目录需要根据自己的电脑的库安装包的位置进行指定。</p>\n<pre><code class=\"prism language-bash\">./configure --with-openssl<span class=\"token operator\">=</span><span class=\"token punctuation\">..</span>/openssl-1.1.1g --with-pcre<span class=\"token operator\">=</span><span class=\"token punctuation\">..</span>/pcre-8.44 --with-zlib<span class=\"token operator\">=</span><span class=\"token punctuation\">..</span>/zlib-1.2.11\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e6fbe630a87e43e78e76fe7677ec4f09.png\"/></p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">make</span>\n<span class=\"token function\">make</span> <span class=\"token function\">install</span>\nldconfig\n</code></pre>\n<p>总结：</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">tar</span> -zxvf nginx-1.16.1.tar.gz \n<span class=\"token builtin class-name\">cd</span> nginx-1.16.1\n./configure --with-openssl<span class=\"token operator\">=</span><span class=\"token punctuation\">..</span>/openssl-1.1.1g --with-pcre<span class=\"token operator\">=</span><span class=\"token punctuation\">..</span>/pcre-8.44 --with-zlib<span class=\"token operator\">=</span><span class=\"token punctuation\">..</span>/zlib-1.2.11\n<span class=\"token function\">make</span>\n<span class=\"token function\">make</span> <span class=\"token function\">install</span>\nldconfig\n</code></pre>\n<p>  来看一些make install 都做了哪些操作，如下图。这里最重要的是记住<code>/usr/local/nginx</code>是nginx安装的根目录，<code>usr/local/nginx/config</code>是nginx的一些配置文件，<code>/usr/local/nginx/sbin</code>是nginx的启动目录。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c440d492f5dd449f8c1372f319180076.png\"/></p>\n<h2><a id=\"22_Nginx_187\"></a>2.2 Nginx相关的指令</h2>\n<ul><li>Nginx的默认安装目录</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># /usr/local/nginx</span>\nconf -<span class=\"token operator\">&gt;</span> 存储配置文件的目录\nhtml -<span class=\"token operator\">&gt;</span> 默认的存储网站<span class=\"token punctuation\">(</span>服务器<span class=\"token punctuation\">)</span>静态资源的目录 <span class=\"token punctuation\">[</span>图片, html, js, css<span class=\"token punctuation\">]</span>\nlogs -<span class=\"token operator\">&gt;</span> 存储log日志\nsbin -<span class=\"token operator\">&gt;</span> 启动nginx的可执行程序\n</code></pre>\n<ul><li>Nginx可执行程序的路径</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 麻烦的启动方式</span>\nroot@wxf:/<span class=\"token comment\"># cd /usr/local/nginx/sbin</span>\nroot@wxf:/usr/local/nginx/sbin<span class=\"token comment\"># pwd</span>\n/usr/local/nginx/sbin\nroot@wxf:/usr/local/nginx/sbin<span class=\"token comment\"># ./nginx </span>\n<span class=\"token comment\"># 快速启动的方式</span>\n<span class=\"token comment\"># 1. 将/usr/local/nginx/sbin/添加到环境变量PATH中</span>\n<span class=\"token comment\"># 2. /usr/local/nginx/sbin/nginx创建软连接, 放到PATH对应的路径中, 比如: /usr/bin</span>\n<span class=\"token function\">ln</span> -s /usr/local/nginx/sbin/nginx /usr/bin/nginx\nroot@wxf:/<span class=\"token comment\"># nginx </span>\n</code></pre>\n<ul><li>启动Nginx - 需要管理器权限</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 假设软连接已经创建完毕</span>\n<span class=\"token function\">sudo</span> nginx <span class=\"token comment\"># 启动</span>\n</code></pre>\n<ul><li>关闭Nginx</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 第一种, 马上关闭</span>\n<span class=\"token function\">sudo</span> nginx -s stop\n<span class=\"token comment\"># 第二种, 等nginx作为当前操作之后关闭</span>\n<span class=\"token function\">sudo</span> nginx -s quit\n</code></pre>\n<ul><li>重新加载Nginx</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">sudo</span> nginx -s reload  <span class=\"token comment\"># 修改了nginx的配置文件之后, 需要执行该命令</span>\n</code></pre>\n<ul><li>测试是否启动成功</li></ul>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 1. 命令方式</span>\n<span class=\"token function\">ps</span> -aux <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> nginx\n<span class=\"token comment\"># 2. 浏览器查看</span>\n<span class=\"token function\">curl</span> localhost\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2d06cfe980ed4b7cb9e2d94e3d4b64ad.png\"/></p>\n<h2><a id=\"23_Nginx_246\"></a>2.3 Nginx的配置</h2>\n<ol><li><strong>Nginx配置文件的位置</strong></li></ol>\n<pre><code class=\"prism language-bash\">/usr/local/nginx/conf/\n<span class=\"token comment\"># 需要我们修改的只有</span>\nnginx.conf\n\n<span class=\"token function\">vi</span> /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<p>  <br/>   </p>\n<ol start=\"2\"><li><strong>Nginx配置文件的组织格式</strong><br/>   <br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5c677f291ca641e5b08f047dceb63fd7.png\"/></li></ol>\n<ul><li>http模块-&gt;http相关的通信配置 \n  <ul><li>server模块 -&gt; <code>每个server对应的是一台web服务器</code>\n<ul><li>location 模块 \n      <ul><li>处理的是客户端的请求</li></ul> </li></ul> </li></ul> </li><li>mail模块 -&gt;处理邮件相关的动作<br/>   <br/>   <br/>   </li></ul>\n<ol start=\"3\"><li><strong>常用配置项介绍</strong></li></ol>\n<p>  注意下面的配置项，是把nginx当作一台web服务器来使用，与后续介绍的反向代理不同。</p>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># user  nobody; # 启动之后的worker进程属于谁,默认就是nobody</span>\n- 错误提示: nginx操作xxx文件时候失败, 原因: Permission denied  \n- 将nobody -<span class=\"token operator\">&gt;</span> root\n- \nworker_processes  <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># 设置worker进程的个数, 最大 == cpu的核数 (推荐)</span>\n\nerror_log  logs/error.log<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 错误日志, /usr/local/nginx目录，这里是相对路径。后面跟日志级别，不写则默认</span>\n\npid        logs/nginx.pid<span class=\"token punctuation\">;</span> <span class=\"token comment\"># pid文件, 里边是nginx的进程ID</span>\n\n<span class=\"token comment\"># nginx的事件处理</span>\nevents <span class=\"token punctuation\">{<!-- --></span>\n \tuse epoll<span class=\"token punctuation\">;</span>\t<span class=\"token comment\"># 多路IO复用使用epoll</span>\n \tworker_connections  <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\"># 每个工作的进程的最大连接数</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># http模块-&gt;http相关的通信配置</span>\nhttp<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\"># 每个server模块可以看做一台web服务器</span>\n\tserver<span class=\"token punctuation\">{<!-- --></span>\n\t\tlisten       <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\"># web服务器监听的端口, http协议的默认端口</span>\n\t    server_name  localhost<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 对应一个域名, 客户端通过该域名访问该nginx web服务器</span>\n\t    charset utf8<span class=\"token punctuation\">;</span> \t<span class=\"token comment\"># 字符串编码</span>\n\t    \n\t\t// location 模块, 处理客户端的请求\n\t    location <span class=\"token punctuation\">{<!-- --></span>指令<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{<!-- --></span>\n\t    \t<span class=\"token comment\">#...</span>\n\t\t<span class=\"token punctuation\">}</span>\t\n\t\t// location 模块, 处理客户端的请求\n\t    location <span class=\"token punctuation\">{<!-- --></span>指令<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{<!-- --></span>\n\t    \t<span class=\"token comment\">#...</span>\n\t\t<span class=\"token punctuation\">}</span>\t\n\t\t// location 模块, 处理客户端的请求\n\t    location <span class=\"token punctuation\">{<!-- --></span>指令<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{<!-- --></span>\n\t    \t<span class=\"token comment\">#...</span>\n\t\t<span class=\"token punctuation\">}</span>\t\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"24_location_318\"></a>2.4 location指令的提取</h2>\n<p>  上面的配置文件中，location后面跟的都是一个指令，这个指令是什么呢？</p>\n<p>  假设现在有一个客户端发送一个请求，<code>http://192.168.10.100:80/login.html</code> 。web服务器收到这个请求之后就需要处理客户端的请求，这个时候我们<code>将协议，ip:端口，尾部的文件名都去掉</code>。剩下的就是服务器要处理的location指令。</p>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 客户端 (浏览器), 请求:</span>\n  http://192.168.10.100:80/login.html\n<span class=\"token comment\"># 服务器处理客户端的请求</span>\n  服务器要处理的指令如何从url中提取?\n  - 去掉协议: http\n  - 去掉IP/域名+端口: <span class=\"token number\">192.168</span>.10.100:80\n  - 最后如果是文件名, 去掉该名字: login.html\n  - 剩下的: /\n  服务器要处理的location指令: \n  location /\n  <span class=\"token punctuation\">{<!-- --></span>\n        处理动作\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  上述说的是静态请求，那么动态请求呢？get带参数怎么办？其实直接把?以及?之后的全部去掉即可</p>\n<ol><li>静态请求：客户端访问服务器的静态网页, 不涉及任何数据的处理, 如下面的URL:</li></ol>\n<pre><code class=\"prism language-bash\">http://localhsot:80/login.html\n\n- 去掉协议: http://\n- 去掉IP/域名+端口: localhsot:80\n- 最后如果是文件名, 去掉该名字: login.html\n- 剩下的: /\n- 服务器要处理的location指令: \n  location /\n  <span class=\"token punctuation\">{<!-- --></span>\n        处理动作\n  <span class=\"token punctuation\">}</span>\n\nhttp://localhsot:80/hello/login.html\n\n- 去掉协议: http://\n- 去掉IP/域名+端口: localhsot:80\n- 最后如果是文件名, 去掉该名字: login.html\n- 剩下的: /hello/\n- 服务器要处理的location指令: \n  location /hello/\n  <span class=\"token punctuation\">{<!-- --></span>\n        处理动作\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<ol start=\"2\"><li>动态请求：客户端会将数据提交给服务器</li></ol>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 使用get方式提交数据得到的url</span>\nhttp://localhost/login?user<span class=\"token operator\">=</span>zhang3<span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">passwd</span><span class=\"token operator\">=</span><span class=\"token number\">123456</span><span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">age</span><span class=\"token operator\">=</span><span class=\"token number\">12</span><span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">sex</span><span class=\"token operator\">=</span>man\n\n- http: 协议\n- localhost: 域名\n- /login: 服务器端要处理的指令\n- ? <span class=\"token builtin class-name\">:</span> 连接符, 后边的内容是客户端给服务器提交的数据\n- <span class=\"token operator\">&amp;</span> <span class=\"token builtin class-name\">:</span> 分隔符\n- user/zhang3<span class=\"token punctuation\">..</span>.等：键值对，数据\n\n<span class=\"token comment\">########################</span>\n- 去掉协议\n- 去掉域名/IP\n- 去掉端口\n- 去掉末尾的文件<span class=\"token punctuation\">(</span>此处没有<span class=\"token punctuation\">)</span>\n- 去掉?和它后边的内容\n- 剩下的: /login\n- 服务器要处理的location指令: \n  location /login\n  <span class=\"token punctuation\">{<!-- --></span>\n        处理动作\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 如果看到的是请求行, 如何找处理指令?</span>\nPOST /upload/UploadAction HTTP/1.1\n\nGET /?username<span class=\"token operator\">=</span>tom<span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">phone</span><span class=\"token operator\">=</span><span class=\"token number\">123</span><span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">email</span><span class=\"token operator\">=</span>hello%40qq.com<span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">date</span><span class=\"token operator\">=</span><span class=\"token number\">2018</span>-01-01<span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">sex</span><span class=\"token operator\">=</span>male<span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">class</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token operator\">&amp;</span><span class=\"token assign-left variable\">rule</span><span class=\"token operator\">=</span>on HTTP/1.1\n\n<span class=\"token number\">1</span>. 找请求行的第二部分\n\n- 如果是post, 处理指令就是请求行的第二部分（/upload/UploadAction）\n- 服务器要处理的location指令: \n  location /upload/UploadAction\n  <span class=\"token punctuation\">{<!-- --></span>\n        处理动作\n  <span class=\"token punctuation\">}</span>\n  \n- 如果是get, 处理指令就是请求行的第二部分, ? 以前的内容（/）\n- 服务器要处理的location指令: \n  location /\n  <span class=\"token punctuation\">{<!-- --></span>\n        处理动作\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<h1><a id=\"3_Nginx_423\"></a>3. Nginx的使用</h1>\n<h2><a id=\"31__424\"></a>3.1 部署静态网页</h2>\n<p>nginx默认存放静态资源的目录是</p>\n<pre><code class=\"prism language-bash\">/usr/local/nginx/html\n</code></pre>\n<p><code>自己创建新的目录应该与这个html同级别</code>才行</p>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 应该在 /usr/local/nginx/</span>\n<span class=\"token function\">mkdir</span> /usr/local/nginx/mydir\n</code></pre>\n<p>  将源码中写好的html网页yundisk目录放到<code>/usr/local/nginx/</code>目录下。那么这个yundisk目录和html目录现在是同级的。yundisk里面存储的是静态资源。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a3f5583204e24bb4871b541b45d3f89c.png\"/></p>\n<h2><a id=\"32_httpipportloginhtml_440\"></a>3.2 访问http://ip:port/login.html</h2>\n<ul><li> <p>访问地址: <a href=\"http://192.168.109.101/login.html\">http://192.168.109.101/login.html</a></p>\n<ul><li> <p>login.html放到什么位置?</p> <pre><code class=\"prism language-shell\">location的指令是 / \n/ -<span class=\"token operator\">&gt;</span> 服务器的资源根目录, /usr/local/nginx/root/\nroot在下面location里面指定\n我们现在不使用默认的html文件夹\nlogin.htm-<span class=\"token operator\">&gt;</span> 放到yundisk中\n</code></pre> </li><li> <p>服务器要处理的动作</p> <pre><code class=\"prism language-nginx\"># root@wxf:/usr/local/nginx/conf# vi nginx.conf\n\n# 对应这个请求服务器要添加一个location\nlocation 指令(/)\n{\n    # 找一个静态网页，root需要显示指定\n    root yundisk;  # 相对于/usr/local/nginx/来找\n    # 客户端的请求如果是一个目录, nginx需要找一默认显示的网页\n    index index.html index.htm;\n}\n# 配置之后重启nginx\nsudo nginx -s reload\n</code></pre> </li><li> <p>牢记指令和root的关系</p> <pre><code class=\"prism language-shell\">文件存储的真实路径等于下面三个路径的拼接\n- 默认路径/usr/local/nginx/\n- root\n- location 指令\n 即 /usr/local/nginx/ + root<span class=\"token punctuation\">(</span>yundisk<span class=\"token punctuation\">)</span> + location 指令<span class=\"token punctuation\">(</span>/<span class=\"token punctuation\">)</span>\n -  /usr/local/nginx/yundisk/\n</code></pre> </li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4b7dbeaab7d64a028589d163a238142b.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\598b7c8bee744ec2ad3758df98f98e1f.png\"/></p>\n<h2><a id=\"33_httpipporthelloreghtml_482\"></a>3.3 访问http://ip:port/hello/reg.html</h2>\n<ul><li> <p>访问地址: <a href=\"http://192.168.109.100/hello/reg.html\">http://192.168.109.100/hello/reg.html</a></p>\n<ul><li> <p>hello是什么?</p>\n<ul><li>目录</li></ul> </li><li> <p>reg.html放到哪儿?</p>\n<ul><li>hello目录中</li></ul> </li><li> <p>如何添加location</p> <pre><code class=\"prism language-nginx\"># root@wxf:/usr/local/nginx/conf# vi nginx.conf\n\n- 根据上面的指令提取规则\n- 很容易找出指令/hello/\nlocation /hello/\n{\n    root yundisk;\n    index xx.html;\n}\n</code></pre> </li><li> <p>牢记指令和root的关系</p> <pre><code class=\"prism language-shell\">文件存储的真实路径等于下面三个路径的拼接\n- 默认路径/usr/local/nginx/\n- root\n- location 指令\n 即 /usr/local/nginx/ + root<span class=\"token punctuation\">(</span>yundisk<span class=\"token punctuation\">)</span> + location 指令<span class=\"token punctuation\">(</span>/<span class=\"token punctuation\">)</span>\n -  /usr/local/nginx/yundisk/hello/\n</code></pre> </li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\62fbfb1b15f244cdb7743127ce82dc4b.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\58191d420ebb432eb8e889e3ff441465.png\"/></p>\n<h2><a id=\"34_httpipportupload_521\"></a>3.4 访问http://ip:port/upload/</h2>\n<ul><li> <p>访问地址: <a href=\"http://192.168.109.100/upload/\">http://192.168.109.100/upload/</a></p> </li><li> <p>想要让浏览器显示upload.html</p>\n<ul><li> <p>直接访问一个目录, 得到一默认网页</p>\n<ul><li> <p>upload是一个目录, uplaod.html应该再upload目录中</p> <pre><code class=\"prism language-nginx\"># root@wxf:/usr/local/nginx/conf# vi nginx.conf\n\nlocation /upload/\n{\n    root yundisk;\n    index upload.html;\n}\n</code></pre> </li></ul> </li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3580581b89ba4b82b5ac47516424dea4.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3486292cdcd94df789d6faa25bb19e74.png\"/></p>\n<h1><a id=\"4_Nginx_548\"></a>4. Nginx作为反向代理服务器</h1>\n<h2><a id=\"41__549\"></a>4.1 准备实验环境</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8e4236adc93e4ba8a31fd303ea5f8891.png\"/></p>\n<blockquote>\n<ol><li>需要客户端 - 1个 \n   <ul><li>Window中的浏览器作为客户端</li></ul> </li><li>反向代理服务器 -&gt; 1个 \n   <ul><li>ubuntu192.168.109.101作为反向代理服务器</li></ul> </li><li>web服务器 -&gt; 2个 \n   <ul><li>ubuntu192.168.109.102 - 默认主页修改为gopherwxf</li><li>ubuntu192.168.109.103 - 默认主页修改为wuxufei</li></ul> </li><li>因为反向代理没有绑定域名，所以修改windows的hosts文件，自己加域名 \n   <ul><li>192.168.109.101 ubuntu101to102.com</li><li>192.168.109.101 ubuntu101to103.com</li></ul> </li></ol>\n</blockquote>\n<h2><a id=\"42__564\"></a>4.2 反向代理设置</h2>\n<pre><code class=\"prism language-bash\">找101机器上上对应的nginx的配置文件\n- <span class=\"token function\">vi</span> /usr/local/nginx/conf/nginx.conf\n\n\t<span class=\"token comment\"># 代理几台服务器就需要几个server模块</span>\n    <span class=\"token comment\"># 客户端访问的url: http://192.168.109.100/login.html</span>\n    server <span class=\"token punctuation\">{<!-- --></span>\n        listen       <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\"># 客户端访问反向代理服务器, 代理服务器监听的端口</span>\n        server_name  ubuntu101to102.com<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 客户端访问反向代理服务器, 需要一个域名</span>\n        location / <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\"># 反向代理服务器转发location指令(/), http:// 固定</span>\n            proxy_pass http://reverse.proxy1.com<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\"># 添加一个代理模块</span>\n    upstream reverse.proxy1.com\n    <span class=\"token punctuation\">{<!-- --></span>\n        server <span class=\"token number\">192.168</span>.109.102:80<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\"># 103</span>\n    server <span class=\"token punctuation\">{<!-- --></span>\n        listen       <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\"># 客户端访问反向代理服务器, 代理服务器监听的端口</span>\n        <span class=\"token comment\"># 因为没有配置负载均衡，所以需要不同的域名</span>\n        <span class=\"token comment\"># 来手动指定转发给哪台服务器</span>\n        server_name  ubuntu101to103.com<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 客户端访问反向代理服务器, 需要一个域名</span>\n        location / <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\"># 反向代理服务器转发指令, http:// 固定</span>\n            proxy_pass http://reverse.proxy2.com<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\"># 添加一个代理模块</span>\n    upstream reverse.proxy2.com\n    <span class=\"token punctuation\">{<!-- --></span>\n        server <span class=\"token number\">192.168</span>.109.103:80<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"43__606\"></a>4.3 反向代理总结与测试</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\76e75a0269f0463eacf9fa50495f1608.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4f6e66f9ce7246d580bfcc9ac4d0b05c.png\"/></p>\n<h1><a id=\"5_Nginx_612\"></a>5. Nginx实现负载均衡</h1>\n<h2><a id=\"51__613\"></a>5.1 分析反向代理的缺陷</h2>\n<p>  反向代理虽然能代理到不同的web服务器上，但是server_name必须要不同。那有100台呢？要取100个名字吗？而且如果这100台服务器干的都是相同的内容，这么这个server_name就是冗余了。</p>\n<p>  负载均衡就是实现入口资源的平均分配，那么这个入口地址server_name就应该是一样的了，而不是一个web服务器对应一个地址，这样是指定了。100台服务器都用同一个server_name，至于最终转发到哪台服务器，交给负载均衡来处理，用户不去关心。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\002b5824052e49948962d7be17f3ca6e.png\"/></p>\n<p>  负载均衡就直接把server_name换成一个唯一的域名即可（相同服务的web服务器用同一个域名，如果有别的服务器处理别的业务，则它们共用另一个)。</p>\n<p>  不止server_name是冗余的，proxy_pass也是冗余的，再观察，其实server也是冗余的。我们只需要在upstream里面把web服务器的ip加上去就行了，不需要额外再写server模块。</p>\n<h2><a id=\"52__626\"></a>5.2 负载均衡设置</h2>\n<pre><code class=\"prism language-bash\">    server <span class=\"token punctuation\">{<!-- --></span>\n        listen       <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\"># 客户端访问反向代理服务器, 代理服务器监听的端口</span>\n        server_name  reverse.proxy.com<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 客户端访问反向代理服务器, 需要一个域名</span>\n        location / <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\"># 反向代理服务器转发指令, http:// 固定的头</span>\n            proxy_pass http://linux.com<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        location /hello/ <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\"># 反向代理服务器转发指令, http:// 固定的头</span>\n            proxy_pass http://linux.com<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    \tlocation /upload/ <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\"># 反向代理服务器转发指令, http:// 固定的头</span>\n            proxy_pass http://linux.com<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\"># 添加一个代理模块</span>\n    upstream linux.com\n    <span class=\"token punctuation\">{<!-- --></span>\t<span class=\"token comment\"># 可以配置权重</span>\n    \t<span class=\"token comment\"># 1/4 概率 走102</span>\n    \t<span class=\"token comment\"># 3/4 概率 走103</span>\n        <span class=\"token comment\">#server 192.168.109.102:80 weight=1;</span>\n        <span class=\"token comment\">#server 192.168.109.103:80 weight=3;</span>\n        server <span class=\"token number\">192.168</span>.109.102:80<span class=\"token punctuation\">;</span>\n        server <span class=\"token number\">192.168</span>.109.103:80<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">## =====================================</span>\nweb服务器需要做什么?\n<span class=\"token comment\"># 192.168.109.102</span>\nlocation /\n<span class=\"token punctuation\">{<!-- --></span>\n    root xxx<span class=\"token punctuation\">;</span>\n    index xxx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># 如果反向代理配置了location /hello/ </span>\n<span class=\"token comment\"># 那么web服务器就需要写</span>\nlocation /hello/ \n<span class=\"token punctuation\">{<!-- --></span>\n    root xx<span class=\"token punctuation\">;</span>\n    index xxx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># 如果反向代理配置了location /upload/ </span>\n<span class=\"token comment\"># 那么web服务器就需要写</span>\nlocation /upload/ \n<span class=\"token punctuation\">{<!-- --></span>\n    root xxx<span class=\"token punctuation\">;</span>\n    index xx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># 192.168.109.103</span>\nlocation /\n<span class=\"token punctuation\">{<!-- --></span>\n    root xxx<span class=\"token punctuation\">;</span>\n    index xxx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># 如果反向代理配置了location /hello/ </span>\n<span class=\"token comment\"># 那么web服务器就需要写</span>\nlocation /hello/ \n<span class=\"token punctuation\">{<!-- --></span>\n    root xx<span class=\"token punctuation\">;</span>\n    index xxx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\"># 如果反向代理配置了location /upload/ </span>\n<span class=\"token comment\"># 那么web服务器就需要写</span>\nlocation /upload/ \n<span class=\"token punctuation\">{<!-- --></span>\n    root xxx<span class=\"token punctuation\">;</span>\n    index xx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"53__703\"></a>5.3 负载均衡总结与测试</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\454c25405b47405bb463a6d73ce42e2f.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4eb00ae2f0d044e984a235fc6b46313b.png\"/></p>\n<h1><a id=\"6__714\"></a>6. 需要了解的知识</h1>\n<h2><a id=\"61_IP_715\"></a>6.1 IP和域名的关系</h2>\n<ol><li>什么是域名？</li></ol>\n<pre><code class=\"prism language-bash\">www.baidu.com\nwww.jd.com\nwww.taobao.com\n</code></pre>\n<ol start=\"2\"><li>什么是IP地址？</li></ol>\n<pre><code class=\"prism language-bash\">点分十进制的字符串\n例如：\n<span class=\"token number\">192.168</span>.109.101\n<span class=\"token number\">192.168</span>.109.102\n<span class=\"token number\">192.168</span>.109.103\n</code></pre>\n<ol start=\"3\"><li>域名和IP地址的关系？</li></ol>\n<pre><code class=\"prism language-bash\">域名绑定IP\n一个域名只能绑定一个IP\n一个IP地址被多个域名绑定\n</code></pre>\n<h2><a id=\"62_URLURI_744\"></a>6.2 URL和URI</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f93706e8a8be4451bdd00ccc9fcd1404.png\"/></p>\n<ol><li> <p>概念:</p>\n<blockquote>\n<ul><li> <p>URL（Uniform Resource Locator）: 统一资源定位符</p> </li><li> <p>表示资源位置的字符串</p>\n<ul><li>基本格式: “<mark>协议://IP地址/路径和文件名</mark>” \n       <ul><li><a href=\"ftp://ftp.is.co.za/rfc/rfc1808.txt\">ftp://ftp.is.co.za/rfc/rfc1808.txt</a></li><li><a href=\"http://www.ietf.org/rfc/rfc2396.txt\">http://www.ietf.org/rfc/rfc2396.txt</a></li><li>telnet://192.0.2.16:80/</li></ul> </li></ul> </li><li> <p>URN（Uniform Resource Name）: 统一资源名称</p>\n<ul><li>P2P下载中使用的磁力链接</li></ul> </li><li> <p>URI（Uniform Resource Identifier）: 统一资源标识符</p>\n<ul><li>是一个紧凑的字符串用来标示抽象或物理资源, <mark><strong>URL是URI的一种</strong></mark></li><li>URI可以没有协议, 没有地址(IP/域名)</li><li>让URI能成为URL就必须拥有”协议“，”ip or 域名“，e.g. <code>http://</code> or <code>ftp://</code>。 \n       <ul><li>files.hp.com</li><li>tel:+1-816-555-1212</li><li><a href=\"ftp://ftp.is.co.za/rfc/rfc1808.txt\">ftp://ftp.is.co.za/rfc/rfc1808.txt</a> （also a URL）</li><li><a href=\"http://www.ietf.org/rfc/rfc2396.txt\">http://www.ietf.org/rfc/rfc2396.txt</a> （also a URL）</li><li>telnet://192.0.2.16:80/ （also a URL）</li></ul> </li></ul> </li></ul>\n</blockquote> </li></ol>\n<h2><a id=\"63_DNS_774\"></a>6.3 DNS解析过程</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dd8d383b3a5b406eacff11990a277965.png\"/></p>\n<ol><li> <p>DNS解析的过程</p>\n<blockquote>\n<ol><li>在浏览器中输入www.magedu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 \n     <ul><li>Windows和Linux系统都会在本地缓存dns解析的记录，提高速度。</li></ul> </li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找<code>TCP/IP</code>参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（没有设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责 .com域的这台服务器。这台负责 .com域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com域的下一级DNS服务器地址(magedu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找magedu.com域服务器，重复上面的动作进行查询，直至找到www.magedu.com主机。</li><li>如果用的是转发模式（设置转发器），此DNS服务器就会把请求转发至上一级ISP DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</li></ol>\n</blockquote> </li><li> <p>域名解析服务器</p>\n<blockquote>\n<ul><li> <p>Pod DNS+:</p>\n<ul><li>首选：119.29.29.29</li><li>备选：182.254.116.116</li></ul> </li><li> <p>114DNS:</p>\n<ul><li>首选：114.114.114.114</li><li>备选：114.114.114.115</li></ul> </li><li> <p>阿里 AliDNS:</p>\n<ul><li> <p>首选：223.5.5.5</p> </li><li> <p>备选：223.6.6.6</p> </li></ul> </li></ul>\n</blockquote> </li><li> <p>hosts文件</p> <pre><code class=\"prism language-shell\"><span class=\"token comment\"># 存储的是域名和IP的对应关系</span>\n-windows目录: <span class=\"token string\">\"C:\\Windows\\System32\\drivers<span class=\"token entity\" title=\"\\e\">\\e</span>tc\\hosts\"</span>\n</code></pre> </li></ol>\n<h2><a id=\"64_http_812\"></a>6.4 http协议报文分析</h2>\n<ol><li> <p><code>请求消息(Request)</code> - 客户端(浏览器)发送给服务器的数据格式</p>\n<blockquote>\n<p>四部分: <code>请求行, 请求头, 空行, 请求数据 </code></p>\n<ul><li><code>请求行</code>: 说明请求类型, 要访问的资源, 以及使用的http版本</li><li><code>请求头</code>: 说明服务器要使用的附加信息</li><li><code>空行</code>: 空行是必须要有的, 即使没有请求数据</li><li><code>请求数据</code>: 也叫主体, 可以添加任意的其他数据</li></ul>\n</blockquote>\n<ul><li> <p>Get方式提交数据</p>\n<blockquote>\n<p>第一行: 请求行</p>\n<p>第2-9行: 请求头(键值对)</p>\n<p>第10行: 空行</p>\n<p>get方式提交数据, 没有第四部分, 提交的数据在请求行的第二部分, 提交的数据会全部显示在地址栏中</p>\n</blockquote> <pre><code class=\"prism language-http\">GET /?username=tom&amp;phone=123&amp;email=hello%40qq.com&amp;date=2018-01-01&amp;sex=male&amp;class=3&amp;rule=on HTTP/1.1\nHost: 192.168.26.52:6789\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate\nAccept-Language: zh,zh-CN;q=0.9,en;q=0.8\n\n</code></pre> </li><li> <p>Post方式提交数据</p>\n<blockquote>\n<p>第一行: 请求行</p>\n<p>第2 -12行: 请求头 (键值对)</p>\n<p>第13行: 空行</p>\n<p>第14行: 提交的数据</p>\n</blockquote> <pre><code class=\"prism language-http\">POST / HTTP/1.1\nHost: 192.168.26.52:6789\nConnection: keep-alive\nContent-Length: 84\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: null\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate\nAccept-Language: zh,zh-CN;q=0.9,en;q=0.8\n\nusername=tom&amp;phone=123&amp;email=hello%40qq.com&amp;date=2018-01-01&amp;sex=male&amp;class=3&amp;rule=on\n</code></pre> </li></ul> </li><li> <p><code>响应消息(Response)</code> -&gt; 服务器给客户端发送的数据</p>\n<blockquote>\n<ul><li>四部分: <code>状态行, 消息报头, 空行, 响应正文</code>\n<ul><li><code>状态行</code>: 包括http协议版本号, 状态码, 状态信息</li><li><code>消息报头</code>: 说明客户端要使用的一些附加信息</li><li><code>空行</code>: 空行是必须要有的</li><li><code>响应正文</code>: 服务器返回给客户端的文本信息</li></ul> </li></ul>\n<p>第一行:状态行</p>\n<p>第2 -11行: 响应头(消息报头)</p>\n<p>第12行: 空行</p>\n<p>第13-18行: 服务器给客户端回复的数据</p>\n</blockquote> <pre><code class=\"prism language-http\">HTTP/1.1 200 Ok\nServer: micro_httpd\nDate: Fri, 18 Jul 2014 14:34:26 GMT\n/* 告诉浏览器发送的数据是什么类型 */\nContent-Type: text/plain; charset=iso-8859-1 (必选项)\n/* 发送的数据的长度 */\nContent-Length: 32  \nLocation:url\nContent-Language: zh-CN\nLast-Modified: Fri, 18 Jul 2014 08:36:36 GMT\nConnection: close\n\n#include &lt;stdio.h&gt;\nint main(void)\n{\n    printf(\"hello world!\\n\");\n    return 0;\n}\n</code></pre> </li><li> <p>http状态码</p>\n<blockquote>\n<p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>\n<ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul>\n</blockquote> </li></ol>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-07 10:27:34", "summary": "文件服务器项目前言一些基本概念初步认识正向代理概念理解反向代理概念理解的安装与配置与相关依赖库的安装相关的指令的配置指令的提取的使用部署静态网页访问访问访问作为反向代理服务器准备实验环境反向代理设置反"}