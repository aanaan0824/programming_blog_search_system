{"blogid": "125371841", "writerAge": "码龄5年", "writerBlogNum": "299", "writerCollect": "35", "writerComment": "8", "writerFan": "15", "writerGrade": "5级", "writerIntegral": "3105", "writerName": "重庆熊猫", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125371841.jpg", "writerRankTotal": "7622", "writerRankWeekly": "7890", "writerThumb": "5", "writerVisitNum": "29068", "blog_read_count": "758", "blog_time": "于 2022-04-16 16:27:00 发布", "blog_title": "C#取消正在运行的Task", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\" style=\"font-size: 16px;\">\n<blockquote>\n<p>更新记录<br/> 本文迁移自Panda666原博客，原发布时间：2021年6月29日。</p>\n</blockquote>\n<h3 id=\"一说明\">一、说明</h3>\n<p>Task默认就依托于底层线程池中的线程，使用.NET为我们定义好的CancellationTokenSource类型就可以实现任务的取消。这是标准规范的任务取消操作。</p>\n<h3 id=\"二非标准不推荐任务取消操作\">二、非标准不推荐任务取消操作</h3>\n<p>除了.NET标准的任务取消操作，我们也可以直接进行对任务底层的线程进行中断，但这是非常不推荐的方式。注意：野蛮的中止线程不是一个好选择！！！</p>\n<p>比如：</p>\n<pre class=\"has\"><code class=\"language-c#\">using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Panda666comTest\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //新建线程引用\n            Thread thread = null;\n\n            //新建任务\n            Task t = Task.Run(() =&gt;\n            {\n                //获得当前任务底层的线程的引用\n                thread = Thread.CurrentThread;\n\n                //任务开始\n                Console.WriteLine(\"Task start!\");\n\n                //模拟耗时的操作\n                Thread.Sleep(1000);\n\n                //任务结束\n                Console.WriteLine(\"Task finished!\");\n            });\n\n            //让任务先运行起来\n            Thread.Sleep(10);\n\n            //强行终止任务\n            thread.Abort();\n\n            //wait\n            Console.WriteLine(\"Success\");\n            Console.ReadKey();\n        }\n    }\n}</code></pre>\n<p>注意：线程对象Abort的方法已经在最新的.NET Core中不被支持！！！</p>\n<h3 id=\"三标准的任务取消操作\">三、标准的任务取消操作</h3>\n<p>具体流程如下：<br/> 新建CancellationTokenSource对象用于辅助任务取消</p>\n<pre class=\"has\"><code class=\"language-c#\">CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();</code></pre>\n<p>CancellationTokenSource类型所在命名空间</p>\n<pre class=\"has\"><code class=\"language-c#\">using System.Treading;</code></pre>\n<p>在具体的任务执行中监视CancellationTokenSource对象的成员，Token的IsCancellationRequested属性来确定是否需要取消任务，通过任务定期轮询它，检查是否发出了取消请求</p>\n<pre class=\"has\"><code class=\"language-c#\">token.IsCancellationRequested</code></pre>\n<p>如果调用.Cancel()发出了取消任务请求，任务立即返回，停止继续任务</p>\n<pre class=\"has\"><code class=\"language-c#\">CancellationTokenSource cansrc = new CancellationTokenSource();\ncansrc.Cancel();</code></pre>\n<p>那我们来把上面那个野蛮终止Task的例子修改一下</p>\n<pre class=\"has\"><code class=\"language-c#\">using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Panda666comTest\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            CancellationTokenSource tokenSource = new CancellationTokenSource();\n            CancellationToken cancellationToken = tokenSource.Token;\n\n            //新建任务\n            Task t = Task.Run(() =&gt;\n            {\n                while(true)\n                {\n                    //检测任务是否已经被取消\n                    if(tokenSource.IsCancellationRequested)\n                    {\n                        Console.WriteLine(\"Task canceled\");\n                        break;\n                    }\n\n                    //任务开始\n                    Console.WriteLine(\"Task start!\");\n\n                    //模拟耗时的操作\n                    Thread.Sleep(1000);\n\n                    //任务结束\n                    Console.WriteLine(\"Task finished!\");\n                }\n            }, cancellationToken);\n\n\n            Thread.Sleep(10);\n\n            //用户控制是否取消任务\n            while(true)\n            {\n                Console.Write(\"请切换到英文输入法\");\n                Console.WriteLine(\"取消任务请按Y\");\n                if((Console.ReadKey()).Key == ConsoleKey.Y)\n                {\n                    //任务取消\n                    tokenSource.Cancel();\n                }\n            }\n        }\n    }\n}</code></pre>\n</div>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-16 16:27:00", "summary": "更新记录本文迁移自原博客，原发布时间：年月日。一说明一、说明默认就依托于底层线程池中的线程，使用为我们定义好的类型就可以实现任务的取消。这是标准规范的任务取消操作。二非标准不推荐任务取消操作二、非标准"}