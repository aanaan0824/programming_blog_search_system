{"blogid": "126133110", "writerAge": "码龄2年", "writerBlogNum": "72", "writerCollect": "143", "writerComment": "43", "writerFan": "206", "writerGrade": "4级", "writerIntegral": "840", "writerName": "青柠果", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126133110.jpg", "writerRankTotal": "21312", "writerRankWeekly": "4874", "writerThumb": "73", "writerVisitNum": "27565", "blog_read_count": "6282", "blog_time": "于 2022-08-03 20:13:52 发布", "blog_title": "redis的使用场景", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98\">1.作为缓存</a></p>\n<p id=\"1.1%20%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%20%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8\">1.1 为何使用</a></p>\n<p id=\"1.2%20%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%82%E5%90%88%E6%94%BE%E5%85%A5%E7%BC%93%E5%AD%98-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%20%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%82%E5%90%88%E6%94%BE%E5%85%A5%E7%BC%93%E5%AD%98\">1.2 什么样的数据适合放入缓存</a></p>\n<p id=\"1.3%20%E4%BD%BF%E7%94%A8redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%20%E4%BD%BF%E7%94%A8redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98\">1.3 使用redis作为缓存</a></p>\n<p id=\"1.3.1%20%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#1.3.1%20%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB\">1.3.1 未使用配置类</a></p>\n<p id=\"1.3.2%20%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#1.3.2%20%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB\">1.3.2 使用配置类</a></p>\n<p id=\"2.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">2.分布式锁</a></p>\n<p id=\"2.1%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8\">2.1 压测工具的使用</a></p>\n<p id=\"%C2%A02.2%20%E5%BA%93%E5%AD%98%E9%A1%B9%E7%9B%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.2%20%E5%BA%93%E5%AD%98%E9%A1%B9%E7%9B%AE\">2.2 库存项目</a></p>\n<p id=\"2.2.1%20controller%E5%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.1%20controller%E5%B1%82\">2.2.1 controller层</a></p>\n<p id=\"2.2.2%20dao%E5%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.2%20dao%E5%B1%82\">2.2.2 dao层</a></p>\n<p id=\"2.2.3%C2%A0%20entity%E5%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.3%C2%A0%20entity%E5%B1%82\">2.2.3 entity层</a></p>\n<p id=\"2.2.4%20service%E5%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.4%20service%E5%B1%82\">2.2.4 service层</a></p>\n<p id=\"2.2.5%C2%A0%20mapper-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.5%C2%A0%20mapper\">2.2.5 mapper</a></p>\n<p id=\"2.2.6%20%E4%BE%9D%E8%B5%96-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.6%20%E4%BE%9D%E8%B5%96\">2.2.6 依赖</a></p>\n<p id=\"2.2.7%20%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.7%20%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C\">2.2.7 测试结果</a></p>\n<p id=\"2.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc\" style=\"margin-left:40px;\"><a href=\"#2.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">2.3 解决方案</a></p>\n<p id=\"2.3.1%20%E4%BD%BF%E7%94%A8%20synchronized%20%E6%88%96%E8%80%85lock%E9%94%81%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.1%20%E4%BD%BF%E7%94%A8%20synchronized%20%E6%88%96%E8%80%85lock%E9%94%81%C2%A0\">2.3.1 使用 synchronized 或者lock锁 </a></p>\n<p id=\"2.3.2%20%E4%BD%BF%E7%94%A8redisTemplate-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.2%20%E4%BD%BF%E7%94%A8redisTemplate\">2.3.2 使用redisTemplate</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1>1.作为缓存</h1>\n<h2 id=\"1.1%20%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8\">1.1 为何使用</h2>\n<p>        数据存储在内存中，数据查询速度快。可以分摊数据库压力。</p>\n<p><img alt=\"\" height=\"359\" src=\"..\\..\\static\\image\\5ef5efc4b88e427b9704a9c5b4e27bd3.png\" width=\"1150\"/></p>\n<h2 id=\"1.2%20%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%82%E5%90%88%E6%94%BE%E5%85%A5%E7%BC%93%E5%AD%98\">1.2 什么样的数据适合放入缓存</h2>\n<p>        查询频率比较高，修改频率比较低。</p>\n<p>        安全系数低的数据</p>\n<h2 id=\"1.3%20%E4%BD%BF%E7%94%A8redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98\">1.3 使用redis作为缓存</h2>\n<h3 id=\"1.3.1%20%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB\">1.3.1 未使用配置类</h3>\n<p>注意要将实体类实现序列化：</p>\n<pre><code class=\"language-java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@TableName(value = \"tb_dept\")\npublic class Dept implements Serializable {\n    @TableId(value = \"id\",type = IdType.AUTO)\n    private Integer id;\n\n    private String name;\n\n    private String realname;\n}\n</code></pre>\n<p>对应依赖：</p>\n<pre><code class=\"language-XML\"> &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--连接数据源--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--mp的依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.2&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;</code></pre>\n<p>controller层对应代码：</p>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"order\")\npublic class DeptController {\n    @Resource\n    private DeptService deptService;\n\n    @GetMapping(\"getById/{id}\")\n    //order/getById/1\n    //{}可以放多个，由下面的传参函数对应\n    //@PathVariable:获取请求映射中{}的值\n    public Dept getById(@PathVariable Integer id){\n        return deptService.findById(id);\n    }\n\n    @GetMapping(\"deleteById/{id}\")\n    public String deleteById(@PathVariable Integer id){\n        int i = deptService.deleteById(id);\n        return i&gt;0?\"删除成功\":\"删除失败\";\n    }\n\n    @GetMapping(\"insert\")\n    public Dept insert(Dept dept){\n        Dept insert = deptService.insert(dept);\n        return insert;\n    }\n\n    @GetMapping(\"update\")\n    public Dept update(Dept dept){\n        Dept update = deptService.update(dept);\n        return update;\n    }\n}</code></pre>\n<p>service层对应代码：</p>\n<pre><code class=\"language-java\">@Service\npublic class DeptService {\n    @Resource\n    private DeptMapper deptMapper;\n    //当存储的value类型为对象类型使用redisTemplate\n    //存储的value类型为字符串。StringRedisTemplate\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    //业务代码\n    public Dept findById(Integer id){\n        ValueOperations forValue = redisTemplate.opsForValue();\n        //查询缓存\n        Object o = forValue.get(\"dept::\" + id);\n        //缓存命中\n        if(o!=null){\n            return (Dept) o;\n        }\n        Dept dept = deptMapper.selectById(id);\n        if(dept!=null){\n            //存入缓存中\n            forValue.set(\"dept::\"+id,dept,24, TimeUnit.HOURS);\n        }\n        return dept;\n    }\n\n    public int deleteById(Integer id){\n        redisTemplate.delete(\"dept::\"+id);\n        int i = deptMapper.deleteById(id);\n        return i;\n    }\n\n    public Dept insert(Dept dept){\n        int insert = deptMapper.insert(dept);\n        return dept;\n    }\n\n    public Dept update(Dept dept){\n        redisTemplate.delete(\"dept::\"+dept.getId());\n        int i = deptMapper.updateById(dept);\n        return dept;\n    }\n}</code></pre>\n<p>配置源：</p>\n<pre><code class=\"language-XML\"># 配置数据源\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb?serverTimezone=Asia/Shanghai\nspring.datasource.username=root\nspring.datasource.password=root\n\n#sql日志\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n\n#连接redis\nspring.redis.host=192.168.22*.1**\nspring.redis.port=6379</code></pre>\n<p>查看的缓存: 前部分代码相同@before通知，后部分代码也相同后置通知。 我们可以AOP完成缓存代码和业务代码分离。</p>\n<p>spring框架它应该也能想到。--使用注解即可完成。解析该注解。</p>\n<h3 id=\"1.3.2%20%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB\">1.3.2 使用配置类</h3>\n<p>（1）把缓存的配置类加入</p>\n<pre><code class=\"language-java\">    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        //解决查询缓存转换异常的问题\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置序列化（解决乱码的问题）,过期时间600秒\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(600)) //缓存过期10分钟 ---- 业务需求。\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))//设置key的序列化方式\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) //设置value的序列化\n                .disableCachingNullValues();\n        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n        return cacheManager;\n    }\n</code></pre>\n<p>(2) 使用开启缓存注解</p>\n<p><img alt=\"\" height=\"259\" src=\"..\\..\\static\\image\\82c9e513cf1e44eeaeee58ed5d100cb9.png\" width=\"1200\"/>（3）使用注解  </p>\n<pre><code class=\"language-java\">//业务代码\n    //使用查询注解:cacheNames表示缓存的名称 key:唯一标志---dept::key\n    //先从缓存中查看key为（cacheNames::key）是否存在，如果存在则不会执行方法体，如果不存在则执行方法体并把方法的返回值存入缓存中\n    @Cacheable(cacheNames = {\"dept\"},key=\"#id\")\n    public Dept findById(Integer id){\n        Dept dept = deptMapper.selectById(id);\n        return dept;\n    }\n//先删除缓存在执行方法体。\n    @CacheEvict(cacheNames = {\"dept\"},key = \"#id\")\n    public int deleteById(Integer id){\n        int row = deptMapper.deleteById(id);\n        return row;\n    }\n\n    //这个注释可以确保方法被执行，同时方法的返回值也被记录到缓存中，实现缓存与数据库的同步更新。\n    @CachePut(cacheNames = \"dept\",key=\"#dept.id\")\n    public Dept update(Dept dept){\n        int insert = deptMapper.updateById(dept);\n        return dept;\n    }\n</code></pre>\n<h1 id=\"2.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">2.分布式锁</h1>\n<p>使用压测工具测试高并发下带来线程安全问题</p>\n<h2 id=\"2.1%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8\">2.1 压测工具的使用</h2>\n<p><img alt=\"\" height=\"333\" src=\"..\\..\\static\\image\\655b220de2c745eaa61cecbffc42376c.png\" width=\"868\"/></p>\n<p> <img alt=\"\" height=\"79\" src=\"..\\..\\static\\image\\40c5b3392fc84ac7a7badf9171de88f5.png\" width=\"310\"/><img alt=\"\" height=\"70\" src=\"..\\..\\static\\image\\c2b9a1d0f32c4a7e8b5eb8ffd545534b.png\" width=\"345\"/></p>\n<p class=\"img-center\"><img alt=\"\" height=\"113\" src=\"..\\..\\static\\image\\d1c5b5d171a548ea9e2a59203fd683aa.png\" width=\"282\"/></p>\n<p>内部配置：</p>\n<p> <img alt=\"\" height=\"235\" src=\"..\\..\\static\\image\\8d72a026d04141b48c0b451f4c97dbab.png\" width=\"452\"/><img alt=\"\" height=\"431\" src=\"..\\..\\static\\image\\a26adda4beb24597bf8bfdb1ea68f66a.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"425\" src=\"..\\..\\static\\image\\7a111c8df8cf495289530f7213b6a823.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A02.2%20%E5%BA%93%E5%AD%98%E9%A1%B9%E7%9B%AE\"> 2.2 库存项目</h2>\n<h3 id=\"2.2.1%20controller%E5%B1%82\">2.2.1 controller层</h3>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"bucket\")\npublic class BucketController {\n    @Autowired\n    private BucketService bucketService;\n\n    @GetMapping(\"update/{productId}\")\n    public String  testUpdate(@PathVariable Integer productId){\n        String s = bucketService.updateById(productId);\n        return s;\n    }\n}</code></pre>\n<h3 id=\"2.2.2%20dao%E5%B1%82\">2.2.2 dao层</h3>\n<pre><code class=\"language-java\">//此处写就不需要在启动类使用注解\n@Mapper\npublic interface BucketMapper extends BaseMapper&lt;Bucket&gt; {\n    public Integer updateBucketById(Integer productId);\n}\n</code></pre>\n<h3 id=\"2.2.3%C2%A0%20entity%E5%B1%82\">2.2.3  entity层</h3>\n<pre><code class=\"language-java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Bucket {\n    @TableId(value = \"productId\",type = IdType.AUTO)\n    private Integer productId;\n\n    private Integer num;\n}</code></pre>\n<h3 id=\"2.2.4%20service%E5%B1%82\">2.2.4 service层</h3>\n<pre><code class=\"language-java\">@Service\npublic class BucketService {\n    @Resource\n    private BucketMapper bucketMapper;\n\n    public String updateById(Integer productId){\n        //查看该商品的库存数量\n        Bucket bucket = bucketMapper.selectById(productId);\n        if(bucket.getNum()&gt;0){\n            //修改库存每次减1\n            Integer integer = bucketMapper.updateBucketById(productId);\n            System.out.println(\"扣减成功！剩余库存数：\"+(bucket.getNum()-1));\n            return \"success\";\n        }else {\n            System.out.println(\"扣减失败！库存数不足\");\n            return \"fail\";\n        }\n    }\n}</code></pre>\n<h3 id=\"2.2.5%C2%A0%20mapper\">2.2.5  mapper</h3>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.qy151wd.dao.BucketMapper\"&gt;\n    &lt;update id=\"updateBucketById\" parameterType=\"int\"&gt;\n        update bucket set num=num-1 where productId=#{productId}\n    &lt;/update&gt;\n&lt;/mapper&gt;</code></pre>\n<h3 id=\"2.2.6%20%E4%BE%9D%E8%B5%96\">2.2.6 依赖</h3>\n<pre><code class=\"language-XML\">    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--连接数据源--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--mp的依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.2&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;</code></pre>\n<h3 id=\"2.2.7%20%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C\">2.2.7 测试结果</h3>\n<p><img alt=\"\" height=\"219\" src=\"..\\..\\static\\image\\1ba2ca37290e4a92a87d217752b180b9.png\" width=\"1183\"/>我们看到同一个库存被使用了n次。以及数据库中库存为负数。 线程安全问题导致。</p>\n<h2 id=\"2.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">2.3 解决方案</h2>\n<h3 id=\"2.3.1%20%E4%BD%BF%E7%94%A8%20synchronized%20%E6%88%96%E8%80%85lock%E9%94%81%C2%A0\">2.3.1 使用 synchronized 或者lock锁 </h3>\n<p> 对应的service层修改为</p>\n<pre><code class=\"language-java\">@Service\npublic class BucketService {\n    @Resource\n    private BucketMapper bucketMapper;\n\n    public String updateById(Integer productId){\n        //加自动锁\n        synchronized (this){\n            //查看该商品的库存数量\n            Bucket bucket = bucketMapper.selectById(productId);\n            if(bucket.getNum()&gt;0){\n                //修改库存每次减1\n                Integer integer = bucketMapper.updateBucketById(productId);\n                System.out.println(\"扣减成功！剩余库存数：\"+(bucket.getNum()-1));\n                return \"success\";\n            }else {\n                System.out.println(\"扣减失败！库存数不足\");\n                return \"fail\";\n            }\n        }\n    }\n}</code></pre>\n<p>如果搭建了项目集群，那么该锁无效 。</p>\n<p><img alt=\"\" height=\"450\" src=\"..\\..\\static\\image\\e77ca6664ec34e3cbca5ab537f1ff1bc.png\" width=\"1200\"/></p>\n<h3 id=\"2.3.2%20%E4%BD%BF%E7%94%A8redisTemplate\">2.3.2 使用redisTemplate</h3>\n<p>（1）使用idea开集群项目</p>\n<p><img alt=\"\" height=\"556\" src=\"..\\..\\static\\image\\287689bb8cd246afa68ef8a01ce2fb93.png\" width=\"1200\"/></p>\n<p> （2）使用nginx</p>\n<p class=\"img-center\"><img alt=\"\" height=\"412\" src=\"..\\..\\static\\image\\595a138f68564b20bf3762f3fb2e90cb.png\" width=\"498\"/></p>\n<p> （3）测试结果</p>\n<p><img alt=\"\" height=\"436\" src=\"..\\..\\static\\image\\c99461b8dfd04ecc933292d1a0fad262.png\" width=\"1186\"/></p>\n<p>发现又出现: 重复数字以及库存为负数。</p>\n<p>（4）解决方法</p>\n<p><img alt=\"\" height=\"259\" src=\"..\\..\\static\\image\\c331a662568d4e35b15af8f8ff9ce3d6.png\" width=\"625\"/></p>\n<p>service对应代码修改</p>\n<pre><code class=\"language-java\">@Service\npublic class BucketService {\n    @Resource\n    private BucketMapper bucketMapper;\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    public String updateById(Integer productId){\n        ValueOperations&lt;String,String&gt; forValue = redisTemplate.opsForValue();\n        Boolean flag = forValue.setIfAbsent(\"aaa::\" + productId, \"-----------------\");\n        if(flag){\n            try{\n                //查看该商品的库存数量\n                Bucket bucket = bucketMapper.selectById(productId);\n                if(bucket.getNum()&gt;0){\n                    //修改库存每次减1\n                    Integer integer = bucketMapper.updateBucketById(productId);\n                    System.out.println(\"扣减成功！剩余库存数：\"+(bucket.getNum()-1));\n                    return \"success\";\n                }else {\n                    System.out.println(\"扣减失败！库存数不足\");\n                    return \"fail\";\n                }\n            }finally {\n                redisTemplate.delete(\"aaa::\"+productId);\n            }\n        }\n    return \"服务器正忙，请稍后再试.......\";\n    }\n}</code></pre>\n<p>注意此处的测压速度不易太快（推荐使用5秒100个线程）</p>\n<p>经过测压测试后，结果为：</p>\n<p><img alt=\"\" height=\"358\" src=\"..\\..\\static\\image\\3c498e7c63ed437b904fb803abbfdc82.png\" width=\"1200\"/></p>\n<p> </p>\n<p> </p>\n<p></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-03 20:13:52", "summary": "目录作为缓存为何使用什么样的数据适合放入缓存使用作为缓存未使用配置类使用配置类分布式锁压测工具的使用库存项目层层层层依赖测试结果解决方案使用或者锁使用作为缓存为何使用数据存储在内存中，数据查询速度快。"}