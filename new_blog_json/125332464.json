{"blogid": "125332464", "writerAge": "码龄143天", "writerBlogNum": "45", "writerCollect": "429", "writerComment": "924", "writerFan": "1753", "writerGrade": "5级", "writerIntegral": "2219", "writerName": "兔7", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125332464.jpg", "writerRankTotal": "8995", "writerRankWeekly": "1616", "writerThumb": "640", "writerVisitNum": "13691", "blog_read_count": "784", "blog_time": "已于 2022-07-19 14:49:06 修改", "blog_title": "【C++】类和对象（重中之重）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"0.%20%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#0.%20%E5%89%8D%E8%A8%80\">0. 前言</a></p>\n<p id=\"1.%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86\">1.面向过程和面向对象初步认识</a></p>\n<p id=\"2.%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5\">2.类的引入</a></p>\n<p id=\"3.%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\">3.类的定义</a></p>\n<p id=\"%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9A\">类的两种定义方式：</a></p>\n<p id=\"4.%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85\">4.类的访问限定符及封装</a></p>\n<p id=\"4.1%20%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%20%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6\">4.1 访问限定符</a></p>\n<p id=\"%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E8%AF%B4%E6%98%8E%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E8%AF%B4%E6%98%8E%EF%BC%9A\">访问限定符说明：</a></p>\n<p id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AC%2B%2B%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AC%2B%2B%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">面试题：C++中struct和class的区别是什么？</a></p>\n<p id=\"4.2%20%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%20%E5%B0%81%E8%A3%85\">4.2 封装</a></p>\n<p id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%82-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%82\">面试题：面向对象的三大特性：封装、继承、多态。</a></p>\n<p id=\"5.%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">5.类的作用域</a></p>\n<p id=\"6.%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-toc\" style=\"margin-left:0px;\"><a href=\"#6.%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96\">6.类的实例化</a></p>\n<p id=\"7.%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#7.%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B\">7.类对象模型</a></p>\n<p id=\"7.1%20%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F-toc\" style=\"margin-left:40px;\"><a href=\"#7.1%20%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F\">7.1 如何计算类对象的大小</a></p>\n<p id=\"7.2%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%8C%9C%E6%B5%8B-toc\" style=\"margin-left:40px;\"><a href=\"#7.2%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%8C%9C%E6%B5%8B\">7.2 类对象的存储方式猜测</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\">问题：</a></p>\n<p id=\"%E7%BB%93%E8%AE%BA%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BB%93%E8%AE%BA%EF%BC%9A\">结论：</a></p>\n<p id=\"7.3%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99-toc\" style=\"margin-left:40px;\"><a href=\"#7.3%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99\">7.3 结构体内存对齐规则</a></p>\n<p id=\"8.this%E6%8C%87%E9%92%88-toc\" style=\"margin-left:0px;\"><a href=\"#8.this%E6%8C%87%E9%92%88\">8.this指针</a></p>\n<p id=\"8.1%20this%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%87%BA-toc\" style=\"margin-left:40px;\"><a href=\"#8.1%20this%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%87%BA\">8.1 this指针的引出</a></p>\n<p id=\"8.2%20this%E6%8C%87%E9%92%88%E7%9A%84%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#8.2%20this%E6%8C%87%E9%92%88%E7%9A%84%E7%89%B9%E6%80%A7\">8.2 this指针的特性</a></p>\n<p id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A\">面试题：</a></p>\n<p id=\"9.%C2%A0%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#9.%C2%A0%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">9. 类的6个默认成员函数</a></p>\n<p id=\"10.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#10.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">10. 构造函数</a></p>\n<p id=\"10.1%20%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#10.1%20%E6%A6%82%E5%BF%B5\">10.1 概念</a></p>\n<p id=\"10.2%20%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#10.2%20%E7%89%B9%E6%80%A7\">10.2 特性</a></p>\n<p id=\"%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A\">其特征如下：</a></p>\n<p id=\"11.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#11.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">11. 析构函数</a></p>\n<p id=\"11.1%20%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#11.1%20%E6%A6%82%E5%BF%B5\">11.1 概念</a></p>\n<p id=\"11.2%20%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#11.2%20%E7%89%B9%E6%80%A7\">11.2 特性</a></p>\n<p id=\"%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A\">其特征如下：</a></p>\n<p id=\"12.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#12.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">12. 拷贝构造函数</a></p>\n<p id=\"12.1%20%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#12.1%20%E6%A6%82%E5%BF%B5\">12.1 概念</a></p>\n<p id=\"12.2%20%E7%89%B9%E5%BE%81-toc\" style=\"margin-left:40px;\"><a href=\"#12.2%20%E7%89%B9%E5%BE%81\">12.2 特征</a></p>\n<p id=\"%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A\">其特征如下：</a></p>\n<p id=\"13.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:0px;\"><a href=\"#13.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">13. 赋值运算符重载</a></p>\n<p id=\"13.1%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#13.1%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">13.1 运算符重载</a></p>\n<p id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B3%A8%E6%84%8F%EF%BC%9A\">注意：</a></p>\n<p id=\"13.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#13.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">13.2 赋值运算符重载</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BA%94%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BA%94%E7%82%B9%EF%BC%9A\">​编辑 赋值运算符主要有五点：</a></p>\n<p id=\"%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93\">默认成员函数的总结</a></p>\n<p id=\"%E5%88%86%E5%BC%80%E8%A7%A3%E9%87%8A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%88%86%E5%BC%80%E8%A7%A3%E9%87%8A\">分开解释</a></p>\n<p id=\"%E6%95%B4%E4%BD%93%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%95%B4%E4%BD%93%E6%80%BB%E7%BB%93\">整体总结</a></p>\n<p id=\"%E6%80%9D%E8%80%83-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%9D%E8%80%83\">思考</a></p>\n<p id=\"14.%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#14.%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\">14.日期类的实现</a></p>\n<p id=\"Date.h%EF%BC%88%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#Date.h%EF%BC%88%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%89\">Date.h（类、函数的定义）</a></p>\n<p id=\"Date.cpp%EF%BC%88%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#Date.cpp%EF%BC%88%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89\">Date.cpp（类中函数的实现）</a></p>\n<p id=\"Test.cpp%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#Test.cpp%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89\">Test.cpp（测试）</a></p>\n<p id=\"15.%20const%E6%88%90%E5%91%98-toc\" style=\"margin-left:0px;\"><a href=\"#15.%20const%E6%88%90%E5%91%98\">15. const成员</a></p>\n<p id=\"15.1%20const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#15.1%20const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">15.1 const修饰类的成员函数</a></p>\n<p id=\"%E6%80%9D%E8%80%83%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%80%9D%E8%80%83%EF%BC%9A\">思考：</a></p>\n<p id=\"16.%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#16.%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0\">16.取地址及const取地址操作符重载 </a></p>\n<p id=\"17.%20%E5%86%8D%E8%B0%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#17.%20%E5%86%8D%E8%B0%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">17. 再谈构造函数</a></p>\n<p id=\"17.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC-toc\" style=\"margin-left:40px;\"><a href=\"#17.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC\">17.1 构造函数体赋值</a></p>\n<p id=\"17.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#17.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8\">17.2 初始化列表</a></p>\n<p id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B3%A8%E6%84%8F%EF%BC%9A\">注意：</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\">问题：</a></p>\n<p id=\"17.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#17.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97\">17.3 explicit关键字</a></p>\n<p id=\"18.%20static%E6%88%90%E5%91%98-toc\" style=\"margin-left:0px;\"><a href=\"#18.%20static%E6%88%90%E5%91%98\">18. static成员</a></p>\n<p id=\"18.1%20%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#18.1%20%E6%A6%82%E5%BF%B5\">18.1 概念</a></p>\n<p id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%87%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E3%80%82-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%87%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E3%80%82\">面试题：实现一个类，计算中程序中创建出了多少个类对象。</a></p>\n<p id=\"18.2%20%E7%89%B9%E6%80%A7%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#18.2%20%E7%89%B9%E6%80%A7%C2%A0\">18.2 特性 </a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\">问题：</a></p>\n<p id=\"19.%20C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E7%8E%A9%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#19.%20C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E7%8E%A9%E6%B3%95\">19. C++11 的成员初始化新玩法</a></p>\n<p id=\"20.%20%E5%8F%8B%E5%85%83-toc\" style=\"margin-left:0px;\"><a href=\"#20.%20%E5%8F%8B%E5%85%83\">20. 友元</a></p>\n<p id=\"20.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#20.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0\">20.1 友元函数</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\">问题：</a></p>\n<p id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B3%A8%E6%84%8F%EF%BC%9A%C2%A0\">注意： </a></p>\n<p id=\"20.2%20%E5%8F%8B%E5%85%83%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#20.2%20%E5%8F%8B%E5%85%83%E7%B1%BB\">20.2 友元类</a></p>\n<p id=\"21.%20%E5%86%85%E9%83%A8%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#21.%20%E5%86%85%E9%83%A8%E7%B1%BB\">21. 内部类</a></p>\n<p id=\"%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%89%B9%E6%80%A7\">概念及特性</a></p>\n<hr id=\"hr-toc\"/>\n<h1><span style=\"color:#faa572;\"><strong>0. 前言</strong></span></h1>\n<p><strong>        此博客为博主以后复习的资料，所以大家放心学习，总结的很全面，每段代码都给大家发了出来，大家如果有疑问可以尝试去调试。</strong></p>\n<p><strong>        大家一定要认真看图，图里的文字都是精华，好多的细节都在图中展示、写出来了，所以大家一定要仔细哦~</strong></p>\n<hr/>\n<h1 id=\"1.%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86\"><span style=\"color:#faa572;\">1.面向过程和面向对象初步认识</span></h1>\n<blockquote>\n<p><strong>        <span style=\"color:#79c6cd;\">C语言</span>  是<span style=\"background-color:#79c6cd;\">面向过程</span>的，<span style=\"background-color:#79c6cd;\">关注</span>的是<span style=\"background-color:#79c6cd;\">过程</span>，分析出求解问题的步骤，通过函数调用逐步解决问题。</strong></p>\n<p><strong>        <span style=\"color:#79c6cd;\">C++</span>  是<span style=\"background-color:#79c6cd;\">基于面向对象</span>的，<span style=\"background-color:#79c6cd;\">关注</span>的是<span style=\"background-color:#79c6cd;\">对象</span>，将一件事情拆分成不同的对象，靠对象之间的交互完成。</strong></p>\n</blockquote>\n<hr/>\n<h1 id=\"2.%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5\"><span style=\"color:#faa572;\">2.类的引入</span></h1>\n<p>       <strong> C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</strong></p>\n<pre><code class=\"language-cpp\">struct Student\n{\n\tvoid SetStudentInfo(const char* name, const char* gender, int age)\n\t{\n\t\tstrcpy(_name, name);\n\t\tstrcpy(_gender, gender);\n\t\t_age = age;\n\t}\n\n\tvoid PrintStudentInfo()\n\t{\n\t\tcout &lt;&lt; _name &lt;&lt; \" \" &lt;&lt; _gender &lt;&lt; \" \" &lt;&lt; _age &lt;&lt; endl;\n\t}\n\n\tchar _name[20];\n\tchar _gender[3];\n\tint _age;\n};\nint main()\n{\n\tStudent s;\n\ts.SetStudentInfo(\"Liyuyue\", \"男\", 20);\n\ts.PrintStudentInfo();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"572\" src=\"..\\..\\static\\image\\e3e762c882b6476ea40d18f150b0d658.png\" width=\"1026\"/></p>\n<p><strong>        上面结构体的定义，<span style=\"background-color:#79c6cd;\">在C++中更喜欢用class来代替</span>。</strong></p>\n<hr/>\n<h1 id=\"3.%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\"><span style=\"color:#faa572;\">3.类的定义</span></h1>\n<pre><code class=\"language-cpp\">class ClassName\n{\n\t// 类体：由成员函数和成员变量组成\n\n}; // 一定要注意后面的分号</code></pre>\n<p><strong>        <span style=\"background-color:#79c6cd;\">class</span>为定义类的<span style=\"background-color:#79c6cd;\">关键字</span>，<span style=\"background-color:#79c6cd;\">ClassName为类的名字</span>，<span style=\"background-color:#79c6cd;\">{}中为类的主体</span>，<span style=\"background-color:#79c6cd;\">注意</span>类定义结束时后面<span style=\"background-color:#79c6cd;\">分号</span>。 </strong></p>\n<p><strong>        类中的元素称为<span style=\"background-color:#79c6cd;\">类的成员</span>：类中的<span style=\"background-color:#79c6cd;\">数据</span>称为<span style=\"background-color:#79c6cd;\">类的属性</span>或者<span style=\"background-color:#79c6cd;\">成员变量</span>; 类中的<span style=\"background-color:#79c6cd;\">函数</span>称为<span style=\"background-color:#79c6cd;\">类的方法</span>或者<span style=\"background-color:#79c6cd;\">成员函数</span>。</strong></p>\n<h3 id=\"%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9A\"><strong><span style=\"background-color:#a2e043;\">类的两种定义方式：</span></strong></h3>\n<p><strong>        1.  声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</strong></p>\n<p><img alt=\"\" height=\"533\" src=\"..\\..\\static\\image\\f880ce621e0b4961a4caa9948c51e971.png\" width=\"702\"/></p>\n<p>     <strong>    2. 声明放在.h文件中，类的定义放在.cpp文件中。</strong></p>\n<p><img alt=\"\" height=\"338\" src=\"..\\..\\static\\image\\86fcded407e842c7bebcc0ebd637346e.png\" width=\"813\"/></p>\n<div>\n<strong><span style=\"color:#777777;\">       </span><span style=\"color:#0d0016;\"> 一般情况下，更期望采用第二种方式。</span></strong>\n</div>\n<hr/>\n<h1 id=\"4.%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85\"><span style=\"color:#faa572;\">4.类的访问限定符及封装</span></h1>\n<h2 id=\"4.1%20%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6\"><span style=\"color:#9c8ec1;\">4.1 访问限定符</span></h2>\n<p><strong>        C++实现封装的方式：<span style=\"background-color:#79c6cd;\">用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用</span>。</strong></p>\n<p><img alt=\"\" height=\"387\" src=\"..\\..\\static\\image\\c4fbc06f837945c3ac2d7d24dbe5b402.png\" width=\"596\"/></p>\n<h3 id=\"%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E8%AF%B4%E6%98%8E%EF%BC%9A\"><span style=\"color:#fe2c24;\">访问限定符说明：</span></h3>\n<ol><li><strong>public修饰的成员在类外可以直接被访问。</strong></li><li><strong>protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)。</strong></li><li><strong>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止。</strong></li><li><strong>class的默认访问权限为private，struct为public(因为struct要兼容C)。</strong></li></ol>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AC%2B%2B%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><strong><span style=\"color:#fe2c24;\">面试题：C++中struct和class的区别是什么？</span></strong></h3>\n<p><strong>        解答：C++需要兼容C语言，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。 和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式是private。</strong></p>\n<h2 id=\"4.2%20%E5%B0%81%E8%A3%85\"><span style=\"color:#9c8ec1;\">4.2 封装</span></h2>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%82\"><span style=\"color:#fe2c24;\">面试题：面向对象的三大特性：<span style=\"background-color:#79c6cd;\">封装、继承、多态</span>。</span></h3>\n<p><strong><u>在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？</u></strong></p>\n<p><strong>        <span style=\"background-color:#79c6cd;\">封装</span>：<span style=\"background-color:#79c6cd;\">将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互</span>。</strong></p>\n<p><strong>        <span style=\"background-color:#79c6cd;\">封装本质上是一种管理</span>：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给<span style=\"background-color:#79c6cd;\">封装</span>起来。但是我们目的全封装起来，不让别人看。所以我们<span style=\"background-color:#79c6cd;\">开放了售票通道</span>，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。 不想给别人看到的，我们使用protected/private把成员<span style=\"background-color:#79c6cd;\">封装</span>起来。<span style=\"background-color:#79c6cd;\">开放</span>一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</strong></p>\n<hr/>\n<h1 id=\"5.%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span style=\"color:#faa572;\">5.类的作用域</span></h1>\n<p>   <strong>     <span style=\"background-color:#79c6cd;\">类定义了一个新的作用域</span>，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。</strong></p>\n<pre><code class=\"language-cpp\">class Person\n{\npublic:\n\tvoid PrintPersonInfo();\nprivate:\n\tchar _name[20];\n\tchar _gender[3];\n\tint _age;\n};\n// 这里需要指定PrintPersonInfo是属于Person这个类域\nvoid Person::PrintPersonInfo()\n{\n\tcout &lt;&lt; _name &lt;&lt; \" \" &lt;&lt; _gender &lt;&lt; \" \" &lt;&lt; _age &lt;&lt; endl;\n}\n\nint main()\n{\n\tPerson p;\n\tp.Person::PrintPersonInfo();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"499\" src=\"..\\..\\static\\image\\944b0dd2143b4642a2114e8e2569e230.png\" width=\"786\"/></p>\n<hr/>\n<h1 id=\"6.%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96\"><span style=\"color:#faa572;\">6.类的实例化</span></h1>\n<p><strong>        用类类型创建对象的过程，称为类的实例化</strong></p>\n<ol><li><strong>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。</strong></li><li><strong>一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量。</strong></li><li><strong>做个比方：类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间。</strong></li></ol>\n<p><img alt=\"\" height=\"460\" src=\"..\\..\\static\\image\\55d85dc372e7473a8dd5720f7cf4da7e.png\" width=\"750\"/></p>\n<p><img alt=\"\" height=\"365\" src=\"..\\..\\static\\image\\2a4d022dcb4f4a709ad1133dcc148374.png\" width=\"615\"/></p>\n<hr/>\n<h1 id=\"7.%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B\"><span style=\"color:#faa572;\">7.类对象模型</span></h1>\n<h2 id=\"7.1%20%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F\"><span style=\"color:#9c8ec1;\">7.1 如何计算类对象的大小</span></h2>\n<p><strong>        类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大小？</strong></p>\n<pre><code class=\"language-cpp\">class A\n{\npublic:\n\tvoid PrintA()\n\t{\n\tcout &lt;&lt; _a &lt;&lt; endl;\n\t}\nprivate:\n\tchar _a;\n\tint _b;\n};\n\nint main()\n{\n\tA a;\n\tint sz = sizeof(a);\n\tcout &lt;&lt; sz &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"584\" src=\"..\\..\\static\\image\\896fb447dccf495b9ae32b12ce058309.png\" width=\"1200\"/></p>\n<h2 id=\"7.2%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%8C%9C%E6%B5%8B\"><span style=\"color:#9c8ec1;\">7.2 类对象的存储方式猜测</span></h2>\n<ul><li><strong>对象中包含类的各个成员</strong></li></ul>\n<p><img alt=\"\" height=\"268\" src=\"..\\..\\static\\image\\0083f09112754eb8b6e0040c08d784fe.png\" width=\"497\"/></p>\n<div>\n<strong>        </strong>\n<span style=\"color:#fe2c24;\"><strong>缺陷</strong></span>\n<strong>：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多个对象时，<span style=\"background-color:#79c6cd;\">每个对象中都会保存一份代码，相同代码保存多次，浪费空间。那么如何解决呢？ </span></strong>\n</div>\n<p></p>\n<ul><li><strong>只保存成员变量，成员函数存放在公共的代码段</strong></li></ul>\n<p><img alt=\"\" height=\"589\" src=\"..\\..\\static\\image\\5394f71100f047a5b06a63ad144aa486.png\" width=\"725\"/></p>\n<h3 id=\"%E9%97%AE%E9%A2%98%EF%BC%9A\"><span style=\"color:#fe2c24;\">问题：</span></h3>\n<p><strong>        对于上述两种存储方式，那计算机到底是按照那种方式来存储的？</strong></p>\n<p></p>\n<p><strong>我们再通过对下面的不同对象分别获取大小来分析看下：</strong></p>\n<pre><code class=\"language-cpp\">// 类中既有成员变量，又有成员函数\nclass A1 {\npublic:\n\tvoid f1() {}\nprivate:\n\tint _a;\n};\n// 类中仅有成员函数\nclass A2 {\npublic:\n\tvoid f2() {}\n};\n// 类中什么都没有---空类\nclass A3\n{};\n\nint main()\n{\n\tA1 a1;\n\tA2 a2;\n\tA3 a3;\n\tint sz = sizeof(a1);\n\tcout &lt;&lt; sz &lt;&lt; endl;\n\n\tsz = sizeof(a2);\n\tcout &lt;&lt; sz &lt;&lt; endl;\n\n\tsz = sizeof(a3);\n\tcout &lt;&lt; sz &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"717\" src=\"..\\..\\static\\image\\9b986d23bbb64c3484efef90cfdface0.png\" width=\"772\"/></p>\n<h3 id=\"%E7%BB%93%E8%AE%BA%EF%BC%9A\"><span style=\"color:#fe2c24;\">结论：</span></h3>\n<p>       <strong> 一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。</strong></p>\n<h2 id=\"7.3%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99\"><span style=\"color:#9c8ec1;\">7.3 结构体内存对齐规则</span></h2>\n<ol><li><strong>第一个成员在与结构体偏移量为0的地址处。</strong></li><li><strong>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。<br/><u>注意</u>：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。<br/> VS中默认的对齐数为8。</strong></li><li><strong>结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。</strong></li><li><strong>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</strong></li></ol>\n<hr/>\n<h1 id=\"8.this%E6%8C%87%E9%92%88\"><span style=\"color:#faa572;\">8.this指针</span></h1>\n<h2 id=\"8.1%20this%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%87%BA\"><span style=\"color:#9c8ec1;\">8.1 this指针的引出</span></h2>\n<p><strong>        我们先来定义一个日期类Date：</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tvoid Display()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\n\n\tvoid SetDate(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\nprivate:\n\tint _year; // 年\n\tint _month; // 月\n\tint _day; // 日\n};\nint main()\n{\n\tDate d1, d2;\n\td1.SetDate(2018, 5, 1);\n\td2.SetDate(2018, 7, 1);\n\td1.Display();\n\td2.Display();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"634\" src=\"..\\..\\static\\image\\c63ae555e0c04c019cc0d85489f5f8ea.png\" width=\"1057\"/></p>\n<p><strong>        <u>对于上述类，有这样的一个问题</u>：Date类中有SetDate与Display两个成员函数，函数体中没有关于不同对象的区分，那当s1调用SetDate函数时，该函数是如何知道应该设置s1对象，而不是设置s2对象呢？</strong></p>\n<p><img alt=\"\" height=\"639\" src=\"..\\..\\static\\image\\716715a49a714ecdb9382a84c499f28e.png\" width=\"1200\"/></p>\n<p><strong>        C++中通过引入this指针解决该问题，即：<span style=\"background-color:#79c6cd;\">C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该 指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</span></strong></p>\n<h2 id=\"8.2%20this%E6%8C%87%E9%92%88%E7%9A%84%E7%89%B9%E6%80%A7\"><span style=\"color:#9c8ec1;\">8.2 this指针的特性</span></h2>\n<ol><li><strong>this指针的类型：类类型 *const。</strong></li><li><strong>只能在“成员函数”的内部使用。</strong></li><li><strong><span style=\"background-color:#79c6cd;\">this指针本质上其实是一个成员函数的形参</span>，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以<span style=\"background-color:#79c6cd;\">对象中不存储this指针</span>。</strong></li><li><strong><span style=\"background-color:#79c6cd;\">this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递。</span></strong></li></ol>\n<p><img alt=\"\" height=\"238\" src=\"..\\..\\static\\image\\d0fa877342f844e58e4464cb988b7418.png\" width=\"547\"/></p>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A\"><span style=\"color:#fe2c24;\">面试题：</span></h3>\n<ol><li><strong>this指针存在哪里？</strong></li><li><strong>this指针可以为空吗？</strong></li></ol>\n<pre><code class=\"language-cpp\">// 1.下面程序能编译通过吗？\n// 2.下面程序会崩溃吗？在哪里崩溃\nclass A\n{\npublic:\n\tvoid PrintA()\n\t{\n\t\tcout &lt;&lt; _a &lt;&lt; endl;\n\t}\n\n\tvoid Show()\n\t{\n\t\tcout &lt;&lt; \"Show()\" &lt;&lt; endl;\n\t}\nprivate:\n\tint _a;\n};\nint main()\n{\n\tA* p = NULL;\n\tp-&gt;PrintA();\n\tp-&gt;Show();\n}</code></pre>\n<p><img alt=\"\" height=\"854\" src=\"..\\..\\static\\image\\764bbad12e9742d5bca35be8981effe6.png\" width=\"582\"/></p>\n<hr/>\n<h1 id=\"9.%C2%A0%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span style=\"color:#faa572;\">9. 类的6个默认成员函数</span></h1>\n<p><strong>        ​如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。</strong></p>\n<pre><code class=\"language-cpp\">class Date {};</code></pre>\n<p><img alt=\"\" height=\"317\" src=\"..\\..\\static\\image\\7fa5d368d9854c608c89db44aba86c3c.png\" width=\"937\"/></p>\n<hr/>\n<h1 id=\"10.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span style=\"color:#faa572;\">10. 构造函数</span></h1>\n<h2 id=\"10.1%20%E6%A6%82%E5%BF%B5\"><strong><span style=\"color:#9c8ec1;\">10.1 概念</span></strong></h2>\n<p><strong>对于以下的日期类：</strong></p>\n<pre><code class=\"language-cpp\">\nclass Date\n{\npublic:\n\tvoid SetDate(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\n\tvoid Display()\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\td1.SetDate(2018, 5, 1);\n\td1.Display();\n\tDate d2;\n\td2.SetDate(2018, 7, 1);\n\td2.Display();\n\treturn 0;\n}</code></pre>\n<p><strong><img alt=\"\" height=\"655\" src=\"..\\..\\static\\image\\b4c42f251199474a9ae68500d6045b2c.png\" width=\"1005\"/></strong></p>\n<p><strong>         对于Date类，可以通过SetDate公有的方法给对象设置内容，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？</strong></p>\n<p><strong>        <span style=\"background-color:#79c6cd;\">构造函数</span>是一个<span style=\"background-color:#79c6cd;\">特殊的成员函数</span>，<span style=\"background-color:#79c6cd;\">名字与类名相同，创建类类型对象时由编译器自动调用</span>，保证每个数据成员都有一个合适的初始值，并且<span style=\"background-color:#79c6cd;\">在对象的生命周期内只调用一次</span>。</strong></p>\n<h2 id=\"10.2%20%E7%89%B9%E6%80%A7\"><strong><span style=\"color:#9c8ec1;\">10.2 特性</span></strong></h2>\n<p><strong>        <span style=\"background-color:#79c6cd;\">构造函数</span>是特殊的成员函数。</strong></p>\n<p><strong>        需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主要任务<span style=\"background-color:#79c6cd;\">并不是开空间创建对象</span>，<span style=\"background-color:#79c6cd;\">而是初始化对象</span>。</strong></p>\n<h3 id=\"%E5%85%B6%E7%89%B9%E5%BE%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><strong><span style=\"color:#fe2c24;\">其特征如下：</span></strong></h3>\n<ol><li><strong>函数名与类名相同。</strong></li><li><strong>无返回值。</strong></li><li><strong>对象实例化时编译器<span style=\"background-color:#79c6cd;\">自动调用</span>对应的构造函数。</strong></li><li><strong>构造函数可以重载。</strong> <pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t// 1.无参构造函数\n\tDate()\n\t{}\n\n\t// 2.带参构造函数\n\tDate(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1; // 调用无参构造函数\n\tDate d2(2015, 1, 1); // 调用带参的构造函数\n\n\t// 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明\n\t// 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象\n\tDate d3();\n\n\treturn 0;\n}</code></pre> <br/><strong><img alt=\"\" height=\"696\" src=\"..\\..\\static\\image\\0e726c67593f4dbc91c9998abbbe69a0.png\" width=\"1073\"/></strong></li><li><strong>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。</strong> <pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t/*\n\t// 如果用户显式定义了构造函数，编译器将不再生成\n\tDate (int year, int month, int day)\n\t{\n\t_year = year;\n\t_month = month;\n\t_day = day;\n\t}\n\t*/\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d;\n\treturn 0;\n}</code></pre> <br/><strong><img alt=\"\" height=\"521\" src=\"..\\..\\static\\image\\6118bf523e214f2f86bab652148b96d8.png\" width=\"886\"/></strong></li><li><strong>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。<span style=\"background-color:#a2e043;\">注意：</span><span style=\"color:#ad720d;\">无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数</span>，都可以认为是<span style=\"color:#ad720d;\">默认成员函数</span>。</strong> <pre><code class=\"language-cpp\">// 默认构造函数\nclass Date\n{\npublic:\n\tDate()\n\t{\n\t\t_year = 1900;\n\t\t_month = 1;\n\t\t_day = 1;\n\t}\n\n\tDate(int year = 1900, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\n\nint main()\n{\n\tDate d1;\n}</code></pre> <br/><img alt=\"\" height=\"635\" src=\"..\\..\\static\\image\\a3a7a21ce3f34c7eb4a80cfc0d8ef6fb.png\" width=\"794\"/></li><li><strong>关于编译器生成的默认成员函数，很多小伙伴会有疑惑：在我们不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？d 对象调用了编译器生成的默认构造函数，但 是 d 对象 _year / _month / _day，依旧是随机值。也就说在这里<span style=\"background-color:#79c6cd;\">编译器生成的默认构造函数并没有什么卵用？？？</span><br/><br/><br/> 解答：C++把类型分成<span style=\"background-color:#79c6cd;\">内置类型(基本类型)</span>和<span style=\"background-color:#79c6cd;\">自定义类型</span>。内置类型就是语法已经定义好的类型：如 int / char...，自定义类型就是我们使用 class / struct / union 自己定义的类型，看看下面的程序，就会发现<span style=\"background-color:#79c6cd;\">编译器生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数</span>。</strong> <pre><code class=\"language-cpp\">class Time\n{\npublic:\n\tTime()\n\t{\n\t\tcout &lt;&lt; \"Time()\" &lt;&lt; endl;\n\t\t_hour = 0;\n\t\t_minute = 0;\n\t\t_second = 0;\n\t}\nprivate:\n\tint _hour;\n\tint _minute;\n\tint _second;\n};\nclass Date\n{\nprivate:\n\t// 基本类型(内置类型)\n\tint _year;\n\tint _month;\n\tint _day;\n\t// 自定义类型\n\tTime _t;\n};\nint main()\n{\n\tDate d;\n\treturn 0;\n}</code></pre> <br/><img alt=\"\" height=\"700\" src=\"..\\..\\static\\image\\0d670faefaac4cb5bf28a2188127795d.png\" width=\"959\"/></li><li><strong>成员变量的命名风格</strong>  </li></ol>\n<pre><code class=\"language-cpp\">// 我们看看这个函数，是不是很僵硬？\nclass Date\n{\npublic:\n\tDate(int year)\n\t{\n\t\t// 这里的year到底是成员变量，还是函数形参？\n\t\tyear = year;\n\t}\nprivate:\n\tint year;\n};\n// 所以我们一般都这样\nclass Date\n{\npublic:\n\tDate(int year)\n\t{\n\t\t_year = year;\n\t}\nprivate:\n\tint _year;\n};\n// 或者这样。\nclass Date\n{\npublic:\n\tDate(int year)\n\t{\n\t\tm_year = year;\n\t}\nprivate:\n\tint m_year;\n};</code></pre>\n<p><img alt=\"\" height=\"808\" src=\"..\\..\\static\\image\\4a90ee6f04e74c2ea3e1ed97a57a1326.png\" width=\"763\"/></p>\n<hr/>\n<h1 id=\"11.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span style=\"color:#faa572;\">11. 析构函数</span></h1>\n<h2 id=\"11.1%20%E6%A6%82%E5%BF%B5\"><span style=\"color:#9c8ec1;\">11.1 概念</span></h2>\n<p>       <strong>  前面通过构造函数的学习，我们知道一个对象时怎么来的，那一个对象又是怎么没呢的？</strong></p>\n<p><strong>         <u>析构函数</u>：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而<span style=\"background-color:#79c6cd;\">对象在销毁时会自动调用析构函数，完成类的一些资源清理工作</span>。</strong></p>\n<h2 id=\"11.2%20%E7%89%B9%E6%80%A7\"><span style=\"color:#9c8ec1;\">11.2 特性</span></h2>\n<p><strong>        <span style=\"background-color:#79c6cd;\">析构函数</span>是特殊的成员函数。</strong></p>\n<h3><strong><span style=\"color:#fe2c24;\">其特征如下：</span></strong></h3>\n<ol><li><strong>析构函数名是在类名前加上字符 ~。</strong></li><li><strong>无参数无返回值（注意是无返回值，而不是返回值为空，且不能被重载）。</strong></li><li><strong>一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。</strong></li><li><strong>对象生命周期结束时，C++编译系统系统自动调用析构函数。</strong> <pre><code class=\"language-cpp\">\ntypedef int DataType;\nclass SeqList\n{\npublic:\n\tSeqList(int capacity = 10)\n\t{\n\t\t_Data = (DataType*)malloc(capacity * sizeof(DataType));\n\t\t_size = 0;\n\t\t_capacity = capacity;\n\t}\n\n\t~SeqList()\n\t{\n\t\tcout &lt;&lt; \"~Stack()析构函数\" &lt;&lt; endl;\n\t\tif (_Data)\n\t\t{\n\t\t\tfree(_Data); // 释放堆上的空间\n\t\t\t_Data = nullptr; // 将指针置为空\n\t\t\t_capacity = 0;\n\t\t\t_size = 0;\n\t\t}\n\t}\n\nprivate:\n\tint* _Data;\n\tsize_t _size;\n\tsize_t _capacity;\n};\nint main()\n{\n\tSeqList L;\n\treturn 0;\n}</code></pre> <br/><img alt=\"\" height=\"771\" src=\"..\\..\\static\\image\\84722cd1e8d140f5b9f50fc68a298cc5.png\" width=\"896\"/><pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\tStack(int capacity = 4)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\t_size = 0;\n\t\t_capacity = capacity;\n\t}\n\tvoid Push(int x)\n\t{}\n\t// 像Stack这样的类，析构函数具有重大意义\n\t~Stack()\n\t{\n\t\tcout &lt;&lt; \"~Stack()析构函数\" &lt;&lt; endl;\n\t\t// 清理资源\n\t\tfree(_a);\n\t\t_a = nullptr;\n\t\t_size = _capacity = 0;\n\t}\nprivate:\n\tint* _a;\n\tint _size;\n\tint _capacity;\n};\nint main()\n{\n\tStack st1;\n\tst1.Push(1);\n\tst1.Push(2);\n\tStack st2;\n\tst2.Push(10);\n\tst2.Push(11);\n\treturn 0;\n}</code></pre> <br/><img alt=\"\" height=\"752\" src=\"..\\..\\static\\image\\6c42156a403244e1a3fdd50fdd37b5e9.png\" width=\"901\"/></li><li><strong>关于编译器自动生成的析构函数，是否会完成一些事情呢？下面的程序我们会看到，编译器生成的默认析构函数，<span style=\"background-color:#79c6cd;\">会对自定类型成员调用它的析构函数</span>。</strong> <pre><code class=\"language-cpp\">class String\n{\npublic:\n\tString(const char* str = \"Liyuyue\")\n\t{\n\t\t_str = (char*)malloc(strlen(str) + 1);\n\t\tstrcpy(_str, str);\n\t}\n\t~String()\n\t{\n\t\tcout &lt;&lt; \"~String()\" &lt;&lt; endl;\n\t\tfree(_str);\n\t}\nprivate:\n\tchar* _str;\n};\n\nclass Person\n{\nprivate:\n\tString _name;\n\tint _age;\n};\nint main()\n{\n\tPerson p;\n\treturn 0;\n}</code></pre> <br/><img alt=\"\" height=\"670\" src=\"..\\..\\static\\image\\e62ea9cc36d9470780cf60e5a5ec6e0c.png\" width=\"1022\"/></li></ol>\n<p><strong>        最后要声明一下，<span style=\"background-color:#79c6cd;\">析构函数不是完成对象的销毁</span>，这<span style=\"background-color:#79c6cd;\">个对象是存在函数栈帧里面，函数结束，栈帧销毁，对象就销毁了</span>。</strong></p>\n<p><strong>        针对这个对象有两块空间要销毁</strong></p>\n<ol><li><strong>对象本身，它是函数结束时栈帧销毁，它就销毁。</strong></li><li><strong>对象里的*_str指向的堆上的空间，它是析构函数清理的。</strong></li></ol>\n<hr/>\n<h1 id=\"12.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span style=\"color:#faa572;\">12. 拷贝构造函数</span></h1>\n<h2 id=\"12.1%20%E6%A6%82%E5%BF%B5\"><span style=\"color:#9c8ec1;\">12.1 概念</span></h2>\n<p><strong>        <span style=\"background-color:#79c6cd;\">拷贝构造函数</span>：<span style=\"background-color:#79c6cd;\">只有单个形参</span>，该形参是对本<span style=\"background-color:#79c6cd;\">类类型对象的引用(一般常用const修饰)</span>，在用已存在的类类型对象创建新对象时由编译器自动调用。</strong></p>\n<h2 id=\"12.2%20%E7%89%B9%E5%BE%81\"><span style=\"color:#9c8ec1;\">12.2 特征</span></h2>\n<p><strong>        拷贝构造函数也是特殊的成员函数。</strong></p>\n<h3><span style=\"color:#fe2c24;\">其特征如下：</span></h3>\n<ol><li><strong>拷贝构造函数<span style=\"background-color:#79c6cd;\">是构造函数的一个重载形式</span>。</strong></li><li><strong>拷贝构造函数的<span style=\"background-color:#79c6cd;\">参数只有一个</span>且<span style=\"background-color:#79c6cd;\">必须使用引用传参</span>，使用<span style=\"background-color:#79c6cd;\">传值方式会引发无穷递归调用</span>。</strong> <pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 2002, int month = 9, int day = 13)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tDate(const Date&amp; d)\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\tDate d2(d1);\n\treturn 0;\n}</code></pre> <br/><strong><img alt=\"\" height=\"623\" src=\"..\\..\\static\\image\\6ae65cf18ee541b2a4f4d912fb32acdb.png\" width=\"983\"/><br/><img alt=\"\" height=\"615\" src=\"..\\..\\static\\image\\30ed3bc2135e40168b8705a6cc669110.png\" width=\"956\"/></strong></li><li><strong><span style=\"background-color:#79c6cd;\">若未显示定义，系统生成默认的拷贝构造函数</span>。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝。</strong> <pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t/*Date(int year = 2021, int month = 3, int day = 21)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}*/\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1; \n\t// 这里d2调用的默认拷贝构造完成拷贝，d2和d1的值也是一样的。\n\tDate d2(d1);\n\t\n\treturn 0;\n}</code></pre> <br/><img alt=\"\" height=\"533\" src=\"..\\..\\static\\image\\7aa622128c4f4526916a386bb340a933.png\" width=\"982\"/></li><li><strong>那么<span style=\"background-color:#79c6cd;\">编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了</span>，我们还需要自己实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？</strong> <pre><code class=\"language-cpp\">#include&lt;string&gt;\n\n// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。\nclass String\n{\npublic:\n\tString(const char* str = \"Liyuyue\")\n\t{\n\t\t_str = (char*)malloc(strlen(str) + 1);\n\t\tstrcpy(_str, str);\n\t}\n\t~String()\n\t{\n\t\tcout &lt;&lt; \"~String()\" &lt;&lt; endl;\n\t\tfree(_str);\n\t}\nprivate:\n\tchar* _str;\n};\nint main()\n{\n\tString s1(\"Hello CSDN\");\n\tString s2(s1);\n}</code></pre> <br/><img alt=\"\" height=\"582\" src=\"..\\..\\static\\image\\dde2a8a73d5645a09e542eea2b6fe9c8.png\" width=\"1036\"/><br/><img alt=\"\" height=\"869\" src=\"..\\..\\static\\image\\63234d57d81e46d9a227d318b1409c1b.png\" width=\"1200\"/></li></ol>\n<hr/>\n<h1 id=\"13.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span style=\"color:#faa572;\">13. 赋值运算符重载</span></h1>\n<h2 id=\"13.1%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span style=\"color:#9c8ec1;\"><strong>13.1 运算符重载</strong></span></h2>\n<p><strong>        <span style=\"background-color:#79c6cd;\">C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数</span>，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</strong></p>\n<p><strong>         函数名字为：关键字<span style=\"background-color:#79c6cd;\">operator后面接需要重载的运算符符号</span>。</strong></p>\n<p><strong>         函数原型：<span style=\"background-color:#79c6cd;\">返回值类型 operator操作符(参数列表)</span></strong></p>\n<h3 id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A\"><span style=\"color:#fe2c24;\">注意：</span></h3>\n<ol><li><strong>不能通过连接其他符号来创建新的操作符：比如operator@</strong></li><li><strong>重载操作符必须有一个类类型或者枚举类型的操作数</strong></li><li><strong>用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义</strong></li><li><strong>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参</strong></li><li><strong><span style=\"background-color:#79c6cd;\">.*</span> 、<span style=\"background-color:#79c6cd;\">::</span> 、<span style=\"background-color:#79c6cd;\">sizeof</span> 、<span style=\"background-color:#79c6cd;\">?:</span> 、<span style=\"background-color:#79c6cd;\">.</span> 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</strong></li></ol>\n<pre><code class=\"language-cpp\">// 全局的operator==\nclass Date\n{\npublic:\n\tDate(int year = 2002, int month = 9, int day = 13)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\t//private:\n\tint _year;\n\tint _month;\n\tint _day;\n};\n// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？\n// 这里其实可以用我后面会讲到的友元解决，或者干脆重载成成员函数。\nbool operator==(const Date&amp; d1, const Date&amp; d2)\n{\n\treturn d1._year == d2._year\n\t\t&amp;&amp; d1._month == d2._month\n\t\t&amp;&amp; d1._day == d2._day;\n}\nint main()\n{\n\tDate d1(2021, 3, 21);\n\tDate d2(2021, 3, 21);\n\tcout &lt;&lt; (d1 == d2) &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"705\" src=\"..\\..\\static\\image\\57504457c88b4ac48e6d28400a3b9703.png\" width=\"924\"/></p>\n<pre><code class=\"language-cpp\">\nclass Date\n{\npublic:\n\tDate(int year = 2002, int month = 9, int day = 13)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\n\tDate(const Date&amp; d)\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\n\n\tDate&amp; operator=(const Date&amp; d)\n\t{\n\t\tif (this != &amp;d)\n\t\t{\n\t\t\t_year = d._year;\n\t\t\t_month = d._month;\n\t\t\t_day = d._day;\n\t\t}\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<p><img alt=\"\" height=\"642\" src=\"..\\..\\static\\image\\6a1a74a213ac4fd796930ba0e6daa633.png\" width=\"818\"/></p>\n<h2 id=\"13.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span style=\"color:#9c8ec1;\">13.2 赋值运算符重载</span></h2>\n<pre><code class=\"language-cpp\">\nclass Date\n{\npublic:\n\tDate(int year = 2002, int month = 9, int day = 13)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\n\tDate(const Date&amp; d)\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\n\n\tDate&amp; operator=(const Date&amp; d)\n\t{\n\t\tif (this != &amp;d)\n\t\t{\n\t\t\t_year = d._year;\n\t\t\t_month = d._month;\n\t\t\t_day = d._day;\n\t\t}\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BA%94%E7%82%B9%EF%BC%9A\"><img alt=\"\" height=\"658\" src=\"..\\..\\static\\image\\619714043829429ea9689d5772ee5cd4.png\" width=\"714\"/> <span style=\"color:#fe2c24;\">赋值运算符主要有五点：</span></h3>\n<p></p>\n<ol><li><strong>参数类型</strong></li><li><strong>返回值</strong></li><li><strong>检测是否自己给自己赋值</strong></li><li><strong>返回*this</strong></li><li><strong>一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝</strong></li></ol>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 2002, int month = 9, int day = 13)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\tDate d2(2021,3, 21);\n\t// 这里d1调用的编译器生成operator=完成拷贝，d2和d1的值也是一样的。\n\n\td1 = d2;\n\treturn 0;\n}</code></pre>\n<p><strong><img alt=\"\" height=\"483\" src=\"..\\..\\static\\image\\f67f588f290e4ab594788138f4a1937a.png\" width=\"965\"/></strong></p>\n<p><strong>        那么<span style=\"background-color:#79c6cd;\">编译器生成的默认赋值重载函数已经可以完成字节序的值拷贝了</span>，我们还需要自己实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？</strong></p>\n<pre><code class=\"language-cpp\">// 这里会发现下面的程序会崩溃掉\nclass String\n{\npublic:\n\tString(const char* str = \"\")\n\t{\n\t\t_str = (char*)malloc(strlen(str) + 1);\n\t\tstrcpy(_str, str);\n\t}\n\t~String()\n\t{\n\t\tcout &lt;&lt; \"~String()\" &lt;&lt; endl;\n\t\tfree(_str);\n\t}\nprivate:\n\tchar* _str;\n};\nint main()\n{\n\tString s1(\"Hello\");\n\tString s2(\"CSDN\");\n\n\ts1 = s2;\n}</code></pre>\n<p><img alt=\"\" height=\"646\" src=\"..\\..\\static\\image\\a4d6624fabc447998a934dc337244a1b.png\" width=\"1054\"/></p>\n<hr/>\n<h1 id=\"%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93\"><span style=\"color:#faa572;\">默认成员函数的总结</span></h1>\n<h2 id=\"%E5%88%86%E5%BC%80%E8%A7%A3%E9%87%8A\"><span style=\"color:#9c8ec1;\">分开解释</span></h2>\n<p><strong>        <span style=\"color:#6eaad7;\">默认成员函数</span>：我们不写编译器会自动生成，虽然会自动生成，但是好多时候还是需要我们自己写，因为生成的那个不一定好用。</strong></p>\n<p><strong>        <span style=\"color:#6eaad7;\">构造函数</span>：初始化，大部分情况下，都需要我们自己写构造函数。</strong></p>\n<p><strong>        <span style=\"color:#6eaad7;\">析构函数</span>：清理内对象中资源。</strong></p>\n<p><strong>        <span style=\"color:#6eaad7;\">拷贝构造函数</span>：拷贝初始化，特殊构造函数，深浅拷贝问题。</strong></p>\n<p><strong>        <span style=\"color:#6eaad7;\">赋值运算符重载</span>：也是拷贝行为，但是不一样的是，拷贝构造是创建一个对象时，拿同类对象初始化的拷贝，这里的赋值拷贝时那个对象已经都存在了，都被初始化过了，现在想把一个对象，复制拷贝给另一个对象。</strong></p>\n<h2 id=\"%E6%95%B4%E4%BD%93%E6%80%BB%E7%BB%93\"><strong><span style=\"color:#9c8ec1;\">整体总结</span></strong></h2>\n<p><strong>1. <span style=\"background-color:#79c6cd;\">构造和析构的特性是类似的</span>，我们不写编译器内置类型不处理，自定义类型调用它的构造和析构处理。</strong></p>\n<p><strong>2. <span style=\"background-color:#79c6cd;\">拷贝构造和赋值重载特性是类似的</span>，内置类型会完成浅拷贝，自定义类型会调用他们的拷贝构造和赋值重载。</strong></p>\n<h2 id=\"%E6%80%9D%E8%80%83\"><span style=\"color:#9c8ec1;\">思考</span></h2>\n<p><strong>Date d5(d1)：<span style=\"color:#6eaad7;\">拷贝构造</span>，拿一个已经存在的对象去构造初始化另一个要创建的对象。</strong></p>\n<p><strong>d1 = d2：<span style=\"color:#6eaad7;\">赋值重载</span>，两个已经存在的对象进行拷贝。</strong></p>\n<p><strong>Date d6 = d1：这是要注意的，这里是<span style=\"color:#6eaad7;\">拷贝构造</span>，不是赋值重载，因为这里符合拷贝构造的定义：拿一个已经存在的对象去构造初始化另一个要创建的对象。</strong></p>\n<hr/>\n<h1 id=\"14.%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span style=\"color:#faa572;\">14.日期类的实现</span></h1>\n<p>       <strong> 这里为了让大家更好的理解，我已经用多文件的方式写了一份日期类的代码，<span style=\"background-color:#79c6cd;\">大家可以通过我写的代码来巩固自己对前面知识的理解，里面写了很多注释，都很清楚，如果有兴趣的小伙伴可以尝试去写</span>，会有很大的收获！！！</strong></p>\n<p><strong>        大家如果需要以下代码可以点下面链接去我的gitee去取。</strong><a class=\"has-card\" href=\"https://gitee.com/liyuyuea/CPP/tree/master/Class_Date_/Class_Date_\" title=\"Class_Date_/Class_Date_ · Liyuyuea/C++ - 码云 - 开源中国 (gitee.com)\"><span class=\"link-card-box\"><span class=\"link-title\">Class_Date_/Class_Date_ · Liyuyuea/C++ - 码云 - 开源中国 (gitee.com)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://gitee.com/liyuyuea/CPP/tree/master/Class_Date_/Class_Date_</span></span></a></p>\n<h2 id=\"Date.h%EF%BC%88%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%89\"><span style=\"color:#9c8ec1;\"><strong>Date.h（类、函数的定义）</strong></span></h2>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include&lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\nusing std::cin;\nusing std::istream;\nusing std::ostream;\n\n// 析构、拷贝构造、赋值重载，可以不写，默认生成就够用; \n// 像Stack才需要自己写这三个\nclass Date\n{\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);\n\tfriend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);\npublic:\n\t// 全缺省的构造函数\n\tDate(int year = 0, int month = 1, int day = 1);\n\n\n\t// 获取某年某月的天数\n\tint GetMonthDay(int year, int month);\n\n\n\tvoid Print() const;\n\n\n//\tDate d5(d1); // 拷贝构造  拿一个已经存在的对象去构造初始化另一个要创建的对象\n//\td1 = d2;     // 赋值重载  两个已经存在的对象-&gt;拷贝\n//\tDate d6 = d1; // 拷贝构造? 赋值重载? ---&gt;拷贝构造\n\n\n\t// 拷贝构造函数\n\t// d2(d1)\n\tDate(const Date&amp; d);\n\n\t// 赋值运算符重载\n\t// d2 = d3 -&gt; d2.operator=(&amp;d2, d3)\n\tDate&amp; operator=(const Date&amp; d);\n\n\n\t//析构函数\n\t~Date();\n\n\n\t// 日期+=天数\n\tDate&amp; operator+=(int day);\n\n\t// 日期+天数\n\tDate operator+(int day) const;\n\n\t// 日期-=天数\n\tDate&amp; operator-=(int day);\n\n\t// 日期-天数\n\tDate operator-(int day) const;\n\n\n\t// ++前置\n\tDate&amp; operator++();\n\n\t// 后置++\n\tDate operator++(int);\n\n\t// 后置--\n\tDate operator--(int);\n\n\t// --前置\n\tDate&amp; operator--();\n\n\n\t// &gt;运算符重载\n\tbool operator&gt;(const Date&amp; d) const;\n\n\t// ==运算符重载\n\tbool operator==(const Date&amp; d) const;\n\n\t// &gt;=运算符重载\n\tbool operator &gt;= (const Date&amp; d) const;\n\n\t// &lt;运算符重载\n\tbool operator &lt; (const Date&amp; d) const;\n\n\t// &lt;=运算符重载\n\tbool operator &lt;= (const Date&amp; d) const;\n\n\t// !=运算符重载\n\tbool operator != (const Date&amp; d) const;\n\n\n\n\t// 日期-日期 返回天数\n\tint operator-(const Date&amp; d) const;\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<h2 id=\"Date.cpp%EF%BC%88%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span style=\"color:#9c8ec1;\">Date.cpp（类中函数的实现）</span></h2>\n<pre><code class=\"language-cpp\">#include\"Date.h\"\n\n// 获取当年当月的天数\n// 1.定义成内联函数，因为频繁调用，为了减少函数栈帧的消耗，直接展开\n// 2.这个数要频繁调用，用static放在静态区最好\n// 3.month写在判断闰年之前\ninline int Date::GetMonthDay(int year, int month)\n{\n\t\n\tstatic int Dayarray[13] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\tint day = Dayarray[month];\n\n\tif (month == 2 &amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0))\n\t{\n\t\tday = 29;\n\t}\n\n\treturn day;\n}\n\n// 打印\nvoid Date::Print() const\n{\n\tcout &lt;&lt; _year &lt;&lt; \"年\" &lt;&lt; _month &lt;&lt; \"月\" &lt;&lt; _day &lt;&lt; \"日\" &lt;&lt; endl;\n}\n\n// 全缺省的构造函数\nDate::Date(int year, int month, int day)\n{\n\tif (year &gt; 0 &amp;&amp; month &gt; 0 &amp;&amp; month &lt; 13 &amp;&amp; day &gt; 0 &amp;&amp; day &lt; GetMonthDay(year, month))\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\telse\n\t{\n\t\tcout &lt;&lt; \"非法日期\" &lt;&lt; endl;\n\t\tcout &lt;&lt; year &lt;&lt; \"年\" &lt;&lt; month &lt;&lt; \"月\" &lt;&lt; day &lt;&lt; \"日\" &lt;&lt; endl;\n\t}\n\n}\n\n// 拷贝构造函数\nDate::Date(const Date&amp; d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n}\n\n\n// 赋值运算符重载\nDate&amp; Date::operator=(const Date&amp; d)\n{\n\tif (this != &amp;d)\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\n\n\treturn *this;\n}\n\n\nDate::~Date()\n{\n\t_year = 0;\n\t_month = 0;\n\t_day = 0;\n}\n\n\n// 日期+=天数\nDate&amp; Date::operator+=(int day)\n{\n\t_day += day;\n\t// 天数不合法，不断进位，让日期(天数)合法\n\twhile (_day &gt; GetMonthDay(_year, _month))\n\t{\n\t\t_day -= GetMonthDay(_year, _month);\n\t\t_month++;\n\t\tif (_month &gt; 12)\n\t\t{\n\t\t\t_month = 1;\n\t\t\t_year++;\n\t\t}\n\t}\n\n\treturn *this;\n}\n\n\n\n// 日期+天数\nDate Date::operator+(int day) const\n{\n\t//复刻+=\n\tDate ret(*this);\n\tret += day;\n\treturn ret;\n}\n\n// 日期-=天数\nDate&amp; Date::operator-=(int day)\n{\n\t_day -= day;\n\twhile (_day &lt; 1)\n\t{\n\t\t_day += GetMonthDay(_year, _month - 1);\n\t\t_month--;\n\t\tif (_month &lt; 1)\n\t\t{\n\t\t\t_month = 12;\n\t\t\t_year--;\n\t\t}\n\t}\n\treturn *this;\n}\n\n// 日期-天数\nDate Date::operator-(int day) const\n{\n\tDate ret(*this);\n\tret -= day;\n\treturn ret;\n}\n\n\n\n// 前置++和后置++都完成了++，不同的地方在于返回值不一样\n// 因为他们的运算符是一样的，函数名就是一样的，\n// 为了区分，对后置++做了特殊处理，加了一个参数，形成函数重载\n\n//++前置\nDate&amp; Date::operator++()\n{\n\t*this += 1;//复刻\n\treturn *this;\n}\n\n\n//后置++\nDate Date::operator++(int)\n{\n\tDate ret(*this);\n\t*this += 1;\n\treturn ret;\n}\n\n\n//--前置\nDate&amp; Date::operator--()\n{\n\t*this -= 1;\n\treturn *this;\n}\n\n//后置--\nDate Date::operator--(int)\n{\n\tDate ret = *this;\n\t*this -= 1;\n\treturn ret;\n}\n\n\n\n// ==运算符重载\nbool Date::operator==(const Date&amp; d) const\n{\n\tif (_year == d._year)\n\t{\n\t\tif (_month == d._month)\n\t\t{\n\t\t\tif (_day == d._day)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &gt;运算符重载\nbool Date::operator&gt;(const Date&amp; d) const\n{\n\tif (_year &gt; d._year)\n\t\treturn true;\n\telse if (_year == d._year)\n\t{\n\t\tif (_month &gt; d._month)\n\t\t\treturn true;\n\t\telse if (_month == d._month)\n\t\t{\n\t\t\tif (_day &gt; d._day)\n\t\t\t\treturn true;\n\t\t\telse if (_day == d._day)\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn false;\n\t\n}\n\n// &gt;=运算符重载\nbool Date::operator &gt;= (const Date&amp; d) const\n{\n\treturn (*this == d) || (*this &gt; d);\n}\n\n// &lt;运算符重载\nbool Date::operator &lt; (const Date&amp; d) const\n{\n\treturn !(*this &gt;= d);\n}\n\n// &lt;=运算符重载\nbool Date::operator &lt;= (const Date&amp; d) const\n{\n\treturn !(*this &gt; d);\n}\n\n// !=运算符重载\nbool Date::operator != (const Date&amp; d) const\n{\n\treturn !(*this == d);\n}\n\n\n\n// 日期-日期 返回天数\nint Date::operator-(const Date&amp; d) const\n{\n\t// 效率差别不大的情况下，尽量选择写可读性强的，简单的程序\n\tDate max = *this;\n\tDate min = d;\n\tint flag = 1;\n\tif (*this &lt; d)\n\t{\n\t\tmax = d;\n\t\tmin = *this;\n\t\tflag = -1;\n\t}\n\n\tint n = 0;\n\twhile (max != min)\n\t{\n\t\t++min;\n\t\t++n;\n\t}\n\n\treturn n * flag;\n}</code></pre>\n<h2 id=\"Test.cpp%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89\"><span style=\"color:#9c8ec1;\">Test.cpp（测试）</span></h2>\n<pre><code class=\"language-cpp\">#include\"Date.h\"\n\nvoid Test1()\n{\n\tDate d1(2022, 6, 12);\n\td1.Print();\n\n\td1 += 100;\n\td1.Print();\n\n\td1 += 1;\n\td1.Print();\n\n\tcout &lt;&lt; endl;\n\n\tDate d2(2021, 3, 21);\n\tDate tmp = d2 + 20;\n\ttmp.Print();\n\n\ttmp = d2 + 40;\n\ttmp.Print();\n\n}\n\nvoid Test2()\n{\n\tDate d1(2022, 6, 12);\n\td1.Print();\n\n\td1 -= 100;\n\td1.Print();\n\n\td1 -= 1;\n\td1.Print();\n\n\tcout &lt;&lt; endl;\n\n\tDate d2(2021, 3, 21);\n\tDate tmp = d2 - 20;\n\ttmp.Print();\n\n\ttmp = d2 - 40;\n\ttmp.Print();\n\n}\n\nvoid Test3()\n{\n\t//Date d1(2022, 6, 12);\n\t//d1.Print();\n\n\t//d1++;\n\t//d1.Print();\n\n\t//d1++;\n\t//d1.Print();\n\n\tcout &lt;&lt; endl;\n\n\tDate d2(2021, 3, 21);\n\tDate tmp1 = ++d2;\n\ttmp1.Print();\n\td2.Print();\n\n\tDate tmp2 = d2++;\n\ttmp2.Print();\n\td2.Print();\n\n}\n\nvoid Test4()\n{\n\tcout &lt;&lt; endl;\n\n\tDate d2(2021, 3, 21);\n\tDate tmp1 = --d2;\n\ttmp1.Print();\n\td2.Print();\n\n\tDate tmp2 = d2--;\n\ttmp2.Print();\n\td2.Print();\n\n}\n\nvoid Test5()\n{\n\tDate d1(2022, 6, 12);\n\t\n\tcout &lt;&lt; endl;\n\n\tDate d2(2021, 3, 21);\n\t\n\tint ret = d1 &lt;= d2;\n\tcout &lt;&lt; ret &lt;&lt; endl;\n\n}\n\nvoid Test6()\n{\n\tDate d1(2022, 3, 21);\n\n\tDate d2(2021, 3, 21);\n\n\tint tmp = d1 - d2;\n\tcout &lt;&lt; tmp &lt;&lt; endl;\n\n}\n\n//void Test7()\n//{\n//\tDate d2(2021, 3, 21);\n//\n//\t\n//\tcout &lt;&lt; d2;\n//\n//}\n\n\nint main()\n{\n\t//Test7();\n\treturn 0;\n}</code></pre>\n<hr/>\n<h1 id=\"15.%20const%E6%88%90%E5%91%98\"><span style=\"color:#faa572;\">15. const成员</span></h1>\n<h2 id=\"15.1%20const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span style=\"color:#9c8ec1;\">15.1 const修饰类的成员函数</span></h2>\n<p><strong>        <span style=\"background-color:#79c6cd;\">将const修饰的类成员函数称之为const成员函数</span>，const修饰类成员函数，实际修饰该成员函数<span style=\"background-color:#79c6cd;\">隐含的this 指针</span>，表明在该成员函数中<span style=\"background-color:#79c6cd;\">不能对类的任何成员进行修改</span>。</strong></p>\n<p><img alt=\"\" height=\"369\" src=\"..\\..\\static\\image\\6b6d21f66be04dc183954d3242fc5bbd.png\" width=\"804\"/></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tvoid Display()\n\t{\n\t\tcout &lt;&lt; \"Display ()\" &lt;&lt; endl;\n\t\tcout &lt;&lt; \"year:\" &lt;&lt; _year &lt;&lt; endl;\n\t\tcout &lt;&lt; \"month:\" &lt;&lt; _month &lt;&lt; endl;\n\t\tcout &lt;&lt; \"day:\" &lt;&lt; _day &lt;&lt; endl &lt;&lt; endl;\n\t}\n\tvoid Display() const\n\t{\n\t\tcout &lt;&lt; \"Display () const\" &lt;&lt; endl;\n\t\tcout &lt;&lt; \"year:\" &lt;&lt; _year &lt;&lt; endl;\n\t\tcout &lt;&lt; \"month:\" &lt;&lt; _month &lt;&lt; endl;\n\t\tcout &lt;&lt; \"day:\" &lt;&lt; _day &lt;&lt; endl &lt;&lt; endl;\n\t}\nprivate:\n\tint _year; // 年\n\tint _month; // 月\n\tint _day; // 日\n};\nint main()\n{\n\tDate d1;\n\td1.Display();\n\n\tconst Date d2;\n\td2.Display();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"656\" src=\"..\\..\\static\\image\\c528f76cdc544efa975271948fa927d0.png\" width=\"749\"/></p>\n<h3 id=\"%E6%80%9D%E8%80%83%EF%BC%9A\"><span style=\"color:#fe2c24;\">思考：</span></h3>\n<ol><li><strong>const对象可以调用非const成员函数吗？</strong></li><li><strong>非const对象可以调用const成员函数吗？</strong></li><li><strong>const成员函数内可以调用其它的非const成员函数吗？</strong></li><li><strong>非const成员函数内可以调用其它的const成员函数吗？</strong></li></ol>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\c014483dbb96436b9e3b99bd872266f1.png\" width=\"1200\"/></p>\n<hr/>\n<h1 id=\"16.%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0\"><span style=\"color:#faa572;\">16.取地址及const取地址操作符重载 </span></h1>\n<p>  <strong>      这两个默认成员函数一般不用重新定义 ，编译器默认会生成。</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate* operator&amp;()\n\t{\n\t\t//return this;\n\t\treturn nullptr;\n\t}\n\n\tconst Date* operator&amp;()const\n\t{\n\t\treturn this;\n\t}\nprivate:\n\tint _year; // 年\n\tint _month; // 月\n\tint _day; // 日\n};</code></pre>\n<p><img alt=\"\" height=\"414\" src=\"..\\..\\static\\image\\e556b81119374c1b9cfcd610504481df.png\" width=\"633\"/></p>\n<p><strong>         这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容！</strong></p>\n<hr/>\n<h1 id=\"17.%20%E5%86%8D%E8%B0%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span style=\"color:#faa572;\">17. 再谈构造函数</span></h1>\n<h2 id=\"17.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC\"><span style=\"color:#9c8ec1;\">17.1 构造函数体赋值</span></h2>\n<p><strong>        在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<p><strong>        虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，<span style=\"background-color:#79c6cd;\">构造函数体中的语句只能将其称作为赋初值</span>，而不能称作初始化。因为<span style=\"background-color:#79c6cd;\">初始化只能初始化一次，而构造函数体内可以多次赋值</span>。</strong></p>\n<h2 id=\"17.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8\"><span style=\"color:#9c8ec1;\">17.2 初始化列表</span></h2>\n<p><strong>        初始化列表：以一个<span style=\"background-color:#79c6cd;\">冒号开始</span>，接着是一个以<span style=\"background-color:#79c6cd;\">逗号分隔的数据成员列表</span>，每个\"<span style=\"background-color:#79c6cd;\">成员变量</span>\"后面跟一个<span style=\"background-color:#79c6cd;\">放在括号中的初始值或表达式</span>。</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year, int month, int day)\n\t\t: _year(year)\n\t\t, _month(month)\n\t\t, _day(day)\n\t{}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<h3><span style=\"color:#fe2c24;\">注意：</span></h3>\n<ol><li><strong>每个成员变量在初始化列表中<span style=\"background-color:#79c6cd;\">只能出现一次</span>(初始化只能初始化一次)</strong></li><li><strong>类中包含以下成员，必须放在初始化列表位置进行初始化：<br/> 1. 引用成员变量<br/> 2.const成员变量<br/> 3.自定义类型成员(该类没有默认构造函数)</strong> <pre><code class=\"language-cpp\">class A\n{\npublic:\n\tA(int a)\n\t\t:_a(a)\n\t{}\nprivate:\n\tint _a;\n};\n\nclass B\n{\npublic:\n\tB(int a, int ref)\n\t\t:_aobj(a)\n\t\t, _ref(ref)\n\t\t, _n(10)\n\t{}\nprivate:\n\tA _aobj; // 没有默认构造函数\n\tint&amp; _ref; // 引用\n\tconst int _n; // const \n};</code></pre> <p></p> </li><li><strong>尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</strong> <pre><code class=\"language-cpp\">class Time\n{\npublic:\n\tTime(int hour = 0)\n\t\t:_hour(hour)\n\t{\n\t\tcout &lt;&lt; \"Time()\" &lt;&lt; endl;\n\t}\nprivate:\n\tint _hour;\n};\n\nclass Date\n{\npublic:\n\tDate(int day)\n\t{}\nprivate:\n\tint _day;\n\tTime _t;\n};\nint main()\n{\n\tDate d(1);\n\treturn 0;\n}</code></pre> <br/><img alt=\"\" height=\"614\" src=\"..\\..\\static\\image\\3fd6f6152d6749ca92e9143b75344484.png\" width=\"1017\"/><br/><img alt=\"\" height=\"408\" src=\"..\\..\\static\\image\\55c745a886d54958a2336d0c20bf290e.png\" width=\"790\"/></li><li><strong><span style=\"background-color:#79c6cd;\">成员变量</span>在类中<span style=\"background-color:#79c6cd;\">声明次序</span>就是其在初始化列表中的<span style=\"background-color:#79c6cd;\">初始化顺序</span>，与其在初始化列表中的先后次序无关（所以建议在写初始化列表的时候要按照声明顺序写）。</strong> <pre><code class=\"language-cpp\">//A. 输出1 1\n//B.程序崩溃\n//C.编译不通过\n//D.输出1 随机值\nclass A\n{\npublic:\n\tA(int a)\n\t\t:_a1(a)\n\t\t, _a2(_a1)\n\t{}\n\n\tvoid Print() {\n\t\tcout &lt;&lt; _a1 &lt;&lt; \" \" &lt;&lt; _a2 &lt;&lt; endl;\n\t}\nprivate:\n\tint _a2;\n\tint _a1;\n};\nint main() \n{\n\tA aa(1);\n\taa.Print();\n}\n</code></pre> <img alt=\"\" height=\"564\" src=\"..\\..\\static\\image\\5a1b2e4753fc41d8882a1ed78fef6474.png\" width=\"845\"/><br/>  </li></ol>\n<h3><span style=\"color:#fe2c24;\">问题：</span></h3>\n<p><strong><span style=\"background-color:#a2e043;\">构造函数中，在哪里调用的自定义类型的默认构造函数呢？我们先要明确以下三点。</span></strong></p>\n<ol><li><strong>对象定义的时候自动调用构造函数</strong></li><li><strong><span style=\"color:#fe2c24;\"><span style=\"background-color:#faa572;\">构造函数的初始化列表可以认为是成员变量定义初始化的地方</span></span></strong></li><li><strong>初始化列表，你显示的写或者不写，都要走一遍</strong></li></ol>\n<p><strong>        内置函数如果在初始化列表没初始化，那么初始值就是随机值，<span style=\"background-color:#79c6cd;\">自定义类型在初始化的时候要调用它的默认构造函数进行初始化</span>，所以自定义类型是在构造函数的初始化列表调用它的默认构造函数的。</strong></p>\n<h2 id=\"17.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97\"><span style=\"color:#9c8ec1;\">17.3 explicit关键字</span></h2>\n<p><strong>         构造函数不仅可以构造与初始化对象，<span style=\"background-color:#79c6cd;\">对于单个参数的构造函数，还具有类型转换的作用</span>。</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year)\n\t\t:_year(year)\n\t{}\n\n\texplicit Date(int year)\n\t\t:_year(year)\n\t{}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1(2018);\n\n\td1 = 2019;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"787\" src=\"..\\..\\static\\image\\cb65d262986d43e8971a7d7118e05647.png\" width=\"1047\"/></p>\n<p>         <strong>上述代码可读性不是很好，<span style=\"background-color:#79c6cd;\">用explicit修饰构造函数，将会禁止单参构造函数的隐式转换</span>。</strong></p>\n<h1 id=\"18.%20static%E6%88%90%E5%91%98\"><span style=\"color:#faa572;\">18. static成员</span></h1>\n<h2 id=\"18.1%20%E6%A6%82%E5%BF%B5\"><span style=\"color:#9c8ec1;\"><strong>18.1 概念</strong></span></h2>\n<p><strong>        声明为<span style=\"background-color:#79c6cd;\">static的类成员</span>称为<span style=\"background-color:#79c6cd;\">类的静态成员</span>，用<span style=\"background-color:#79c6cd;\">static</span>修饰的<span style=\"background-color:#79c6cd;\">成员变量</span>，称之为<span style=\"background-color:#79c6cd;\">静态成员变量</span>；用<span style=\"background-color:#79c6cd;\">static修饰的成员函数</span>，称之为<span style=\"background-color:#79c6cd;\">静态成员函数</span>。<span style=\"background-color:#79c6cd;\">静态的成员变量一定要在类外进行初始化</span>。</strong></p>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%87%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E3%80%82\"><span style=\"color:#fe2c24;\">面试题：实现一个类，计算中程序中创建出了多少个类对象。</span></h3>\n<pre><code class=\"language-cpp\">class A\n{\npublic:\n\tA() \n\t{ \n\t\t++_scount; \n\t}\n\tA(const A&amp; t) \n\t{\n\t\t++_scount;\n\t}\n\tstatic int GetACount() \n\t{ \n\t\treturn _scount;\n\t}\nprivate:\n\tstatic int _scount;\n};\nint A::_scount = 0;\n int main()\n{\n\tcout &lt;&lt; A::GetACount() &lt;&lt; endl;\n\tA a1, a2;\n\tA a3(a1);\n\tcout &lt;&lt; A::GetACount() &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"678\" src=\"..\\..\\static\\image\\10df948cf8114809acfab7ada2c90232.png\" width=\"878\"/></p>\n<h2 id=\"18.2%20%E7%89%B9%E6%80%A7%C2%A0\"><span style=\"color:#9c8ec1;\">18.2 特性 </span></h2>\n<ol><li><strong><span style=\"background-color:#6eaad7;\">静态成员</span>为所有<span style=\"background-color:#6eaad7;\">类对象所共享</span>，不属于某个具体的对象，他是放在静态区的</strong></li><li><strong><span style=\"background-color:#6eaad7;\">静态成员变量</span>必须在<span style=\"background-color:#6eaad7;\">类外定义</span>，定义时不添加static关键字</strong></li><li><strong>类静态成员即可用类名::静态成员或者对象.静态成员来访问</strong></li><li><strong>静态成员函数<span style=\"background-color:#6eaad7;\">没有</span>隐藏的<span style=\"background-color:#6eaad7;\">this指针</span>，不能访问任何非静态成员</strong></li><li><strong>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值</strong></li></ol>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"689\" src=\"..\\..\\static\\image\\1908d8e454d34d51bb351e841ee26031.png\" width=\"1067\"/></h3>\n<h3><span style=\"color:#fe2c24;\">问题：</span></h3>\n<ol><li><strong>静态成员函数可以调用非静态成员函数吗？</strong></li><li><strong>非静态成员函数可以调用类的静态成员函数吗？</strong></li></ol>\n<p><img alt=\"\" height=\"373\" src=\"..\\..\\static\\image\\e8dd3618ff4144ee90372eb5aa4c67eb.png\" width=\"782\"/></p>\n<h1 id=\"19.%20C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E7%8E%A9%E6%B3%95\"><span style=\"color:#faa572;\"><strong>19. C++11 的成员初始化新玩法</strong></span></h1>\n<p><strong>        C++11支持非静态成员变量在声明时进行初始化赋值，<span style=\"background-color:#79c6cd;\">但是要注意这里不是初始化，这里是给声明的成员变量缺省值</span>。</strong></p>\n<pre><code class=\"language-cpp\">class B\n{\npublic:\n\tB(int b = 0)\n\t\t:_b(b)\n\t{}\n\tint _b;\n};\nclass A\n{\npublic:\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; a &lt;&lt; endl;\n\t\tcout &lt;&lt; b._b &lt;&lt; endl;\n\t\tcout &lt;&lt; p &lt;&lt; endl;\n\t\tcout &lt;&lt; n &lt;&lt; endl;\n\t}\nprivate:\n\t// 非静态成员变量，可以在成员声明时给缺省值。\n\tint a = 10;\n\tB b = 20;\n\tint* p = (int*)malloc(4);\n\tstatic int n;\n};\nint A::n = 10;\nint main()\n{\n\tA a;\n\ta.Print();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"702\" src=\"..\\..\\static\\image\\ed22235fcf7a4fe794f2fc411b0840f6.png\" width=\"867\"/></p>\n<h1 id=\"20.%20%E5%8F%8B%E5%85%83\"><span style=\"color:#faa572;\">20. 友元</span></h1>\n<p><strong>        友元分为：<span style=\"background-color:#79c6cd;\">友元函数</span>和<span style=\"background-color:#79c6cd;\">友元类</span></strong></p>\n<p><strong>        友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。</strong></p>\n<h2 id=\"20.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0\"><strong><span style=\"color:#9c8ec1;\">20.1 友元函数</span></strong></h2>\n<h3><strong><span style=\"color:#fe2c24;\">问题：</span></strong></h3>\n<p><strong>        现在我们尝试去重载operator&lt;&lt;，然后发现我们没办法将operator&lt;&lt;重载成成员函数。<span style=\"background-color:#79c6cd;\">因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置</span>。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&gt;&gt;重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year, int month, int day)\n\t\t: _year(year)\n\t\t, _month(month)\n\t\t, _day(day)\n\t{}\n\n\tostream&amp; operator&lt;&lt;(ostream&amp; _cout)\n\t{\n\t\t_cout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day;\n\t\treturn _cout;\n\t}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d(2021, 3, 21);\n\td &lt;&lt; cout;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"617\" src=\"..\\..\\static\\image\\978cf2c9123f431e9c6997b14def6fd3.png\" width=\"738\"/></p>\n<p><strong>        <span style=\"background-color:#79c6cd;\">友元函数</span>可以<span style=\"background-color:#79c6cd;\">直接访问</span>类的<span style=\"background-color:#79c6cd;\">私有</span>成员，它是<span style=\"background-color:#79c6cd;\">定义在类外部</span>的<span style=\"background-color:#79c6cd;\">普通函数</span>，不属于任何类，但需要在类的内部声明，声明时需要加<span style=\"background-color:#79c6cd;\">friend</span>关键字。</strong></p>\n<pre><code class=\"language-cpp\">class Date\n{\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);\n\tfriend istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d);\npublic:\n\tDate(int year = 2021, int month = 3, int day = 21)\n\t\t: _year(year)\n\t\t, _month(month)\n\t\t, _day(day)\n\t{}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)\n{\n\t_cout &lt;&lt; d._year &lt;&lt; \"-\" &lt;&lt; d._month &lt;&lt; \"-\" &lt;&lt; d._day;\n\n\treturn _cout;\n}\nistream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d)\n{\n\t_cin &gt;&gt; d._year;\n\t_cin &gt;&gt; d._month;\n\t_cin &gt;&gt; d._day;\n\n\treturn _cin;\n}\nint main()\n{\n\tDate d;\n\tcin &gt;&gt; d;\n\tcout &lt;&lt; d &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"799\" src=\"..\\..\\static\\image\\ab744c01ffa74e5c92ecb1513e09c426.png\" width=\"832\"/></p>\n<h3 id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A%C2%A0\"><span style=\"color:#fe2c24;\">注意： </span></h3>\n<ol><li><strong><span style=\"background-color:#6eaad7;\">友元函数</span>可访问类的私有和保护成员，但<span style=\"background-color:#6eaad7;\">不是类的成员函数</span></strong></li><li><strong>友元函数<span style=\"background-color:#6eaad7;\">不能用const修饰</span></strong></li><li><strong><span style=\"background-color:#6eaad7;\">友元函数</span>可以在类定义的任何地方声明，<span style=\"background-color:#6eaad7;\">不受类访问限定符限制</span></strong></li><li><strong>一个函数可以是多个类的友元函数</strong></li><li><strong>友元函数的调用与普通函数的调用和原理相同</strong></li></ol>\n<h2 id=\"20.2%20%E5%8F%8B%E5%85%83%E7%B1%BB\"><span style=\"color:#9c8ec1;\">20.2 友元类</span></h2>\n<p><strong>        友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</strong></p>\n<ol><li><strong>友元关系是单向的，不具有交换性。<br/>         比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。</strong></li><li><strong>友元关系不能传递<br/>        如果B是A的友元，C是B的友元，则不能说明C时A的友元。</strong></li></ol>\n<pre><code class=\"language-cpp\">class Date; // 前置声明\nclass Time\n{\n\tfriend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量\npublic:\n\tTime(int hour = 1, int minute = 1, int second = 1)\n\t\t: _hour(hour)\n\t\t, _minute(minute)\n\t\t, _second(second)\n\t{}\n\nprivate:\n\tint _hour;\n\tint _minute;\n\tint _second;\n};\nclass Date\n{\npublic:\n\tDate(int year = 1900, int month = 1, int day = 1)\n\t\t: _year(year)\n\t\t, _month(month)\n\t\t, _day(day)\n\t{}\n\n\tvoid SetTimeOfDate(int hour, int minute, int second)\n\t{\n\t\t// 直接访问时间类私有的成员变量\n\t\t_t._hour = hour;\n\t\t_t._minute = minute;\n\t\t_t._second = second;\n\t}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n\tTime _t;\n};</code></pre>\n<p><img alt=\"\" height=\"869\" src=\"..\\..\\static\\image\\7ac73294956a4e4c9219904f00869d3a.png\" width=\"916\"/></p>\n<h1 id=\"21.%20%E5%86%85%E9%83%A8%E7%B1%BB\"><span style=\"color:#faa572;\">21. 内部类</span></h1>\n<h2 id=\"%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%89%B9%E6%80%A7\"><span style=\"color:#9c8ec1;\">概念及特性</span></h2>\n<p>      <strong>  概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个<span style=\"background-color:#79c6cd;\">内部类是一个独立的类</span>，<span style=\"background-color:#79c6cd;\">它不属于外部类，更不能通过外部类的对象去调用内部类</span>。外部类对内部类没有任何优越的访问权限。</strong></p>\n<p><strong>        注意：<span style=\"background-color:#79c6cd;\">内部类就是外部类的友元类</span>。注意友元类的定义，<span style=\"background-color:#79c6cd;\">内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元</span>。</strong></p>\n<p><strong>特性：</strong></p>\n<ol><li><strong>内部类可以定义在外部类的public、protected、private都是可以的。</strong></li><li><strong>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。</strong></li><li><strong>sizeof(外部类)=外部类，和内部类没有任何关系。</strong></li></ol>\n<pre><code class=\"language-cpp\">class A\n{\nprivate:\n\tstatic int k;\n\tint h;\npublic:\n\tclass B\n\t{\n\tpublic:\n\t\tvoid foo(const A&amp; a)\n\t\t{\n\t\t\tcout &lt;&lt; k &lt;&lt; endl;//OK\n\t\t\tcout &lt;&lt; a.h &lt;&lt; endl;//OK\n\t\t}\n\t};\n};\nint A::k = 1;\nint main()\n{\n\tA::B b;\n\n\tb.foo(A());\n\treturn 0;\n}</code></pre>\n<p><strong> </strong><img alt=\"\" height=\"552\" src=\"..\\..\\static\\image\\d67dc56ef9154ac8b08a4667f713c53d.png\" width=\"629\"/></p>\n<p><img alt=\"\" height=\"512\" src=\"..\\..\\static\\image\\6522248be21949e49c16a3fa63dfbbb7.png\" width=\"811\"/></p>\n<p><strong>         如上就是C++类和对象的所有知识，接下来本专辑会更新C++<span style=\"color:#fe2c24;\"><span style=\"background-color:#9c8ec1;\">内存管理</span></span>，如果大家喜欢看此文章并且有收获，可以时刻关注我，本专栏持续更新！</strong></p>\n<p><strong>        感谢大家观看，感谢大家支持！</strong></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-19 14:49:06", "summary": "目录前言面向过程和面向对象初步认识类的引入类的定义类的两种定义方式：类的访问限定符及封装访问限定符访问限定符说明：面试题：中和的区别是什么？封装面试题：面向对象的三大特性：封装、继承、多态。类的作用域"}