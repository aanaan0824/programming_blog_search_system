{"blogid": "125459617", "writerAge": "码龄1年", "writerBlogNum": "161", "writerCollect": "408", "writerComment": "122", "writerFan": "49", "writerGrade": "5级", "writerIntegral": "2084", "writerName": "小天狼星_布莱克", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125459617.jpg", "writerRankTotal": "9986", "writerRankWeekly": "1467", "writerThumb": "353", "writerVisitNum": "31508", "blog_read_count": "2906", "blog_time": "于 2022-06-25 17:24:18 发布", "blog_title": "C++简单排序——冒泡排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>今天我们来学习一种新的排序方法——<strong>冒泡排序</strong>。</p>\n<p>上一次我们学习了一种简单的排序——<strong>计数排序</strong>，这种排序有两个局限： 1、要排序的类型必须是有序类型（如整形），像浮点型这种无序数据类型则不能用计数排序。 2、要排序的数据必须有固定的小范围，否则就会数组太大爆内存。</p>\n<p>针对这种缺点，人们研发了冒泡排序（从小到大）：从后面开始往前两两对比，如果前数大于后数则交换，否则不交换，重复此操作，直到在一次操作中没有交换才结束。由于在过程中，最小/大数会不断向前移动，像泡泡从水里冒出来一样，故称冒泡排序。</p>\n<p><s>文字看不懂，</s>看看具体操作：将数列：4 9 2 8 6  从小到大排序。</p>\n<p>第一步： 4 9 2 6 8      // 后面两个数 8 6 比较，8大于6，所以交换。</p>\n<p>第二步： 4 9 2 6 8      // 接下来将 2 6 比较，不交换。</p>\n<p>第三步： 4 2 9 6 8      // 将 9 2 比较，交换。</p>\n<p>第四步： 2 4 9 6 8      // 将 4 2 比较，交换。</p>\n<p>//现在完成了最小数放在最前面，用了4次比较，3次交换。我们要将第2小数放到第2位。</p>\n<p>第五步： 2 4 9 6 8      // 再次从后面开始，6 8 比较，不交换。</p>\n<p>第六步： 2 4 6 9 8      // 将 6 9 比较，交换。</p>\n<p>第七步： 2 4 6 9 8      // 将 4 6 比较，不交换。</p>\n<p>//我们已经将第2小数放到第2位，用了3次比较，1次交换。现在要将第3小数放到第3位。</p>\n<p>第八步： 2 4 6 8 9      // 将 9 8 比较，交换。这时，排序已经完成，但程序还没结束。</p>\n<p>第九步： 2 4 6 8 9      // 将 6 8 比较，不交换。</p>\n<p>//我们已经将第3小数放到第3位，用了2次比较，1次交换。现在要将第4小数放到第4位。</p>\n<p>第十步： 2 4 6 8 9      // 将 8 9 比较，不交换。</p>\n<p>这时，程序结束了。我们也将数列排好了。每一次的交换如下：</p>\n<p>4 9 2 8 6</p>\n<p>4 9 2 6 8</p>\n<p>4 2 9 6 8</p>\n<p>2 4 9 6 8</p>\n<p>2 4 6 9 8</p>\n<p>2 4 6 8 9</p>\n<p>排序结束。</p>\n<p>知道了基本原理，代码也就好打了（将整形的数从小到大排序）：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nint n,i,j,a[2000];\nbool t;              //定义变量\nint main()\n{\n\tcin &gt;&gt;n;\n\tfor (i=1;i&lt;=n;i++)\n\t\tcin &gt;&gt;a[i];       //输入\n\tfor (i=1;i&lt;=n;i++)\n\t{\n\t\tt=1;\n\t\tfor (j=n;j&gt;i;j--)\n\t\t\tif (a[j]&lt;a[j-1])        //从后面往前两两判断\n\t\t\t{\n\t\t\t\tswap(a[j],a[j-1]);     //交换\n\t\t\t\tt=0;\n\t\t\t}\n\t\tif (t)\n\t\t\tbreak;    //如一次循环中没有交换，说明已经排好序了，退出循环  \n\t}\n\tfor (i=1;i&lt;=n;i++)\n\t\tcout &lt;&lt;a[i] &lt;&lt;\" \";        //输出\n\treturn 0;        //华丽结束\n}</code></pre>\n<p>冒泡排序时间复杂度为O（n²），比计数排序要慢，但没有数据类型和范围的局限（当然，范围不能太大），是一种很好用的稳定排序。</p>\n<p>冒泡排序讲解完毕，下期预告：排序的稳定性。</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-25 17:24:18", "summary": "今天我们来学习一种新的排序方法冒泡排序。上一次我们学习了一种简单的排序计数排序，这种排序有两个局限：、要排序的类型必须是有序类型如整形，像浮点型这种无序数据类型则不能用计数排序。、要排序的数据必须有固"}