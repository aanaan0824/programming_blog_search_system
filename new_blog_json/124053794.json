{"blogid": "124053794", "writerAge": "码龄5年", "writerBlogNum": "62", "writerCollect": "142", "writerComment": "8", "writerFan": "25", "writerGrade": "4级", "writerIntegral": "1494", "writerName": "花北城", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124053794.jpg", "writerRankTotal": "14175", "writerRankWeekly": "17748", "writerThumb": "36", "writerVisitNum": "138869", "blog_read_count": "1402", "blog_time": "已于 2022-04-29 14:52:33 修改", "blog_title": "C#服务(Service)安装及一键启停解决方案", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>1、问题描述</p>\n<p>今天，我们编写了一个窗体应用程序，我们要将其设置成开机自动启动，上篇文章介绍有两种方式。</p>\n<p>一种，开机启动目录下创建应有程序的快捷方式；另一种，写Windows服务；我们现在采用“服务方式自启程序”，因为用户不具备管理员权限，服务安全，我们也方便监控管理。</p>\n<p>好了，方案确认好了，先说说我们面临的问题，或者说是待解决的问题：</p>\n<p>①安装服务，通过咱新开发的C#应用软件安装，不希望借助第三方工具（installutil.exe），因为面向人群非科班出身，操作越简单越好。</p>\n<p>②开启、停止服务，不希望出现【黑色命令框】弹窗，看着就烦，用户体验不好。</p>\n<p>③不希望出现Windows权限不够的提示框，因为用户是普通用户，不具备“管理员操作权限”，本程序有一些敏感操作，有需要最高权限，不要出现“权限不够，哪怕是否确认授权”消息提示框。</p>\n<p></p>\n<p>怎么样？需求是不是很变态，需要同时满足以上三点，网上很多技术教程已经不适用。变态需求即是挑战，下面我将介绍本文解决方案，彻底解决以上问题，希望可以帮助面临同样困状的你们。</p>\n<p></p>\n<p>2、问题解决</p>\n<p>点击【是否开机自启】，安装Windows service服务，并实现服务启停。</p>\n<p><img alt=\"\" height=\"475\" src=\"..\\..\\static\\image\\ab7b8d48d80746729262a1e182ae55b7.png\" width=\"456\"/></p>\n<p>（1）Main()主方法改写，Program.cs文件下启动窗体，改成服务形式仿照我的代码改写吧。</p>\n<pre><code class=\"language-cs\"> static void Main(string[] args)\n        {\n            //ProcessExec processExec = new ProcessExec();\n            //string aa = \"\";\n            //processExec.MediaServiceStart(\"\", out aa);\n\n            if (args.Length &gt; 0)\n            {\n                var serviceName = Const.ct_strServiceName;\n                var host = HostFactory.New(x =&gt;\n                {\n                    x.EnableShutdown();\n                    x.Service&lt;ServiceCtrl&gt;();\n                    x.RunAsLocalSystem();\n                    x.SetDescription(Const.ct_strProjName);\n                    x.SetDisplayName(serviceName);\n                    x.SetServiceName(serviceName);\n                });\n                LogHelper.Info(\"***********主程序运行(服务方式)**********\");\n                host.Run();\n            }\n            else\n            {\n                bool createNew;\n                //使用用互斥量(System.Threading.Mutex)只运行一个实列\n                using (System.Threading.Mutex mutex = new System.Threading.Mutex(true, Application.ProductName, out createNew))\n                {\n                    if (createNew)\n                    {\n                        Application.EnableVisualStyles();\n                        Application.SetCompatibleTextRenderingDefault(false);\n                        LogHelper.Info(\"***********主程序运行(客户端方式)**********\");\n                        Application.Run(new FormMain());\n                    }\n                    else\n                    {\n                        System.Threading.Thread.Sleep(1000);\n                        System.Environment.Exit(1);\n                    }\n                }\n            }\n            \n    }</code></pre>\n<p>（2）安装service服务方式</p>\n<p>①添加新项--&gt;Windows服务--AutoPlayerService.cs</p>\n<p><img alt=\"\" height=\"607\" src=\"..\\..\\static\\image\\325fd54c61e34f78aa4993a3be7fff9e.png\" width=\"1200\"/></p>\n<p> ②右键空白处，【添加安装程序】，它会自动创建ProjectInstaller.cs文件，打开该文件有两个组件serviceProcessInstaller1、serviceInstaller1</p>\n<p>网上大部分方式，教你们在属性中填写 服务信息，我不叫你们这种方式，如下图所示：</p>\n<p><img alt=\"\" height=\"236\" src=\"..\\..\\static\\image\\169cc42e2fc14d79b9ae65f3f9ff54b4.png\" width=\"346\"/><img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\6e0b54bdb3d1467489d32ccaf154b6ce.png\" width=\"318\"/></p>\n<p> ③我的方式，通过使用底层入口实现。</p>\n<p>添加以下4行代码。</p>\n<pre><code class=\"language-cs\">        [DllImport(\"kernel32.dll\")]\n        public static extern int WinExec(string CmdLine, int ShowCmd);\n\n        [DllImport(\"shell32.dll\")]\n        public static extern int ShellExecute(IntPtr hWnd, string Operation, string FileName,\n                                              string Parameters, string Directory, int ShowCmd);</code></pre>\n<p> ④实现方法</p>\n<p>安装服务</p>\n<pre><code class=\"language-cs\">                string cmd = Application.ExecutablePath;\n                cmd += \" install\";\n                WinExec(cmd, 1);\n                MessageBox.Show(\"服务安装完毕！\");\n                ShellExecute(this.Handle, \"open\", \"Services.msc\", \"\", \"\", 1);</code></pre>\n<p>卸载方法</p>\n<pre><code class=\"language-cs\">                    ServiceStop(Const.ct_strServiceName);//停止服务\n                    string cmd = Application.ExecutablePath;\n                    cmd += \" uninstall\";\n                    WinExec(cmd, 1);\n                    MessageBox.Show(\"服务卸载完毕！\");</code></pre>\n<p>（3）服务启停</p>\n<p>①创建服务类ServiceCtrl.cs ，实现接口ServiceControl。</p>\n<pre><code class=\"language-cs\">  public class ServiceCtrl : ServiceControl\n    {\n        MainTimer m_MainTimer;\n\n        public ServiceCtrl()\n        {\n            try\n            {\n                m_MainTimer = new MainTimer(21600);//6小时检查一次\n                m_MainTimer.InitTimer();\n            }\n            catch (Exception err)\n            {\n                LogHelper.Error(\"初始化服务发生错误：\" + err.ToString());\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 服务启动时执行\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"c\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public bool Start(Topshelf.HostControl c)\n        {\n            try\n            {\n                m_MainTimer.StartTimer();\n                string l_strMsgError = \"\";\n                if (SysParameter.shutdown_tag == \"T\")\n                {\n                    ProcessExec exec = new ProcessExec();\n                    exec.StartShutDown(out l_strMsgError);\n                }\n                return true;\n            }\n            catch (Exception err)\n            {\n                LogHelper.Error(\"启动服务发生错误：\" + err.ToString());\n                return false;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 服务关闭时执行\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"c\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public bool Stop(Topshelf.HostControl c)\n        {\n            try\n            {\n                m_MainTimer.StopTimer();\n                return true;\n            }\n            catch (Exception err)\n            {\n                LogHelper.Error(\"停止服务发生错误：\" + err.ToString());\n                return false;\n            }\n        }\n    }</code></pre>\n<p>②服务启动</p>\n<pre><code class=\"language-cs\">        //启动服务\n        public static void ServiceStart(string serviceName)\n        {\n            using (ServiceController control = new ServiceController(serviceName))\n            {\n                if (control.Status == ServiceControllerStatus.Stopped)\n                {\n                    control.Start();\n                }\n            }\n        }</code></pre>\n<p>③服务停止</p>\n<pre><code class=\"language-cs\">      //停止服务\n        public static void ServiceStop(string serviceName)\n        {\n            using (ServiceController control = new ServiceController(serviceName))\n            {\n                if (control.Status == ServiceControllerStatus.Running)\n                {\n                    control.Stop();\n                }\n            }\n        }</code></pre>\n<p>④服务判断是否在运行状态，可选</p>\n<pre><code class=\"language-cs\">        //判断服务状态\n        public static bool IsServiceRuning(string serviceName)\n        {\n            ServiceController[] services = ServiceController.GetServices();\n            foreach (ServiceController sc in services)\n            {\n                if (sc.ServiceName.ToLower() == serviceName.ToLower())\n                {\n                    if (sc.Status == ServiceControllerStatus.Running)\n                    {\n                        return true;\n                    }\n                    else\n                    {\n                        return false;\n                    }\n                }\n            }\n            return false;\n        }</code></pre>\n<p>此刻服务启停代码已经实现了，关于调用，我给一个案例。</p>\n<pre><code class=\"language-cs\"> //启动服务（Windows服务运行）\n        private void BTN_ServiceRun_Click(object sender, EventArgs e)\n        {\n            m_service.Start(null);\n            try\n            {\n                BTN_ServiceRun.Enabled = false;\n\n                //ToDo：采用服务式，无dos黑框\n                //string cmd = Const.ct_strServiceName;\n                //cmd = \"net start \" + cmd;\n                //FormSet.WinExec(cmd, 1);\n\n                FormSet.ServiceStart(Const.ct_strServiceName);\n                if (DataOperation.UpdateStateType(\"正在运行\"))\n                {\n                    GC_Main.DataSource = DataOperation.SelectData();\n                    GC_Main.RefreshDataSource();\n                }\n            }\n            finally\n            {\n                BTN_ServiceStop.Enabled = true;\n            }\n        }\n\n        //停止服务（Windows服务停止）\n        private void BTN_ServiceStop_Click(object sender, EventArgs e)\n        {\n            m_service.Stop(null);\n            try\n            {\n                BTN_ServiceStop.Enabled = false;\n\n                FormSet.ServiceStop(Const.ct_strServiceName);\n                if (DataOperation.UpdateStateType(\"已停止\"))\n                {\n                    GC_Main.DataSource = DataOperation.SelectData();\n                    GC_Main.RefreshDataSource();\n                }\n            }\n            finally\n            {\n                BTN_ServiceRun.Enabled = true;\n            }\n        }</code></pre>\n<p>（4）此刻你会发现，每次服务操作都会有“权限不足”的弹窗提示，我们要升级管理员权限</p>\n<p>创建app.manifest应用程序清单文件。</p>\n<pre><code class=\"language-html\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;assembly manifestVersion=\"1.0\" xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n  &lt;assemblyIdentity version=\"1.0.0.0\" name=\"MyApplication.app\"/&gt;\n  &lt;trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v2\"&gt;\n    &lt;security&gt;\n      &lt;requestedPrivileges xmlns=\"urn:schemas-microsoft-com:asm.v3\"&gt;\n        &lt;!-- UAC 清单选项\n             如果想要更改 Windows 用户帐户控制级别，请使用\n             以下节点之一替换 requestedExecutionLevel 节点。n\n        &lt;requestedExecutionLevel  level=\"asInvoker\" uiAccess=\"false\" /&gt;\n        &lt;requestedExecutionLevel  level=\"requireAdministrator\" uiAccess=\"false\" /&gt;\n        &lt;requestedExecutionLevel  level=\"highestAvailable\" uiAccess=\"false\" /&gt;\n\n            指定 requestedExecutionLevel 元素将禁用文件和注册表虚拟化。\n            如果你的应用程序需要此虚拟化来实现向后兼容性，则删除此\n            元素。\n        --&gt;\n        &lt;requestedExecutionLevel  level=\"requireAdministrator\" uiAccess=\"false\" /&gt;\n      &lt;/requestedPrivileges&gt;\n    &lt;/security&gt;\n  &lt;/trustInfo&gt;\n\n  &lt;compatibility xmlns=\"urn:schemas-microsoft-com:compatibility.v1\"&gt;\n    &lt;application&gt;\n      &lt;!-- 设计此应用程序与其一起工作且已针对此应用程序进行测试的\n           Windows 版本的列表。取消评论适当的元素，\n           Windows 将自动选择最兼容的环境。 --&gt;\n\n      &lt;!-- Windows Vista --&gt;\n      &lt;!--&lt;supportedOS Id=\"{e2011457-1546-43c5-a5fe-008deee3d3f0}\" /&gt;--&gt;\n\n      &lt;!-- Windows 7 --&gt;\n      &lt;!--&lt;supportedOS Id=\"{35138b9a-5d96-4fbd-8e2d-a2440225f93a}\" /&gt;--&gt;\n\n      &lt;!-- Windows 8 --&gt;\n      &lt;!--&lt;supportedOS Id=\"{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}\" /&gt;--&gt;\n\n      &lt;!-- Windows 8.1 --&gt;\n      &lt;!--&lt;supportedOS Id=\"{1f676c76-80e1-4239-95bb-83d0f6d0da78}\" /&gt;--&gt;\n\n      &lt;!-- Windows 10 --&gt;\n      &lt;!--&lt;supportedOS Id=\"{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}\" /&gt;--&gt;\n\n    &lt;/application&gt;\n  &lt;/compatibility&gt;\n\n  &lt;!-- 指示该应用程序可以感知 DPI 且 Windows 在 DPI 较高时将不会对其进行\n       自动缩放。Windows Presentation Foundation (WPF)应用程序自动感知 DPI，无需\n       选择加入。选择加入此设置的 Windows 窗体应用程序(目标设定为 .NET Framework 4.6 )还应\n       在其 app.config 中将 \"EnableWindowsFormsHighDpiAutoResizing\" 设置设置为 \"true\"。--&gt;\n  &lt;!--\n  &lt;application xmlns=\"urn:schemas-microsoft-com:asm.v3\"&gt;\n    &lt;windowsSettings&gt;\n      &lt;dpiAware xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\"&gt;true&lt;/dpiAware&gt;\n    &lt;/windowsSettings&gt;\n  &lt;/application&gt;\n  --&gt;\n\n  &lt;!-- 启用 Windows 公共控件和对话框的主题(Windows XP 和更高版本) --&gt;\n  &lt;!--\n  &lt;dependency&gt;\n    &lt;dependentAssembly&gt;\n      &lt;assemblyIdentity\n          type=\"win32\"\n          name=\"Microsoft.Windows.Common-Controls\"\n          version=\"6.0.0.0\"\n          processorArchitecture=\"*\"\n          publicKeyToken=\"6595b64144ccf1df\"\n          language=\"*\"\n        /&gt;\n    &lt;/dependentAssembly&gt;\n  &lt;/dependency&gt;\n  --&gt;\n\n&lt;/assembly&gt;\n</code></pre>\n<p>&lt;requestedExecutionLevel  level=\"requireAdministrator\" uiAccess=\"false\" /&gt;这句代码帮你以管理员身份运行。其它东西自己慢慢研究吧</p>\n<p></p>\n<p>3、链接分享</p>\n<p>你需要引入最强大的组件库 Geyc.Utils.dll，里面封装了大量实战项目的帮助、操作类，实时更新补充。</p>\n<p>倘若你在项目引用过程中，发现组件中的错误，或是库不支持，或是组件适配环境性问题，请联系我修改封装底层库文件。</p>\n<p>链接：https://pan.baidu.com/s/1sEO9aH2_re7Xwa-WDL_V7w?pwd=l6d0 <br/> 提取码：l6d0</p>\n<p></p>\n<p><img alt=\"\" height=\"509\" src=\"..\\..\\static\\image\\00182a438d6343308ff73c3aedcdc1e0.png\" width=\"1200\"/></p>\n<p>3、新手使用</p>\n<p>是的，和往常一样，我已将方法封装，你也只需要几行代码就可以实现高大尚的功能。</p>\n<pre><code class=\"language-cs\">//判断服务是否运行\nIsServiceRuning(string serviceName)\n\n//安装服务\nInstallService(string serviceFilePath)\n\n//卸载服务\nUninstallService(string serviceFilePath)\n\n//启动服务\nServiceStart(string serviceName)\n\n//停止服务\nServiceStop(string serviceName)</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-29 14:52:33", "summary": "、问题描述今天，我们编写了一个窗体应用程序，我们要将其设置成开机自动启动，上篇文章介绍有两种方式。一种，开机启动目录下创建应有程序的快捷方式；另一种，写服务；我们现在采用服务方式自启程序，因为用户不具"}