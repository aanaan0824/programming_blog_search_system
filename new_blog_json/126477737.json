{"blogid": "126477737", "writerAge": "码龄10年", "writerBlogNum": "585", "writerCollect": "2412", "writerComment": "2412", "writerFan": "19457", "writerGrade": "7级", "writerIntegral": "14459", "writerName": "一一哥Sun", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126477737.jpg", "writerRankTotal": "737", "writerRankWeekly": "75", "writerThumb": "1796", "writerVisitNum": "782945", "blog_read_count": "1013", "blog_time": "于 2022-08-23 09:20:53 发布", "blog_title": "老司机带带你，教你学会Java中又骚又暴力的“反射”技术", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>在Java中有这么一个很骚的技术，几乎贯穿了所有主流的框架，在所有主流框架的底层中你都可以看见它的身影，这个技术就是<u><strong>反射</strong></u>。关于反射，有很多小白会觉得很难，搞不清楚到底是怎么回事，也不知道该怎么用，今天<strong>壹哥</strong>就来教教你如何理解和使用Java的反射。</p>\n<h1>一. 反射概念</h1>\n<p>我们知道，在物理层面上，反射是一种光学现象，是指光在传播到不同物质时，在分界面上改变传播方向后又返回原来物质中的现象。</p>\n<p><img alt=\"\" height=\"688\" src=\"..\\..\\static\\image\\1ae50ebf64924b3cbbb86a31f3b16fb5.png\" width=\"1200\"/></p>\n<p>而在Java中，反射是一种机制，而不是一种现象。反射机制指的是程序在运行时能够动态获取类对象的属性，和调用类对象的方法。</p>\n<p><img alt=\"\" height=\"580\" src=\"..\\..\\static\\image\\e0aa54ee54bf4bb1a192ef2b1115f676.png\" width=\"1200\"/></p>\n<p>Java中的编译类型有两种<strong>：</strong></p>\n<p></p>\n<blockquote>\n<ul><li> <p><span style=\"color:#fe2c24;\"><strong>静态编译</strong></span>：在编译时确定类型，绑定对象即通过。</p> </li></ul>\n<ul><li> <p><span style=\"color:#fe2c24;\"><strong>动态编译</strong></span>：运行时确定类型，绑定对象。动态编译最大限度地发挥了Java的灵活性，体现了多态的应用，可以减低类之间的耦合性。</p> </li></ul>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>使用反射可以赋予 </strong><strong>JVM</strong><strong> 动态编译的能力，否则类的元数据信息只能用静态编译的方式实现。</strong></span></p>\n<h1>二. 反射API</h1>\n<p>在Java中，JDK为我们提供了一些反射相关的API，如下表所示：</p>\n<table><tbody><tr><td colspan=\"1\" rowspan=\"1\"> <p>类</p> </td><td colspan=\"1\" rowspan=\"1\"> <p>含义</p> </td></tr><tr><td colspan=\"1\" rowspan=\"1\"> <p>java.lang.Class</p> </td><td colspan=\"1\" rowspan=\"1\"> <p>代表整个字节码。代表一个类型，代表整个类。</p> </td></tr><tr><td colspan=\"1\" rowspan=\"1\"> <p>java.lang.reflect.Method</p> </td><td colspan=\"1\" rowspan=\"1\"> <p>代表字节码中的方法字节码。代表类中的方法。</p> </td></tr><tr><td colspan=\"1\" rowspan=\"1\"> <p>java.lang.reflect.Constructor</p> </td><td colspan=\"1\" rowspan=\"1\"> <p>代表字节码中的构造方法字节码。代表类中的构造方法。</p> </td></tr><tr><td colspan=\"1\" rowspan=\"1\"> <p>java.lang.reflect.Field</p> </td><td colspan=\"1\" rowspan=\"1\"> <p>代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</p> </td></tr></tbody></table>\n<p>接下来我们就来看看反射到底怎么用。</p>\n<h1>三. 具体使用</h1>\n<p>下面<strong>壹哥</strong>就用一个案例来让大家感受一下反射的牛逼之处。</p>\n<h2>1. 常规实现</h2>\n<p>我们知道，在Java中的实体类总会有一些固定的方法，比如每个属性的 get()、set()方法，还有初始化属性创建对象的构造方法，打印对象信息的toString()等方法。假如我们在没有使用注解的情况下，需要创建2个普通的实体类：Cat、Dog，代码如下所示：</p>\n<pre><code class=\"language-java\"> public class Cat {\n    private String name;\n    private int age;\n\n    public Cat() {\n    }\n    \n    public Cat(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cat{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class Dog{\n    private String name;\n    private int age;\n\n    public Dog() {\n    }\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Dog{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}</code></pre>\n<p>我们想在案例代码中<strong>创建对象</strong>并打印<strong>对象信息</strong><strong>，如下所示：</strong></p>\n<pre><code class=\"language-java\">public class Demo01 {\n    public static void main(String[] args){\n        Cat cat = new Cat(\"招财\", 1);\n        System.out.println(cat.toString());\n\n        Dog dog = new Dog(\"旺财\",2);\n        System.out.println(dog.toString());\n    }\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"172\" src=\"..\\..\\static\\image\\1ecc0f776561483281e08842034e2269.png\" width=\"1200\"/></p>\n<p>在上面这两个实体类中，都存在着名字相同、但方法体不同的toString()方法。如果我们在实体类中不重写toString() ，直接通过对象调用 toString()，打印的结果不会是对象的信息。</p>\n<p><img alt=\"\" height=\"192\" src=\"..\\..\\static\\image\\7ac9837582374d5896c948afb0f94621.png\" width=\"1200\"/></p>\n<p>我们可以使用<strong>反射</strong>给两个实体类，甚至更多的实体类自动加上toString()方法，从而达到减少代码量的目的。</p>\n<p></p>\n<h2>2. 反射实现</h2>\n<h3>2.1 创建父类BaseEntity</h3>\n<p>首先我们创建一个父类BaseEntity</p>\n<pre><code class=\"language-java\">public class BaseEntity {\n    @Override\n    public String toString() {\n        //1.获取反射对象\n        Class&lt;? extends BaseEntity&gt; clazz = this.getClass();\n        //2.创建 StringBuffer 对象拼接字符串\n        StringBuffer sb = new StringBuffer();\n        //3.通过 getSimpleName() 获取类名并拼接\n        sb.append(clazz.getSimpleName());\n        //拼接大括号\n        sb.append(\"{\");\n        //4.获取所有成员变量对象\n        Field[] fields = clazz.getDeclaredFields();\n        Object value = null;\n        for (int i = 0; i &lt; fields.length; i++) {\n            //5.获取成员变量对象\n            Field field = fields[i];\n            //6.打开访问权限\n            field.setAccessible(true);\n            //7.通过 getName() 获取属性名并拼接\n            sb.append(getName());\n            sb.append(\"=\");\n            //8.通过 get() 传递 this 获取对象的属性值\n            try {\n                value = field.get(this);\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            //9.判断是否为 String 类型的属性，是则添加单引号\n            if(field.getType() == String.class){\n                sb.append(\"'\");\n                sb.append(value);\n                sb.append(\"'\");\n            }else{\n                sb.append(value);\n            }\n            //10.判断是否为最后一个属性对象\n            if(i == fields.length-1){\n                sb.append(\"}\");\n            }else{\n                sb.append(\", \");\n            }\n        }\n        //11.通过 toString() 转换成字符串并返回\n        return sb.toString();\n    }\n}</code></pre>\n<h3>2.2 继承父类</h3>\n<p>然后将两个实体类 Cat 和 Dog，都继承 BaseEntity且不重写 toString()方法。</p>\n<pre><code class=\"language-java\">public class Cat extends BaseEntity{\n    private String name;\n    private int age;\n\n    public Cat() {\n    }\n    \n    public Cat(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class Dog extends BaseEntity{\n    private String name;\n    private int age;\n\n    public Dog() {\n    }\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}</code></pre>\n<h3>2.3 运行测试</h3>\n<p>接下来在案例类中<strong>创建对象</strong>并打印<strong>对象信息，</strong><strong>这里</strong>会发现打印结果不再是之前没有 toString() 的情况，而是会分别打印出各自对象的信息。</p>\n<pre><code class=\"language-java\">public class Demo01 {\n    public static void main(String[] args){\n        Cat cat = new Cat(\"招财\", 1);\n        System.out.println(cat.toString());\n\n        Dog dog = new Dog(\"旺财\",2);\n        System.out.println(dog.toString());\n    }\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"156\" src=\"..\\..\\static\\image\\1af66e45184b4ad7aa27a0fd3e7a27e9.png\" width=\"1200\"/></p>\n<p> 我们可以在以上案例中发现，toString()方法在运行状态时，通过反射获取了运行对象的类属性，进行了信息的拼接，从而达到了减少实体类代码量的目的，提高了代码的复用性。</p>\n<h1>四. 小结</h1>\n<p>使用反射技术，可以让我们进行动态的创建对象和编译，体现出很高的代码灵活性。但反射技术却对性能有一定的影响，它不如静态创建对象那样来得直接高效。所以反射既有好处也有缺点，但好处远大于缺点。当然，今天<strong>壹哥</strong>只是通过这样的一个小案例，给大家展现了反射技术强大功能的冰山一角，它还有更多的神奇之处有待于我们继续挖掘，请大家继续关注我哦。</p>\n<p></p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\463e23ce5ed14dedb2d94e84bfdec9d2.png\" width=\"1200\"/></p>\n<p> </p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-23 09:20:53", "summary": "在中有这么一个很骚的技术，几乎贯穿了所有主流的框架，在所有主流框架的底层中你都可以看见它的身影，这个技术就是反射。关于反射，有很多小白会觉得很难，搞不清楚到底是怎么回事，也不知道该怎么用，今天壹哥就来"}