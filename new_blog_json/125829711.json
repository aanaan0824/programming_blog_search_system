{"blogid": "125829711", "writerAge": "码龄1年", "writerBlogNum": "85", "writerCollect": "2633", "writerComment": "3307", "writerFan": "2912", "writerGrade": "6级", "writerIntegral": "8211", "writerName": "小黎的培培笔录", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125829711.jpg", "writerRankTotal": "1688", "writerRankWeekly": "250", "writerThumb": "2970", "writerVisitNum": "77796", "blog_read_count": "932", "blog_time": "于 2022-08-05 12:30:00 发布", "blog_title": "「Java 数据结构」：环形链表和约瑟夫问题。", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8\">一、环形链表</a></p>\n<p id=\"1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9\">1、创建结点</a></p>\n<p id=\"%C2%A02%E3%80%81%E6%B7%BB%E5%8A%A0%E5%B0%8F%E7%BB%93%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02%E3%80%81%E6%B7%BB%E5%8A%A0%E5%B0%8F%E7%BB%93%E7%82%B9\"> 2、添加小结点</a></p>\n<p id=\"%C2%A03%E3%80%81%E6%98%BE%E7%A4%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03%E3%80%81%E6%98%BE%E7%A4%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"> 3、显示循环链表</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98\">二、约瑟夫问题</a></p>\n<p id=\"%C2%A01%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"> 1、问题描述</a></p>\n<p id=\"2%E3%80%81%E9%A6%96%E5%85%88%E7%A1%AE%E5%AE%9A%E5%9C%88%E5%A4%A7%E5%B0%8F%E5%8F%8A%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"> <a href=\"#2%E3%80%81%E9%A6%96%E5%85%88%E7%A1%AE%E5%AE%9A%E5%9C%88%E5%A4%A7%E5%B0%8F%E5%8F%8A%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE\">2、首先确定圈大小及开始位置</a></p>\n<p id=\"3%E3%80%81%E5%87%BA%E5%9C%88%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"> <a href=\"#3%E3%80%81%E5%87%BA%E5%9C%88%E6%93%8D%E4%BD%9C\">3、出圈操作</a></p>\n<p id=\"4%E3%80%81%E5%87%BA%E5%9C%88%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"> <a href=\"#4%E3%80%81%E5%87%BA%E5%9C%88%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">4、出圈方法完整代码</a></p>\n<hr id=\"hr-toc\"/>\n<h1>一、环形链表</h1>\n<blockquote>\n<h2 id=\"1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9\">1、创建结点</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\2eac8a89db7a45f59bc60058dcc365c8.png\"/></p>\n<p>        环形链表其实也很好理解，就是将单链表的头和尾连接起来，就形成了环形链表。</p>\n<pre><code>public class Node {\n    public int data;\n    public Node next;\n\n    public Node(int data) {\n        this.data = data;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"data=\" + data +\n                '}';\n    }\n}</code></pre>\n<h2 id=\"%C2%A02%E3%80%81%E6%B7%BB%E5%8A%A0%E5%B0%8F%E7%BB%93%E7%82%B9\"> 2、添加小结点</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\1bf451816c044abb8b6a4cc07a5cb15b.png\"/></p>\n<p style=\"text-align:center;\">写一个方法用来添加结点，这个方法我们直接传入需要创建结点的个数，然后再方法中直接创建出一个简单的循环链表。代码解析：</p>\n<pre><code>//创建一个first结点，当前没有编号\npublic Node first = new Node(-1);</code></pre>\n<pre><code>   \n     public void add(int n){\n        //其实循环链表，一个结点也可以循环，但这里为了方便后面介绍约瑟夫问题\n        //我们循环的结点不能少于两个所以做了这个判断。\n        if (n &lt; 2){\n            System.out.println(\"n的值不正确\");\n            return;\n        }\n\n        //辅助结点\n        Node end = null;\n\n        //使用for循环来创建链表\n        for (int i = 1; i &lt;= n; i++) {\n\n            //根据编号创建结点\n            Node node = new Node(i);\n\n            //如果是第一个结点，first头指向第一个结点，end表示尾，回过头来指向first，形成循环\n            if(i == 1){\n                first = node;\n                end = first;\n            }else{\n                //先将尾部end的next指向新的结点node，然后end后移指向新的结点，\n                //再将end的next指向第一个结点first，这样就形成了循环\n                end.next = node;\n                end = end.next;\n                end.next = first;\n            }\n\n        }\n    }</code></pre>\n<h2 id=\"%C2%A03%E3%80%81%E6%98%BE%E7%A4%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"> 3、显示循环链表</h2>\n<p>        显示循环链表的方式和单链表的显示方式差不多，关键点在于如何判断循环链表的结束，我们的尾部是指向头部的，所以当尾部的next指向的结点等于头部，就是最后一个结点，此时就退出循环。</p>\n<pre><code>  public void show(Node first){\n\n        //判断循环链表是否为空\n        if (first.next == first){\n            System.out.println(\"列表为空！\");\n            return;\n        }\n        \n        //辅助结点\n        Node temp = first;\n        //循环打印\n        while (true){\n\n            System.out.println(temp);\n            //最后一个结点的next等于first，就退出\n\n            if (temp.next == first){\n                break;\n            }\n\n            temp = temp.next;\n        }\n    }</code></pre>\n<p></p>\n</blockquote>\n<hr/>\n<h1 id=\"%E4%BA%8C%E3%80%81%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98\">二、约瑟夫问题</h1>\n<blockquote>\n<h2 id=\"%C2%A01%E3%80%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"> 1、问题描述</h2>\n<p>       约瑟夫(Joseph)问题的一种描述是:编号为1,2,...n的n个人按顺时针方向围坐一圈，每人持有一个密码(正整数)。开始选任一个正整数作为报数上限值m, 从第一个人开始按顺时针方向自1开始顺序报数, 报到m时停止报数。 报m的人出列, 将它的密码作为新的m值。 试设计一个程序求出出列顺序。</p>\n<h2 id=\"2%E3%80%81%E9%A6%96%E5%85%88%E7%A1%AE%E5%AE%9A%E5%9C%88%E5%A4%A7%E5%B0%8F%E5%8F%8A%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE\">2、首先确定圈大小及开始位置</h2>\n<p><strong>▶ 写一个方法</strong></p>\n<p><strong>        </strong>start ：表示从哪一个位置开始</p>\n<p>        m ： 报多少个数，报到m个数的人出列</p>\n<p>        n ：圈总的大小</p>\n<pre><code>public void goOutCircle(int start,int m, int n){\n\n}</code></pre>\n<p><strong>▶ 确定圈的大小</strong></p>\n<p><strong>        </strong>传入的n要多余两个人才能玩，然后传入的开始位置start不能在总人数之外，符合条件，我们调用前面我们介绍的方法add（）进行循环链表的创建。</p>\n<pre><code>        if (n &gt;= 2 &amp;&amp; start &lt;= n){\n\n            add(n);\n\n        }else {\n\n            System.out.println(\"输入异常！\");\n\n            return;\n\n        }</code></pre>\n<p><strong>▶ 确定开始位置</strong></p>\n<p><strong>        </strong>first是指向链表的第一个的，但我们开始的位置可以是任何一个结点，所以先声明辅助结点temp，遍历循环链表，如果结点的data和传入的start的值相等，就找到了开始位置，将first 指向开始位置temp，然后循环就结束了。</p>\n<pre><code>        Node temp = first;\n\n        while (true){\n            if (temp.data == start){\n                first = temp;\n                break;\n            }\n            temp = temp.next;\n        }</code></pre>\n<h2 id=\"3%E3%80%81%E5%87%BA%E5%9C%88%E6%93%8D%E4%BD%9C\">3、出圈操作</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\54292541bd4b4747b249e4efcbd98a8c.png\"/></p>\n<p>        首先，我们需要一个辅助的结点end，然后假设开始位置在数据2的地方，first和end都指向数据2，数的次数为m = 2。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\7bdab6c8f9004eacab4b200afb4c6b25.png\"/></p>\n<p>        开始数数，数据3的位置是数数m = 2 的时候，这时数据3应该出圈。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\ca6f56d07b0847b49dec789cd696cc18.png\"/></p>\n<p>        first继续指向要出圈数据的下一个结点，end所在的结点指向first指向的结点，就让数据3出圈了。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\7f3db4a0254940c1bee135b863737c99.png\"/></p>\n<p>        结点出圈后，first和end又同时指向一个结点，m 又开始重新计数 ，如此循环下去即可。</p>\n<pre><code>        Node end = first;\n\n        while (true) {\n            //当总数只有一个的时候，循环结束。\n            if (n == 1) {\n                System.out.println(\"胜利者为\" + first + \"号\");\n                break;\n            }\n\n            //用for循环，循环次数为 m - 1，因为本身要数一个数\n            for (int i = 1; i &lt;= m - 1; i++) {\n                //first指向下一个结点\n                first = first.next;\n                //如果找到了要出圈的结点，first是正好指向它的\n                if (i == m - 1) {\n                    //first指向的这个结点出圈\n                    System.out.println(first + \"号出圈\");\n                    //每出圈一个，总数减一\n                    n--;\n                    //first继续指向下一个结点\n                    first = first.next;\n                    //此时end还在出圈结点的前一个位置，end的next指向first\n                    end.next = first;\n                    //end也同样指向first指向的结点\n                    end = first;\n                    break;\n                }\n                //如果没有到要出圈的结点，end继续跟着first指向同一个结点\n                end = first;\n            }\n\n        }</code></pre>\n<h2 id=\"4%E3%80%81%E5%87%BA%E5%9C%88%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">4、出圈方法完整代码</h2>\n<pre><code>    public void goOutCircle(int start,int m, int n){\n        //首先确定圈的大小\n        if (n &gt;= 2 &amp;&amp; start &lt;= n){\n            add(n);\n        }else {\n            System.out.println(\"输入异常！\");\n            return;\n        }\n\n        //确定数数的位置\n        Node temp = first;\n        while (true){\n            if (temp.data == start){\n                first = temp;\n                break;\n            }\n            temp = temp.next;\n        }\n\n        //进行遍历\n        Node end = first;\n        while (true) {\n            if (n == 1) {\n                System.out.println(\"胜利者为\" + first + \"号\");\n                break;\n            }\n\n            for (int i = 1; i &lt;= m - 1; i++) {\n                first = first.next;\n                if (i == m - 1) {\n                    System.out.println(first + \"号出圈\");\n                    n--;\n                    first = first.next;\n                    end.next = first;\n                    end = first;\n                    break;\n                }\n                end = first;\n            }\n\n        }\n\n    }</code></pre>\n<p><strong>运行结果：</strong></p>\n<p style=\"text-align:center;\"><strong>        <img alt=\"\" src=\"..\\..\\static\\image\\96f208d47d1f40b290c00068fb258f23.png\"/></strong></p>\n<p></p>\n</blockquote>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-05 12:30:00", "summary": "目录一、环形链表、创建结点、添加小结点、显示循环链表二、约瑟夫问题、问题描述、首先确定圈大小及开始位置、出圈操作、出圈方法完整代码一、环形链表、创建结点环形链表其实也很好理解，就是将单链表的头和尾连接"}