{"blogid": "126593257", "writerAge": "码龄3年", "writerBlogNum": "46", "writerCollect": "45", "writerComment": "16", "writerFan": "14", "writerGrade": "3级", "writerIntegral": "528", "writerName": "爽帅_", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126593257.jpg", "writerRankTotal": "32754", "writerRankWeekly": "75622", "writerThumb": "40", "writerVisitNum": "35071", "blog_read_count": "645", "blog_time": "已于 2022-08-31 22:12:05 修改", "blog_title": "【C++】泛型编程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>        为了让函数或者类有更好的复用性，C++引入了摸板的技术。让不同的数据类型，能使用到相同的函数或者类中去，这种编程的思想也叫做泛型编程。</p>\n</blockquote>\n<hr/>\n<h1>一、摸板</h1>\n<pre><code class=\"language-cpp\">void Swap(int &amp;left,int &amp; right)\n{\n    int temp =left;\n    left = right;\n    right = temp;\n}</code></pre>\n<p>        在学习C语言的时候，写一个交换变量数据的函数，会发现一个问题就是这个函数只能用来交换int类型的变量，那么我要交换其他类型的变量要怎么办呢，多写几个对应的函数吗？这种方法其实不是很好，因为会造成代码冗余。</p>\n<p>        这里使用C++的摸板可以轻松的解决</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt; \nvoid Swap(T&amp; left, T&amp; right)\n{\n    T temp=left;\n    left=right;\n    right=temp;\n}\n\nint i=1,j=2;\ndouble x=1.1,y=2.2;\nSwap(i,j);\nSwap(x,y);</code></pre>\n<p>        摸板格式template&lt; typename(也可以用class) + 后面的类型名字T是随便取的 &gt;，Ty,K,V,一般是大写字母或者单词首字母大写。</p>\n<p>        T 代表是一个摸板类型(当成变量的类型就可以了int、char这些，也可以是自定义类型)。</p>\n<p>PS：这里交换变量使用了一个中间变量，那么可以不可以直接使用异或来交换呢，其实不行，因为异或交换要 int 类型才可以使用。</p>\n<p><span style=\"color:#a2e043;\"><span style=\"background-color:#511b78;\">PS：这里int和double类型的两个调用，实际上调用的不是同一个函数。</span></span></p>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nT Add(const T&amp; left,const T&amp; right)\n{\n    return left+right;\n}\n\n//编译器自动推演，隐式实例化\nAdd(1.1,2);     //这里推演实例化出错\n\n//强制类型转换后可以继续使用\nAdd((int)1.1,2);\nAdd(1.1,(double)2);</code></pre>\n<p>        摸板有个隐式类型的转换，直接输入数据编译器就能根据数据判断是什么类型的变量，但是要注意，如果两个变量类型不同，那么它就不会知道你到底想用哪个类型的变量。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//或者定义两个参数\n\ntemplate&lt;class T1，class T2&gt;\nT1 Add(const T1&amp; left,const T2&amp; right)\n{\n    return left+right;\n}\n\n//这里就可以编译器自动推导。\n\nAdd(1.1,2);\nAdd(1,2.2); //这里会出警告，double到int会损失精度</code></pre>\n<p>        摸板中定义两个类型的参数，这里编译器就会帮你自动强制转换数据类型，这里double类型和int类型计算，int类型就会被提升为double类型。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//显示实例化\nAdd&lt;int&gt;(1.1,2);</code></pre>\n<p>        使用这种方法也可以解决，明确的告知编译器，我就是想用 int 类型的变量。</p>\n<p></p>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nT* func(int n)\n{\n    T* a = new T[n];\n    return a;\n}\n\n\n//所以这里必需显示实例化\nfunc&lt;int&gt;(20);</code></pre>\n<p>        这种摸板函数没法自动推演，编译器不知道返回值的类型，所以使用的时候必须明确告知要返回变量的类型。</p>\n<pre><code class=\"language-cpp\">int Add(int left,int right)\n{\n    \n}\n\ntemplate&lt;class T&gt;\nT Add(T left,T right)\n{\n\treturn left+right;    \n}\n\n\nAdd(1,2);</code></pre>\n<p>        摸板函数和普通函数可以同时存在，调用时会先去检查有没有专门处理int类型的函数，如果没有就调用摸板。</p>\n<p>       </p>\n<h1>二、类摸板</h1>\n<p>         </p>\n<pre><code class=\"language-cpp\">typedef char STDateType;\n\nclass Stack\n{\n    private:\n    \tSTDateType *a;\n    \tint top;\n    \tint capacity;\n};\n\nStack st1;\nStack st2;</code></pre>\n<p>        在C语言中为了方便使用不同类型的变量，这里一般用宏定义。但是并没有解决在两个对象中，一个存储变量int，一个存储double。</p>\n<p>        也就是说定义的<span style=\"color:#fe2c24;\">所有对象只能存储一种类型的数据</span>。但是实际使用的时候是需要灵活变通的，要多种类型一起使用包括自定义类型。所以类也可以使摸板。</p>\n<p><span style=\"color:#ffd900;\"><span style=\"background-color:#1a439c;\">PS：函数能根据传入的数据推导出数据类型，但是类摸板不能，所以使用摸板类实例化对象的时候，必须显示实例化。</span></span></p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nclass Stack\n{\n\tpublic:\n    \tStack(size_t capacity = 4)\n            :_a(nullptr)\n          \t ,_capacity(0)\n             ,_top(0);\n        {\n            if(capacity &gt; 0)\n            {\n                _a = new T[capacity];  \n               _capacity = capacity;\n                _top = 0;\n            }\n        }\n    \t\n    \t~Stack()\n        {\n            delete[] _a;\n            _a = nullptr;\n            _capacity = _top =0;\n        }\n    \n    \tvoid Push(const T&amp; x)\n        {\t\n             //如果插入满了，开辟新空间\n             if(_top == _capacity){\n\t\t\t\tsize_t NewCapacity = _capatcity == 0 ? 4 : _capacity*2;\n                T* tmp =new T[NewCapacity];\n                if(_a){\n                    memcpy(tmp,_a,sizeof(T)*_top);\n                    delete[] _a;\n\t\t\t\t}\n                \n                 _a = tmp;\n                 _capacity = NewCapacity;\n             }\n            \n            _a[_top]=x;\n            ++_top;\n        }\n    \t\n    \tvoid Pop()\n        {\n            assert(_top &gt; 0);\n            --_top;\n        }\n    \n    \n    \tbool Empty()\n        {\n            return _top == 0;\n        }\n    \n    \tT&amp; Top() //这边使用了引用，那么可以修改,不想修改要加const。\n        {\n            assert(_top &gt; 0);\n            return _a[_top-1];\n        }\n    \n    private:\n    \tT *_a;\n    \tint _top;\n    \tint _capacity;\n\n};\n\nStack&lt;int&gt; st1;\nStack&lt;char&gt; st2;\n    \nst1.Top()++;</code></pre>\n<p>        这里两个Stack类型的变量就可以存储多种类型的数据了，包括自定义类型，而摸板其实就是为了能更好的支持自定义类型而创建出来的。</p>\n<p><span style=\"color:#38d8f0;\"><span style=\"background-color:#511b78;\">PS：摸板不支持分离编译，声明放在.h 定义放在 .cpp ！！！！但是可以在当前文件分开写，所以可以创建一个.hpp的文件，这个是约定俗称的，方便人一看到就知道是什么意思。</span></span><br/>         </p>\n<pre><code class=\"language-cpp\">//声明定义在本文件分离。\ntemplate&lt;class T&gt;\nclass Stack\n{\n\tpublic:\n    \tStack(size_t capacity = 4)\n            :_a(nullptr)\n          \t ,_capacity(0)\n             ,_top(0);\n        {\n            if(capacity &gt; 0)\n            {\n                _a = new T[capacity];  \n               _capacity = capacity;\n                _top = 0;\n            }\n        }\n    \t\n    \t~Stack()\n        {\n            delete[] _a;\n            _a = nullptr;\n            _capacity = _top =0;\n        }\n    \n    \tvoid Push(const T&amp; x);\n    \tvoid Pop();\n    \tbool Empty();\n    \tT&amp; Top();\n\n    private:\n    \tT *_a;\n    \tint _top;\n    \tint _capacity;\n\n};\n\n//注意这里的写法\ntemplate&lt;class T&gt;\nvoid Stack&lt;T&gt;::Push(const T&amp; x)\n{\t\n       if(_top == _capacity){\n                \n            size_t NewCapacity = _capatcity == 0 ? 4 : _capacity*2;\n                \n            T* tmp =new T[NewCapacity];\n                \n            if(_a){\n                memcpy(tmp,_a,sizeof(T)*_top);\n                delete[] _a;\n\t\t\t}\n                \n                _a = tmp;\n                _capacity = NewCapacity;\n                \n       }\n            \n       _a[_top]=x;\n       ++_top;\n}</code></pre>\n<p>        </p>\n<h1>三、STL</h1>\n<blockquote>\n<p>         </p>\n<p>         标准模板库（Standard Template Library，STL）是<a href=\"https://baike.baidu.com/item/%E6%83%A0%E6%99%AE%E5%AE%9E%E9%AA%8C%E5%AE%A4/489303?fromModule=lemma_inlink\" title=\"惠普实验室\">惠普实验室</a>开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在<a href=\"https://baike.baidu.com/item/%E6%83%A0%E6%99%AE%E5%AE%9E%E9%AA%8C%E5%AE%A4/489303?fromModule=lemma_inlink\" title=\"惠普实验室\">惠普实验室</a>工作时所开发出来的。虽说它主要出现到C++中，但在被引入C++之前该技术就已经存在了很长时间。</p>\n<p>        STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（<a href=\"https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3%E5%99%A8/3803342?fromModule=lemma_inlink\" title=\"迭代器\">迭代器</a>），几乎所有的代码都采用了<a href=\"https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E7%B1%BB/6768650?fromModule=lemma_inlink\" title=\"模板类\">模板类</a>和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>\n</blockquote>\n<p>        STL六大组件：<span style=\"color:#fe2c24;\">容器（数据结构）</span>，<span style=\"color:#ff9900;\">算法</span>，<span style=\"color:#ffd900;\">迭代器</span>，<span style=\"color:#a2e043;\">配接器</span>，<span style=\"color:#38d8f0;\">仿函数</span>，<span style=\"color:#956fe7;\">空间配置器</span>。   </p>\n<h2>sting：</h2>\n<p><img alt=\"\" height=\"284\" src=\"..\\..\\static\\image\\4f3b6a6a7dba4453a5b91f69146804d7.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"144\" src=\"..\\..\\static\\image\\7bb01fe75f9541b6a6f42176dbbb8a35.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#include&lt;string&gt;\n\n//string是一个宏定义\ntypedef basic_string&lt;char&gt; string;\n\nstring str; //等价于\nbasic_string&lt;char&gt; str\n</code></pre>\n<p>        使用string容器要加载头文件，并且其中的很多函数都在std的命名空间中，string是 basic_string&lt;char&gt; 的宏，其中 basic_string 就是类名了。        </p>\n<p>         <img alt=\"\" height=\"290\" src=\"..\\..\\static\\image\\de61a637e5b44abe97ebc028dcb3aaab.png\" width=\"1200\"/></p>\n<p>        basic_string根据不同的摸板参数，宏定义了多个不同的容器，定义多个是为了匹配对应的编码，因为不同的编码大小不一样。</p>\n<p>       这里先学习string容器和其中常用函数的使用，这个是一通百通的，因为其他的容器相似度非常高，也是编写库的人特意设置的，学会这一个其他的也会使用了。</p>\n<p></p>\n<h3>构造函数：</h3>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\b17d4a3f1a8548eebba0c51876e97efd.png\" width=\"1200\"/></p>\n<p>        string可以用同样的string对象来进行初始化，也可以使用字符串(char*)来进行初始化(隐式类型装)。</p>\n<p>        还可以指定要初始化的数据段，指定开始的位置，和要初始化的长度。如果给与的长度大于了字符串后面的长度，那么把后面全部复制下来。</p>\n<p>        其中如果不指定长度，其默认的缺省值为一个静态变量<span style=\"color:#fe2c24;\">npos</span>，值为-1。</p>\n<p><span style=\"color:#a2e043;\"><span style=\"background-color:#511b78;\">PS：npos的类型为size_t，是一个无符号的整形，给值-1会变成一个非常大的整数。那么其意思就很明确了，不输入指针的长度，则从开始位置往后全部给要初始的对象。</span></span></p>\n<p>   </p>\n<p><img alt=\"\" height=\"389\" src=\"..\\..\\static\\image\\b4fdd668562e4c05af6e1d86a82446f7.png\" width=\"979\"/></p>\n<p>        这种对象的初始化的方法，在STL里面是通用的，其他容器大差不差。</p>\n<p>        </p>\n<h3>重载运算符[ ]:</h3>\n<p><img alt=\"\" height=\"175\" src=\"..\\..\\static\\image\\c1b8677101f84734b2f7dfb874a9469e.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"488\" src=\"..\\..\\static\\image\\ce2c8a08e3f4400a9e5db0ed644d0e4b.png\" width=\"910\"/></p>\n<p>        我们知道字符串其实就是一个字符数组，可以通过[ ]访问每个单个的字符，所以string里面重载了运算符[ ]，给我们用来访问字符。</p>\n<p>        <span style=\"color:#fe2c24;\">[ ]返回的是字符的引用</span>，所以可以通过这个运算符修改单个的字符。</p>\n<p></p>\n<h3>迭代器：</h3>\n<p>        迭代器每个容器因为其特性不一样实现的方法也不一样，在string里面因为其本质还是使用数组来存储数据的，所以这里的迭代器就是指针。</p>\n<p>        既然[ ]、指针就能遍历string，为何要定义一个迭代器出来？因为并不是所有的容器都是使用指针来实现迭代器的。但是<span style=\"color:#fe2c24;\">迭代器使用的方法都是一样的，是STL遍历容器的通用方法</span>。</p>\n<p>        <img alt=\"\" height=\"535\" src=\"..\\..\\static\\image\\4c0e041b9a454042a7ec44995af4916b.png\" width=\"886\"/></p>\n<p>        使用string里面的一个宏定义iterator来定义一个变量it，it就是string容器的迭代器，其使用方法和指针相似。</p>\n<pre><code class=\"language-cpp\">it!=s.end();\n\nit&lt;s.end();</code></pre>\n<p>        这里迭代器判断是不是到了容器尾部的时候，最好使用!=，而不是使用&lt;符号，虽然两个效果在这里是一样的(因为string底层迭代器就是指针)。但是在其容器中会出错(比如list)。</p>\n<p></p>\n<pre><code class=\"language-cpp\">for (auto ch : s)\n{\n\tcout &lt;&lt; ch &lt;&lt; endl;\n}\n\n//想修改用使用引用\nfor(auto &amp; ch : it)\n{\n    ch++;\n}</code></pre>\n<p>        范围for的底层就是迭代器。</p>\n<p><span style=\"color:#ffd900;\"><span style=\"background-color:#1a439c;\">PS：范围for里面的迭代器，能自动遍历，自动迭代，自动判断结束 。</span></span></p>\n<p></p>\n<h3>反向迭代器：</h3>\n<p><img alt=\"\" height=\"442\" src=\"..\\..\\static\\image\\d0e2adb63fc242f0a8c9a817cc82394c.png\" width=\"899\"/></p>\n<p>        其实看名字就大概能明白其是什么意思了，就是从容器尾部往开始位置遍历。</p>\n<p><span style=\"color:#38d8f0;\"><span style=\"background-color:#511b78;\">PS：要注意这里迭代器++是往容器前面走(左边)，--是往容器后面走(右边)。</span></span></p>\n<p></p>\n<h3>常量迭代器：</h3>\n<p>        </p>\n<p><img alt=\"\" height=\"365\" src=\"..\\..\\static\\image\\6e7a0ba3a67c48df8bca67bcff98cf4b.png\" width=\"889\"/></p>\n<p></p>\n<p></p>\n<h3>常量反向迭代器：</h3>\n<p><img alt=\"\" height=\"401\" src=\"..\\..\\static\\image\\07effdc261f846448392f267e9f5c2a0.png\" width=\"1070\"/></p>\n<p></p>\n<p><span style=\"color:#ff9900;\"><span style=\"background-color:#511b78;\">PS：常量迭代器是不能修改对象中的数据的。 </span></span></p>\n<p></p>\n<h3>push_back():</h3>\n<p>        push_back()这个函数只能在string尾部<span style=\"color:#fe2c24;\">插入一个字符</span>。</p>\n<p>        <img alt=\"\" height=\"420\" src=\"..\\..\\static\\image\\4fd219ed594c4b82b365f5ffd6a88dd0.png\" width=\"730\"/></p>\n<p></p>\n<h3>append():</h3>\n<p>        <img alt=\"\" height=\"425\" src=\"..\\..\\static\\image\\36f8dbd64b7a40b58112a6b6b06c3c7c.png\" width=\"1200\"/></p>\n<p>        在string尾部插入一个字符串，并且可以指定插入字符串的开始位置和长度。</p>\n<p> <img alt=\"\" height=\"400\" src=\"..\\..\\static\\image\\b9b5f71618c247e7baaf71bd10a1ac69.png\" width=\"1020\"/></p>\n<p></p>\n<h3>重载+=符号：</h3>\n<p>        <img alt=\"\" height=\"464\" src=\"..\\..\\static\\image\\55cb926c321f4396be018d7a9bc77536.png\" width=\"741\"/></p>\n<p>        </p>\n<p>        用法跟append()差不多，只不过看起来更容易理解了，用起来也方便。</p>\n<p></p>\n<h3>insert(): </h3>\n<p>        <img alt=\"\" height=\"493\" src=\"..\\..\\static\\image\\3ab922c89c98408cbc2504a6e6c2eb37.png\" width=\"1200\"/></p>\n<p>         在指定位置插入一个字符串，同样可以指定插入字符串的开始位置和长度。</p>\n<p></p>\n<p><img alt=\"\" height=\"294\" src=\"..\\..\\static\\image\\29625bdcaa474d0db7e3b30141eb8493.png\" width=\"1032\"/></p>\n<p></p>\n<h3>reserve()和resize():</h3>\n<p>        在插入数据的时候，函数内部就已经帮我们判断了如果容器满了，则会重新扩容空间。但是我们如果知道要输入数据大小，那么就可以提前开辟空间。</p>\n<p>        reserve()开辟空间，resize()则是开辟空间并初始化。</p>\n<p><img alt=\"\" height=\"605\" src=\"..\\..\\static\\image\\6f921d94a8ae400b80b15ce6985f4e04.png\" width=\"1200\"/></p>\n<p><span style=\"color:#a2e043;\"><span style=\"background-color:#511b78;\">PS：string内置了一个函数capacity()，可以得知现在string的容量。</span></span></p>\n<p></p>\n<h3>c_str:</h3>\n<p><img alt=\"\" height=\"195\" src=\"..\\..\\static\\image\\cfb18015299d446295a0d2cc0be3d825.png\" width=\"1200\"/></p>\n<p>        有时候需要兼容C语言，所以里面包含了兼容C语言的函数，c_str()函数返回的是const char*的类型。</p>\n<pre><code class=\"language-cpp\">string filename(\"test.cpp\");\nFILE* fp = fopen(filename.c_str,\"r\");\nchar ch=getc(fp);\n\nwhile(ch != EoF){\n    cout&lt;&lt;ch;\n    char ch=getc(fp);\n}\n</code></pre>\n<p>        这里filename和filename.c_str是有区别的，filename 是以容器的size()为准。filename.c_str是常量字符串，以“\\0”为结束标识。</p>\n<p></p>\n<h3>find():</h3>\n<p><img alt=\"\" height=\"311\" src=\"..\\..\\static\\image\\0285102bb43a4d2dac27f1e55ee64524.png\" width=\"1200\"/></p>\n<p>         查找字符串，查找到了返回匹配字符串第一个字符的位置，没找到返回npos。</p>\n<p><img alt=\"\" height=\"270\" src=\"..\\..\\static\\image\\9c445250f85446aeb6912d4db4bd6112.png\" width=\"1049\"/></p>\n<p>        find()，在查找字符串的时候，可以指定开始查找的位置，也可以指定查找的字符串长度。但是要注意，如果有多个字符串可以匹配上，这里只返回第一个匹配上的位置。</p>\n<p>        </p>\n<h3>find_first_of():</h3>\n<p>        <img alt=\"\" height=\"305\" src=\"..\\..\\static\\image\\fee626274f90412299ced9e28027fcf1.png\" width=\"1200\"/></p>\n<p>        这个函数比较难理解，它不是要把完全匹配的字符串位置给找出来。<span style=\"color:#fe2c24;\">而是匹配的字符串的字符，谁第一个在主串出现，就返回该处匹配的位置</span>。</p>\n<p></p>\n<p><img alt=\"\" height=\"277\" src=\"..\\..\\static\\image\\bb7e2a1de8ce4ef5aaeb8e6bd0708747.png\" width=\"1020\"/></p>\n<p>        这里e是最先在主串里面出现的，所以这里返回1。匹配失败返回npos。</p>\n<p></p>\n<h1>四、模拟实现string</h1>\n<pre><code class=\"language-cpp\">namespace STR\n{\n\n    class string\n    {    \n    public:\n\n        //构造函数 使用初始化列表\n\t\tstring(const char* str = \"\")           //这里的缺省值是 \\0\n\t\t\t:_str(new char[strlen(str)+1])     //加1 是加上 \\0的空间\n\t\t\t,_size(strlen(str))\n\t\t\t,_capacity(strlen(str))     //capacity不包括 \\0\n\t\t{\n\t\t\tstrcpy(_str, str);\n\t\t}\n\n\n\n        //构造函数  另一种写法\n        string(const char* str = \"\") //这里的缺省值是 \\0\n\t\t{\n\n            //这样写可以复用变量，如果写在初始列表，变量初始顺序要严格匹配声明顺序。\n\n\t\t\t_size = strlen(str);\n\t\t\t_capacity = _size;\n\t\t\t_str = new char[_capacity + 1];    //加1 是加上 \\0的空间\n\t\t\t\n\t\t\tstrcpy(_str, str);\n\t\t}\n\n\n        //析构函数\n        ~string()\n        {\n            delete[] _str;\n            _str = nullptr;\n            _capacity = _size = 0;\n        }\n    \n\n    private:\n        char* _str;\n\t\tsize_t _size;    //字符串的长度 不包括\\0\n\t\tsize_t _capacity;    //数组的容量 不统计\\0\n\n\n        static size_t nops_t;\n    };\n\n}\n\n//静态变量 类外面定义\nsize_t STR::string::nops_t = -1;\n</code></pre>\n<p><span style=\"color:#a2e043;\"><span style=\"background-color:#511b78;\">PS：这里为了能方便与库里面的string进行区分，这里自定义了一个命名空间STR。</span></span></p>\n<p>        这里开始写拷贝构造函数的时候就要注意了，成员变量中定义了一个数组，那么就要注意深浅拷贝的问题，为了避免浅拷贝，这里初始化的时候要为 _str 重新开辟一段空间。</p>\n<p>传统写法：</p>\n<pre><code class=\"language-cpp\">//拷贝构造函数  传统写法\nstring(const string&amp; str)\n\t:_str(new char[str._capacity + 1])    //新开辟一段空间\n\t, _size(str._size)\n\t, _capacity(str._capacity)\n{\n\n    strcpy(_str, str._str);\n\n}</code></pre>\n<p> 现代写法：</p>\n<pre><code class=\"language-cpp\">const char* c_str() const  //const string* const this\n{\n\treturn _str;\n}\n\n\nvoid swap(string&amp; str)\n{\n    std::swap(_str, str._str);\n    std::swap(_size, str._size);\n    std::swap(_capacity, str._capacity);\n}\n\n//拷贝构造函数  现代写法\nstring(const string&amp; str)\n\t   :_str(nullptr)\n\t\t, _size(0)\n\t\t, _capacity(0)\n{\n    //注意这里是str._str是char*类型的字符串,这里复用了构造函数\n    string tmp(str._str); \n\n    swap(tmp);\n}</code></pre>\n<p>        拷贝构造函数的现代写法非常巧妙、简洁，并且借用了构造函数来进行深拷贝。</p>\n<p>        这里定义了一个交换函数swap()，里面复用了库里面的swap()来交换数据。</p>\n<p></p>\n<p><img alt=\"\" height=\"700\" src=\"..\\..\\static\\image\\c6758d05ea19412ab07bf0196624033e.png\" width=\"1200\"/></p>\n<p>        库里面的swap()被摸板化了，可以直接进行自定义类型的交换，但是这里会<span style=\"color:#fe2c24;\">多次调用拷贝构造，浪费效率</span>。</p>\n<p>        所以这里在string内部又重载了一个 swap()函数，其本身只是进行变量数据的交换，所以效率比较高。  </p>\n<p>        现代写法的思路就是把传进来的字符串重新生成一个对象，再把对象的数据跟自己交换，而且由于tmp是函数内部的局部变量，出了函数就会调用析构函数销毁，不用手动释放地址。</p>\n<p>        这种写法也可以在重载赋值符号上，<span style=\"color:#fe2c24;\">重载赋值符号的时候也要考虑深浅拷贝的问题</span>。</p>\n<pre><code class=\"language-cpp\">//传统写法\nstring&amp; operator=(const string&amp; str)\n{\n\n\tif (this!=&amp;str) {\n\n\t\tdelete[] _str;\n\t\t_str = new char[str._capacity + 1];  //+1是给\\0留的空间\n\t\tstrcpy(_str, str._str);\n\t\t_capacity = str._capacity;\n\t\t_size = str._size;\n\n\t}\n\n\t\treturn *this;\n}\n\n//现代写法\nstring&amp; operator=(const string&amp; str)\n{\n\tif (this != &amp;str) {\n\n\t\tstring tmp(str._str);\n\t\tswap(tmp);\n\t}\n\t\treturn *this;\n}\n</code></pre>\n<p>        套路一样把传进来的字符串重新生成一个对象，再把对象的数据跟自己交换。</p>\n<pre><code class=\"language-cpp\">string&amp; operator=(const string&amp; str)\n{\n\tif(this!=&amp;str){\n        string tmp(str);\n        std::swap(*this,tmp); //这里使用库里面的swap,会造成错误\n    }\n    return *this;\n}</code></pre>\n<p>        还有一点， 如果重载赋值符号，使用库里面的swap()进行交换，swap（*this，tmp），函数内部还是使用的赋值符号，会再去调用赋值，所以这里会死循环，造成栈溢出。</p>\n<pre><code class=\"language-cpp\">//重载[]  返回pos位置的字符的引用\n\n//常量的调用 ，只能读，不能写\nconst char&amp; operator[](size_t pos) const\n{\n\tassert(pos &lt; _size);\n\treturn _str[pos];\n}\n\n//普遍调用， 可以读，可以写\nchar&amp; operator[](size_t pos)\n{\n\tassert(pos &lt; _size);\n\treturn _str[pos];\n}</code></pre>\n<p>        重载[ ]非常简单，直接复用数组的[ ]即可。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//扩容\nvoid reserve(size_t n)\n{\n\tif (n &gt; _capacity) {\n\n\t\tchar* tmp = new char[n + 1];\n\t\tstrcpy(tmp, _str);\n\t\tdelete[] _str;\n\n\t\t_str = tmp;\n\t\t_capacity = n;\n\n\t}\n\n}\n\n//开空间并初始化\nvoid resize(size_t n,char ch='\\0')\n{\n\t//1.比当前的空间大\n\tif (n&gt;_size) {\n\n\t\treserve(n);\n\t\tfor (size_t i = _size; i &lt; n; i++) {\n\n\t\t\t_str[i] = ch;\n\t\t\t\t\t\n\t    }\n\n\t\t_str[n] = '\\0';\n\t\t_size = n;\n\t}\n\telse {\t//2.比当前的空间小\n\t\t_str[n] = '\\0';\n\t\t_size = n;\n\n    }\n}</code></pre>\n<p>        扩容函数，如果string内部已经有内容的话，要把数据拷贝到新开辟的空间里面去。开辟空间的时候要多留一个字节给\"\\0\"。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//插入一个字符串\nvoid push_back(char cn)\n{\n\n\tif (_size == _capacity) { //如果空间满了，要扩容\n\n\t\t//如果string容器里面没有数据，开4个字节的空间。\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t}\n\n\t\t_str[_size] = cn;\n\t\t_size++;\n\t\t_str[_size] = '\\0';\n\n}\n\n//插入一个字符串\nvoid append(const char* str)\n{\n\tsize_t len = strlen(str);\n\tif (_size + len &gt; _capacity) {\n\n\t\treserve(_size + len);\n\n\t}\n\n\tstrcpy(_str + _size, str);\n\t//strcat(_str,str) 也可以使用这个函数追加，不过要找\\0，效率低\n\t_size += len;\n}\n\n\nvoid append(const string&amp; str)\n{\n\tappend(str._str);\n}\n\n\nvoid append(size_t n, char ch)\n{\n\n\tfor (size_t i = 0; i &lt; n; i++) {\n\t\tpush_back(ch);\n\t}\n\n}\n\n\nstring&amp; operator+=(char ch)\n{\n\tpush_back(ch);\n\treturn *this;\n}\n\n\nstring&amp; operator+=(const char* str)\n{\n\tappend(str);\n\treturn *this;\n}\n\n</code></pre>\n<p>        插入字符或者字符串，实现其实比较简单，主要是注意判断如果数组的容量占满了要重新开辟空间。</p>\n<p>        </p>\n<pre><code class=\"language-cpp\">//插入字符\nstring&amp; insert(size_t pos, char ch)\n{\n\tassert(pos &lt;= _size);\n\tif (_size == _capacity) {\n\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\n\t}\n\n\tsize_t end = _size + 1;\n\twhile (end &gt; pos) {\n\n\t\t_str[end] = _str[end - 1];\n\t\tend--;\n\t}\n\n\t_str[pos] = ch;\n\t_size++;\n\n\treturn *this;\n}\n\n//插入字符串\nstring&amp; insert(size_t pos, const char* str)\n{\n\tassert(pos &lt;= _size);\n\tsize_t len = strlen(str);\n\n\tif (_size + len &gt; _capacity) {\n\t\treserve(_size + len);\n\t}\n\n\tsize_t end = _size + len;\n\twhile (end &gt;= pos + len) {\n\n\t\t_str[end] = _str[end - len];\n\t\tend--;\t\n\t}\n\n\tstrncpy(_str + pos, str, len);\n\t_size += len;\n\n\treturn *this;\n}</code></pre>\n<p>        在指定位置插入时，要把插入位置后面的数据往后挪动。这里不要用strcpy()会把\\0也拷贝进去，所以这里使用了strncay()；</p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\84f3d326cb6c456d88defa9a6ba99bb0.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">size_t end = _size;\nwhile (end &gt;= pos) {\n    \n    //这里pos==0,end减到最后变为-1的时候，会变得非常大，造成越界。\t\t\n    _str[end + 1] = _str[end];\n    end--;\n}\n\nsize_t end = _size+1;\nwhile (end &gt; pos) {\n\t\t\t\t\n    _str[end] = _str[end-1];\n    end--;\n}</code></pre>\n<p><span style=\"color:#38d8f0;\"><span style=\"background-color:#1a439c;\">PS：这里挪动数据有两种写法，最好使用下面的写法，因为上面在开头插入数据时，最后end会变为-1，而这里end是size_t类型的数据，会变得非常大，从而出错。</span></span></p>\n<p></p>\n<pre><code class=\"language-cpp\">void push_back(char ch)\n{\n    insert(_size,ch);\n}\n\nvoid append(const char* str)\n{\n    intsert(_size,str);\n}</code></pre>\n<p>        其实也可以先实现insert()，然后复用实现push_back()和append()。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//删除\nvoid erase(size_t pos, size_t n = nops_t) //如果不写，那么全删除了\n{\n\tassert(pos &lt; _size);\n\n\t//如果没给参数，或者给的参数过大，则pos后面的全部删除\n\tif (n == nops_t || n + pos &gt; _size) {\n\t\t_str[0] = '\\0';\n\t\t_size = 0;\n\t}\n\telse\n\t{\n\t\t//把要删除的数据，用后面的数据覆盖\n\t\tstrcpy(_str + pos, _str + pos + n);\n\t\t_size -= n;\n\n\t}\n}\n\nvoid clear()\n{\n\t_str[0] = '\\0';\n\t_size = 0;\n}</code></pre>\n<p>        删除函数比较简单没什么要注意的地方。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//查找字符\nsize_t find(char ch, size_t pos = 0) \n{\n\tassert(pos &lt; _size);\n\tfor (size_t i = pos; i &lt; _size;i++) {\n\t\tif (ch==_str[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn nops_t;\n}\n\n//查找字符串\nsize_t find(const char* sub, size_t pos = 0)\n{\n\tassert(pos &lt; _size);\n\tconst char* ret = strstr(_str + pos,sub);\n\tif (ret == nullptr) {\n\t\treturn nops_t;\n\t}\n\telse {\n\t\treturn ret - _str;\n\t}\n\n}</code></pre>\n<p>        这里使用了库里面的串匹配函数，这里也可以自己写个KMP算法来查找，不过其实效率也差不多。</p>\n<p>        这里返回查找到字符串位置的写法比较巧妙，<span style=\"color:#fe2c24;\">使用的是指针减指针的知识点，获得的是中间元素的个数，而_str又是数组的起始地址，所以这里就返回的就是查找到的位置</span>。</p>\n<p></p>\n<pre><code class=\"language-cpp\">bool operator&gt;(const string&amp; str)const\n{\n\t//大于0就是真\n\treturn strcmp(_str, str._str) &gt; 0;\n}\n\nbool operator==(const string&amp; str)const\n{\n\treturn strcmp(_str, str._str) == 0;\n}\n\t\t\nbool operator&lt;=(const string&amp; str)const\n{\n\treturn  !(*this &gt; str);\n}\n\t\t\nbool operator&gt;=(const string&amp; str)const\n{\n\treturn *this &gt; str || *this == str;\n}\n\t\t\nbool operator&lt;(const string&amp; str)const\n{\n\treturn !(*this &gt;= str);\n}\n\t\t\nbool operator!=(const string&amp; str)const\n{\n\treturn !(*this == str);\n}</code></pre>\n<p>        C语言里面字符串是可以比较大小的，所以这里也要重载一下，这里直接复用strcmp()，以后比较字符串的大小的时候，就可以直接使用运算符，很方便也容易理解。</p>\n<p></p>\n<pre><code class=\"language-cpp\">string substr(size_t pos, size_t len = nops_t)const\n{\n\tassert(pos &lt; _size);\n\tsize_t realLen = len;\n    //如果没给参数，或者给的参数过大，则pos后面的全部返回为子串\n\tif (len == nops_t || pos + len &gt; _size)\n\t{\n\t\trealLen = _size - pos;\n\t}\n\n\tstring sub;\n\tfor (size_t i = 0; i &lt; realLen;i++) {\n\t\tsub += _str[pos + i];\n\t}\n\n\treturn sub;\n}</code></pre>\n<p>        把主串中的一段数据作子串返回。分割字符串的时候用的比较多。</p>\n<p></p>\n<pre><code class=\"language-cpp\">//重载流提取和流插入\n//实现成全局函数，避免和this指针的位置问题。\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const string&amp; str);\n\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, string&amp; str);\n\n\nstd::ostream&amp; STR::operator&lt;&lt;(std::ostream&amp; out, const string&amp; str)\n{\n\tfor (size_t i = 0; i &lt; str.size(); i++)\n\t{\n\t\tout &lt;&lt; str[i];\n\t}\n\n\treturn out;\n}\n\n\n\n//这种写法+=多次，扩容多次\nstd::istream&amp; STR::operator&gt;&gt;(std::istream&amp; in, string&amp; str)\n{\n\t\n\tchar ch;\n\t//in&gt;&gt;ch 不能使用这个，这个无法检查到空格\n\tch = in.get();\n\twhile (ch != ' ' &amp;&amp; ch != '\\n') {\n\n\t    str += ch;\n\t\tch = in.get();\n\n\t}\n\n\treturn in;\n}\n\n\n\nstd::istream&amp; STR::operator&gt;&gt;(std::istream&amp; in, string&amp; str)\n{\n\tstr.clear();\n\tchar ch;\n\n\tconst size_t N = 32;\n\tchar buff[N]={0};\n\tsize_t i = 0;\n\n\tch = in.get();\n\t//其思路是，buff满了，再追加到str里面\n\twhile (ch != ' ' &amp;&amp; ch != '\\n') {\n\t\n\t\tbuff[i++] = ch;\n\t\tif (i == N-1) {\n\t\t\t\n\t\t\tbuff[i] = '\\0';\n\t\t\tstr += buff;\n\t\t\ti = 0;\n\n\t\t}\n\t\tch = in.get();\n\t\n\t}\n\n\tbuff[i] = '\\0';\n\tstr += buff;\n\n\treturn in;\n\n}</code></pre>\n<p>        这里流提取比较好理解，但是流插入要注意一下，流插入是可以连续对多个对象进行插入的。</p>\n<p>       <span style=\"color:#fe2c24;\"> 但是使用cin&gt;&gt;ch；这种写法不能接收到空格和换行符</span>，因为它本身检查到空格和换行就是输入的间隔，会造成这里退出不了循环，所以这里使用了cin里面自带的get()函数。</p>\n<p>        如果输入的内容很长，使用+=的效率很低。所以这里使用一个数组先接收一定的数据，数组的数据满了才添加到对象里面(和缓冲区的概念相似)。</p>\n<p></p>\n<hr/>\n<pre><code class=\"language-cpp\">//迭代器\ntypedef char* iterator;\n//const 迭代器\ntypedef const char* const_iterator;\niterator begin()\n{\n\treturn _str;\n}\n\niterator end()\n{\n\treturn _size + _str;\n}\n</code></pre>\n<p>        迭代器的实现也比较简单，因为string就是用数组来存储的字符串，用指针也可以访问，这里只不过是把指针进行了宏定义，但是这种写法也是可以使用范围for的。</p>\n<p><img alt=\"\" height=\"676\" src=\"..\\..\\static\\image\\e6188ad7bdbe40beac84dba68d81ea4e.png\" width=\"1200\"/></p>\n<p> </p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-31 22:12:05", "summary": "为了让函数或者类有更好的复用性，引入了摸板的技术。让不同的数据类型，能使用到相同的函数或者类中去，这种编程的思想也叫做泛型编程。一、摸板在学习语言的时候，写一个交换变量数据的函数，会发现一个问题就是这"}