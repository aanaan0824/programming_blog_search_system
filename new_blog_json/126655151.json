{"blogid": "126655151", "writerAge": "码龄4年", "writerBlogNum": "270", "writerCollect": "642", "writerComment": "2879", "writerFan": "6460", "writerGrade": "6级", "writerIntegral": "8712", "writerName": "张艳伟_Laura", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126655151.jpg", "writerRankTotal": "1699", "writerRankWeekly": "2129", "writerThumb": "414", "writerVisitNum": "492600", "blog_read_count": "587", "blog_time": "于 2022-09-02 13:15:00 发布", "blog_title": "【Spring】@Autowired和@Resource关键字的区别", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_1\"></a>共同点</h2>\n<p>两个注解的作用一样，都是做bean的注入，在接口只有一个实现类的时候，两个注解可以交替使用。<br/> 两者都可以写在字段和setter方法上，两者如果都写在字段上，那么就不需要再写setter方法</p>\n<h2><a id=\"_5\"></a>不同点</h2>\n<p>@Autowired<br/> @Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;<br/> 只按照byType注入。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cdddc1813647408fbeb5751081aefbe2.png\"/><br/> @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允 许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualififier注解一起使用。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4697c7f2dbf8410890b732a382a4e0b4.png\"/></p>\n<p>@Resource<br/> @Resource默认按照ByName自动注入，由J2EE提供，需要导入javax.annotation.Resource。<br/> @Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的 名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策 略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通 过反射机制使用byName自动注入策略。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\41a8b76cd50d49d1b1be74556bec8fce.png\"/><br/> 注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属 性，而不是直接去操作属性。<br/> 其实@Resource并不是spring的注解，它的包 是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>\n<p>@Resource装配顺序：</p>\n<ul><li>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异 常。</li><li>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li><li>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛 出异常。</li><li>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回 退为一个原始类型进行匹配，如果匹配则自动装配。</li></ul>\n<p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-02 13:15:00", "summary": "共同点两个注解的作用一样，都是做的注入，在接口只有一个实现类的时候，两个注解可以交替使用。两者都可以写在字段和方法上，两者如果都写在字段上，那么就不需要再写方法不同点为提供的注解，需要导入包只按照注入"}