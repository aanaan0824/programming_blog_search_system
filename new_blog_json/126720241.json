{"blogid": "126720241", "writerAge": "码龄4年", "writerBlogNum": "774", "writerCollect": "60839", "writerComment": "37072", "writerFan": "104743", "writerGrade": "10级", "writerIntegral": "172232", "writerName": "兔老大RabbitMQ", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126720241.jpg", "writerRankTotal": "4", "writerRankWeekly": "136", "writerThumb": "88798", "writerVisitNum": "5021594", "blog_read_count": "1506", "blog_time": "于 2022-09-06 10:58:10 发布", "blog_title": "算法之美-用状态机消除递归", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<h3>高级算法思想必备</h3>\n</blockquote>\n<h3>1. 递归的简介</h3>\n<p>我们知道，递归是一种函数调用自身的方法，利用计算机程序运行的天然机制(<strong>即计算机擅长的是解决同一个问题</strong>)，可以大幅度的精简代码，比如使用递归实现一个阶乘：</p>\n<pre><code>long long factorial(int n) {\n    if(n == 1) return 1; // 递归基(出口)\n    return n * factorial(n - 1);\n}</code></pre>\n<h3>2.递归的效率</h3>\n<p>因为递归使用的是系统内存的堆栈来实现，在调用函数时，需要将函数的参数和函数的返回地址压入堆栈中，所以在调用递归函数时，会产生一定的开销，主要开销是用来保存上一次的函数调用现场(运行状态和变量值)，所以，当调用次数过多时，会占用大量的栈空间，可能导致<strong>栈溢出</strong>的问题，所以，在单纯的讨论效率问题上，递归并不是一个很好的设计模式。</p>\n<h3>3.常见的递归算法</h3>\n<p>常见的递归算法有很多，主要是分为两个策略<strong>分而治之</strong>和<strong>减而治之</strong>。</p>\n<p>所谓分而治之，就是求解一个大规模的问题，可以将其划分为多个（通常情况下为两个）子问题，两个问题的规模大体相同。由子问题的解，得到原问题的解。</p>\n<pre><code>// 二分查找\nint sum(int A[], int low, int high)\n{\nreturn (low == high) ? A[low] : sum(A, low, (low + high) &gt;&gt; 1) + sum(A, ((low + high) &gt;&gt; 1) + 1, high);\n}</code></pre>\n<p>所谓减而治之，就是求解一个大规模的问题，可以将其划分为两个子问题，其一是平凡问题，另一个/规模缩减。由子问题的解，得到原问题的解。</p>\n<pre><code>// 递归求数组和\nint sum(int A[], int n)\n{\n    return (n &lt; 1) ? 0 : A[n - 1] + sum(A, n-1);\n}</code></pre>\n<p>如归并排序、快速排序以及搜索等算法就是使用的分而治之的策略。</p>\n<p></p>\n<p>我们也观察到，使用递归对于简化问题的效果是极好的，但同时增加了资源的开销，所以，我们在设计算法时，有一些优化方式，如：</p>\n<ul><li> <p>将非尾递归函数变成尾递归函数(可能部分语言不支持)</p> </li><li> <p>将递归的表达式(即自顶向下)转化为递推表达式(自底向上)</p> </li><li> <p>使用状态机等方法模拟递归从而消除递归</p> </li></ul>\n<p><strong>尾递归：</strong></p>\n<p>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。</p>\n<h3>4.状态机的概念</h3>\n<p><strong>状态机</strong>:</p>\n<blockquote>\n<p>状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。</p>\n<p><strong>分为两种，一种称为moore型，一种称为mealy型，其主要差别在于，moore型状态机的输出只由系统内部的状态决定，而mealy型的输出由输入和系统内部的状态共同决定。</strong></p>\n</blockquote>\n<p>先来解释什么是“状态”（ State ）。现实事物是有不同状态的，例如一个自动门，就有 open 和 closed 两种状态。我们通常所说的状态机是有限状态机，也就是被描述的事物的状态的数量是有限个，例如自动门的状态就是两个 open 和 closed 。</p>\n<p>状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型。说白了，一般就是指一张状态转换图。例如，根据自动门的运行规则，我们可以抽象出下面这么一个图。</p>\n<p>自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。open 状态下如果读取关门信号，状态就会切换为 closed 。</p>\n<p><img alt=\"\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NjaHJvZGluZ2VyY2F0c3MvRmlndXJlQmVkQG1hc3Rlci9pbWcvMjAyMDA2MTcxODIxNDIucG5n?x-oss-process=image/format,png\"/></p>\n<p>状态机的全称是有限状态自动机，自动两个字也是包含重要含义的。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。例如对于自动门，给定初始状态 closed ，给定输入“开门”，那么下一个状态时可以运算出来的。</p>\n<p>自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。open 状态下如果读取关门信号，状态就会切换为 closed 。</p>\n<p>状态机的全称是有限状态自动机，自动两个字也是包含重要含义的。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。例如对于自动门，给定初始状态 closed ，给定输入“开门”，那么下一个状态时可以运算出来的。</p>\n<p>这样状态机的基本定义我们就介绍完毕了。</p>\n<h3>5.使用状态机消除递归</h3>\n<p>知道了状态机的概念以后，我们先来回顾一下系统运行递归函数的过程：</p>\n<ul><li> <p>递归过程(自顶向下):如果当前状态不满足递归出口条件，则不断的递归过程，将当前的状态压入堆栈中，直到满足递归出口的条件，停止递归。</p> </li><li> <p>回溯过程(自底向上)：当递归树上的一分支的递归状态结束之后，不断的进行回溯将栈中保存的内容pop出栈，然后计算递归表达式，直到栈空为止，返回最后的计算结果。</p> </li></ul>\n<p>我们可以画出状态图：</p>\n<p><img alt=\"\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NjaHJvZGluZ2VyY2F0c3MvRmlndXJlQmVkQG1hc3Rlci9pbWcvVTgzN1FIRi5wbmc?x-oss-process=image/format,png\"/></p>\n<p>这样，我们利用这个递归的状态机，使用数据结构实现的栈，而不使用系统堆栈，就可以完成整个递归的计算，这里以递归计算阶乘为例子：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n​\nstruct Data {\n    int num; // 方法的参数\n    int return_address; // 方法返回的地址，这里暂时不使用\n};\n​\nstd::stack&lt;Data&gt; my_stk;\n​\nint execute_factorial(int n) {\n    int state = 1; // 初始状态为1\n    int res = 1; \n    while(state != 6) { // 当状态为6时结束递归\n        switch(state) {\n            case 1: // 递归初始化状态\n                state = 2;\n                break;\n            case 2: // 判断是否到达递归出口\n                if(n &lt;= 1) {  \n                    res = 1;\n                    state = 4; // 递归过程完成，进入回溯状态\n                } else \n                    state = 3; // 继续递归过程\n​\n                break;\n            case 3: // 递归入栈\n                my_stk.push({n, 0});\n                --n; // 每递归一次n减1\n                state = 2;\n                break;\n            case 4: // 栈是否为空\n                if(my_stk.empty())\n                    state = 6;\n                else\n                    state = 5;\n                break;\n            case 5: // 回溯过程\n                Data tmp =my_stk.top();\n                my_stk.pop();\n                res *= tmp.num;\n                state = 4;\n                break;\n        }\n    }\n    return res;\n}\n​\nint main()\n{\n    std::cout &lt;&lt; execute_factorial(5) &lt;&lt; std::endl;\n    return 0;\n}</code></pre>\n<p>上述代码就是使用状态机对递归进行消除，我们可以对比一下递归版的阶乘和递推版的阶乘，以及使用状态机版的阶乘。</p>\n<p>可以观察到，在递归逻辑较简单的时候，我们一般是将递归化为递推，在递归逻辑较复杂时，我们可以使用状态机来消除递归，虽然代码量稍大，但在某些情况(如很难推算出递推式，或者无法推出递推式)则能很好的简化递归。</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 10:58:10", "summary": "高级算法思想必备递归的简介我们知道，递归是一种函数调用自身的方法，利用计算机程序运行的天然机制即计算机擅长的是解决同一个问题，可以大幅度的精简代码，比如使用递归实现一个阶乘：递归基出口递归的效率因为递"}