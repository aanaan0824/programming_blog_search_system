{"blogid": "125238400", "writerAge": "码龄1年", "writerBlogNum": "48", "writerCollect": "311", "writerComment": "15", "writerFan": "31", "writerGrade": "3级", "writerIntegral": "593", "writerName": "一只路过的菜鸟", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125238400.jpg", "writerRankTotal": "32832", "writerRankWeekly": "26809", "writerThumb": "52", "writerVisitNum": "51699", "blog_read_count": "12662", "blog_time": "已于 2022-09-06 17:01:56 修改", "blog_title": "前端200道面试题及答案（更新中）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"html%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#html%E7%9B%B8%E5%85%B3\">html相关</a></p>\n<p id=\"%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9cookie%E5%92%8CStorage(localStorage%E5%92%8CsessionStorage)%20%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9cookie%E5%92%8CStorage%28localStorage%E5%92%8CsessionStorage%29%20%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F\">1）说一下对cookie和Storage(localStorage和sessionStorage) 的认识和区别？</a></p>\n<p id=\"link%E5%92%8C%40import%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#link%E5%92%8C%40import%E7%9A%84%E5%8C%BA%E5%88%AB\">2）link和@import的区别</a></p>\n<p id=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F\">3）浏览器如何实现不同标签页的通信？</a></p>\n<p id=\"iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">4）iframe的优缺点</a></p>\n<p id=\"canvas-toc\" style=\"margin-left:40px;\"><a href=\"#canvas\">5）canvas</a></p>\n<p id=\"%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9Bh5%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8Ccss3%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9Bh5%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8Ccss3%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F\">6）做项目用到哪些h5新特性和css3新特性？</a></p>\n<p id=\"%E7%94%A8localstorage%E5%92%8CsessionStorage%E5%86%99%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%94%A8localstorage%E5%92%8CsessionStorage%E5%86%99%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F\">7）用localstorage和sessionStorage写过什么？</a></p>\n<p id=\"%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E5%8A%A0%E8%BD%BD%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E5%8A%A0%E8%BD%BD%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F\">8）如何解决页面内容加载缓慢的问题？</a></p>\n<p id=\"cookie%E7%9A%84%E7%89%B9%E7%82%B9*-toc\" style=\"margin-left:40px;\"><a href=\"#cookie%E7%9A%84%E7%89%B9%E7%82%B9*\">9）cookie的特点*</a></p>\n<p id=\"%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B\">10）页面渲染过程</a></p>\n<p id=\"11%EF%BC%89%E7%BD%91%E9%A1%B5%E4%B8%8A%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF-toc\" style=\"margin-left:40px;\"><a href=\"#11%EF%BC%89%E7%BD%91%E9%A1%B5%E4%B8%8A%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF\">11）网页上哪里可以看到请求的所有信息</a></p>\n<p id=\"12%EF%BC%89HTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#12%EF%BC%89HTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0\">12）HTML5的新特性                                                                                                                                       </a></p>\n<p id=\"13%EF%BC%89localstore%E5%92%8Csessionstore%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#13%EF%BC%89localstore%E5%92%8Csessionstore%E7%9A%84%E5%8C%BA%E5%88%AB\">13）localstore和sessionstore的区别</a></p>\n<p id=\"14%EF%BC%89%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E5%8F%82%E6%95%B0%E7%9A%84%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#14%EF%BC%89%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E5%8F%82%E6%95%B0%E7%9A%84%EF%BC%9F\">14）页面之间是怎么传参数的？</a></p>\n<p id=\"15%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4localstrorage%E4%BF%9D%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#15%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4localstrorage%E4%BF%9D%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F\">15）如何在浏览器查看和清除localstrorage保存的数据？</a></p>\n<p id=\"16%EF%BC%89%E5%AF%B9H5%E6%96%B0%E5%A2%9E%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#16%EF%BC%89%E5%AF%B9H5%E6%96%B0%E5%A2%9E%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">16）对H5新增的语义化标签的理解？</a></p>\n<p id=\"css%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#css%E7%9B%B8%E5%85%B3\">css相关</a></p>\n<p id=\"17%EF%BC%89CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9D%83%E5%80%BC%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#17%EF%BC%89CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9D%83%E5%80%BC%EF%BC%9F\">17）CSS选择器的优先级排序，怎么计算权值？</a></p>\n<p id=\"18%EF%BC%89display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#18%EF%BC%89display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB\">18）display：none和visibility：hidden的区别</a></p>\n<p id=\"19%EF%BC%89CSS%E7%9A%84%E7%BB%A7%E6%89%BF%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C.one.%20two%E5%92%8C.one%20%3E%20.two%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%BA%A7%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E8%BF%9E%E7%9D%80%E4%B8%80%E8%B5%B7%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F(%E6%9D%83%E5%80%BC%E7%9B%B8%E5%8A%A0)-toc\" style=\"margin-left:40px;\"><a href=\"#19%EF%BC%89CSS%E7%9A%84%E7%BB%A7%E6%89%BF%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C.one.%20two%E5%92%8C.one%20%3E%20.two%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%BA%A7%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E8%BF%9E%E7%9D%80%E4%B8%80%E8%B5%B7%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%28%E6%9D%83%E5%80%BC%E7%9B%B8%E5%8A%A0%29\">19）CSS的继承选择器，.one. two和.one &gt; .two的区别？两个同级类选择器连着一起写有什么作用？(权值相加)</a></p>\n<p id=\"20%EF%BC%89CSS%E7%9A%84%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#20%EF%BC%89CSS%E7%9A%84%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">20）CSS的引用方式有哪些？它们的区别？</a></p>\n<p id=\"21%EF%BC%89css%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9%E7%AC%A6%EF%BC%9F%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss3%E6%96%B0%E5%A2%9E%E7%9A%84%E4%BC%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%A1%E7%AE%97-toc\" style=\"margin-left:40px;\"><a href=\"#21%EF%BC%89css%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9%E7%AC%A6%EF%BC%9F%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss3%E6%96%B0%E5%A2%9E%E7%9A%84%E4%BC%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%A1%E7%AE%97\">21）css有哪些选择符？可继承的属性有哪些？css3新增的伪元素有哪些？css优先级的计算</a></p>\n<p id=\"22%EF%BC%89fixed%E5%92%8Cabsolute%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#22%EF%BC%89fixed%E5%92%8Cabsolute%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">22）fixed和absolute的区别？</a></p>\n<p id=\"23%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#23%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F\">23）如何实现水平、垂直居中？</a></p>\n<p id=\"24%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%B7%A6%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%9B%BA%E5%AE%9A%EF%BC%8C%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E8%87%AA%E9%80%82%E5%BA%94%3F-toc\" style=\"margin-left:40px;\"><a href=\"#24%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%B7%A6%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%9B%BA%E5%AE%9A%EF%BC%8C%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E8%87%AA%E9%80%82%E5%BA%94%3F\">24）实现左侧边栏固定，其他内容自适应?</a></p>\n<p id=\"25%EF%BC%89css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#25%EF%BC%89css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\">25）css3的新特性</a></p>\n<p id=\"26%EF%BC%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#26%EF%BC%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%9F\">26）了解过哪些页面布局？</a></p>\n<p id=\"27%20%E7%94%A8animation%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8A%A8%E7%94%BB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#27%20%E7%94%A8animation%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8A%A8%E7%94%BB%EF%BC%9F\">27 用animation做过什么？做过哪些动画？</a></p>\n<p id=\"28%20Sass%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#28%20Sass%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F\">28 Sass写一个数组？</a></p>\n<p id=\"29%EF%BC%89rem%E5%87%BA%E7%8E%B0%E5%BE%88%E5%B0%8F%E7%9A%84%E5%B0%8F%E6%95%B0%E6%89%8B%E6%9C%BA%E4%B8%8A%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C-toc\" style=\"margin-left:40px;\"><a href=\"#29%EF%BC%89rem%E5%87%BA%E7%8E%B0%E5%BE%88%E5%B0%8F%E7%9A%84%E5%B0%8F%E6%95%B0%E6%89%8B%E6%9C%BA%E4%B8%8A%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C\">29）rem出现很小的小数手机上会发生什么，</a></p>\n<p id=\"30%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8less-toc\" style=\"margin-left:40px;\"><a href=\"#30%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8less\">30 什么时候用less</a></p>\n<p id=\"31%20animation%E5%92%8Ctransition-toc\" style=\"margin-left:40px;\"><a href=\"#31%20animation%E5%92%8Ctransition\">31 animation和transition</a></p>\n<p id=\"32%20%E7%A7%BB%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%A9%E9%82%A3%E4%B8%AA%E5%9B%BE%E7%89%87%E6%85%A2%E6%85%A2%E6%94%BE%E5%A4%A7-toc\" style=\"margin-left:40px;\"><a href=\"#32%20%E7%A7%BB%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%A9%E9%82%A3%E4%B8%AA%E5%9B%BE%E7%89%87%E6%85%A2%E6%85%A2%E6%94%BE%E5%A4%A7\">32 移入图片让那个图片慢慢放大</a></p>\n<p id=\"33%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#33%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5\">33 盒子模型概念</a></p>\n<p id=\"34%20css%E7%9A%84%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#34%20css%E7%9A%84%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F\">34 引用样式的方式有哪几种？他们的优先级排序怎么样？</a></p>\n<p id=\"35%20px%2Cem%2Crem%2C%25-toc\" style=\"margin-left:40px;\"><a href=\"#35%20px%2Cem%2Crem%2C%25\">35 px,em,rem,%，vm,vh</a></p>\n<p id=\"36%20display%E7%9A%84%E5%80%BC%E5%92%8C%E4%BD%9C%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#36%20display%E7%9A%84%E5%80%BC%E5%92%8C%E4%BD%9C%E7%94%A8\">36 display的值和作用</a></p>\n<p id=\"37%20css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#37%20css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\">37列举两种清除浮动的方法(代码实现或者描述思路)</a></p>\n<p id=\"38%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%80%AA%E5%BC%82%E6%A8%A1%E5%9E%8B%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#38%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%80%AA%E5%BC%82%E6%A8%A1%E5%9E%8B%EF%BC%89\">38 盒子模型（怪异模型）</a></p>\n<p id=\"39%20%E8%B0%88%E8%B0%88fixed%20%EF%BC%8Crelated%20%EF%BC%8C%20absolute-toc\" style=\"margin-left:40px;\"><a href=\"#39%20%E8%B0%88%E8%B0%88fixed%20%EF%BC%8Crelated%20%EF%BC%8C%20absolute\">39 谈谈fixed ，relative ， absolute</a></p>\n<p id=\"40%20float%E5%92%8Cabsolute%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#40%20float%E5%92%8Cabsolute%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">40 float和absolute有什么区别？</a></p>\n<p id=\"41%20css3%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#41%20css3%E6%96%B0%E7%89%B9%E6%80%A7\">41 代码实现3栏效果，左右两栏固定宽度，中间栏随着浏览器宽度自适应变化</a></p>\n<p id=\"42%20css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D-toc\" style=\"margin-left:40px;\"><a href=\"#42%20css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D\">42 css选择器的权重</a></p>\n<p id=\"43%20transition%20transform%20translate%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%20transform%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#43%20transition%20transform%20translate%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%20transform%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">43 transition transform translate 之间的区别 transform的属性有哪些？</a></p>\n<p id=\"44%20css3%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#44%20css3%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8\">44 css3中的选择器</a></p>\n<p id=\"46%20%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%83%8C%E6%99%AF%E8%89%B2%E4%B8%BA%E7%BA%A2%E8%89%B2%EF%BC%8C%E5%8D%8A%E5%BE%84%E4%B8%BA200px%E7%9A%84%E5%9C%86%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%81%9C%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%E5%8A%A8%E7%94%BB-toc\" style=\"margin-left:40px;\"><a href=\"#46%20%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%83%8C%E6%99%AF%E8%89%B2%E4%B8%BA%E7%BA%A2%E8%89%B2%EF%BC%8C%E5%8D%8A%E5%BE%84%E4%B8%BA200px%E7%9A%84%E5%9C%86%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%81%9C%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%E5%8A%A8%E7%94%BB\">46 用CSS实现一个背景色为红色，半径为200px的圆，并设置不停的上下移动动画</a></p>\n<p id=\"javascript%E4%BB%A5%E5%8F%8Aes6%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#javascript%E4%BB%A5%E5%8F%8Aes6%E7%9B%B8%E5%85%B3\">javascript以及es6相关</a></p>\n<p id=\"%C2%A0null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"> null和undefined的区别？</a></p>\n<p id=\"%C2%A0js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"> js的数据类型</a></p>\n<p id=\"%C2%A0js%20%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0js%20%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90\"> js 的继承实现方式有哪些，列举两个例子</a></p>\n<p id=\"eval%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#eval%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">eval是什么？</a></p>\n<p id=\"%C2%A0%E7%94%A8%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E7%94%A8%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F\"> 用什么会导致内存泄漏？</a></p>\n<p id=\"%C2%A0js%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0js%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9F\"> js深度克隆的代码实现？</a></p>\n<p id=\"%C2%A0%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%8C%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%90%8E%E5%8F%B0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%8Chtml%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%9F%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%8C%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%90%8E%E5%8F%B0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%8Chtml%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%9F%9F\"> 同源策略，跨域，后台如何解决跨域，html有哪些标签可以跨域</a></p>\n<p id=\"es6-toc\" style=\"margin-left:40px;\"><a href=\"#es6\">es6</a></p>\n<p id=\"js%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#js%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95\">js自己封装一个方法</a></p>\n<p id=\"%C2%A0jq%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0jq%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F\"> jq用过哪些方法？</a></p>\n<p id=\"%C2%A0promise%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0promise%EF%BC%9F\"> promise？</a></p>\n<p id=\"%C2%A0%E8%A7%A6%E6%91%B8%E6%9C%89%E5%87%A0%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E8%A7%A6%E6%91%B8%E6%9C%89%E5%87%A0%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%9F\"> 触摸有几个事件？</a></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\">什么时候会发生跨域问题</a></p>\n<p id=\"%C2%A0%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"> 匿名函数</a></p>\n<p id=\"%C2%A0This%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0This%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\"> This指向问题</a></p>\n<p id=\"%C2%A0JQ%EF%BC%8CJS%EF%BC%8Cvue%20%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0JQ%EF%BC%8CJS%EF%BC%8Cvue%20%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"> JQ，JS，vue 三者的区别</a></p>\n<p id=\"%C2%A0%E7%94%A8jq%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%81-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E7%94%A8jq%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%81\"> 用jq实现双向绑定！</a></p>\n<p id=\"%C2%A0ajax%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0ajax%E7%9A%84%E5%AE%9E%E7%8E%B0\"> ajax的实现</a></p>\n<p id=\"ajax%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#ajax%E7%9A%84%E5%AE%9E%E7%8E%B0\">ajax的实现</a></p>\n<p id=\"%C2%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%8A%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E3%80%82-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%8A%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E3%80%82\"> 在数组上新增一个方法，实现复制。</a></p>\n<p id=\"%C2%A0%E6%9C%9F%E6%9C%9B%EF%BC%9A%5B1%2C2%2C3%5D.copy()%20%2F%2F%E8%BE%93%E5%87%BA%20%5B1%2C2%2C3%2C1%2C2%2C3%5D-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%9C%9F%E6%9C%9B%EF%BC%9A%5B1%2C2%2C3%5D.copy%28%29%20%2F%2F%E8%BE%93%E5%87%BA%20%5B1%2C2%2C3%2C1%2C2%2C3%5D\"> 期望：[1,2,3].copy() //输出 [1,2,3,1,2,3]</a></p>\n<p id=\"%C2%A0.%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E1%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%94%E5%9B%9E2%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%AC%A13%EF%BC%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0.%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E1%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%94%E5%9B%9E2%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%AC%A13%EF%BC%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82\"> .使用闭包实现一个方法，第一次调用返回1，第二次返回2，第三次3，以此类推。</a></p>\n<p id=\"%C2%A0.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C.then%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E3%80%82-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C.then%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E3%80%82\"> .封装一个函数，参数是定时器的时间，.then执行回调函数。</a></p>\n<p id=\"%C2%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F\"> 说一说前端性能优化有哪些方法？</a></p>\n<p id=\"%C2%A0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%88%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%EF%BC%89%2C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C%E3%80%82-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%88%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%EF%BC%89%2C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C%E3%80%82\"> 一个页面上有大量的图片（大型电商网站）,加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</a></p>\n<p id=\"%C2%A0module.export%E5%92%8Cexport%EF%BC%9F-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"%C2%A0.export%E5%92%8Cexport%20default%3F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0.export%E5%92%8Cexport%20default%3F\"> .export和export default?</a></p>\n<p id=\"%E6%80%8E%E4%B9%88%E5%8E%BB%E5%88%A4%E6%96%AD%E5%87%BA%E6%9D%A5%E6%95%B0%E7%BB%84%E9%87%8C%E9%9D%A2%E5%80%BC%E4%B8%BA1%E7%9A%84%E5%85%83%E7%B4%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%8E%E4%B9%88%E5%8E%BB%E5%88%A4%E6%96%AD%E5%87%BA%E6%9D%A5%E6%95%B0%E7%BB%84%E9%87%8C%E9%9D%A2%E5%80%BC%E4%B8%BA1%E7%9A%84%E5%85%83%E7%B4%A0\">怎么去判断出来数组里面值为1的元素</a></p>\n<p id=\"%C2%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8E%BB%E4%BF%AE%E6%94%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%80%BC%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8E%BB%E4%BF%AE%E6%94%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%80%BC%EF%BC%9F\"> 有一个数组，怎么去修改每一个值？</a></p>\n<p id=\"%C2%A0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D\"> 数组去重</a></p>\n<p id=\"%C2%A0%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6\"> 统计字符串中出现最多的字符</a></p>\n<p id=\"js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:40px;\"><a href=\"#js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\">js垃圾回收机制</a></p>\n<p id=\"%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型、原型链</a></p>\n<p id=\"%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\">作用域链</a></p>\n<p id=\"%E9%97%AD%E5%8C%85-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%97%AD%E5%8C%85\">闭包</a></p>\n<p id=\"%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95\">继承方法</a></p>\n<p id=\"%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95\">辗转相除法</a></p>\n<p id=\"%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2\">数组转字符串</a></p>\n<p id=\"%E4%BA%8C%E7%BA%A7%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E7%BA%A7%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95\">二级下拉菜单</a></p>\n<p id=\"%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F\">图片预加载和懒加载？</a></p>\n<p id=\"bind()%20apply()-toc\" style=\"margin-left:40px;\"><a href=\"#bind%28%29%20apply%28%29\">bind() apply()</a></p>\n<p id=\"const%E7%94%A8%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#const%E7%94%A8%E6%B3%95\">const用法</a></p>\n<p id=\"Utf-8%E7%BC%96%E7%A0%81%E6%B1%89%E5%AD%97%E5%8D%A0%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82-toc\" style=\"margin-left:40px;\"><a href=\"#Utf-8%E7%BC%96%E7%A0%81%E6%B1%89%E5%AD%97%E5%8D%A0%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82\">Utf-8编码汉字占多少个字节</a></p>\n<p id=\"ajax-toc\" style=\"margin-left:40px;\"><a href=\"#ajax\">ajax</a></p>\n<p id=\"js%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#js%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\">js对数组的操作，包括向数组中插入删除数据</a></p>\n<p id=\"%E4%B8%A4%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8Csetinterval%E5%92%8Csettimeout%E3%80%82%E5%9B%A0%E4%B8%BAsettimeout%E6%98%AF%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A6%81%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E6%80%8E%E4%B9%88%E5%81%9A%E3%80%82%EF%BC%88%E7%AD%94%E6%A1%88%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%EF%BC%8C%E5%A4%A7%E6%A6%82%E6%98%AF%E8%BF%99%E6%A0%B7%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%9F%A5%E6%9F%A5%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%A4%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8Csetinterval%E5%92%8Csettimeout%E3%80%82%E5%9B%A0%E4%B8%BAsettimeout%E6%98%AF%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A6%81%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E6%80%8E%E4%B9%88%E5%81%9A%E3%80%82%EF%BC%88%E7%AD%94%E6%A1%88%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%EF%BC%8C%E5%A4%A7%E6%A6%82%E6%98%AF%E8%BF%99%E6%A0%B7%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%9F%A5%E6%9F%A5%EF%BC%89\">两种定时器，setinterval和settimeout。因为settimeout是只执行一次的，如果要执行多次怎么做。（答案：设置一个回调函数，多次调用，大概是这样，你可以去查查）</a></p>\n<p id=\"JS%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:40px;\"><a href=\"#JS%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\">JS内存回收机制</a></p>\n<p id=\"promise%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#promise%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\">promise是什么？能解决什么问题？</a></p>\n<p id=\"%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B9%B6%E8%BF%94%E5%9B%9E%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B9%B6%E8%BF%94%E5%9B%9E%EF%BC%9F\">编程：连接两个数组并返回？</a></p>\n<p id=\"%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9F\">冒泡排序？</a></p>\n<p id=\"%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%90%91%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%90%91%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\">创建新数组，向数组插入数据</a></p>\n<p id=\"es6%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#es6%E6%96%B0%E7%89%B9%E6%80%A7\">es6新特性</a></p>\n<p id=\"js%E5%AF%B9%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#js%E5%AF%B9%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\">js对数组有哪些操作方法</a></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88\">什么是ajax，可以用来做什么</a></p>\n<p id=\"%E8%AE%B2%E4%B8%8B%E4%BD%A0%E5%81%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%8C%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AE%B2%E4%B8%8B%E4%BD%A0%E5%81%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%8C%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD\">讲下你做轮播图的思路，无缝轮播</a></p>\n<p id=\"js%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#js%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8\">js的选择器</a></p>\n<p id=\"js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">js数据类型</a></p>\n<p id=\"%E5%87%8F%E5%B0%91%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%87%8F%E5%B0%91%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95\">减少页面加载时间的方法</a></p>\n<p id=\"%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91\">怎么理解模块化开发</a></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\">什么是闭包，有什么作用？</a></p>\n<p id=\"%E5%AE%9A%E6%97%B6%E5%99%A8%20settimeout%E5%92%8Csetinterval%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8settimeout%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E5%AE%9A%E7%9A%84%E6%97%B6%E9%97%B4%E5%B0%B1%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8%20settimeout%E5%92%8Csetinterval%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8settimeout%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E5%AE%9A%E7%9A%84%E6%97%B6%E9%97%B4%E5%B0%B1%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0\">定时器 settimeout和setinterval的区别，如果用settimeout实现每隔一定的时间就执行一次，怎么实现</a></p>\n<p id=\"%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BB%A51%E5%BC%80%E5%A4%B4%E7%9A%8411%E4%BD%8D%E6%95%B0%E5%AD%97)-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%28%E4%BB%A51%E5%BC%80%E5%A4%B4%E7%9A%8411%E4%BD%8D%E6%95%B0%E5%AD%97%29\">手机号的正则表达式(以1开头的11位数字)</a></p>\n<p id=\"%3Col%3E%3Cli%3E%3C%2Fli%3E%3C%2Fol%3E%E7%BB%93%E6%9E%84%E7%9A%84html%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%9F%90%E4%B8%AAli%E5%B0%B1%E5%BC%B9%E5%87%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC-toc\" style=\"margin-left:40px;\"></p>\n<ol><li></li></ol>\n<p><a href=\"#%3Col%3E%3Cli%3E%3C%2Fli%3E%3C%2Fol%3E%E7%BB%93%E6%9E%84%E7%9A%84html%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%9F%90%E4%B8%AAli%E5%B0%B1%E5%BC%B9%E5%87%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC\">结构的html代码，写原生js实现点击某个li就弹出对应的索引值</a></p>\n<p></p>\n<p id=\"%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%EF%BC%8C%20%E8%A6%81%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8D%E8%83%BD%E5%81%9C%E7%95%99%E5%9C%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%BD%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%EF%BC%8C%20%E8%A6%81%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8D%E8%83%BD%E5%81%9C%E7%95%99%E5%9C%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%BD%8D%E7%BD%AE\">对数组进行随机排序， 要求数组中的每个元素不能停留在原来的位置</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0parse%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E6%9C%89%E6%95%88%E7%9A%84JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90JavaScript%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0parse%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E6%9C%89%E6%95%88%E7%9A%84JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90JavaScript%E5%AF%B9%E8%B1%A1\">代码实现parse方法，将有效的JSON字符串转换成JavaScript对象</a></p>\n<p id=\"%E5%8E%9F%E7%94%9Fjs%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FES6%E6%96%B0%E5%A2%9E%E5%93%AA%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8E%9F%E7%94%9Fjs%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FES6%E6%96%B0%E5%A2%9E%E5%93%AA%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%9F\">原生js的变量类型有哪些？ES6新增哪几个变量类型？</a></p>\n<p id=\"js%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#js%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">js的数组方法有哪些？</a></p>\n<p id=\"es6%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%E7%9A%84%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#es6%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%E7%9A%84%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">es6的有哪些扩展？新增的数组方法有哪些？用什么方法连接两个数组？函数扩展中的箭头函数中的this所指向的是什么？一般函数的this指向的又是什么？</a></p>\n<p id=\"%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F%E5%8F%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F%E5%8F%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F\">用什么方法判断是否是数组？又用什么方法判断是否是对象？</a></p>\n<p id=\"http%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#http%E7%9B%B8%E5%85%B3\">http相关</a></p>\n<p id=\"%E6%B5%8F%E8%A7%88%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8\">浏览器</a></p>\n<p id=\"bootstrap-toc\" style=\"margin-left:0px;\"><a href=\"#bootstrap\">bootstrap</a></p>\n<p id=\"vue%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#vue%E7%9B%B8%E5%85%B3\">vue相关</a></p>\n<p id=\"node%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#node%E7%9B%B8%E5%85%B3\">node相关</a></p>\n<p id=\"4%C2%A0%20module.export%E5%92%8Cexport%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#4%C2%A0%20module.export%E5%92%8Cexport%EF%BC%9F\">4  module.export和export？</a></p>\n<p id=\"%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F\">微信小程序</a></p>\n<p id=\"react-toc\" style=\"margin-left:0px;\"><a href=\"#react\">react</a></p>\n<p id=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3\">数据库相关</a></p>\n<p id=\"%E5%85%B6%E4%BB%96-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%B6%E4%BB%96\">其他</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h1 style=\"margin-left:0;text-align:justify;\"></h1>\n<h1 style=\"margin-left:0;text-align:justify;\"></h1>\n<h1 id=\"html%E7%9B%B8%E5%85%B3\" style=\"margin-left:0;text-align:justify;\">html相关</h1>\n<p></p>\n<ol><li style=\"text-align:justify;\"> <h2 id=\"%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9cookie%E5%92%8CStorage(localStorage%E5%92%8CsessionStorage)%20%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F\">1）说一下对cookie和Storage(localStorage和sessionStorage) 的认识和区别？</h2>\n<ol><li style=\"text-align:justify;\"> <p> session 是一个后端存储空间<br/> 2. cookie / localStorage / sessionStorage 的区别<br/> 存储大小</p> <p>cookie 4kb  <br/> localStorage 5M <br/> 通讯相关</p> <p>cookie 随请求携带<br/> storage 不会自动携带<br/> 操作相关</p> <p>cookie 操作复杂，没有 api，前后端都可以操作<br/> storage 操作简单，有 api，只能前端操作<br/> 存储格式</p> <p>cookie：字符串格式<br/> storageL: 键值对<br/> 时效相关</p> <p>cookie：默认会话级别，可以手动设置<br/> storage：localStorage的存储是永久性的，只有在手动删除或者浏览器被卸载后才会被清除，sessionStorage 是会话，当窗口或者页面关闭后会被清除<br/> 3.loaclStorage 和 sessionStorage 的区别<br/> 跨页面通讯能力<br/> localStorage 随便跨页面<br/> sessionStorage 只是在本页面跳转可以通讯<br/> 时效性<br/> localStorage 是永久<br/> sessionStorage 是会话<br/> 共同点<br/> 不能存储其他数据类型，只能存储字符串数据类型<br/> 如果一定要存储其他数据类型，转成 json 格式存储</p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"link%E5%92%8C%40import%E7%9A%84%E5%8C%BA%E5%88%AB\">2）link和@import的区别</h2>\n<ol><li style=\"text-align:justify;\">  <p>都知道 ，外部引入 CSS 有2种方式，link标签和@import。<br/> 但是它们有何本质区别？<br/> 本人项目中多数情况都使用link方式，但见过某些项目人，自以为@import高大上类似es6，极力吹捧使用@import，就此找了一些资料对此进行比较说明：<br/> 先上结论<br/><strong>慎用@import方式。可以避免考虑@import的语法规则和注意事项，以及不合理的引入顺序导致的资源文件下载顺序混乱和http请求过多。</strong></p> <p>区别1：<br/> link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事物如引入网站标题图标；@import属于CSS范畴，只能加载CSS。</p> &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"XXX<strong>.ico</strong>\"&gt;</li><li style=\"text-align:justify;\"> <p></p> 区别2：<br/> link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。所以会出现一开始没有css样式，闪烁一下出现样式后的页面。 <p></p> <p>区别3：<br/> link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p> <p>区别4：<br/> link支持使用Javascript控制DOM去改变样式；而@import不支持。</p> <p>顺便总结下在html中css有四种引入方式：</p> <p>内联样式<br/> 内联CSS也可称为行内CSS或者行级CSS，它直接在标签内部引入，显著的优点是十分的便捷、高效<br/> 示例：&lt;div style=\"background:red\"&gt;&lt;/div&gt;<br/> 这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个</p> <p>拥有相同的样式，你不得不重复地为每个<br/> 添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。<br/> 嵌入样式<br/> 嵌入方式也称页级CSS或内部CSS，整体是放在head标签里边的，在style标签里边定义样式，作用范围和字面意思相同，仅限于本页面的元素；如果你写的代码超过了几百行，想想每次把代码页拉到最上边都很烦，所以它在可维护性方面较差。<br/> 示例：</p> <p>嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。<br/> 外部样式<br/> 链接方式指的是使用 HTML 头部的 标签引入外部的 CSS 文件。<br/> 示例：</p> <p>这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。<br/> 导入样式<br/> 导入方式指的是使用 CSS 规则引入外部 CSS 文件。<br/> 示例：</p> <p>或者写在css样式中</p> <p>@charset “utf-8”;<br/> @import url(style.css);<br/> *{ margin:0; padding:0;}<br/> .notice-link a{ color:#999;}</p> <p><strong>HTML加载过程：<br/> 　　　　1) 加载HTML-DOM结构</strong></p> <p><strong>2)CSS和JS</strong></p> <p><strong>3)图片和多媒体</strong></p> <p><strong>4)加载事件触发</strong></p> <p>总结：　link和@import都没有放置顺序的要求，但是不同的放置位置可能会造成效果显示的差异。对于link，无论放到哪个位置，都是一边加载数据，一边进行优化，视觉感受很好；而对于@import，放置到哪里，才从哪里开始加载CSS样式，即先加载数据，然后加载样式，如果网速不佳，可能会造成只有数据出来，而样式一点点加载的效果。并且在同一个页面中，调用两种方式，link永远比@import优先级高。</p> <p>在项目中使用的时候，一般在页面中调用方式为link，并且放在head标签中；使用@import除了在CSS文件中，在页面调用时，一般加载第三方的样式会使用到，并且需要放置在页面的底部，不会影响自己的网站。<br/>  </p>        </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F\">3）浏览器如何实现不同标签页的通信？</h2>\n<ol><li style=\"text-align:justify;\"> <p>浏览器内多个标签页之间通信，通俗的讲就是浏览器中开了多个窗口，在其中一个窗口做了一些行为等其他窗口不用刷新也能有相关表现。</p> <p><strong>一、cookie+setInterval方式</strong><br/> 要想在多个窗口中通信，通信的内容一定不能放在window对象中，因为window是当前窗口的作用域，里面的内容只属于当前窗口。而cookie是浏览器的本地存储机制，和窗口无关。</p> <p>将要发送的信息写入cookie：</p> <pre><code class=\"language-javascript\"> var msg = documet.querySelector('#msg');\n if(msg.value.trim() != \"\"){\n \tdocment.cookie = \"msg=\" + msg.value.trim();\n }\n</code></pre> <p><br/><br/><br/> 在另一个页面读取cookie：</p>\n<blockquote>\n<p>  var recMsg = document.querySelector('#recMsg');<br/>  function getValue(key){<!-- --><br/>     var cookies = '{\"'+document.cookie.replace(/=/g,'\":\"').replace(/;\\s+/g,'\", \"')+'\"}';<br/>     cookies = JSON.parse(cookies);<br/>     return cookies[key];<br/>  }<br/>  setInterval(function(){<!-- --><br/>     recMsg.innerHTML = getValue(\"msg1\");<br/>  },500);</p>\n</blockquote> <p><br/><br/> 但是由于仅仅从cookie读取信息不能实时更新，需要手动刷新，因此采用setInterval定时器解决，将读取信息的代码封装成一个函数，在定时器内调用即可</p> <p>缺点：</p> <p>1）cookie空间有限，容量4k<br/> 2）每次http请求都会把当前域的cookie发送到服务器上，浪费带宽<br/> 3）setInterval评率设置过大会影响浏览器性能，过小会影响时效性</p> <p>优点：每个浏览器都兼容</p> <p><strong>二、websocket协议</strong><br/> websocket是一种网络通信协议，因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息，但如果这时服务器有连续变化的状态，那么就只能使用轮询（每个一段时间，就发出一个询问）的方式来询问。因为websocket拥有全双工（full-duplex）通信自然可以实现多个标签页之间的通信。<br/> 发送方先发送消息到WebSocketServer，然后服务端再实时把消息发给接收方</p> <p>用法：新建webSocket文件夹，在该目录下打开终端，运行npm init （npm安装及配置步骤）初始化一个简单的node项目（因为需要引入ws包），一直按回车到结束就初始了一个简单的node项目。再安装ws包，依旧在当前目录下的终端运行npm i -save ws，在webSocket目录下新建sever.js、send.html、reveive.html文件</p> <p><strong>三、localstorage</strong></p> 四、html5浏览器新特性——SharedWorker<br/> WebWorker的升级版，webworker只能在一个窗口内使用，而SharedWorker可以在多个窗口之间通信<br/> SharedWorker也是纯客户端的，没有服务端参与<br/> SharedWorker在客户端有一个自己维护的对象worker.js，消息存储在worker.js的data中<br/> SharedWorker不如localStorage的是接收消息不是自动的，也要用定时器实时从worker.js中获取消息<br/><br/><a class=\"link-info\" href=\"https://blog.csdn.net/jewfer/article/details/122614963\" title=\"原文链接：https://blog.csdn.net/jewfer/article/details/122614963\">原文链接：https://blog.csdn.net/jewfer/article/details/122614963</a></li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">4）iframe的优缺点</h2>\n<ol><li style=\"text-align:justify;\">   <p><strong>一、iframe的优点：</strong><br/> 1、　iframe能够原封不动地把嵌入的网页展现出来。</p> <p>2、　如果有多个网页调用iframe，只需要修改iframe的内容，就可以实现对调用iframe的每一个页面内容的更改，方便快捷。</p> <p>3、　网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性。</p> <p>4、　如果遇到加载缓慢的第三方内容如图标和广告等，可以用iframe来解决。</p> <p><strong>二、iframe的缺点：</strong><br/> 1、　会产生很多页面，不容易管理。</p> <p>2、　在几个框架中都出现上下、左右滚动条时，这些滚动条除了会挤占已经非常有限的页面空间外，还会分散访问者的注意力。</p> <p>3、　使用框架结构时，必须保证正确设置所有的导航链接，否则会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下会导致链接死循环。</p> <p>4、　很多的移动设备（PDA手机）无法完全显示框架，设备兼容性差。</p> <p>5、　iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。</p> <p>现在基本上都是用Ajax来代替iframe，iframe已渐渐退出了前端开发。</p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"canvas\">5）canvas</h2>\n<ol><li style=\"text-align:justify;\"> <p>Canvas介绍<br/> 1.canvas是html5的一个新标签，属于h5的新特性<br/> 2.canvas标签是一个图形的容器，简单点说就是一块画布，你可以在上画矩形，圆形，三角形，折线等等,也可以用来画logo<br/> 3.它是通过javascript来画的，即脚本绘制图形</p> <p>canvas可以用来干啥呢？<br/> 1.制作web网页游戏（但是如果代码写的不咋的游戏可能会非常卡）<br/> 2.数据可视化（这么说你可能不明白，但我告诉你echarts就是基于canvas）<br/> 3.广告banner的动态效果非常适合用canvas制作<br/> 4.canvas还可以用来内嵌一些网页<br/><br/><a class=\"link-info has-card\" href=\"https://blog.csdn.net/u012468376/article/details/73350998\" title=\"原文链接\"><span class=\"link-card-box\"><span class=\"link-title\">原文链接</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://blog.csdn.net/u012468376/article/details/73350998</span></span></a></p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9Bh5%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8Ccss3%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F\">6）做项目用到哪些h5新特性和css3新特性？</h2>\n<ol><li style=\"text-align:justify;\"> <p>1 HTML5 的新特性<br/><strong>增加了新标签、新表单和新特性</strong>；<br/> IE9以上才兼容，如不考虑兼容问题，则可以大量使用（如移动端）；</p> <p>1 重点是常用新特性；<br/> 1.1 HTML5 新增的语义化标签<br/> div 对于搜索引擎来说是没有语义的；</p> <p>header：头部标签<br/> nav：导航标签<br/> article：内容标签<br/> section：定义文档某个区域<br/> aside：侧边栏标签<br/> footer：尾部标签<br/> 主要是针对搜索引擎的<br/> 可以多次使用<br/> 在IE9中需要转为块级元素才能使用<br/> 1.2 HTML5 新增的多媒体标签<br/> 1 音频：audio；<br/> 有 MP3 Wav Ogg 三种格式；<br/> 语法<br/> &lt;audio src=\"文件地址\" controls=\"controls\"&gt;&lt;/audio&gt;<br/> 1<br/> 属性<br/> autoplay autoplay 视频就绪自动播放（谷歌浏览器需要添加muted来解决自动播放问题）；<br/> controls controls 向用户显示播放器控件；<br/> loop loop 播放完是否继续循环播放<br/> src url<br/> Chrome 把音频和视频自动播放禁止了；<br/> 2 视频：video；<br/> 尽量使用 MP4；<br/> 另外还有 Ogg 格式；<br/> 语法：<br/> &lt;video src=\"文件地址\" controls=\"controls\"&gt;&lt;/video&gt;<br/> 1<br/> 属性<br/> autoplay autoplay 视频就绪自动播放（谷歌浏览器需要添加muted来解决自动播放问题）；<br/> controls controls 向用户显示播放器控件；<br/> width px<br/> height px<br/> loop loop 播放完是否继续循环播放<br/> preload auto（预先加载视频）| none（不应加载视频）<br/> src url<br/> poster Imgurl 加载等待的画面图片<br/> muted muted 静音播放<br/> 视频静音后可以自动播放；<br/> 从而不再使用flash等插件<br/> 1.3 HTML5 新增的 input 类型<br/> 验证的时候必须添加 form 表单域；<br/> 使用 submit 进行提交；<br/> type=\"email\"    限制用户输入必须为 Email 类型<br/> type=\"url\"    限制用户输入必须为 URL 类型<br/> type=\"date\"    限制用户输入必须为 date 类型<br/> type=\"time\"    限制用户输入必须为 time 类型<br/> type=\"month\"    限制用户输入必须为 month 类型<br/> type=\"week\"    限制用户输入必须为 week 类型<br/> type=\"number\"    限制用户输入必须为 number 类型<br/> type=\"tel\"    限制用户输入必须为 tel 类型<br/> type=\"search\"    限制用户输入必须为 search 类型<br/> type=\"color\"    限制用户输入必须为 color 类型<br/> type=\"submit\"    提交按钮<br/> 1.4 HTML5 新增的表单属性<br/> 属性    值    说明<br/> required    required    表单拥有该属性表示其内容不能为空，必填<br/> placeholder    提示文本    表单的提示信息，存在默认值将不显示<br/> autofocus    autofocus    自动聚焦属性，页面加载完成后聚焦到指定表单<br/> autocomplete    off/on    浏览器基于之前输入的值，显示出可能的选项，<br/> 默认已经打开，关闭autocomplete=\"off\"<br/> 需要放在表单内，加上name属性，同时提交成功<br/> multiple    multiple    可以多选文件提交<br/> ``` /* 设置占位符颜色 */ input::placeholder { color: springgreen; } ```<br/> 2 CSS3<br/> 存在兼容性问题</p> <p>2.1 属性选择器<br/> 属性选择器可以根据元素特定属性来选择元素，这样就可以不用借助于类或者 id 选择器；<br/> 权重为 0, 0, 1, 0；<br/> 类选择器、属性选择器、伪类选择器权重相同；<br/> input[name=\"username\"] {<!-- --><br/>     outline: none;<br/>     border: 3px solid skyblue;<br/> }<br/><br/> 选择符    简介<br/> E[att]    匹配有 att 属性的 E 元素<br/> E[att=\"val\"]    匹配有 att 属性且属性等于 val 的 E 元素<br/> E[att^=\"val\"]    匹配有 att 属性且值以 val 开头的 E 元素<br/> E[att$=\"val\"]    匹配有 att 属性且值以 val 结尾的 E 元素<br/> E[att*=\"val\"]    匹配有 att 属性且值中含有 val 的 E 元素<br/> 2.2 结构伪类选择器<br/> 根据文档结构来选择元素，常用于根据父级选择器里面的子元素；<br/> /* 选择第一个孩子，且必须是 li */<br/> ul li:first-child {<!-- --><br/>     color: red;<br/> }</p> <p>ul li:nth-child(2) {<!-- --><br/>     color: red;<br/> }</p> <p>// 使用 even 选出奇数行<br/> ul li:nth-child(even) {<!-- --><br/>     background-color: red;<br/>     color: white;<br/> }<br/><br/> ul li:nth-child(even) // 使用 even 选出奇数行<br/> ul li:nth-child(odd) // 使用 odd 选出偶数行<br/> ul li:nth-child(n) // n 是选择所有<br/> n 可以被公示替代<br/> 2n 取出偶数项<br/> 2n + 1 取出奇数项<br/> 5n 取出 5 的倍数项<br/> n + 5 从第五项开始<br/> -n + 5 前五项<br/> 数字可以是任何数字<br/> div:nth-child(n) 会包含所有标签类型，同时需要满足设置的标签类型，都满足方能选中；<br/> div:nth-of-type(n) 只包含指定元素，如此处为div；<br/> 选择符    简介<br/> E:first-child    匹配父元素中的第一个子元素 E<br/> E:last-child    &gt;匹配父元素中的最后一个子元素 E<br/> E:nth-child(n)    &gt;匹配父元素中的第 n 个子元素 E<br/> E:first-of-type    指定类型 E 的第一个<br/> E:last-of-type    指定类型 E 的最后一个<br/> E:nth-of-type(n)    指定类型 E 的第 n 个<br/> 2.3 伪元素选择器<br/> 伪元素选择器可以用于利用 css 创建新标签元素，不需要 HTML 标签，从而简化 HTML 结构；</p> <p>after 和 before 创建的元素是行内元素；</p> <p>新创建的元素在文档树中是找不到的；</p> <p>语法：element::before()；</p> <p>after 和 before 必须有 content 属性；</p> <p>伪元素选择器和标签选择器一样，权重为0, 0, 0, 1；</p> <p>选择符    简介<br/> ::before    在元素内部的前面插入内容<br/> ::after    在元素内部的后面插入内容<br/> div {<!-- --><br/>     width: 200px;<br/>     height: 200px;<br/>     background-color: pink;<br/> }</p> <p>div::before {<!-- --><br/>     /* content是必须要写的，元素内容 */<br/>     content: 'before 伪元素选择器';<br/> }</p> <p>div::after {<!-- --><br/>     /* content是必须要写的，元素内容 */<br/>     content: 'after 伪元素选择器';<br/> }<br/><br/> content 必须填写，可以写空字符串；</p> <p>在伪元素中使用 iconfont：</p> <p>@font-face {<!-- --><br/>     font-family: \"iconfont\";<br/>     src: url('iconfont.eot?t=1587189598280');<br/>     /* IE9 */<br/>     src: url('iconfont.eot?t=1587189598280#iefix') format('embedded-opentype'),<br/>         /* IE6-IE8 */<br/>         url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAJwAAsAAAAABiAAAAIjAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCcAooRgE2AiQDCAsGAAQgBYRtBzIbbgXILrBt2JMiJESQDXTjExAAiOD5/b7Nue9+1bRqcaNJFE0LNDyRiFs3oa1TOqFoJv/9X7p0TKPyfLfcQ01/I//fmLm0hedxGiERBoSECkU85Jegb+7hAvs8l9ObQAdyV32gXPegNQYNoF4cUKB7YBRZCWXcMHbBC3xMoG5GQ+7k7HiBqsxeFYj3b7QB1UJAllm6KpQbDmbxWUk1PaVv4FP0/finF1WSUsGuuny5smH6i5NVPE4ePQSEIAEdL6HAFpCJ28bEuYJgXEE9UbQAjlUe/DKZBHZxVItgf51d2gRTMBn84q0UIMFjUYYbkzYR5Rf7pEf216s366Re+xcwRT8rDtKBHILvT23nf7WRwc97HpmzYS5Q3cwZfL5s4EA2FLYtZU3WOJ6UD9tWV8cE9vT9TTWOrpUJVaMJrorpDIWqJTKzWyhp2EZZ1T7qNm2ONwywgsg1bPgACF2fSNp+oND1Q2b2FyVj/yjrRoG6+xhc2LASb+rHH8gQstF8R9eKI+U6pB6Xn0jfA4Pzioi/EWduGLutTjm9oYh4iS3ZQ/dEFCqOQ1yD5ygIYkw49siSliOS9Ntt1fSmlhWHUHeMEYMgNmR6h1yWWEQFk0W98vkTot0FDNzRV5e+ISzjzo66WjoDyI02GtT3KK9kHrQeIRSksFgIrcE8EgjEUNI8z0MsosWZEEv0tZ1Raqi2tb0+/LtTUGebUjg1herHN0akfQsAAAAA') format('woff2'),<br/>         url('iconfont.woff?t=1587189598280') format('woff'),<br/>         url('iconfont.ttf?t=1587189598280') format('truetype'),<br/>         /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */<br/>         url('iconfont.svg?t=1587189598280#iconfont') format('svg');<br/>     /* iOS 4.1- */<br/> }</p> <p>.iconfont {<!-- --><br/>     font-family: \"iconfont\" !important;<br/>     font-size: 16px;<br/>     font-style: normal;<br/>     -webkit-font-smoothing: antialiased;<br/>     -webkit-text-stroke-width: 0.2px;<br/>     -moz-osx-font-smoothing: grayscale;<br/> }</p> <p>div::after {<!-- --><br/>     position: absolute;<br/>     font-family: \"iconfont\" !important;<br/>     font-size: 16px;<br/>     font-style: normal;<br/>     -webkit-font-smoothing: antialiased;<br/>     -webkit-text-stroke-width: 0.2px;<br/>     -moz-osx-font-smoothing: grayscale;<br/>     /* top: ; */<br/>     content: '\\e77b';<br/> }<br/><br/> 原本直接放在“ iconfont ”类中的样式放在对应伪类中，然后将“&amp;#x”改为“\\”即可（如  ，在content中变为 \\e77b）；</p> <p>2.4 CSS3 盒子模型<br/> CSS3 中可以通过 box-sizing 来指定盒模型，分别是 content-box、border-box；<br/> 这样就可以该表计算盒子大小的方式；<br/> 可以分成两种情况：<br/> 1 box-sizing: content-box 盒子大小为 width + padding + border （默认）；<br/> 2 box-sizing: border-box 盒子大小为 width；<br/> .div2 {<!-- --><br/>     width: 200px;<br/>     height: 200px;<br/>     background-color: skyblue;<br/>     border: 5px solid greenyellow;<br/>     padding: 15px;<br/>     box-sizing: border-box;<br/> }<br/><br/> 使用通配符进行统一默认配置；<br/> * {<!-- --><br/>     margin: 0;<br/>     padding: 0;<br/>     box-sizing: border-box;<br/> }<br/><br/> 2.5 CSS3 其他特性（了解）<br/> 1 CSS3 滤镜 filter；</p> <p>用于将模糊或颜色偏移等图形效果应用于元素；<br/> filter: 函数();     <br/> 例如：filter: blur(5px); blur模糊处理 数值越大越模糊<br/><br/> 2 CSS3 calc 函数：</p> <p>calc() 使声明css属性值时执行一些计算；<br/> width: calc(100% - 80px);<br/> 1<br/> 上例中使得子元素永远比父元素窄 80px；<br/> 可以使用运算符<br/> 2.6 CSS3 过渡<br/> 在不使用 Flash 动画或 javascript 的情况下，配置元素样式变化过度效果；</p> <p>主要是过渡效果；<br/> 与 :hover 搭配使用；<br/> transition: 要过渡的属性 花费时间 运动曲线 何时开始;<br/> 1<br/> 要过渡的属性：如果是所有属性，可以写 all ；<br/> 花费时间：单位为秒，必须写单位，如 0.5s；<br/> 运动曲线：可以省略；<br/> linear：匀速；<br/> ease：缓慢减速；<br/> ease-in：加速；<br/> ease-out：减速；<br/> ease-in-out：先加速后减速；<br/> 何时开始：用于延迟，可以省略；<br/> div {<!-- --><br/>     width: 200px;<br/>     height: 100px;<br/>     background: no-repeat;<br/>     background-image: url(../1.jpg);<br/>     background-size: 100% 100%;<br/>     transition: background-image 1s, width 1s;<br/> }</p> <p>div:hover {<!-- --><br/>     background-image: url(../2.jpg);<br/>     width: 400px;<br/> }<br/><br/> 改变多个属性则用逗号分开，或用all；<br/> 直接用 all 最常见；<br/><br/><a class=\"link-info has-card\" href=\"https://blog.csdn.net/qq_42680313/article/details/105587567\" title=\"原文链接：\"><span class=\"link-card-box\"><span class=\"link-title\">原文链接：</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://blog.csdn.net/qq_42680313/article/details/105587567</span></span></a></p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"%E7%94%A8localstorage%E5%92%8CsessionStorage%E5%86%99%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F\">7）用localstorage和sessionStorage写过什么？</h2>\n<ol><li style=\"text-align:justify;\"> <p>sessionStorage用作临时交流的留言板或是交流记录</p> </li><li style=\"text-align:justify;\"> <p>用<a href=\"https://so.csdn.net/so/search?q=localStorage&amp;spm=1001.2101.3001.7020\" title=\"localStorage\">localStorage</a>做过记住用户名和密码的功能，做过小游戏最高分和排行榜</p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E5%8A%A0%E8%BD%BD%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F\">8）如何解决页面内容加载缓慢的问题？</h2>\n<ol><li style=\"text-align:justify;\"> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>一、优化图片</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">几乎没有哪个网页上是没有图片的。如果你经历过56K猫的年代，你一定不会很喜欢有大量图片的网站。因为加载那样一个网页会花费大量的时间。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">即使在现在，网络带宽有了很多的提高，56K猫逐渐淡出，优化图片以加快网页速度还是很有必要的。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">优化图片包括减少图片数、降低图像质量、使用恰当的格式。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">1、减少图片数：去除不必要的图片。可以将大量的背景图整合成一张雪碧图</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">2、降低图像质量：如果不是很必要，尝试降低图像的质量，尤其是jpg格式，降低5%的质量看起来变化不是很大，但文件大小的变化是比较大的。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">3、使用恰当的格式：请参阅下一点。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">因此，在上传图片之前，你需要对图片进行编辑，如果你觉得photoshop太麻烦，可以试试一些在线图片编辑工具。懒得编辑而又想图片有特殊的效果？可以试试用过调用javascript来实现图片特效。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>二、图像格式的选择</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">一般在网页上使用的图片格式有三种，jpg、png、gif。三种格式的具体技术指标不是这篇文章探讨的内容，我们只需要知道在什么时候应该使用什么格式，以减少网页的加载时间。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">1、JPG：一般用于展示风景、人物、艺术照的摄影作品。有时也用在电脑截屏上。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">2、GIF：提供的颜色较少，可用在一些对颜色要求不高的地方，比如网站logo、按钮、表情等等。当然，gif的一个重要的应用是动画图片。就像用Lunapic制作的倒映图片。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">3、PNG：PNG格式能提供透明背景，是一种专为网页展示而发明的图片格式。一般用于需要背景透明显示或对图像质量要求较高的网页上。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>三、优化CSS</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">CSS叠层样式表让网页加载起来更高效，浏览体验也得到提高。有了CSS，表格布局的方式可以退休了。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">但有时我们在写CSS的时候会使用了一些比较罗嗦的语句，比如这句：</span></span></p> <p style=\"margin-left:0;\"></p>\n<div style=\"margin-left:0;\">\n<table align=\"center\" border=\"1\" cellspacing=\"0\" style=\"margin-left:auto;\"><tbody><tr><td style=\"border-color:#dddddd;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\"><span style=\"color:#4f4f4f;\"><span style=\"color:#ff0000;\">以下为引用的内容：</span><br/> margin-top: 10px;<br/> margin-right: 20px;<br/> margin-bottom: 10px;<br/> margin-left: 20px;</span></span></span></td></tr></tbody></table>\n</div> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">你可以将它简化为：</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">margin: 10px 20px 10px 20px;</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">又或者这句：</span></span></p> <p style=\"margin-left:0;\"></p>\n<div style=\"margin-left:0;\">\n<table align=\"center\" border=\"1\" cellspacing=\"0\" style=\"margin-left:auto;\"><tbody><tr><td style=\"border-color:#dddddd;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\"><span style=\"color:#4f4f4f;\"><span style=\"color:#ff0000;\">以下为引用的内容：</span><br/> &lt;p class=\"decorated\"&gt;A paragraph of decorated text&lt;/p&gt;<br/> &lt;p class=\"decorated\"&gt;Second paragraph&lt;/p&gt;<br/> &lt;p class=\"decorated\"&gt;Third paragraph&lt;/p&gt;<br/> &lt;p class=\"decorated\"&gt;Forth paragraph&lt;/p&gt;</span></span></span></td></tr></tbody></table>\n</div> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">可以用div来包含：</span></span></p> <p style=\"margin-left:0;\"></p>\n<div style=\"margin-left:0;\">\n<table align=\"center\" border=\"1\" cellspacing=\"0\" style=\"margin-left:auto;\"><tbody><tr><td style=\"border-color:#dddddd;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\"><span style=\"color:#4f4f4f;\"><span style=\"color:#ff0000;\">以下为引用的内容：</span><br/> &lt;div class=\"decorated\"&gt;<br/> &lt;p&gt;A paragraph of decorated text&lt;/p&gt;<br/> &lt;p&gt;Second paragraph&lt;/p&gt;<br/> &lt;p&gt;Third paragraph&lt;/p&gt;<br/> &lt;p&gt;Forth paragraph&lt;/p&gt;<br/> &lt;/div&gt;</span></span></span></td></tr></tbody></table>\n</div> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">简化CSS能去除冗余的属性，提高运行效率。如果你写好CSS后懒得去做简化，你可以使用一些在线的简化CSS工具，比如CleanCSS。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>四、网址后加斜杠</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">有些网址，比如\"www.kenengba.com/220\"，当服务器收到这样一个地址请求的时候，它需要花费时间去确定这个地址的文件类型。如果220是一个目录，不妨在网址后多加一个斜杠，让其变成www.kenengba.com/220/，这样服务器就能一目了然地知道要访问该目录下的index或default文件，从而节省了加载时间。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>五、标明高度和宽度</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">这点很重要，但很多人由于懒惰或其它原因，总是将其忽视。当你在网页上添加图片或表格时，你应该指定它们的高度和宽度，也就是height和width参数。如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">下面是一个比较友好的图片代码：</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">&lt;img id=\"moon\" height=\"200\" width=\"450\" src=\"http://www.kenengba.com/moon.png\" alt=\"moon image\" /&gt;</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>六、减少http请求</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">当浏览者打开某个网页，浏览器会发出很多对象请求（图像、脚本等等），视乎网络延时情况，每个对象加载都会有所延迟。如果网页上对象很多，这可以需要花费大量的时间。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">因此，要为http请求减负。如何减负？</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">1、去除一些不必要的对象。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">2、将临近的两张图片合成一张。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">3、合并CSS</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">看看下面这段代码，需要加载三个CSS：</span></span></p> <p style=\"margin-left:0;\"></p>\n<div style=\"margin-left:0;\">\n<table align=\"center\" border=\"1\" cellspacing=\"0\" style=\"margin-left:auto;\"><tbody><tr><td style=\"border-color:#dddddd;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\"><span style=\"color:#4f4f4f;\"><span style=\"color:#ff0000;\">以下为引用的内容：</span><br/> &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/body.css\" /&gt;<br/> &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/side.css\" /&gt;<br/> &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/footer.css\" /&gt;</span></span></span></td></tr></tbody></table>\n</div> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">我们可以将其合成一个：</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\" /&gt;</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">从而减少http请求。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\"><strong>七、其它小技巧（译者添加）</strong></span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">1、去除不必要加载项。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">2、如果在网页上嵌入了其它网站的widget，如果有选择余地，一定要选择速度快的。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">3、尽量用图片代替flash，这对SEO也有好处。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">4、有些内容可以静态化就将其静态化，以减少服务器的负担。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">5、统计代码放在页尾。</span></span></p> <p style=\"margin-left:0;\"><span style=\"color:#4d4d4d;\"><span style=\"background-color:#ffffff;\">6、尽量不要用一个很小的图片当背景，这样做会加大客户端CPU处理时间</span></span></p> <strong>7，静态资源使用cdn</strong>                                                                                                      <strong>8，增加服务器带宽                                                                                                     9，如果用户多的话，使用高并发</strong>                           </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"cookie%E7%9A%84%E7%89%B9%E7%82%B9*\">9）cookie的特点*</h2>\n<ol><li style=\"text-align:justify;\"> <p>一、cookie的特点：<br/> 1、cookie不可跨域<br/> 2、cookie存储在浏览器里面<br/> 3、cookie有数量与大小的限制<br/> 1）数量在50个左右<br/> 2）大小在4kb左右<br/> 4、cookie的存储时间非常灵活<br/> 5、cookie不光可以服务器设置（用set-cookie），也可以客户端设置。<br/> document.cookie<br/> key:value</p> <p>二、cookie的属性<br/> 1、name cookie的名字，唯一性<br/> 2、value cookie的值<br/> 3、domain 设置cookie在哪个域名下是有效的<br/> 4、path cookie的路径<br/> 5、expires cookie的过期时间<br/> 6、max-age cookie的有效期,<br/> 值：-1 临时cookie，0有效期够了的 cookie，正数存活周期<br/> 7、HttpOnly 有这个标记的cookie，前端是无法获取的<br/> 8、Secure 设置cookie只能通过https协议传输<br/> 9、SameSite 设置cookie在跨域请求的时候不能被发送。<br/>  </p> <p></p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B\">10）页面渲染过程</h2>\n<ol><li style=\"text-align:justify;\"> <p><span style=\"color:#4da8ee;\"><strong>1、解析HMTML标签，构建DOM树</strong></span><br/>        HTML 文档中的所有内容皆是节点，各节点之间拥有层级关系，如父子关系、兄弟关系等，彼此相连，构成DOM树。最常见的几种节点有：文档节点、元素节点、文本节点、属性节点、注释节点。</p> <p>DOM节点树中节点与HTML文档中内容一一对应，DOM树构建过程：读取html文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 DOM 树。</p> <p><span style=\"color:#4da8ee;\"><strong>2、解析CSS，构建CSSOM树</strong></span><br/>         CSS文档中，所有元素皆是节点，与HTML文件中的标签节点一一对应。CSS中各节点之间同样拥有层级关系，如父子关系、兄弟关系等，彼此相连，构成CSSOM树。</p> <p>在构建DOM树的过程中，在 HTML 文档的 head 标签中遇到 link 标签，该标签引用了一个外部CSS样式表。由于预见到需要利用该CSS资源来渲染页面，浏览器会立即发出对该CSS资源的请求，并进行CSSDOM树的构建。</p> <p>CSSOM树构建过程与DOM树构建流程一致：读取CSS文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 CSSOM 树。</p> <p><span style=\"color:#4da8ee;\"><strong>3、把DOM和CSSOM组合成渲染树（render tree）</strong></span><br/>       </p> <p>        渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。</p> <p>构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。</p> <p><span style=\"color:#4da8ee;\"><strong>4.在渲染树的基础上进行布局，计算每个节点的几何结构</strong></span><br/>  4.<strong>1重绘（repaint）：屏幕的一部分要重绘</strong>。渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小。<strong>譬如某个div标签节点的背景颜色、字体颜色等等发生改变，但是该div标签节点的宽、高、内外边距并不发生变化</strong>，此时触发浏览器重绘（repaint）。</p> <p> 4.<strong>2重排（reflow）：也有称回流</strong>，<strong>当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树</strong>。譬如JS为某个p标签节点添加新的样式：\"display:none;\"。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即重排（reflow）。</p> <p>注意：<strong>重排必将引起重绘，而重绘不一定会引起重排。</strong></p> <p>何时回引起重排？</p> <p>当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排：</p> <p>1、添加或者删除可见的DOM元素；</p> <p>2、元素位置改变——display、float、position、overflow等等；</p> <p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p> <p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p> <p>5、页面渲染初始化；</p> <p>6、浏览器窗口尺寸改变——resize事件发生时；</p> <p>4.3如何减少和避免重排</p> <p>Reflow 的成本比 Repaint 的成本高得多的多。一个节点的 Reflow 很有可能导致子节点，甚至父节点以及兄弟节点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。----浏览器的渲染原理简介</p> <p>1. 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）；</p> <p>2. 让要操作的元素进行”离线处理”，处理完后一起更新；</p> <p>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；<br/> b) 使用display:none技术，只引发两次回流和重绘；<br/> c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p> <p>3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存；</p> <p>4. 让元素脱离动画流，减少回流的Render Tree的规模；</p> <p><span style=\"color:#4da8ee;\"><strong>5、把每个节点绘制到屏幕上（painting）</strong></span><br/><br/><a class=\"link-info has-card\" href=\"https://blog.csdn.net/m0_56551554/article/details/121789562\" title=\"原文链接：https://blog.csdn.net/m0_56551554/article/details/121789562\"><span class=\"link-card-box\"><span class=\"link-title\">原文链接：https://blog.csdn.net/m0_56551554/article/details/121789562</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://blog.csdn.net/m0_56551554/article/details/121789562</span></span></a></p> </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"11%EF%BC%89%E7%BD%91%E9%A1%B5%E4%B8%8A%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF\">11）网页上哪里可以看到请求的所有信息</h2> <p></p> <p></p>\n<ol><li style=\"text-align:justify;\">  <p>以谷歌浏览器为例：</p> <p>按下f12打开控制台 找到Network就可以看见网页请求的所有信息了</p>            <img alt=\"\" src=\"..\\..\\static\\image\\20210626005956470.png\"/>     </li></ol></li><li style=\"text-align:justify;\"> <h2 id=\"12%EF%BC%89HTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0\">12）HTML5的新特性                                                                                                                                       </h2> <p>HTML新特性<br/><strong>1：语义化标签</strong><br/> 通过语义化标签，可以让页面有更加完善的结构，让页面的元素有含义，同时利于被搜索引擎解析，有利于SEO，主要标签包括下面的标签：</p> <p>标签    描述<br/> header    表示文档的头部区域<br/> footer    表示文档的尾部区域<br/> nav    表示文档导航部分<br/> section    表示文档的某一节<br/> article    表示文章<br/> main    表示文档主要的内容区域<br/><strong>2：增强型表单</strong><br/><strong>例如可以通过input的type属性指定类型是number还是date或者url，同时还添加了placeholder和required等表单属性</strong>。</p> <p><strong>3. 媒体元素</strong><br/> 新增了audio和video两个媒体相关的标签，可以让开发人员不必以来任何插件就能在网页中嵌入浏览器的音频和视频内容。</p> <p><strong>4. canvas绘图</strong><br/> canvas绘图指的是在页面中设定一个区域，然后通过JS动态的在这个区域绘制图形。</p> <p><strong>5. svg绘图</strong><br/> 这一部分不详细展开，想要了解的小伙伴可以参考其他文章~</p> <p><strong>6. 地理定位</strong><br/> 使用<strong>getCurrentPosition()方法</strong>来获取用户的位置，从而实现队地理位置的定位。</p> <p><strong>7. 拖放API</strong><br/> 通过给标签元素设置属性<strong>draggable值为true</strong>，能够实现对目标元素的拖动。</p> <p><strong>8. Web Worker</strong><br/> Web Worker通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行，worker线程运行结束之后会把结果返回给主线程，worker线程可以处理一些计算密集型的任务，这样主线程就会变得相对轻松，<strong>这并不是说JS具备了多线程的能力，而实浏览器作为宿主环境提供了一个JS多线程运行的环境。</strong></p> <p><strong>9. Web Storage</strong><br/> 关于Web Storage部分，大家需要重点掌握的是<strong>cookie、Localstorage和SessionStorage三者之间的区别：</strong></p> <p><strong>10. Websocket</strong><br/> 关于websocket协议，大家主要需要记住的就是websocket和HTTP的区别。</p> <p>相同点<br/> HTTP和Websocket都是基于TCP的应用层协议。</p> <p>不同点<br/> websocket是双向通信协议，模拟socket协议，可以双向发送和接受消息，HTTP是单向的，意思是说通信只能由客户端发起。<br/> websocket是需要浏览器和服务器通过握手建立连接，但是HTTP是浏览器向服务器发送连接，服务器预先不知道这个连接。</p> <p>联系<br/> websocket建立握手时需要基于HTTP进行传输，建立连接之后呢便不再需要HTTP协议了。<br/><br/><a class=\"link-info\" href=\"https://blog.csdn.net/sinat_41696687/article/details/123159705\" title=\"原文链接：https://blog.csdn.net/sinat_41696687/article/details/123159705\">原文链接：https://blog.csdn.net/sinat_41696687/article/details/123159705</a></p> </li><li style=\"text-align:justify;\"> <h2 id=\"13%EF%BC%89localstore%E5%92%8Csessionstore%E7%9A%84%E5%8C%BA%E5%88%AB\">13）localstore和sessionstore的区别</h2> </li></ol>\n<p style=\"text-align:justify;\">                </p>\n<p>LocalStorge和sessionStorage之间的区别<br/> localStorage<br/> localStorage的生命周期是永久性的，也就是说使用localStorage存储数据，数据会被永久保存，数据不会因为窗口或浏览器的关闭而消失，除非主动的去删除数据。</p>\n<p>localStorage有length属性，可以通过控制台查看其有多少条记录的数据。</p>\n<pre><code class=\"language-javascript\">var storage = null;\nstorage.setItem(\"key\",\"value\")   //调用setItem方法存储数据\nstorage.getItem(\"key\")            //调用getItem方法获取key的值\nstroage.removeItem(\"key\")        //删除key对应的值\nstroage.clear()                   //清空数据</code></pre>\n<p><br/><br/> sessionStorage<br/> sessionStorage的生命周期相比localStorage来说很短，其周期在窗口关闭时结束。也就是说，当浏览器窗口关闭，sessionStorage的使命就已经结束，其保留的数据也会被清除。</p>\n<p>sessionStorage也拥有length属性，两者的使用方法也是一致的，但和localstorage比较，仍有一些区别。</p>\n<p>页面刷新不会消除已获得的数据<br/> 这里我写了两个html文件(test1.html / test2.html)来进行说明：</p>\n<p>因为篇幅问题，所以只取了部分需要注意的代码段</p>\n<p>这是test1.html的部分代码：</p>\n<pre><code class=\"language-javascript\">&lt;body&gt;\n    &lt;button&gt;跳转按钮&lt;/button&gt;\n    &lt;div&gt;页面的作用:在 sessionStorage 中存数据&lt;/div&gt;\n    &lt;script&gt;\n        var Data = window.sessionStorage;\n        console.log(Data)\n        var str = 'sessionData'\n        // sessionStorage 存储数据 \n        Data.setItem('code',str)\n        document.getElementsByTagName('button')[0].onclick = function(){\n            window.location.href = './test2.html'\n        }\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p><br/><br/> test2.html的部分代码：</p>\n<pre><code class=\"language-javascript\">&lt;body&gt;\n    &lt;div&gt;我是test2页面&lt;/div&gt;\n    &lt;script&gt;\n        \n      var sessionData = sessionStorage.getItem('code')\n      console.log(sessionData)\n      console.log(sessionStorage.getItem('code'))\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p><br/><br/> 打开test1页面，可以看见跳转按钮以及一段文字：页面的作用:在 sessionStorage 中存数据；</p>\n<p>打开控制器，可以看见已经传入了 code 以及它的值 sessionData;</p>\n<p>这时点击跳转按钮，会看见页面刷新，进入test2页面，显示“我是test2页面”</p>\n<p>sessionStorage 在test1窗口关闭前；就保存数据了。换一个新的窗口(test2)；也不会有数据改变<br/><br/> sessionStorage.getItem(key) 获取sessionStorage的数据中value值<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"14%EF%BC%89%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E5%8F%82%E6%95%B0%E7%9A%84%EF%BC%9F\">14）页面之间是怎么传参数的？</h2> </li></ul>\n<p style=\"text-align:justify;\">                </p>\n<p>1.cookie 传值。</p>\n<p> 缺点: cookie储存是需要服务器支持的，本地直接运行静态文件是实现不了的。cookie能够存储少量数据到客户端的磁盘中，特定的网页之间是可以共享cookie中的数据。</p>\n<p>2.LocalStorage和SessionStorage传值。</p>\n<p> 优点:本地静态文件可支持。在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。此方法类似cookie，将数据存在一个公共的地方，实现页面之间传值。</p>\n<p> 3.get方式，Url传值.。</p>\n<p>优点: 速度快. cookie 和 LocalStorage和SessionStorage 都存在速度慢,反应不过来的问题, 我在a页面写进去,在b页面读出来.有时会读到空值。post提交表单跳转的方式肯定不行了，因服务端并不处理这些请求参数，连到达客户端的机会都没有。</p>\n<p>4.window.open和window.opener之间传值</p>\n<p>window.open可以打开一个新的页面，在新的页面中可以通过window.opener获取父页面的窗口对象，从而可以获取父窗口中的参数。</p>\n<p>如：var content = window.opener.document.getElementById(\"open\").innerHTML; <br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"15%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B8%85%E9%99%A4localstrorage%E4%BF%9D%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F\">15）如何在浏览器查看和清除localstrorage保存的数据？</h2> </li></ul>\n<p style=\"text-align:justify;\">        1.按下F12打开开发人员工具<br/>         2.点击切换到 Application<br/>         3.点击<a href=\"https://so.csdn.net/so/search?q=LocalStorage&amp;spm=1001.2101.3001.7020\" title=\"LocalStorage\">LocalStorage</a> 即可查看到保存过的数据信息</p>\n<p style=\"text-align:justify;\"><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20200320142629646.png\"/></p>\n<p style=\"text-align:justify;\">如何清除数据？<br/> 点击上方的Clear storage 点击 Clear site data即可删除数据</p>\n<p style=\"text-align:justify;\"><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20200320143025229.png\"/></p>\n<p></p>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"16%EF%BC%89%E5%AF%B9H5%E6%96%B0%E5%A2%9E%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">16）对H5新增的语义化标签的理解？</h2> </li></ul>\n<p>一、 语义化标签是什么？</p>\n<p>常用的语义化标签包括</p>\n<p>&lt;<a href=\"https://so.csdn.net/so/search?q=header&amp;spm=1001.2101.3001.7020\" title=\"header\">header</a>&gt;&lt;/header&gt;头部</p>\n<p>&lt;nav&gt;&lt;/nav&gt;导航栏</p>\n<p>&lt;section&gt;&lt;/section&gt;区块（有语义化的div）</p>\n<p>&lt;main&gt;&lt;/main&gt;主要区域</p>\n<p>&lt;artical&gt;&lt;/artical&gt;主要内容</p>\n<p>&lt;aside&gt;&lt;/aside&gt;侧边栏</p>\n<p>&lt;footer&gt;&lt;/footer&gt;底部</p>\n<p>二、 为什么会用语义化标签？</p>\n<p>平时，我们都会采用DIV+CSS布局我们的页面。但是这样的布局方式不仅使我们的<strong>文档结构</strong>不够<strong>清晰</strong>，而且不利于浏览器对页面的读取。所以HTML5新增了很多新的语义化标签。并且，在我们未给页面添加css样式时，用户体验并不好。语义化标签也能让<strong>浏览器更好的读取页面结构。</strong>再就是<strong>便于团队开发和维护，语义化更具可读性</strong>，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>\n<p></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"css%E7%9B%B8%E5%85%B3\" style=\"margin-left:0;text-align:justify;\">css相关</h1>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"17%EF%BC%89CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9D%83%E5%80%BC%EF%BC%9F\">17）CSS选择器的优先级排序，怎么计算权值？</h2> </li></ul>\n<p style=\"text-align:justify;\">一、各个类型选择器的权重</p>\n<pre><code class=\"language-javascript\">* 第零等：!important，大过了其它任何设置。\n* 第一等：代表内联样式，如：style=''，权值为1000。\n* 第二等：代表ID选择器，如：#content，权值为0100。\n* 第三等：代表类、伪类和属性选择器，如.content，权值为0010。\n* 第四等：代表标签选择器和伪元素选择器，如div p，权值为0001。\n* 第五等：通配符、子选择器、相邻选择器等的。如*、&gt;、+，权值为0000。\n* 第六等：继承的样式没有权值，通配选择器定义的规则优先级高于元素继承过来的规则的优先级。</code></pre>\n<p style=\"text-align:justify;\"><br/><br/> 二、!important<br/><strong>!important的作用是提升优先级，换句话说，加了这句的样式的优先级是最高的（比内联样式的优先级还高)。</strong><br/> 1<br/> 三、CSS优先级规则</p>\n<pre><code class=\"language-javascript\">* css选择器的权值不同时，权值高的选择器优先；\n* css选择器的权值相同时，后定义的选择器优先；\n* css属性后面加!important时，无条件绝对优先；\n* 总结：\n* !important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 || 伪类选择器 || 属性选择器 &gt; 标签选择器 || 伪元素选择器 &gt; 通配符选择器 || 子选择器 || 相邻选择器 &gt; 继承样式</code></pre>\n<p style=\"text-align:justify;\"><br/> * 注意:<br/> * !important规则被应用在一个样式声明中时，该样式声明会覆盖CSS中任何其他对该元素的声明，无论它处在声明列表中的哪个位置。<br/> * 但是注意，使用!important样式很难调试，因为它改变了你样式本来的权值规则。<br/><br/> 四、权值如何进行比较<br/>  </p>\n<pre><code class=\"language-javascript\">* 当两个权值进行比较时，从高位到低位逐位进行比较，从高等级开始比较。\n* 如果相同等级的权值相同，再继续进行下一个等级的比较。\n* 如果不相同，直接应用相同等级权值比较大的选择器对应的样式。而不是把四个等级的权值加起来进行比较。\n* 如果某个样式后面加了!important，则绝对优先，比内联样式更优先。\n\n同一个选择器，同一个属性设置了两次或多次样式，则后设置的样式会覆盖之前的样式</code></pre>\n<p style=\"text-align:justify;\"><br/><br/><a class=\"link-info\" href=\"https://blog.csdn.net/qq_39090575/article/details/110703916\" title=\"原文链接：https://blog.csdn.net/qq_39090575/article/details/110703916\">原文链接：https://blog.csdn.net/qq_39090575/article/details/110703916</a></p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"18%EF%BC%89display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB\">18）display：none和visibility：hidden的区别</h2> </li></ul>\n<p style=\"text-align:justify;\">很多人认为visibility: hidden和display: none的区别仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性</p>\n<p style=\"text-align:justify;\">visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果<strong>重新给子元素设置visibility: visible,则子元素又会显示出来</strong>。这个和display: none有着质的区别 ：父元素设置display:none; 子元素设置display:block;后子元素不会显示</p>\n<p style=\"text-align:justify;\">visibility: hidden不会影响计数器的计数，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样</p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"19%EF%BC%89CSS%E7%9A%84%E7%BB%A7%E6%89%BF%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C.one.%20two%E5%92%8C.one%20%3E%20.two%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%BA%A7%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E8%BF%9E%E7%9D%80%E4%B8%80%E8%B5%B7%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F(%E6%9D%83%E5%80%BC%E7%9B%B8%E5%8A%A0)\">19）CSS的继承选择器，.one. two和.one &gt; .two的区别？两个同级类选择器连着一起写有什么作用？(权值相加)</h2> </li></ul>\n<p>1、CSS的继承选择器，.one .two和.one&gt;.two的区别？<br/> .one .two，匹配.one下所有包含.two的标签，包含所有后代元素</p>\n<p>.one&gt;.two，匹配.one下子元素中包含.two的标签，只包含.one的子级元素<br/><br/><strong>2、两个同级类选择器连着一起写有什么作用？（.one.two）<br/> 权值相加，匹配既包含.one又包含.two类名的标签</strong><br/><br/><a class=\"link-info\" href=\"https://blog.csdn.net/qq_39090575/article/details/113074619\" title=\"原文链接：https://blog.csdn.net/qq_39090575/article/details/113074619\">原文链接：https://blog.csdn.net/qq_39090575/article/details/113074619</a></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"20%EF%BC%89CSS%E7%9A%84%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">20）CSS的引用方式有哪些？它们的区别？</h2> </li></ul>\n<p>方式一：内联样式</p>\n<p>内联样式也叫行内样式，指的是直接在HTML标签中的 style 属性中添加 css。</p>\n<p>示例：</p>\n<pre><code class=\"language-javascript\">&lt;div style=\"width: 100px; height: 100px\"&gt;&lt;/div&gt;</code></pre>\n<p><br/> 这种方式只能改变当前标签的样式，如果想要多个 div 标签拥有相同的样式，就只能重复的为每个 div 添加和修改相同的样式，还会使HTML代码变得冗长，并且难以维护。所以一般不推荐使用内联样式引入CSS样式。</p>\n<p>方式二：嵌入样式</p>\n<p>嵌入样式指的是在HTML头部中的 style 标签中写入CSS代码。</p>\n<p>示例：</p>\n<pre><code class=\"language-javascript\">&lt;head&gt;\n    &lt;style&gt;\n    .div {\n        width: 100px;\n        height: 100px;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;</code></pre>\n<p><br/> 嵌入方式的 CSS 只对当前的网页有效，所以当多个页面需要引入相同的 CSS 样式时，这样写会导致代码冗余，也不利于维护。但是，因为 CSS 代码在HTML文件中，所以会使得代码比较集中，当我们写模板网页时，这样比较写比较好，因为可以让人一目了然地查看 HTML 结构和 CSS 样式。</p>\n<p>方式三：链接样式</p>\n<p>链接方式指的是使用HTML头部的标签引入外部的 CSS 文件。</p>\n<p>示例：</p>\n<pre><code class=\"language-javascript\">&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\"&gt;\n&lt;/head&gt;</code></pre>\n<p><br/> 链接方式是最常见也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性，并且所有的 CSS 代码只存在于 CSS 文件中，CSS文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可，并且其他页面需要相同的 CSS 样式时可以复用。</p>\n<p>方式四：导入样式</p>\n<p>导入样式指的是使用 CSS 规则引入外部 CSS 文件。</p>\n<p>示例;</p>\n<pre><code class=\"language-javascript\">&lt;style type=\"text/css\"&gt;\n    @import url(style.css);\n&lt;/style&gt;</code></pre>\n<p><br/> 或者</p>\n<pre><code>&lt;style type=\"text/css\"&gt;\n    @import url(\"index.css\");\n&lt;/style&gt;</code></pre>\n<p><br/> 或者</p>\n<pre><code>&lt;style type=\"text/css\"&gt;\n    @import \"index.css\";\n&lt;/style&gt;</code></pre>\n<p><br/> 原文链接：https://blog.csdn.net/m0_48298027/article/details/110651878</p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"21%EF%BC%89css%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9%E7%AC%A6%EF%BC%9F%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss3%E6%96%B0%E5%A2%9E%E7%9A%84%E4%BC%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%A1%E7%AE%97\">21）css有哪些选择符？可继承的属性有哪些？css3新增的伪元素有哪些？css优先级的计算</h2> </li></ul>\n<p>一、CSS 选择符：<br/> 1.id选择器(# myid)<br/> 2.类选择器(.myclassname)<br/> 3.标签选择器(div, h1, p，span)<br/> 4.相邻选择器(h1 + p)<br/> 5.子选择器(ul &gt; li,ol&gt;li)<br/> 6.后代选择器(li a)<br/> 7.通配符选择器，也称全局选择器( * )<br/> 8.属性选择器(a[rel = “external”])<br/> 9.伪类选择器(a: hover, li:nth-child)</p>\n<p>二、可继承的样式：<br/> 1.font-size<br/> 2.font-family<br/> 3.color<br/> 4.text-indent</p>\n<p>三、不可继承的样式：<br/> 1.border<br/> 2.padding<br/> 3.margin<br/> 4.width<br/> 5.height</p>\n<p>四、优先级算法：<br/> 1.优先级就近原则，同权重情况下样式定义最近者为准;<br/> 2.载入样式以最后载入的定位为准;<br/> 3.!important &gt; 内联样式&gt;id选择器&gt;calss选择器&gt;标签选择器和伪元素选择器&gt;通配符、子选择器、相邻选择器等&gt;继承的样式没有权值<br/> 4.important 比 内联优先级高，但内联比 id 要高</p>\n<p>五、CSS3新增伪类举例：<br/> p:first-of-type：选择属于其父元素的首个p元素的每个p元素。<br/> p:last-of-type：选择属于其父元素的最后p元素的每个p元素。<br/> p:only-of-type：选择属于其父元素唯一的p元素的每个p元素。<br/> p:only-child：选择属于其父元素的唯一子元素的每个p元素。<br/> p:nth-child(2)：选择属于其父元素的第二个子元素的每个p元素。<br/> :enabled： disabled 控制表单控件的禁用状态。<br/> :checked： 单选框或复选框被选中。<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"22%EF%BC%89fixed%E5%92%8Cabsolute%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">22）fixed和absolute的区别？</h2> </li></ul>\n<p>fixed:固定定位    absolute:绝对定位  两者都会使元素脱离文档流</p>\n<p>区别很简单：</p>\n<p>1、没有滚动条的情况下没有差异</p>\n<p>2、在有滚动条的情况下，fixed定位不会随滚动条移动而移动，而absolute则会随滚动条移动</p>\n<p>常用场合：</p>\n<p>1.fixed固定定位，只针对浏览器窗口定位，上下左右，不会随着窗口大小改变，固定不变，例如固定位置的小广告，常用于网站边缘的公司联系方式和快速回到顶部</p>\n<p>2.absolute绝对定位，脱离文档流，相对于有最近的具有相对定位的上级父元素或者祖宗元素定位，如果依次向上找没找到具有相对定位的上级元素，则相对于浏览器窗口定位<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"23%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F\">23）如何实现水平、垂直居中？</h2> </li></ul>\n<p>1、利用定位+margin:auto<br/> 父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了0，那么这时候如果子级没有设置宽高，则会和父元素宽高相同，完全覆盖</p>\n<p>这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个margin：auto它就可以上下左右都居中了</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .father{\n        width:500px;\n        height:300px;\n        border:1px solid #0a3b98;\n        position: relative;\n    }\n    .son{\n        width:100px;\n        height:40px;\n        background: #f0a238;\n        position: absolute;\n        top:0;\n        left:0;\n        right:0;\n        bottom:0;\n        margin:auto;\n    }\n&lt;/style&gt;\n&lt;div class=\"father\"&gt;\n    &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><br/> 2、利用定位+margin:负值</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .father {\n        position: relative;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-left:-50px;\n        margin-top:-50px;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n&lt;/style&gt;\n&lt;div class=\"father\"&gt;\n    &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><br/> 初始位置为方块1的位置<br/> 当设置left、top为50%的时候，内部子元素为方块2的位置<br/> 设置margin为负数时，使内部子元素到方块3的位置，即中间位置<br/> 这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作</p>\n<p>但是该方案需要知道子元素自身的宽高，但是我们可以通过下面transform属性进行移动</p>\n<p>3、利用定位+transform<br/> translate(-50%, -50%)将会将元素位移自己宽度和高度的-50%</p>\n<p>这种方法其实和最上面被否定掉的margin负值用法一样，可以说是margin负值的替代方案，并不需要知道自身元素的宽高</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .father {\n        position: relative;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n  transform: translate(-50%,-50%);\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n&lt;/style&gt;\n&lt;div class=\"father\"&gt;\n    &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><br/> 4、table布局</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .father {\n        display: table-cell;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n        vertical-align: middle;\n        text-align: center;\n    }\n    .son {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n&lt;/style&gt;\n&lt;div class=\"father\"&gt;\n    &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><br/> 5、flex布局</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .father {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n&lt;/style&gt;\n&lt;div class=\"father\"&gt;\n    &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><br/> css3中了flex布局，可以非常简单实现垂直水平居中</p>\n<p>这里可以简单看看flex布局的关键属性作用：</p>\n<p>display: flex时，表示该容器内部的元素将按照flex进行布局</p>\n<p>align-items: center表示这些元素将相对于本容器水平居中</p>\n<p>justify-content: center也是同样的道理垂直居中</p>\n<p>6、gird布局</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .father {\n            display: grid;\n            align-items:center;\n            justify-content: center;\n            width: 200px;\n            height: 200px;\n            background: skyblue;\n \n        }\n        .son {\n            width: 10px;\n            height: 10px;\n            border: 1px solid red        }\n&lt;/style&gt;\n&lt;div class=\"father\"&gt;\n    &lt;div class=\"son\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"24%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%B7%A6%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%9B%BA%E5%AE%9A%EF%BC%8C%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%E8%87%AA%E9%80%82%E5%BA%94%3F\">24）实现左侧边栏固定，其他内容自适应?</h2> </li></ul>\n<p style=\"text-align:justify;\"><strong>HTML</strong><br/>  </p>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt;\n    &lt;title&gt;Static Template&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"./index.css\" /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"box\"&gt;\n      &lt;div id=\"left\"&gt;&lt;/div&gt;\n      &lt;div id=\"right\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div id=\"box2\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>方案一：左侧固定宽度，右侧flex自适应 flex：1； 占据剩余空间</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  display: flex;\n}\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n}\n#right {\n  flex: 1;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/> 方案二：左侧浮动，右侧设置宽度100%，占据左侧普通流位置</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n}\n#left {\n  width: 100px;\n  height: 100%;\n  float: left;\n  background-color: lightgreen;\n}\n#right {\n  width: 100%;\n  height: 100%;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/><br/> 方案三：左侧固定宽度左浮动，右侧设margin-left等于左侧宽度</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n}\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n  float: left;\n}\n#right {\n  width: calc(100% - 100px);\n  margin-left: 100px;\n  height: 100%;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/><br/> 方案四：左侧固定宽度、固定定位，右侧宽度100%</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n  position: relative;\n}\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n#right {\n  width: 100%;\n  height: 100%;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/> 方案五：左侧宽度固定、固定定位，右侧左边距等于左侧宽度：</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n  position: relative;\n}\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n#right {\n  width: calc(100% - 100px);\n  margin-left: 100px;\n  height: 100%;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/> 方案六：双左浮动，右侧计算属性计算宽度</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n}\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n  float: left;\n}\n#right {\n  width: calc(100% - 100px);\n  height: 100%;\n  float: left;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/> 方案七：左侧左浮，右侧右浮动，右侧计算宽度：</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n}\n/* #box::after {\n  content: \" \";\n  display: block;\n  clear: both;\n} */\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n  float: left;\n}\n#right {\n  width: calc(100% - 100px);\n  float: right;\n  height: 100%;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p><br/> 方案八：左侧固定宽度，display:inline-block，右侧右浮动，计算宽度</p>\n<pre><code class=\"language-javascript\">#box {\n  width: 100%;\n  height: 400px;\n  background-color: #aaaaaa;\n}\n/* #box::after {\n  content: \" \";\n  display: block;\n  clear: both;\n} */\n#left {\n  width: 100px;\n  height: 100%;\n  background-color: lightgreen;\n  display: inline-block;\n}\n#right {\n  width: calc(100% - 100px);\n  float: right;\n  height: 100%;\n  background-color: lightblue;\n}\n\n#box2 {\n  width: 500px;\n  height: 500px;\n  background-color: plum;\n}</code></pre>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"25%EF%BC%89css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\">25）css3的新特性</h2> </li></ul>\n<p>二、选择器<br/> css3中新增了一些选择器，主要为如下图所示：</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\afa627b672191550a033cf128d2e138b.png\"/></p>\n<p></p>\n<p>三、新样式<br/> 边框<br/> css3新增了三个边框属性，分别是：</p>\n<p>border-radius：创建圆角边框</p>\n<p>box-shadow：为元素添加阴影</p>\n<p>border-image：使用图片来绘制边框</p>\n<p>box-shadow</p>\n<p>设置元素阴影，设置属性如下：</p>\n<p>水平阴影</p>\n<p>垂直阴影</p>\n<p>模糊距离(虚实)</p>\n<p>阴影尺寸(影子大小)</p>\n<p>阴影颜色</p>\n<p>内/外阴影</p>\n<p>其中水平阴影和垂直阴影是必须设置的</p>\n<p>背景<br/> 新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break</p>\n<p>background-clip</p>\n<p>用于确定背景画区，有以下几种可能的属性：</p>\n<p>background-clip: border-box; 背景从border开始显示</p>\n<p>background-clip: padding-box; 背景从padding开始显示</p>\n<p>background-clip: content-box; 背景显content区域开始显示</p>\n<p>background-clip: no-clip; 默认属性，等同于border-box</p>\n<p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p>\n<p>background-origin</p>\n<p>当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的</p>\n<p>background-origin: border-box; 从border开始计算background-position</p>\n<p>background-origin: padding-box; 从padding开始计算background-position</p>\n<p>background-origin: content-box; 从content开始计算background-position</p>\n<p>默认情况是padding-box，即以padding的左上角为原点</p>\n<p>background-size</p>\n<p>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>\n<p>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</p>\n<p>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</p>\n<p>background-size: 100px 100px; 缩小图片至指定的大小</p>\n<p>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</p>\n<p>background-break<br/> 元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示</p>\n<p>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</p>\n<p>background-break: bounding-box; 把盒之间的距离计算在内；</p>\n<p>background-break: each-box; 为每个盒子单独重绘背景</p>\n<p>文字<br/> word-wrap<br/> 语法：word-wrap: normal|break-word</p>\n<p>normal：使用浏览器默认的换行</p>\n<p>break-all：允许在单词内换行</p>\n<p>text-overflow<br/> text-overflow设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p>\n<p>clip：修剪文本</p>\n<p>ellipsis：显示省略符号来代表被修剪的文本</p>\n<p>text-shadow<br/> text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p>\n<p>text-decoration<br/> CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>\n<p>text-fill-color: 设置文字内部填充颜色</p>\n<p>text-stroke-color: 设置文字边界填充颜色</p>\n<p>text-stroke-width: 设置文字边界宽度</p>\n<p>颜色<br/> css3新增了新的颜色表示方式rgba与hsla</p>\n<p>rgba分为两部分，rgb为颜色值，a为透明度</p>\n<p>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度</p>\n<p>四、transition 过渡<br/> transition属性可以被指定为一个或多个CSS属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p>\n<p>过度效果</p>\n<p>持续时间</p>\n<p>语法如下：</p>\n<p>transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)<br/> 上面为简写模式，也可以分开写各个属性</p>\n<p>transition-property: width; <br/> transition-duration: 1s;<br/> transition-timing-function: linear;<br/> transition-delay: 2s;<br/> 五、transform 转换<br/> transform属性允许你旋转，缩放，倾斜或平移给定元素</p>\n<p>transform-origin：转换元素的位置（围绕那个点进行转换），默认值为(x,y,z):(50%,50%,0)</p>\n<p>使用方式：</p>\n<p>transform: translate(120px, 50%)：位移</p>\n<p>transform: scale(2, 0.5)：缩放</p>\n<p>transform: rotate(0.5turn)：旋转</p>\n<p>transform: skew(30deg, 20deg)：倾斜</p>\n<p>六、animation 动画<br/> 动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p>\n<p>animation也有很多的属性</p>\n<p>animation-name：动画名称</p>\n<p>animation-duration：动画持续时间</p>\n<p>animation-timing-function：动画时间函数</p>\n<p>animation-delay：动画延迟时间</p>\n<p>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</p>\n<p>animation-direction：动画执行方向</p>\n<p>animation-paly-state：动画播放状态</p>\n<p>animation-fill-mode：动画填充模式</p>\n<p>七、渐变<br/> 颜色渐变是指在两个颜色之间平稳的过渡，css3渐变包括</p>\n<p>linear-gradient：线性渐变</p>\n<p>❝<br/> background-image: linear-gradient(direction, color-stop1, color-stop2, ...);</p>\n<p>❞<br/> radial-gradient：径向渐变</p>\n<p>❝<br/> linear-gradient(0deg, red, green);</p>\n<p>❞<br/> 八、其他<br/> 关于css3其他的新特性还包括flex弹性布局、Grid栅格布局，</p>\n<p>除此之外，还包括多列布局、媒体查询、混合模式等等<br/>  </p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"26%EF%BC%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%9F\">26）了解过哪些页面布局？</h2> </li></ul>\n<p>几种常见布局<br/><strong>table布局</strong><br/> 父级容器—display: table<br/> 子级容器—display:table-cell<br/> 例子</p>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh_CN\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      .box {\n        width: 600px;\n        height: 100px;\n        display: table;\n      }\n      .left,\n      .right {\n        display: table-cell;\n      }\n      .left {\n        background: yellowgreen;\n      }\n      .right {\n        background: skyblue;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"box\"&gt;\n      &lt;div class=\"left\"&gt;&lt;/div&gt;\n      &lt;div class=\"right\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong>float布局</strong><br/> 特点:</p>\n<p>元素\"浮动\"<br/> 脱离文档流<br/> 但不脱离文本流<br/> 对自身的影响: 形成\"块\"(BFC，具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素)、位置尽量靠上、位置尽量靠左(右)，无法满足会靠下<br/> 对兄弟的影响: 上面贴非float元素、旁边贴float元素、不影响其它块级元素位置、影响其它块级元素内部文本</p>\n<p><strong>flexbox布局</strong><br/> 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现；2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br/> Flex是Flexible Box的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性；任何一个容器都可以指定为Flex布局，行内元素也可以使用Flex布局; webkit内核的浏览器，必须加上-webkit-前缀。</p>\n<p>弹性盒子<br/> 盒子本来就是并列的<br/> 指定宽度即可<br/> 水平竖直居中 flex 实现</p>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt;\n    &lt;title&gt;水平竖直居中布局解决方案-flex+justify-content&lt;/title&gt;\n    &lt;style&gt;\n      * {\n        margin: 0;\n        padding: 0;\n      }\n      #parent {\n        width: 100%;\n        height: 400px;\n        background: #ccc;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      #child {\n        width: 300px;\n        height: 200px;\n        background: #c9394a;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 定义父级元素 --&gt;\n    &lt;div id=\"parent\"&gt;\n      &lt;!-- 定义子级元素 --&gt;\n      &lt;div id=\"child\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong>Grid布局</strong><br/> 网格布局（Grid）是最强大的 CSS 布局方案。<br/> 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的CSS框架达到的效果，现在浏览器内置了;Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。Flex 布局是轴线布局，只能指定\"项目\"针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成\"行\"和\"列\"，产生单元格，然后指定\"项目所在\"的单元格，可以看作是二维布局。Grid 布局远比Flex布局强大。</p>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh_CN\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      .wrapper {\n        display: grid;\n        grid-template-columns: repeat(3, 1fr);\n        grid-gap: 10px;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"wrapper\"&gt;\n      &lt;div&gt;One&lt;/div&gt;\n      &lt;div&gt;Two&lt;/div&gt;\n      &lt;div&gt;Three&lt;/div&gt;\n      &lt;div&gt;Four&lt;/div&gt;\n      &lt;div&gt;Five&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong> </strong></p>\n<p><strong>columns布局</strong><br/> CSS属性 columns 用来设置元素的列宽和列数。<br/> 例子</p>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh_CN\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      .content-box {\n        columns: 3 auto;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p class=\"content-box\"&gt;\n      JavaScript 框架 WHY VUE.JS?起步 GITHUB 易用 已经会了\n      HTML、CSS、JavaScript?即刻阅读指南开始构建应用! 灵活\n      不断繁荣的生态系统,可以在一个库和一套完整框架之间自如伸.JavaScript 框架\n      WHY VUE.JS?起步 GITHUB 易用 已经会了\n      HTML、CSS、JavaScript?即刻阅读指南开始构建应用! 灵活\n      不断繁荣的生态系统,可以在一个库和一套完整框架之间自如伸.JavaScript 框架\n      WHY VUE.JS?起步 GITHUB 易用 已经会了\n      HTML、CSS、JavaScript?即刻阅读指南开始构建应用! 灵活\n      不断繁荣的生态系统,可以在一个库和一套完整框架之间自如伸.JavaScript 框架\n      WHY VUE.JS?起步 GITHUB 易用 已经会了\n      HTML、CSS、JavaScript?即刻阅读指南开始构建应用! 灵活\n      不断繁荣的生态系统,可以在一个库和一套完整框架之间自如伸.JavaScript 框架\n      WHY VUE.JS?起步 GITHUB 易用 已经会了\n      HTML、CSS、JavaScript?即刻阅读指南开始构建应用! 灵活\n      不断繁荣的生态系统,可以在一个库和一套完整框架之间自如伸.\n    &lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"27%20%E7%94%A8animation%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8A%A8%E7%94%BB%EF%BC%9F\">27 用animation做过什么？做过哪些动画？</h2> </li></ul>\n<p style=\"text-align:justify;\">做走马灯  原文链接：<a href=\"https://juejin.im/post/5d483219f265da03aa2553e1\" title=\"用animation制作走马灯 - 掘金\">用animation制作走马灯 - 掘金</a></p>\n<p>做3d魔方      本文链接：<a href=\"https://blog.csdn.net/CodingmanNAN/article/details/103967313\" title=\"使用 C3 Animation 做一个3D魔方_Jaosncode的博客-CSDN博客\">使用 C3 Animation 做一个3D魔方_Jaosncode的博客-CSDN博客</a> </p>\n<p>用animation做无缝匀速滚动   本文链接：<a href=\"https://blog.csdn.net/hsy0827/article/details/123912846\" title=\"用animation做无缝匀速滚动_是黄小仙呀的博客-CSDN博客_如何设置animation动画为匀速运动\">用animation做无缝匀速滚动_是黄小仙呀的博客-CSDN博客_如何设置animation动画为匀速运动</a></p>\n<p> 做弹力球            本文链接：<a href=\"https://blog.csdn.net/lxhby520/article/details/79999566\" title=\"用动画（animation）做弹力球_lxhby520的博客-CSDN博客\">用动画（animation）做弹力球_lxhby520的博客-CSDN博客</a> </p>\n<p>使用animation制作进度条   本文链接：<a href=\"https://blog.csdn.net/xiaozhuangyumaotao/article/details/105587718\" title=\"使用animation制作进度条_乐之者java的博客-CSDN博客\">使用animation制作进度条_乐之者java的博客-CSDN博客</a></p>\n<p></p>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"28%20Sass%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F\">28 Sass写一个数组？</h2> </li></ul>\n<pre><code class=\"language-javascript\">// 定义数组，数组元素用逗号隔开\n$liColor:#f5ad1b,#5f89ce,#94bf45,#da8ec5,#78bfc2,#bec278;\n \n// 开始 @each 循环遍历数组\n// $c 作为循环变量，代表了数组的元素，不是索引~！！！\n@each $c in $liColor{\n     $i:index($liColor,$c);        // 获取 $c 在数组中的索引，并赋值给 $i 赋值用冒号，不是等号~！\n     li:nth-child( #{$i} ){      // 经典的地方来了，SCSS 循环是从 1 开始，不是 0 哦~\n       background: $c;           // 背景色\n       &amp;:hover{\n         background: lighten($c,10%);    // hover 后的颜色\n       }\n     }\n}</code></pre>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"29%EF%BC%89rem%E5%87%BA%E7%8E%B0%E5%BE%88%E5%B0%8F%E7%9A%84%E5%B0%8F%E6%95%B0%E6%89%8B%E6%9C%BA%E4%B8%8A%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C\">29）rem出现很小的小数手机上会发生什么，</h2> </li></ul>\n<p>为了保证大部分分辨率下计算出的根字体大小都为整数，所以约定根字体大小的计算公式为：<br/> 分辨率宽度 / 10；</p>\n<p>在iPhone6下，如果一个元素的宽和高都是1.75rem，其在浏览器内的渲染尺寸<br/> 应该是1.75 * 37.5 = 65.625px；</p>\n<p>但真实渲染尺寸却是另外一种情况：</p>\n<p>    有的宽度是66px，有的却是65px，而且顺序上毫无规律。<br/>     <br/>     如果浏览器统一做四舍五入处理，那么所有的色块尺寸也应该是一样的，不会出现部分向上取整，<br/> 部分向下取整。</p>\n<p>设想：</p>\n<p>    浏览器在渲染时所做的舍入处理只是应用在元素的渲染尺寸上，其真实占据的空间依旧是原始大小。<br/>     <br/>     <strong>也就是说如果一个元素尺寸是0.625px，那么其渲染尺寸应该是1px，空出的0.375px空间由<br/> 其临近的元素填充；</strong><br/>     <br/>   <strong>  同样道理，如果一个元素尺寸是0.375px，其渲染尺寸就应该是0，但是其会占据<br/> 临近元素0.375px的空间。</strong></p>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"30%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8less\">30 什么时候用less</h2> </li></ul>\n<ol><li>函数式编程css</li><li>自定义变量用于整体主题调整</li><li>嵌套语法简化开发复杂度</li></ol>\n<p>页面层级结构多，重复使用的css代码较多时</p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"31%20animation%E5%92%8Ctransition\">31 animation和transition</h2> </li></ul>\n<p>1.animation概念<br/> 可以用 name 设置动画的名称，用 duration 设置动画完成的周期，用 timing-function 设置动<br/> 画的速度曲线，delay 设置动画什么时候开始，iteration-count 设置动画播放的次数，direction 规定下一<br/> 个周期是否逆向的播放，play-state 动画是否正在进行或者暂停，fill-mode 设置动画停了之后位置什么状态</p>\n<blockquote>\n<p>animation 属性是一个简写属性，用于设置六个动画属性：<br/> animation-name    规定需要绑定到选择器的 keyframe 名称。<br/> animation-duration    规定完成动画所花费的时间，以秒或毫秒计。<br/> animation-timing-function    规定动画的速度曲线。<br/> animation-delay    规定在动画开始之前的延迟。<br/> animation-iteration-count    规定动画应该播放的次数。<br/> animation-direction    规定是否应该轮流反向播放动画。</p>\n</blockquote>\n<p></p>\n<p><br/> 2.transition概念<br/> 用 property 去设置过渡效果的属性名称，duration 设置过渡效果的周期，timing-function 规<br/> 定速度效果的速度曲线，delay 设定过渡效果什么时候开始；</p>\n<blockquote>\n<p>transition 属性是一个简写属性，用于设置四个过渡属性：<br/> transition-property    规定设置过渡效果的 CSS 属性的名称。<br/> transition-duration    规定完成过渡效果需要多少秒或毫秒。<br/> transition-timing-function    规定速度效果的速度曲线。<br/> transition-delay    定义过渡效果何时开始。</p>\n</blockquote>\n<p><br/><br/> 3.区别</p>\n<blockquote>\n<p><br/> 1）transition 是过渡，是样式值的变化的过程，只有开始和结束；animation 其实也叫关键帧，通过和 keyframe 结合可以设置中间帧的一个状态；<br/> 2）animation 配合 @keyframe 可以不触发时间就触发这个过程，而 transition 需要通过 hover 或者 js 事件来配合触发；<br/> 3）animation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次；<br/> 4）animation 可以结合 keyframe 设置每一帧，但是 transition 只有两帧；<br/>  </p>\n</blockquote>\n<p>transition可以实现简单的过渡动画效果，而animation可以实现更为复杂的动画效果 </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"32%20%E7%A7%BB%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%A9%E9%82%A3%E4%B8%AA%E5%9B%BE%E7%89%87%E6%85%A2%E6%85%A2%E6%94%BE%E5%A4%A7\">32 移入图片让那个图片慢慢放大</h2> </li></ul>\n<p><strong>DOM</strong></p>\n<pre><code class=\"language-javascript\">&lt;body&gt;\n    &lt;div class=\"box\"&gt;\n        &lt;div class=\"img\"&gt;\n            图片\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;</code></pre>\n<p><br/><strong>CSS</strong><br/>  </p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    body {\n        width: 100vw;\n        height: 100vh;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    }\n\n    .box {\n        width: 300px;\n        height: 300px;\n        border: 1px solid black;\n        position: relative;\n    }\n\n    .img {\n        width: 300px;\n        height: 300px;\n        background-color: red;\n        font-size: 24px;\n        line-height: 300px;\n        text-align: center;\n        position: absolute;\n        transform-origin: right center;\n        animation: animate 3s linear;/*使用动画*/\n    }\n\n    /*图片的运动动画*/\n    @keyframes animate {\n        from {\n            transform: scale(0);\n            left: -110%;\n        }\n        to {\n            transform: scale(1);\n            left: 0;\n        }\n    }\n&lt;/style&gt;</code></pre>\n<p><br/><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/20201216171943145.gif\"/></p>\n<p></p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"33%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5\">33 盒子模型概念</h2> </li></ul>\n<p>盒模型的概念</p>\n<p>盒模型是CSS布局的基石，规定了网页元素如何显示以及元素间相互关系。CSS定义所有的元素都可以拥有像盒子一样的外形和平面空间。即都包含内容区、补白（内填充）、边框、边界(外边距)这就是盒模型。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\3c49a287b04943ceb4a45e6a6fe650f4.png\"/></p>\n<p></p>\n<p>盒模型的组成</p>\n<p>盒模型组成 = content(内容) + padding(内填充) + border(边框) + margin(外边距)</p>\n<p>内填充：padding,在设定页面中一个元素内容到元素的边缘(边   框) 之间的距离。 也称补白。padding不可以写负值！<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"34%20css%E7%9A%84%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F\">34 引用样式的方式有哪几种？他们的优先级排序怎么样？</h2> </li></ul>\n<p>一共有4中方式，分别为内联、内嵌、外联、导入。</p>\n<p>1、内联（行内样式） - 在标签内直接写样式，</p>\n<pre><code class=\"language-javascript\">style=\"\"&lt;div style=\"width: 300px;height: 300px\"&gt;&lt;/div&gt;</code></pre>\n<p><br/><br/> 2、内嵌（内部样式） - 在head标签里，加一个style标签，在style里写样式</p>\n<pre><code class=\"language-javascript\">&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;title&gt;document&lt;/title&gt;\n    &lt;style&gt;\n        div {\n            background-color: red;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;</code></pre>\n<p><br/><br/> 3、外联（外部样式） - 新建一个.css文件，通过link来引入样式</p>\n<pre><code class=\"language-javascript\">&lt;link rel=\"stylesheet\" href=\"css/index.css\"&gt;</code></pre>\n<p><br/><br/> 4、导入（导入样式） - 在head标签里，加一个style标签，再写@import url()，跟用link的方式差不多</p>\n<pre><code class=\"language-javascript\">&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;title&gt;document&lt;/title&gt;\n    &lt;style&gt;\n        @import url(css/index.css);\n    &lt;/style&gt;\n&lt;/head&gt;</code></pre>\n<p><br/><br/> 5、优先级</p>\n<p>1、就近原则</p>\n<p>2.理论上：内联&gt;内嵌&gt;外联&gt;导入</p>\n<p>3.实际上：内嵌、外联、导入在同一个文件头部，在CSS选择器权值相同的情况下，谁离相应的代码近，谁的优先级高<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"35%20px%2Cem%2Crem%2C%25\">35 px,em,rem,%，vm,vh</h2> </li></ul>\n<p>1.px</p>\n<p>px就是像素，也是我们现在经常使用的基本单位，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。</p>\n<p>2.em</p>\n<p><strong>em参考物是父元素的font-size</strong>，默认字体大小是16px，所以1em不是固定值，因为它会继承父元素的字体大小</p>\n<p>3.rem</p>\n<p>r<strong>em参考物是相对于根元素</strong>，我们在使用时可以在根元素设置一个参考值即可，相对于em使用，减少很大运算工作量，例：html大小为10px，12rem就是120px</p>\n<p>4.%</p>\n<p><strong>% 是相对于父元素的大小设定的比率</strong>，position:absolute;的元素是相对于已经定位的父元素，position：fixed；的元素是相对可视窗口</p>\n<p>5、vw</p>\n<p>css3新单位，viewpoint width的缩写，视窗宽度，1vw等于视窗宽度的1%。</p>\n<p>举个例子：浏览器宽度1200px, 1 vw = 1200px/100 = 12 px。</p>\n<p>再举个例子：浏览器宽度1200px, 1 vw = 1200px/100 = 12 px</p>\n<p>6.vh</p>\n<p>vm相对于视口的宽度。视口被均分为100单位</p>\n<p>h1 {<!-- --><br/>     font-size: 8vh;<br/> }<br/><br/> 再举个例子：浏览器高度900px, 1 vh = 900px/100 = 9 px</p>\n<p>总结：</p>\n<p><strong>  1.vw：1vw等于视口宽度的1%。<br/>   2.vh：1vh等于视口高度的1%。</strong><br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"36%20display%E7%9A%84%E5%80%BC%E5%92%8C%E4%BD%9C%E7%94%A8\">36 display的值和作用</h2> </li></ul>\n<p style=\"text-align:justify;\"></p>\n<p>1、display的值有：</p>\n<p>none，inline，block，list-item，inline-block，table，inline-table，table-caption，table-cell，table-row，table-row-group，table-column，table-column-group，table-footer-group，table-header-group，run-in，box，inline-box，flexbox，inline-flexbox，flex，inline-flex</p>\n<p>2、作用：</p>\n<p>none： 表示隐藏对象，与visibility属性的hidden值不同，display：none不为被隐藏的对象保留物理空间 ，然visibility：hidden就保留</p>\n<p>inline（默认值）：表示指定对象为内联元素</p>\n<p>block： 指定对象为块元素。</p>\n<p>list-item： 指定对象为列表项目</p>\n<p>inline-block： 指定对象为内联块元素。（这是CSS2中的属性）</p>\n<p>table： 指定对象作为块元素级的表格。类同于html标签table（CSS2）</p>\n<p>inline-table： 指定对象作为内联元素级的表格。类同于html标签table（CSS2）</p>\n<p>table-caption： 指定对象作为表格标题。类同于html标签caption（CSS2）</p>\n<p>table-cell： 指定对象作为表格单元格。类同于html标签td（CSS2）</p>\n<p>table-row： 指定对象作为表格行。类同于html标签tr（CSS2）</p>\n<p>table-row-group： 指定对象作为表格行组。类同于html标签tbody（CSS2）</p>\n<p>table-column： 指定对象作为表格列。类同于html标签col（CSS2）</p>\n<p>table-column-group： 指定对象作为表格列组显示。类同于html标签colgroup（CSS2）</p>\n<p>table-header-group： 指定对象作为表格标题组。类同于html标签thead（CSS2）</p>\n<p>table-footer-group： 指定对象作为表格脚注组。类同于html标签tfoot（CSS2）</p>\n<p>run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）</p>\n<p>box： 将对象作为弹性伸缩盒显示。（伸缩盒的最老版本中属性）（CSS3）</p>\n<p>inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒的最老版本中属性）（CSS3）</p>\n<p>flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒的最老版本中属性）（CSS3）</p>\n<p>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒的最老版本中属性）（CSS3）</p>\n<p>flex： 将对象作为弹性伸缩盒显示。（伸缩盒的最老版本中属性）（CSS3）</p>\n<p>inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒的最老版本中属性）（CSS3）<br/>  </p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"37%20css3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\">37列举两种清除浮动的方法(代码实现或者描述思路)</h2> </li></ul>\n<p>实例：</p>\n<p>  HTML代码代码</p>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;清除浮动&lt;/title&gt;\n    &lt;style&gt;\n        #parent{\n            border: 1px solid black;\n        }\n        #child{\n            width: 100px;\n            height: 100px;\n            background: red;\n            float: left;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"parent\"&gt;\n        &lt;div id=\"child\"&gt;&lt;/div&gt;\n    &lt;/div&gt;   \n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong>效果图-----未清除浮动</strong><br/><img alt=\"效果图\" src=\"..\\..\\static\\image\\20201107150332109.png\"/><br/>   <strong>效果图-----已清除浮动</strong><br/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20201107154250901.png\"/></p>\n<p></p>\n<p> 当为子元素设置了浮动，如果不清除浮动，那么父元素将会出现高度塌陷的现象。所以当我们设置了浮动后，就要解决浮动带来的影响。下面就要我们介绍几种清除浮动的方法！</p>\n<p><strong>方法一：额外标签法</strong></p>\n<p>  给谁清除浮动，就在其后额外添加一个空白标签 ，给其设置clear：both。</p>\n<p>  优点：通俗易懂，书写方便。</p>\n<p>  缺点：添加许多无意义的标签，结构化比较差。</p>\n<p>  clear：both：本质就是闭合浮动， 就是让父盒子闭合出口和入口，不让子盒子出来 。</p>\n<p>  css样式</p>\n<pre><code class=\"language-javascript\">#clear{\n    clear: both;\n}</code></pre>\n<p><br/><br/>   html代码</p>\n<pre><code class=\"language-javascript\">&lt;div id=\"parent\"&gt;\n    &lt;div id=\"child\"&gt;&lt;/div&gt;\n    &lt;!-- 方法一  额外标签法 --&gt;\n    &lt;div id=\"clear\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><strong>方法二：父元素添加overflow:hidden</strong></p>\n<p>  通过触发BFC方式，实现清除浮动</p>\n<p>  优点：代码简洁</p>\n<p>  缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素。</p>\n<p>  css样式</p>\n<pre><code class=\"language-javascript\">#parent{\n    overflow: hidden;\n}</code></pre>\n<p><br/><br/><strong>方法三：使用after伪元素清除浮动</strong></p>\n<p>  优点：符合闭合浮动思想，结构语义化正确。</p>\n<p>  缺点：ie6-7不支持伪元素：after，使用zoom:1触发hasLayout。</p>\n<p>  css样式</p>\n<p><br/> 方法四：使用before和after双伪元素清除浮动</p>\n<p>  优点：代码更简洁</p>\n<p>  缺点：用zoom:1触发hasLayout.</p>\n<p>  css样式</p>\n<pre><code class=\"language-javascript\">#parent:after,#parent:before{\ncontent: \"\";\ndisplay: table;\n}\n#parent:after{\n    clear: both;\n}\n#parent{\n    *zoom: 1;\n}</code></pre>\n<p><br/><br/> 方法五：为父元素设置高度</p>\n<p>  缺点: 需要手动添加高度，如何后面的高度发生变化，还要再次修改高度，给后期的维护带来麻烦。</p>\n<p>  优点: 简单粗暴直接有效，清除了浮动带来的影响。<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"38%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%80%AA%E5%BC%82%E6%A8%A1%E5%9E%8B%EF%BC%89\">38 盒子模型（怪异模型）</h2> </li></ul>\n<p>标准盒子模型和怪异盒子模型（IE盒子模型） </p>\n<p>在标准模式下，一个块的总宽度 = 内容的width + padding(左右) + border(左右) + margin(左右)</p>\n<p>设置padding和border会将盒子撑大，在设置的宽高外产生</p>\n<p> <img alt=\"\" src=\"..\\..\\static\\image\\20201217181615702.png\"/></p>\n<p></p>\n<p></p>\n<p>在怪异模式下，一个块的总宽度 = 内容的width + margin(左右)（这里的width包含了padding(左右)和border(左右)的值），设置的padding和border会在原有的宽高里面产生，不会撑开盒子</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\20201217181629469.png\"/></p>\n<p></p>\n<p></p>\n<p>例如一个div：</p>\n<pre><code class=\"language-javascript\"> div{\n        width:100px;\n        height:100px;\n        padding:20px;\n        border:2px solid #000;\n    }</code></pre>\n<p><br/><br/> 在标准模式下：总宽度为100px;</p>\n<p><br/> 在怪异模式下：总宽度为144px;</p>\n<p><br/> 4.<strong>两种模式的转换（通过box-sizing）</strong><br/> box-sizing中比较常用的两个属性值为 content-box 和 border-box ，它可以改变盒子模型的解析计算模式，可以参考上面的代码案例。</p>\n<p>当设置box-sizing:content-box时，采用标准模式进行计算，默认就是这种模式；<br/> 当设置<strong>box-sizing:border-box时，采用怪异模式进行计算</strong>；<br/>  </p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"39%20%E8%B0%88%E8%B0%88fixed%20%EF%BC%8Crelated%20%EF%BC%8C%20absolute\">39 谈谈fixed ，relative ， absolute</h2> </li></ul>\n<p>.relative相对定位</p>\n<p>相对定位：设置相对定位的盒子会相对它原来的位置，通过指定偏移，到达新的位置，但是原来的位置会被保留下来，且仍在标准文档流中，它对父级盒子和相邻的盒子都没有任何影响。</p>\n<p>absolute 绝对定位</p>\n<p>绝对定位：设置绝对定位的盒子会相对于距离最近的设置了相对定位的祖先元素进行定位，如果一直找不到具有相对定位的祖先元素，就相对于浏览器窗口定位，且会使元素脱离文档流。</p>\n<p>fixed 固定定位</p>\n<p>固定定位：设置了固定定位的盒子只会相对于浏览器窗口进行定位，也就是窗口中左上角的原点</p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"40%20float%E5%92%8Cabsolute%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">40 float和absolute有什么区别？</h2> </li></ul>\n<p style=\"text-align:justify;\"><strong>1》文字内容是否会被覆盖</strong></p>\n<p style=\"text-align:justify;\">float浮动，当元素通过float来脱离文档流时，虽然其他的元素会当其不存在，但其他元素的内容还是会把这个元素占的位置让出来。也就是该元素浮动在另外一个有文字内容的元素上时，文字内容并不会被浮动的元素覆盖，而是环绕在周围。如：</p>\n<p style=\"text-align:justify;\"><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210130153319721.png\"/></p>\n<p style=\"text-align:justify;\">absolute脱离文档流的时候，其他元素和元素中的文本都会无视掉他，因此不会像float那样将其他元素的内容挤到旁边去。如：</p>\n<p style=\"text-align:justify;\"><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210130153904315.png\"/></p>\n<p style=\"text-align:justify;\">2》相对何处进行定位</p>\n<p style=\"text-align:justify;\">当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。</p>\n<p style=\"text-align:justify;\">设置绝对定位的盒子会相对于距离最近的设置了相对定位的祖先元素进行定位，且会使元素脱离文档流，如果一直找不到具有相对定位的祖先元素，就相对于浏览器窗口定位。</p>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"41%20css3%E6%96%B0%E7%89%B9%E6%80%A7\">41 代码实现3栏效果，左右两栏固定宽度，中间栏随着浏览器宽度自适应变化</h2> </li></ul>\n<p><strong>1 flex布局</strong></p>\n<pre><code class=\"language-javascript\">&lt;section class=\"layout flexbox\"&gt;\n    &lt;style&gt;\n        .layout.flexbox{\n          margin-top: 110px;\n        }\n        .layout.flexbox .left-center-right{\n          display: flex;\n        }\n        .layout.flexbox .left{\n          width: 300px;\n          background: red;\n        }\n        .layout.flexbox .center{\n          flex:1;\n          background: yellow;\n        }\n        .layout.flexbox .right{\n          width: 300px;\n          background: blue;\n        }\n    &lt;/style&gt;\n    &lt;h1&gt;三栏布局&lt;/h1&gt;\n    &lt;article class=\"left-center-right\"&gt;\n        &lt;div class=\"left\"&gt;&lt;/div&gt;\n        &lt;div class=\"center\"&gt;\n        &lt;h2&gt;flexbox解决方案&lt;/h2&gt;\n        1.这是三栏布局的felx解决方案；\n        2.这是三栏布局的flex解决方案；\n        &lt;/div&gt;\n        &lt;div class=\"right\"&gt;&lt;/div&gt;\n    &lt;/article&gt;\n&lt;/section&gt;</code></pre>\n<ol><li> <p></p> </li></ol>\n<p>felxbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。 <br/> felxbox的缺点就是不能兼容IE8及以下浏览器。</p>\n<p><strong>2 表格布局 </strong></p>\n<pre><code class=\"language-javascript\">&lt;section class=\"layout table\"&gt;\n    &lt;style&gt;\n        .layout.table .left-center-right{\n          width:100%;\n          height: 100px;\n          display: table;\n        }\n        .layout.table .left-center-right&gt;div{\n          display: table-cell;\n        }\n        .layout.table .left{\n          width: 300px;\n          background: red;\n        }\n        .layout.table .center{\n          background: yellow;\n        }\n        .layout.table .right{\n          width: 300px;\n          background: blue;\n        }\n    &lt;/style&gt;\n    &lt;h1&gt;三栏布局&lt;/h1&gt;\n    &lt;article class=\"left-center-right\"&gt;\n        &lt;div class=\"left\"&gt;&lt;/div&gt;\n        &lt;div class=\"center\"&gt;\n        &lt;h2&gt;表格布局解决方案&lt;/h2&gt;\n        1.这是三栏布局的表格解决方案；\n        2.这是三栏布局的表格解决方案;\n        &lt;/div&gt;\n        &lt;div class=\"right\"&gt;&lt;/div&gt;\n    &lt;/article&gt;\n&lt;/section&gt;</code></pre>\n<p><strong> 5.网格布局</strong></p>\n<pre><code class=\"language-javascript\">&lt;section class=\"layout grid\"&gt;\n    &lt;style&gt;\n        .layout.grid .left-center-right{\n          width:100%;\n          display: grid;\n          grid-template-rows: 100px;\n          grid-template-columns: 300px auto 300px;\n        }\n        .layout.grid .left-center-right&gt;div{\n \n        }\n        .layout.grid .left{\n          width: 300px;\n          background: red;\n        }\n        .layout.grid .center{\n          background: yellow;\n        }\n        .layout.grid .right{\n \n          background: blue;\n        }\n    &lt;/style&gt;\n    &lt;h1&gt;三栏布局&lt;/h1&gt;\n    &lt;article class=\"left-center-right\"&gt;\n        &lt;div class=\"left\"&gt;&lt;/div&gt;\n        &lt;div class=\"center\"&gt;\n        &lt;h2&gt;网格布局解决方案&lt;/h2&gt;\n        1.这是三栏布局的网格布局解决方案；\n        2.这是三栏布局的网格布局解决方案;\n        &lt;/div&gt;\n        &lt;div class=\"right\"&gt;&lt;/div&gt;\n    &lt;/article&gt;\n&lt;/section&gt;</code></pre>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"42%20css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D\">42 css选择器的权重</h2> </li></ul>\n<p style=\"text-align:justify;\">* 第零等：!important，大过了其它任何设置 权值为 infinity 。<br/> * 第一等：代表内联样式，如：style=''，权值为1000。<br/> * 第二等：代表ID选择器，如：#content，权值为0100。<br/> * 第三等：代表类、伪类和属性选择器，如.content，权值为0010。<br/> * 第四等：代表标签选择器和伪元素选择器，如div p，权值为0001。<br/> * 第五等：通配符、子选择器、相邻选择器等的。如*、&gt;、+，权值为0000。<br/> * 第六等：继承的样式没有权值，通配选择器定义的规则优先级高于元素继承过来的规则的优先级。</p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"43%20transition%20transform%20translate%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%20transform%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">43 transition transform translate 之间的区别 transform的属性有哪些？</h2> </li></ul>\n<p style=\"text-align:justify;\">transition的优点在于简单易用，但是它有几个很大的局限。<br/> （1）transition需要事件触发，所以没法在网页加载时自动发生。<br/> （2）transition是一次性的，不能重复发生，除非再次触发。<br/> （3）transition只有两个状态，开始状态和结束状态，不能定义中间状态。<br/> （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。<br/><img alt=\"\" height=\"301\" src=\"..\\..\\static\\image\\cf108112c4574dcfa2e8bb82024813a9.png\" width=\"864\"/></p>\n<p>transform是使元素变换，变形</p>\n<p> transform中的四个方法</p>\n<p>1.旋转rotate<br/> rotate：通过指定的角度参数对原元素指定一个效果。<br/> 如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。如：transform:rotate(30deg)；</p>\n<p><img alt=\"image-20200803155143384\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1MTQ5LnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>2.移动translate<br/> translate() 根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p>\n<p>如：transform:translate(100px,20px):</p>\n<p><img alt=\"image-20200803155216425\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1MjE2LnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>translateX<br/> 通过给定一个X方向上的数目指定一个translation。只向x轴进行移动元素，同样其基点是元素中心点，也可以根据transform-origin改变基点位置<br/> transform:translateX(100px):</p>\n<p><img alt=\"image-20200803155241091\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1MjQxLnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>translateY<br/> 通过给定Y方向的数目指定一个translation。只向Y轴进行移动，基点在元素心点，可以通过transform-origin改变基点位置。<br/> transform:translateY(20px):</p>\n<p><img alt=\"image-20200803155313026\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1MzEzLnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>3.缩放scale<br/> 缩放scale和移动translate是有点相似的，也是有三种情况：下面我们具体来看看这三种情况具体使用方法：<br/> 注意：默认值是1，它的值放大是比1大，缩小比1小。<br/> 1、scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。</p>\n<p>如：transform:scale(2,1.5); </p>\n<p>如果只写入一个参数就按照等比例宽高同时缩放 如transform:scale(1.5);  宽高都变为1.5倍</p>\n<p><img alt=\"image-20200803155332956\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1MzMzLnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>2、scaleX(n) 定义 2D 缩放转换，改变元素的宽度。</p>\n<p>如：transform:scaleX(2):</p>\n<p><img alt=\"image-20200803155351125\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1MzUxLnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>3、scaleY(n) 定义 2D 缩放转换，改变元素的高度。</p>\n<p>如：transform:scaleY(2):</p>\n<p><img alt=\"image-20200803155408877\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1NDA4LnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>4.扭曲skew<br/> 1、skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。</p>\n<p>如：transform:skew(30deg,10deg);</p>\n<p><img alt=\"image-20200803155433112\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1NjMwLnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>2、skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。</p>\n<p>如：transform:skewX(30deg);</p>\n<p><img alt=\"image-20200803155514487\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1NjQ4LnBuZw?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p>3、skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。</p>\n<p>如：transform:skewY(10deg);</p>\n<p><img alt=\"image-20200803155539603\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3d1Z29uZ3ppLWdpdC9CbG9nRmlndXJlYmVkL2ltYWdlLzIwMjAwODAzMTU1OTAzLnBuZw?x-oss-process=image/format,png\"/></p>\n<p> 当然还有3d的效果</p>\n<p></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"44%20css3%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8\">44 css3中的选择器</h2> </li></ul>\n<p style=\"text-align:justify;\"><img alt=\"\" height=\"197\" src=\"..\\..\\static\\image\\b6506e7bd87f4baa9305577d3e351ccd.png\" width=\"554\"/></p>\n<p style=\"text-align:justify;\"><img alt=\"\" height=\"195\" src=\"..\\..\\static\\image\\b29e0d04701a414d9235355d5161dfa9.png\" width=\"554\"/></p>\n<p style=\"text-align:justify;\"><img alt=\"\" height=\"274\" src=\"..\\..\\static\\image\\54e7d0c9be474162aa3de3e11f702ea9.png\" width=\"553\"/></p>\n<p> <img alt=\"\" height=\"351\" src=\"..\\..\\static\\image\\66bc4bcb190040e9af1e40f7a089cc38.png\" width=\"554\"/></p>\n<p> <img alt=\"\" height=\"259\" src=\"..\\..\\static\\image\\ae9ded23ac264a5bb8642bffff28dc90.png\" width=\"554\"/></p>\n<p> <img alt=\"\" height=\"149\" src=\"..\\..\\static\\image\\7ca33d40129d4792bb412a14c1bdd213.png\" width=\"646\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p style=\"text-align:justify;\"></p>\n<ul><li style=\"text-align:justify;\"> <h2 id=\"46%20%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%83%8C%E6%99%AF%E8%89%B2%E4%B8%BA%E7%BA%A2%E8%89%B2%EF%BC%8C%E5%8D%8A%E5%BE%84%E4%B8%BA200px%E7%9A%84%E5%9C%86%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%81%9C%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%E5%8A%A8%E7%94%BB\">46 用CSS实现一个背景色为红色，半径为200px的圆，并设置不停的上下移动动画</h2> </li></ul>\n<p>一、DOM</p>\n<pre><code class=\"language-javascript\">&lt;body&gt;\n    &lt;div class=\"box\"&gt;&lt;/div&gt;\n&lt;/body&gt;</code></pre>\n<p><br/> 二、CSS</p>\n<pre><code class=\"language-javascript\">&lt;style&gt;\n    .box {\n        width: 200px;\n        height: 200px;\n        background-color: red;\n        border-radius: 50%;\n        position: relative;\n        left: 0;\n        top: 0;\n        animation: move 2s linear infinite;\n    }\n\n    /*\n        此方式为动画方式，使用的是定位的top属性\n        还可以设置\n            transform: translateY();\n            margin-top\n    */\n    @keyframes move {\n        form {\n            top: 0;\n        }\n\n        50% {\n            top: 100px;\n        }\n\n        to {\n            top: 0;\n        }\n    }\n&lt;/style&gt;\n</code></pre>\n<p><br/> 三、结果</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/20201208215019816.gif#pic_center\"/></p>\n<p></p>\n<p></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"javascript%E4%BB%A5%E5%8F%8Aes6%E7%9B%B8%E5%85%B3\" style=\"margin-left:0px;text-align:justify;\">javascript以及es6相关</h1>\n<p></p>\n<h2 id=\"%C2%A0null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\" style=\"text-align:justify;\"> null和undefined的区别？ js的数据类型？</h2>\n<h1></h1>\n<h3><a name=\"t1\"></a>一、基本数据类型</h3>\n<p>在介绍undefined与null之前，我们先来了解一下<a href=\"https://so.csdn.net/so/search?q=ECMAScript&amp;spm=1001.2101.3001.7020\" title=\"ECMAScript\">ECMAScript</a>中的数据类型。在ECMAScript中有六种简单数据类型(也称为基本数据类型): Undefined、Null、Boolean、Number 和 String、Symbol (ES6中引入) 。还有一种复杂数据类型——Object。</p>\n<p>Undefined和Null都只有一个值，分别对应着undefined和null。这两种不同类型的值，既有着不同的语义和场景，又表现出较为相似的行为。</p>\n<h3><a name=\"t2\"></a>二、undefined</h3>\n<p>undefined 的字面意思就是：未定义的值 。这个值的语义是，希望表示一个变量最原始的状态，而非人为操作的结果 。 这种原始状态会在以下 4 种场景中出现：</p>\n<p><strong>1、声明一个变量，但是没有赋值</strong></p>\n<pre>\n</pre>\n<ol><li> <p><code>var foo;</code></p> </li><li> <p><code>console.log(foo); // undefined</code></p> </li><li> <p><code>复制代码</code></p> </li></ol>\n<p>访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。</p>\n<p><strong>2、访问对象上不存在的属性或者未定义的变量</strong></p>\n<pre>\n</pre>\n<ol><li> <p><code>console.log(Object.foo); // undefined</code></p> </li><li> <p><code>console.log(typeof demo); // undefined</code></p> </li><li> <p><code>复制代码</code></p> </li></ol>\n<p>访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。</p>\n<p><strong>3、函数定义了形参，但没有传递实参</strong></p>\n<pre>\n</pre>\n<ol><li> <p><code>//函数定义了形参 a</code></p> </li><li> <p><code>function fn(a) {<!-- --></code></p> </li><li> <p><code>console.log(a); // undefined</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>fn(); //未传递实参</code></p> </li><li> <p><code>复制代码</code></p> </li></ol>\n<p>函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。</p>\n<p><strong>4、使用void对表达式求值</strong></p>\n<pre>\n</pre>\n<ol><li> <p><code>void 0 ; // undefined</code></p> </li><li> <p><code>void false; // undefined</code></p> </li><li> <p><code>void []; // undefined</code></p> </li><li> <p><code>void null; // undefined</code></p> </li><li> <p><code>void function fn(){} ; // undefined</code></p> </li><li> <p><code>复制代码</code></p> </li></ol>\n<p>ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。</p>\n<p>因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。</p>\n<h3><a name=\"t3\"></a>三、null</h3>\n<p>null 的字面意思是：空值 。这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 在内存里的表示就是，栈中的变量没有指向堆中的内存对象。</p>\n<p><strong>1、一般在以下两种情况下我们会将变量赋值为null</strong></p>\n<ul><li> <p>如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。</p> </li><li> <p>当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。</p> </li></ul>\n<p><strong>2、特殊的typeof null</strong></p>\n<p>当我们使用typeof操作符检测null值，我们理所应当地认为应该返\"Null\"类型呀，但是事实返回的类型却是\"object\"。</p>\n<pre>\n</pre>\n<ol><li> <p><code>var data = null;</code></p> </li><li> <p><code>console.log(typeof data); // \"object\"</code></p> </li><li> <p><code>复制代码</code></p> </li></ol>\n<p>是不是很奇怪？其实我们可以从两方面来理解这个结果:</p>\n<ul><li> <p>一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回\"object\"也是可以理解的。</p> </li><li> <p>另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的(对象的类型标签是 0)。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了\"object\"。在<a href=\"https://so.csdn.net/so/search?q=ES6&amp;spm=1001.2101.3001.7020\" title=\"ES6\">ES6</a>中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持\"object\"类型。</p> </li></ul>\n<h3><a name=\"t4\"></a>四、总结</h3>\n<p>用一句话总结两者的区别就是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可，重点：<span style=\"color:#4da8ee;\"><strong>给一个变量赋值为null，可以手动释放该变量占用的内存，</strong></span><span style=\"color:#b95514;\"><strong>而给变量赋值为undefined</strong>，<strong>依旧会给该变量分配内存空间</strong></span></p>\n<h2 id=\"%C2%A0js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" style=\"text-align:justify;\"></h2>\n<h2 id=\"%C2%A0js%20%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90\" style=\"text-align:justify;\"> js 的继承实现方式有哪些，列举两个例子</h2>\n<p>寄生组合继承<br/> 这个方法有点意思，融合了原型继承和call继承的优点，真正实现了私对私，公对公~为此，我们需要在call继承的基础上加上原型继承。</p>\n<p>原型继承的思想是让子类原型=父类的一个实例，即Child.prototype = new Parent，换句话说，即Child.prototype.__proto__ = Parent.prototype(父类实例原型链指向父类原型，没毛病吧)。<br/> 从另一个角度看，我们不创建新的父类实例了！而是让子类原型的__proto__重定向，原本指向Object.prototype，现在让它指向Parent.prototype。实现了原型继承同样的效果。——实际上就是原型继承。</p>\n<p>但还有一个问题，IE6~8下是不允许我们操作__proto__的，我们使用Object.create的方法代替。<br/> Object.create(A)：创建一个空对象，让这个空对象的__proto__指向A。</p>\n<pre><code class=\"language-javascript\">// 寄生组合继承\nfunction Parent(){\n    this.x = 100;\n}\nParent.prototype.getX = function getX(){\n    return this.x;\n}\nfunction Child(){\n    Parent.call(this);      // call继承当然要保留，实现私对私\n    this.y = 200;\n}\nChild.prototype = Object.create(Parent.prototype);    // 另类原型继承\nChild.prototype.getY = function getY(){\n    return this.y;\n}\nlet c1 = new Child;\nconsole.log(c1);\n</code></pre>\n<p><br/> Child.prototype = Object.create(Parent.prototype)这句核心代码实际上和Child.prototype = new Parent别无二致，只是创建的不是父类的实例，而是一个空对象，然后手动更改原型链指向而已。这个操作也可以让父类的公有属性方法成为子类的公有属性方法。</p>\n<p>ES6中的类和继承</p>\n<pre><code class=\"language-javascript\">class Parent{\n    constructor(){         // constructor函数实际上是Parent函数的私有属性方法\n        this.x = 100;\n    }\n    getX(){             // 在Parent.prototype上的公有属性方法\n        return this.x;\n    }\n}\n// 原本毫无关联的两个类，因为extends而成为了父子\nclass Child extends Parent{\n    constructor(){\n        super();            // 只要用extends实现继承，就要在constructor函数的第一行加一句super()，否则会报错         \n        this.y = 200;\n    }\n    getY(){          \n        return this.y;\n    }\n}</code></pre>\n<p><br/><br/> ES6中的继承可以实现与寄生组合继承同样的效果，但写法是不是极其简单呐~<br/>  </p>\n<h2 id=\"eval%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\" style=\"text-align:justify;\">eval是什么？</h2>\n<h2 id=\"%C2%A0%E7%94%A8%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F\" style=\"text-align:justify;\"> 用什么会导致内存泄漏？</h2>\n<h2 id=\"%C2%A0js%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9F\" style=\"text-align:justify;\"> js深度克隆的代码实现？</h2>\n<h2 id=\"%C2%A0%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%8C%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%90%8E%E5%8F%B0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%8Chtml%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%9F%9F\" style=\"text-align:justify;\"> 同源策略，跨域，后台如何解决跨域，html有哪些标签可以跨域</h2>\n<h2 id=\"es6\" style=\"text-align:justify;\">es6</h2>\n<h2 id=\"js%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95\" style=\"text-align:justify;\">js自己封装一个方法</h2>\n<h2 id=\"%C2%A0jq%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F\" style=\"text-align:justify;\"> jq用过哪些方法？</h2>\n<h2 id=\"%C2%A0promise%EF%BC%9F\" style=\"text-align:justify;\"> promise？</h2>\n<h2 id=\"%C2%A0%E8%A7%A6%E6%91%B8%E6%9C%89%E5%87%A0%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%9F\" style=\"text-align:justify;\"> 触摸有几个事件？</h2>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\" style=\"text-align:justify;\">什么时候会发生跨域问题</h2>\n<h2 id=\"%C2%A0%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\" style=\"text-align:justify;\"> 匿名函数</h2>\n<h2 id=\"%C2%A0This%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\" style=\"text-align:justify;\"> This指向问题</h2>\n<h2 id=\"%C2%A0JQ%EF%BC%8CJS%EF%BC%8Cvue%20%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\" style=\"text-align:justify;\"> JQ，JS，vue 三者的区别</h2>\n<h2 id=\"%C2%A0%E7%94%A8jq%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%81\" style=\"text-align:justify;\"> 用jq实现双向绑定！</h2>\n<h2 id=\"%C2%A0ajax%E7%9A%84%E5%AE%9E%E7%8E%B0\" style=\"text-align:justify;\"> ajax的实现</h2>\n<h2 id=\"ajax%E7%9A%84%E5%AE%9E%E7%8E%B0\" style=\"text-align:justify;\">ajax的实现</h2>\n<h2 id=\"%C2%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%8A%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E3%80%82\" style=\"text-align:justify;\"> 在数组上新增一个方法，实现复制。</h2>\n<h2 id=\"%C2%A0%E6%9C%9F%E6%9C%9B%EF%BC%9A%5B1%2C2%2C3%5D.copy()%20%2F%2F%E8%BE%93%E5%87%BA%20%5B1%2C2%2C3%2C1%2C2%2C3%5D\" style=\"text-align:justify;\"> 期望：[1,2,3].copy() //输出 [1,2,3,1,2,3]</h2>\n<h2 id=\"%C2%A0.%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E1%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%94%E5%9B%9E2%EF%BC%8C%E7%AC%AC%E4%B8%89%E6%AC%A13%EF%BC%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82\" style=\"text-align:justify;\"> .使用闭包实现一个方法，第一次调用返回1，第二次返回2，第三次3，以此类推。</h2>\n<p>       期望</p>\n<pre><code>count()//输出1\ncount()//输出2\ncount()//输出3\n……\n</code></pre>\n<p>      实现</p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n    function outer() {\n        let number = 0;\n        return function inner() {\n            console.log(++number);\n        }\n    }\n    let count = outer();\n    count();\n    count();\n    count();\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"%C2%A0.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C.then%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E3%80%82\" style=\"text-align:justify;\"> .封装一个函数，参数是定时器的时间，.then执行回调函数。</h2>\n<p>期望</p>\n<pre><code class=\"language-javascript\">sleep(5000).then(() =&gt; console.log('我会在5秒后打印'));</code></pre>\n<p><br/><br/> Promise创建</p>\n<pre><code class=\"language-javascript\">var promise = new Promise(function(resolve, reject) {\n    //异步处理\n    //处理结束后、调用resolve或reject，当异步代码执行成功时，我们才会调用resolve(...)，当异步代码失败时就会调用reject(...)\n    //对于已经实例化过的promise对象可以调用promise.then()方法，传递resolve和reject方法作为回调\n});</code></pre>\n<p><br/><br/> 程序实现</p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n    function sleep(time) {\n        return new Promise((resolve) =&gt; setTimeout(resolve, time));\n    }\n    sleep(5000).then(() =&gt; console.log('我会在5秒后打印'));\n&lt;/script&gt;</code></pre>\n<p></p>\n<h2 id=\"%C2%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F\" style=\"text-align:justify;\"> 说一说前端性能优化有哪些方法？</h2>\n<p>这里说一下前端性能优化的七大手段，包括减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的<a href=\"https://so.csdn.net/so/search?q=API&amp;spm=1001.2101.3001.7020\" title=\"API\">API</a>和构建优化</p>\n<p id=\"anchor1\"><a name=\"t0\"></a><strong>减少请求数量</strong></p>\n<p>【合并】</p>\n<p>　　如果不进行文件合并，有如下3个隐患</p>\n<p>　　1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟</p>\n<p>　　2、受丢包问题影响更严重</p>\n<p>　　3、经过<a href=\"https://so.csdn.net/so/search?q=%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;spm=1001.2101.3001.7020\" title=\"代理服务器\">代理服务器</a>时可能会被断开</p>\n<p>　　但是，文件合并本身也有自己的问题</p>\n<p>　　1、首屏渲染问题</p>\n<p>　　2、缓存失效问题</p>\n<p>　　所以，对于文件合并，有如下改进建议</p>\n<p>　　1、公共库合并</p>\n<p>　　2、不同页面单独合并</p>\n<p>【图片处理】</p>\n<p>　　1、雪碧图</p>\n<p>　　CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台</p>\n<p>　　2、Base64</p>\n<p>　　将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33%</p>\n<p>　　3、使用字体图标来代替图片</p>\n<p>【减少重定向】</p>\n<p>　　尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验</p>\n<p>　　如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面</p>\n<p>【使用缓存】</p>\n<p>　　使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应</p>\n<p>【不使用CSS @import】</p>\n<p>　　CSS的@import会造成额外的请求</p>\n<p>【避免使用空的src和href】</p>\n<p>　　a标签设置空的href，会重定向到当前的页面地址</p>\n<p>　　form设置空的method，会提交表单到当前的页面地址</p>\n<p></p>\n<p id=\"anchor2\"><strong>减小资源大小</strong></p>\n<p>【压缩】</p>\n<p>　　1、HTML压缩</p>\n<p>　　HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等</p>\n<p>　　2、CSS压缩</p>\n<p>　　CSS压缩包括无效代码删除与CSS语义合并</p>\n<p>　　3、JS压缩与混乱</p>\n<p>　　JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护</p>\n<p>　　4、图片压缩</p>\n<p>　　针对真实图片情况，舍弃一些相对无关紧要的色彩信息</p>\n<p>【webp】</p>\n<p>　　在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性</p>\n<p>【开启gzip】</p>\n<p>　　HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40%</p>\n<p></p>\n<p id=\"anchor3\"><strong>优化网络连接</strong></p>\n<p>【使用CDN】</p>\n<p>　　CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</p>\n<p>【使用DNS预解析】</p>\n<p>　　当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照<code>浏览器缓存</code>、<code>系统缓存</code>、<code>路由器缓存</code>、<code>ISP(运营商)DNS缓存</code>、<code>根域名服务器</code>、<code>顶级域名服务器</code>、<code>主域名服务器</code>的顺序，逐步读取缓存，直到拿到IP地址</p>\n<p>　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到<code>系统缓存</code>中，缩短DNS解析时间，来提高网站的访问速度</p>\n<p>　　方法是在 head 标签里面写上几个 link 标签</p>\n<pre>\n</pre>\n<ol><li> <p><code>&lt;link rel=\"dns-prefecth\" href=\"https://www.google.com\"&gt;</code></p> </li><li> <p><code>&lt;link rel=\"dns-prefecth\" href=\"https://www.google-analytics.com\"&gt;</code></p> </li></ol>\n<p>　　对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间</p>\n<p>【并行连接】</p>\n<p>　　由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数</p>\n<p>【持久连接】</p>\n<p>　　使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量</p>\n<p>【管道化连接】</p>\n<p>　　在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了</p>\n<p></p>\n<p id=\"anchor4\"><strong>优化资源加载</strong></p>\n<p>【资源加载位置】</p>\n<p>　　通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用</p>\n<p>　　1、CSS文件放在head中，先外链，后本页</p>\n<p>　　2、JS文件放在body底部，先外链，后本页</p>\n<p>　　3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件</p>\n<p>　　4、body中间尽量不写style标签和script标签</p>\n<p>【资源加载时机】</p>\n<p>　　1、异步script标签</p>\n<p>　　defer:  异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似</p>\n<p>　　async: 异步加载，加载完成后立即执行</p>\n<p>　　2、模块按需加载</p>\n<p>　　在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块</p>\n<p>　　按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载</p>\n<p>　　webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure</p>\n<p>　　3、使用资源预加载preload和资源预读取prefetch</p>\n<p>　　preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度</p>\n<p>　　prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度</p>\n<p>　　4、资源懒加载与资源预加载</p>\n<p>　　资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源</p>\n<p>　　资源预加载是提前加载用户所需的资源，保证良好的用户体验</p>\n<p>　　资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能</p>\n<p>　　</p>\n<p id=\"anchor5\"><strong>减少重绘回流</strong></p>\n<p>【样式设置】</p>\n<p>　　1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率</p>\n<p>　　2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次</p>\n<p>　　3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流</p>\n<p>　　4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流</p>\n<p>　　5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间</p>\n<p>　　6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现</p>\n<p>【渲染层】</p>\n<p>　　1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围</p>\n<p>　　2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流</p>\n<p>【DOM优化】</p>\n<p>　　1、缓存DOM</p>\n<pre><code>const div = document.getElementById('div')</code></pre>\n<p>　　由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM</p>\n<p>　　2、减少DOM深度及DOM数量</p>\n<p>　　HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</p>\n<p>　　3、批量操作DOM</p>\n<p>　　由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM</p>\n<p>　　4、批量操作CSS样式</p>\n<p>　　通过切换class或者使用元素的style.csstext属性去批量操作元素样式</p>\n<p>　　5、在内存中操作DOM</p>\n<p>　　使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上</p>\n<p>　　6、DOM元素离线更新</p>\n<p>　　对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作</p>\n<p>　　7、DOM读写分离</p>\n<p>　　浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行</p>\n<p>　　8、事件代理</p>\n<p>　　事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件</p>\n<p>　　利用事件代理，可以减少内存使用，提高性能及降低代码复杂度</p>\n<p>　　9、防抖和节流</p>\n<p>　　使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发</p>\n<p>　　10、及时清理环境</p>\n<p>　　及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存</p>\n<p></p>\n<p id=\"anchor6\"><a name=\"t5\"></a><strong>性能更好的API</strong></p>\n<p>　　1、用对选择器</p>\n<p>　　选择器的性能排序如下所示，尽量选择性能更好的选择器</p>\n<pre>\n</pre>\n<ol><li> <p><code>id选择器（#myid）</code></p> </li><li> <p><code>类选择器（.myclassname）</code></p> </li><li> <p><code>标签选择器（div,h1,p）</code></p> </li><li> <p><code>相邻选择器（h1+p）</code></p> </li><li> <p><code>子选择器（ul &gt; li）</code></p> </li><li> <p><code>后代选择器（li a）</code></p> </li><li> <p><code>通配符选择器（*）</code></p> </li><li> <p><code>属性选择器（a[rel=\"external\"]）</code></p> </li><li> <p><code>伪类选择器（a:hover,li:nth-child）</code></p> </li></ol>\n<p>　　2、使用requestAnimationFrame来替代setTimeout和setInterval</p>\n<p>　　希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧</p>\n<p>　　3、使用IntersectionObserver来实现图片可视区域的懒加载</p>\n<p>　　传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题</p>\n<p>　　4、使用web worker</p>\n<p>　　客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用</p>\n<p>　　但是，使用一些新的API的同时，也要注意其浏览器兼容性</p>\n<p></p>\n<p id=\"anchor7\"><a name=\"t6\"></a><strong>webpack优化</strong></p>\n<p>【打包公共代码】</p>\n<p>　　使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件</p>\n<p>　　webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk</p>\n<p>　　通过设置 optimization.splitChunks.chunks: \"all\" 来启动默认的代码分割配置项</p>\n<p>【动态导入和按需加载】</p>\n<p>　　webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure</p>\n<p>【剔除无用代码】</p>\n<p>　　tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup</p>\n<p>　　JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的</p>\n<p>【长缓存优化】</p>\n<p>　　1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效</p>\n<p>　　2、使用Name而不是id</p>\n<p>　　每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变</p>\n<p>　　下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建</p>\n<p>【公用代码内联】</p>\n<p>　　使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中</p>\n<h2 id=\"%C2%A0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%88%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%EF%BC%89%2C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C%E3%80%82\" style=\"text-align:justify;\"> 一个页面上有大量的图片（大型电商网站）,加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h2>\n<ol><li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li><li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li><li>如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。</li><li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li><li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。<br/>  </li></ol>\n<h2 id=\"%C2%A0module.export%E5%92%8Cexport%EF%BC%9F\" style=\"text-align:justify;\"></h2>\n<p></p>\n<h2 id=\"%C2%A0.export%E5%92%8Cexport%20default%3F\" style=\"text-align:justify;\"> .export和export default?</h2>\n<p>使用export和export default进行暴露<br/> 每一个js文件相当于在一个函数中运行，而函数的作用域是局部作用域，所以两个js文件之间的作用域不是共享的。<br/> 此时ES6规范就为我们提供了export和export default帮助我们将想要暴露的对象暴露出去。</p>\n<p>export<br/> export的暴露格式：</p>\n<p>暴露一个变量：<br/> export 变量名<br/> 或者定义的时候就进行了暴露<br/> export var 变量名 = 变量值<br/> 暴露多个变量：<br/> export {量名1,变量2,变量3}<br/> 注意： 在js中如果对直接声明的变量进行暴露是没有意义的，因为不使用任任何关键字（如：var）直接生命的变量本事就是全局的如果再使用export进行暴露是没有意义的。</p>\n<p>export default<br/> 使用格式：<br/> 定义一个对象，将对象暴露出去：</p>\n<pre><code class=\"language-javascript\">const 对象名 = {\n    属性：值\n}\nexport default 对象名</code></pre>\n<p><br/><br/> import进行引入<br/><strong>针对 export暴露的引入</strong><br/><strong>格式：import {暴露的变量名1,暴露的变量名1,...} from '文件路径名'</strong></p>\n<p>针对 export default暴露的引入<br/><strong>格式：import 自定义的名字 from '文件路径名'</strong></p>\n<p>export和export default区别<br/><strong>export 和 export default 都可用于导出常量、函数、文件、模块等<br/> 在一个文件或模块中，export、import可以有多个，export default仅有一个<br/> 通过export方式导出，在导入时要加{ }，且不能自定义名字，export default不用加{ }，且可以自定义名字</strong><br/> export使用例子<br/> a.js:</p>\n<pre><code class=\"language-javascript\">var a = 100\nfunction fun_a() {\n   console.log(\"我是a中的函数\")\n}\nexport {\n    a,\n    fun_a\n}\nexport var b = 200</code></pre>\n<p><br/> b.js</p>\n<pre><code class=\"language-javascript\">import {a,b,fun_a} from './a'\nconsole.log(a)\nfun_a()\nconsole.log(b)</code></pre>\n<p><br/><br/> 运行b.js,报错<br/> （安装node环境所致，安装了node环境默认使用的是commomJS规范而不是ES6规范，所以报错。没有安装node可能不会报该错）</p>\n<pre><code class=\"language-javascript\">(node:12892) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n(Use `node --trace-warnings ...` to show where the warning was created)\nC:\\Users\\86198\\VScode\\qianDuan\\Node.js\\b.js:1\nimport {a,b,fun_a} from './a'\n^^^^^^\n\nSyntaxError: Cannot use import statement outside a module</code></pre>\n<p><br/><br/> 解决：<br/> 在b所在的文件夹添加package.json文件，添加\"type\": \"module\",指定规范模式为ES6模式<br/> 再次运行如果报如下错误</p>\n<pre><code class=\"language-javascript\">Error [ERR_MODULE_NOT_FOUND]: Cannot find module\n 'C:\\Users\\86198\\VScode\\qianDuan\\Node.js\\a' \nimported from C:\\Users\\86198\\VScode\\qianDuan\\Node.js\\b.js\nDid you mean to import ../a.js?</code></pre>\n<p><br/><br/> 是因为import的文件路径没写全，将路径进行补全<br/> 再次运行，运行成功：</p>\n<pre><code class=\"language-javascript\">100\n我是a中的函数\n200</code></pre>\n<p><br/><br/> export default使用例子<br/> a.js</p>\n<pre><code class=\"language-javascript\">const module_a = {\n    getName (){\n       console.log(\"我是a中的函数\")\n    },\n    a:100\n}\nexport default module_a</code></pre>\n<p><br/> b.js</p>\n<pre><code class=\"language-javascript\">import module_a from './a.js'\nconsole.log(module_a.a)\nmodule_a.getName()</code></pre>\n<p><br/> 运行b.js</p>\n<pre><code class=\"language-javascript\">100\n我是a中的函数</code></pre>\n<p><br/><br/>  </p>\n<h2 id=\"%E6%80%8E%E4%B9%88%E5%8E%BB%E5%88%A4%E6%96%AD%E5%87%BA%E6%9D%A5%E6%95%B0%E7%BB%84%E9%87%8C%E9%9D%A2%E5%80%BC%E4%B8%BA1%E7%9A%84%E5%85%83%E7%B4%A0\" style=\"text-align:justify;\">怎么去判断出来数组里面值为1的元素</h2>\n<p>1.该值在数组中有多个，找出所有位置</p>\n<pre><code class=\"language-javascript\">   //封装函数 在数组中找到某个值所在的所有索引位置 \n        function indexOfAll(arr, val) {\n            let idxArr = [],\n                obj = {}\n            arr.forEach((item, index) =&gt; {\n                if (item == val) {\n\n                    idxArr.push(index)\n                }\n            })\n            return obj = {\n                [val]: idxArr\n            };\n        }\n\n        let arr = [1, 2, 3, 'hello', 'world', 23, 23, 3, 67, 3, 100];\n        console.log(indexOfAll(arr, 3))//{3:[2, 7, 9]}</code></pre>\n<p> 2，该值在数组中只有一个</p>\n<p><strong>返回true或者false</strong></p>\n<p>some（）</p>\n<pre><code class=\"language-javascript\">  console.log(arr.some((item) =&gt; {\n            return item == 1//这里放要判断的条件和值\n        }))</code></pre>\n<p><strong>返回索引</strong></p>\n<p><strong>arr.indexOf(val)  arr.lastIndexOf(val) val为要找的值</strong></p>\n<h2 id=\"%C2%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8E%BB%E4%BF%AE%E6%94%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%80%BC%EF%BC%9F\" style=\"text-align:justify;\"> 有一个数组，怎么去修改每一个值？</h2>\n<pre><code class=\"language-javascript\">\n    let arr = [1, 2, 3, 4, 5];\n    \n    //方法1，通过索引下标，找到要修改的元素，重新赋值\n    arr[0] = 10;\n    console.log(arr);//[10, 2, 3, 4, 5]\n    \n    //方法2，使用数组的spliceAPI，参数(起始下标, 要删除元素的个数, 要插入的元素)\n    arr.splice(1, 1, 20);\n    console.log(arr);//[10, 20, 3, 4, 5]\n\n    //方法3，都修改成同一个值\n    arr.fill(0);\n    console.log(arr);//[0, 0, 0, 0, 0]\n\n\n//  方法四  使用map()方法\n let arr = [1, 2, 3, 'hello', 'world', 23, 23, 3, 67, 3, 100];\n let arr2 = arr.map((item, index) =&gt; {\n            return item + \"元\"\n        })\n        console.log(arr2)//['1元', '2元', '3元', 'hello元', 'world元', '23元', '23元', '3元', '67元', '3元', '100元']\n\n//方法五  使用循环 foreach  、for 、for of、for in ....  </code></pre>\n<h2 id=\"%C2%A0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D\" style=\"text-align:justify;\"> 数组去重</h2>\n<p><strong>Methods 1: 思路：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。</strong></p>\n<pre><code class=\"language-javascript\">        function unique(arr) {\n            let newArr = [arr[0]];\n            for (let i = 1; i &lt; arr.length; i++) {\n                let repeat = false;\n                for (let j = 0; j &lt; newArr.length; j++) {\n                    if (arr[i] === newArr[j]) {\n                        repeat = true;\n                        break;\n                    }else{\n                        \n                    }\n                }\n                if (!repeat) {\n                    newArr.push(arr[i]);\n                }\n            }\n            return newArr;\n        }\n \n        console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/><strong>Methods 2: 思路：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</strong></p>\n<pre><code class=\"language-javascript\">        function unique2(arr) {\n            var formArr = arr.sort()\n            var newArr=[formArr[0]]\n            for (let i = 1; i &lt; formArr.length; i++) {\n                if (formArr[i]!==formArr[i-1]) {\n                    newArr.push(formArr[i])\n                }\n            }\n            return newArr\n        }\n        console.log(unique2([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3,  4,5, 6, 7]</code></pre>\n<p><br/><strong> Methods 3: 利用对象属性存在的特性，如果没有该属性则存入新数组。</strong></p>\n<pre><code class=\"language-javascript\">        function unique3(arr) {\n            var obj={}\n            var newArr=[]\n            for (let i = 0; i &lt; arr.length; i++) {\n                if (!obj[arr[i]]) {\n                    obj[arr[i]] = 1\n                    newArr.push(arr[i])\n                }   \n            }\n            return newArr\n        }\n        console.log(unique2([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/><strong>Methods 4: 利用数组的indexOf下标属性来查询。</strong></p>\n<pre><code class=\"language-javascript\">        function unique4(arr) {\n            var newArr = []\n            for (var i = 0; i &lt; arr.length; i++) {\n                if (newArr.indexOf(arr[i])===-1) {\n                    newArr.push(arr[i])\n                }\n            }\n            return newArr\n        }\n        console.log(unique4([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/><strong>Methods 5: 利用数组原型对象上的includes方法。</strong></p>\n<pre><code class=\"language-javascript\">        function unique5(arr) {\n            var newArr = []\n            for (var i = 0; i &lt; arr.length; i++) {\n                if (!newArr.includes(arr[i])) {\n                    newArr.push(arr[i])\n                }\n            }\n            return newArr\n        }\n        console.log(unique5([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/><strong>Methods 6: 利用数组原型对象上的 filter 和 includes方法。</strong></p>\n<pre><code class=\"language-javascript\">        function unique6(arr) {\n            var newArr = []\n            newArr = arr.filter(function (item) {\n                return newArr.includes(item) ? '' : newArr.push(item)\n            })\n            return newArr\n        }\n        console.log(unique6([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/><strong>Methods 7: 利用数组原型对象上的 forEach 和 includes方法。</strong></p>\n<p>       </p>\n<pre><code class=\"language-javascript\">   function unique7(arr) {\n            let newArr = [];\n            arr.forEach(item =&gt; {\n                return newArr.includes(item) ? '' : newArr.push(item);\n            });\n            return newArr;\n        }\n        console.log(unique7([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 4, 5, 6, 7]</code></pre>\n<p><br/><strong>Methods 8: 利用数组原型对象上的 splice 方法</strong>。</p>\n<pre><code class=\"language-javascript\">        function unique8(arr) {\n            var i,j,len = arr.length;\n            for (i = 0; i &lt; len; i++) {\n                for (j = i + 1; j &lt; len; j++) {\n                    if (arr[i] == arr[j]) {\n                        arr.splice(j, 1);\n                        len--;\n                        j--;\n                    }\n                }\n            }\n            return arr;\n        }\n        console.log(unique8([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));</code></pre>\n<p><br/><strong>Methods 9: 利用数组原型对象上的 lastIndexOf 方法。</strong></p>\n<pre><code class=\"language-javascript\">        function unique9(arr) {\n            var res = [];\n            for (var i = 0; i &lt; arr.length; i++) {\n                res.lastIndexOf(arr[i]) !== -1 ? '' : res.push(arr[i]);\n            }\n            return res;\n        }\n        console.log(unique9([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/><strong>Methods 10: 利用 ES6的set 方法。</strong></p>\n<pre><code class=\"language-javascript\">        function unique10(arr) {\n            //Set数据结构，它类似于数组，其成员的值都是唯一的\n            return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组\n        }\n        console.log(unique10([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));\n        // 结果是[1, 2, 3, 5, 6, 7, 4]</code></pre>\n<p><br/>  <br/>  </p>\n<h2 id=\"%C2%A0%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6\" style=\"text-align:justify;\"> 统计字符串中出现最多的字符</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n\t&lt;meta charset=\"utf-8\"&gt;\n\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n\t&lt;title&gt;&lt;/title&gt;\n\t&lt;link rel=\"stylesheet\" href=\"\"&gt;\n&lt;/head&gt;\n&lt;script&gt;\n\t// 判断一个字符串中出现次数最多的字符，统计这个次数\n\t//第一种方法\n\tvar str='asdoosdpedncxsdopdaqdg';\n\tfunction sum(str){\n\t\tvar json={};\n\t\tfor(var i=0;i&lt;str.length;i++){\n\t\t\tvar key=str.charAt(i);\n\t\t\tif(json[key]===undefined){\n\t\t\t\tjson[key]=1;\n\t\t\t}else{\n\t\t\t\tjson[key]+=1;\n\t\t\t}\n\t\t}\n\t\tconsole.log(json);\n\t\t\n\t\tvar maxkey=\"\";\n\t\tvar maxvalue=0;\n\t\tfor(var k in json){\n\t\t\tif(maxkey==\"\"){\n\t\t\t\tmaxkey=k;\n\t\t\t\tmaxvalue=json[k];\n\t\t\t}else{\n\t\t\t\tif(json[k]&gt;maxvalue){\n\t\t\t\t\tmaxkey=k;\n\t\t\t\t\tmaxvalue=json[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconsole.log(maxkey);//出现次数最多的字符\n\t\tconsole.log(maxvalue);//出现次数\n\t}\n\t// 执行函数\n\tsum(str);\n\n\t//第二种精简方法\n\tfunction count(str) { \n\t\tvar obj = {}; \n\t\tstr.replace(/\\S/g,function(s){\n\t\t !obj[s]?obj[s]=1:obj[s]++;\n\t\t}) \n\t\treturn obj; \n\t}\n\n\tcount(str);\n&lt;/script&gt;\n&lt;body&gt;\n\t\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\" style=\"text-align:justify;\">js垃圾回收机制</h2>\n<p>什么是垃圾？<br/><strong>（1）没有被引用的对象或变量</strong></p>\n<p><strong>（2）无法访问到的对象（几个对象引用形成一个环，互相引用）</strong></p>\n<p>可达性<br/><strong>可达性是指那些以某种方式可以访问到或可以用到的值，它们被保证存储在内存中</strong>。</p>\n<p>有一组基本的固有可达值，由于显而易见而无法删除：<br/> （1）本地函数的局部变量和参数<br/> （2）嵌套调用链上的其他函数的变量与参数<br/> （3）全局变量<br/> （4）还有一些其他的，内部的<br/> 这些值成为根。</p>\n<p>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。<br/> 垃圾回收机制<br/> 垃圾回收机制（GC：Garbage Collection）：执行环境负责管理代码执行过程中使用的内存。JS的垃圾回收机制是为了以防内存泄漏，<strong>内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，没有被释放，导致该内存无法被使用</strong>，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p>\n<p>垃圾回收的必要性<br/> 字符串、对象和数组没有固定的大小，所以只有当它们大小已知时才能对它们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都要分配内存才存储这个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便它们能够被再次利用;否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。<br/> JavaScript有自己的垃圾回收机制（Garbage Collection），JavaScript的解释器可用检测到何时程序不再使用一个对象，当确定了一个对象无用的时候，就说明不再需要这个对象了，就可用把这个对象所占用的内存释放掉。</p>\n<p>例如：</p>\n<pre><code class=\"language-javascript\">var a='use'\nvar b='over a'\nvar a=b   //将a重写</code></pre>\n<p><br/><br/> 代码执行以后，‘use’这个字符串就失去了引用（刚开始是被a引用的），系统检测到之后，就会启动垃圾回收机制，释放use字符串的存储空间，以便这些空间可用再被利用。</p>\n<p><strong>垃圾回收方式</strong><br/> JavaScript执行环境中的垃圾回收器怎样才能检测到哪块内存可以被回收呢？</p>\n<p>通常<strong>有两种方式</strong>：<strong>标记清除（</strong>mark and sweep）、<strong>引用计数</strong>（reference counting）</p>\n<p>标记清除<br/> 这是JavaScript中最常用的垃圾回收方式。</p>\n<p>（1）当变量进入执行环境时（函数中声明变量），就标记这个变量为“进入环境”，当变量离开环境时（函数执行结束），则将其标记为“离开环境”，离开环境之后还有的变量则是需要被删除的变量。</p>\n<p>（2）垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。</p>\n<p>（3）去掉环境中的变量以及被环境中变量引用的变量的标记。</p>\n<p>（4）之后再被加上标记的变量即是需要回收的变量（因为环境中的变量已经无法访问到这些变量）</p>\n<p>（5）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>\n<p>引用计数<br/> 这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时，则说明没有办法再访问这个值了，被视为准备回收的对象，每当过一段时间开始垃圾回收的时候，就把被引用数为0的变量回收。引用计数方法可能导致循环引用，类似死锁，导致内存泄露。</p>\n<p>例如：</p>\n<pre><code class=\"language-javascript\">function problem() {\n    var objA = new Object();\n    var objB = new Object();\n\n    objA.someOtherObject = objB;\n    objB.anotherObject = objA;\n}</code></pre>\n<p><br/><br/> objA和objB相互引用，两个对象的引用次数都是2。函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>\n<p>补充：</p>\n<p>常见内存泄漏的原因：</p>\n<p>（1）全局变量引起的内存泄露<br/> （2）闭包引起的内存泄露：慎用闭包<br/> （3）dom清空或删除时，事件未清除导致的内存泄漏<br/> （4）循环引用带来的内存泄露<br/>  </p>\n<h2 id=\"%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE\" style=\"text-align:justify;\">原型、原型链</h2>\n<p>一、原型<br/> ①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象<br/> ②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象<br/> ③所有引用类型的__proto__属性指向它构造函数的prototype</p>\n<pre><code class=\"language-javascript\">var a = [1,2,3];\na.__proto__ === Array.prototype; // true</code></pre>\n<p><br/><br/> 二、原型链<br/> 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p>\n<p>对象的__proto__和构造函数的原型prototype组成了原型链</p>\n<p>举例，有以下代码</p>\n<pre><code class=\"language-javascript\">function Parent(month){\n    this.month = month;\n}\n\nvar child = new Parent('Ann');\n\nconsole.log(child.month); // Ann\n\nconsole.log(child.father); // undefined</code></pre>\n<p><br/><br/> 在child中查找某个属性时，会执行下面步骤：</p>\n<p>访问链路为：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\2c00c3c083104961a2d7fe443579b119.png\"/>访问路链为 ：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdn.net/20180620155400807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p>①一直往上层查找，直到到null还没有找到，则返回undefined<br/><strong>②Object.prototype.__proto__ === null  注意这里的Null是一个对象</strong><br/> ③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象<br/> 原文链接：<a href=\"https://blog.csdn.net/xiaoermingn/article/details/80745117\" title=\"【原型和原型链】什么是原型和原型链_TowYingWang的博客-CSDN博客_原型和原型链\">【原型和原型链】什么是原型和原型链_TowYingWang的博客-CSDN博客_原型和原型链</a></p>\n<h2 id=\"%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\" style=\"text-align:justify;\">作用域链</h2>\n<p><strong>一般情况使用的变量取值是在当前执行环境的作用域中查找，如果当前作用域没有查到这个值，就会向上级作用域查找，直到查找到全局作用域，这么一个查找的过程我们叫做作用域链，下级作用域可以向上级作用域不断查找，但是上级作用域不能向下级作用域查找，类似原型链</strong></p>\n<p><strong>举个栗子：</strong></p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n    let a = 10;\n\n    function tttt() {\n        let b = 20;\n        return function ttt() {\n            return function tt() {\n                return function t() {\n                    let c = '张三'\n                    var d = \"小李\"\n                    a = 'hello';\n                    b = \"world\"\n                    console.log(b) //在全局访问不了b 所以在这打印     world\n\n                }\n            }\n        }\n    }\n    // 调用最内层函数 t 看看a  、b的值会不会改变\n    tttt()()()()\n    console.log(a)//hello\n        // console.log(d)//d is not defined\n    console.log(c)//c is not defined\n&lt;/script&gt;</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"107\" src=\"..\\..\\static\\image\\18360c474fb74588ad1ffdc907d60cd8.png\" width=\"440\"/></p>\n<p></p>\n<p>可以看到 a 、b的值改变了 </p>\n<h2 id=\"%E9%97%AD%E5%8C%85\" style=\"text-align:justify;\">闭包</h2>\n<p>1.什么是闭包？<br/> 如果一个函数用到了它作用域外面的变量，那么这个变量和这个函数之间的环境就叫闭包。</p>\n<p>闭包有以下个特性：</p>\n<ol><li>函数嵌套函数；</li><li>内部函数用到了外部函数的参数和变量；</li><li>参数和变量不会被垃圾回收机制回收。</li><li>参数和变量不会被垃圾回收机制回收</li></ol>\n<p>2.用码举例</p>\n<pre><code>function a() {\n  var i = 0;\n  return function inner() {\n    i++;\n    return i;\n  };\n}\n \n// 或者\nfunction a() {\n  var i = 0;\n  function inner() {\n    return i;\n  }\n}</code></pre>\n<p><br/> 闭包使函数的私有变量不受外部干扰</p>\n<p>是变量存于内存中不被销毁</p>\n<pre><code class=\"language-javascript\"> function a() {\n    var i = 0;\n    return function () {\n        i++;\n        return i;\n    };\n}\nvar fn = a();\nconsole.log(fn()); //输出结果: 1\nconsole.log(fn()); //输出结果: 2\nconsole.log(fn()); //输出结果: 3</code></pre>\n<p><br/> 变量 i 保存在父作用域中，每次访问函数 y 时， 在函数 y 中找不到变量 i， 会顺着作用域链一直向上找，直到全局作用域中也没找到为止。</p>\n<p>闭包常用于实现单例模式、柯里化、防抖、节流、模块化。</p>\n<p>滥用闭包可能会造成内存泄漏（无用变量存于内存中无法回收，一直占用内存）。解决此问题的方法是，清除变量（设为 null）。<br/> 本文链接：<a href=\"https://blog.csdn.net/nilmao/article/details/123717311\" title=\"【闭包】什么是闭包？闭包用途_nilmao的博客-CSDN博客_闭包\">【闭包】什么是闭包？闭包用途_nilmao的博客-CSDN博客_闭包</a></p>\n<h2 id=\"%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95\" style=\"text-align:justify;\">继承方法</h2>\n<p></p>\n<pre><code class=\"language-javascript\"> //动物园\n\n        //继承性： 先一个父类，然后子类继承父类的方法和属性\n        //动物类：动物所有的共有内容放到动物类\n        //对应的动物类型时继承 动物类的方法或者属性\n\n        //动物类(构造函数)\n        function Animal(name, age, color) {\n            this.name = name\n            this.age = age\n            this.color = color\n        }\n        Animal.prototype.move = function() {\n            console.log(this.name + \"正在移动\")\n        }\n        Animal.prototype.eat = function() {\n            console.log(this.name + \"正在吃\")\n        }\n\n        //狗：构造函数 继承 Animal中所有的属性和方法\n        //方法一：原型链继承：将原型改成对应的对象\n        //问题：无法初始化对应的属性 \n        function Dog(name, age, color) {\n\n        }\n        Dog.prototype = new Animal(\"小黑\", 2, \"白色\")\n            //{name:'小黑',age:2,color:\"白色\"}\n        Dog.prototype.watch = function() {\n                console.log('汪汪汪')\n            }\n            // var d1=new Dog(\"旺财\",5,\"黑色\")\n            // var d2=new Dog(\"小白\",4,\"褐色\")\n            // d1.move()\n\n\n            //老虎：\n            //方法二：冒充继承法：通过call或者apply改变原有函数的this指向，实现的\n            //问题：无法将原型中所带有的方法和属性继承过来\n\n        function Tiger(name, age, color) {\n            this.height = 180\n                //改变Animal中this的指向性\n                //call和apply 面试题！！！！\n            Animal.call(this, name, age, color)\n        }\n        Tiger.prototype.chiren = function() {\n                console.log(this.name + \"吃人\")\n            }\n            //产生一个新的对象  构造函数内部this-&gt;{}\n            // var t1=new Tiger(\"心吧\",21,\"八色\")\n            // t1.eat()\n            // console.log(t1)\n\n方法一和方法二都不是正确的继承方式，将他两结合得到正确的组合继承\n\n\n            //猫\n            //方法三：组合继承：冒充继承+原型继承\n        function Cat(name, age, color) {\n            Animal.call(this, name, age, color)\n                //    Animal.apply(this,[name,age,color])\n        }\n        Cat.prototype = new Animal()\n        Cat.prototype.maimeng = function() {\n            console.log(this.name + \"正在卖萌\")\n        }\n        var c1 = new Cat(\"小白\", 2, \"白色\")\n        console.log(c1)\n        c1.move()</code></pre>\n<p><strong> 方法四 es6中的继承 使用 extends和super进行继承</strong></p>\n<p>1、使用class构造一个父类</p>\n<pre><code class=\"language-javascript\">  class Parent {\n      constructor(name,age){\n        this.name = name\n        this.age = age\n      }\n      sayName(){\n        console.log(this.name);\n      }\n    }</code></pre>\n<p><br/><br/> 2、使用class构造一个子类，并使用extends实现继承，super指向父类的原型对象</p>\n<p></p>\n<pre><code class=\"language-javascript\">  class Child extends Parent{\n      constructor(name,age,gender){\n        super(name,age) //这里的super（）必须写在constructor内部的最上面\n        this.gender = gender  //super 下方可以添加其他属性和方法\n      }\n      sayGender(){\n        console.log(this.gender);\n      }\n    }</code></pre>\n<p><br/><br/> 3、实例化对象</p>\n<pre><code class=\"language-javascript\">      const ming = new Child('ming',18,'男')\n    ming.sayGender()\n    ming.sayName()\n    console.log(ming.name);\n    console.log(ming.age);</code></pre>\n<p>方法五：原型式继承</p>\n<p>这里不得不提到的就是 <strong>ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）</strong>。</p>\n<pre><code class=\"language-javascript\">let parent4 = {\n  name: 'parent4',\n  friends: ['p1', 'p2', 'p3'],\n  getName: function () {\n    return this.name\n  },\n}\n\n//下面这句代码将parent4作为了person的原型\nlet person = Object.create(parent4) \n\nperson.name = 'Tom'\nperson.friends.push('jerry')\n\nlet person2 = Object.create(parent4)\nperson2.friends.push('lucy')\n\nconsole.log(person.name)\nconsole.log(person.name === person.getName())\nconsole.log(person2.name)\nconsole.log(person.friends)\nconsole.log(person2.friends)\n\n</code></pre>\n<p>通过 Object.create 这个方法可以实现普通对象的继承，不仅仅能继承属性，同样也可以继承 getName 的方法，请看这段代码的执行结果。<br/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210314113515602.png\"/><br/> 最后两个输出结果是一样的，讲到这里你应该可以联想到浅拷贝的知识点，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。</p>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95\" style=\"text-align:justify;\">辗转相除法</h2>\n<p>辗转相除法又名欧几里得算法（Euclidean algorithm）<br/> 目的是求出两个正整数的最大公约数</p>\n<p></p>\n<p>代码实现</p>\n<pre><code class=\"language-javascript\">function gcd(a ,b) {\n    let max = a &gt; b ? a : b;    //获取两数之间最大的数\n    let min = a &gt; b ? b : a;    //获取两数之间最小的数\n    let r = max % min;          //获取两数的余数\n    if(r === 0) {\n        return min;\n    }else {\n        return gcd(min ,r);\n    }\n}\n\nfunction gcd(a ,b) {\n    return b === 0 ? a : gcb(b ,a % b);\n}</code></pre>\n<p><br/><br/>  </p>\n<p></p>\n<h2 id=\"%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2\" style=\"text-align:justify;\">数组转字符串</h2>\n<p></p>\n<p>JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。</p>\n<p>数组方法    说明</p>\n<ol><li>toString()    将数组转换成一个字符串</li><li>toLocalString()    把数组转换成本地约定的字符串</li><li>join()    将数组元素连接起来以构建一个字符串</li></ol>\n<p>示例1<br/> 下面使用 toString() 方法读取数组的值。</p>\n<p>数组中 toString() 方法能够把每个元素转换为字符串，然后以逗号连接输出显示。</p>\n<pre><code class=\"language-javascript\">var a = [1,2,3,4,5,6,7,8,9,0];  //定义数组\nvar s = a.toString();  //把数组转换为字符串\nconsole.log(s);  //返回字符串“1,2,3,4,5,6,7,8,9,0”\nconsole.log(typeof s);  //返回字符串string，说明是字符串类型</code></pre>\n<p><br/><br/> 当数组用于字符串环境中时，JavaScript 会自动调用 toString() 方法将数组转换成字符串。在某些情况下，需要明确调用这个方法。</p>\n<pre><code class=\"language-javascript\">var a = [1,2,3,4,5,6,7,8,9,0];  //定义数组\nvar b = [1,2,3,4,5,6,7,8,9,0];  //定义数组\nvar s = a + b;  //数组连接操作\nconsole.log(s);  //返回“1,2,3,4,5,6,7,8,9,01,2,3,4,5,6,7,8,9,0”\nconsole.log(typeof s);  //返回字符串string，说明是字符串类型</code></pre>\n<p><br/><br/> toString() 在把数组转换成字符串时，首先要将数组的每个元素都转换为字符串。当每个元素都被转换为字符串时，才使用逗号进行分隔，以列表的形式输出这些字符串。</p>\n<pre><code class=\"language-javascript\">var a = [1,[2,3],[4,5]],[6,[7,[8,9],0]]];  //定义多维数组\nvar s = a.toString();  //把数组转换为字符串\nconsole.log(S);  //返回字符串“1,2,3,4,5,6,7,8,9,0”</code></pre>\n<p><br/><br/> 其中数组 a 是一个多维数组，JavaScript 会以迭代的方式调用 toString() 方法把所有数组都转换为字符串。</p>\n<p>示例2<br/><strong>下面使用 toLocalString() 方法读取数组的值。</strong></p>\n<p>toLocalString() 方法与 toString() 方法用法基本相同，主要区别在于 toLocalString() 方法能够使用用户所在地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</p>\n<pre><code class=\"language-javascript\">var a = [1,2,3,4,5];  //定义数组\nvar s = a.toLocalString();  //把数组转换为本地字符串\nconsole.log(s);  //返回字符串“1,2,3,4,5,6,7,8,9,0”</code></pre>\n<p><br/><br/> 在上面示例中，toLocalString() 方法根据中国的使用习惯，先把数字转换为浮点数之后再执行字符串转换操作。</p>\n<p>示例3<br/><strong>下面使用 join() 方法可以把数组转换为字符串</strong>。</p>\n<p><strong>join() 方法可以把数组转换为字符串，不过它可以指定分隔符。在调用 join() 方法时，可以传递一个参数作为分隔符来连接每个元素</strong>。如果省略参数，默认使用逗号作为分隔符，这时与 toString() 方法转换操作效果相同。</p>\n<pre><code class=\"language-javascript\">var a = [1,2,3,4,5];  //定义数组\nvar s = a.join(\"==\");  //指定分隔符\nconsole.log(s);  //返回字符串“1==2==3==4==5”</code></pre>\n<p><br/><br/> 示例4<br/> 下面使用 split() 方法把字符串转换为数组。</p>\n<p>split() 方法是 String 对象方法，<strong>与 join() 方法操作正好相反。该方法可以指定两个参数，第 1 个参数为分隔符，指定从哪儿进行分隔的标记；第 2 个参数指定要返回数组的长度</strong>。</p>\n<pre><code class=\"language-javascript\">var s = \"1==2== 3==4 ==5\";\nvar a = s.split(\"==\");\nconsole.log(a);\nconsole.log(a.constructor == Array);</code></pre>\n<p><br/>  </p>\n<h2 id=\"%E4%BA%8C%E7%BA%A7%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95\" style=\"text-align:justify;\">二级下拉菜单</h2>\n<p>这里用原生js实现</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;select id=\"bt1\"&gt;\n\n\n    &lt;/select&gt;\n\n    &lt;select id=\"bt2\"&gt;\n\n    &lt;/select&gt;\n&lt;/body&gt;\n&lt;script&gt;\n    var cityArr = ['北京', '上海', '广州'];\n    var areaArr = [\n        [\"东城区\", \"西城区\", \"崇文区\", \"宣武区\", \"朝阳区\", \"丰台区\", \"石景山区\", \"海淀区\", \"门头沟区\", \"房山区\", \"通州区\", \"顺义区\", \"昌平区\", \"大兴区\", \"平谷区\", \"怀柔区\", \"密云县\", \"延庆县\"],\n        [\"黄浦区\", \"徐汇区\", \"长宁区\", \"静安区\", \"普陀区\", \"闸北区\", \"虹口区\", \"杨浦区\", \"宝山区\", \"闵行区\", \"嘉定区\", \"松江区\", \"金山区\", \"青浦区\", \"南汇区\", \"奉贤区\", \"浦东新区\", \"崇明县\"],\n        [\"越秀区\", \"荔湾区\", \"海珠区\", \"天河区\", \"白云区\", \"黄埔区\", \"番禺区\", \"花都区\", \"南沙区\", \"萝岗区\", \"增城市\", \"从化市\"]\n    ]\n\n    // 把以上两个数据做到两个下拉列表中，并关联起来\n    //给bt1添加内容\n    var str = \"\";\n    for (var j = 0; j &lt; cityArr.length; j++) {\n        str = str + \"&lt;option&gt;\" + cityArr[j] + \"&lt;/option&gt;\";\n    };\n    console.log(str)\n    var bt1 = document.getElementById(\"bt1\"); //设置变量bt1=页面中id为bt1的元素\n    bt1.innerHTML = str; //设置bt1的内容为str\n\n    //给bt2添加内容\n    var str1 = \"\";\n\n    for (var k = 0; k &lt; areaArr[0].length; k++) {\n        str1 = str1 + \"&lt;option&gt;\" + areaArr[0][k] + \"&lt;/option&gt;\";\n    }\n\n    console.log(str1);\n    var bt2 = document.getElementById(\"bt2\"); //设置变量bt2=页面中id为bt2的元素\n    bt2.innerHTML = str1; //设置bt2的内容为str\n\n    // 联动 城市变化时对应的地区也发生变化\n\n    bt1.onchange = function() {\n        var index = bt1.selectedIndex;\n        var str1 = \"\";\n        for (var n = 0; n &lt; areaArr[index].length; n++) {\n            str1 = str1 + \"&lt;option&gt;\" + areaArr[index][n] + '&lt;/option&gt;'\n        }\n        bt2.innerHTML = str1;\n    }\n&lt;/script&gt;\n\n&lt;/html&gt;</code></pre>\n<p></p>\n<h2 id=\"%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F\" style=\"text-align:justify;\">图片预加载和懒加载？</h2>\n<p></p>\n<p>原生js实现图片懒加载</p>\n<pre><code class=\"language-html\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        * {\n            padding: 0;\n            margin: 0;\n            list-style: none;\n        }\n        \n        ul {\n            width: 910px;\n            margin: 0 auto;\n        }\n        \n        ul li {\n            width: 300px;\n            height: 300px;\n            border: 1px solid red;\n            float: left;\n        }\n        \n        ul li img {\n            width: 100%;\n            height: 100%;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;ul id=\"list\"&gt;\n\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;script type=\"text/javascript\"&gt;\n    var list = document.getElementById(\"list\");\n    for (var i = 1; i &lt;= 32; i++) {\n\n//下面这行代码写图片的路径\n        var imgPath = './image/' + (i &lt;= 9 ? ('0' + i) : i) + \".jfif\";\n        var li = document.createElement(\"li\");\n        var img = document.createElement(\"img\");\n        img._src = imgPath;\n        li.appendChild(img);\n        list.appendChild(li);\n    }\n    var imgArr = document.querySelectorAll(\"img\");\n    console.log(imgArr[0]._src);\n    //只显示可视区中的图片\n    for (var i = 0; i &lt; imgArr.length; i++) {\n        var imgOffsetTop = imgArr[i].offsetTop;\n        var bodyHeigh = document.documentElement.clientHeight;\n        var bodySt = document.documentElement.scrollTop || document.body.scrollTop;\n        //图片的上边框显示到可视区域中\n        if (imgOffsetTop &lt;= bodyHeigh + bodySt) {\n            imgArr[i].src = imgArr[i]._src;\n        }\n    }\n\n    window.onscroll = function() {\n        var imgArr = document.querySelectorAll(\"img\");\n        //只显示可视区中的图片\n        for (var i = 0; i &lt; imgArr.length; i++) {\n            var imgOffsetTop = imgArr[i].offsetTop;\n            var bodyHeigh = document.documentElement.clientHeight;\n            var bodySt = document.documentElement.scrollTop || document.body.scrollTop;\n            //图片的上边框显示到可视区域中\n            if (imgOffsetTop &lt;= bodyHeigh + bodySt) {\n                imgArr[i].src = imgArr[i]._src\n            }\n        }\n    }\n&lt;/script&gt;\n\n&lt;/html&gt;\n\n</code></pre>\n<p></p>\n<p>图片预加载和懒加载<br/> 图片懒加载<br/> 在渲染页面的时候，先将图片用一张默认图片代替，当图片到达浏览器可视区域时，才显示真实的图片。</p>\n<p>这样的好处是，可以减缓服务器负担，加快初始界面的渲染速度。</p>\n<p>实现方式：</p>\n<p>使用setTimeOut或setInterval定时器进行延迟加载<br/> 条件加载，符合条件或触发事件后再进行异步下载<br/> 通过滚动条监听用户距图片距离，快要到达之前进行加载</p>\n<pre><code class=\"language-javascript\">// 通过滚动条监听用户距图片距离，到达进行加载\n    let img = document.querySelector('img')\n    function lazyLoad(){\n      let viewHeight = document.documentElement.clientHeight\n      let scrollTop = document.documentElement.scrollTop\n      // 判断图片是否进入可视区\n      if(img.offsetTop &lt; viewHeight+scrollTop){\n        var url =\"https://himg.bdimg.com/sys/portraitn/item/46ecf7f5\"\n        img.src = url\n      }\n    }\n    window.addEventListener('scroll',lazyLoad)\n\n//如果放多张图片 使用循环</code></pre>\n<p><br/><br/> 图片预加载<br/> 与懒加载相反，先将图片提前加载到缓存，用户一打开页面就能快速呈现图片。</p>\n<p>好处是，遇到一些较大的图片时，可以避免页面慢慢渲染。但是服务器负担会增大。</p>\n<p>实现方式：css的background元素会自动预加载</p>\n<pre><code class=\"language-html\">// 预加载的图片不能使用dispaly:none隐藏，只能将其宽高设为0或者移到看不见的地方\n  &lt;style&gt;\n    li{\n      list-style: none;\n    }\n    #img {\n    background-image: url('https://himg.bdimg.com/sys/portraitn/item/46ecf7f5');\n    width: 0;\n    height: 0;  \n    }\n  &lt;/style&gt;\n\n&lt;body&gt;\n  &lt;li id=\"img\"&gt;&lt;/li&gt;\n  &lt;button&gt;点击展示&lt;/button&gt;\n\n  &lt;script&gt;\n    let btn =  document.querySelector('button')\n    let li = document.querySelector('li')\n    btn.addEventListener('click',function(){\n      let myImg = document.createElement('img')\n      myImg.src = 'https://himg.bdimg.com/sys/portraitn/item/46ecf7f5'\n      li.appendChild(myImg)\n    })  &lt;/script&gt;\n  \n&lt;/body&gt;</code></pre>\n<p><br/><br/> JavaScript则常用new Image()实现<br/>  </p>\n<pre><code class=\"language-javascript\">   // 预加载图片路径\n    const urlList = [\n    'https://himg.bdimg.com/sys/portraitn/item/46ecf7f5'\n    ]\n\n    function preLoad(){\n      let img = new Image()\n      img.src = urlList[0]\n      // onload是图片加载完成事件\n      img.onload = function(){\n\n        //放入图片加载完之后的操作\n        console.log('图片预加载成功');\n\n      }\n    }</code></pre>\n<p><br/>     preLoad()<br/><br/>  </p>\n<p><br/><a class=\"link-info\" href=\"https://blog.csdn.net/qq_47234456/article/details/124568755\" title=\"原文链接：https://blog.csdn.net/qq_47234456/article/details/124568755\">原文链接：https://blog.csdn.net/qq_47234456/article/details/124568755</a></p>\n<h2 id=\"bind()%20apply()\" style=\"text-align:justify;\">bind() apply()</h2>\n<h2 id=\"const%E7%94%A8%E6%B3%95\" style=\"text-align:justify;\">const用法</h2>\n<h2 id=\"Utf-8%E7%BC%96%E7%A0%81%E6%B1%89%E5%AD%97%E5%8D%A0%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82\" style=\"text-align:justify;\">Utf-8编码汉字占多少个字节</h2>\n<h2 id=\"ajax\" style=\"text-align:justify;\">ajax</h2>\n<h2 id=\"js%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\" style=\"text-align:justify;\">js对数组的操作，包括向数组中插入删除数据</h2>\n<h2 id=\"%E4%B8%A4%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8Csetinterval%E5%92%8Csettimeout%E3%80%82%E5%9B%A0%E4%B8%BAsettimeout%E6%98%AF%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A6%81%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E6%80%8E%E4%B9%88%E5%81%9A%E3%80%82%EF%BC%88%E7%AD%94%E6%A1%88%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%EF%BC%8C%E5%A4%A7%E6%A6%82%E6%98%AF%E8%BF%99%E6%A0%B7%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%9F%A5%E6%9F%A5%EF%BC%89\" style=\"text-align:justify;\">两种定时器，setinterval和settimeout。因为settimeout是只执行一次的，如果要执行多次怎么做。（答案：设置一个回调函数，多次调用，大概是这样，你可以去查查）</h2>\n<h2 id=\"JS%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\" style=\"text-align:justify;\">JS内存回收机制</h2>\n<h2 id=\"promise%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\" style=\"text-align:justify;\">promise是什么？能解决什么问题？</h2>\n<h2 id=\"%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B9%B6%E8%BF%94%E5%9B%9E%EF%BC%9F\" style=\"text-align:justify;\">编程：连接两个数组并返回？</h2>\n<h2 id=\"%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9F\" style=\"text-align:justify;\">冒泡排序？</h2>\n<h2 id=\"%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%90%91%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\" style=\"text-align:justify;\">创建新数组，向数组插入数据</h2>\n<h2 id=\"es6%E6%96%B0%E7%89%B9%E6%80%A7\" style=\"text-align:justify;\">es6新特性</h2>\n<h2 id=\"js%E5%AF%B9%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\" style=\"text-align:justify;\">js对数组有哪些操作方法</h2>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88\" style=\"text-align:justify;\">什么是ajax，可以用来做什么</h2>\n<h2 id=\"%E8%AE%B2%E4%B8%8B%E4%BD%A0%E5%81%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%8C%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD\" style=\"text-align:justify;\">讲下你做轮播图的思路，无缝轮播</h2>\n<h2 id=\"js%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8\" style=\"text-align:justify;\">js的选择器</h2>\n<h2 id=\"js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" style=\"text-align:justify;\">js数据类型</h2>\n<h2 id=\"%E5%87%8F%E5%B0%91%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95\" style=\"text-align:justify;\">减少页面加载时间的方法</h2>\n<h2 id=\"%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91\" style=\"text-align:justify;\">怎么理解模块化开发</h2>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\" style=\"text-align:justify;\">什么是闭包，有什么作用？</h2>\n<h2 id=\"%E5%AE%9A%E6%97%B6%E5%99%A8%20settimeout%E5%92%8Csetinterval%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8settimeout%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E5%AE%9A%E7%9A%84%E6%97%B6%E9%97%B4%E5%B0%B1%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0\" style=\"text-align:justify;\">定时器 settimeout和setinterval的区别，如果用settimeout实现每隔一定的时间就执行一次，怎么实现</h2>\n<h2 id=\"%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%BB%A51%E5%BC%80%E5%A4%B4%E7%9A%8411%E4%BD%8D%E6%95%B0%E5%AD%97)\" style=\"text-align:justify;\">手机号的正则表达式(以1开头的11位数字)</h2>\n<h2 id=\"%3Col%3E%3Cli%3E%3C%2Fli%3E%3C%2Fol%3E%E7%BB%93%E6%9E%84%E7%9A%84html%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%9F%90%E4%B8%AAli%E5%B0%B1%E5%BC%B9%E5%87%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B4%A2%E5%BC%95%E5%80%BC\" style=\"text-align:justify;\">&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;结构的html代码，写原生js实现点击某个li就弹出对应的索引值</h2>\n<h2 id=\"%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%EF%BC%8C%20%E8%A6%81%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%8D%E8%83%BD%E5%81%9C%E7%95%99%E5%9C%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%BD%8D%E7%BD%AE\" style=\"text-align:justify;\">对数组进行随机排序， 要求数组中的每个元素不能停留在原来的位置</h2>\n<h2 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0parse%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E6%9C%89%E6%95%88%E7%9A%84JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90JavaScript%E5%AF%B9%E8%B1%A1\" style=\"text-align:justify;\">代码实现parse方法，将有效的JSON字符串转换成JavaScript对象</h2>\n<h2 id=\"%E5%8E%9F%E7%94%9Fjs%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FES6%E6%96%B0%E5%A2%9E%E5%93%AA%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%9F\" style=\"text-align:justify;\">原生js的变量类型有哪些？ES6新增哪几个变量类型？</h2>\n<h2 id=\"js%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\" style=\"text-align:justify;\">js的数组方法有哪些？</h2>\n<h2 id=\"es6%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%E7%9A%84%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\" style=\"text-align:justify;\">es6的有哪些扩展？新增的数组方法有哪些？用什么方法连接两个数组？函数扩展中的箭头函数中的this所指向的是什么？一般函数的this指向的又是什么？</h2>\n<h2 id=\"%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F%E5%8F%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F\" style=\"text-align:justify;\">用什么方法判断是否是数组？又用什么方法判断是否是对象？</h2>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"http%E7%9B%B8%E5%85%B3\" style=\"margin-left:0;text-align:justify;\">http相关</h1>\n<ol><li style=\"text-align:justify;\">GET和POST的区别？何时使用POST**</li><li style=\"text-align:justify;\">http状态码</li><li style=\"text-align:justify;\">HTTP状态码200/302/401/404/500分别代表什么意思</li><li style=\"text-align:justify;\">http协议</li><li style=\"text-align:justify;\">http中的方法，除了get方法、post方法</li><li style=\"text-align:justify;\">http和https的区别</li><li style=\"text-align:justify;\">http协议</li></ol>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"%E6%B5%8F%E8%A7%88%E5%99%A8\" style=\"margin-left:0;text-align:justify;\">浏览器</h1>\n<ol><li style=\"text-align:justify;\">浏览器存储</li><li style=\"text-align:justify;\">浏览器图片加载</li></ol>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"bootstrap\" style=\"margin-left:0;text-align:justify;\">bootstrap</h1>\n<ol><li style=\"text-align:justify;\">bootstrap的原理</li><li style=\"text-align:justify;\">46.用过bootstrap的哪些组件，导航条怎么实现的（问原理），怎么适应窗口大小？</li><li style=\"text-align:justify;\">d-flex和d-block有什么冲突？</li><li style=\"text-align:justify;\">bootstrap的grid-system?</li><li style=\"text-align:justify;\">bookstrap的响应式所示怎么实现的。</li><li style=\"text-align:justify;\">bookstrap栅格系统，你怎么理解栅格系统</li></ol>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"vue%E7%9B%B8%E5%85%B3\" style=\"margin-left:0;text-align:justify;\">vue相关</h1>\n<ol><li style=\"text-align:justify;\">vue生命周期的理解</li><li style=\"text-align:justify;\">v-if和v-show的作用相似，它们的区别？</li><li style=\"text-align:justify;\">vue项目</li><li style=\"text-align:justify;\">v-model双向绑定原理</li><li style=\"text-align:justify;\">用过vue的哪些组件？</li><li style=\"text-align:justify;\">vue项目用什么搭建的，搭建的时候有遇到过什么问题吗？</li><li style=\"text-align:justify;\">axios的withCredential? intercepter,</li><li style=\"text-align:justify;\">vue-router 的模式有？</li><li style=\"text-align:justify;\">head标签里面有个什么vue(发音一样我不知道是什么)方法还是啥东西？</li><li style=\"text-align:justify;\">watch的作用？为什么要用它？</li><li style=\"text-align:justify;\">vue的生命周期，哪个钩子函数可以数据请求，为什么？</li><li style=\"text-align:justify;\">vue第三方组件的引入</li><li style=\"text-align:justify;\">vue第三方组件的引入</li><li style=\"text-align:justify;\">Vue中有哪些生命周期函数</li><li style=\"text-align:justify;\">路由跳转的方式</li><li style=\"text-align:justify;\">vue生命周期的理解</li><li style=\"text-align:justify;\">vue数据双向绑定的原理，用了什么设计模式(web高级)</li><li style=\"text-align:justify;\">Vue的钩子函数</li><li style=\"text-align:justify;\">Vue基于什么语言</li><li style=\"text-align:justify;\">Vue的第三方组件库ivew</li><li style=\"text-align:justify;\">组件之间的传参（例如子组件和父组件之间的传参）</li><li style=\"text-align:justify;\">vue如何实现双向据绑定？</li><li style=\"text-align:justify;\">vue父组件子组件通信？</li><li style=\"text-align:justify;\">vue删除数据监测不到？</li><li style=\"text-align:justify;\">父组件子组件传参</li><li style=\"text-align:justify;\">路由跳转的方式</li><li style=\"text-align:justify;\">vue路由传参怎么实现？</li><li style=\"text-align:justify;\">vue生命周期的钩子函数有哪些？</li><li style=\"text-align:justify;\">MVVM和MVC区别？</li></ol>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"node%E7%9B%B8%E5%85%B3\" style=\"margin-left:0;text-align:justify;\">node相关</h1>\n<p style=\"text-align:justify;\">1 做node用了什么框架</p>\n<p style=\"text-align:justify;\">2 用mongodb做过什么</p>\n<p style=\"text-align:justify;\">3 node.js</p>\n<h2 id=\"4%C2%A0%20module.export%E5%92%8Cexport%EF%BC%9F\" style=\"text-align:justify;\">4  module.export和export？</h2>\n<p style=\"text-align:justify;\"></p>\n<p>每一个<a href=\"https://so.csdn.net/so/search?q=node&amp;spm=1001.2101.3001.7020\" title=\"node\">node</a>.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是 {}</p>\n<pre><code> module.exports = {};</code></pre>\n<p>在 node 的 js 模块里可以直接调用 <a href=\"https://so.csdn.net/so/search?q=exports&amp;spm=1001.2101.3001.7020\" title=\"exports\">exports</a> 和 module 两个“全局”变量，但是 exports 是 module.exports 的一个引用。</p>\n<ul><li><strong>exports 是 module.exports 的一个引用</strong></li><li><strong>module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {}</strong></li><li><strong>require 引用模块后，返回的是 module.exports 而不是 exports!!!!!</strong></li><li><strong>exports.xxx 相当于在导出对象上挂属性，该属性对调用模块直接可见</strong></li><li><strong>exports = 相当于给 exports 对象重新赋值，调用模块不能访问 exports 对象及其属性</strong></li><li><strong>如果此模块是一个类，就应该直接赋值 module.exports，这样调用者就是一个类构造器，可以直接 new 实例。</strong></li></ul>\n<pre><code class=\"language-javascript\">//plus.js\n\nfunction plus(a,b){\n\nreturn a+b;\n\n}\n\n// 这样导出的 plus 是作为 exports 的一个方法被导出的\n\nexports.plus = plus;\n\n\n\n// main.js\n\nvar Plus = require('plus');\n\nconsole.log(Plus.plus(1,2)); // 左边的 Plus 是 require 过来的模块名，右边的是它的 plus 方法。</code></pre>\n<p>在 node 编译的过程中，会把 js 模块封装成如下形式：</p>\n<pre>\n</pre>\n<pre><code class=\"language-javascript\">// require 是对 Node.js 实现查找模块的 Module._load 实例的引用\n\n// __finename 和 __dirname 是 Node.js 在查找该模块后找到的模块名称和模块绝对路径\n\n(function(exports,require,module,__filename,__dirname){\n\nfunction plus(a,b){\n\nreturn a+b;\n\n}\n\nexports.plus = plus;\n\n})</code></pre>\n<p>为了将函数直接导出成模块，而不是模块的一个方法，需要</p>\n<p>module.exports = plus;</p>\n<pre><code class=\"language-javascript\">// plus.js\n\nfunction plus(a,b){\n\nreturn a+b ;\n\n}\n\nmodule.exports = plus;\n\n// main.js\n\nvar plus = require('plus');\n\nconsole.log(plus(1,2));</code></pre>\n<p></p>\n<p>exports = module.exports = {};</p>\n<ul><li></li></ul>\n<p>例子一：</p>\n<pre><code class=\"language-javascript\">var name = 'rainbow';\n\nexports.name = name;\n\nexports.sayName = function(){\n\nconsole.log(name);\n\n}\n\n// 给 exports 赋值相当于给 module.exports 这个空对象添加了两个属性，相当于：\n\nvar name = 'rainbow';\n\nmodule.exports.name = name;\n\nmodule.exports.sayName = function(){\n\nconsole.log(name);\n\n}</code></pre>\n<p></p>\n<p>例子二：</p>\n<pre><code class=\"language-javascript\">exports = module.exports = somethings\n\n// 等价于\n\nmodule.exports = somethings\n\nexports = module.exports\n\n// module.exports = somethings 是对 mudole.exports 进行了覆盖，\n\n// 此时 module.exports 和 exports 的关系断裂，\n\n// mudole.exports 指向了新的内存块，\n\n// 而exports 还是指向原来的内存块，\n\n// 为了让 module.exports 和 exports 还是指向同一个内存或者说指向同一个\"对象\"，\n\n// 所以我们就 exports = module.exports.</code></pre>\n<p></p>\n<p>例子三：</p>\n<pre>\n</pre>\n<p><code>exports = function(){};</code></p>\n<p><code>// 这样就是重新给 exports 赋值，它将不再是 module.exports 的引用，二者将无任何联系。</code></p>\n<p>例子四：</p>\n<pre>\n</pre>\n<pre><code class=\"language-javascript\">module.exports.something = function(){};\n\nexports.something = function(){};</code></pre>\n<p><code>// 上面两个方程是等价的</code></p>\n<p>例子五：</p>\n<pre>\n</pre>\n<pre><code class=\"language-javascript\">// index.js\n\nvar something = require('./requireMe');\n\nsomething();\n\n// requireMe.js\n\nexports.something = function(){\n\nconsole.log('am a function');\n\n}\n\n// 以上代码会报错，因为 require 出来的 module.exports 是一个object，不能直接执行</code></pre>\n<pre><code class=\"language-javascript\">//修改方式一\n\n// requireMe.js\n\nmodule.exports = function(){\n\nconsole.log('am a function');\n\n}\n\n// 当把代码改成上面这样，就不会报错，因为此时的 module.exports 是一个 function,可以直接执行。\n\n// 修改方式二\n\n// index.js\n\nvar something = require('./requireMe');\n\nsomething.something();\n\n// 因为这时候 require 出来的是一个 object，有一个 something 的属性，所以可以这样调用执行。</code></pre>\n<ul><li></li></ul>\n<p style=\"text-align:justify;\"><span style=\"color:#1a439c;\"><strong>总结</strong>：<strong>要导出的东西放在model.exports里面   model.exports={} 刚开始他是一个空对象</strong></span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#1a439c;\">       <strong>model.exports={ //这里面以键值对的形式放要导出的东西 }</strong></span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#1a439c;\"><strong>可以使用对象的简写方式，</strong></span></p>\n<h1 id=\"%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F\" style=\"margin-left:0;text-align:justify;\">微信小程序</h1>\n<ol><li style=\"text-align:justify;\">微信小程序获取用户信息</li></ol>\n<h1 id=\"react\" style=\"margin-left:0;text-align:justify;\">react</h1>\n<ol><li style=\"text-align:justify;\">react的生命周期?</li></ol>\n<h1 id=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3\" style=\"margin-left:0;text-align:justify;\">数据库相关</h1>\n<ol><li style=\"text-align:justify;\">数据库</li><li style=\"text-align:justify;\">Mongodb的update有几个参数？</li><li style=\"text-align:justify;\">vue和react的区别，用法区别</li></ol>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h1 id=\"%E5%85%B6%E4%BB%96\" style=\"margin-left:0;text-align:justify;\">其他（此题目处供参考，根据个人情况回答）</h1>\n<ol><li style=\"text-align:justify;\">对哪个编程语言比较熟？</li><li style=\"text-align:justify;\">webpack中在production下怎么禁止console.log和alert？</li><li style=\"text-align:justify;\">传统网站、响应式、vue、小程序的区别？</li><li style=\"text-align:justify;\">除了学校和培训，你还自学有什么技术？</li><li style=\"text-align:justify;\">项目中哪个是你做得比较好的，实现了什么功能</li><li style=\"text-align:justify;\">项目中哪个是你做得比较好的，实现了什么功能</li><li style=\"text-align:justify;\">项目中遇到兼容性问题</li><li style=\"text-align:justify;\">最近两年面试题总结，答案有时间慢慢完善：</li><li style=\"text-align:justify;\">购物车的实现过程（包括怎么布局，可以用vue、react、jq等）</li><li style=\"text-align:justify;\">购物车详情页优化（用户商品加入太多导致页面卡顿）（懒加载、分页）</li><li style=\"text-align:justify;\">数据结构（排序算法，冒泡以外的）</li><li style=\"text-align:justify;\">团队合作的经验</li><li style=\"text-align:justify;\">通宵经历（不是玩的）</li><li style=\"text-align:justify;\">课外项目（自己瞎做的那种）</li><li style=\"text-align:justify;\">为什么学前端？</li><li style=\"text-align:justify;\">有没有参赛或者除了学校课程内容外的经验？应该是想知道有没有合作经验</li><li style=\"text-align:justify;\">是否熟悉使用开发者工具？有没有使用过断点调试？</li><li style=\"text-align:justify;\">最近有没有在看某一本书？或者是有没有学习某一个课程？有没有什么学习的计划？</li></ol>\n<p style=\"margin-left:0;text-align:justify;\">************持续更新中.......</p>\n<p style=\"margin-left:0;text-align:justify;\">实在抱歉 由于篇幅太长，导编辑起来很卡所以没有继续编辑，  进行了分类其他内容放在以下链接（题目不一定相同）</p>\n<p style=\"margin-left:0;text-align:justify;\"><a href=\"https://blog.csdn.net/m0_65450343/article/details/124209101\" title=\"前端十五道html面试题_一只路过的菜鸟的博客-CSDN博客_前端html面试题\">前端十五道html面试题_一只路过的菜鸟的博客-CSDN博客_前端html面试题</a></p>\n<p style=\"margin-left:0;text-align:justify;\"><a href=\"https://blog.csdn.net/m0_65450343/article/details/124658549\" title=\"js十五道面试题（含答案）_一只路过的菜鸟的博客-CSDN博客_js面试题\">js十五道面试题（含答案）_一只路过的菜鸟的博客-CSDN博客_js面试题</a></p>\n<p style=\"margin-left:0;text-align:justify;\"><a href=\"https://blog.csdn.net/m0_65450343/article/details/125631822\" title=\"【30 道 Vue 面试题，内含详细讲解】_一只路过的菜鸟的博客-CSDN博客_vue的一些面试题\">【30 道 Vue 面试题，内含详细讲解】_一只路过的菜鸟的博客-CSDN博客_vue的一些面试题</a></p>\n<p style=\"margin-left:0;text-align:justify;\"><a href=\"https://blog.csdn.net/m0_65450343/article/details/123295695\" title=\"http相关十道面试题（含答案）_一只路过的菜鸟的博客-CSDN博客_http面试题\">http相关十道面试题（含答案）_一只路过的菜鸟的博客-CSDN博客_http面试题</a></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 17:01:56", "summary": "目录相关说一下对和和的认识和区别？和的区别浏览器如何实现不同标签页的通信？的优缺点做项目用到哪些新特性和新特性？用和写过什么？如何解决页面内容加载缓慢的问题？的特点页面渲染过程网页上哪里可以看到请求的"}