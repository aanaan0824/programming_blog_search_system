{"blogid": "125319191", "writerAge": "码龄3年", "writerBlogNum": "14", "writerCollect": "16", "writerComment": "0", "writerFan": "3", "writerGrade": "2级", "writerIntegral": "156", "writerName": "Ljwen_", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125319191.jpg", "writerRankTotal": "92361", "writerRankWeekly": "490590", "writerThumb": "15", "writerVisitNum": "5031", "blog_read_count": "1939", "blog_time": "于 2022-06-16 16:59:48 发布", "blog_title": "React -- useState 的使用及注意事项", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>一、基本使用</strong></p>\n<p><code>useState</code>是 react 提供的一个定义响应式变量的 hook 函数，基本语法如下：</p>\n<pre><code class=\"prism language-jsx\">const [count, setCount] = useState(initialCount)\n</code></pre>\n<ul><li>它返回一个状态和一个修改状态的方法，状态需要通过这个方法来进行修改；</li><li><code>initialCount</code> 是我们传入的一个初始状态，它是惰性的，我们可以通过传一个函数来返回一个值当作初始状态，并且这个函数只会在初始渲染时执行一次；</li></ul>\n<pre><code class=\"prism language-jsx\">const [count, setCount] = useState(() =&gt; {\n    const initialCount = someExpensiveComputation();\n    return initialCount\n})\n</code></pre>\n<p>接下来把定义好的状态运用到页面：</p>\n<pre><code class=\"prism language-jsx\">import { useState } from 'react'\nfunction App() {\n    const [count, setCount] = useState(0)\n    const handleClick = () =&gt; {\n        setCount(count + 1)\n        // 传入一个函数，更新的值是基于之前的值来执行\n        // setCount(count =&gt; count + 1)\n    }\n    return (\n    \t&lt;div&gt;\n        \t&lt;h4&gt;count: {count}&lt;/h4&gt;\n            &lt;button onClick={ handleClick }&gt;点击更新状态&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>页面渲染完成后，我们可以看到 <code>count</code>的值是 0，当我们点击按钮时，会将 <code>count</code>的值加 1，页面也同时更新；</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\88864fbcf2944cba86af80f80d5ad1f3.png\"/></p>\n<p>了解完基础用法后，我们可以思考几个问题；</p>\n<ul><li><code>setCount</code>修改值时它是同步还是异步？</li><li>连续调用 <code>setCount</code>会发生什么？</li></ul>\n<p><strong>第一个问题：<code>setCount</code>修改值时它是同步还是异步？</strong></p>\n<pre><code class=\"prism language-jsx\">const handleClick = () =&gt; {\n    console.log(\"value1: \", count)\n    setCount(count =&gt; count + 1)\n    console.log(\"value2: \", count)\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4f4b113d89244a17822ba0c4616dcf88.jpeg\"/></p>\n<p>从图中我们可以看出，页面的值是更新了，但是控制台打印的是之前的值，这是不是也表示 <code>setCount</code>是异步的呢？我们换一种方法，用异步来修改状态；</p>\n<pre><code class=\"prism language-jsx\">const handleClick = () =&gt; {\n    console.log(\"value1: \", count)\n    setTimeout(() =&gt; {\n        setCount(count =&gt; count + 1)\n        console.log(\"value2: \", count)\n    }, 0)\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ef289661684c4140abc9f697719f40af.jpeg\"/></p>\n<p>显然，异步修改状态跟同步修改状态的结果是一致的，这也表明了 <code>setCount</code> 是异步更新的；那我们要怎么拿到更新后的值呢，我们可以用另外一个 hook 函数 <code>useRef</code>，代码如下：</p>\n<pre><code class=\"prism language-jsx\">function App() {\n  const [count, setCount] = useState(0)\n  const countRef = useRef(count)\n  countRef.current = count\n  const handleClick = () =&gt; {\n    setCount(count =&gt; count + 1)\n    console.log(\"value3: \", count)\n    setTimeout(() =&gt; {\n      console.log(countRef.current)\n    }, 0)\n  }\n  return (\n    &lt;div&gt;\n      &lt;h4&gt;count: {count}&lt;/h4&gt;\n      &lt;button onClick={handleClick}&gt;点击更新状态&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8f82f5c2d79d4f798ea62b57f6f5a81d.png\"/></p>\n<p>从图中我们可以看出，我们已经拿到了更新之后的值，<code>useRef</code>不仅可以用于访问 DOM 节点，也可以用来表示一个容器，<code>current</code>属性可以保存任何值，而且<code>useRef</code>返回的对象会在整个生命周期内保持；</p>\n<p><strong>第二个问题：连续调用 <code>setCount</code>会发生什么？</strong></p>\n<p>（1）传入一个基于状态的值</p>\n<pre><code class=\"prism language-jsx\">const handleClick = () =&gt; {\n    console.log(\"value1: \", count)\n    setCount(count + 1)\n    console.log(\"value2: \", count)\n    setCount(count + 1)\n    console.log(\"value3: \", count)\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5ebeef9784d14b3da1de833b7f83957f.jpeg\"/></p>\n<p>从图片可以看出，如果我们传入的是一个普通值，他只会进行最后一次更新；</p>\n<p>（2）传入一个函数</p>\n<pre><code class=\"prism language-jsx\">const handleClick = () =&gt; {\n    console.log(\"value1: \", count)\n    setCount(count =&gt; count + 1)\n    console.log(\"value2: \", count)\n    setCount(count =&gt; count + 1)\n    console.log(\"value3: \", count)\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\38981594a5224174888090613299bcf3.jpeg\"/></p>\n<p>可以看出，传入一个函数的话，它会进行两次赋值，因为它更新的值是基于之前的值来执行，所以在开发中推荐使用函数传入的形式进行修改；</p>\n<p><strong>二、注意事项</strong></p>\n<p><strong>1、复杂变量的修改</strong></p>\n<p>对于复杂类型的变量我们修改时需要重新定义，在原来数据的基础上修改不会引起组件的重新渲染，因为 React 组件的更新机制只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，就不会重新渲染组件；举个例子</p>\n<pre><code class=\"prism language-jsx\">function App() {\n    const [arr, setArr] = useState([1])\n    const pushData = () =&gt; {\n        arr.push(4)\n        setArr(arr)\n    }\n    return (\n        &lt;div&gt;\n            &lt;h4&gt;{arr.join(\"-\")}&lt;/h4&gt;\n            &lt;button onClick={pushData}&gt;点击添加数组&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>上面的代码在点击按钮时，视图不会发生变化，但是 <code>arr</code>的值是变化了，如果想修改这个数组，需要重新定义一个数组来修改，在原数组上的修改不会引起组件的重新渲染，React 组件的更新机制对只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，就不会重新渲染组件；</p>\n<pre><code class=\"prism language-jsx\">const pushData = () =&gt; {\n    setArr([...arr, 4])\n}\n</code></pre>\n<p><strong>2、异步操作获取更新的值</strong></p>\n<p>在类组件里面，修改值时异步操作可以拿到更新后的值，但是在函数组件，异步获取是拿不到更新后的值的，举个例子对比一下：</p>\n<p><strong>类组件</strong></p>\n<pre><code class=\"prism language-jsx\">class App extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            count: 0\n        }\n    }\n    handleClick = () =&gt; {\n        this.setState({\n            count: this.state.count + 1\n        })\n        console.log(this.state.count)\n        setTimeout(() =&gt; {\n            console.log(this.state.count)\n        })\n    }\n    render() {\n        return (\n            &lt;&gt;\n            &lt;h4&gt;count: {this.state.count}&lt;/h4&gt;\n            &lt;button onClick={this.handleClick}&gt;点击更新状态&lt;/button&gt;\n            &lt;/&gt;\n        );\n    }\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\eb7e90eb9cd34f4896857e5513529b71.jpeg\"/></p>\n<p><strong>函数组件</strong></p>\n<pre><code class=\"prism language-jsx\">function App() {\n    const [count, setCount] = useState(0)\n    const handleClick = () =&gt; {\n        setCount(count =&gt; count + 1)\n        console.log(\"value1: \", count)\n        setTimeout(() =&gt; {\n            console.log(\"value2: \", count)\n        })\n    }\n    return (\n        &lt;div&gt;\n            &lt;h4&gt;count: {count}&lt;/h4&gt;\n            &lt;button onClick={handleClick}&gt;点击更新状态&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\549ef7b51a58420ea5a2a0092c7ba734.jpeg\"/></p>\n<p>显然，在函数组件中是不能通过异步来获取更新的值，我们可以通过 <code>useRef</code>来获取；</p>\n<pre><code class=\"prism language-jsx\">const countRef = useRef(count)\ncountRef.current = count\nconst handleClick = () =&gt; {\n    setCount(count =&gt; count + 1)\n    console.log(\"value1: \", countRef.current)\n    setTimeout(() =&gt; {\n        console.log(\"value2: \", countRef.current)\n    })\n}\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-16 16:59:48", "summary": "一、基本使用是提供的一个定义响应式变量的函数，基本语法如下：它返回一个状态和一个修改状态的方法，状态需要通过这个方法来进行修改；是我们传入的一个初始状态，它是惰性的，我们可以通过传一个函数来返回一个值"}