{"blogid": "124483303", "writerAge": "码龄6年", "writerBlogNum": "29", "writerCollect": "75", "writerComment": "3", "writerFan": "5", "writerGrade": "2级", "writerIntegral": "325", "writerName": "晴天的空间", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124483303.jpg", "writerRankTotal": "83806", "writerRankWeekly": "120480", "writerThumb": "20", "writerVisitNum": "26244", "blog_read_count": "8959", "blog_time": "于 2022-04-28 20:47:11 发布", "blog_title": "MySQL事务隔离级别详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_0\"></a>一、什么是事务？</h3>\n<p>事务是逻辑上的一组操作，要么全执行，要么全不执行。</p>\n<p>事务最经典栗子也经常被拿出来的栗子就是银行转账了。比如小明要给小红转账1000元，这个转账会涉及到两个关键操作：将小明的余额减1000元，将小红的余额减1000元。万一这两个操作之间突然出现错误，导致小明余额减少但是小红余额没有增加，这种情况是肯定不允许的。事务就是保证这两个关键操作要么都成功，要么都不成功。</p>\n<h3><a id=\"ACID_6\"></a>二、事务的特性（ACID）</h3>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\6b4470712316171dcf4d9639280060a0.png\"/></p>\n<ul><li>**原子性：**事务最小的执行单位，不允许分割。事务的原子性确保动作要么全部执行，要么全部不执行。</li><li>**一致性：**执行事务的前后，数据保持一致。例如转账的业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。</li><li>**隔离性：**并发访问数据库时，一个用户的事务不应该被其他事务所影响，各并发事务之间数据库是独立的。</li><li>**持久性：**一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有影响。</li></ul>\n<h3><a id=\"_15\"></a>三、并发事务带来的问题</h3>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但是可能会带来以下的问题：</p>\n<ul><li>**脏读（Dirty read）：**当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是“<strong>脏数据</strong>”，这种行为就是“<strong>脏读</strong>”，依据“<strong>脏数据</strong>”所做的操作可能是会出现问题的。</li><li><strong>修改丢失（Lost of modify）：<strong>是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，这种情况就被称为</strong>修改丢失</strong>。例如：事务1读取表中数据<code>A=20</code>，事务2也读取<code>A=20</code>，事务1修改<code>A=A-1</code>，事务2也修改<code>A=A-1</code>，最终结果都是<code>19</code>，但是事务1的修改记录丢失了。</li><li><strong>不可重复读（Unrepeatableread）：<strong>指在一个事务内多次读取同一数据，在这个事务还没结束时，另外一个事务也访问了这个数据并对这个数据进行了修改，那么就可能造成第一个事务两次读取的数据不一致，这种情况就被称为</strong>不可重复读。</strong></li><li><strong>幻读（Phantom read）：<strong>幻读与不可重复读类似，幻读是指一个事务读取了几行数据，这个事务还没结束，接着另外一个事务插入了一些数据，在随后的查询中，第一个事务读取到的数据就会比原本读取到的多，就好像发生了幻觉一样，所以称为</strong>幻读</strong>。</li></ul>\n<h4><a id=\"_24\"></a>不可重复读和幻读区别：</h4>\n<p>不可重复读的重点是修改，幻读的重点是新增或者删除。</p>\n<p>栗子1（同样的条件，你读取过的数据，再次读取的时候不一样了）：事务1中的A先生读取自己的工资是1000的操作还没结束，事务2的B先生就修改了A先生的工资为2000，A先生再次读取自己工资的时候就变成2000了，这就是不可重复读。</p>\n<p>栗子2（同样的条件，第1次和第2次读取出来的记录条数不一样）：假如某工资表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，总共查询到4条记录，这是事务2又查询了一条工资大于3000的记录，事务1再次读取查询到的记录就是5条了，这就是幻读。</p>\n<h3><a id=\"_32\"></a>四、事务隔离级别</h3>\n<p><strong>SQL标准定义了四个隔离级别：</strong></p>\n<ul><li>**读取未提交（READ-UNCOMMITTED）：**最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能造成脏读、不可重复读、幻读。</strong></li><li>**读取已提交（READ-COMMITTED）：**允许读取并发事务已经提交的数据，<strong>可以避免脏读，但是可能造成不可重复、幻读。</strong></li><li>**可重复读（REPEATABLE-READ）：**对同一字段多次读取的结果都是一致的，除非本身事务修改，<strong>可以避免脏读和不可重复读，但是可能造成幻读。</strong></li><li>**可串行化（SERIALIZABLE）：**最高的隔离级别，完全服从ACID的隔离级别，所以的事务依次执行，<strong>可以避免脏读、不可重复读、幻读。</strong></li></ul>\n<table><thead><tr><th align=\"center\">隔离级别</th><th align=\"center\">脏读</th><th align=\"center\">不可重复读</th><th align=\"center\">幻读</th></tr></thead><tbody><tr><td align=\"center\">读取未提交</td><td align=\"center\">√</td><td align=\"center\">√</td><td align=\"center\">√</td></tr><tr><td align=\"center\">读取已提交</td><td align=\"center\">×</td><td align=\"center\">√</td><td align=\"center\">√</td></tr><tr><td align=\"center\">可重复读</td><td align=\"center\">×</td><td align=\"center\">×</td><td align=\"center\">√</td></tr><tr><td align=\"center\">可串行化</td><td align=\"center\">×</td><td align=\"center\">×</td><td align=\"center\">×</td></tr></tbody></table>\n<p><code>MySQL InnoDB</code>存储引擎默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ）</strong>，可以通过命令<code>select @@tx_isolation;</code>语句来查看，<code>MySQL 8.0</code> 该语句改为<code>SELECT @@transaction_isolation;</code></p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@tx_isolation</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span>\n<span class=\"token operator\">|</span> @<span class=\"token variable\">@tx_isolation</span>  <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span>\n<span class=\"token operator\">|</span> <span class=\"token keyword\">REPEATABLE</span><span class=\"token operator\">-</span><span class=\"token keyword\">READ</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span>\n</code></pre>\n<p><strong><code>MySQL InnoDB</code>存储引擎的可重复读并不能避免幻读，需要应用使用加锁读来保证，这加锁读使用到的机制就是<code>Next-Key Locks</code></strong>。</p>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>读取已提交（READ-COMMITTED）</strong>，<code>InnoDB</code> 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>\n<p><code>InnoDB</code>存储引擎在分布式事务的情况下一般会用到<strong>可串行化</strong>隔离级别。</p>\n<p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p>\n<blockquote>\n<p>InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对事务的原有ACID要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>\n</blockquote>\n<h3><a id=\"_69\"></a>四、实际情况演示</h3>\n<p><code>MySQL</code>命令行的默认配置中事务都是自动提交的，即执行<code>SQL</code>语句就会马上执行<code>COMMIT</code>操作。可以用命令<code>START TRANSACTION</code>开始一个事务。</p>\n<p>我们可以通过下面命令设置事务隔离级别。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">SESSION</span><span class=\"token operator\">|</span><span class=\"token keyword\">GLOBAL</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">TRANSACTION</span> <span class=\"token keyword\">ISOLATION</span> <span class=\"token keyword\">LEVEL</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">READ</span> <span class=\"token keyword\">UNCOMMITTED</span><span class=\"token operator\">|</span><span class=\"token keyword\">READ</span> <span class=\"token keyword\">COMMITTED</span><span class=\"token operator\">|</span><span class=\"token keyword\">REPEATABLE</span> <span class=\"token keyword\">READ</span><span class=\"token operator\">|</span><span class=\"token keyword\">SERIALIZABLE</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>我们再来看一下我们在实际操作中使用到的一些并发控制语句：</p>\n<ul><li><code>START TRANSACTION | BEGIN</code> ：显示的开启一个事务。</li><li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li><li><code>ROLLBACK</code>：回滚到结束用户的事务，并撤销正在进行的所有未提交的修改。</li></ul>\n<h4><a id=\"_85\"></a>（脏读）读取未提交</h4>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\dc55f413cc9a00079dc7ed98b0f9c019.png\"/></p>\n<h4><a id=\"_89\"></a>（避免脏读）读取已提交</h4>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\5ac32bc7d96c46f50c1382587410642c.png\"/></p>\n<h4><a id=\"_93\"></a>不可重复读</h4>\n<p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\db2e39a8ae194ff6b171d341201308b5.png\"/></p>\n<h4><a id=\"_99\"></a>可重复读</h4>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ysjbfC4b-1651149978452)(https://qtspace.cn/contentimg/81.jpg)]</p>\n<h4><a id=\"_103\"></a>幻读</h4>\n<p>演示幻读出现的情况</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\6de60c4efcbb211261cb5d0dacb06440.png\"/></p>\n<p>sql 脚本 1 在第一次查询工资为 500 的记录时只有一条，sql 脚本 2 插入了一条工资为 500 的记录，提交之后；sql 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p>\n<p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<p>解决幻读的方法</p>\n<ul><li>将事务隔离级别调整为 <code>SERIALIZABLE</code>。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-Key Locks</code>。</li></ul>\n<blockquote>\n<p>说明：<code>Next-Key Locks</code> 相当于 行锁 + 间隙锁</p>\n</blockquote>\n<blockquote>\n<p>参考：https://javaguide.cn/database/mysql/transaction-isolation-level.html</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-04-28 20:47:11", "summary": "一、什么是事务？事务是逻辑上的一组操作，要么全执行，要么全不执行。事务最经典栗子也经常被拿出来的栗子就是银行转账了。比如小明要给小红转账元，这个转账会涉及到两个关键操作：将小明的余额减元，将小红的余额"}