{"blogid": "126743150", "writerAge": "码龄24天", "writerBlogNum": "52", "writerCollect": "2", "writerComment": "1", "writerFan": "31", "writerGrade": "3级", "writerIntegral": "520", "writerName": "web13057969558", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743150.jpg", "writerRankTotal": "37660", "writerRankWeekly": "10862", "writerThumb": "0", "writerVisitNum": "2053", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:24:54 发布", "blog_title": "JVM - 对象的创建", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_JVM___2\"></a># <code>JVM</code> - 对象的创建</h2>\n<blockquote>\n<p><code>JDK</code>版本：<code>1.8</code></p>\n</blockquote>\n<h3><a id=\"_1_7\"></a># 1、对象的创建的方式</h3>\n<p><img alt=\"JVM对象实例化脑图\" src=\"..\\..\\static\\image\\8cd37189c1fd44a18ad979e691cdc94b.png\"/></p>\n<p><code>Java</code>语言中，对象创建的方式有六种：</p>\n<ul><li><code>new</code>关键字：最常见的形式、<code>Xxx</code>的静态方法、<code>XxxBuilder</code>、<code>XxxFactory</code>的静态方法。</li><li><code>Class</code>类的<code>newInstance()</code>方法：通过反射的方式创建对象，调用类的无参构造器进行对象的创建，且其访问权限为<code>public</code>。</li><li><code>Constructor</code>的<code>newInstance()</code>方法：通过反射的方式创建对象，调用类的无参、有参构造器进行对象的创建，对构造器访问权限没有要求。</li><li>使用<code>clone()</code>方法：不调用任何构造器，但是要求当前类实现<code>Cloneable</code>接口，重写<code>clone()</code>方法。</li><li>使用序列化：从文件、网络中获取一个对象的二进制流。</li><li>使用第三方库：<code>Objenesis</code>。</li></ul>\n<h3><a id=\"_2_20\"></a># 2、对象创建的具体过程</h3>\n<p>这里讨论的是普通的<code>Java</code>对象，不包括数组和<code>Class</code>对象等。</p>\n<p><img alt=\"JVM对象创建的步骤脑图\" src=\"..\\..\\static\\image\\57a589f4cfa74b61a21315d4b2ff82ea.png\"/></p>\n<h4><a id=\"_1_26\"></a># 1、对象类加载检查</h4>\n<p>当<code>Java</code>虚拟机遇到一条字节码<code>new</code>指令时，首先将去检查这个指令的参数是否能在<code>Metaspace</code>的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、和初始化，即判断该类型的元信息是否存在。</p>\n<p>如果没有定位到该类的符号引用，<code>JVM</code>会使用双亲委派模式使用当前类的类加载器以**<code>ClassLoader</code>+包名+类名**作为<code>key</code>进行查找对应的<code>.class</code>文件。如果找到了<code>.class</code>文件则进行类加载，并生成对应的<code>Class</code>对象。如果没有找到则抛出<code>ClassNotFoundException</code>异常。</p>\n<h4><a id=\"_2_32\"></a># 2、为对象分配堆内存</h4>\n<p>在类加载检查通过后，接下来<code>JVM</code>虚拟机将为新生对象分配堆内存。对象所需的内存大小在类加载完成后便可完全确定。为对象分配内存空间的任务实际上便等同于将一块确定大小的内存区域从<code>JVM</code>堆中划分出来，这里的对内划分分为两种情况：</p>\n<p>假设<code>JVM</code>堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存放在另一边，已使用与未使用内存之间使用一个指针作为内存分界点的指示器，在这种情况下为新生对象分配内存只需要将指针朝着空闲内存的方向移动一段空间与新生对象内存大小相等的距离即可，这种分配方式称为<strong>指针碰撞(<code>Bump The Pointer</code>)</strong>。</p>\n<p>如果<code>JVM</code>堆中内存不是绝对规整的，已使用的内存与空闲内存相互交错在一起，那就没有办法进行简单的指针碰撞分配内存了，<code>JVM</code>必须维护一个堆内存的空闲列表，在为新生对象分配内存时必须在空闲列表中寻找一块符合要求的内存空间划分给新生对象。分配成功之后并将列表进行更新，这种分配方式称为<strong>空闲列表(<code>Free List</code>)</strong>。</p>\n<p>选择哪种分配方式是由<code>JVM</code>堆内存是否规整决定的，而<code>JVM</code>堆内存是否规则是由<code>JVM</code>所采用的垃圾收集器是否带有空间压缩整理(<code>Compact</code>)能力决定的。所以当使用<code>Serial</code>、<code>ParNew</code>等带压缩整理过程的垃圾收集器时，系统采用的对象内存分配算法是指针碰撞，既简单又高效。而当使用<code>CMS</code>这种基于清除(<code>Sweep</code>)算法收集垃圾时，理论上就只能采用较为复杂的空闲列表算法来分配内存。</p>\n<h4><a id=\"_3_42\"></a># 3、内存分配并发问题</h4>\n<p>对象的创建在<code>JVM</code>中是非常频繁的行为，即使仅仅是修改一个指针所指向的位置，在并发场景下也是非线程安全的。解决这个问题有两种可选方案：</p>\n<ul><li>对为对象分配内存的动作进行同步处理，采用<code>CAS</code>以及失败重试的方式保证更新操作的原子性。</li><li>将为对象分配内存的动作按照线程划分在不同的区域中进行，即每个线程在堆中预先分配一块小内存，称为本地线程分配缓冲区(<code>Thread Local Allocation Buffer TLAB</code>)，这部分内存空间是线程隔离的，在为新生对象分配内存时先尝试在<code>TLAB</code>中进行分配，如果本地线程分配缓冲区用完了，再尝试使用<code>CAS</code>以及失败重试的方式进行分配。虚拟机是否使用<code>TLAB</code>可以通过<code>-XX:+UseTLAB</code>选项进行配置。</li></ul>\n<h4><a id=\"_4_49\"></a># 4、初始化分配到的内存</h4>\n<p>在内存分配完成之后，虚拟机必须将分配到的内存空间进行初始化，初始化过程不包括对象头。内存初始化的作用是对类中的所有属性设置默认值，如果使用了<code>TLAB</code>这一项工作也可以提前至<code>TLAB</code>分配内存成功后一同进行。这步操作保证了对象的实例字段在<code>Java</code>代码中可以不赋初始值就直接使用，使程序都能访问到这些实例字段的数据类型所对应的零值。</p>\n<h4><a id=\"_5_53\"></a># 5、设置对象头</h4>\n<p>初始化内存之后，<code>JVM</code>还会将一些信息设置到对象头中。<code>JVM</code>会将对象所属的类(即类的元信息数据)、如何才能寻找到类的元数据信息、对象的哈希码(对象的哈希码会延迟到正真调用<code>Object#hashCode()</code>方法时才进行计算)、对象的<code>GC</code>分代年龄等信息存放在对象的对象头(<code>Object Header</code>)中。</p>\n<h4><a id=\"_6init_57\"></a># 6、执行<code>&lt;init&gt;()</code></h4>\n<p>当上述所有步骤执行完成之后，从<code>JVM</code>的角度看一个新生对象已经创建完成了，但是从<code>Java</code>程序的角度看，对象创建才刚刚开始–构造函数。即<code>Class</code>文件中的<code>&lt;init&gt;()</code>方法还未执行，此时对象中的所有实例字段都还为默认的零值，对象需要的其它资源和状态信息也还未按照预定的意图构建好。</p>\n<p>一般来说执行初始化动作由字节码流中<code>new</code>指令后面是否跟随<code>invokespecial</code>指令所决定，<code>Java</code>编译器会在遇到<code>new</code>关键字地方同生成这两条字节码指令，但是通过其它方式并不一定会如此。<code>new</code>指令之后会直接执行<code>&lt;inti&gt;()</code>方法，按照开发者的意愿对对象进行初始化动作，至此一个真正可用的<code>Java</code>对象才算完全被创建出来。</p>\n<p>综上所述，为对象属性赋值的操作：</p>\n<ul><li>属性的默认初始化</li><li>显示初始化</li><li>代码块中初始化</li><li>构造器中初始化</li></ul>\n<p>对象实例化的过程：</p>\n<ul><li>加载类元信息</li><li>为对象分配内存，同时处理并发问题</li><li>属性的默认初始化</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul>\n<hr/>\n<h3><a id=\"_3_80\"></a># 3、对象的内存布局</h3>\n<p>在<code>Hotsopt VM</code>中，对象在堆内存中存储布局可以划分为三个部分：对象头(<code>Object Header</code>)、实例数据(<code>Instance Data</code>)和对齐填充(<code>Padding</code>)。</p>\n<p><img alt=\"对象内存布局\" src=\"..\\..\\static\\image\\7b41dbe0fefc4baeaea04dfa906a3532.png\"/></p>\n<h4><a id=\"_1Object_Header_86\"></a># 1、对象头(<code>Object Header</code>)</h4>\n<p><img alt=\"对象的内存布局\" src=\"..\\..\\static\\image\\792701ecdc514d6ba9064c62ee0e226d.png\"/></p>\n<p><code>Hotsopt VM</code>中对象的对象头中包含两类信息：</p>\n<p>第一类是用于村粗对象自身的运行时数据，如哈希码(<code>hashCode</code>)、<code>GC</code>分代年龄、锁状态标志、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，这类数据官方称为<code>Mark Word</code>。</p>\n<p>对象头中另外一部分是类型指针，即实例对象指向它的类型元数据的指针，<code>Java</code>虚拟机通过这个指针来确定该对象是哪个类的实例。</p>\n<p>此外如果对象是一个<code>Java</code>数组，对象头中必须有一块用于记录数组长度的数据，因为<code>JVM</code>可以通过普通<code>Java</code>对象的元数据信息确定<code>Java</code>对象的大小，如果数组长度是不确定的，<code>JVM</code>将无法通过元数据中的信息推断出数组的大小。</p>\n<h4><a id=\"_2Instance_Data_98\"></a># 2、实例数据(<code>Instance Data</code>)</h4>\n<p>实例数据部分是对象真正存储的有效信息，即在<code>Java</code>代码中定义的各种类型的字段内容，无论是父类中继承下来的还是在子类中定义的字段都必须在此进行记录。</p>\n<h4><a id=\"_3Padding_102\"></a># 3、对齐填充(<code>Padding</code>)</h4>\n<p>对齐填充并不是比如存在的，也没有特殊的含义，它仅仅是起着占位符的作用。由于<code>Hotspot</code>虚拟机的自动内存管理系统要求对象地址的起始地址必须是8字节的整数倍，换而言之就是所有<code>Java</code>对象的大小都必须是8字节的整数倍。其中对象头部分已被精心设计成正好是8字节的整数倍，因此如果在实例数据部分没有对齐的话，就需要对齐填充部分进行补全。</p>\n<p>创建一个<code>Account</code>类：</p>\n<pre><code>public class Account {\n\n\n    public Account() {\n        System.out.println(\"Account‘s No Arg Construt\");\n    }\n\n}\n</code></pre>\n<p>创建一个<code>Customer</code>类：</p>\n<pre><code>public class Customer {\n\n    private Integer id = 100001;\n\n    private String name;\n\n    private Account account;\n\n    {\n        name = \"kapcd\";\n    }\n\n    public Customer() {\n        System.out.println(\"Customer's No Arg Construct\");\n        account = new Account();\n    }\n\n    public static void main(String[] args) {\n        Customer customer = new Customer();\n    }\n\n}\n</code></pre>\n<p>其对象内存布局如下图所示：</p>\n<p><img alt=\"对象的内存分布图\" src=\"..\\..\\static\\image\\2a4028a4e9e5495796eed1ab05a60ba7.png\"/></p>\n<hr/>\n<h3><a id=\"_4_150\"></a># 4、对象的访问定位</h3>\n<p><img alt=\"对象的访问定位\" src=\"..\\..\\static\\image\\78bc916729b44ebab83d903a914c63ca.png\"/></p>\n<p>创建对象自然是为了后续使用该对象，<code>Java</code>应用程序会通过栈上的<code>reference</code>数据来操作堆上的具体对象。由于<code>reference</code>类型在《<code>Java</code>虚拟机规范》中只规定了它是一个指向对象的引用，并没有具体规定这个引用应该通过什么方式去定位、访问到堆中具体位置，所以对象访问方式也是由虚拟机而实现的，主流的访问方式有使用句柄和直接指针两种：</p>\n<ul><li>如果使用句柄访问的方式，<code>Java</code>堆中可能会划分出一块内存空间来作为句柄池，<code>reference</code>中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li><li>如果使用直接指针访问的方式，<code>Java</code>堆中对象的内存布局就必须考虑如何放置访问类型数据相关的信息，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ul>\n<p>下图为句柄访问方式：</p>\n<p><img alt=\"句柄对象访问方式\" src=\"..\\..\\static\\image\\9a8a7755497b4640aaf0fb9e3a88bfda.png\"/></p>\n<p>下图为直接指针访问方式：</p>\n<p><img alt=\"直接指针访问\" src=\"..\\..\\static\\image\\c279f722d93946408d32b800a0143717.png\"/></p>\n<p>以上两种对象访问方式各有千秋，使用句柄来访问的最大好处就是<code>reference</code>中存储的是稳定的句柄地址，当对象应该垃圾收集而被移动时只会改变句柄中的实例数据指针，而<code>reference</code>本身不需要被修改。</p>\n<p>使用直接指针访问对象最大的好处就是速度快，它节省了一次指针定位的时间开销，由于对象访问在<code>Java</code>中是一种非常频繁的行为，因此这类开销积少成多也是一项极为可观的执行成本。</p>\n<hr/>\n<p><a href=\"https://github.com/kapbc/Java-Kapcb\">GitHub源码地址</a>：<code>https://github.com/kapbc/Java-Kapcb/tree/master/src/main/java/com/kapcb/ccc/jvm</code></p>\n<blockquote>\n<p>备注：此文为笔者学习<code>JVM</code>的笔记，鉴于本人技术有限，文中难免出现一些错误，感谢大家批评指正。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:24:54", "summary": "对象的创建版本：、对象的创建的方式对象实例化脑图语言中，对象创建的方式有六种：关键字：最常见的形式、的静态方法、、的静态方法。类的方法：通过反射的方式创建对象，调用类的无参构造器进行对象的创建，且其访"}