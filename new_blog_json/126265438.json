{"blogid": "126265438", "writerAge": "码龄1年", "writerBlogNum": "29", "writerCollect": "127", "writerComment": "370", "writerFan": "169", "writerGrade": "4级", "writerIntegral": "1259", "writerName": "白杨783", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126265438.jpg", "writerRankTotal": "15451", "writerRankWeekly": "354", "writerThumb": "294", "writerVisitNum": "9279", "blog_read_count": "645", "blog_time": "已于 2022-08-11 14:45:21 修改", "blog_title": "面向对象的三大特性之——继承", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"1.%E7%BB%A7%E6%89%BF-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E7%BB%A7%E6%89%BF\">1.继承</a></p>\n<p id=\"1.1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F\">1.1为什么要继承？</a></p>\n<p id=\"1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5\">1.2继承的概念</a></p>\n<p id=\"1.3%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95\">1.3 继承的语法</a></p>\n<p id=\"1.4%20%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:40px;\"><a href=\"#1.4%20%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE\">1.4 父类成员访问</a></p>\n<p id=\"1.4.1%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#1.4.1%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\">1.4.1 子类中访问父类的成员变量</a></p>\n<p id=\"1.4.2%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#1.4.2%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\">1.4.2 子类中访问父类的成员方法</a></p>\n<p id=\"1.5%20super%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#1.5%20super%E5%85%B3%E9%94%AE%E5%AD%97\">1.5 super关键字</a></p>\n<p id=\"1.6%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#1.6%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">1.6 子类构造方法</a></p>\n<p id=\"1.7super%E5%92%8Cthis-toc\" style=\"margin-left:40px;\"><a href=\"#1.7super%E5%92%8Cthis\">1.7super和this</a></p>\n<p id=\"%C2%A01.8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01.8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"> 1.8继承关系上的执行顺序</a></p>\n<p id=\"1.9protected%20%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.9protected%20%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0\">1.9protected 关键字 </a></p>\n<p id=\"1.11%20final%20%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#1.11%20final%20%E5%85%B3%E9%94%AE%E5%AD%97\">1.11 final 关键字</a></p>\n<p id=\"1.12%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88-toc\" style=\"margin-left:40px;\"><a href=\"#1.12%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88\">1.12 继承与组合</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%E7%BB%A7%E6%89%BF\">1.继承</h1>\n<h2 id=\"1.1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F\">1.1为什么要继承？</h2>\n<p>java中使用类对现实世界中实体进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体。但是现实世界一些事物可能存在关联，在设计程序时就需要考虑。</p>\n<p>比如：猫和狗都是动物。</p>\n<p>创建一个狗类：</p>\n<pre><code class=\"language-java\">//狗类\npublic class Dog {\n    String name;\n    int age;\n    float weight;\n    public void eat(){\n        System.out.println(name+\"正在吃饭\");\n    }\n    public void sleep(){\n        System.out.println(name+\"正在睡觉\");\n    }\n    public void Bark(){\n        System.out.println(name+\"汪汪汪\");\n    }\n}</code></pre>\n<p>创建一个猫类</p>\n<pre><code class=\"language-java\">public class Cat {\n    String name;\n    int age;\n    float weight;\n    public void eat(){\n        System.out.println(name+\"正在吃饭\");\n    }\n    public void sleep(){\n        System.out.println(name+\"正在睡觉\");\n    }\n    public void mew(){\n        System.out.println(name+\"喵喵喵\");\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"542\" src=\"..\\..\\static\\image\\bf0c4f7bff904af1a3563f209f9932f9.png\" width=\"1200\"/></p>\n<p>我们会发现上述创建的狗类和猫类有很多相同的地方：它们都有名字，年龄，都会吃饭睡觉等等。我们能否<strong>将这些共性给抽取出来，实现代码的复用呢</strong>？</p>\n<h2 id=\"1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5\">1.2继承的概念</h2>\n<p><span style=\"color:#333333;\">允许程序员在保持原有类特性的基础上进行<strong>扩展，增加新功能</strong>，这样产生新的类，称<strong>子类（派生类）</strong></span><span style=\"color:#333333;\">。</span></p>\n<p><span style=\"color:#333333;\">狗和猫都是动物，我们就可以将共性的内容进行抽取，然后用继承的思想来达到共用。</span></p>\n<p><img alt=\"\" height=\"591\" src=\"..\\..\\static\\image\\59d986b1123a4df28eadbdb4581a3c9b.png\" width=\"1140\"/></p>\n<div>\n<span style=\"color:#333333;\">Dog</span>\n<span style=\"color:#333333;\">和</span>\n<span style=\"color:#333333;\">Cat</span>\n<span style=\"color:#333333;\">都继承了</span>\n<span style=\"color:#333333;\">Animal</span>\n<span style=\"color:#333333;\">类，其中：</span>\n<span style=\"color:#333333;\">Animal</span>\n<span style=\"color:#333333;\">类称为父类</span>\n<span style=\"color:#333333;\">/</span>\n<span style=\"color:#333333;\">基类或超类，</span>\n<span style=\"color:#333333;\">Dog</span>\n<span style=\"color:#333333;\">和</span>\n<span style=\"color:#333333;\">Cat</span>\n<span style=\"color:#333333;\">可以称为</span>\n<span style=\"color:#333333;\">Animal</span>\n<span style=\"color:#333333;\">的 子类/</span>\n<span style=\"color:#333333;\">派生类，继承之后，子类可以复用父类中成员，子类在实现时只需关心自己新增加的成员即可。</span>\n</div>\n<p></p>\n<h2 id=\"1.3%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95\"><span style=\"color:#333333;\"><strong>1.3 </strong></span><span style=\"color:#333333;\"><strong>继承的语法</strong></span></h2>\n<p><span style=\"color:#333333;\">在</span><span style=\"color:#333333;\">Java</span><span style=\"color:#333333;\">中如果要表示类之间的继承关系，需要借助</span><span style=\"color:#333333;\"><strong>extends</strong></span><span style=\"color:#333333;\">关键字</span></p>\n<p>写一个Animal类作为父类：</p>\n<pre><code class=\"language-java\">public class Animal {\n    String name;\n    int age;\n    float weight;\n    public void eat(){\n        System.out.println(name+\"正在吃饭\");\n    }\n    public void sleep(){\n        System.out.println(name+\"正在睡觉\");\n    }\n}\n</code></pre>\n<p> 重写狗类：</p>\n<pre><code class=\"language-java\">public class Dog extends Animal {\n    public void Bark(){\n        System.out.println(name+\"汪汪汪\");\n    }\n}</code></pre>\n<p>重写猫类：</p>\n<pre><code class=\"language-java\">public class Cat extends Animal {\n    public void mew(){\n        System.out.println(name+\"喵喵喵\");\n    }\n}</code></pre>\n<p>可以发现我们重新写的狗类和猫类节省了大量的代码。</p>\n<p>注意：</p>\n<p><span style=\"color:#333333;\">1. 子类会将父类中的成员变量或者成员方法继承到子类中</span></p>\n<p><span style=\"color:#333333;\">2. 子类继承父类之后，必须要新添加自己特有的成员，体现出与父类的不同，否则就没有必要继承了</span></p>\n<h2 id=\"1.4%20%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE\"><span style=\"color:#333333;\"><strong>1.4 </strong></span><span style=\"color:#333333;\"><strong>父类成员访问</strong></span></h2>\n<h3 id=\"1.4.1%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span style=\"color:#333333;\"><strong>1.4.1 </strong></span><span style=\"color:#333333;\"><strong>子类中访问父类的成员变量</strong></span></h3>\n<div>\n<span style=\"color:#333333;\">1. </span>\n<span style=\"color:#333333;\"><strong>子类和父类不存在同名成员变量</strong></span>\n</div>\n<div>\n<pre><code class=\"language-java\">public class Base {\n    int a;\n    int b;\n}\npublic class Derived extends Base{\n        int c;\n    public void method(){\n        a = 10;\n        // 访问从父类中继承下来的a\n        b = 20; // 访问从父类中继承下来的b\n        c = 30; // 访问子类自己的c\n     } \n}</code></pre>\n<p><span style=\"color:#333333;\">2. </span><span style=\"color:#333333;\"><strong>子类和父类成员变量同名 </strong></span></p>\n</div>\n<div>\n<span style=\"color:#333333;\">在子类方法中 或者 通过子类对象访问成员时：<strong>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找</strong></span>\n<span style=\"color:#333333;\">。 </span>\n</div>\n<div>\n<pre><code class=\"language-java\">public class Base { \n    int a; \n    int b; \n    int c; \n}\npublic class Derived extends Base {\n    int a; // 与父类中成员a同名，且类型相同\n    char b; // 与父类中成员b同名，但类型不同\n\n    public void method() {\n        a = 100; // 就近，访问子类自己的a\n        b = 101; // 就近原则访问子类自己的b\n        c = 102; // 子类没有c，访问的肯定是从父类继承下来的c \n        d = 103; // 编译失败，因为父类和子类都没有定义成员变量b\n    }\n}</code></pre>\n<h2 id=\"1.4.2%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span style=\"color:#333333;\"><strong>1.4.2 </strong></span><span style=\"color:#333333;\"><strong>子类中访问父类的成员方法</strong></span></h2>\n<div>\n<strong><span style=\"color:#333333;\">通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到 则访问，否则编译报错。 </span></strong>\n</div>\n<div>\n<strong><span style=\"color:#333333;\">通过子类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同</span><span style=\"color:#333333;\">(</span><span style=\"color:#333333;\">重载</span><span style=\"color:#333333;\">)</span><span style=\"color:#333333;\">，根据调用 方法适传递的参数选择合适的方法访问，如果没有则报错；</span></strong>\n</div>\n<div>\n<pre><code class=\"language-java\">public class Base {\n    public void methodA(){\n        System.out.println(\"Base中的methodA()\"); \n    }\n    public void methodB(){\n        System.out.println(\"Base中的methodB()\");\n    }\n}\npublic class Derived extends Base{\n    public void methodA(int a) { \n        System.out.println(\"Derived中的method(int)方法\");\n    }\n    public void methodB(){ \n        System.out.println(\"Derived中的methodB()方法\"); \n    }\n    public void methodC(){\n        methodA(); // 没有传参，访问父类中的methodA()\n        methodA(20); // 传递int参数，访问子类中的methodA(int)\n        methodB(); // 直接访问，则永远访问到的都是子类中的methodB()，父类的无法访问到 \n    }\n}</code></pre>\n<h2 id=\"1.5%20super%E5%85%B3%E9%94%AE%E5%AD%97\"><span style=\"color:#333333;\"><strong>1.5 super</strong></span><span style=\"color:#333333;\"><strong>关键字</strong></span></h2>\n</div>\n<div>\n<span style=\"color:#333333;\"><strong>super</strong></span>\n<span style=\"color:#333333;\"><strong>关键字：该关键字主要作用：在子类方法中访问父</strong></span>\n<span style=\"color:#333333;\"><strong>类的成员</strong></span>\n</div>\n<div>\n<div>\n<span style=\"color:#333333;\"><span style=\"background-color:#ffd900;\">1. </span></span>\n<span style=\"color:#333333;\"><strong><span style=\"background-color:#ffd900;\">只能在非静态方法中使用 </span></strong></span>\n</div>\n<div>\n<span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">2. </span></span>\n<span style=\"color:#333333;\"><strong><span style=\"background-color:#38d8f0;\">在子类方法中，访问父类的成员变量和方法</span></strong></span>\n<span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">。</span></span>\n</div>\n<div>\n   父类：\n  </div>\n<div>\n<pre><code class=\"language-java\">public class Base {\n    int a;\n    int b;\n    public void methodA(){\n        System.out.println(\"Base中的methodA()\");\n    }\n    public void methodB(){\n        System.out.println(\"Base中的methodB()\");\n    }\n}</code></pre>\n<p></p>\n</div>\n<div>\n   子类：\n  </div>\n<div>\n<pre><code class=\"language-java\">public class Derived extends Base {\n    int a;\n    // 与父类中成员变量同名且类型相同\n    char b; // 与父类中成员变量同名但类型不同 \n\n    // 与父类中methodA()构成重载\n    public void methodA(int a) {\n        System.out.println(\"Derived中的method()方法\");\n    }\n    // 与基类中methodB()构成重写\n\n    public void methodB() {\n        System.out.println(\"Derived中的methodB()方法\");\n    }\n\n    public void methodC() { // 对于同名的成员变量，直接访问时，访问的都是子类的\n        a = 100; // 等价于： this.a = 100; \n        b = 101; // 等价于： this.b = 101; \n        // 注意：this是当前对象的引用 // 访问父类的成员变量时，需要借助super关键字 \n        // super是获取到子类对象中从基类继承下来的部分\n        super.a = 200;\n        super.b = 201; \n        // 父类和子类中构成重载的方法，直接可以通过参数列表区分清访问父类还是子类方法\n        methodA(); // 没有传参，访问父类中的methodA()\n        methodA(20); // 传递int参数，访问子类中的methodA(int) // 如果在子类中要访问重写的基类方法，则需要借助super关键字\n        methodB(); // 直接访问，则永远访问到的都是子类中的methodA()，基类的无法访问到 \n        super.methodB(); // 访问父类的methodB() \n    }\n}</code></pre>\n<h2 id=\"1.6%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span style=\"color:#333333;\"><strong>1.6 </strong></span><span style=\"color:#333333;\"><strong>子类构造方法</strong></span></h2>\n<div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#fe2c24;\">子类对象构造时，需要先调用父类构造方法，然后执行子类的构造方法。</span></span></strong>\n</div>\n<div>\n<div></div>\n<div>\n<span style=\"color:#333333;\">父类</span>\n</div>\n<div>\n<pre><code class=\"language-java\">public class Base {\n    public Base(){ \n        System.out.println(\"Base()\");\n    }\n}</code></pre>\n<p>子类</p>\n<pre><code class=\"language-java\">public class Derived extends Base{\n    public Derived() {\n        // super();\n        // 注意子类构造方法中默认会调用基类的无参构造方法：super(),\n        // 用户没有写时,编译器会自动添加，而且super()必须是子类构造方法中第一条语句，\n        // 并且只能出现一次\n       System.out.println(\"Derived()\");\n    }\n}</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n        Derived d = new Derived();\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"139\" src=\"..\\..\\static\\image\\33508f90edba4fe1b14bde985f6d1902.png\" width=\"626\"/></p>\n<p>先调用了public Base,后调用了Derived</p>\n<p><span style=\"background-color:#ffd900;\"> </span><span style=\"color:#333333;\"><strong><span style=\"background-color:#ffd900;\">子类对象中成员是有两部分组成的，父类继承下来的以及子类新增加的部分 。</span></strong></span></p>\n<div>\n<span style=\"color:#333333;\"><strong><span style=\"background-color:#38d8f0;\">在构造子类对象时候 ，先要调用父类的构造方法，将从父类继承下来的成员构造完整 </span></strong></span>\n</div>\n<div>\n<span style=\"color:#333333;\"><strong><span style=\"background-color:#38d8f0;\">，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整 </span></strong></span>\n<span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">。</span></span>\n</div>\n<div></div>\n<div>\n<strong><span style=\"color:#fe2c24;\">this()和super()不能同时出现</span></strong>\n</div>\n<div></div>\n<div>\n<img alt=\"\" height=\"645\" src=\"..\\..\\static\\image\\987e650184814d20b91e548512f94984.png\" width=\"820\"/>\n</div>\n<p><img alt=\"\" height=\"672\" src=\"..\\..\\static\\image\\c8a373cd35814f6796627bbf190b042f.png\" width=\"876\"/></p>\n<p></p>\n<div></div>\n<div>\n<div>\n        注意：\n       </div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#e6b223;\">1. </span></span><span style=\"color:#333333;\"><span style=\"background-color:#e6b223;\">若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的</span></span><span style=\"color:#333333;\"><span style=\"background-color:#e6b223;\">super()</span></span><span style=\"color:#333333;\"><span style=\"background-color:#e6b223;\">调用，即调用基类构 造方法 </span></span></strong>\n</div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#79c6cd;\">2. </span></span><span style=\"color:#333333;\"><span style=\"background-color:#79c6cd;\">如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的 父类构造方法调用，否则编译失败。 </span></span></strong>\n</div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#a2e043;\">3. </span></span><span style=\"color:#333333;\"><span style=\"background-color:#a2e043;\">在子类构造方法中，</span></span><span style=\"color:#333333;\"><span style=\"background-color:#a2e043;\">super(...)</span></span><span style=\"color:#333333;\"><span style=\"background-color:#a2e043;\">调用父类构造时，必须是子类构造函数中第一条语句。 </span></span></strong>\n</div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#6eaad7;\">4. super(...)</span></span><span style=\"color:#333333;\"><span style=\"background-color:#6eaad7;\">只能在子类构造方法中出现一次。</span></span></strong>\n</div>\n<div>\n<h2 id=\"1.7super%E5%92%8Cthis\"><span style=\"color:#333333;\"><strong>1.7super</strong></span><span style=\"color:#333333;\"><strong>和</strong></span><span style=\"color:#333333;\"><strong>this </strong></span></h2>\n<div>\n         相同点：\n        </div>\n<div>\n<strong>1.都是java中的关键字</strong>\n</div>\n<div></div>\n<div>\n<strong>2.只能在非静态方法中使用，<span style=\"color:#333333;\">必须是构造方法中的第一条语句，并且不能同时存在 </span></strong>\n</div>\n<div></div>\n<div>\n         不同点：\n        </div>\n<div></div>\n<div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#ffd900;\">1. this</span></span><span style=\"color:#333333;\"><span style=\"background-color:#ffd900;\">是当前对象的引用，当前对象即调用实例方法的对象，</span></span><span style=\"color:#333333;\"><span style=\"background-color:#ffd900;\">super</span></span><span style=\"color:#333333;\"><span style=\"background-color:#ffd900;\">相当于是子类对象中从父类继承下来部分成 员的引用</span></span></strong>\n</div>\n<div></div>\n<div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">2. </span></span><span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">在非静态成员方法中，</span></span><span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">this</span></span><span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">用来访问本类的方法和属性，</span></span><span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">super</span></span><span style=\"color:#333333;\"><span style=\"background-color:#38d8f0;\">用来访问父类继承下来的方法和属性</span> </span></strong>\n</div>\n<div></div>\n<div>\n<strong><span style=\"color:#333333;\"><span style=\"background-color:#956fe7;\">3. </span></span><span style=\"color:#333333;\"><span style=\"background-color:#956fe7;\">构造方法中一定会存在</span></span><span style=\"color:#333333;\"><span style=\"background-color:#956fe7;\">super(...)</span></span><span style=\"color:#333333;\"><span style=\"background-color:#956fe7;\">的调用，用户没有写编译器也会增加，但是</span></span><span style=\"color:#333333;\"><span style=\"background-color:#956fe7;\">this(...)</span></span><span style=\"color:#333333;\"><span style=\"background-color:#956fe7;\">用户不写则没有 </span></span></strong>\n</div>\n<div></div>\n<div>\n<div>\n<span style=\"color:#333333;\"><strong>初始化</strong></span>\n</div>\n<div></div>\n<div>\n<p>代码执行顺序：</p>\n<div>\n<strong><span style=\"color:#0d0016;\"><span style=\"background-color:#ffd900;\">1. 静态代码块先执行，并且只执行一次，在类加载阶段执行 </span></span></strong>\n</div>\n<div></div>\n<div>\n<strong><span style=\"color:#0d0016;\"><span style=\"background-color:#38d8f0;\">2. 当有对象创建时，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行</span></span></strong>\n</div>\n<div></div>\n<div>\n<pre><code class=\"language-java\">class Person {\n    public String name;\n    public int age;\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n        System.out.println(\"构造方法执行\");\n    }\n    {\n        System.out.println(\"实例代码块执行\");\n    }\n    static {\n        System.out.println(\"静态代码块执行\");\n    }\n}\npublic class TestDemo {\n    public static void main(String[] args) { \n        Person person1 = new Person(\"zhangsan\",10); \n        System.out.println(\"============================\");\n        Person person2 = new Person(\"lisi\",20); \n    }\n}</code></pre>\n<p><img alt=\"\" height=\"237\" src=\"..\\..\\static\\image\\e16a0d4342d344e28b9559a317e42a2e.png\" width=\"597\"/></p>\n<h2 id=\"%C2%A01.8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"> 1.8<span style=\"color:#333333;\"><strong>继承关系上的执行顺序</strong></span></h2>\n<div>\n<strong><span style=\"color:#0d0016;\">1、父类静态代码块优先于子类静态代码块执行，且是最早执行 </span></strong>\n</div>\n<div>\n<strong><span style=\"color:#0d0016;\">2、父类实例代码块和父类构造方法紧接着执行 </span></strong>\n</div>\n<div>\n<strong><span style=\"color:#0d0016;\">3、子类的实例代码块和子类构造方法紧接着再执行 </span></strong>\n</div>\n<div>\n<strong><span style=\"color:#0d0016;\">4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行</span></strong>\n</div>\n<div></div>\n<div>\n<pre><code class=\"language-java\">class Student extends Person{\n    public Student(String name,int age) {\n        super(name,age);\n        System.out.println(\"Student：构造方法执行\");\n    }\n    {\n        System.out.println(\"Student：实例代码块执行\");\n    }\n    static {\n        System.out.println(\"Student：静态代码块执行\");\n    }\n}\npublic class TestDemo2 {\n    public static void main(String[] args) {\n        Student student1 = new Student(\"张三\", 19);\n        System.out.println(\"===========================\");\n        Student student2 = new Student(\"李四\", 20);\n    }\n}</code></pre>\n<p>执行结果：</p>\n<p><img alt=\"\" height=\"437\" src=\"..\\..\\static\\image\\5bf26f716ea247b09a9e7c75e64c5551.png\" width=\"679\"/></p>\n<h2 id=\"1.9protected%20%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0\"><span style=\"color:#333333;\"><strong>1.9protected </strong></span><span style=\"color:#333333;\"><strong>关键字</strong></span> </h2>\n<div>\n<span style=\"color:#333333;\">Java</span>\n<span style=\"color:#333333;\">中引入了访问限定符，主要限定：类或者类中成员能否在类外或者其 他包中被访问。</span>\n</div>\n<div>\n<img alt=\"\" height=\"392\" src=\"..\\..\\static\\image\\05448cf8be7d4949a57e614a13b391e4.png\" width=\"679\"/>\n</div>\n<p><span style=\"color:#333333;\">父类中不同访问权限的成员，在子类中的可见性又是什么样子的呢？</span></p>\n<p>extend01包中</p>\n<pre><code class=\"language-java\">// extend01包中\npublic class B {\n    private int a;\n    protected int b;\n    public int c;\n    int d;\n}</code></pre>\n<p> extend01包中的子类：</p>\n<pre><code class=\"language-java\">public class D extends B{\n    public void method(){\n        super.a = 10; // 编译报错，父类private成员在相同包子类中不可见\n        super.b = 20;// 父类中protected成员在相同包子类中可以直接访问\n        super.c = 30; // 父类中public成员在相同包子类中可以直接访问\n        super.d = 40; // 父类中默认访问权限修饰的成员在相同包子类中可以直接访问\n    }\n}</code></pre>\n<p>extend02包中的子类：</p>\n<pre><code class=\"language-java\">public class C extends B {\n    public void method(){\n        super.a = 10; // 编译报错，父类中private成员在不同包子类中不可见\n        super.b = 20; // 父类中protected修饰的成员在不同包子类中可以直接访问\n        super.c = 30; // 父类中public修饰的成员在不同包子类中可以直接访问\n        super.d = 40; // 父类中默认访问权限修饰的成员在不同包子类中不能直接访问\n     }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>extend02中的非子类</p>\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n        C c = new C();\n        c.c = 10;// 父类中public成员在不同包其他类中可以直接访问\n        c.d = 20;// 报错：父类中protected成员在不同包其他类中不能直接访问\n    }</code></pre>\n<p> <span style=\"color:#333333;\">注意：父类中</span><span style=\"color:#333333;\">private</span><span style=\"color:#333333;\">成员变量虽然在子类中不能直接访问，但是也继承到子类中了</span></p>\n<h2 id=\"1.11%20final%20%E5%85%B3%E9%94%AE%E5%AD%97\"><span style=\"color:#333333;\"><strong>1.11 final </strong></span><span style=\"color:#333333;\"><strong>关键字</strong></span></h2>\n<div>\n<span style=\"color:#333333;\">final</span>\n<span style=\"color:#333333;\">关键可以用来修饰变量、成员方法以及类。</span>\n</div>\n<div>\n<span style=\"color:#333333;\">1. </span>\n<span style=\"color:#333333;\"><strong>修饰变量或字段，表示常量</strong></span>\n<span style=\"color:#333333;\"><strong>(</strong></span>\n<span style=\"color:#333333;\"><strong>即不能修改</strong></span>\n<span style=\"color:#333333;\"><strong>)</strong></span>\n</div>\n<div>\n<pre><code class=\"language-java\">final int a = 10; \na = 20; // 编译出错</code></pre>\n<div>\n<span style=\"color:#333333;\">2. </span>\n<span style=\"color:#333333;\"><strong>修饰类：表示此类不能被继承 </strong></span>\n</div>\n<div>\n<pre><code class=\"language-java\">final public class Animal {\n     ...\n}\npublic class Bird extends Animal {\n   ...\n}// 编译出错</code></pre>\n<div>\n<span style=\"color:#333333;\">3. </span>\n<span style=\"color:#333333;\"><strong>修饰方法：表示该方法不能被重写</strong></span>\n</div>\n<div></div>\n<h2 id=\"1.12%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88\"><span style=\"color:#333333;\"><strong>1.12 </strong></span><span style=\"color:#333333;\"><strong>继承与组合</strong></span></h2>\n<div>\n<span style=\"color:#333333;\">和继承类似</span>\n<span style=\"color:#333333;\">, </span>\n<span style=\"color:#333333;\">组合也是一种表达类之间关系的方式</span>\n<span style=\"color:#333333;\">, </span>\n<span style=\"color:#333333;\">也是能够达到代码重用的效果。组合并没有涉及到特殊的语法 (诸如</span>\n<span style=\"color:#333333;\"> extends </span>\n<span style=\"color:#333333;\">这样的关键字</span>\n<span style=\"color:#333333;\">), </span>\n<span style=\"color:#333333;\">仅仅是将一个类的实例作为另外一个类的字段。 </span>\n</div>\n<div></div>\n<div>\n<div>\n<span style=\"color:#333333;\"><strong>继承表示对象之间是</strong></span>\n<span style=\"color:#333333;\"><strong>is-a</strong></span>\n<span style=\"color:#333333;\"><strong>的关系</strong></span>\n<span style=\"color:#333333;\">，比如：狗是动物，猫是动物 </span>\n</div>\n<div>\n<span style=\"color:#333333;\"><strong>组合表示对象之间是</strong></span>\n<span style=\"color:#333333;\"><strong>has-a</strong></span>\n<span style=\"color:#333333;\"><strong>的关系</strong></span>\n<span style=\"color:#333333;\">，比如：汽车有轮胎，发动机，和车载系统等</span>\n</div>\n<div>\n<pre><code class=\"language-java\">// 轮胎类\nclass Tire{\n    // ...\n}\n// 发动机类\nclass Engine{\n    // ...\n}\n// 车载系统类\nclass VehicleSystem{ \n    // ...\n}\nclass Car{\n    private Tire tire; // 可以复用轮胎中的属性和方法\n    private Engine engine; // 可以复用发动机中的属性和方法\n    private VehicleSystem vs; // 可以复用车载系统中的属性和方法 \n    // ...\n}\n// 奔驰是汽车\nclass Benz extend Car{\n // 将汽车中包含的：轮胎、发送机、车载系统全部继承下来 \n}</code></pre>\n<p></p>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-11 14:45:21", "summary": "目录继承为什么要继承？继承的概念继承的语法父类成员访问子类中访问父类的成员变量子类中访问父类的成员方法关键字子类构造方法和继承关系上的执行顺序关键字关键字继承与组合继承为什么要继承？中使用类对现实世界"}