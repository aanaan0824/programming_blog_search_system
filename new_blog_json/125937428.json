{"blogid": "125937428", "writerAge": "码龄1年", "writerBlogNum": "77", "writerCollect": "684", "writerComment": "1104", "writerFan": "919", "writerGrade": "5级", "writerIntegral": "3683", "writerName": "NO.-LL", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125937428.jpg", "writerRankTotal": "5192", "writerRankWeekly": "191", "writerThumb": "1241", "writerVisitNum": "44490", "blog_read_count": "406", "blog_time": "已于 2022-08-19 21:57:08 修改", "blog_title": "进阶C++__STL__stack和queue | deque与priority queue", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"stack%E5%AE%B9%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#stack%E5%AE%B9%E5%99%A8\">stack容器</a></p>\n<p id=\"%C2%A0stack%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0stack%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"> stack 基本概念</a></p>\n<p id=\"stack%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#stack%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\">stack 常用接口</a></p>\n<p id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0stack%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0stack%E7%B1%BB\">模拟实现stack类</a></p>\n<p style=\"margin-left:40px;\"></p>\n<p id=\"queue%20%E5%AE%B9%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#queue%20%E5%AE%B9%E5%99%A8\">queue 容器</a></p>\n<p id=\"queue%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#queue%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">queue 基本概念</a></p>\n<p id=\"queue%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#queue%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\">queue 常用接口</a></p>\n<p id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0queue%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0queue%E7%B1%BB\">模拟实现queue类</a></p>\n<p style=\"margin-left:40px;\"></p>\n<p id=\"%E2%85%A1.%C2%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%85%A1.%C2%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97\">优先级队列 - priority queue</a></p>\n<p id=\"0x00%20priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#0x00%20priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D\"> priority_queue 的概念</a></p>\n<p id=\"0x01%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#0x01%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8\">优先级队列的使用</a></p>\n<p id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0priority_queue%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0priority_queue%E7%B1%BB\">模拟实现priority_queue类</a></p>\n<p style=\"margin-left:40px;\"></p>\n<p id=\"%E2%85%A2.%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%85%A2.%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97\">双端队列 - double ended queue</a></p>\n<p id=\"deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">deque容器基本概念</a></p>\n<p id=\"deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">deque构造函数</a></p>\n<p id=\"deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\">deque赋值操作</a></p>\n<p id=\"deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\">deque大小操作</a></p>\n<p id=\"deque%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:40px;\"><a href=\"#deque%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\">deque 插入和删除</a></p>\n<p id=\"deque%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#deque%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\">deque 数据存取</a></p>\n<p id=\"deque%20%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#deque%20%E6%8E%92%E5%BA%8F\">deque 排序</a></p>\n<p id=\"deque%EF%BC%8Cstack%20%E5%92%8C%20queue%20%E7%9A%84%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8-toc\" style=\"margin-left:0px;\">         <a href=\"#deque%EF%BC%8Cstack%20%E5%92%8C%20queue%20%E7%9A%84%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8\">deque，stack 和 queue 的底层默认容器</a></p>\n<p id=\"deque%20%E7%9A%84%E7%BC%BA%E9%99%B7-toc\" style=\"margin-left:40px;\"><a href=\"#deque%20%E7%9A%84%E7%BC%BA%E9%99%B7\">deque 的缺陷</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1></h1>\n<h1></h1>\n<h1 id=\"stack%E5%AE%B9%E5%99%A8\">stack容器</h1>\n<p></p>\n<h2 id=\"%C2%A0stack%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"> stack 基本概念</h2>\n<blockquote>\n<ol><li>栈是一种特殊的线性表，只允许在<strong>固定的一端</strong>进行插入和删除元素的操作。</li><li>进行数据插入的删除和操作的一端，称为 <strong>栈顶 </strong>。另一端则称为 <strong>栈底 </strong>。</li><li><strong><strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</li></ol>\n<ul><li>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></li><li>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></li></ul>\n<p><img alt=\"\" height=\"321\" src=\"..\\..\\static\\image\\0a4835a5a38d4ce2a02c517c1d595027.png\" width=\"772\"/></p>\n<p><strong>文档介绍：</strong><a href=\"https://cplusplus.com/reference/stack/stack/?kw=stack\" title=\"stack - C++ Reference\">stack - C++ Reference</a> </p>\n<ul><li>stack 是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。</li><li>stack 是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。</li><li>标准容器 vector、deque、list 均符合这些需求，默认情况下，如果没有为 stack 指定特定的底层容器， 默认情况下使用 deque。<br/>  </li></ul>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"stack%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\">stack 常用接口</h2>\n<blockquote>\n<p>功能描述：栈容器常用的对外接口</p>\n<p>构造函数：</p>\n<ul><li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul>\n<p>赋值操作：</p>\n<ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li></ul>\n<p>数据存取：</p>\n<ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top();</code> //返回栈顶元素</li></ul>\n<p>大小操作：</p>\n<ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul>\n</blockquote>\n<p> <strong>示例：</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;stack&gt;\n\n//栈容器常用接口\nvoid test01()\n{\n\t//创建栈容器 栈容器必须符合先进后出\n\tstack&lt;int&gt; s;\n\n\t//向栈中添加元素，叫做 压栈 入栈\n\ts.push(10);\n\ts.push(20);\n\ts.push(30);\n\n\twhile (!s.empty()) {\n\t\t//输出栈顶元素\n\t\tcout &lt;&lt; \"栈顶元素为： \" &lt;&lt; s.top() &lt;&lt; endl;\n\t\t//弹出栈顶元素\n\t\ts.pop();\n\t}\n\tcout &lt;&lt; \"栈的大小为：\" &lt;&lt; s.size() &lt;&lt; endl;\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>栈顶元素为： 30<br/> 栈顶元素为： 20<br/> 栈顶元素为： 10<br/> 栈的大小为：0</p>\n</blockquote>\n<p></p>\n<h2 id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0stack%E7%B1%BB\">模拟实现stack类</h2>\n<p>函数接口</p>\n<pre><code class=\"language-cpp\">  #include&lt;deque&gt;\n\n  template&lt;class T, class Con = deque&lt;T&gt;&gt;\n\n  class stack\n\n  {\n\n  public:\n\n    stack();\n\n    void push(const T&amp; x);\n\n    void pop();\n\n    T&amp; top();\n\n    const T&amp; top()const;\n\n    size_t size()const;\n\n    bool empty()const;\n\n  private:\n\n    Con _c;\n\n  };</code></pre>\n<p>模拟实现</p>\n<pre><code class=\"language-cpp\">/*\n\n*思路：\n\n* 1. stack和queue的模拟实现思路一样，都是通过容器适配而成\n\n* 2. 容器的模板参数Con给出容器deque作为底层的默认容器(使用的过程中也可以自己指定容器)\n\n* 3. stack和queue的方式实现在底层都是转为调用适配容器，只要容器能够满足所有的转调用操作，都可以充当适配   容器\n\n* 4. 由于stack和queue是通过其他容器适配而成，所以stack和queue称为容器适配器\n\n*/\n#include&lt;deque&gt;\n\n  template&lt;class T, class Con = deque&lt;T&gt;&gt;\n\n  class stack\n  {\n  public:\n\n    stack()\n    {}\n    void push(const T&amp; x)\n    {\n      _c.push_back(x);\n    }\n\n    void pop()\n    {\n      _c.pop_back();\n    }\n\n    T&amp; top()\n    {\n      return _c.back();\n    }\n\n    const T&amp; top()const\n    {\n      return _c.back();\n    }\n\n    size_t size()const\n    {\n      return _c.size();\n    }\n\n    bool empty()const\n\n    {\n      return _c.empty();\n    }\n\n  private:\n    Con _c;\n\n  };</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"queue%20%E5%AE%B9%E5%99%A8\">queue 容器</h1>\n<h2 id=\"queue%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">queue 基本概念</h2>\n<blockquote>\n<p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>\n<p>队列容器允许从一端新增元素，从另一端移除元素</p>\n<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>\n<p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p>\n<p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\b93fb2776ff44dda0cde8082799240fe.png\"/></p>\n<p><strong>文档介绍：</strong><a href=\"https://cplusplus.com/reference/queue/queue/\" title=\"queue - C++ Reference\">queue - C++ Reference</a></p>\n<ul><li>队列是一种容器适配器，专门用于在FIFO上下文(先进先出)中操作，其中从容器一端插入元素，另一端 提取元素。</li><li>队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue 提供一组特定的 成员函数来访问其元素。元素从队尾入队列，从队头出队列。</li><li>标准容器类 deque 和 list 满足了这些要求。默认情况下，如果没有为 queue 实例化指定容器类，则使用标 准容器 deque。</li></ul>\n</blockquote>\n<p><br/>  </p>\n<h2 id=\"queue%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\">queue 常用接口</h2>\n<blockquote>\n<p>功能描述：栈容器常用的对外接口</p>\n<p>构造函数：</p>\n<ul><li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul>\n<p>赋值操作：</p>\n<ul><li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li></ul>\n<p>数据存取：</p>\n<ul><li><code>push(elem);</code> //往队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front();</code> //返回第一个元素</li></ul>\n<p>大小操作：</p>\n<ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n\nclass Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis-&gt;m_Name = name;\n\t\tthis-&gt;m_Age = age;\n\t}\n\n\tstring m_Name;\n\tint m_Age;\n};\n\nvoid test01() {\n\n\t//创建队列\n\tqueue&lt;Person&gt; q;\n\n\t//准备数据\n\tPerson p1(\"唐僧\", 30);\n\tPerson p2(\"孙悟空\", 1000);\n\tPerson p3(\"猪八戒\", 900);\n\tPerson p4(\"沙僧\", 800);\n\n\t//向队列中添加元素  入队操作\n\tq.push(p1);\n\tq.push(p2);\n\tq.push(p3);\n\tq.push(p4);\n\n\t//队列不提供迭代器，更不支持随机访问\t\n\twhile (!q.empty()) {\n\t\t//输出队头元素\n\t\tcout &lt;&lt; \"队头元素-- 姓名： \" &lt;&lt; q.front().m_Name \n              &lt;&lt; \" 年龄： \"&lt;&lt; q.front().m_Age &lt;&lt; endl;\n        \n\t\tcout &lt;&lt; \"队尾元素-- 姓名： \" &lt;&lt; q.back().m_Name  \n              &lt;&lt; \" 年龄： \" &lt;&lt; q.back().m_Age &lt;&lt; endl;\n        \n\t\tcout &lt;&lt; endl;\n\t\t//弹出队头元素\n\t\tq.pop();\n\t}\n\n\tcout &lt;&lt; \"队列大小为：\" &lt;&lt; q.size() &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>队头元素-- 姓名： 唐僧 年龄： 30<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>\n<p>队头元素-- 姓名： 孙悟空 年龄： 1000<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>\n<p>队头元素-- 姓名： 猪八戒 年龄： 900<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>\n<p>队头元素-- 姓名： 沙僧 年龄： 800<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>\n<p>队列大小为：0</p>\n</blockquote>\n<p></p>\n<h2 id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0queue%E7%B1%BB\">模拟实现queue类</h2>\n<p>函数接口</p>\n<pre><code class=\"language-cpp\">  template&lt;class T, class Con = deque&lt;T&gt;&gt;\n\n  class queue\n\n  {\n\n  public:\n\n    queue();\n\n    void push(const T&amp; x);\n\n    void pop();\n\n    T&amp; back();\n\n    const T&amp; back()const;\n\n    T&amp; front();\n\n    const T&amp; front()const;\n\n    size_t size()const;\n\n    bool empty()const;\n\n  private:\n\n    Con _c;\n\n  };</code></pre>\n<p>模拟实现</p>\n<pre><code class=\"language-cpp\">/*\n\n*思路：\n\n* 1. stack和queue的模拟实现思路一样，都是通过容器适配而成\n\n* 2. 容器的模板参数Con给出容器deque作为底层的默认容器(使用的过程中也可以自己指定容器)\n\n* 3. stack和queue的方式实现在底层都是转为调用适配容器，只要容器能够满足所有的转调用操作，都可以充当适配   容器\n\n* 4. 由于stack和queue是通过其他容器适配而成，所以stack和queue称为容器适配器\n\n*/\n#include&lt;deque&gt;\ntemplate&lt;class T, class Con = deque&lt;T&gt;&gt;\n\n  class queue\n\n  {\n\n  public:\n\n    queue()\n    {}\n\n    void push(const T&amp; x)\n    {\n      _c.push_back(x);\n    }\n\n    void pop()\n    {\n      _c.pop_front();\n    }\n\n    T&amp; back()\n    {\n      return _c.back();\n    }\n\n    const T&amp; back()const\n    {\n      return _c.back();\n    }\n\n    T&amp; front()\n    {\n      return _c.front();\n    }\n\n    const T&amp; front()const\n    {\n      return _c.front();\n    }\n\n    size_t size()const\n    {\n      return _c.size();\n    }\n\n    bool empty()const\n    {\n      return _c.empty();\n    }\n\n  private:\n\n    Con _c;\n\n  };</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"%E2%85%A1.%C2%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97\"><a href=\"https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E7%BA%A7&amp;spm=1001.2101.3001.7020\" title=\"优先级\">优先级</a>队列 - priority queue</h1>\n<h3 id=\"0x00%20priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D\"> priority_queue 的概念</h3>\n<blockquote>\n<p>优先级队列（priority_queue）其实，不满足先进先出的条件，更像是数据类型中的“堆”。优先级队列每次出队的元素是队列中优先级最高的那个元素，而不是队首的元素。这个优先级可以通过元素的大小等进行定义。比如定义元素越大优先级越高，那么每次出队，都是将当前队列中最大的那个元素出队</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\6bd0fd024f41016a5b5a092df7868924.jpeg\"/></p>\n<p></p>\n<p><strong>文档介绍：</strong><a href=\"https://cplusplus.com/reference/queue/priority_queue/\" title=\"priority_queue - C++ Reference\">priority_queue - C++ Reference</a></p>\n<ul><li>优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的。</li><li>此上下文类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素（优先队列中位于顶部的元素）。</li><li>优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特 定的成员函数来访问其元素。元素从特定容器的“尾部”弹出，其称为优先队列的顶部。</li><li>标准容器类 vector 和 deque 满足这些需求。默认情况下，如果没有为特定的 priority_queue 类实例化指 定容器类，则使用 vector。</li><li>需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数 make_heap、push_heap 和 pop_heap 来自动完成此操作。</li></ul>\n</blockquote>\n<p><br/>  </p>\n<h2 id=\"0x01%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8\">优先级队列的使用</h2>\n<blockquote>\n<p>优先级队列默认使用 vector 作为其底层存储数据的容器，</p>\n<p>在 vector 上又使用了堆算法将 vector 中元素构造成堆的结构，因为 priority_queue 就是堆。</p>\n<p>所有需要用到堆的地方，都可以考虑使用 priority_queue。</p>\n<p>值得注意的是，priority_queue 默认为大根堆。</p>\n<p><span style=\"background-color:#f9eda6;\">优先级队列默认大的优先级高，传的是 less 仿函数，底层是一个大堆；</span></p>\n<p><span style=\"background-color:#f9eda6;\">如果想控制小的优先级高，需手动传 greater 仿函数，其底层是一个小堆。</span><br/>  </p>\n<ul><li>empty()：检测容器是否为空</li><li>size()：返回容器中有效元素个数</li><li>front()：返回容器中第一个元素的引用</li><li>push_back()：在容器尾部插入元素</li><li>pop_back()：删除容器尾部元素</li></ul>\n<p></p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;functional&gt;  // greater算法的头文件\nusing namespace std;\n\nvoid test_priority_queue() \n{\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pQ;\n  \n    pQ.push(2);\n    pQ.push(5);\n    pQ.push(1);\n    pQ.push(6);\n    pQ.push(8);\n    while (!pQ.empty()) {\n        cout &lt;&lt; pQ.top() &lt;&lt; \" \";\n        pQ.pop();\n    }\n    cout &lt;&lt; endl;\n\n\n    priority_queue&lt;int&gt; pQ2;\n //默认是用 vector 存储的，注意这里没有明确指定 less 还是 greater，所以默认为 less。\n    pQ2.push(2);\n    pQ2.push(5);\n    pQ2.push(1);\n    pQ2.push(6);\n    pQ2.push(8);\n    while (!pQ2.empty()) {\n        cout &lt;&lt; pQ2.top() &lt;&lt; \" \";\n        pQ2.pop();\n    }\n    cout &lt;&lt; endl;\n}\n\n\n\nint main() {\n    test_priority_queue();\n    return 0;\n}</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>1 2 5 6 8<br/> 8 6 5 2 1</p>\n</blockquote>\n<p>默认是用 vector 存储的，注意这里没有明确指定 less 还是 greater，所以默认为 less。</p>\n<p>我们在定义优先级队列时主动去传 greater&lt;int&gt; 即可令该优先级队列以小的优先级高。</p>\n<p></p>\n<h2 id=\"%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0priority_queue%E7%B1%BB\">模拟实现priority_queue类</h2>\n<p>函数接口</p>\n<pre><code class=\"language-cpp\">namespace bit\n\n{\n\n  #include&lt;vector&gt;\n\n  #include&lt;functional&gt;\n\n  template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;T&gt; &gt;\n\n  class priority_queue\n\n  {\n\n  public:\n\n    priority_queue();\n\n    template &lt;class InputIterator&gt;\n\n    priority_queue(InputIterator first, InputIterator last);\n\n    bool empty() const;\n\n    size_t size() const;\n\n    T&amp; top() const;\n\n    void push(const T&amp; x);\n\n    void pop();\n\n  private:\n\n    Container c;\n\n    Compare comp;\n\n  };\n\n};</code></pre>\n<p>模拟实现</p>\n<pre><code class=\"language-cpp\">namespace bit\n\n{\n\n  //函数对象 less\n  template&lt;class T&gt;\n\n  struct less\n  {\n    bool operator()(const T&amp; left, const T&amp; right)\n    { \n      return left &lt; right; \n    }\n  };\n\n  //函数对象 greater\n  template&lt;class T&gt;\n\n  struct greater\n  {\n    bool operator()(const T&amp; left, const T&amp; right)\n    { \n      return left &gt; right; \n    }\n  };\n   \n\nnamespace bit\n{\n\n  //函数对象 less\n  template&lt;class T&gt;\n  struct less\n  {\n    bool operator()(const T&amp; left, const T&amp; right)\n    { \n      return left &lt; right; \n    }\n  };\n\n\n  //函数对象 greater\n  template&lt;class T&gt;\n  struct greater\n  {\n    bool operator()(const T&amp; left, const T&amp; right)\n    { \n      return left &gt; right; \n    }\n  };\n\n   \n\n  template &lt;class T, class Container = std::vector&lt;T&gt;, class Compare = less&lt;T&gt; &gt;\n  class priority_queue\n  {\n  public:\n\n    //创建空的优先级队列\n    priority_queue():c()\n    {}\n\n    template &lt;class InputIterator&gt;\n    priority_queue(InputIterator first, InputIterator last)\n      :c(first, last)\n    {\n      //将c中的元素调整为堆的结构，默认为大堆\n      int count = c.size();\n      int root = ((count - 2) &gt;&gt; 1);\n      for (; root &gt;= 0; root--)\n       AdjustDown(root);\n    }\n\n    bool empty() const\n    {\n      return c.empty();\n    }\n\n    size_t size() const\n    {\n      return c.size();\n    }\n\n    // 堆顶元素不允许修改，因为：堆顶元素修改可以会破坏堆的特性\n\n    const T&amp; top() const\n    {\n      return c.front();\n    }\n\n    void push(const T&amp; x)\n    {\n      c.push_back(x);\n      //push_heap(c.begin(), c.end(), comp);\n      AdjustUp(c.size() - 1);\n    }\n\n    void pop()\n    {\n      if (empty())\n       return;\n      std:swap(c.front(), c.back());\n      c.pop_back();\n      AdjustDown(0);\n    }\n\n  private:\n\n    //向上调整\n\n    void AdjustUp(int child)\n    {\n\n      int parent = ((child - 1) &gt;&gt; 1);\n      while (child)\n      {\n        if (Com(c[parent], c[child]))\n        {\n          std::swap(c[child], c[parent]);\n          child = parent;\n          parent = ((child - 1) &gt;&gt; 1);\n       }\n        else  return;\n\n      }\n\n    }\n\n     \n\n    //向下调整\n    void AdjustDown(int parent)\n    {\n      int child = parent * 2 + 1;\n      while (child &lt; c.size())\n      {\n\n        // 找以parent为根的较大的孩子\n        if (child + 1 &lt; c.size() &amp;&amp; Com(c[child], c[child+1]))\n        child += 1;\n\n        // 检测双亲是否满足情况\n        if (Com(c[parent], c[child]))\n        {\n          std::swap(c[child], c[parent]);\n          parent = child;\n          child = parent * 2 + 1;\n       }\n       else  return;\n\n      }\n\n    }\n\n  private:\n\n    Container c;\n\nCompare Com;\n  };\n\n};</code></pre>\n<p></p>\n<p></p>\n<h1 id=\"%E2%85%A2.%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97\">双端队列 - double ended queue</h1>\n<p></p>\n<h2 id=\"deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">deque容器基本概念</h2>\n<blockquote>\n<p><strong>功能：</strong></p>\n<ul><li>双端数组，可以对头端进行插入删除操作</li></ul>\n<p><strong>deque与vector区别：</strong></p>\n<ul><li> <p>deque 可以在头尾两端进行插入和删除操作，且时间复杂度为 <img alt=\"O(1)\" src=\"https://latex.codecogs.com/gif.latex?O%281%29\"/>，比vector快,</p> </li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"568\" src=\"..\\..\\static\\image\\8f2efb7eef67490ba4eaa474de82d3a5.png\" width=\"1002\"/></h3>\n<p></p>\n<p><strong>deque内部工作原理:</strong></p>\n<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>\n<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>\n<p><img alt=\"\" height=\"595\" src=\"..\\..\\static\\image\\88b588716e9e44c4a510f1e205acd104.png\" width=\"1104\"/></p>\n<p></p>\n<ul><li>deque容器的迭代器也是支持随机访问的</li></ul>\n</blockquote>\n<p></p>\n<h2 id=\"deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">deque构造函数</h2>\n<p></p>\n<ul><li><code>deque&lt;T&gt;</code> deqT; //默认构造形式</li><li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul>\n<p>注意：</p>\n<pre><code class=\"language-cpp\">void printDeque(deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n无const，迭代器用iterator\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n有const限定用cosnt_iterator</code></pre>\n<p><strong>示例：</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n//deque构造\nvoid test01() {\n\n\tdeque&lt;int&gt; d1; //无参构造函数\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\td1.push_back(i);\n\t}\n\tprintDeque(d1);\n\tdeque&lt;int&gt; d2(d1.begin(),d1.end());\n\tprintDeque(d2);\n\n\tdeque&lt;int&gt;d3(10,100);\n\tprintDeque(d3);\n\n\tdeque&lt;int&gt;d4 = d3;\n\tprintDeque(d4);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<p></p>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 100 100 100 100 100 100 100 100 100 100<br/> 100 100 100 100 100 100 100 100 100 100</p>\n</blockquote>\n<p>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>\n<p></p>\n<p></p>\n<h2 id=\"deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\">deque赋值操作</h2>\n<ul><li> <p><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</p> </li><li> <p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p> </li><li> <p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p> </li></ul>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n//赋值操作\nvoid test01()\n{\n\tdeque&lt;int&gt; d1;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\td1.push_back(i);\n\t}\n\tprintDeque(d1);\n\n\tdeque&lt;int&gt;d2;\n\td2 = d1;\n\tprintDeque(d2);\n\n\tdeque&lt;int&gt;d3;\n\td3.assign(d1.begin(), d1.end());\n\tprintDeque(d3);\n\n\tdeque&lt;int&gt;d4;\n\td4.assign(10, 100);\n\tprintDeque(d4);\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 100 100 100 100 100 100 100 100 100 100</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\">deque大小操作</h2>\n<ul><li> <p><code>deque.empty();</code> //判断容器是否为空</p> </li><li> <p><code>deque.size();</code> //返回容器中元素的个数</p> </li><li> <p><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> </li><li> <p><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> <p>​</p> </li><li><strong>deque没有容量的概念</strong></li></ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//大小操作\nvoid test01()\n{\n\tdeque&lt;int&gt; d1;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\td1.push_back(i);\n\t}\n\tprintDeque(d1);\n\n\t//判断容器是否为空\n\tif (d1.empty()) {\n\t\tcout &lt;&lt; \"d1为空!\" &lt;&lt; endl;\n\t}\n\telse {\n\t\tcout &lt;&lt; \"d1不为空!\" &lt;&lt; endl;\n\t\t//统计大小\n\t\tcout &lt;&lt; \"d1的大小为：\" &lt;&lt; d1.size() &lt;&lt; endl;\n\t}\n\n\t//重新指定大小\n\td1.resize(15, 1);\n\tprintDeque(d1);\n\n\td1.resize(5);\n\tprintDeque(d1);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> d1不为空!<br/> d1的大小为：10<br/> 0 1 2 3 4 5 6 7 8 9 1 1 1 1 1<br/> 0 1 2 3 4</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"deque%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\">deque 插入和删除</h2>\n<p>两端插入操作：</p>\n<ul><li><code>push_back(elem);</code> //在容器尾部添加一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul>\n<p>指定位置操作：</p>\n<ul><li> <p><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p> </li><li> <p><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</p> </li><li> <p><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</p> </li><li> <p><code>clear();</code> //清空容器的所有数据</p> </li><li> <p><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</p> </li><li> <p><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</p> <p>​</p> <p>​</p> </li></ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n//两端操作\nvoid test01()\n{\n\tdeque&lt;int&gt; d;\n\t//尾插\n\td.push_back(10);\n\td.push_back(20);\n\t//头插\n\td.push_front(100);\n\td.push_front(200);\n\n\tprintDeque(d);\n\n\t//尾删\n\td.pop_back();\n\t//头删\n\td.pop_front();\n\tprintDeque(d);\n\tcout&lt;&lt;endl;\n}\n\n//插入\nvoid test02()\n{\n\tdeque&lt;int&gt; d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintDeque(d);\n\n\td.insert(d.begin(), 1000);\n\tprintDeque(d);\n\n\td.insert(d.begin(), 2,10000);\n\tprintDeque(d);\n\n\tdeque&lt;int&gt;d2;\n\td2.push_back(1);\n\td2.push_back(2);\n\td2.push_back(3);\n\n\td.insert(d.begin(), d2.begin(), d2.end());\n\tprintDeque(d);\n\tcout&lt;&lt;endl;\n\n}\n\n//删除\nvoid test03()\n{\n\tdeque&lt;int&gt; d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintDeque(d);\n\n\td.erase(d.begin());\n\tprintDeque(d);\n\n\t//d.erase(d.begin(), d.end());\n\td.clear();\n\tprintDeque(d);\n\n}\n\nint main() {\n\n\ttest01();\n\n\ttest02();\n\n    test03();\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>200 100 10 20<br/> 100 10</p>\n<p></p>\n<p>200 100 10 20<br/> 1000 200 100 10 20<br/> 10000 10000 1000 200 100 10 20<br/> 1 2 3 10000 10000 1000 200 100 10 20</p>\n<p></p>\n<p>200 100 10 20<br/> 100 10 20</p>\n<p>（空字符串）<br/>  </p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"deque%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\">deque 数据存取</h2>\n<ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul>\n<p></p>\n<p>除了用迭代器获取deque容器中元素，[ ]和at也可以</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//数据存取\nvoid test01()\n{\n\n\tdeque&lt;int&gt; d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\n\tfor (int i = 0; i &lt; d.size(); i++) {\n\t\tcout &lt;&lt; d[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\n\tfor (int i = 0; i &lt; d.size(); i++) {\n\t\tcout &lt;&lt; d.at(i) &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tcout &lt;&lt; \"front:\" &lt;&lt; d.front() &lt;&lt; endl;\n\n\tcout &lt;&lt; \"back:\" &lt;&lt; d.back() &lt;&lt; endl;\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>200 100 10 20<br/> 200 100 10 20<br/> front:200<br/> back:20</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"deque%20%E6%8E%92%E5%BA%8F\">deque 排序</h2>\n<ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d) \n{\n\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\n\t}\n\tcout &lt;&lt; endl;\n}\n\nvoid test01()\n{\n\n\tdeque&lt;int&gt; d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintDeque(d);\n\t\n\tsort(d.begin(), d.end());\n\tprintDeque(d);\n\t\n\tsort(d.begin(), d.end(),greater&lt;int&gt;());\n\tprintDeque(d);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>200 100 10 20<br/> 10 20 100 200<br/> 200 100 20 10</p>\n</blockquote>\n<p></p>\n<h1 id=\"deque%EF%BC%8Cstack%20%E5%92%8C%20queue%20%E7%9A%84%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8\">deque，stack 和 queue 的底层默认容器</h1>\n<blockquote>\n<p></p>\n<p> 在 stack 和 queue 的实现上，是选择 deque 作为底层默认容器的。</p>\n<p></p>\n<div>\n<span style=\"color:#777777;\">stack</span>\n<span style=\"color:#777777;\">是一种后进先出的特殊线性数据结构，因此只要具有</span>\n<span style=\"color:#777777;\">push_back()</span>\n<span style=\"color:#777777;\">和</span>\n<span style=\"color:#777777;\">pop_back()</span>\n<span style=\"color:#777777;\">操作的线性结构，都可以作为stack</span>\n<span style=\"color:#777777;\">的底层容器，比如</span>\n<span style=\"color:#777777;\">vector</span>\n<span style=\"color:#777777;\">和</span>\n<span style=\"color:#777777;\">list</span>\n<span style=\"color:#777777;\">都可以；</span>\n<span style=\"color:#777777;\">queue是先进先出的特殊线性数据结构，只要具有 push_back和pop_front</span>\n<span style=\"color:#777777;\">操作的线性结构，都可以作为</span>\n<span style=\"color:#777777;\">queue</span>\n<span style=\"color:#777777;\">的底层容器，比如</span>\n<span style=\"color:#777777;\">list</span>\n<span style=\"color:#777777;\">。但是</span>\n<span style=\"color:#777777;\">STL</span>\n<span style=\"color:#777777;\">中对</span>\n<span style=\"color:#777777;\">stack</span>\n<span style=\"color:#777777;\">和 queue默认选择</span>\n<span style=\"color:#777777;\">deque</span>\n<span style=\"color:#777777;\">作为其底层容器，主要是因为：</span>\n</div>\n<div></div>\n<ol><li><span style=\"color:#0d0016;\">stack 和 queue 不需要遍历（因此 stack 和 queue 没有迭代器），只需要在固定的一端或者两端进行操作。</span></li><li><span style=\"color:#0d0016;\">在 stack 中元素增长时，deque 比 vector 的效率高（扩容时不需要搬移大量数据）；queue  中的元素增长时，deque 不仅效率高，而且内存使用率高。 结合了 deque 的优点，而完美的避开了其缺陷。</span><br/>  </li></ol>\n</blockquote>\n<p></p>\n<h2 id=\"deque%20%E7%9A%84%E7%BC%BA%E9%99%B7\">deque 的缺陷</h2>\n<blockquote>\n<div>\n<span style=\"color:#777777;\"><strong>deque</strong></span>\n<span style=\"color:#777777;\"><strong>有一个致命缺陷：<span style=\"background-color:#f9eda6;\">不适合遍历</span>，因为在遍历时，</strong></span>\n<span style=\"color:#777777;\"><strong>deque</strong></span>\n<span style=\"color:#777777;\"><strong>的迭代器要频繁的去检测其是否移动到</strong></span>\n<span style=\"color:#777777;\"><strong>某段小空间的边界，导致效率低下</strong></span>\n<span style=\"color:#777777;\">，而序列式场景中，可能需要经常遍历，因此</span>\n<span style=\"color:#777777;\"><strong>在实际中，需要线性结构</strong></span>\n<span style=\"color:#777777;\"><strong>时，大多数情况下优先考虑</strong></span>\n<span style=\"color:#777777;\"><strong>vector</strong></span>\n<span style=\"color:#777777;\"><strong>和</strong></span>\n<span style=\"color:#777777;\"><strong>list</strong></span>\n<span style=\"color:#777777;\">，</span>\n<span style=\"color:#777777;\">deque</span>\n<span style=\"color:#777777;\">的应用并不多，而</span>\n<strong><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">目前能看到的一个应用就是，</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">STL</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">用其作</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">为</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">stack</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">和</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">queue</span></span><span style=\"color:#777777;\"><span style=\"background-color:#f9eda6;\">的底层数据结构</span></span></strong>\n</div>\n<div>\n<img alt=\"\" height=\"523\" src=\"..\\..\\static\\image\\8e4ee6e51f9c4700844134e252b5395c.png\" width=\"1042\"/>\n</div>\n<p></p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-19 21:57:08", "summary": "目录容器基本概念常用接口模拟实现类容器基本概念常用接口模拟实现类优先级队列的概念优先级队列的使用模拟实现类双端队列容器基本概念构造函数赋值操作大小操作插入和删除数据存取排序，和的底层默认容器的缺陷容器"}