{"blogid": "126653926", "writerAge": "None", "writerBlogNum": "482", "writerCollect": "4663", "writerComment": "787", "writerFan": "5814", "writerGrade": "7级", "writerIntegral": "11665", "writerName": "阿里巴巴淘系技术团队官网博客", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126653926.jpg", "writerRankTotal": "977", "writerRankWeekly": "3462", "writerThumb": "1246", "writerVisitNum": "1159300", "blog_read_count": "795", "blog_time": "于 2022-09-01 16:20:04 发布", "blog_title": "告别BeanUtils，Mapstruct从入门到精通", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div id=\"js_content\">\n<p><img alt=\"9989cbd6572770e5d25848f90e9c5f82.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/9989cbd6572770e5d25848f90e9c5f82.gif\"/></p>\n<p>如果你现在还在使用BeanUtils，看了本文，也会像我一样，从此改用Mapstruct。</p>\n<p>对象之间的属性拷贝，之前用的是Spring的BeanUtils，有一次，在学习领域驱动设计的时候，看了一位大佬的文章，他在文章中提到使用Mapstruct做DO和Entity的相互转换，出于好奇，后来就去了解了一下Mapstruct，发现这个工具确实优秀，所以果断弃用BeanUtils。</p>\n<p>如果你现在还在使用BeanUtils，看了本文，也会像我一样，从此改用Mapstruct。</p>\n<p>先上结论，Mapstruct的性能远远高于BeanUtils，这应该是大佬使用Mapstruct的主要原因，下面是我的测试结果，可以看出随着属性个数的增加，BeanUtils的耗时也在增加，并且BeanUtils的耗时跟属性个数成正比，而Mapstruct的耗时却一直是1秒，所以从对比数据可以看出Mapstruct是非常优秀的，其性能远远超过BeanUtils。</p>\n<p>下文会讲到Mapstruct性能好的根本原因。</p>\n<table><tbody><tr><td width=\"123\"><p>对象转换次数<br/></p></td><td width=\"123\"><p>属性个数<br/></p></td><td width=\"123\"><p>BeanUtils耗时</p></td><td width=\"123\"><p>Mapstruct耗时</p></td></tr><tr><td width=\"123\"><p>5千万次</p></td><td width=\"123\"><p>6<br/></p></td><td width=\"123\"><p>14秒<br/></p></td><td width=\"123\"><p>1秒</p></td></tr><tr><td width=\"123\"><p>5千万次</p></td><td width=\"123\"><p>15<br/></p></td><td width=\"123\"><p>36秒<br/></p></td><td width=\"123\"><p>1秒</p></td></tr><tr><td width=\"123\"><p>5千万次</p></td><td width=\"123\"><p>25<br/></p></td><td width=\"123\"><p>55秒</p></td><td width=\"123\"><p>1秒</p></td></tr></tbody></table>\n<p>Mapstruct 依赖</p>\n<p>使用Mapstruct需要依赖的包如下,mapstruct、mapstruct-processor、lombok，可以去仓库中查看最新版本。</p>\n<pre class=\"has\"><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;\n            &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;\n            &lt;version&gt;1.5.0.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;\n            &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;\n            &lt;version&gt;1.5.0.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.12&lt;/version&gt;\n        &lt;/dependency&gt;</code></pre>\n<p>简单的属性拷贝</p>\n<p>下面我们先来看下Mapstruct最简单的使用方式。</p>\n<p>当两个对象的属性类型和名称完全相同时，Mapstruct会自动拷贝；假设我们现在需要把UserPo的属性值拷贝到UserEntity中，我们需要做下面几件事情：</p>\n<ol><li><p>定义UserPo和UserEntity</p></li><li><p>定义转换接口</p></li><li><p>编写测试main方法</p></li></ol>\n<h4><strong>▐</strong><strong>  </strong><strong>首先定义UserPo和UserEntity</strong></h4>\n<p style=\"text-align:justify;\">UserPo和UserEntity的属性类型和名称完全相同。</p>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n\nimport java.util.Date;\n\n\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserPo {\n    private Long id;\n    private Date gmtCreate;\n    private Date createTime;\n    private Long buyerId;\n    private Long age;\n    private String userNick;\n    private String userVerified;\n}</code></pre>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport lombok.Data;\n\n\nimport java.util.Date;\n\n\n@Data\npublic class UserEntity {\n    private Long id;\n    private Date gmtCreate;\n    private Date createTime;\n    private Long buyerId;\n    private Long age;\n    private String userNick;\n    private String userVerified;\n}</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>定义转换接口</strong></h4>\n<p>定义mapstruct接口，在接口上打上@Mapper注解。</p>\n<p>接口中有一个常量和一个方法，常量的值是接口的实现类，这个实现类是Mapstruct默认帮我们实现的，下文会讲到。定义了一个po2entity的转换方法，表示把入参UserPo对象，转换成UserEntity。</p>\n<p>注意@Mapper是Mapstruct的注解，不要引错了。</p>\n<pre class=\"has\"><code class=\"language-java\">package mapstruct;\n\n\nimport org.mapstruct.Mapper;\nimport org.mapstruct.factory.Mappers;\n\n\n@Mapper\npublic interface IPersonMapper {\n    IPersonMapper INSTANCT = Mappers.getMapper(IPersonMapper.class);\n    UserEntity po2entity(UserPo userPo);\n}</code></pre>\n<h4><strong>▐</strong><strong>  测试类</strong></h4>\n<p style=\"text-align:justify;\">创建一个UserPo对象，并使用Mapstruct做转化。</p>\n<pre class=\"has\"><code class=\"language-cs\">package mapstruct;\n\n\n\n\nimport org.springframework.beans.BeanUtils;\n\n\nimport java.util.Date;\npublic class MapStructTest {\n    public static void main(String[] args) {\n        testNormal();\n    }\n\n\n    public static void testNormal() {\n        System.out.println(\"-----------testNormal-----start------\");\n        UserPo userPo = UserPo.builder()\n                .id(1L)\n                .gmtCreate(new Date())\n                .buyerId(666L)\n                .userNick(\"测试mapstruct\")\n                .userVerified(\"ok\")\n                .age(18L)\n                .build();\n        System.out.println(\"1234\" + userPo);\n        UserEntity userEntity = IPersonMapper.INSTANCT.po2entity(userPo);\n        System.out.println(userEntity);\n        System.out.println(\"-----------testNormal-----ent------\");\n    }\n}</code></pre>\n<h4><strong>▐</strong><strong>  测试结果</strong></h4>\n<p style=\"text-align:justify;\">可以看到，所有赋值的属性都做了处理，且两边的值都一样，结果符合预期。</p>\n<p style=\"text-align:justify;\">﻿</p>\n<p style=\"text-align:justify;\"><img alt=\"97324b552de351a925f8200791647e0e.png\" src=\"..\\..\\static\\image\\97324b552de351a925f8200791647e0e.png\"/></p>\n<p>Mapstruct 性能优于 BeanUtils 的原因</p>\n<p style=\"text-align:justify;\">Java程序执行的过程，是由编译器先把java文件编译成class字节码文件，然后由JVM去解释执行class文件。Mapstruct正是在java文件到class这一步帮我们实现了转换方法，即做了预处理，提前编译好文件，如果用过lombok的同学一定能理解其好处，通过查看class文件，可以看出IPersonMapper被打上org.mapstruct.Mapper注解后，编译器自动会帮我们生成一个实现类IPersonMapperImpl，并实现了po2entity这个方法，看下面的截图。</p>\n<h4><strong>▐</strong><strong>  </strong><strong>IPersonMapperImpl代码</strong></h4>\n<h4></h4>\n<p style=\"text-align:justify;\">从生成的代码可以看出，转化过程非常简单，只使用了UserPo的get方法和UserEntity的set方法，没有复杂的逻辑处理，清晰明了，所以性能很高。</p>\n<p style=\"text-align:justify;\">下面再去看BeanUtils的默认实现。</p>\n<p style=\"text-align:justify;\"><img alt=\"4a6d53a6ed2d43a016963eab04ce3b1c.png\" src=\"..\\..\\static\\image\\4a6d53a6ed2d43a016963eab04ce3b1c.png\"/></p>\n<h4><strong>▐</strong><strong>  </strong><strong>Spring的BeanUtils源</strong><strong>码</strong></h4>\n<h2></h2>\n<p style=\"text-align:justify;\">BeanUtils部分源码如下，转换的原理是使用的反射，反射的效率相对来说是低的，因为jvm优化在这种场景下有可能无效，所以在对性能要求很高或者经常被调用的程序中，尽量不要使用。我们平时在研发过程中，也会遵守这个原则，非必要，不反射。</p>\n<p style=\"text-align:justify;\">从下面的BeanUtils代码中可以看出，转化逻辑非常复杂，有很多的遍历，去获取属性，获取方法，设置方法可访问，然后执行，所以执行效率相对Mapstruct来说，是非常低的。回头看Mapstruct自动生成的实现类，简洁、高效。</p>\n<pre class=\"has\"><code class=\"language-typescript\">private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties)\n      throws BeansException {\n\n\n    Assert.notNull(source, \"Source must not be null\");\n    Assert.notNull(target, \"Target must not be null\");\n\n\n    Class&lt;?&gt; actualEditable = target.getClass();\n    if (editable != null) {\n      if (!editable.isInstance(target)) {\n        throw new IllegalArgumentException(\"Target class [\" + target.getClass().getName() +\n            \"] not assignable to Editable class [\" + editable.getName() + \"]\");\n      }\n      actualEditable = editable;\n    }\n    PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);\n    List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);\n\n\n    for (PropertyDescriptor targetPd : targetPds) {\n      Method writeMethod = targetPd.getWriteMethod();\n      if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {\n        PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());\n        if (sourcePd != null) {\n          Method readMethod = sourcePd.getReadMethod();\n          if (readMethod != null &amp;&amp;\n              ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {\n            try {\n              if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                readMethod.setAccessible(true);\n              }\n              Object value = readMethod.invoke(source);\n              if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n              }\n              writeMethod.invoke(target, value);\n            }\n            catch (Throwable ex) {\n              throw new FatalBeanException(\n                  \"Could not copy property '\" + targetPd.getName() + \"' from source to target\", ex);\n            }\n          }\n        }\n      }\n    }</code></pre>\n<p>属性类型相同名称不同</p>\n<p style=\"text-align:justify;\">对于属性名称不同的属性进行处理时，需要使用@Mapping，比如修改UserEntity中的userNick为userNick1，然后进行转换。</p>\n<h4><strong>▐</strong><strong>  </strong><strong>修改UserEntity属性userNick1</strong></h4>\n<h4><strong></strong></h4>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport lombok.Data;\n\n\nimport java.util.Date;\n\n\n@Data\npublic class UserEntity {\n    private Long id;\n    private Date gmtCreate;\n    private Date createTime;\n    private Long buyerId;\n    private Long age;\n    private String userNick1;\n    private String userVerified;\n}</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>@Mapping注解指定source和target字段名称对应关系</strong></h4>\n<p style=\"text-align:justify;\">@Mapping(target = \"userNick1\", source = \"userNick\")，此处的意思就是在转化的过程中，将UserPo的userNick属性值赋值给UserEntity的userNick1属性。</p>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport org.mapstruct.Mapper;\nimport org.mapstruct.Mapping;\nimport org.mapstruct.factory.Mappers;\n@Mapper\npublic interface IPersonMapper {\n    IPersonMapper INSTANCT = Mappers.getMapper(IPersonMapper.class);\n    @Mapping(target = \"userNick1\", source = \"userNick\")\n    UserEntity po2entity(UserPo userPo);\n}</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>执行结果</strong></h4>\n<p style=\"text-align:justify;\">可以看到，正常映射，符合预期。</p>\n<p style=\"text-align:justify;\"><img alt=\"4a05ef3026c5fde6b23772fc9d8a8252.png\" src=\"..\\..\\static\\image\\4a05ef3026c5fde6b23772fc9d8a8252.png\"/></p>\n<h4></h4>\n<h4><strong>▐</strong><strong>  </strong><strong>查看class文件</strong></h4>\n<p style=\"text-align:justify;\">我们再来看实现类，可以看到，Mapstruct帮我们做了处理，把po的userNick属性赋值给了entity的userNick1。</p>\n<p style=\"text-align:justify;\"><img alt=\"5d7d96f100453f22256369a0c7a1a6ca.png\" src=\"..\\..\\static\\image\\5d7d96f100453f22256369a0c7a1a6ca.png\"/></p>\n<p>String转日期&amp;String转数字&amp;忽略某个字端&amp;给默认值等</p>\n<pre class=\"has\"><code class=\"language-kotlin\">@Mapping(target = \"createTime\", source = \"createTime\", dateFormat = \"yyyy-MM-dd\")\n@Mapping(target = \"age\", source = \"age\", numberFormat = \"#0.00\")\n@Mapping(target = \"id\", ignore = true)\n@Mapping(target = \"userVerified\", defaultValue = \"defaultValue-2\")</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>查看class实现类</strong></h4>\n<h4><br/></h4>\n<ol><li><p>createTime：可以看到对日期使用了SimpleDateFormat进行转换，这里建议不要使用这个，因为每次都创建了一个SimpleDateFormat，可以参考《阿里巴巴Java开发手册》关于日期转换的建议。</p></li><li><p>age：字符串转数字，也是帮忙做了处理</p></li><li><p>id：字段赋值没有了</p></li><li><p>userVerified：如果为null赋值默认值</p></li></ol>\n<p style=\"text-align:justify;\"><img alt=\"801aa82458d10a99e3576bdfe36fc9de.png\" src=\"..\\..\\static\\image\\801aa82458d10a99e3576bdfe36fc9de.png\"/></p>\n<h1></h1>\n<p>自定义转换</p>\n<p style=\"text-align:justify;\">如果现有的能力都不能满足需要，可以自定义一个转换器，比如我们需要把一个字符串使用JSON工具转换成对象。</p>\n<h4><strong>▐</strong><strong>  </strong><strong>添加属性</strong></h4>\n<h4></h4>\n<p style=\"text-align:justify;\">我们在po中加入一个字符串的attributes属性，在entity中加入Attributes类型的属性</p>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Attributes {\n    private Long id;\n    private String name;\n}</code></pre>\n<pre class=\"has\"><code class=\"language-typescript\">package mapstruct;\n\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n\nimport java.util.Date;\n\n\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserPo {\n    private Long id;\n    private Date gmtCreate;\n    private String createTime;\n    private Long buyerId;\n    private String age;\n    private String userNick;\n    private String userVerified;\n    private String attributes;\n}</code></pre>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport lombok.Data;\n\n\nimport java.util.Date;\n\n\n@Data\npublic class UserEntity {\n    private Long id;\n    private Date gmtCreate;\n    private Date createTime;\n    private Long buyerId;\n    private Long age;\n    private String userNick1;\n    private String userVerified;\n    private Attributes attributes;\n}</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>编写自定义转换处理类</strong></h4>\n<h4></h4>\n<p style=\"text-align:justify;\">转换器很简单，就是一个普通的Java类，只要在方法上打上Mapstruct的注解@Named。</p>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport com.alibaba.fastjson.JSONObject;\nimport org.apache.commons.lang3.StringUtils;\nimport org.mapstruct.Named;\n\n\npublic class AttributeConvertUtil {\n    /**\n     * json字符串转对象\n     *\n     * @param jsonStr\n     * @return\n     */\n    @Named(\"jsonToObject\")\n    public Attributes jsonToObject(String jsonStr) {\n        if (StringUtils.isEmpty(jsonStr)) {\n            return null;\n        }\n        return JSONObject.parseObject(jsonStr, Attributes.class);\n    }\n}</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>修改转换接口</strong></h4>\n<ol><li><p style=\"text-align:justify;\">在@Mapper上引用我们的自定义转换代码类AttributeConvertUtil</p></li><li><p style=\"text-align:justify;\">使用qualifiedByName指定我们使用的自定义转换方法<br/></p></li></ol>\n<pre class=\"has\"><code class=\"language-kotlin\">package mapstruct;\n\n\nimport org.mapstruct.Mapper;\nimport org.mapstruct.Mapping;\nimport org.mapstruct.factory.Mappers;\n\n\n/**\n * @author jiangzhengyin\n */\n@Mapper(uses = AttributeConvertUtil.class)\npublic interface IPersonMapper {\n    IPersonMapper INSTANCT = Mappers.getMapper(IPersonMapper.class);\n    @Mapping(target = \"attributes\", source = \"attributes\", qualifiedByName = \"jsonToObject\")\n    @Mapping(target = \"userNick1\", source = \"userNick\")\n    @Mapping(target = \"createTime\", source = \"createTime\", dateFormat = \"yyyy-MM-dd\")\n    @Mapping(target = \"age\", source = \"age\", numberFormat = \"#0.00\")\n    @Mapping(target = \"id\", ignore = true)\n    @Mapping(target = \"userVerified\", defaultValue = \"defaultValue-2\")\n    UserEntity po2entity(UserPo userPo);\n}</code></pre>\n<h4><strong>▐</strong><strong>  </strong><strong>测试类及结果</strong></h4>\n<p style=\"text-align:justify;\">可以看出我们将把String转成了JSON对象</p>\n<pre class=\"has\"><code class=\"language-cs\">public class MapStructTest {\n    public static void main(String[] args) {\n        testNormal();\n    }\n\n\n    public static void testNormal() {\n        System.out.println(\"-----------testNormal-----start------\");\n        String attributes = \"{\\\"id\\\":2,\\\"name\\\":\\\"测试123\\\"}\";\n        UserPo userPo = UserPo.builder()\n                .id(1L)\n                .gmtCreate(new Date())\n                .buyerId(666L)\n                .userNick(\"测试mapstruct\")\n                .userVerified(\"ok\")\n                .age(\"18\")\n                .attributes(attributes)\n                .build();\n        System.out.println(\"1234\" + userPo);\n        UserEntity userEntity = IPersonMapper.INSTANCT.po2entity(userPo);\n        System.out.println(userEntity);\n        System.out.println(\"-----------testNormal-----ent------\");\n    }\n }</code></pre>\n<p style=\"text-align:justify;\"><img alt=\"632cf757d3393bd50df41da98089239b.png\" src=\"..\\..\\static\\image\\632cf757d3393bd50df41da98089239b.png\"/></p>\n<h4><strong>▐</strong><strong>  </strong><strong>查看实现类</strong></h4>\n<p style=\"text-align:justify;\">可以看到，在实现类中Mapstruct帮我们new了一个AttributeConvertUtil的对象，并调用了该对象的jsonToObject方法，将字符串转成JSON，最终赋值给了UserEntity的attributes属性，实现很简单，也是我们可以猜到的。</p>\n<p style=\"text-align:justify;\"><img alt=\"c8326aaaece9e17def55c8fcfef36a20.png\" src=\"..\\..\\static\\image\\c8326aaaece9e17def55c8fcfef36a20.png\"/></p>\n<p>性能对比</p>\n<p style=\"text-align:justify;\">代码很简单，循环的创建UserPo对象，使用两种方式，转换成UserEntity对象，最终输出两种方式的执行耗时。可以加减属性或者修改转换次数，对比不同场景下的执行耗时。</p>\n<pre class=\"has\"><code class=\"language-cs\">public static void testTime() {\n        System.out.println(\"-----------testTime-----start------\");\n        int times = 50000000;\n        final long springStartTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; times; i++) {\n            UserPo userPo = UserPo.builder()\n                    .id(1L)\n                    .gmtCreate(new Date())\n                    .buyerId(666L)\n                    .userNick(\"测试123\")\n                    .userVerified(\"ok\")\n                    .build();\n            UserEntity userEntity = new UserEntity();\n            BeanUtils.copyProperties(userPo, userEntity);\n        }\n        final long springEndTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; times; i++) {\n            UserPo userPo = UserPo.builder()\n                    .id(1L)\n                    .gmtCreate(new Date())\n                    .buyerId(666L)\n                    .userNick(\"测试123\")\n                    .userVerified(\"ok\")\n                    .build();\n            UserEntity userEntity = IPersonMapper.INSTANCT.po2entity(userPo);\n        }\n        final long mapstructEndTime = System.currentTimeMillis();\n        System.out.println(\"BeanUtils use time=\" + (springEndTime - springStartTime) / 1000 + \"秒\" +\n                \"; Mapstruct use time=\" + (mapstructEndTime - springEndTime) / 1000 + \"秒\");\n        System.out.println(\"-----------testTime-----end------\");\n    }</code></pre>\n<p style=\"text-align:justify;\"><img alt=\"b89030eb982f2f9e30e10619997db254.png\" src=\"..\\..\\static\\image\\b89030eb982f2f9e30e10619997db254.png\"/><br/></p>\n<p>总结</p>\n<p style=\"text-align:justify;\">通过本次调研，Mapstruct的高性能是毋庸置疑的，这也是我选择使用他的根本原因。在使用方式上和BeanUtils对比，Mapstruct需要创建mapper接口和自定义转换工具类，其实上手成本并不高，但是我们换取了高性能，这是非常值得的，所以强烈推荐大家使用Mapstruct，是时候和BeanUtils说再见了。</p>\n<p style=\"text-align:justify;\">保持好奇，不断探索，让程序更友好！</p>\n<p>团队介绍</p>\n<p style=\"text-align:justify;\">TMALL CAMPUS (天猫校园) 是阿里巴巴旗下重要的业务单元，天猫校园整合阿里巴巴大生态，将新理念、新技术、新业态、新模式落地到校园，为师生提供多方位、多形态的服务，协助高校后勤服务升级；致力于打造购物、学习、生活、实践为一体的校园生活新方式，实现校园商业的服务育人。<br/>天猫校园，让校园学习生活更美好</p>\n<p style=\"text-align:center;\">✿  <strong>拓展阅读</strong></p>\n<p style=\"text-align:center;\"><a href=\"\"><img alt=\"8f1aec5f834eba868dccd592e35504e4.jpeg\" src=\"..\\..\\static\\image\\8f1aec5f834eba868dccd592e35504e4.jpeg\"/></a></p>\n<p style=\"text-align:center;\"><a href=\"\"><img alt=\"28df8007fc3490f8a05a8575e3218aab.jpeg\" src=\"..\\..\\static\\image\\28df8007fc3490f8a05a8575e3218aab.jpeg\"/></a></p>\n<p><strong>作者<strong>|</strong></strong>蒋政印（不习）</p>\n<p><strong>编辑|</strong>橙子君</p>\n<p><img alt=\"e0a2a5f23420a1a86ae329369fcdcd58.png\" src=\"..\\..\\static\\image\\e0a2a5f23420a1a86ae329369fcdcd58.png\"/></p>\n</div>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-01 16:20:04", "summary": "如果你现在还在使用，看了本文，也会像我一样，从此改用。对象之间的属性拷贝，之前用的是的，有一次，在学习领域驱动设计的时候，看了一位大佬的文章，他在文章中提到使用做和的相互转换，出于好奇，后来就去了解了"}