{"blogid": "126329123", "writerAge": "码龄2年", "writerBlogNum": "25", "writerCollect": "1669", "writerComment": "913", "writerFan": "9222", "writerGrade": "5级", "writerIntegral": "2785", "writerName": "石原里美的微笑", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126329123.jpg", "writerRankTotal": "7270", "writerRankWeekly": "781", "writerThumb": "1063", "writerVisitNum": "94631", "blog_read_count": "1273", "blog_time": "已于 2022-09-05 11:04:21 修改", "blog_title": "Java中的反射如何理解——精简", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BC%95%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E8%A8%80\">引言</a></p>\n<p id=\"%E5%8F%8D%E5%B0%84%E6%A6%82%E5%BF%B5%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%8D%E5%B0%84%E6%A6%82%E5%BF%B5%C2%A0\">反射概念 </a></p>\n<p id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取类对象 </a></p>\n<p id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取构造器对象 </a></p>\n<p id=\"%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BD%BF%E7%94%A8\">获取构造器对象并使用</a></p>\n<p id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取成员变量对象 </a></p>\n<p id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取方法对象 </a></p>\n<p id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8%C2%A0\">反射获取成员方法并使用 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%BC%95%E8%A8%80\">引言</h1>\n<blockquote>\n<p>        经过前面的学习，相信大家已经能够对网络编程有了一定的了解，而我们的Java基础知识也要在本次的学习之后结束了，希望之前总结的Java知识能够对你有所帮助。本次我们学习的内容是Java中的反射，这也是一个非常重要的知识点，在这个时候大家可千万不能够放弃学习啊。而且在学习过Javase之后，才会发现这只是冰山一角，废话不多说了，我们开始今天的学习吧！</p>\n<p><img alt=\"\" height=\"515\" src=\"..\\..\\static\\image\\4d5c22df7edf4e638d3c7adb5dc89427.png\" width=\"686\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%8F%8D%E5%B0%84%E6%A6%82%E5%BF%B5%C2%A0\">反射概念 </h1>\n<blockquote>\n<p>反射是指对于任何一个Class类，在\"运行的时候\"都可以直接得到这个类全部成分</p>\n<ul><li>在运行时,可以直接得到这个类的构造器对象:<span style=\"background-color:#a2e043;\">constructor</span></li><li>在运行时,可以直接得到这个类的成员变量对象:<span style=\"background-color:#38d8f0;\">Field</span></li><li>在运行时,可以直接得到这个类的成员方法对象:<span style=\"background-color:#ed7976;\">Method</span></li></ul>\n<p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。<br/><strong>反射的关键</strong></p>\n<p>HelloWorld.java -&gt; javac -&gt; HelloWorld.java</p>\n<p><span style=\"color:#fe2c24;\">Class c = HelloWorld.java</span></p>\n</blockquote>\n<h1 id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取类对象 </h1>\n<blockquote>\n<p>首先，反射的第一步是需要获取类的对象，只有获取了类的对象，才可以进一步获取其他的对象，在此共有三种方法可以获取类的对象：</p>\n<p>1、在源代码阶段，通过Class类中的静态方法forName(全限名：包名+类名) 获取；</p>\n<pre><code class=\"language-java\">//Student为要获取的类对象\nClass c1 = forNmae(\"Student\");</code></pre>\n<p>2、在class对象阶段，通过类名.class直接获取</p>\n<pre><code class=\"language-java\">Class c2 = Student.class</code></pre>\n<p>3、在Runtime运行时阶段通过对象获取</p>\n<pre><code class=\"language-java\">Student student = new Student();\nClass c3 = student.getClass();</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"211\" src=\"https://img-blog.csdnimg.cn/8a64d8cecc5e4e3383c39880582ee6a3.gif\" width=\"260\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取构造器对象 </h1>\n<blockquote>\n<p>在前面获取Class类对象之后，便可以获取其类中构造器对象。</p>\n<p>Class类中常用于获取构造器的方法</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>Constructor&lt;?&gt;[]getconstructors()</td><td>返回所有构造器对象的数组（只能拿public的)</td></tr><tr><td>constructor&lt;?&gt;[] getDeclaredconstructors()</td><td>返回所有构造器对象的数组,存在就能拿到</td></tr><tr><td>Constructor&lt;T&gt; getconstructor(class&lt;?&gt;... parameterTypes)</td><td>返回单个构造器对象（只能拿public的)</td></tr><tr><td>Constructor&lt;T&gt; getDeclaredConstructor(class&lt;?&gt;... parameterTypes)</td><td>返回单个构造器对象,存在就能拿到</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">/**\n1、返回所有构造器对象的数组（只能拿public的)\ngetconstructors()\n*/\nClass c1 = Student.class;\nConstructor[] constructors = c1.getconstructors();\n/**\n2、返回所有构造器对象的数组,存在就能拿到\ngetDeclaredconstructors()\n*/\nClass c2 = Student.class;\nConstructor[] constructors = c2.getDeclaredconstructors();\n/**\n3、返回单个构造器对象（只能拿public的)\ngetconstructor(根据参数个数获取构造器，若无参，则获取无参构造器)\n*/\nClass c3 = Student.class;\nConstructor constructor = c3.getconstructor();\n/**\n4、返回单个构造器对象,存在就能拿到\ngetDeclaredconstructor(规则同上)\n*/\nClass c4 = Student.class;\nConstructor constructor = c4.getDeclaredconstructor(String.class,int.class);</code></pre>\n<p></p>\n</blockquote>\n<h2 id=\"%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BD%BF%E7%94%A8\">获取构造器对象并使用</h2>\n<blockquote>\n<p> 获取构造器的作用是初始化一个对象返回</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>T newInstance(Object ...inittargs)</td><td>根据指定的构造器创建对象</td></tr><tr><td>public void setAccessible(boolean flag)</td><td>设置为true，表示取消访问检查，进行暴力反射</td></tr></tbody></table>\n<pre><code class=\"language-java\">//1、获取单个构造器\nClass c = Student.class;\nConstructor constructor = c4.getDeclaredconstructor();\n//2、调用方法创建对象\nStudent s = (Student)constructor.newInstance();</code></pre>\n<p>在运行代码过后发现并不能创建对象，会直接报错，这是什么原因呢？这是因为获取的构造器是私有的，不能用来直接创建，因此需要用到另一个方法进行暴力反射。在第三行加一行代码</p>\n<pre><code class=\"language-java\">constructor.setAccessible(true);</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"238\" src=\"https://img-blog.csdnimg.cn/e753d94be8184a3e9ed3afc32173f3c2.gif\" width=\"238\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取成员变量对象 </h1>\n<blockquote>\n<p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象</p>\n<p>Class类中用于获取成员变量的方法</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>Field[ ]getFields()</td><td>返回所有成员变量对象的数组〈只能拿public的)</td></tr><tr><td>Field[ ]getDeclaredFields()</td><td>返回所有成员变量对象的数组,存在就能拿到</td></tr><tr><td>Field getField(String name)</td><td>返回单个成员变量对象（只能拿public的)</td></tr><tr><td>Field getDeclaredField(String name)</td><td>返回单个成员变量对象，存在就能拿到</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">/**\n1、返回所有成员变量对象的数组〈只能拿public的)\ngetFields()\n*/\nClass c = Student.class;\nField[] fields = c.getFields();\n/**\n2、返回单个成员变量对象（只能拿public的)\ngetDeclaredField()\n*/\nClass c = Student.class;\nField field = c.getDeclaredField(\"name\");</code></pre>\n<p>Field的方法：给成员变量赋值和取值</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>void set(Object obj,Object value)</td><td>给对象定义某个成员变量数据</td></tr><tr><td>Object  get(Object obj)</td><td>获取对象成员变量的值</td></tr><tr><td>public void setAccessible(boolean flag)</td><td>设置为true，表示取消访问检查，进行暴力反射</td></tr><tr><td>Class getType()</td><td>获取属性的类型，返回class对象</td></tr><tr><td>String getName()</td><td>获取属性的名称</td></tr></tbody></table>\n<pre><code class=\"language-java\">//1、获取Student对象类\nClass c = Student.class;\n//2、通过对象类获取name成员变量\nField name = c.getDeclaredField(\"name\");\n//3、定义Student类，并为其成员变量name赋值\nStudent s = new Student();\nname.set(s,\"石原里美\");//s.setName(\"石原里美\")</code></pre>\n<p>在运行的过程之中，我们同样会遇到和之前一样的错误，不能对私有成员变量赋值，因此还需要对其进行暴力反射，需要在第二步之后添加一行代码name.setAccessible(true);</p>\n<p class=\"img-center\"><img alt=\"\" height=\"191\" src=\"https://img-blog.csdnimg.cn/5ac6a1a3fb72405191a727bf4be877bd.gif\" width=\"248\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1%C2%A0\">反射获取方法对象 </h1>\n<blockquote>\n<p>反射的第一步先得到类对象，然后从类对象中获取类的方法对象</p>\n<p>Class类中用于获取成员方法的方法 </p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>Method[ ] getNethods()</td><td>返回所有成员方法对象的数组(只能拿public的)</td></tr><tr><td>Method[ ] getDeclaredMethods()</td><td>返回所有成员方法对象的数组，存在就能拿到</td></tr><tr><td>Method getMethod(String name，class&lt;?&gt;... parameterTypes)</td><td>返回单个成员方法对象(只能拿public的)</td></tr><tr><td>Method getDeclaredMethod(String name，Class&lt;?&gt;... parameterTypes)</td><td>返回单个成员方法对象,存在就能拿到</td></tr></tbody></table>\n<pre><code class=\"language-java\">//1、获取类对象中所有方法\nClass c = Student.class;\nMethod[] methods = c.getDeclaredMethods();\n//2、根据参数获取单个方法\nClass c = Student.class;\nMethod m1 = c.getDeclaredMethod(\"study\");//无参数方法\nMethod m2 = c.getDeclaredMethod(\"study\",String.class);//若存在方法重载，则需要根据参数区分</code></pre>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8%C2%A0\">反射获取成员方法并使用 </h2>\n<blockquote>\n<p>Method类中用于触发执行的方法</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>object invoke(object obj， object. . . args)<br/>  </td><td> <p>运行方法：</p> <p>参数一:用obj对象调用该方法<br/> 参数二:调用方法的传递的参数（如果没有就不写)</p> <p>返回值:方法的返回值（如果没有就不写)</p> </td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">Class c = new Student();\nMethod method = c.getDeclaredMethod(\"study\");\nObject result = method.invoke(c);</code></pre>\n<p>注意：若没有返回值，则直接返回null，另外若是私有方法则需要对其进行暴力反射。若有参数，则在对象之后传输。</p>\n</blockquote>\n<p style=\"text-align:center;\"><strong><span style=\"background-color:#4da8ee;\">创作不易，给个三连</span></strong></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"264\" src=\"https://img-blog.csdnimg.cn/c9a0c27a9ab94134a728ea999f7ef565.gif\" width=\"305\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-05 11:04:21", "summary": "目录引言反射概念反射获取类对象反射获取构造器对象获取构造器对象并使用反射获取成员变量对象反射获取方法对象反射获取成员方法并使用引言经过前面的学习，相信大家已经能够对网络编程有了一定的了解，而我们的基础"}