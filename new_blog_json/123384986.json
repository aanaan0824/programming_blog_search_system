{"blogid": "123384986", "writerAge": "码龄2年", "writerBlogNum": "109", "writerCollect": "1535", "writerComment": "179", "writerFan": "1112", "writerGrade": "5级", "writerIntegral": "2039", "writerName": "秃头披风侠.", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123384986.jpg", "writerRankTotal": "11826", "writerRankWeekly": "25433", "writerThumb": "692", "writerVisitNum": "176224", "blog_read_count": "3250", "blog_time": "于 2022-03-09 23:36:41 发布", "blog_title": "Session详解，学习Session，这篇文章就够了(包含底层分析和使用)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>        <strong>说明：下面介绍session，我们使用到了游览器抓包，http的知识，如果不了解，请先简单了解下。<a class=\"link-info\" href=\"https://blog.csdn.net/m0_51545690/article/details/123090635\" title=\"，http请求\"></a><a class=\"link-info\" href=\"https://blog.csdn.net/m0_51545690/article/details/123088133\" title=\"http介绍\">http介绍</a>，http请求，<a class=\"link-info\" href=\"https://blog.csdn.net/m0_51545690/article/details/123099721\" title=\"http响应\">http响应</a>。因为cookie和session是一对”好兄弟“，我们介绍session也要使用到cookie，如果不清楚cookie，请查看<a class=\"link-info\" href=\"https://blog.csdn.net/m0_51545690/article/details/123359959\" title=\"cookie详解\">cookie详解</a>。废话不多说，直接开始吧。</strong></p>\n<hr/>\n<h2>什么是session</h2>\n<blockquote>\n<p>        session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。 </p>\n</blockquote>\n<h2>session有什么用</h2>\n<blockquote>\n<p>        我们先来想一个问题，这个问题就是我们在游览购物网站时，我们并没有登录，但是我们任然可以将商品加入购物车，并且进行查看，当我们退出游览器后再打开游览器进行查看时，购物车中依然有我们选择的商品，这该怎么实现呢？</p>\n<p>        当然，我们可以使用cookie，但是cookie能存放大量数据吗？这时，我们就需要一种新的技术，<strong>Session</strong>。session是存储于服务器端的特殊对象，服务器会为每一个游览器(客户端)创建一个唯一的session。这个session是服务器端共享，每个游览器(客户端)独享的。我们可以在session存储数据，实现数据共享。</p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>这是session的简单原理示意图</strong></span></p>\n<h2><img alt=\"\" height=\"529\" src=\"..\\..\\static\\image\\1df47fdfc6f64b5fb692ddeed8f49580.png\" width=\"1146\"/> session的存储形式</h2>\n<blockquote>\n<p>        session类似于一个Map，里面可以存放多个键值对，是以key-value进行存放的。key必须是一个字符串，value是一个对象。</p>\n</blockquote>\n<h2>session底层实现机制</h2>\n<blockquote>\n<p>        session是每一个游览器(客户端)所唯一的，这个是怎么实现的呢？其实，在访问一个网站时，在HTTP请求中往往会携带一个cookie，这个cookie的名字是JSESSIONID，这个JSESSIONID表示的就是session的id，这个是由服务器创建的，并且是唯一的。服务器在使用session时，会根据JSESSIONID来进行不同操作。</p>\n<p>        下面我使用图示来进行说明</p>\n</blockquote>\n<p><img alt=\"\" height=\"480\" src=\"..\\..\\static\\image\\20ec6f00f97d4348b2a3f5c8de0f0ee1.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         当我们在服务端使用session时，首先要获取session，这个session是通过JSESSIONID进行获取。当然，这时就已经有好多种情况了。例如游览器访问时没有携带JSESSIONID，游览器携带的JSESSIONID对应的session不存在(或者失效)等情况。上面这个图就对服务器获取session的一些情况进行了说明。</p>\n</blockquote>\n<h2>游览器抓包进行查看 </h2>\n<blockquote>\n<p>        下面我创建了一个简单的服务器，服务端操作session，看游览器中的JSESSION的如何进行携带的。我服务器的访问地址是localhost:8080/cs/createSession,最开始游览器是没有JSESSIONID的cookie，而服务端要操作session，我们访问后看服务器返回什么。</p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong> 这是我们抓包后看到的请求头</strong></span><img alt=\"\" height=\"390\" src=\"..\\..\\static\\image\\168042b840da4a2a9de2a113d128baf9.png\" width=\"1200\"/></p>\n<p> <span style=\"color:#fe2c24;\"><strong>这是我们的响应头</strong></span></p>\n<p><img alt=\"\" height=\"209\" src=\"..\\..\\static\\image\\1d9d236ab9454ccf86e6e9ae165aef23.png\" width=\"883\"/></p>\n<blockquote>\n<p>        我们发现如果游览器访问服务器，如果没有携带JSESSIONID，那么服务器就会创建一个session，并且把这个session的JSESSIONID返回给游览器。 </p>\n</blockquote>\n<blockquote>\n<p>        下面，我们再次访问同样的地址，这次就会携带JSESSIONID了。 </p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>我们发送的请求头 </strong></span></p>\n<p><img alt=\"\" height=\"401\" src=\"..\\..\\static\\image\\de489254024543e2845555c2909b3db9.png\" width=\"1071\"/><strong><span style=\"color:#fe2c24;\"> 我们抓包看见的响应头</span></strong></p>\n<p><img alt=\"\" height=\"169\" src=\"..\\..\\static\\image\\9bbf220f014d4716ae383567447bf73f.png\" width=\"751\"/></p>\n<blockquote>\n<p>         我们发现，如果游览器携带了JSESSIONID，那么游览器在访问时就会携带。而服务器在使用session时，就会使用这个JSESSIONID的session。</p>\n</blockquote>\n<blockquote>\n<p>        当然，上面是正常情况，那就是服务器端有对应JSESSIONID的session，并且没有过期。下面，我把游览器发送请求的JSESSIONID改2个字母，看游览器请求和服务器返回的是上面。 </p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>请求头 </strong></span></p>\n<p><img alt=\"\" height=\"393\" src=\"..\\..\\static\\image\\adb293dfda3241558b47d53e37c5615b.png\" width=\"1200\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong>响应头</strong></span></p>\n<p><img alt=\"\" height=\"191\" src=\"..\\..\\static\\image\\b9121147b0de4fc7aee5b67273ca6cc0.png\" width=\"781\"/></p>\n<blockquote>\n<p>        这次，我们发现请求头和响应头都携带了JSESSIONID，这是因为游览器携带的JSESSIONID在服务器端并没有对应的session，或者session已经过期了。所以服务器创建了一个新的session，并且把新的JSESSIONID返回给了游览器。 </p>\n</blockquote>\n<blockquote>\n<p>         通过session底层实现机制和http抓包查看JSESSIONID，大家应该已经对session的原理有了清晰的认识。下面我来介绍一下session的常用方法(基于java的)。</p>\n</blockquote>\n<h2> session常用方法</h2>\n<ul><li>resquest.getSession()：得到请求游览器(客户端)对应的session。如果没有，那么就创建应该新的session。如果有那么就返回对应的session</li><li>setAttribute(String s, Object o)：在session存放属性</li><li>getAttribute(String s)：从session中得到s所对应的属性</li><li>removeAttribute(String s)：从session中删除s对应的属性</li><li>getId()：得到session所对应的id</li><li>invalidate()：使session立即无效</li><li>setMaxInactiveInterval(int i)：设置session最大的有效时间。<strong>注意，这个有效时间是两次访问服务器所间隔的最大时间，如果超过最大的有效时间，那么这个session就失效了。</strong></li></ul>\n<hr/>\n<h2>session实例应用</h2>\n<blockquote>\n<p>        我们利用session来实现一个登录验证的功能。如果用户登录成功了，那么我们在1天内访问主页面就不需要登录了。我们利用session进行实现。</p>\n<p>        我创建了一个html页面，2个servlet来实现这次功能。代码如下</p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>html页面</strong></span></p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;login&lt;/title&gt;\n    &lt;base href=\"/cs/\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=\"checkLogin\" method=\"post\"&gt;\n    用户名：&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt;\n    密　码：&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt;\n    &lt;input type=\"submit\" value=\"登录\"&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<blockquote>\n<p>        这个html就是一个简单的登录页面。</p>\n</blockquote>\n<p><strong><span style=\"color:#fe2c24;\">这个Servlet用于判断用户名和密码是否是我们规定的</span></strong> </p>\n<pre><code class=\"language-java\">import javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebServlet(\"/checkLogin\")\npublic class CheckServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //得到用户名和密码\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        //判断用户名和密码是否为我们设置的密码\n        if (username.equals(\"tom\") &amp;&amp; password.equals(\"tom123\")){\n            //得到session\n            HttpSession session = request.getSession();\n            //设置最长访问间隔时间\n            session.setMaxInactiveInterval(60*60*24);\n            //将用户名存入session\n            session.setAttribute(\"username\",username);\n            //重定向到主页面\n            response.sendRedirect(request.getContextPath()+\"/mainPage\");\n        }else {\n            //设置MIME类型和编码\n            response.setContentType(\"text/html;charset=utf-8\");\n            //写回提示信息\n            PrintWriter writer = response.getWriter();\n            writer.write(\"&lt;h1&gt;账号或密码错误&lt;/h1&gt;\");\n            writer.write(\"&lt;h3&gt;&lt;a href='\"+request.getContextPath()+\"/login.html'&gt;点击重新登录&lt;/a&gt;&lt;/h3&gt;\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>这个Servlet就是我们的主页面</strong></span></p>\n<pre><code class=\"language-java\">import javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebServlet(\"/mainPage\")\npublic class MainServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //设置响应的MIME类型和编码\n        response.setContentType(\"text/html;charset=utf-8\");\n        //得到session\n        HttpSession session = request.getSession();\n        //取出用户名\n        Object username = session.getAttribute(\"username\");\n        PrintWriter writer = response.getWriter();\n        //判断用户名是否存在\n        if (username != null){\n            //在一天内登录过，无需再次登录\n            writer.write(\"&lt;h1&gt;用户：\"+username+\" 登录成功&lt;/h1&gt;\");\n        }else {\n            //没有登录，或者登录间隔大于1天。重定向到登陆界面\n            response.sendRedirect(request.getContextPath()+\"/login.html\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n</code></pre>\n<hr/>\n<h2>代码测试</h2>\n<blockquote>\n<p>       <strong> 我们一来就直接访问主界面。</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"702\" src=\"..\\..\\static\\image\\208029788f8842768435acb4a7ffefc7.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         <strong>发现服务器发现我们没有登录，直接重定向到登录界面。下面我们来登录一下，输入我们设置的用户名和密码，分别是tom和tom123</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"563\" src=\"..\\..\\static\\image\\2eab405feba748409cb4d3c906e92376.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        <strong>我们登录成功了，那么现在我们关闭游览器，然后重新打开，并且直接访问主界面，看能否直接访问。</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"701\" src=\"..\\..\\static\\image\\939432048a7a4498a3a9f1a02ffcd1a5.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         <strong>我们发现登录成功了，并没有重定向，因为我们已经登录过了嘛，一天之内都不需要重新登陆。我们的功能就实现了。</strong></p>\n</blockquote>\n<hr/>\n<h2>session和cookie的比较 </h2>\n<ul><li>cookie保存在客户端，session保存在服务端</li><li>cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)</li><li>我们使用session需要cookie的配合。cookie用来携带JSESSIONID</li><li>cookie存放的数据量较小，session可以存储更多的信息。</li><li>cookie由于存放在客服端，相对于session更不安全</li><li>由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。</li></ul>\n<hr/>\n<h2><strong>总结</strong></h2>\n<p><strong>        session就是一个存储于服务器的特殊对象，通过session可以实现数据共享，session有一个JSESSIONID，这个是session的唯一标识，使用它可以查找到session。session是会话级别的，对于每一个客户端来说是独享它所拥有的session的，我们使用session在进行页面跳转时，服务端可以利用session进行数据共享。session由服务器进行控制。session的创建和销毁都是服务器进行管理的。服务器会为每一个客户端创建一个session。</strong></p>\n<p><strong>        <span style=\"color:#fe2c24;\">以上就是我对于session的讲解，如果觉得讲的不错，那就点赞评论支持一下吧！！！</span></strong></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-03-09 23:36:41", "summary": "说明：下面介绍，我们使用到了游览器抓包，的知识，如果不了解，请先简单了解下。，请求介绍介绍，请求，响应响应。因为和是一对好兄弟，我们介绍也要使用到，如果不清楚，请查看详解详解。废话不多说，直接开始吧。"}