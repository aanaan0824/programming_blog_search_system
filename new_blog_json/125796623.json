{"blogid": "125796623", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5465", "writerComment": "4193", "writerFan": "7301", "writerGrade": "7级", "writerIntegral": "13153", "writerName": "三分苦", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125796623.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4502", "writerVisitNum": "115903", "blog_read_count": "230", "blog_time": "于 2022-08-21 09:09:04 发布", "blog_title": "【 C++ 】list的模拟实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"00-toc\" style=\"margin-left:80px;\"><a href=\"#00\">1、list三个基本模板类</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">2、结点类接口实现</a></p>\n<p id=\"22-toc\" style=\"margin-left:80px;\"><a href=\"#22\">        基本框架</a></p>\n<p id=\"33-toc\" style=\"margin-left:80px;\"><a href=\"#33\">        构造函数</a></p>\n<p id=\"44-toc\" style=\"margin-left:80px;\"><a href=\"#44\">3、迭代器类接口实现</a></p>\n<p id=\"55-toc\" style=\"margin-left:80px;\"><a href=\"#55\">        3.1、正向迭代器</a></p>\n<p id=\"66-toc\" style=\"margin-left:80px;\"><a href=\"#66\">                基本框架</a></p>\n<p id=\"77-toc\" style=\"margin-left:80px;\"><a href=\"#77\">                默认成员函数</a></p>\n<p id=\"88-toc\" style=\"margin-left:80px;\"><a href=\"#88\">                构造函数</a></p>\n<p id=\"99-toc\" style=\"margin-left:80px;\"><a href=\"#99\">                * 运算符重载</a></p>\n<p id=\"000-toc\" style=\"margin-left:80px;\"><a href=\"#000\">                -&gt;运算符重载</a></p>\n<p id=\"111-toc\" style=\"margin-left:80px;\"><a href=\"#111\">                ++运算符重载</a></p>\n<p id=\"222-toc\" style=\"margin-left:80px;\"><a href=\"#222\">                --运算符重载</a></p>\n<p id=\"333-toc\" style=\"margin-left:80px;\"><a href=\"#333\">                !=运算符重载</a></p>\n<p id=\"444-toc\" style=\"margin-left:80px;\"><a href=\"#444\">                ==运算符重载</a></p>\n<p id=\"555-toc\" style=\"margin-left:80px;\"><a href=\"#555\">        3.2、反向迭代器</a></p>\n<p id=\"999-toc\" style=\"margin-left:80px;\"><a href=\"#999\">4、list类接口实现</a></p>\n<p id=\"0000-toc\" style=\"margin-left:80px;\"><a href=\"#0000\">        基本框架</a></p>\n<p id=\"1111-toc\" style=\"margin-left:80px;\"><a href=\"#1111\">        4.1、默认成员函数</a></p>\n<p id=\"2222-toc\" style=\"margin-left:80px;\"><a href=\"#2222\">                构造函数</a></p>\n<p id=\"3333-toc\" style=\"margin-left:80px;\"><a href=\"#3333\">                析构函数</a></p>\n<p id=\"4444-toc\" style=\"margin-left:80px;\"><a href=\"#4444\">                拷贝构造函数</a></p>\n<p id=\"5555-toc\" style=\"margin-left:80px;\"><a href=\"#5555\">                赋值运算符重载函数</a></p>\n<p id=\"6666-toc\" style=\"margin-left:80px;\"><a href=\"#6666\">        4.2、迭代器相关函数</a></p>\n<p id=\"7777-toc\" style=\"margin-left:80px;\"><a href=\"#7777\">                begin和end</a></p>\n<p id=\"8888-toc\" style=\"margin-left:80px;\"><a href=\"#8888\">                rbegin和rend</a></p>\n<p id=\"9999-toc\" style=\"margin-left:80px;\"><a href=\"#9999\">        4.3、增加的相关函数</a></p>\n<p id=\"00000-toc\" style=\"margin-left:80px;\"><a href=\"#00000\">                insert</a></p>\n<p id=\"11111-toc\" style=\"margin-left:80px;\"><a href=\"#11111\">                push_back尾插</a></p>\n<p id=\"22222-toc\" style=\"margin-left:80px;\"><a href=\"#22222\">                push_front头插</a></p>\n<p id=\"33333-toc\" style=\"margin-left:80px;\"><a href=\"#33333\">        4.4、删除的相关函数</a></p>\n<p id=\"44444-toc\" style=\"margin-left:80px;\"><a href=\"#44444\">                erase</a></p>\n<p id=\"55555-toc\" style=\"margin-left:80px;\"><a href=\"#55555\">                pop_back尾删</a></p>\n<p id=\"66666-toc\" style=\"margin-left:80px;\"><a href=\"#66666\">                pop_front头删</a></p>\n<p id=\"77777-toc\" style=\"margin-left:80px;\"><a href=\"#77777\">        4.5、其它函数</a></p>\n<p id=\"88888-toc\" style=\"margin-left:80px;\"><a href=\"#88888\">                clear清除</a></p>\n<p id=\"99999-toc\" style=\"margin-left:80px;\"><a href=\"#99999\">                empty_init空初始化</a></p>\n<p id=\"00-toc\" style=\"margin-left:80px;\"><a href=\"#00\">                swap交换</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">5、源码链接</a></p>\n<hr/>\n<h3>1、list三个基本函数类</h3>\n<blockquote>\n<p>前面list的学习中我们得知，list其实就是一个带头双向循环链表：</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\b99d9fdf2ee84c6ca1254e1179c4c772.png\"/></p>\n<p>现在要模拟实现list，要实现下列三个类：</p>\n<ol><li>模拟实现结点类</li><li>模拟实现迭代器的类</li><li>模拟list主要功能的类</li></ol>\n<p>这三个类的实现层层递进，就好比如我整个核心list的类的模拟实现其基本功能（增加删除……）要建立在迭代器类和结点类均已实现好的情况下才得以完成。</p>\n</blockquote>\n<hr/>\n<h3 id=\"11\">2、结点类接口实现</h3>\n<blockquote>\n<p>因为list的本质为带头双向循环链表，所以其每个结点都要确保有下列成员：</p>\n<ol><li>前驱指针</li><li>后继指针</li><li>data值存放数据</li></ol>\n<p>而结点类的内部<span style=\"color:#956fe7;\">只需要实现一个构造函数</span>即可。</p>\n</blockquote>\n<h3 id=\"22\">基本框架</h3>\n<blockquote>\n<pre><code class=\"language-cpp\">//1、结点类的模拟实现\ntemplate&lt;class T&gt;\nstruct list_node//因为成员函数都是公有，就不设计成class了，直接struct\n{\n\tlist_node&lt;T&gt;* _next;//后继指针\n\tlist_node&lt;T&gt;* _prev;//前驱指针\n\tT _data;//记录数据\n};</code></pre>\n</blockquote>\n<h3 id=\"33\">构造函数</h3>\n<blockquote>\n<p>构造函数这里是用来对其成员变量的一个初始化。</p>\n<pre><code class=\"language-cpp\">//构造函数\nlist_node(const T&amp; val = T())//给一个缺省值T()\n\t:_next(nullptr)\n\t, _prev(nullptr)\n\t, _data(val)\n{}</code></pre>\n</blockquote>\n<h3 id=\"44\">3、迭代器类接口实现</h3>\n<blockquote>\n<p>这里强调下，因为list的特殊性，其本质是带头双向循环链表，对于链表，我们已然得知其内存空间是不连续的，是通过结点的指针顺次链接，我们不能像先前的string和vector一样直接解引用去访问其数据，结点的指针解引用还是结点，结点指针++还是结点指针，<span style=\"color:#956fe7;\">归根结底在于list物理空间不连续。而string和vector的物理空间是连续的</span>，所以这俩不需要实现迭代器类，可以直接使用。</p>\n<p>为了能让list像vector一样去解引用，++访问到下一个数据，我们需要<span style=\"color:#fe2c24;\">单独写一个迭代器类的接口实现，在其内部进行封装补齐相应的功能，而这就要借助运算符重载来完成</span>。</p>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：</span></li></ul>\n<p>迭代器又分为<span style=\"color:#956fe7;\">正向迭代器和反向迭代器</span>。</p>\n</blockquote>\n<h3 id=\"55\">3.1、正向迭代器</h3>\n<h3 id=\"66\">基本框架</h3>\n<blockquote>\n<pre><code class=\"language-cpp\">//模拟实现迭代器类\ntemplate&lt;class T, class Ref, class Ptr&gt;\nstruct __list_iterator//因为成员函数都是公有，就不设计成class了，直接struct\n{\n\ttypedef list_node&lt;T&gt; Node;\n\ttypedef __list_iterator&lt;T, Ref, Ptr&gt; self;//只要用自己的类型，就对其typedef成self，方便后续使用\n\tNode* _node;\n};</code></pre>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：</span></li></ul>\n<p>这里我迭代器类的模板参数里面包含了3个参数：</p>\n<pre><code class=\"language-cpp\">template&lt;class T, class Ref, class Ptr&gt;</code></pre>\n<p>而后文list类的模拟实现中，我对迭代器进行了两种typedef：</p>\n<pre><code class=\"language-cpp\">typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;//普通迭代器\ntypedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;//const迭代器</code></pre>\n<p>根据这里的对应关系：<span style=\"color:#956fe7;\">Ref对应的是&amp;引用类型，Ptr对应的是*指针类型</span>，这里如果我是普通对象传过来的迭代器，生成对应的普通迭代器，如果是const对象传递过来的迭代器，会生成对应的const迭代器。</p>\n<p>这样做的原因在于<span style=\"color:#fe2c24;\">避免单独写一个支持不能修改迭代器指向结点数据的类而造成的复用性差。</span></p>\n</blockquote>\n<h3 id=\"77\">默认成员函数</h3>\n<blockquote>\n<p>这里的默认成员函数我们只需要写构造函数。</p>\n<ul><li>析构函数 -- 结点不属于迭代器，不需要迭代器释放</li><li>拷贝构造 -- 默认浅拷贝即可</li><li>赋值重载 -- 默认浅拷贝即可</li></ul>\n</blockquote>\n<h3 id=\"88\">构造函数</h3>\n<blockquote>\n<p>这里我们通过结点的指针即可完成构造。通过结点指针构造一个迭代器。</p>\n<pre><code class=\"language-cpp\">//构造函数\n__list_iterator(Node* node)//通过结点指针构造一个迭代器\n\t:_node(node)\n{}</code></pre>\n</blockquote>\n<h3 id=\"99\">* 运算符重载</h3>\n<blockquote>\n<p>*解引用的目的是为了<span style=\"color:#956fe7;\">获取结点里的_data数据</span>，因此我们直接return返回结点指向的_data即可。</p>\n<pre><code class=\"language-cpp\">//*运算符重载\nRef operator*()//结点出了作用域还在，用引用返回\n{\n\treturn _node-&gt;_data;//返回结点指向的数据\n}</code></pre>\n</blockquote>\n<h3 id=\"000\">-&gt;运算符重载</h3>\n<blockquote>\n<p>假设出现这样的场景，我链表存储的不是内置类型，而是<span style=\"color:#956fe7;\">自定义类型</span>，如下：</p>\n<pre><code class=\"language-cpp\">struct AA\n{\n\tAA(int a1 = 0, int a2 = 0)\n\t\t:_a1(a1)\n\t\t, _a2(a2)\n\t{}\n\tint _a1;\n\tint _a2;\n};\nvoid test()\n{\n\tcpp::list&lt;AA&gt; lt;\n\tlt.push_back(AA(1, 1));\n\tlt.push_back(AA(2, 2));\n\tlt.push_back(AA(3, 3));\n\tlt.push_back(AA(4, 4));\n}</code></pre>\n<p>对于内置类型和自定义类型成员的指针，其访问方式都是不同的：</p>\n<pre><code class=\"language-cpp\">int*  *it\nAA*   (*it). 或者 it-&gt;</code></pre>\n<p><span style=\"color:#fe2c24;\">而这里我们应该重载一个-&gt;运算符。以便于访问自定义类型成员的指针的数据。</span></p>\n<pre><code class=\"language-cpp\">//-&gt;运算符重载\nPtr operator-&gt;()\n{\n    return &amp;(operator*());//返回结点指针所指结点的数据的地址\n    //或者return &amp;_node-&gt;_data;\n}</code></pre>\n<p>实现了-&gt;运算符重载后，我们执行it-&gt;_a1，编译器将其转换成it.operator-&gt;()，此时获得的是结点位置的地址即AA*，而理应还有一个箭头-&gt;才能获取数据，也就是这样：it.operator-&gt;()-&gt;_a1</p>\n<ul><li><strong>总结：</strong>编译器为了<span style=\"color:#956fe7;\">可读性进行优化处理</span>，如果不优化应该是it-&gt;-&gt;_a1，优化以后，省略了一个箭头-&gt;。</li></ul>\n</blockquote>\n<h3 id=\"111\">++运算符重载</h3>\n<blockquote>\n<p>++运算符分为前置++和后置++</p>\n<ul><li><span style=\"background-color:#edf6e8;\">前置++</span></li></ul>\n<p>迭代器++的返回值还是迭代器，这里的++是为了让结点指向下一个结点的指针，注意前置++是要返回自增后的结点指针。</p>\n<pre><code class=\"language-cpp\">//前置++\nself&amp; operator++()//迭代器++的返回值还是迭代器\n{\n\t_node = _node-&gt;_next;//直接让自己指向下一个结点即可实现++\n\treturn *this;//返回自增后的结点指针\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">后置++</span></li></ul>\n<p>为了区分前置++，后置++通常要加上一个参数以便区别。此外，后置++是返回自增前的结点指针。</p>\n<pre><code class=\"language-cpp\">//后置++\nself operator++(int)//加参数以便于区分前置++\n{\n\tself tmp(*this);//拷贝构造tmp\n\t_node = _node-&gt;_next;//直接让自己指向下一个结点即可实现++\n\treturn tmp;//注意返回tmp，才是后置++\n}</code></pre>\n</blockquote>\n<h3 id=\"222\">--运算符重载</h3>\n<blockquote>\n<p>--运算符也分前置--和后置--</p>\n<ul><li><span style=\"background-color:#edf6e8;\">前置--</span></li></ul>\n<p>前置--是让此结点指向上一个结点，最后返回自减后的结点指针即可。</p>\n<pre><code class=\"language-cpp\">//前置--\nself&amp; operator--()\n{\n\t_node = _node-&gt;_prev;//让_node指向上一个结点即可实现--\n\treturn *this;\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">后置--</span></li></ul>\n<p>注意传参以区分前置--，最后返回的是自减前的结点指针即可。</p>\n<pre><code class=\"language-cpp\">//后置--\nself operator--(int)//记得传缺省值以区分前置--\n{\n\tself tmp(*this);//拷贝构造tmp\n\t_node = _node-&gt;_prev;\n\treturn tmp;\n}</code></pre>\n</blockquote>\n<h3 id=\"333\">!=运算符重载</h3>\n<blockquote>\n<p>这里比较是否不等，是两个迭代器的比较，直接返回两个结点的位置是否不同即可。</p>\n<pre><code class=\"language-cpp\">//!=运算符重载\nbool operator!=(const self&amp; it)\n{\n\treturn _node != it._node;//返回两个结点指针的位置是否不同即可\n}</code></pre>\n</blockquote>\n<h3 id=\"444\">==运算符重载</h3>\n<blockquote>\n<p>这里直接返回俩结点指针是否相同即可。</p>\n<pre><code class=\"language-cpp\">//==运算符重载\nbool operator==(const self&amp; it)\n{\n\treturn _node == it._node;//返回俩结点指针是否相同\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"555\">3.2、反向迭代器</h3>\n<blockquote>\n<p>反向迭代器是一个适配器模式（后文会将适配器）。相较于正向迭代器，反向迭代器有下面三种主要变化：</p>\n<ul><li>反向迭代器的++执行的操作是正向迭代器里的--，</li><li>反向迭代器里的--执行的操作是正向迭代器里的++</li><li>反向迭代器的*解引用和-&gt;操作指向的是前一个数据</li></ul>\n<p><span style=\"color:#0d0016;\"><strong>总代码如下：</strong></span></p>\n<pre><code class=\"language-cpp\">namespace cpp\n{\n\ttemplate&lt;class Iterator, class Ref, class Ptr&gt;\n\tstruct Reverse_iterator\n\t{\n\t\tIterator _it;\n\t\ttypedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;\n\t\t\n\t\t//构造函数\n\t\tReverse_iterator(Iterator it)\n\t\t\t:_it(it)\n\t\t{}\n\t\t//*运算符重载\n\t\tRef operator*()\n\t\t{\n\t\t\tIterator tmp = _it;\n\t\t\t//返回上一个数据\n\t\t\treturn *(--tmp);\n\t\t}\n\t\t//-&gt;运算符重载\n\t\tPtr operator-&gt;()\n\t\t{\n\t\t\t//复用operator*，返回上一个数据\n\t\t\treturn &amp;(operator*());\n\t\t}\n\t\t//++运算符重载\n\t\tSelf&amp; operator++()\n\t\t{\n\t\t\t--_it;\n\t\t\treturn *this;\n\t\t}\n\t\t//--运算符重载\n\t\tSelf&amp; operator--()\n\t\t{\n\t\t\t++_it;\n\t\t\treturn *this;\n\t\t}\n\t\t//!=运算符重载\n\t\tbool operator!=(const Self&amp; s)\n\t\t{\n\t\t\treturn _it != s._it;//返回两个结点指针的位置是否不同即可\n\t\t}\n\t\t//==运算符重载\n\t\tbool operator==(const Self&amp; s)\n\t\t{\n\t\t\treturn _it == s._it;//返回俩结点指针是否相同\n\t\t}\n\t};\n}\n</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"999\">4、list类接口实现</h3>\n<blockquote>\n<p>此接口的核心任务是为了模拟实现list类的一些<span style=\"color:#956fe7;\">核心功能</span>，好比如插入删除，迭代器等等。</p>\n</blockquote>\n<h3 id=\"0000\">基本框架</h3>\n<blockquote>\n<p>在list类中的唯一成员变量即自定义类型的变量，由先前的结点类构成的头结点：</p>\n<pre><code class=\"language-cpp\">/*3、模拟实现list的功能类*/\ntemplate&lt;class T&gt;\nclass list\n{\n\ttypedef list_node&lt;T&gt; Node;\t\npublic:\n\t//正向迭代器\n\ttypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;//普通迭代器\n\ttypedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;//const迭代器\n\n\t//反向迭代器适配支持\n\ttypedef Reverse_iterator&lt;iterator, T&amp;, T*&gt;reverse_iterator;\n\ttypedef Reverse_iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;//const反向迭代器\nprivate:\n\tNode* _head;\n};</code></pre>\n</blockquote>\n<h3 id=\"1111\">4.1、默认成员函数</h3>\n<h3 id=\"2222\">构造函数</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#edf6e8;\">无参构造：</span></li></ul>\n<p>此目的是为了对哨兵位的头结点_head进行初始化：</p>\n<pre><code class=\"language-cpp\">//构造函数\nlist()\n{\n\t_head = new Node();//申请一个头结点\n\t_head-&gt;_next = _head;//头结点的下一个结点指向自己构成循环\n\t_head-&gt;_prev = _head;//头结点的上一个结点指向自己构成循环\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">传迭代器区间构造：</span></li></ul>\n<p>先初始化，再利用循环对迭代器区间的元素挨个尾插即可。</p>\n<pre><code class=\"language-cpp\">//传迭代器区间构造\ntemplate &lt;class InputIterator&gt;\nlist(InputIterator first, InputIterator last)\n{\n\tempty_init();\n\twhile (first != last)\n\t{\n\t\tpush_back(*first);\n\t\tfirst++;\n\t}\n}</code></pre>\n</blockquote>\n<h3 id=\"3333\">析构函数</h3>\n<blockquote>\n<p>这里可以先复用clear函数把除了头结点的所有结点给删除掉，最后delete头结点即可。</p>\n<pre><code class=\"language-cpp\">//析构函数\n~list()\n{\n\tclear();\n\tdelete _head;//删去哨兵位头结点\n\t_head = nullptr;\n}</code></pre>\n</blockquote>\n<h3 id=\"4444\">拷贝构造函数</h3>\n<blockquote>\n<p>假设要用lt1拷贝构造lt2。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">传统写法：</span></li></ul>\n<p>首先复用empty_init对头结点进行初始化，接着遍历lt1的元素，在遍历的过程中尾插将lt1的元素尾插到lt2上即可。这里直接利用push_back自动开辟空间完成深拷贝。</p>\n<pre><code class=\"language-cpp\">//传统写法\nlist(const list&lt;T&gt;&amp; lt)\n{\n\t//先初始化lt2\n\tempty_init();\n\t//遍历lt1，把lt1的元素push_back到lt2里头\n\tfor (auto e : lt)\n\t{\n\t\tpush_back(e);//自动开辟新空间，完成深拷贝\n\t}\t\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">现代写法：</span></li></ul>\n<p>这里先初始化lt2自己，再把lt1引用传参传给lt，传lt的迭代器区间构造tmp，复用swap交换头结点指针即可完成深拷贝的现代写法。</p>\n<pre><code class=\"language-cpp\">//现代写法\nlist(const list&lt;T&gt;&amp; lt)\n{\n\t//初始化自己\n\tempty_init();\n\tlist&lt;T&gt;tmp(lt.begin(), lt.end());//借用迭代器区间去构造tmp\n\t//交换头结点指针即可完成深拷贝现代写法\n\tswap(tmp);\n}</code></pre>\n</blockquote>\n<h3 id=\"5555\">赋值运算符重载函数</h3>\n<blockquote>\n<ul><li>假设要把lt1赋值给lt2。</li></ul>\n<p>这里直接给出<span style=\"color:#956fe7;\">现代写法</span>。注意这里传值传参把lt1传给lt自定义类型传值传参调用拷贝构造，拷贝构造完成的是深拷贝生成了lt，复用swap函数交换lt1与lt的头结点指针指向即可，最后返回*this。</p>\n<pre><code class=\"language-cpp\">//赋值运算符重载（现代写法）\nlist&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)//套用传值传参去拷贝构造完成深拷贝\n{\n\tswap(lt);\n\treturn *this;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"6666\">4.2、迭代器相关函数</h3>\n<h3 id=\"7777\">begin和end</h3>\n<blockquote>\n<ul><li><span style=\"color:#956fe7;\">begin的作用</span>是返回第一个位置的结点的迭代器，而第一个结点就是哨兵位头结点的下一个结点，因此，直接return返回_head的_next即可。</li><li><span style=\"color:#956fe7;\">end的作用</span>就是返回最后一个有效数据的下一个位置的迭代器，而这里对于list指的就是头结点_head的位置。</li></ul>\n<p>begin和end均分为普通对象调用和const对象调用，因此要写两个版本。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">普通对象调用版</span></li></ul>\n<pre><code class=\"language-cpp\">//begin\niterator begin()//begin返回的就是第一个有效数据，即头结点的下一个结点\n{\n\treturn iterator(_head-&gt;_next);//构造了一个匿名对象，通过调用构造函数利用头结点指向的第一个结点作为参数，来返回头结点\n\t//return _head-&gt;_next;  也可以这样写\n}\n//end\niterator end()\n{\n\treturn iterator(_head);//end返回的是最后一个结点的下一个结点，就是头结点_head\n\t//return _head;  也可以这样写\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">const对象调用版</span></li></ul>\n<pre><code class=\"language-cpp\">//begin\nconst_iterator begin() const\n{\n\treturn const_iterator(_head-&gt;_next);\n\t//return _head-&gt;_next; \n}\n//end\nconst_iterator end() const\n{\n\treturn const_iterator(_head);\n\t//return _head;  也可以这样写\n}</code></pre>\n</blockquote>\n<h3 id=\"8888\">rbegin和rend</h3>\n<blockquote>\n<p>rbegin就是正向迭代器里end()的位置，rend就是正向迭代器里begin()的位置。</p>\n<p><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\f031e655db914303b61079c9a22a2623.png\" width=\"480\"/></p>\n<p>rbegin和rend同样分为普通对象调用和const对象调用：</p>\n<ul><li><span style=\"background-color:#edf6e8;\">普通对象调用：</span></li></ul>\n<pre><code class=\"language-cpp\">//rbegin()\nreverse_iterator rbegin()\n{\n\treturn reverse_iterator(end());\n}\n//rend\nreverse_iterator rend()\n{\n\treturn reverse_iterator(begin());\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">const对象调用：</span></li></ul>\n<pre><code class=\"language-cpp\">//const反向迭代器\nconst_reverse_iterator rbegin() const\n{\n\treturn const_reverse_iterator(end());\n}\nconst_reverse_iterator rend() const\n{\n\treturn const_reverse_iterator(begin());\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"9999\">4.3、增加的相关函数</h3>\n<h3 id=\"00000\">insert</h3>\n<blockquote>\n<p>实现insert首先创建一个新的结点存储插入的值，接着取出插入位置pos的结点为cur，记录cur的上一个结点位置prev，先链接prev和newnode，再链接newnode和cur即可。最后记得要返回新插入元素的迭代器位置。</p>\n<pre><code class=\"language-cpp\">//insert，插入pos位置之前\niterator insert(iterator pos, const T&amp; x)\n{\n\tNode* newnode = new Node(x);//创建新的结点\n\tNode* cur = pos._node; //迭代器pos处的结点指针\n\tNode* prev = cur-&gt;_prev;\n\t//prev newnode cur\n\t//链接prev和newnode\n\tprev-&gt;_next = newnode;\n\tnewnode-&gt;_prev = prev;\n\t//链接newnode和cur\n\tnewnode-&gt;_next = cur;\n\tcur-&gt;_prev = newnode;\n\t//返回新插入元素的迭代器位置\n\treturn iterator(newnode);\n}</code></pre>\n<ul><li><strong>补充：</strong>list的insert不存在野指针和意义变了的迭代器失效问题。</li></ul>\n</blockquote>\n<h3 id=\"11111\">push_back尾插</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#edf6e8;\">法一：</span></li></ul>\n<p>首先，创建一个新结点用来存储尾插的值，接着找到尾结点。将尾结点和新结点前后链接构成循环，再将头结点和新结点前后链接构成循环即可。</p>\n<pre><code class=\"language-cpp\">//尾插\nvoid push_back(const T&amp; x)\n{\n\tNode* tail = _head-&gt;_prev;//找尾\n\tNode* newnode = new Node(x);//创建一个新的结点\n\t//_head  tail  newnode\n\t//使tail和newnode构成循环\n\ttail-&gt;_next = newnode;\n\tnewnode-&gt;_prev = tail;\n\t//使newnode和头结点_head构成循环\n\tnewnode-&gt;_next = _head;\n\t_head-&gt;_prev = newnode;\n\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">法二：</span></li></ul>\n<p>这里也可以<span style=\"color:#956fe7;\">复用insert函数</span>，当insert中的pos位置为哨兵位头结点的位置时，实现的就是尾插，因为insert插入是在pos位置前插入，而pos位哨兵位头结点时，在其前一个位置（尾部）插入就是实现了尾插。</p>\n<pre><code class=\"language-cpp\">//尾插\nvoid push_back(const T&amp; x)\n{\n\t//法二：复用insert\n\tinsert(end(), x);\n}</code></pre>\n</blockquote>\n<h3 id=\"22222\">push_front头插</h3>\n<blockquote>\n<p>直接<span style=\"color:#956fe7;\">复用insert函数</span>，当pos位置为begin()时，获得的pos就是第一个有效结点数据，即可满足头插。</p>\n<pre><code class=\"language-cpp\">//头插\nvoid push_front(const T&amp; x)\n{\n\tinsert(begin(), x);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"33333\">4.4、删除的相关函数</h3>\n<h3 id=\"44444\">erase</h3>\n<blockquote>\n<p>erase删除的是pos位置的结点，首先取出pos位置的结点为cur，记录cur上一个结点的位置为prev，再记录cur下一个结点的位置为next，链接prev和next，最后delete释放cur的结点指针即可。最后记得返回删除元素后一个元素的迭代器位置。</p>\n<pre><code class=\"language-cpp\">//erase\niterator erase(iterator pos)\n{\n\tassert(pos != end());\n\tNode* cur = pos._node;\n\tNode* prev = cur-&gt;_prev;\n\tNode* next = cur-&gt;_next;\n\t//prev cur next\n\t//链接prev和next\n\tprev-&gt;_next = next;\n\tnext-&gt;_prev = prev;\n\t//delete要删去的结点\n\tdelete cur;\n\t//返回删除元素后一个元素的迭代器位置\n\t//return next;\n\treturn iterator(next);\n}</code></pre>\n</blockquote>\n<h3 id=\"55555\">pop_back尾删</h3>\n<blockquote>\n<p>直接<span style=\"color:#956fe7;\">复用erase</span>即可，当pos位置为--end()时，pos就是最后一个结点的位置，实现的就是尾删。</p>\n<pre><code class=\"language-cpp\">//尾删\nvoid pop_back()\n{\n\terase(--end());\n}</code></pre>\n</blockquote>\n<h3 id=\"66666\">pop_front头删</h3>\n<blockquote>\n<p>直接<span style=\"color:#956fe7;\">复用erase</span>即可，当pos位置为begin()时，pos就是第一个有效数据，实现的就是头删。</p>\n<pre><code class=\"language-cpp\">//头删\nvoid pop_front()\n{\n\terase(begin());\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"77777\">4.5、其它函数</h3>\n<h3 id=\"88888\">clear清除</h3>\n<blockquote>\n<p>clear的作用是清除除了头结点外的所有结点，这里可以复用erase并通过遍历的方式一个一个删除。</p>\n<pre><code class=\"language-cpp\">//clear清除\nvoid clear()\n{\n\t//复用erase\n\titerator it = begin();\n\twhile (it != end())\n\t{\n\t\tit = erase(it);//用it接收删除后的下一个结点的位置\n\t}\n}</code></pre>\n</blockquote>\n<h3 id=\"99999\">empty_init空初始化</h3>\n<blockquote>\n<p>此函数的作用把哨兵位的头结点开出来，再对齐初始化。该函数是库里的。</p>\n<pre><code class=\"language-cpp\">//空初始化  对头结点进行初始化\nvoid empty_init()\n{\n\t_head = new Node();\n\t_head-&gt;_next = _head;\n\t_head-&gt;_prev = _head;\n}</code></pre>\n</blockquote>\n<h3 id=\"00\">swap交换</h3>\n<blockquote>\n<p>对于链表的swap，直接交换头结点指针的指向即可完成。直接复用库函数的swap即可。</p>\n<pre><code class=\"language-cpp\">//swap交换函数\nvoid swap(list&lt;T&gt;&amp; lt)\n{\n\tstd::swap(_head, lt._head);//交换头指针\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E6%BA%90%E7%A0%81%E9%93%BE%E6%8E%A5\">5、源码链接</h3>\n<blockquote>\n<p>链接直达：<a class=\"link-info\" href=\"https://gitee.com/bit-zy/xzy--c/tree/master/cpp_stl_list/cpp_stl_list\" title=\"list的模拟实现完整版\">list的模拟实现完整版</a></p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-21 09:09:04", "summary": "目录、三个基本模板类、结点类接口实现基本框架构造函数、迭代器类接口实现、正向迭代器基本框架默认成员函数构造函数运算符重载运算符重载运算符重载运算符重载运算符重载运算符重载、反向迭代器、类接口实现基本框"}