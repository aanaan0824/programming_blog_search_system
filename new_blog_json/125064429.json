{"blogid": "125064429", "writerAge": "码龄3年", "writerBlogNum": "22", "writerCollect": "26", "writerComment": "15", "writerFan": "75", "writerGrade": "2级", "writerIntegral": "304", "writerName": "敲代码的小王", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125064429.jpg", "writerRankTotal": "74410", "writerRankWeekly": "169861", "writerThumb": "43", "writerVisitNum": "10951", "blog_read_count": "1493", "blog_time": "已于 2022-05-31 14:00:02 修改", "blog_title": "C++线程池", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_1\"></a>介绍</h2>\n<blockquote>\n<p>线程池维护者多个线程，等待着分配可并发执行的任务，可以避免在短时间创建和销毁大量线程带来时间成本。</p>\n</blockquote>\n<p>线程池的优点：</p>\n<ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul>\n<h2><a id=\"_11\"></a>原理</h2>\n<blockquote>\n<ul><li>线程池中有一个阻塞队列，用于存放上层发来的任务请求。</li><li>线程池中管理着一批线程，当任务到来时，空闲的线程从任务队列获取任务，并执行，当大量任务到来时，任务会被阻塞在队列中，等待空闲的线程来获取。当队列中没有任务时，线程将会被阻塞直到有任务到来。</li></ul>\n</blockquote>\n<p><img alt=\"image-20220531132058173\" src=\"..\\..\\static\\image\\8a7d12e875c8d4f124ccd0a4e4df82e5.png\"/></p>\n<p>其实这就是一个基于生产者消费者模型来实现的线程池，那么同样遵守三种规则，生产者和生产者之间存在互斥，处理任务的线程之间存在互斥关系，生产者和消费者之间存在同步和互斥关系。</p>\n<h2><a id=\"_20\"></a>实现</h2>\n<p>通过上面的分析可以写出基本的结构，考虑到线程池，只要存在一份实例就可以，可以设计为单例模式。</p>\n<pre><code class=\"prism language-c++\">template &lt;class T&gt;\nclass ThreadPool\n{\nprivate:\n    int _threadCount;//线程数量\n    pthread_mutex_t _mlock;\n    pthread_cond_t _cond;\n    static ThreadPool&lt;T&gt; *_instance;\n    queue&lt;T&gt; _queue;//用于存放任务的队列\npublic:\n    static ThreadPool&lt;T&gt; *GetInstance()\n    {\n        static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n        if (_instance == nullptr)\n        {\n            pthread_mutex_lock(&amp;mtx);\n            if (_instance == nullptr)\n            {\n                _instance = new ThreadPool&lt;T&gt;;\n                _instance-&gt;Init();\n            }\n            pthread_mutex_unlock(&amp;mtx);\n        }\n        return _instance;\n    }\n};\ntemplate &lt;class T&gt;\nThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::_instance = nullptr;\n</code></pre>\n<p>线程池，线程池，那么肯定要有一批线程。</p>\n<pre><code class=\"prism language-c++\">    void Init()\n    {\n        pthread_t tid;\n        for (int i = 0; i &lt; _threadCount; i++)\n        {\n            pthread_create(&amp;tid, nullptr, ？, ？);\n        }\n    }\n</code></pre>\n<p>到现在有线程了，那么这一批线程执行什么呢，怎么执行呢？</p>\n<p>线程池的作用就是减少大量频繁的创建销毁线程带来的时间成本，所以这一批线程，应该是一直执行的不能退出（有任务时执行任务，没有任务了阻塞等待任务）。</p>\n<p>线程的任务从哪里来呢，一定是从阻塞队列中获取，线程处理函数是void *(*start_routine) (void *)类型的，只有一个参数，那么也就意味着Handler函数必须是静态的（非静态成员函数有隐含的this指针），那么静态的函数也就无法访问类的非静态成员，也就无法获取到任务了，此时在就只能通过对象来调用了，就需要将ThreadPool的对象作为参数传给Handler。</p>\n<pre><code class=\"prism language-c++\">    static void *Handler(void *arg)\n    {\n        ThreadPool&lt;T&gt; *obj = (ThreadPool&lt;T&gt; *)arg;\n        pthread_detach(pthread_self());\n        while (true)\n        {\n            obj-&gt;Lock();\n            //先获取任务，没有任务挂起\n            while (obj-&gt;Empty())\n            {\n                pthread_cond_wait(&amp;obj-&gt;_cond, &amp;obj-&gt;_mlock);\n            }\n            T t;\n            obj-&gt;Pop(&amp;t);\n            obj-&gt;Unlock();\n            //处理任务\n            t()//仿函数\n        }\n    }\n</code></pre>\n<p>线程池对外应该提供一个Push任务结构，向阻塞队列中添加任务。</p>\n<pre><code class=\"prism language-c++\">    void Push(const T &amp;t)\n    {\n        Lock();\n        _queue.push(t);\n        Unlock();\n        //此时可能所有的线程已经全部休眠，需要唤醒一下\n        pthread_cond_signal(&amp;_cond);\n    }\n</code></pre>\n<p>线程获取任务，通过Pop从队列中获取，在获取任务时不需要加锁，因为此时线程处于临界区内。</p>\n<pre><code class=\"prism language-c++\">    void Pop(T *t)\n    {\n        *t = _queue.front();\n        _queue.pop();\n    }\n</code></pre>\n<p>到这里就完成了线程池的主要内容，<a href=\"https://github.com/2856672598/2022/blob/main/ThreadPool/\">详细代码</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-31 14:00:02", "summary": "介绍线程池维护者多个线程，等待着分配可并发执行的任务，可以避免在短时间创建和销毁大量线程带来时间成本。线程池的优点：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。当"}