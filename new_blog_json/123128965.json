{"blogid": "123128965", "writerAge": "码龄5年", "writerBlogNum": "14", "writerCollect": "27", "writerComment": "1", "writerFan": "4", "writerGrade": "2级", "writerIntegral": "282", "writerName": "清淡的咸菜", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123128965.jpg", "writerRankTotal": "141658", "writerRankWeekly": "194613", "writerThumb": "12", "writerVisitNum": "14795", "blog_read_count": "855", "blog_time": "已于 2022-02-25 11:45:01 修改", "blog_title": "Rust Cargo toml描述文件配置详细参考", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"Cargotoml_0\"></a>Cargo的toml描述文件配置字段详细参考</h2>\n<h4><a id=\"package__1\"></a>[package] 节点</h4>\n<pre><code class=\"prism language-toml\">[package]\n# 软件包名称，如果需要在别的地方引用，请使用它。\nname = \"hello_world\"\n\n# 当前版本号\nversion = \"0.1.0\"\n\n# 软件作者\nauthors = [\"you@mail.com\"]\n\n# 自定义构建工作流程\n#这时，自定义的构建流程可以使用rust语言，写在\"build.rs\"文件中。\nbuild = \"build.rs\"\n\n# 显式声明软件包文件夹内哪些文件被排除在项目的构建流程之外，\n# 哪些文件包含在项目的构建流程中\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n\n# 当软件包在向公共仓库发布时出现错误时，使能此字段可以阻止此错误。\npublish = false\n\n# 关于软件包的一个简短介绍。\ndescription = \"...\"\n\n# 下面这些字段标明了软件包仓库的更多信息\ndocumentation = \"...\"\nhomepage = \"...\"\nrepository = \"...\"\n\n# 顾名思义，此字段指向的文件就是传说中的ReadMe，\n# 并且，此文件的内容最终会保存在注册表数据库中。\nreadme = \"...\"\n\n# 用于分类和检索的关键词。\nkeywords = [\"...\", \"...\"]\n\n# 软件包的许可证，必须是cargo仓库已列出的已知的标准许可证。\nlicense = \"...\"\n\n# 软件包的非标许可证书对应的文件路径。\nlicense-file = \"...\"\n</code></pre>\n<h4><a id=\"_47\"></a>依赖的详细配置</h4>\n<pre><code class=\"prism language-toml\">[dependencies]\nhammer = \"0.5.0\"\ncolor = \"&gt; 0.6.0, &lt; 0.8.0\"\n</code></pre>\n<p><strong>与平台相关的依赖格式不变，不同的是需要定义在[target]字段下。例如：</strong></p>\n<pre><code class=\"prism language-toml\"># 注意，此处的cfg可以使用not、any、all等操作符任意组合键值对。\n# 并且此用法仅支持cargo 0.9.0（rust 1.8.0）以上版本。\n# 如果是windows平台，则需要此依赖。\n[target.'cfg(windows)'.dependencies]\nwinhttp = \"0.4.0\"\n\n[target.'cfg(unix)'.dependencies]\nopenssl = \"1.0.1\"\n\n# 如果是32位平台，则需要此依赖。\n[target.'cfg(target_pointer_width = \"32\")'.dependencies]\nnative = { path = \"native/i686\" }\n\n[target.'cfg(target_pointer_width = \"64\")'.dependencies]\nnative = { path = \"native/i686\" }\n\n# 另一种写法就是列出平台的全称描述\n[target.x86_64-pc-windows-gnu.dependencies]\nwinhttp = \"0.4.0\"\n[target.i686-unknown-linux-gnu.dependencies]\nopenssl = \"1.0.1\"\n\n# 如果使用自定义平台，请将自定义平台文件的完整路径用双引号包含\n[target.\"x86_64/windows.json\".dependencies]\nwinhttp = \"0.4.0\"\n[target.\"i686/linux.json\".dependencies]\nopenssl = \"1.0.1\"\nnative = { path = \"native/i686\" }\nopenssl = \"1.0.1\"\nnative = { path = \"native/x86_64\" }\n\n# [dev-dependencies]段落的格式等同于[dependencies]段落，\n# 不同之处在于，[dependencies]段落声明的依赖用于构建软件包，\n# 而[dev-dependencies]段落声明的依赖仅用于构建测试和性能评估。\n# 此外，[dev-dependencies]段落声明的依赖不会传递给其他依赖本软件包的项目\n[dev-dependencies]\niron = \"0.2\"\n</code></pre>\n<h4><a id=\"_95\"></a>自定义编译器调用方式模板详细参数</h4>\n<pre><code class=\"prism language-toml\"># 开发模板, 对应`cargo build`命令\n[profile.dev]\nopt-level = 0  # 控制编译器的 --opt-level 参数，也就是优化参数\ndebug = true   # 控制编译器是否开启 `-g` 参数\nrpath = false  # 控制编译器的 `-C rpath` 参数\nlto = false    # 控制`-C lto` 参数，此参数影响可执行文件和静态库的生成，\ndebug-assertions = true  # 控制调试断言是否开启\ncodegen-units = 1 # 控制编译器的 `-C codegen-units` 参数。注意，当`lto = true`时，此字段值被忽略\n\n# 发布模板, 对应`cargo build --release`命令\n[profile.release]\nopt-level = 3\ndebug = false\nrpath = false\nlto = false\ndebug-assertions = false\ncodegen-units = 1\n\n# 测试模板，对应`cargo test`命令\n[profile.test]\nopt-level = 0\ndebug = true\nrpath = false\nlto = false\ndebug-assertions = true\ncodegen-units = 1\n\n# 性能评估模板，对应`cargo bench`命令\n[profile.bench]\nopt-level = 3\ndebug = false\nrpath = false\nlto = false\ndebug-assertions = false\ncodegen-units = 1\n\n# 文档模板，对应`cargo doc`命令\n[profile.doc]\nopt-level = 0\ndebug = true\nrpath = false\nlto = false\ndebug-assertions = true\ncodegen-units = 1\n</code></pre>\n<h4><a id=\"features_143\"></a>[features]段落</h4>\n<p><strong>[features]段落中的字段被用于条件编译选项或者是可选依赖。例如：</strong></p>\n<pre><code class=\"prism language-toml\">[package]\nname = \"awesome\"\n\n[features]\n# 此字段设置了可选依赖的默认选择列表，\n# 注意这里的\"session\"并非一个软件包名称，\n# 而是另一个featrue字段session\ndefault = [\"jquery\", \"uglifier\", \"session\"]\n\n# 类似这样的值为空的feature一般用于条件编译，\n# 类似于`#[cfg(feature = \"go-faster\")]`。\ngo-faster = []\n\n# 此feature依赖于bcrypt软件包，\n# 这样封装的好处是未来可以对secure-password此feature增加可选项目。\nsecure-password = [\"bcrypt\"]\n\n# 此处的session字段导入了cookie软件包中的feature段落中的session字段\nsession = [\"cookie/session\"]\n\n[dependencies]\n# 必要的依赖\ncookie = \"1.2.0\"\noauth = \"1.1.0\"\nroute-recognizer = \"=2.1.0\"\n\n# 可选依赖\njquery = { version = \"1.0.2\", optional = true }\nuglifier = { version = \"1.5.3\", optional = true }\nbcrypt = { version = \"*\", optional = true }\ncivet = { version = \"*\", optional = true }\n</code></pre>\n<p><strong>如果其他软件包要依赖使用上述awesome软件包，可以在其描述文件中这样写：</strong></p>\n<pre><code class=\"prism language-toml\">[dependencies.awesome]\nversion = \"1.3.5\"\ndefault-features = false # 禁用awesome 的默认features\nfeatures = [\"secure-password\", \"civet\"] # 使用此处列举的各项features\n</code></pre>\n<p>使用features时需要遵循以下规则：</p>\n<ul><li>feature名称在本描述文件中不能与出现的软件包名称冲突</li><li>除了default feature，其他所有的features均是可选的</li><li>features不能相互循环包含</li><li>开发依赖包不能包含在内</li><li>features组只能依赖于可选软件包<br/> features的一个重要用途就是，当开发者需要对软件包进行最终的发布时，在进行构建时可以声明暴露给终端用户的features，这可以通过下述命令实现：</li></ul>\n<pre><code class=\"prism language-shell\">$ cargo build --release --features <span class=\"token string\">\"shumway pdf\"</span>\n</code></pre>\n<h4><a id=\"_198\"></a>关于测试</h4>\n<p>当运行cargo test命令时，cargo将会按做以下事情：</p>\n<ul><li>编译并运行软件包源代码中被#[cfg(test)] 所标志的单元测试</li><li>编译并运行文档测试</li><li>编译并运行集成测试</li><li>编译examples</li></ul>\n<p>配置构建目标<br/> 所有的诸如[[bin]], [lib], [[bench]], [[test]]以及 [[example]]等字段，均提供了类似的配置，以说明构建目标应该怎样被构建。例如（下述例子中[lib]段落中各字段值均为默认值）：</p>\n<pre><code class=\"prism language-toml\">[lib]\n# 库名称，默认与项目名称相同\nname = \"foo\"\n\n# 此选项仅用于[lib]段落，其决定构建目标的构建方式，\n# 可以取dylib, rlib, staticlib 三种值之一，表示生成动态库、r库或者静态库。\ncrate-type = [\"dylib\"]\n\n# path字段声明了此构建目标相对于cargo.toml文件的相对路径\npath = \"src/lib.rs\"\n\n# 单元测试开关选项\ntest = true\n\n# 文档测试开关选项\ndoctest = true\n\n# 性能评估开关选项\nbench = true\n\n# 文档生成开关选项\ndoc = true\n\n# 是否构建为编译器插件的开关选项\nplugin = false\n\n# 如果设置为false，`cargo test`将会忽略传递给rustc的--test参数。\nharness = true\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-02-25 11:45:01", "summary": "的描述文件配置字段详细参考节点软件包名称，如果需要在别的地方引用，请使用它。当前版本号软件作者自定义构建工作流程这时，自定义的构建流程可以使用语言，写在文件中。显式声明软件包文件夹内哪些文件被排除在项"}