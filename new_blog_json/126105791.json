{"blogid": "126105791", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "4592", "writerComment": "4393", "writerFan": "6378", "writerGrade": "7级", "writerIntegral": "13415", "writerName": "@每天都要敲代码", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126105791.jpg", "writerRankTotal": "799", "writerRankWeekly": "90", "writerThumb": "4873", "writerVisitNum": "81120", "blog_read_count": "412", "blog_time": "于 2022-08-31 20:23:16 发布", "blog_title": "JavaSE | 反射机制(反射Class)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅作者简介：一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href=\"https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421\" title=\"@每天都要敲代码的个人主页\">@每天都要敲代码的个人主页</a></p>\n<p>🔥系列专栏：<a href=\"https://blog.csdn.net/m0_61933976/category_11820121.html?spm=1001.2014.3001.5482\" title=\"JavaSE从入门到精通\">JavaSE从入门到精通</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0\">一：反射机制概述</a></p>\n<p id=\"%E4%BA%8C%EF%BC%9A%E5%8F%8D%E5%B0%84Class-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%EF%BC%9A%E5%8F%8D%E5%B0%84Class\">二：反射Class</a></p>\n<p id=\"1.%20%E8%8E%B7%E5%8F%96Class%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20%E8%8E%B7%E5%8F%96Class%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%C2%A0\">1. 获取Class的三种方式 </a></p>\n<p id=\"2.%20%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B%E5%8C%96(%E5%88%9B%E5%BB%BA)%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B%E5%8C%96%28%E5%88%9B%E5%BB%BA%29%E5%AF%B9%E8%B1%A1\">2. 通过反射实例化(创建)对象</a></p>\n<p id=\"3.%20%E9%80%9A%E8%BF%87%E8%AF%BB%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20%E9%80%9A%E8%BF%87%E8%AF%BB%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1\">3. 通过读配置属性文件实例化对象</a></p>\n<p id=\"4.%20%E5%8F%AA%E8%AE%A9%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%BF%E7%94%A8%C2%A0Class.forName-toc\" style=\"margin-left:40px;\"><a href=\"#4.%20%E5%8F%AA%E8%AE%A9%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%BF%E7%94%A8%C2%A0Class.forName\">4. 只让静态代码块执行</a></p>\n<p id=\"5.%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84-toc\" style=\"margin-left:40px;\"><a href=\"#5.%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\">5. 获取类路径下文件的绝对路径</a></p>\n<p id=\"6.%20%E6%89%A9%E5%B1%95%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#6.%20%E6%89%A9%E5%B1%95%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0\">6. 扩展：类加载器概述</a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BB%93\">小总结</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0\">一：<strong>反射机制概述</strong></h1>\n<blockquote>\n<p>1、反射机制有什么用？<br/>         通过java语言中的<span style=\"color:#fe2c24;\">反射机制可以操作字节码文件</span>。<br/>         优点类似于黑客。（可以读和修改字节码文件。）<br/>         通过反射机制可以操作代码片段。（class文件。）   <br/> 2、反射机制的相关类在哪个包下？<br/>         <span style=\"color:#fe2c24;\">java.lang.reflect.*</span>;   <br/> 3、反射机制相关的重要的类有哪些？<br/>    <span style=\"color:#fe2c24;\">     java.lang.Class：</span><span style=\"color:#0d0016;\">代表整个字节码，代表一个类型，代表</span><span style=\"color:#fe2c24;\">整个类</span><span style=\"color:#0d0016;\">。</span><br/><span style=\"color:#fe2c24;\">        java.lang.reflect.Method：</span><span style=\"color:#0d0016;\">代表字节码中的方法字节码。代表类中的</span><span style=\"color:#fe2c24;\">方法</span><span style=\"color:#0d0016;\">。</span><br/><span style=\"color:#fe2c24;\">        java.lang.reflect.Constructor：</span><span style=\"color:#0d0016;\">代表字节码中的构造方法字节码。代表类中的</span><span style=\"color:#fe2c24;\">构造方法<br/>         java.lang.reflect.Field：</span><span style=\"color:#0d0016;\">代表字节码中的属性字节码。代表类中的</span><span style=\"color:#fe2c24;\">成员变量</span><span style=\"color:#0d0016;\">（静态变量</span>+实例变量）。     </p>\n</blockquote>\n<pre><code class=\"language-java\">   // java.lang.Class：（整个是一个class）\n            public class User{\n                // Field （成员变量）\n                int no;\n\n                // Constructor（构造方法）\n                public User(){\n                \n                }\n                public User(int no){\n                    this.no = no;\n                }\n \n\n                // Method（方法）\n                public void setNo(int no){\n                    this.no = no;\n                }\n                public int getNo(){\n                    return no;\n                }\n            }</code></pre>\n<h3></h3>\n<h1 id=\"%E4%BA%8C%EF%BC%9A%E5%8F%8D%E5%B0%84Class\">二：反射Class</h1>\n<h2 id=\"1.%20%E8%8E%B7%E5%8F%96Class%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%C2%A0\">1. 获取Class的三种方式 </h2>\n<blockquote>\n<p>要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？<br/><strong>三种方式：</strong><br/>         <span style=\"color:#0d0016;\">第一种：</span><span style=\"color:#fe2c24;\">Class c = Class.forName(\"完整类名带包名\")</span>;<br/>             1、静态方法<br/>             2、方法的参数是一个字符串。<br/>             3、字符串需要的是一个完整类名。<br/>             4、完整类名必须带有包名。java.lang包也不能省略。<br/>         <span style=\"color:#0d0016;\">第二种：</span><span style=\"color:#fe2c24;\">Class c = 对象（引用）.getClass();</span><br/>        <span style=\"color:#0d0016;\"> 第三种：</span><span style=\"color:#fe2c24;\">Class c = 任何类型.class;</span></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\nimport java.util.Date;\n\npublic class ReflectTest01 {\n    public static void main(String[] args) {\n\n        // 第一种方式：Class.forName()\n        Class c1 = null;\n        Class c2 = null;\n        try {\n            // c1代表String.class文件，或者说c1代表String类型。\n            c1 = Class.forName(\"java.lang.String\"); \n            // c2代表Date类型\n            c2 = Class.forName(\"java.util.Date\"); \n            // c3代表Integer类型\n            Class c3 = Class.forName(\"java.lang.Integer\"); \n            // c4代表System类型\n            Class c4 = Class.forName(\"java.lang.System\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        // 第二种方式：对象.getClass()\n        // java中任何一个对象都有一个方法：getClass()\n        String s = \"abc\";\n        // x代表String.class字节码文件；x代表String类型\n        Class x = s.getClass(); \n        // true（==判断的是对象的内存地址）\n        System.out.println(x == c1); \n\n        Date time = new Date();\n        Class y = time.getClass();\n        // true (c2和y两个变量中保存的内存地址都是一样的，都指向方法区中的字节码文件)\n        System.out.println(c2 == y); \n\n        // 第三种方式，java语言中任何一种类型，包括基本数据类型，它都有.class属性。\n        // z代表String类型\n        Class z = String.class;\n        // k代表Date类型 \n        Class k = Date.class; \n        // f代表int类型\n        Class f = int.class; \n        // e代表double类型\n        Class e = double.class; \n        System.out.println(c1 == x &amp;&amp; x == z); // true\n\n    }\n\n}\n</code></pre>\n<h3></h3>\n<h2 id=\"2.%20%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B%E5%8C%96(%E5%88%9B%E5%BB%BA)%E5%AF%B9%E8%B1%A1\">2. 通过反射实例化(创建)对象</h2>\n<blockquote>\n<p>（1）<span style=\"color:#fe2c24;\">获取到Class，通过Class的newInstance()方法来实例化（创建）对象。</span><br/> （2）newInstance()方法内部实际上调用了无参数构造方法，必须保证无参构造存在才可以；所以一旦我们写上了有参构造方法，无参构造方法也要写上！ 如果有有参构造方法，而没有写无参构造方法会出现异java.lang.InstantiationException 实例化异常</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\nimport com.bjpowernode.java.bean.User;\n\npublic class ReflectTest02 {\n    public static void main(String[] args) {\n\n        // 第一种方法创建对象：不使用反射机制\n        User user = new User();\n        System.out.println(user);\n\n        // 第二种方法创建对象：以反射机制的方式创建对象。（这种方式比较灵活）\n        try {\n            // 通过反射机制，获取Class，通过Class来实例化（创建）对象\n            Class c = Class.forName(\"com.bjpowernode.java.bean.User\");\n            Object obj = c.newInstance();\n           \n            System.out.println(obj);\n            /*\n            执行结果：\n                无参数构造方法\n                com.bjpowernode.java.bean.User@4554617c\n            */\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package com.bjpowernode.java.bean;\n\npublic class User {\n    // 无参构造（不写也行，默认会有）\n    public User() {\n        System.out.println(\"无参数构造方法\");\n    }\n\n    // 有参构造写了，无参构造必须写；不然调用newInstance()会出现异常\n    public User(String s) {\n        System.out.println(\"无参数构造方法\");\n    }\n\n}\n</code></pre>\n<h2></h2>\n<h2 id=\"3.%20%E9%80%9A%E8%BF%87%E8%AF%BB%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1\"><strong>3. 通过读配置属性文件实例化对象</strong></h2>\n<blockquote>\n<p>（1）通过读配置属性文件实例化对象，java代码写一遍，再不改变java源代码的基础之上，只改变配置文件，可以做到不同对象的实例化；非常之灵活。（符合OCP开闭原则：对扩展开放，对修改关闭）</p>\n<p>（2）配置文件写好，命名为xxx.properties，然后使用IO流+Properties</p>\n<p>（3）后期我们要学习的是高级框架，而工作过程中，也都是使用高级框架，<br/>     包括： ssh ssm<br/>     Spring SpringMVC MyBatis<br/>     Spring Struts Hibernate<br/>     ...<br/>     这些高级框架底层实现原理：都采用了反射机制。所以反射机制很重要的；学会了反射机制有利于我们理解剖析框架底层的源代码。</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\nimport java.io.FileReader;\nimport java.util.Properties;\n\npublic class ReflectTest03 {\n    public static void main(String[] args) throws Exception {\n        // IO流+Properties集合\n        // 通过IO流读classinfo.properties配置文件\n        // 配置文件内容是：className=com.bjpowernode.java.bean.User\n        FileReader reader = new FileReader(\"day08\\\\classinfo.properties\");\n        // 创建属性类对象Map，properties的key和value都是String\n        Properties pro = new Properties();\n        // 加载\n        pro.load(reader);\n        // reader关闭流\n        reader.close();\n        // 通过key获取value\n        String s = pro.getProperty(\"className\");\n        //System.out.println(s); // com.bjpowernode.java.bean.User\n\n        // 最后在通过反射机制实例化对象\n        Class c = Class.forName(s);\n        Object obj = c.newInstance();\n        System.out.println(obj);\n        /*\n        执行结果：\n            无参数构造方法\n            com.bjpowernode.java.bean.User@4554617c\n        */\n\n        // 怎么体现灵活性？\n        // 这里的代码我们都不改变，只改变classinfo.properties配置文件\n        // 例如改成：className=java.util.Date\n        // 此时执行的结果就变了：Wed Aug 03 15:40:02 CST 2022\n\n    }\n}\n</code></pre>\n<p></p>\n<h2 id=\"4.%20%E5%8F%AA%E8%AE%A9%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%BF%E7%94%A8%C2%A0Class.forName\"><strong>4. 只让静态代码块执行</strong></h2>\n<blockquote>\n<p><strong>Class.forName()执行发生了什么</strong></p>\n<p>（1）Class.forName(\"完整类名\");这个方法的执行会导致类加载，<span style=\"color:#fe2c24;\">类加载时，静态代码块执行</span>。如果你只是希望一个类的静态代码块执行，其它代码一律不执行，使用Class.forName()</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\npublic class ReflectTest04 {\n    public static void main(String[] args) {\n        try {\n            // Class.forName()这个方法的执行会导致：类加载。\n            // 类加载，静态代码块就会执行\n            Class.forName(\"com.bjpowernode.java.reflect.MyClass\");\n            // 执行结果：MyClass类的静态代码块执行了！\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass MyClass{\n    // 静态代码块在类加载时执行，并且只执行一次\n    static{\n        System.out.println(\"MyClass类的静态代码块执行了！\");\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"5.%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\"><strong>5. 获取类路径下文件的绝对路径</strong></h2>\n<blockquote>\n<p>（1）怎么获取一个文件的绝对路径。以下讲解的这种方式是通用的。但前提是：文件需要在类路径(src)下才能用这种方式。</p>\n<p>（2） 例如：</p>\n<pre><code class=\"language-java\"> String path = Thread.currentThread().getContextClassLoader()\n               .getResource(\"User.properties\").getPath();</code></pre>\n<p>        Thread.currentThread() 当前线程对象<br/>         getContextClassLoader() 是线程对象的方法，可以获取到当前线程的类加载器对象。<br/>         getResource() 【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源。</p>\n<p>        getPath() 获取路径</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\nimport java.io.FileReader;\n\n// 研究一下文件路径的问题\npublic class AboutPath {\n    public static void main(String[] args) throws Exception {\n        // 我们写成下面这种路径形式，只能在IDEA工具中才能找到，不够通用！\n        FileReader reader = new FileReader(\"day08\\\\classinfo.properties\");\n\n        // 通用的一种方式：\n        // 注意：使用以下通用方式的前提是：这个文件必须在类路径下。\n        // 什么类路径下？方式在src下的都是类路径下。【src是类的根路径】\n\n        //Thread.currentThread() 当前线程对象\n        //getContextClassLoader() 是线程对象的方法，可以获取到当前线程的类加载器对象。\n        //getResource() 【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源。\n        // 写成下面这种形式，放到Linux环境下也是没问题的\n        // 假设classinfo.properties刚好在src下\n        String path = Thread.currentThread().getContextClassLoader()\n                .getResource(\"classinfo.properties\").getPath();\n        // 拿到绝对路径\n        System.out.println(path); // C:/Users/86177/IdeaProjects/JavaSe1/out/production/day08/classinfo.properties\n\n        // 假设有一个example文件没有直接在src下面，而是bean下面（com/bjpowernode/java/bean/example）\n        String path2 = Thread.currentThread().getContextClassLoader()\n                .getResource(\"com/bjpowernode/java/bean/example\").getPath();\n        // 获取绝对路径\n        System.out.println(path2); // C:/Users/86177/IdeaProjects/JavaSe1/out/production/day08/com/bjpowernode/java/bean/example\n    }\n}\n</code></pre>\n<h2></h2>\n<blockquote>\n<p>这样我们就可以修改原来的代码，得到更加通用的方式！</p>\n<p>      <strong>  第一种：先通过相对路径</strong>（这里的相对路径前提：一定是在src下的才可以；在模块下的就不行）获取绝对路径，然后创建流：</p>\n<pre><code class=\"language-java\">// 1.得到相对路径\nString path =Thread.currentThread().getContextClassLoader().getResource(\"相对路径\").getPath(); \n// 2.创建流\n FileReader reader = new FileReader(path);</code></pre>\n<p>       <strong> 第二种方式：直接返回一个流（InputStream）</strong></p>\n<pre><code class=\"language-java\">InputStream reader = Thread.currentThread().getContextClassLoader()\n                .getResourceAsStream(\"com/bjpowernode/java/bean/example\");</code></pre>\n<p>注意：这两种方式还是还是使用IO流+properties集合的方式，使用绝对路径而不是相对路径更加的通用：</p>\n<p>                第一种方式先得到绝对路径，返回String，然后在创建IO流</p>\n<p>                第二种方式直接返回的就是一个流InputStream</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\nimport java.io.FileReader;\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class ReflectTest05 {\n    public static void main(String[] args) throws Exception {\n         // 第一种方式：先拿到绝对路径，然后创建流\n          //还是以example为例（className=java.util.Date），先拿到绝对路径\n        String path = Thread.currentThread().getContextClassLoader()\n                .getResource(\"com/bjpowernode/java/bean/example\").getPath();\n        FileReader reader = new FileReader(path);\n      \n        // 第二种方式：直接返回一个流（InputStream）\n        InputStream reader = Thread.currentThread().getContextClassLoader()\n                .getResourceAsStream(\"com/bjpowernode/java/bean/example\");\n\n        // 创建Map集合对象\n        Properties pro = new Properties();\n        pro.load(reader);\n        reader.close();\n        // 通过key获取value\n        String className = pro.getProperty(\"className\");\n\n        // 创建对象\n        Class c = Class.forName(className);\n        Object obj= c.newInstance();\n        System.out.println(obj); // Wed Aug 03 17:00:36 CST 2022\n\n    }\n}\n</code></pre>\n<blockquote>\n<p><strong> 第三种方式：利用资源绑定器（常用）</strong></p>\n<p>（1）前两种方式都需要创建一个流，而是用资源绑定器就不需要了！</p>\n<p>（2）java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容。<br/> （3）使用这种方式的时候，属性配置文件xxx.properties必须放到类路径下。<br/> 资源绑定器，只能绑定xxx.properties文件。并且这个文件必须在类路径下。文件扩展名也必须是properties<br/> （4）并且在写路径的时候，路径后面的扩展名.properties不能写。</p>\n<pre><code class=\"language-java\">ResourceBundle boudle = ResourceBundle.getBundle(\"classinfo\");\nString className = boudle.getString(\"className\");\n</code></pre>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.reflect;\n\nimport java.util.ResourceBundle;\n\npublic class ResourceBundleTest {\n    public static void main(String[] args) throws Exception {\n        // 例如：classinfo.properties（className=java.util.Date）\n        ResourceBundle boudle = ResourceBundle.getBundle(\"classinfo\");\n        // 通过key获取value\n        String className = boudle.getString(\"className\");\n        //System.out.println(className); // java.util.Date\n        // 实例化对象\n        Class c = Class.forName(className);\n        Object obj = c.newInstance();\n        System.out.println(obj); // Wed Aug 03 19:31:20 CST 2022\n\n    }\n}\n</code></pre>\n<p></p>\n<h2 id=\"6.%20%E6%89%A9%E5%B1%95%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0\"><strong>6. 扩展：类加载器概述</strong></h2>\n<blockquote>\n<p><strong>关于JDK中自带的类加载器：（不需要掌握）</strong><br/> （1）什么是类加载器？<br/>         专门负责加载类的命令/工具；ClassLoader<br/> （2）<strong>JDK中自带了3个类加载器</strong><br/>         <span style=\"color:#fe2c24;\">启动类加载器：rt.jar<br/>         扩展类加载器：ext/*.jar<br/>         应用类加载器：classpath</span><br/> （3）假设有这样一段代码：String s = \"abc\"; <br/>         代码在开始执行之前，会将所需要类全部加载到JVM当中。通过类加载器加载，看到以上代码类加载器会找String.class文件，找到就加载，那么是怎么进行加载的呢？</p>\n<p>       <span style=\"color:#fe2c24;\">首先通过“启动类加载器”加载</span><br/>            注意：启动类加载器专门加载：C:\\Program Files\\Java\\jdk1.8.0_101\\jre\\lib\\rt.jar<br/>            <span style=\"color:#0d0016;\">rt.jar中都是JDK最核心的类库</span>。<br/>     <span style=\"color:#fe2c24;\">  如果通过“启动类加载器”加载不到的时候，然后会通过\"扩展类加载器\"加载</span><br/>            注意：扩展类加载器专门加载：C:\\Program Files\\Java\\jdk1.8.0_101\\jre\\lib\\ext\\*.jar<br/>       <span style=\"color:#fe2c24;\">如果“扩展类加载器”没有加载到，那么会通过“应用类加载器”加载</span><br/>             注意：应用类加载器专门加载：classpath中的类。<br/> （4）java中为了保证类加载的安全，使用了<strong>双亲委派机制</strong>。<br/>         优先从启动类加载器中加载，这个称为“父”，“父”无法加载到，再从扩展类加载器中加载，这个称为“母”。</p>\n<p>        双亲委派。如果都加载不到，才会考虑从应用类加载器中加载。直到加载到为止。</p>\n</blockquote>\n<h2 id=\"%E6%80%BB%E7%BB%93\"><strong>小总结</strong></h2>\n<blockquote>\n<p>1、回顾反射机制</p>\n<p>（1）什么是反射机制？反射机制有什么用？<br/>         <span style=\"color:#fe2c24;\">反射机制：可以操作字节码文件</span><br/>         <span style=\"color:#fe2c24;\">作用：可以让程序更加灵活</span></p>\n<p>（2）反射机制相关的类在哪个包下？<br/>         <span style=\"color:#fe2c24;\">java.lang.reflect.*;</span></p>\n<p>（3）反射机制相关的主要的类？<br/>         java.lang.Class<br/>         java.lang.reflect.Method;<br/>         java.lang.reflect.Constructor;<br/>         java.lang.reflect.Field;</p>\n<p>（4）在java中获取Class的三种方式？<br/>         第一种：     <br/>             Class c = Class.forName(\"完整类名\");<br/>         第二种：<br/>             Class c = 对象.getClass();<br/>         第三种：<br/>             Class c = int.class;</p>\n<p>（5）获取了Class之后，可以调用无参数构造方法来实例化对象      </p>\n<pre><code class=\"language-java\">//c代表的就是日期Date类型\nClass c = Class.forName(\"java.util.Date\");\n//实例化一个Date日期类型的对象\nObject obj = c.newInstance();</code></pre>\n<p>        一定要注意：</p>\n<p>            newInstance()底层调用的是该类型的无参数构造方法。<br/>             如果没有这个无参数构造方法会出现\"实例化\"异常。<br/> （6）如果你只想让一个类的“静态代码块”执行的话，你可以怎么做？<br/>         Class.forName(\"该类的类名\");这样类就加载，类加载的时候，静态代码块执行！<br/> （7）关于路径问题？    </p>\n<pre><code class=\"language-java\">String path = Thread.currentThread().getContextClassLoader()\n    .getResource(\"写相对路径，但是这个相对路径从src出发开始找\").getPath();    \n\nString path = Thread.currentThread().getContextClassLoader()\n    .getResource(\"abc\").getPath();    //必须保证src下有abc文件。\n\nString path = Thread.currentThread().getContextClassLoader()\n    .getResource(\"a/db\").getPath();    //必须保证src下有a目录，a目录下有db文件。\n        </code></pre>\n<p>        这种方式是为了获取一个文件的绝对路径。（通用方式，不会受到环境移植的影响）<br/> 但是该文件要求放在类路径下，换句话说：也就是放到src下面。src下是类的根路径。      </p>\n<pre><code class=\"language-java\">// 直接以流的形式返回：\nInputStream in = Thread.currentThread().getContextClassLoader()\n     .getResourceAsStream(\"com/bjpowernode/test.properties\");</code></pre>\n<p>（8）IO流 + Properties集合，怎么快速绑定属性资源文件？</p>\n<p>  </p>\n<pre><code class=\"language-java\">// 第一：第一这个文件必须在类路径(src)下\n// 第二：这个文件必须是以.properties结尾，但是写的时候不能带上.properties。\nResourceBundle bundle = ResourceBundle.getBundle(\"com/bjpowernode/test\");\nString value = bundle.getString(key);</code></pre>\n</blockquote>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</h1>\n<blockquote>\n<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！<br/> 💬刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"511\" src=\"..\\..\\static\\image\\184068dc41e94efbb14e555f972eaa17.png\" width=\"1200\"/></p>\n<p></p>\n<h1 id=\"2.%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7\"></h1>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-31 20:23:16", "summary": "作者简介：一位材料转码农的选手，希望一起努力，一起进步！个人主页：每天都要敲代码的个人主页每天都要敲代码的个人主页系列专栏：从入门到精通从入门到精通推荐一款模拟面试、刷题神器，从基础到大厂面试题点击跳"}