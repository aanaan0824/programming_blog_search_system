{"blogid": "126569341", "writerAge": "码龄3年", "writerBlogNum": "235", "writerCollect": "3676", "writerComment": "3519", "writerFan": "30153", "writerGrade": "7级", "writerIntegral": "10271", "writerName": "秃秃爱健身", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126569341.jpg", "writerRankTotal": "1231", "writerRankWeekly": "22", "writerThumb": "3026", "writerVisitNum": "267772", "blog_read_count": "1014", "blog_time": "于 2022-08-30 07:53:48 发布", "blog_title": "【微服务36】分布式事务Seata源码解析四：图解Seata Client 如何与Seata Server建立连接、通信【云原生】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_1\">一、前言</a></li><li><a href=\"#_17\">二、概述</a></li><li><a href=\"#TM_32\">三、TM事务管理器初始化</a></li><li><ul><li><a href=\"#1TM_40\">1、TM初始化流程图</a></li><li><a href=\"#2TM_44\">2、TM初始化流程</a></li><li><ul><li><a href=\"#1TmNettyRemotingClient_48\">1）获取TmNettyRemotingClient实例</a></li><li><ul><li><a href=\"#1_TmNettyRemotingClient_57\">1&gt; TmNettyRemotingClient实例化</a></li><li><a href=\"#2_AbstractNettyRemotingClient_75\">2&gt; AbstractNettyRemotingClient实例化</a></li></ul>\n</li><li><a href=\"#2TmNettyRemotingClient_98\">2）初始化TmNettyRemotingClient</a></li><li><ul><li><a href=\"#1__108\">1&gt; 注册一些请求处理组件</a></li><li><a href=\"#2_AbstractNettyRemotingClient_128\">2&gt; 初始化AbstractNettyRemotingClient</a></li><li><ul><li><a href=\"#1AbstractNettyRemoting_140\">（1）AbstractNettyRemoting初始化</a></li><li><a href=\"#2netty_146\">（2）启动netty客户端组件</a></li><li><ul><li><a href=\"#AbstractNettyRemotingClientClientHandler_213\">AbstractNettyRemotingClient.ClientHandler类</a></li></ul>\n</li></ul>\n</li><li><a href=\"#3_seata_server_222\">3&gt; 和事务分组中的每个seata server建立一个长连接</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#RM_251\">四、RM资源管理器初始化</a></li><li><ul><li><a href=\"#1RM_259\">1、RM初始化流程图</a></li><li><a href=\"#2RM_261\">2、RM初始化流程</a></li><li><ul><li><a href=\"#1RmNettyRemotingClient_264\">1、实例化RmNettyRemotingClient</a></li><li><a href=\"#2RmNettyRemotingClient_281\">2、配置RmNettyRemotingClient</a></li><li><ul><li><a href=\"#1_DefaultResourceManager_284\">1&gt; 实例化DefaultResourceManager</a></li><li><a href=\"#2_DefaultRMHandler_296\">2&gt; 实例化DefaultRMHandler</a></li></ul>\n</li><li><a href=\"#3RmNettyRemotingClient_310\">3、初始化RmNettyRemotingClient</a></li></ul>\n</li></ul>\n</li><li><a href=\"#DataSourceProxy_322\">五、DataSourceProxy</a></li><li><ul><li><a href=\"#1DataSourceProxy_349\">1、实例化DataSourceProxy</a></li><li><a href=\"#2DataSourceProxy_355\">2、初始化DataSourceProxy</a></li><li><ul><li><a href=\"#1ID_364\">1）初始化资源ID</a></li><li><a href=\"#2ResourceTC_372\">2）注册Resource到TC</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_402\">六、总结和后续</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>一、前言</h1>\n<p>至此，seata系列的内容包括：</p>\n<blockquote>\n<ol><li><a href=\"https://blog.csdn.net/Saintmm/article/details/121725763\">can not get cluster name in registry config ‘service.vgroupMapping.xx‘, please make sure registry问题解决</a>；</li><li><a href=\"https://blog.csdn.net/Saintmm/article/details/126154377\">Seata Failed to get available servers: endpoint format should like ip:port 报错原因/解决方案汇总版（看完本文必解决问题）</a></li><li><a href=\"https://blog.csdn.net/Saintmm/article/details/126182178\">Seata json decode exception, Cannot construct instance of java.time.LocalDateTime报错原因/解决方案最全汇总版</a></li><li><a href=\"https://saint.blog.csdn.net/article/details/126189208\">【微服务 31】超细的Spring Cloud 整合Seata实现分布式事务（排坑版）</a></li><li><a href=\"https://saint.blog.csdn.net/article/details/126218557\">【微服务 32】Spring Cloud整合Seata、Nacos实现分布式事务案例（巨细排坑版）【云原生】</a></li><li><a href=\"https://saint.blog.csdn.net/article/details/126453122\">【微服务33】分布式事务Seata源码解析一：在IDEA中启动Seata Server</a></li><li><a href=\"https://blog.csdn.net/Saintmm/article/details/126457129\">【微服务34】分布式事务Seata源码解析二：Seata Server启动时都做了什么【云原生】</a></li><li><a href=\"https://saint.blog.csdn.net/article/details/126473847\">【微服务35】分布式事务Seata源码解析三：从Spring Boot特性来看Seata Client 启动时都做了什么</a></li></ol>\n</blockquote>\n<p>本文接着上文中的Seata Client聊的<code>GlobalTransactionScanner</code>来聊一聊Seata Client 如何 与Seata Server建立连接、通信？</p>\n<p><strong>PS：前文中搭建的Seata案例，seata的版本为1.3.0，而本文开始的源码分析将基于当前（2022年8月）最新的版本1.5.2进行源码解析。</strong></p>\n<h1><a id=\"_17\"></a>二、概述</h1>\n<p>在前文（<a href=\"https://saint.blog.csdn.net/article/details/126473847\">【微服务35】分布式事务Seata源码解析三：从Spring Boot特性来看Seata Client 启动时都做了什么</a>），我们聊了随着Spring容器初始化完毕，会调用GlobalTransactionScanner的初始化逻辑（即：<code>afterPropertiesSet()</code>方法），进而调用<code>initClient()</code>方法初始化seata client；</p>\n<ul><li>初始化Seata Client时，TM和RM的逻辑不同，TM会直接和Seata Server建立长连接；</li><li>而RM在AT模式下不会直接和Seata Server建立长连接。<strong><font color=\"blue\">真正建立长连接的地方时实例化DataSourceProxy时。</font></strong></li></ul>\n<p><strong>首先我们要知道Seata Client 与Seata Server的通信是借助Netty的Channel（网络通道）来完成的，即所谓的建立长连接就是通过Netty的Channel进行通信；</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7227b52912ff43d68e68a95e5dec1b7b.png\"/><br/> 本文就看一下TMClient.init()、RMClient.init()方法是如何将TM、RM与TC（Seata Server）建立连接通信的？</p>\n<p><font color=\"blue\"><strong>对TMClient 和 RMClient而言，除自身之外，还会设计到额外的三个类，一定要先明确这几个类的关系，不然看到后面跳过来跳过去的很乱，其关系图如下：</strong></font></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ce0eabc07653431197db7e9b30e910ff.png\"/></p>\n<h1><a id=\"TM_32\"></a>三、TM事务管理器初始化</h1>\n<p><strong>TM全称：Transaction Manager</strong>，中文名：事务管理器，其定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>\n<p>在<code>GlobalTransactionScanner</code>类的如下代码段会进行TM的初始化：</p>\n<pre><code class=\"prism language-java\"><span class=\"token class-name\">TMClient</span><span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span>applicationId<span class=\"token punctuation\">,</span> txServiceGroup<span class=\"token punctuation\">,</span> accessKey<span class=\"token punctuation\">,</span> secretKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"1TM_40\"></a>1、TM初始化流程图</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\64f4e78c973846ffbe0118746ab87f83.png\"/></p>\n<h2><a id=\"2TM_44\"></a>2、TM初始化流程</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\74bc2154b7e948e3abc8d8015a034048.png\"/><br/> TMClient.init()方法入参包括：当前应用的ID、事务组名称，其中获取一个<code>TmNettyRemotingClient</code>实例，然后对其进行初始化；</p>\n<h3><a id=\"1TmNettyRemotingClient_48\"></a>1）获取TmNettyRemotingClient实例</h3>\n<p><strong>整体代码执行流程如下：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e604f8859474406dafe19b40b2bf54ac.png\"/></p>\n<p>在获取TmNettyRemotingClient实例时，首先直接从Spring容器中获取到一个的TmNettyRemotingClient实例，然后再将应用的ID、事务分组名称、鉴权信息设置到TmNettyRemotingClient实例中；</p>\n<p>这其中有几个细节点，下面展开聊一聊：</p>\n<h4><a id=\"1_TmNettyRemotingClient_57\"></a>1&gt; TmNettyRemotingClient实例化</h4>\n<p>实例化TmNettyRemotingClient时采用 DCL（Double Check Lock）保证多线程环境下只会实例化一个<code>TmNettyRemotingClient</code>实例：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\52cbaf34b46e40af9e864a4b876cb10c.png\"/></p>\n<p>其中用于处理消息的线程池的配置如下：</p>\n<blockquote>\n<ol><li>核心线程数和最大线程数都为16；<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6c269fca203e4eba8e3a2a6457e65a8f.png\"/><br/> 2. 线程过期时间为Integer.MAX_VALUE，单位为秒；<br/> 3. 阻塞队列为有界的、最大容量为2000的<code>LinkedBlockingQueue</code>；<br/> 4. 所用线程工厂中生产出的线程名称的前缀为：<code>rpcDispatch_1</code>，其中的1表示<code>TransactionRole</code>为TM。</li></ol>\n</blockquote>\n<p>真正实例化TmNettyRemotingClient时首先会进入其父类<code>AbstractNettyRemotingClient</code>的构造器（下面聊），然后<font color=\"blue\">基于SPI扩展加载鉴权签名组件<code>AuthSigner</code></font>，接着获取<code>开启批量发送请求</code>的配置，默认不开启；注意注册一个配置变更的监听器。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\af73192bd954473a9d56d95f54ed248b.png\"/></p>\n<h4><a id=\"2_AbstractNettyRemotingClient_75\"></a>2&gt; AbstractNettyRemotingClient实例化</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\104440d4da0e44bd89efb925c2a90197.png\"/></p>\n<p>（1）构造器中首先调用父类<code>AbstractNettyRemoting</code>的构造器设置用于处理消息的线程池：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\72312f88617548da8b5cecebf712de93.png\"/></p>\n<p>（2）设置当前事务角色为TMROLE；</p>\n<p>（3）实例化一个NettyClientBootstrap，其中组成了原生netty的Bootstrap、EventLoopGroup、EventExecutorGroup；用于和seata server通信；</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0af4e396ce7f473ea239f48324bca70d.png\"/></p>\n<ul><li>其中netty工作线程名的前缀默认为：<code>NettyClientSelector</code>；工作线程池的数量为1；</li></ul>\n<p>（4）给Bootstrap设置消息处理器Handler（ChannelOutboundHandler），其为：<code>AbstractNettyRemotingClient.ClientHandler</code>。</p>\n<p>（5） 实例化netty的channel管理器，用于管理channel连接；</p>\n<p>方法一路返回，进入到初始化TmNettyRemotingClient。</p>\n<h3><a id=\"2TmNettyRemotingClient_98\"></a>2）初始化TmNettyRemotingClient</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d5c25918592842eb98dfac10b5085e8f.png\"/></p>\n<p><strong>初始化TmNettyRemotingClient时会做三件事：</strong></p>\n<ol><li>注册一些请求处理组件；</li><li>调用其父类<code>AbstractNettyRemotingClient</code>的初始化方法定时对tx事务组进行重连、请求超时检查，启动netty客户端组件；</li><li>如果事务分组不为空，通过长连接管理组件对事务分组建立一个长连接；</li></ol>\n<p>下面细看一下：</p>\n<h4><a id=\"1__108\"></a>1&gt; 注册一些请求处理组件</h4>\n<p>seata server可以主动给seata client发送一些请求过来，对于netty里收到不同的请求需要有不同的请求处理组件；所以此处需要注册一些请求处理组件；</p>\n<p>消息处理器是用来处理消息的，其根据消息的不同类型选择不同的消息处理器来处理消息（<font color=\"blue\">属于典型的策略模式</font>）；</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4123035af473427195ae97dca9fc3e2e.png\"/><br/> 请求处理组件分为两大类：TC响应处理组件（处理seata server的请求）、心跳消息处理组件。</p>\n<p>所谓的注册消息处理器本质上就是将处理器<code>RemotingProcessor</code>和处理消息的线程池<code>ExecutorService</code>包装成一个<code>Pair</code>，然后将Pair作为Value，messageType作为key放入一个Map（<code>processorTable</code>）中；<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6007efe4edb54d61a9fe2b5d3d422188.png\"/></p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">/**\n * This container holds all processors.\n * processor type {@link MessageType}\n */</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token comment\">/*MessageType*/</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RemotingProcessor</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ExecutorService</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token operator\">&gt;</span> processorTable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"2_AbstractNettyRemotingClient_128\"></a>2&gt; 初始化AbstractNettyRemotingClient</h4>\n<p>注册完请求处理组件之后，会使用原子类型（<code>AtomicBoolean</code>）变量<code>initialized</code> + CAS确保AbstractNettyRemotingClient仅会初始化一次。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4c50d72684a2460a938012a1e8a9aa6b.png\"/></p>\n<p>AbstractNettyRemotingClient的初始化同样做了三件事：</p>\n<ol><li>启动一个延时60s，每隔10s对tx事务分组(seata server 列表)发起一个重新连接请求；</li><li>调用其父类<code>AbstractNettyRemoting</code>的初始化方法：启动一个延时3s，每3s执行一次的定时任务，做请求超时检查；</li><li>启动netty客户端组件，其seata server可以与seata client通信；</li></ol>\n<p>下面我们细看一下AbstractNettyRemoting的初始化、netty客户端组件的启动；</p>\n<h5><a id=\"1AbstractNettyRemoting_140\"></a>（1）AbstractNettyRemoting初始化</h5>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a97d96bb2dd04e54983807666f021462.png\"/></p>\n<p>其中仅会启动一个延时3s，每3s执行一次的定时任务，做<font color=\"red\">请求超时检查</font>；请求超时检查的细节如下：</p>\n<ul><li>所谓的请求超时检查，实际是指当seata client发送请求到seata server时，会使用<code>MessageFuture</code>（组合了<code>CompletableFuture</code>）来接收返回值，如果seata server及时返回结果会将MessageFuture从futures中移除。</li></ul>\n<h5><a id=\"2netty_146\"></a>（2）启动netty客户端组件</h5>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>defaultEventExecutorGroup <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>defaultEventExecutorGroup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultEventExecutorGroup</span><span class=\"token punctuation\">(</span>nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClientWorkerThreads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">NamedThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token function\">getThreadPrefix</span><span class=\"token punctuation\">(</span>nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClientWorkerThreadPrefix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClientWorkerThreads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 真正的基于netty API构建一个bootstrap</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bootstrap\n            <span class=\"token comment\">// 设置对应的NioEventGroup，工作线程组，默认一个线程就够了</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>eventLoopGroupWorker<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span>nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClientChannelClazz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ChannelOption</span><span class=\"token punctuation\">.</span>TCP_NODELAY<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ChannelOption</span><span class=\"token punctuation\">.</span>SO_KEEPALIVE<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ChannelOption</span><span class=\"token punctuation\">.</span>CONNECT_TIMEOUT_MILLIS<span class=\"token punctuation\">,</span> nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getConnectTimeoutMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ChannelOption</span><span class=\"token punctuation\">.</span>SO_SNDBUF<span class=\"token punctuation\">,</span> nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClientSocketSndBufSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ChannelOption</span><span class=\"token punctuation\">.</span>SO_RCVBUF<span class=\"token punctuation\">,</span> nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClientSocketRcvBufSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">enableNative</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">PlatformDependent</span><span class=\"token punctuation\">.</span><span class=\"token function\">isOsx</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>LOGGER<span class=\"token punctuation\">.</span><span class=\"token function\">isInfoEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                LOGGER<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"client run on macOS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n            bootstrap<span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EpollChannelOption</span><span class=\"token punctuation\">.</span>EPOLL_MODE<span class=\"token punctuation\">,</span> <span class=\"token class-name\">EpollMode</span><span class=\"token punctuation\">.</span>EDGE_TRIGGERED<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EpollChannelOption</span><span class=\"token punctuation\">.</span>TCP_QUICKACK<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// netty网络通信数据处理组件（PipeLine）进行初始化</span>\n    bootstrap<span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">ChannelInitializer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initChannel</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SocketChannel</span> ch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token class-name\">ChannelPipeline</span> pipeline <span class=\"token operator\">=</span> ch<span class=\"token punctuation\">.</span><span class=\"token function\">pipeline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">// IdleStateHandler，空闲状态检查Handler，如果有数据通过 记录一下数据通过的时间</span>\n                <span class=\"token comment\">// 如果超过很长时间都空闲，没有数据过来，则触发一个user triggered event给ClientHandler进行处理</span>\n                pipeline<span class=\"token punctuation\">.</span><span class=\"token function\">addLast</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">IdleStateHandler</span><span class=\"token punctuation\">(</span>\n                        nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getChannelMaxReadIdleSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                        nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getChannelMaxWriteIdleSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                        nettyClientConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getChannelMaxAllIdleSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token comment\">// 基于seata通信协议的编码器和解码器</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">addLast</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ProtocolV1Decoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">addLast</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ProtocolV1Encoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>channelHandlers <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token function\">addChannelPipelineLast</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> channelHandlers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialized<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> LOGGER<span class=\"token punctuation\">.</span><span class=\"token function\">isInfoEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        LOGGER<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NettyClientBootstrap has started\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>NettyClientBootstrap在启动的过程中设置了4个ChannelHandler：</p>\n<ol><li>IdleStateHandler：处理心跳</li><li>ProtocolV1Decoder：消息解码器</li><li>ProtocolV1Encoder：消息编码器</li><li>AbstractNettyRemotingClient.ClientHandler：处理各种消息</li></ol>\n<h6><a id=\"AbstractNettyRemotingClientClientHandler_213\"></a>AbstractNettyRemotingClient.ClientHandler类</h6>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9a7d1d0187e540aba465f3762a15b26b.png\"/></p>\n<p><font color=\"blue\">ClientHandler类上有个<code>@ChannelHandler.Sharable</code>注解，其表示所有的连接都会共用这一个ChannelHandler；所以当消息处理很慢时，会降低并发。</font></p>\n<p><code>processMessage(ctx, (RpcMessage) msg)</code>方法中会根据消息类型获取到 请求处理组件（<font color=\"red\">消息的处理过程是典型的策略模式</font>），如果消息对应的处理器设置了线程池，则放到线程池中执行；如果对应的处理器没有设置线程池，则直接执行；如果某条消息处理特别慢，会严重影响并发；所以在seata-server中大部分处理器都有对应的线程池。</p>\n<p><code>AbstractNettyRemotingClient.ClientHandler</code>处理消息的方式和seata server的<code>AbstractNettyRemotingServer.ServerHandler</code>一致，此处不再赘述。见文章：<a href=\"https://saint.blog.csdn.net/article/details/126457129\">【微服务34】分布式事务Seata源码解析二：Seata Server启动时都做了什么</a>。</p>\n<h4><a id=\"3_seata_server_222\"></a>3&gt; 和事务分组中的每个seata server建立一个长连接</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0606523194554c8c8aed5052d45a76a4.png\"/></p>\n<p>这里有一个异常信息相信大家比较眼熟：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ebf974bad37a4257ac657ffb26028fc8.png\"/></p>\n<p><strong>再看<code>acquireChannel()</code>方法和seata server建立长连接的代码执行流程：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\087fa75d6c974ef7900c12606263b91f.png\"/></p>\n<p>TM/RM 和 TC 通信的关键在于Channel的创建，seata中通过池化的方式（借助了common-pool中的对象池）方式来创建、管理Channel。</p>\n<p><strong>（1）涉及到的common-pool中的主要类：</strong></p>\n<ul><li><strong>GenericKeydObjectPool&lt;K, V&gt;</strong>：KV泛型对象池，提供对所有对象的存取管理，而对象的创建由其内部的工厂类来完成</li><li><strong>KeyedPoolableObjectFactory&lt;K, V&gt;</strong>：KV泛型对象工厂，负责池化对象的创建，被对象池持有</li></ul>\n<p><strong>（2）涉及到的Seata中对象池实现相关的主要类：</strong></p>\n<ul><li>被池化管理的对象就是Channel，对应common-pool中的泛型V</li><li><strong>NettyPoolKey</strong>：Channel对应的Key，对应common-pool中的泛型K，NettyPoolKey主要包含两个信息： \n  <ul><li><strong>address</strong>：创建Channel时，对应的TC Server地址</li><li><strong>message</strong>：创建Channel时，向TC Server发送的RPC消息体</li></ul> </li><li><strong>GenericKeydObjectPool&lt;NettyPoolKey,Channel&gt;</strong>：Channel对象池<br/> NettyPoolableFactory：创建Channel的工厂类；</li></ul>\n<p>至此，TM的初始化就此完毕！</p>\n<h1><a id=\"RM_251\"></a>四、RM资源管理器初始化</h1>\n<p><strong>RM全称：Resource Manager</strong>，中文名：资源管理器，其管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>\n<p>在<code>GlobalTransactionScanner</code>类的如下代码段会进行RM的初始化：</p>\n<pre><code class=\"prism language-java\"><span class=\"token class-name\">RMClient</span><span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span>applicationId<span class=\"token punctuation\">,</span> txServiceGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"1RM_259\"></a>1、RM初始化流程图</h2>\n<p>和TM初始化流程图基本一致，建议大家研究源码的过程自己画一个出来。</p>\n<h2><a id=\"2RM_261\"></a>2、RM初始化流程</h2>\n<p>RM的初始化流程和TM类似，下面我们看一下差异。</p>\n<h3><a id=\"1RmNettyRemotingClient_264\"></a>1、实例化RmNettyRemotingClient</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b00d3df55e8c4d028ed3a79a0521b9ea.png\"/></p>\n<p>在实例化RmNettyRemotingClient时，处理消息的线程池<code>ThreadPoolExecutor</code>，阻塞队列的最大容量是20000，而TmNettyRemotingClient的2000；</p>\n<p>此外，RmNettyRemotingClient工作线程的前缀名为：<code>rpcDispatch_2</code>，而TmNettyRemotingClient的工作线程的前缀名为：<code>rpcDispatch_1</code>；</p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f65eed17437a476ea6c26c4335243c41.png\"/></p>\n<p><strong>RmNettyRemotingClient的构造器</strong>中，和TmNettyRemotingClient做了同样的事，区别在于RmNettyRemotingClient中不需要<font color=\"blue\">基于SPI扩展加载鉴权签名组件<code>AuthSigner</code></font>：</p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e15c7fa0086f4af9b7aee0b7e978b612.png\"/><br/> 在实例化RmNettyRemotingClient之后，初始化RmNettyRemotingClient之前，会给<code>RmNettyRemotingClient</code>设置资源管理器<code>DefaultResourceManager</code>、事务消息处理器<code>DefaultRMHandler</code>。</p>\n<h3><a id=\"2RmNettyRemotingClient_281\"></a>2、配置RmNettyRemotingClient</h3>\n<p>配置RmNettyRemotingClient是指实例化DefaultResourceManager、DefaultRMHandler将其赋值到RmNettyRemotingClient的字段：resourceManager、transactionMessageHandler上。</p>\n<h4><a id=\"1_DefaultResourceManager_284\"></a>1&gt; 实例化DefaultResourceManager</h4>\n<p>DefaultResourceManager中使用<strong>静态内部类单例模式</strong>保证DefaultResourceManager的唯一性；<strong>实例化流程如下：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\97ec46ee9e114cb09d10ae2f5dd425e0.png\"/></p>\n<p>实例化DefaultResourceManager时会<font color=\"blue\">基于SPI扩展加载资源管理器ResourceManager</font>，一共加载出四个：</p>\n<ul><li>DataSourceManger、SagaResourceManager、ResourceManagerXA、TCCResourceManager。</li><li><strong>博主就感觉这里的命名啊，真是一个人一个写法！！！做为一个开源组件，实现的命名方式不需要统一一下吗！！！！！</strong></li></ul>\n<p><strong>和事务模式的对应关系如下：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\54c5d809378c4021a4f310ffc5b9175e.png\"/></p>\n<h4><a id=\"2_DefaultRMHandler_296\"></a>2&gt; 实例化DefaultRMHandler</h4>\n<p>DefaultRMHandler中使用<strong>静态内部类单例模式</strong>保证DefaultRMHandler的唯一性；<strong>实例化流程如下：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\86725ffeaca94e369c0818dfcaaa8615.png\"/></p>\n<p>实例化DefaultRMHandler时会<font color=\"blue\">基于SPI扩展加载资源管理器RMHandler</font>，一共加载出四个：</p>\n<ul><li>RMHandlerXA、RMHandlerTCC、RMHandlerSaga、RMHandlerAT。</li><li><strong>这个命名就很顺眼了，ResourceManager那是啥！！！</strong></li></ul>\n<p><strong>和事务模式的对应关系如下：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ea3628a37d154da7a46fe584a3331d76.png\"/></p>\n<h3><a id=\"3RmNettyRemotingClient_310\"></a>3、初始化RmNettyRemotingClient</h3>\n<p>整体初始化流程和TM一致，差异点在于最后在与seata server建立长连接时会额外判断资源管理器<code>ResourceManager</code>中是否已经加载了连接资源；默认没有加载连接资源，<font color=\"red\"><strong>所以初始化RMClient时不会立刻和seata server建立长连接</strong></font>。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6bedcacdd5804351a15d13afa4aa79fe.png\"/></p>\n<p>而RM的初始化之所以要判断资源是否存在也很好理解，RM就是管理资源的，没有资源也就没有必要理解和Seata Server建立长连接。</p>\n<p>既然初始化时不会立刻建立长连接，定时任务每30s才会与seata server重新建立长连接，假如在RM初始化后、定时任务执行之前加载了数据库资源，开始要进行一个分布式事务的流程，此时RM还没有seata server（TC）建立channel通信，重大bug啊！！</p>\n<p><strong>既然seata都开源运行了那么久，应该不会存在这个bug吧，我们大胆推测：在创建数据库资源时就会立刻让RM和TC建立长连接。</strong></p>\n<h1><a id=\"DataSourceProxy_322\"></a>五、DataSourceProxy</h1>\n<p>DataSourceProxy是使用seata 实现分布式事务（AT模式）必要引入的DataSource代理，其对数据库操作进行代理。引入方式如下：</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DataSourceConfig</span> <span class=\"token punctuation\">{<!-- --></span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"spring.datasource\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">DruidDataSource</span> <span class=\"token function\">druidDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DruidDataSource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">/**\n     * 需要将 DataSourceProxy 设置为主数据源，否则事务无法回滚\n     *\n     * @param druidDataSource The DruidDataSource\n     * @return The default datasource\n     */</span>\n    <span class=\"token annotation punctuation\">@Primary</span>\n    <span class=\"token annotation punctuation\">@Bean</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dataSource\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">DataSource</span> <span class=\"token function\">dataSource</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DruidDataSource</span> druidDataSource<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DataSourceProxy</span><span class=\"token punctuation\">(</span>druidDataSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"1DataSourceProxy_349\"></a>1、实例化DataSourceProxy</h2>\n<p><strong>实例化DataSourceProxy的代码执行流程如下：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2c8dc2d7fbac49d2a102ee7b41cf817e.png\"/><br/> 实例化很简单，单纯的将要代理的DataSource组合到DataSourceProxy中，然后进行DataSourceProxy的初始化；</p>\n<h2><a id=\"2DataSourceProxy_355\"></a>2、初始化DataSourceProxy</h2>\n<p><strong>初始化DataSourceProxy时会做三件事：</strong></p>\n<ol><li>从数据库连接中获取出JDBC连接信息保存下来；</li><li>初始化资源ID，针对单机MySQL默认为数据库连接地址（不包含?后面的字符）；其用于注册到TC中做标识；</li><li>将当前Resource资源注册到TC；</li></ol>\n<p>下面细看一下：初始化资源ID、将当前Resource资源注册到TC。</p>\n<h3><a id=\"1ID_364\"></a>1）初始化资源ID</h3>\n<p><strong>代码执行流程如下：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\977e6fd4bf9d4c9ab966cd18136076be.png\"/></p>\n<p>针对单机MySQL，ResourceId默认为数据库连接地址（不包含?后面的字符）。</p>\n<h3><a id=\"2ResourceTC_372\"></a>2）注册Resource到TC</h3>\n<p><strong>代码执行流程如下：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\31a960feed6b40ca8cb9be698410e32f.png\"/></p>\n<p>在<code>DataSourceManager#registerResource()</code>方法中会将 数据库资源的resourceID作为key、数据库资源作为value保存到本地缓存<code>dataSourceCache</code>中；</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Resource</span><span class=\"token punctuation\">&gt;</span></span> dataSourceCache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>在RMClient初始化时，会不会立即和TC建立长连接，相对TMClient而言，额外的一个判断条件正是dataSourceCache是否为空。</strong></p>\n<p>后续的注册资源流程其实就只是从<code>NettyClientChannelManager</code>拿到和TC建立长连接的channel，然后向其发送注册RM请求<code>RegisterRMRequest</code>。</p>\n<p><strong>注册成功之后，TC（Seata Server）端会打印日志：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fa0bd9b8cfff4e78affdfc8612c88ab9.png\"/></p>\n<pre><code class=\"prism language-java\"><span class=\"token punctuation\">[</span>rverHandlerThread_1_9_500<span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">i<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">.</span>processor<span class=\"token punctuation\">.</span>server<span class=\"token punctuation\">.</span></span>RegRmProcessor</span>  <span class=\"token operator\">:</span> RM register success<span class=\"token punctuation\">,</span>message<span class=\"token operator\">:</span><span class=\"token class-name\">RegisterRMRequest</span><span class=\"token punctuation\">{<!-- --></span>resourceIds<span class=\"token operator\">=</span>'jdbc<span class=\"token operator\">:</span>mysql<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">3306</span><span class=\"token operator\">/</span>seata_stock'<span class=\"token punctuation\">,</span> applicationId<span class=\"token operator\">=</span>'stock<span class=\"token operator\">-</span>service'<span class=\"token punctuation\">,</span> transactionServiceGroup<span class=\"token operator\">=</span>'saint<span class=\"token operator\">-</span>trade<span class=\"token operator\">-</span>tx<span class=\"token operator\">-</span>group'<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>channel<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>id<span class=\"token operator\">:</span> <span class=\"token number\">0x56942c85</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">L</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">8091</span> <span class=\"token operator\">-</span> <span class=\"token class-name\">R</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">59778</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>client version<span class=\"token operator\">:</span><span class=\"token number\">1.5</span><span class=\"token number\">.2</span>\n</code></pre>\n<p>加载完DataSourceProxy之前，如果定时任务向TC发起注册RM请求<code>RegisterRMRequest</code>（每30s执行一次和seata server重新连接），则在TC端没有resourceId标识：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1f76990b86fd48ba9ccb65e3614c1553.png\"/></p>\n<pre><code class=\"prism language-java\"><span class=\"token punctuation\">[</span>ttyServerNIOWorker_1_5_16<span class=\"token punctuation\">]</span> <span class=\"token class-name\"><span class=\"token namespace\">i<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">.</span>processor<span class=\"token punctuation\">.</span>server<span class=\"token punctuation\">.</span></span>RegTmProcessor</span>  <span class=\"token operator\">:</span> TM register success<span class=\"token punctuation\">,</span>message<span class=\"token operator\">:</span><span class=\"token class-name\">RegisterTMRequest</span><span class=\"token punctuation\">{<!-- --></span>applicationId<span class=\"token operator\">=</span>'stock<span class=\"token operator\">-</span>service'<span class=\"token punctuation\">,</span> transactionServiceGroup<span class=\"token operator\">=</span>'saint<span class=\"token operator\">-</span>trade<span class=\"token operator\">-</span>tx<span class=\"token operator\">-</span>group'<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>channel<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>id<span class=\"token operator\">:</span> <span class=\"token number\">0xf216813f</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">L</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">8091</span> <span class=\"token operator\">-</span> <span class=\"token class-name\">R</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span><span class=\"token operator\">:</span><span class=\"token number\">59369</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>client version<span class=\"token operator\">:</span><span class=\"token number\">1.5</span><span class=\"token number\">.2</span>\n</code></pre>\n<h1><a id=\"_402\"></a>六、总结和后续</h1>\n<p>本文我们聊了TM / RM在实例化GlobalTransactionScanner之后 开始初始化 向TC发起注册请求、建立长连接，但是针对RMClient并不会在初始化时立即和TC建立长连接；</p>\n<p>而是等到DataSourceProxy加载之后，才会立即和TC建立长连接；或者等每30秒执行一次的定时任务和TC建立长连接，但是如果DataSourceProxy还没有加载，则建立长连接时，资源的标识resourceID为null。</p>\n<p>下一篇文章开聊seata如何开启全局事务？</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-30 07:53:48", "summary": "文章目录一、前言二、概述三、事务管理器初始化、初始化流程图、初始化流程获取实例实例化实例化初始化注册一些请求处理组件初始化初始化启动客户端组件类和事务分组中的每个建立一个长连接四、资源管理器初始化、初"}