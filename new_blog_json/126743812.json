{"blogid": "126743812", "writerAge": "码龄5年", "writerBlogNum": "2110", "writerCollect": "5341", "writerComment": "826", "writerFan": "1564", "writerGrade": "8级", "writerIntegral": "48426", "writerName": "霸道流氓气质", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743812.jpg", "writerRankTotal": "104", "writerRankWeekly": "5545", "writerThumb": "1293", "writerVisitNum": "3929783", "blog_read_count": "17", "blog_time": "于 2022-09-07 13:30:50 发布", "blog_title": "Java中数据同步-synchronized关键字与Mointor的使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"autoid-0-0-0\">场景</h1>\n<p>Java中Thread类的常用API以及使用示例：</p>\n<p><a href=\"https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/126596884\" title=\"Java中Thread类的常用API以及使用示例_霸道流氓气质的博客-CSDN博客\">Java中Thread类的常用API以及使用示例_霸道流氓气质的博客-CSDN博客</a></p>\n<p>在上面的基础上，学习线程同步的相关概念。</p>\n<h2 id=\"autoid-1-0-0\">数据不一致问题引入</h2>\n<p>模拟一个营业厅叫号机程序</p>\n<pre><code class=\"hljs\">package com.ruoyi.demo.threadsafe;\n\n/**\n * 模拟营业大厅叫号程序，每次会不一样的发现：某个号码被略过、某个号码被多次显示、号码超过了最大值500\n */\npublic class TicketWindowRunable implements Runnable{\n\n    private int index = 1;\n    private final static int MAX = 500;\n\n    @Override\n    public void run() {\n        while (index &lt;= MAX)\n        {\n            System.out.println(Thread.currentThread()+\"的号码：\"+(index++));\n        }\n    }\n\n    public static void main(String[] args) {\n        final TicketWindowRunable task = new TicketWindowRunable();\n        Thread windowThread1 = new Thread(task,\"1号窗口\");\n        Thread windowThread2 = new Thread(task,\"2号窗口\");\n        Thread windowThread3 = new Thread(task,\"3号窗口\");\n        Thread windowThread4 = new Thread(task,\"4号窗口\");\n\n        windowThread1.start();\n        windowThread2.start();\n        windowThread3.start();\n        windowThread4.start();\n    }\n}</code></pre>\n<p>多次运行上面程序，每次都会不一样。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\6fe85e999e07f47b4677487ed922e223.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>可以通过输出的行数明显发现不一样，主要有三个问题：</p>\n<p>某个号码被略过、某个号码被多次显示、号码超过最大值</p>\n<p>注：</p>\n<p>博客：<br/><a href=\"https://blog.csdn.net/badao_liumang_qizhi\" title=\"霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主\">霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主</a><br/> 关注公众号<br/> 霸道的程序猿<br/> 获取编程相关电子书、教程推送与免费下载。</p>\n<h1 id=\"autoid-1-1-0\">实现</h1>\n<p>1、出现上述不一样的原因是线程的执行是由CPU时间片轮询调度的，CPU调度器在将执行权交给各个线程时，多个线程对index变量(共享变量/资源)</p>\n<p>同时操作引起的。</p>\n<p>要解决这个问题需要使用synchronized关键字，其提供了一种排他机制，也就是在同一时间只能有一个线程执行某些操作。</p>\n<p>2、将上面的叫号程序修改</p>\n<pre><code class=\"hljs\">package com.ruoyi.demo.threadsafe;\n\n/**\n * 模拟营业大厅叫号程序\n */\npublic class TicketWindowRunableWithSync implements Runnable{\n\n    private int index = 1;\n    private final static int MAX = 500;\n    private final static Object MUTEX = new Object();\n    @Override\n    public void run() {\n        synchronized (MUTEX){\n            while (index &lt;= MAX)\n            {\n                System.out.println(Thread.currentThread()+\"的号码：\"+(index++));\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final TicketWindowRunableWithSync task = new TicketWindowRunableWithSync();\n        Thread windowThread1 = new Thread(task,\"1号窗口\");\n        Thread windowThread2 = new Thread(task,\"2号窗口\");\n        Thread windowThread3 = new Thread(task,\"3号窗口\");\n        Thread windowThread4 = new Thread(task,\"4号窗口\");\n\n        windowThread1.start();\n        windowThread2.start();\n        windowThread3.start();\n        windowThread4.start();\n    }\n}</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\788bfbcc74260721afbbc46c727f49ee.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>此时程序运行多次，不会出现数据不一致的问题。</p>\n<p>3、线程堆栈分析</p>\n<p>synchronized关键字提供了一种互斥机制，在同一时刻，只能有一个线程访问同步资源。下面是一个简单示例</p>\n<pre><code class=\"hljs\">package com.ruoyi.demo.threadsafe;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Mutex {\n    private final static Object MUTEX = new Object();\n    public void accessResource(){\n        synchronized (MUTEX){\n            try {\n                //TimeUnit.MINUTES.sleep(10);\n                TimeUnit.SECONDS.sleep(30);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final Mutex mutex = new Mutex();\n        for (int i = 0; i &lt; 5 ; i++) {\n            new Thread(mutex::accessResource).start();\n        }\n    }\n}</code></pre>\n<p>上面定义了一个方法accessResource,使用同步代码块的方式对accessResource进行同步，同时定义5个线程调用accessResource方法。</p>\n<p>由于同步代码块的互斥性，只能有一个线程获取了mutex monitor的锁，其他线程只能进入堵塞状态。</p>\n<p>4、使用JConsole工具监控</p>\n<p>找到jdk的目录下bin下jconsole.exe，双击运行</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\cd26494be46712ee03c15e0ebdd6d9fa.jpeg\"/></p>\n<p>新建连接-本地进程-上面的Mutex选中-连接-接受不安全的连接-线程-Thread-0到4就是上面的5个线程</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\cf8174e921c5da915a4c64625ff9f355.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>当设置休眠10分钟的时候可以看到，Thread-0在sleep</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\3395b36565365aa874fae0619efb50b4.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>其它的则是进入了BLOCKED状态。</p>\n<p>5、使用jps和jstack打印线程堆栈信息</p>\n<p>通过上面的jconsole可以获取到其pid，也可以直接在cmd中输入</p>\n<p>jps</p>\n<p>获取所有的pid之后，再输入</p>\n<p>jstack pid号</p>\n<p>打印进程的线程堆栈信息</p>\n<p> </p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\171492812ed02ac8cf976ba6b17e2ef8.jpeg\"/></p>\n<p>看到与上面的jconsole的效果一致。</p>\n<p>6、规则与注意事项</p>\n<p>规则：</p>\n<p>每个对象都与一个monitor相关联，一个monitor的lock的锁只能被一个线程在同一时间获得。</p>\n<p>释放对monitor的所有权的前提是你曾经获取到了所有权。</p>\n<p>注意问题：</p>\n<p> ①与monitor关联的对象不能为空。</p>\n<p>private final static Object MUTEX = null;</p>\n<p>②synchronized作用域太大。</p>\n<p>如果将其作用在run方法上，则丧失了并发的优势。</p>\n<p>③不同的monitor企图锁相同的方法。</p>\n<pre><code class=\"hljs\">package com.ruoyi.demo.threadsafe;\n\npublic class ErrorMutexDemo implements Runnable {\n    private final Object MUTEX = new Object();\n\n    @Override\n    public void run() {\n        synchronized (MUTEX)\n        {\n           \n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 5; i++) {\n            new Thread(ErrorMutexDemo::new).start();\n        }\n    }\n}</code></pre>\n<p>上面的代码每个线程争抢的monitor关联引用都是彼此独立的，因此不能起到互斥的作用。</p>\n<p>④多个锁的交叉导致死锁</p>\n<p>7、This Monitor与Class Monitor介绍</p>\n<p>ThisMonitor</p>\n<p>两个方法method1和method2都被synchronized关键字修饰，启动两个线程分别访问method1和method2</p>\n<pre><code class=\"hljs\">package com.ruoyi.demo.threadsafe;\n\nimport java.util.concurrent.TimeUnit;\n\nimport static java.lang.Thread.currentThread;\n\npublic class ThisMonitor {\n    public synchronized void method1(){\n        System.out.println(currentThread().getName()+\"enter to method1\");\n        try {\n            TimeUnit.MINUTES.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public synchronized void method2(){\n        System.out.println(currentThread().getName()+\"enter to method2\");\n        try {\n            TimeUnit.MINUTES.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        ThisMonitor thisMonitor = new ThisMonitor();\n        //注意这里调用了构造方法public Thread(Runnable target, String name)\n        //Target——线程启动时调用其run方法的对象。如果为空，则调用此线程的run方法。\n        new Thread(thisMonitor::method1,\"T1\").start();\n        new Thread(thisMonitor::method2,\"T2\").start();\n    }\n}</code></pre>\n<p>运行之后的结果为</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\08e06e1572e137c260c27e6823b1daf9.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>此时用jstack分析</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\ef27c14647d0819ac932c98b6522afdb.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>可以得出，synchronized关键字同步类的不同实例方法，争抢的是同一个monitor的lock，而与之相关联的引用则是ThisMonitor的实例</p>\n<p>引用。</p>\n<p>Classmonitor</p>\n<p>有两个类方法(静态方法)分别使用synchronized对其进行同步</p>\n<pre><code class=\"hljs\">package com.ruoyi.demo.threadsafe;\n\nimport java.util.concurrent.TimeUnit;\n\nimport static java.lang.Thread.currentThread;\n\npublic class ClassMonitor {\n    public static synchronized void method1()\n    {\n        System.out.println(currentThread().getName()+\"enter to method1\");\n        try {\n            TimeUnit.MINUTES.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized void method2()\n    {\n        System.out.println(currentThread().getName()+\"enter to method2\");\n        try {\n            TimeUnit.MINUTES.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Thread(ClassMonitor::method1,\"T1\").start();\n        new Thread(ClassMonitor::method2,\"T2\").start();\n    }\n}</code></pre>\n<p>运行之后的效果</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\24dc486fe2724c15076518301a6e232b.jpeg\"/></p>\n<p></p>\n<p></p>\n<p>使用jstack分析之后</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\3d667fdf05e069d872a753ad822e0d0e.jpeg\"/></p>\n<p>由此可知，用synchronized同步某个类的 不同静态方法争抢的也是同一个monitor的lock。</p>\n<p> 以上代码和示例参考《Java高并发编程详解》，建议阅读原书。 </p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 13:30:50", "summary": "场景中类的常用以及使用示例：中类的常用以及使用示例霸道流氓气质的博客博客中类的常用以及使用示例霸道流氓气质的博客博客在上面的基础上，学习线程同步的相关概念。数据不一致问题引入模拟一个营业厅叫号机程序模"}