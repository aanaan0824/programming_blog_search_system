{"blogid": "122304238", "writerAge": "码龄13年", "writerBlogNum": "14", "writerCollect": "47", "writerComment": "2", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "150", "writerName": "V1ncent Chen", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122304238.jpg", "writerRankTotal": "80386", "writerRankWeekly": "270181", "writerThumb": "6", "writerVisitNum": "14111", "blog_read_count": "7407", "blog_time": "已于 2022-07-28 16:00:43 修改", "blog_title": "MySQL分区表详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>通常情况下，同一张表的数据在物理层面都是存放在一起的。随着业务增长，当同一张表的数据量过大时，会带来管理上的不便。而分区特性可以将一张表从物理层面根据一定的规则将数据划分为多个分区，多个分区可以单独管理，甚至存放在不同的磁盘/文件系统上，提升效率。</p>\n<p>分区表的优点：</p>\n<ul><li>数据可以跨磁盘/文件系统存储，适合存储大量数据。</li><li>数据的管理非常方便，以分区为单位操作数据，不会影响其他分区的正常运行。</li><li>数据查询上在某些条件可以利用分区裁剪(partition pruning)特性，将搜索范围快速定位到特性分区，提升查询性能。</li></ul>\n<p>对于应用来说，表依然是一个逻辑整体，但数据库可以针对不同的数据分区独立执行管理操作，不影响其他分区的运行。而数据划分的规则即称为分区函数，数据写入表时，会根据运算结果决定写入哪个分区。</p>\n<p>MySQL的分区插件与存储引擎运行在不同的层，因此大部分存储引擎都可以利用MySQL的分区特性，只有少数存储引擎（merge，CSV，federated）不支持分区特性。若某张表使用的分区特性，则所有的分区都需要使用相同的存储引擎，且分区特性会同时应用到数据和索引上。</p>\n<p>MySQL的分区类型：</p>\n<p id=\"%E4%B8%80%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B\">一、分区的类型</a></p>\n<p id=\"1.%20Range%20partition(%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA)-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20Range%20partition%28%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA%29\">1. Range partition(范围分区)</a></p>\n<p id=\"2.%20List%20partition(%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA)-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20List%20partition%28%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA%29\">2. List partition(列表分区)</a></p>\n<p id=\"3.%20Hash%20partition(%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA)-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20Hash%20partition%28%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%29\">3. Hash partition(哈希分区)</a></p>\n<p id=\"4.%20Key%20partition(%E9%94%AE%E5%80%BC%E5%88%86%E5%8C%BA)-toc\" style=\"margin-left:40px;\"><a href=\"#4.%20Key%20partition%28%E9%94%AE%E5%80%BC%E5%88%86%E5%8C%BA%29\">4. Key partition(键值分区)</a></p>\n<p id=\"%E4%BA%8C%E3%80%81subparitioning(%E5%AD%90%E5%88%86%E5%8C%BA)-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81subparitioning%28%E5%AD%90%E5%88%86%E5%8C%BA%29\">二、subparitioning(子分区)</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%B4%E6%8A%A4-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%B4%E6%8A%A4\">三、分区的基本维护</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E4%B8%80%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B\">一、分区的类型</h1>\n<h2 id=\"1.%20Range%20partition(%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA)\">1. Range partition(范围分区)</h2>\n<p>Range partition是按照分区表达式的运算结果，判断结果落在某个范围内，从而将数据存储在对应的分区。各个分区定义之间需要连续且不能重叠，范围分区通过partition by range子句定义，而分区的范围通过values less than子句划分。</p>\n<p>例：定义一个员工表，根据员工ID分区，1~10号员工一个分区，11~20号员工一个分区，依次类推，共建立4个分区：</p>\n<pre><code>create table employees (\n    id int not null primary key,\n    first_name varchar(30),\n    last_name varchar(30))\n    partition by range(id)(\n    partition p0 values less than (11),\n    partition p1 values less than (21),\n    partition p2 values less than (31),\n    partition p3 values less than (41)\n    );</code></pre>\n<p>现在随便插入几条数据：</p>\n<pre><code>insert into employees values(1,'Vincent','Chen');\ninsert into employees values(6,'Victor','Chen');\ninsert into employees values(11,'Grace','Li');\ninsert into employees values(16,'San','Zhang');\ncommit;</code></pre>\n<p><strong>分区查询：</strong></p>\n<p>如果在查询时候明确的知道数据所在的分区，我们可以直接指定分区：</p>\n<pre><code>select * from employees partition(p0);  -- 查询p0分区\nselect * from employees partition(p0,p1);  -- 查询p0和p1分区</code></pre>\n<p><img alt=\"\" height=\"161\" src=\"..\\..\\static\\image\\5212bd20879244ee856f57286f073952.png\" width=\"542\"/></p>\n<p><strong> 分区删除：</strong></p>\n<p>如果某分区数据不再需要的时候，我们可以用alter table ... drop partition来删除指定分区，例如删除分区p1，采用drop partition的方式可以快速清除历史数据:</p>\n<pre><code>alter table employees drop partition p1;</code></pre>\n<p><img alt=\"\" height=\"69\" src=\"..\\..\\static\\image\\c9b548eb10b44be49edc70092014b7ed.png\" width=\"536\"/></p>\n<p> 分区p1被删除后，所有p1分区的数据都已丢失，此时原p1分区的范围将由p2覆盖。</p>\n<p><strong>分区新增：</strong></p>\n<p>对于range分区来说，分区新增只能在最大范围之上增加分区，因此p1分区被删除后就无法通过新增分区的方式加回了，下例试图对ID10~20的员工新增一个分区，系统会返还错误。</p>\n<pre><code>alter table employees add partition (partition n1 values less than(21));</code></pre>\n<p><img alt=\"\" height=\"44\" src=\"..\\..\\static\\image\\e21642a19a224663b05576a83129140d.png\" width=\"1015\"/></p>\n<p>而在最大的分区范围之上是可以的：</p>\n<pre><code>alter table employees add partition (partition p4 values less than(51));</code></pre>\n<p><img alt=\"\" height=\"60\" src=\"..\\..\\static\\image\\735e93f82c774f87a034153f9dde696f.png\" width=\"891\"/></p>\n<p><strong> 分区重组织：</strong></p>\n<p>如果一定要在分区之间插入新的分区，则可以采用重组织的方式，将已有分区的数据重新划分，达到创建新分区的效果：</p>\n<p><img alt=\"\" height=\"224\" src=\"..\\..\\static\\image\\7eb26c94295c42ddb02cc4d4c01064da.png\" width=\"700\"/></p>\n<p> 例如我要将p2划分为2个分区，分别是11~20,21~30:</p>\n<pre><code>alter table employees reorganize partition p2 into (\npartition p1 values less than(21),\npartition p2 values less than(31));</code></pre>\n<p><img alt=\"\" height=\"106\" src=\"..\\..\\static\\image\\a93c27b2bfd94939b790fa73bd18533e.png\" width=\"693\"/></p>\n<p> <img alt=\"\" height=\"240\" src=\"..\\..\\static\\image\\12a5af4315d248d8bff8680e667ac62c.png\" width=\"680\"/></p>\n<p> 此时原p2分区被拆分为了p1,p2，数据也在2个分区间重新分布，保证不会丢失。效果就像我们在中间插入了一个分区一样。</p>\n<p>目前定义的分区都是有上限的，如果有大于分区上限的值想插入表中，系统会返还错误，为了兼容这种情况，我们可以新增一个分区，上限为maxvalue。所有大于当前上限的值都会放入这个分区：</p>\n<pre><code>alter table employees add partition(partition pmax values less than(maxvalue));</code></pre>\n<p><img alt=\"\" height=\"72\" src=\"..\\..\\static\\image\\d4db2405496040f98ef2ed32832d8adf.png\" width=\"959\"/></p>\n<p>范围分区的条件除了直接用值，还可以用函数来定义。一个常用的场景就是按时间分区，例如：在create table中使用partition by range(year(hire_date))，可以按照年份来进行分区。这种分区方式在需要定期清理过期数据的场景会非常方便。</p>\n<p><strong>Range columns分区：</strong></p>\n<p>Range分区还有一个变种，叫做range columns分区。此分区方式允许使用多个column来作为分区范围条件。但是此分区方式不能接受函数，只能直接用列的名称。但是对分区列的类型不再限制为整数，可以使用string,date等类型。</p>\n<p>使用range columns对多个列进行分区：</p>\n<pre><code>CREATE TABLE rc2 (\n    a INT,\n    b INT\n)\nPARTITION BY RANGE COLUMNS(a,b) (\n    PARTITION p0 VALUES LESS THAN (0,10),\n    PARTITION p1 VALUES LESS THAN (10,20),\n    PARTITION p2 VALUES LESS THAN (10,30),\n    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE) );</code></pre>\n<p>使用range columns直接对date类型进行分区：</p>\n<pre><code>CREATE TABLE members (\n    firstname VARCHAR(25) NOT NULL,\n    lastname VARCHAR(25) NOT NULL,\n    username VARCHAR(16) NOT NULL,\n    joined DATE NOT NULL\n)\nPARTITION BY RANGE COLUMNS(joined) (\n    PARTITION p0 VALUES LESS THAN ('1960-01-01'),\n    PARTITION p1 VALUES LESS THAN ('1970-01-01'),\n    PARTITION p2 VALUES LESS THAN ('1980-01-01'),\n    PARTITION p3 VALUES LESS THAN ('1990-01-01'),\n    PARTITION p4 VALUES LESS THAN MAXVALUE);\n</code></pre>\n<p><strong>Range partition和null:</strong></p>\n<p>对range分区来说，如果插入数据分区键为null，是可以成功的，数据会被放到第一个分区中。</p>\n<p></p>\n<h2 id=\"2.%20List%20partition(%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA)\"><strong>2. List partition(列表分区)</strong></h2>\n<p>列表分区和范围分区类似，主要区别是list partition的分区范围是预先定义好的一系列值，而不是连续的范围。列表分区采用partition by list和values in子句定义。</p>\n<p>示例，创建一张员工表按照ID进行列表分区：</p>\n<pre><code>CREATE TABLE employees (\n    id INT NOT NULL,\n    fname VARCHAR(30),\n    lname VARCHAR(30)\n)\nPARTITION BY LIST(id) (\n    PARTITION p0 VALUES IN (1,3,5,7,9),\n    PARTITION p1 VALUES IN (2,4,6,8,10)\n);</code></pre>\n<p>和range分区一样，可以使用alter table ... add/drop partition新增/删除分区：</p>\n<pre><code>ALTER TABLE employees ADD PARTITION(PARTITION p2 VALUES IN (11,12,13,14,15));</code></pre>\n<pre><code>ALTER TABLE employees DROP PARTITION p0;</code></pre>\n<p><strong>List partition和非事务引擎：</strong></p>\n<p>如果插入的值在list分区范围中不存在的话，语句会返还错误。如果表使用的是事务型引擎，如innodb。则这个事务会完全回滚。如果使用的是非事务引擎，若MyISAM，虽然也会报错，但是已插入的行无法回滚。</p>\n<p>下面新建两张表，一张使用innodb,一张使用myisam:</p>\n<pre><code>CREATE TABLE employees_innodb (\n    id INT NOT NULL,\n    fname VARCHAR(30),\n    lname VARCHAR(30)\n) ENGINE=InnoDB   -- 事务型引擎\nPARTITION BY LIST(id) (\n    PARTITION p0 VALUES IN (1,3,5,7,9),\n    PARTITION p1 VALUES IN (2,4,6,8,10));\n\nCREATE TABLE employees_myisam (\n    id INT NOT NULL,\n    fname VARCHAR(30),\n    lname VARCHAR(30)\n) ENGINE=MyISAM   -- 非事务型引擎\nPARTITION BY LIST(id) (\n    PARTITION p0 VALUES IN (1,3,5,7,9),\n    PARTITION p1 VALUES IN (2,4,6,8,10));</code></pre>\n<pre><code>insert into employees_innodb values(1,'Vincent','Chen'),(11,'Grace','Li'),(2,'Victor','Chen');\ninsert into employees_myisam values(1,'Vincent','Chen'),(11,'Grace','Li'),(2,'Victor','Chen');\n\nselect * from employees_innodb;\nselect * from employees_myisam;</code></pre>\n<p><img alt=\"\" height=\"276\" src=\"..\\..\\static\\image\\71b684fa242846abba24f5920185097a.png\" width=\"1183\"/></p>\n<p>我们在中间放了一个不存在对应分区的记录来触发错误， 可以看到innodb引擎数据没有数据插入(回滚)。但MyISAM引擎报错前的数据已经保留了下来，但是报错之后的记录未执行插入。</p>\n<p>如果要忽略此错误，可以在insert语句中使用ignore关键字来忽略此错误，只插入符合分区条件的值：</p>\n<pre><code>insert ignore into employees_innodb values(1,'Vincent','Chen'),(11,'Grace','Li'),(2,'Victor','Chen');\ninsert ignore into employees_myisam values(1,'Vincent','Chen'),(11,'Grace','Li'),(2,'Victor','Chen');\n</code></pre>\n<p><img alt=\"\" height=\"491\" src=\"..\\..\\static\\image\\383f91d6f45642febff793febdea22c5.png\" width=\"1200\"/></p>\n<p> 可以看到符合条件的记录被插入，不符合条件的自动被过滤，不返回错误。</p>\n<p><strong>List columns分区：</strong></p>\n<p>和range分区类似，list partition也有一个变种的list columns 分区，此分区类型可以使用多个列同时作为分区条件，且不再限制整数。并且可以使用string,date等数据类型作为分区条件。</p>\n<p><strong>list partition和null:</strong></p>\n<p>对于列表分区来说，必须有1个分区显示的指定可以包含null，否则插入会失败。</p>\n<p></p>\n<h2 id=\"3.%20Hash%20partition(%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA)\">3. Hash partition(哈希分区)</h2>\n<p>Hash partition主要的应用场景是将数据平均的分布在指定数量的hash分区中。在range和list分区类型中，根据分区条件的计算结果，数据可以确定存储在哪个分区，而在hash分区中，数据存储在某个分区是由数据库自己决定的，你只需要指定分区的数量。</p>\n<p>要创建hash分区，你需要使用create table的partition by hash(expr)子句，其中expr是整数类型的列或返还整数的表达式。另外还需要使用partions num来指定hash分区的数量(若忽略partitions子句则默认只创建1个hash分区)。</p>\n<p>例：创建一个具有4个hash分区的表，按照ID进行分区：</p>\n<pre><code>CREATE TABLE employees (\n    id INT NOT NULL,\n    first_name VARCHAR(30),\n    last_name VARCHAR(30)\n)\nPARTITION BY HASH(id)\nPARTITIONS 4;</code></pre>\n<p><strong>Hash分区的性能考虑：</strong></p>\n<p>对于hash分区，数据库决定将数据存储在哪个分区是采用取余的方式进行运算的。存储分区的编号n = mod(expr, num)，其中expr是分区值，num为定义的分区数量。</p>\n<p>例如：对于4个hash分区，ID为5的记录，会存储在mod(5,4)=1，即1号分区中。</p>\n<p>因此，最佳的分区键值的变化方式应该是线性变化，此时使用hash分区的效率最高，分布也会均匀。由于分区键值expr在每次insert/update/delete时都会运算，太复杂的表达式也会带来负面的性能影响，在选择时也需要考虑。</p>\n<p><strong>Liner hash partition(线性哈希分区)：</strong></p>\n<p>以上的分区类型即普通hash分区，另外还有一类变种叫做liner hash partition(线性哈希分区)，线性哈希分区的区别是其使用了更复杂的计算方法来确定数据的分布：</p>\n<pre><code>1. 对于分区数量为num的分区表，先计算V：\n   V = POWER(2, CEILING(LOG(2, num)))\n\n2. 对于分区值与V-1进行位与运算\n   N = expr &amp; (V - 1)   -- 位与运算\n\n3. 对于N&gt;num的情况，再次计算\n   N = N &amp; ((v/2)-1)  </code></pre>\n<p>例：假设分区数量为4</p>\n<p>1. 先根据分区数量num计算V的值，先log再power,如果分区数量如果是2的次方，则此公式计算结果不变。</p>\n<p>V = power(2,ceilling(log(2,4)))  = power(2,ceillling(2)) = power(2,2) = 4</p>\n<p>2. 对于ID为5的记录：</p>\n<p>N = 5 &amp; (V-1) = 5 &amp; 3 = 1</p>\n<p>3. 第二步计算出的结果为1，N&lt;=num，不再需要第三步计算，数据存储在1号分区。</p>\n<p>计算机的位计算效率是非常高的，因此Liner hash在新增/删除/合并/分裂分区场景（需要重新计算并分布数据）速度会快很多，非常适合特别大的数据存储场景（TB级别）。</p>\n<p>Liner hash的缺点是数据的分布可能没有普通hash均匀。</p>\n<p><strong>管理hash分区数量：</strong></p>\n<p>Hash分区无法像range和list那样添加和删除分区，但是你可以用alter table的coalesce partition子句来减少hash分区的数量，用add partition partitions N来增加指定数量的分区。</p>\n<p>例：将employees的hash分区数量由4调整为3：</p>\n<pre><code>ALTER TABLE employees COALESCE PARTITION 1;  -- 移除一个分区</code></pre>\n<p>例：为employees表新增3个hash分区：</p>\n<pre><code>ALTER TABLE employees ADD PARTITION PARTITIONS 3;  -- 新增3个hash分区</code></pre>\n<p><strong>hahs partition和null:</strong></p>\n<p>对于hash partition和key partition，任何表达式对null运算，都会被当做返回为0.</p>\n<p></p>\n<h2 id=\"4.%20Key%20partition(%E9%94%AE%E5%80%BC%E5%88%86%E5%8C%BA)\">4. Key partition(键值分区)</h2>\n<p>Key paritition与hash分区类似，主要区别在于key partition的hash函数是由MySQL server提供的，且使用主键（或非空唯一键）作为分区列：</p>\n<p>例如：创建一个2个分区的key partition table:</p>\n<pre><code>CREATE TABLE k1 (\n    id INT NOT NULL PRIMARY KEY,\n    name VARCHAR(20)\n)\nPARTITION BY KEY()  -- 未指定分区列，自动使用主键\nPARTITIONS 2;</code></pre>\n<pre><code>CREATE TABLE k1 (\n    id INT NOT NULL,  -- 如果未定义not null，创建表会失败\n    name VARCHAR(20),\n    UNIQUE KEY (id)\n)\nPARTITION BY KEY()  -- 未定义主键，自动使用unique key\nPARTITIONS 2;</code></pre>\n<p>另外对于key partition，paritition key也不像其他分区类型那样限制为整数类型，例如，可以使用字符型作为分区键：</p>\n<pre><code>CREATE TABLE tm1 (\n    s1 CHAR(32) PRIMARY KEY   -- 字符型主键，同时作为partition key\n)\nPARTITION BY KEY(s1)\nPARTITIONS 10;</code></pre>\n<p>对于key partition，由于primary key需要同时作为partition key，所以执行alter table ... drop partition会报错（NDB引擎表会重组织并生成隐藏的primary key,不受此限制）。</p>\n<pre><code>mysql&gt; alter table k1 drop primary key;\nERROR 1488 (HY000): Field in list of fields for partition function not found in table\n-- 主键删除失败</code></pre>\n<p>Key partition和hash partition一样，也有liner key分区。</p>\n<pre><code>CREATE TABLE tk (\n    col1 INT NOT NULL,\n    col2 CHAR(5),\n    col3 DATE\n)\nPARTITION BY LINEAR KEY (col1) -- Liner key partition\nPARTITIONS 3;</code></pre>\n<p>Key partition数量的管理方法与hash partition相同。</p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E3%80%81subparitioning(%E5%AD%90%E5%88%86%E5%8C%BA)\">二、subparitioning(子分区)</h1>\n<p>subpartitioning可以在原有分区表的基础上，对每个分区再次进行分区(子分区)。子分区的分区类型可以和父分区不同，因此也叫复合分区。</p>\n<p>下面的示例即对range partition的每个分区再次进行hash partition。父分区p0,p1,p2将各包含2个子分区，因此最终分区的数量为3*2=6个</p>\n<pre><code>CREATE TABLE ts (id INT, purchased DATE)\n    PARTITION BY RANGE( YEAR(purchased) )        -- 父分区采用range partition\n    SUBPARTITION BY HASH( TO_DAYS(purchased) )   -- 子分区采用hash partition\n    SUBPARTITIONS 2                              -- 子分区数量为2\n    (\n        PARTITION p0 VALUES LESS THAN (1990),\n        PARTITION p1 VALUES LESS THAN (2000),\n        PARTITION p2 VALUES LESS THAN MAXVALUE\n    );</code></pre>\n<p>你也可以显示的定义每个子分区的名称，但如果采用这种方式定义，则必须显示指定所有子分区。且子分区的数量必须相同，子分区名称不能重复：</p>\n<pre><code>CREATE TABLE ts (id INT, purchased DATE)\n    PARTITION BY RANGE( YEAR(purchased) )         --父分区为range partition\n    SUBPARTITION BY HASH( TO_DAYS(purchased) )    --子分区为hash partition\n   (\n        PARTITION p0 VALUES LESS THAN (1990) (\n            SUBPARTITION s0,                      -- 显式指定子分区名称和数量\n            SUBPARTITION s1\n        ),\n        PARTITION p1 VALUES LESS THAN (2000) (\n            SUBPARTITION s2,\n            SUBPARTITION s3\n        ),\n        PARTITION p2 VALUES LESS THAN MAXVALUE (\n            SUBPARTITION s4,\n            SUBPARTITION s5\n        )\n    );</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%B4%E6%8A%A4\"><strong>三、分区的基本维护</strong></h1>\n<p>分区表的一大优势就是各个分区可以独立存储和管理。因此大部分在表级别上的管理操作都可以应该在分区上。</p>\n<p><strong>重建分区：</strong></p>\n<p>重建分区功能相当于清除分区中所有记录，然后在重新插入。对于频繁的更新的分区，可以定期使用重建的方式清除碎片。</p>\n<pre><code>ALTER TABLE employees REBUILD PARTITION p0, p1;  -- 重建p0,p1分区\nALTER TABLE employees REBUILD PARTITION ALL;     -- 重建所有分区</code></pre>\n<p><strong>检查分区：</strong></p>\n<p>你可以用check table语句来检查指定分区是否存在损坏：</p>\n<pre><code>ALTER TABLE employees CHECK PARTITION p1;  -- 检查p1分区\nALTER TABLE employees CHECK PARTITION all; -- 检查所有分区</code></pre>\n<p><strong>键值分布统计：</strong></p>\n<p>使用alter table ... analyze partition可以统计指定分区的键值分布，已便更好的生成执行计划：</p>\n<pre><code>ALTER TABLE employees ANALYZE PARTITION p0;  -- 分析p0分区\nALTER TABLE employees ANALYZE PARTITION ALL; -- 分析所有分区</code></pre>\n<p><strong>分区修复：</strong></p>\n<p>使用alter table ... repair partition来修复损坏的分区：</p>\n<pre><code>ALTER TABLE employees REPAIR PARTITION p0; -- 分析p0分区\nALTER TABLE employees REPAIR PARTITION ALL; -- 修复所有分区</code></pre>\n<p><strong>优化分区：</strong></p>\n<p>如果分区存在大量的数据更新，你可以使用optimize partition来回收空间，收集统计信息。其效果相当于在分区上执执行check partition、analyze partition 和 repair partition一样。</p>\n<pre><code>ALTER TABLE employees OPTIMIZE PARTITION p0;</code></pre>\n<p>但是对于innodb存储引擎来说，并不支持optimize partition操作，对单一分区执行会导致所有的分区都重建，谨慎使用（Table does not support optimize on partitions. All partitions will be rebuilt and analyzed.）。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\04d64c51893447f683bd2b7f5ea1db45.png\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-07-28 16:00:43", "summary": "通常情况下，同一张表的数据在物理层面都是存放在一起的。随着业务增长，当同一张表的数据量过大时，会带来管理上的不便。而分区特性可以将一张表从物理层面根据一定的规则将数据划分为多个分区，多个分区可以单独管"}