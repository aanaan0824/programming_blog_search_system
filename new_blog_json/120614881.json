{"blogid": "120614881", "writerAge": "码龄2年", "writerBlogNum": "21", "writerCollect": "43", "writerComment": "1", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "236", "writerName": "Gamer_code", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120614881.jpg", "writerRankTotal": "62334", "writerRankWeekly": "434239", "writerThumb": "9", "writerVisitNum": "11222", "blog_read_count": "6249", "blog_time": "于 2021-11-21 14:05:05 发布", "blog_title": "template的用法(超详细)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>假如我们有以下函数</p>\n<pre><code>int compare(const string &amp;v1,const string &amp;v2)\n{\n    if(v1&lt;v2)return -1;\n    if(v1&gt;v2)return 1;\n    return 0;\n}</code></pre>\n<p>这个函数比较两个值并指出两个值的大于，小于或者等于关系。</p>\n<p></p>\n<h1>1.函数模板</h1>\n<h2>1.</h2>\n<pre><code>template&lt;typename T&gt;\nint compare(const T&amp;v1,const T&amp;v2)\n{\n    if(v1&lt;v2)return -1;\n    if(v1&gt;v2)return 1;\n    return 0;\n}</code></pre>\n<h2>2.使用函数模板</h2>\n<pre><code>int main()\n{\n    //T是int\n    cout&lt;&lt;compare(1,0)&lt;&lt;endl;\n    \n    //T是string\n    string s1=\"hi\",s2=\"world\";\n    cout&lt;&lt;compare(s1,s2)&lt;&lt;endl;\n    return 0;\n\n}</code></pre>\n<h2>3.inline函数模板</h2>\n<p>inline关键字放在template之后，函数类型之前</p>\n<pre><code>//正确写法\ntemplate&lt;typename T&gt;inline T min(const T&amp;,const T&amp;)\n\n//错误写法\ninline template&lt;typename T&gt;T min(const T&amp;,const T&amp;)</code></pre>\n<p></p>\n<p></p>\n<h1>2.类模板</h1>\n<h2>1.定义</h2>\n<pre><code>template&lt;class Type&gt;class Queue{\npublic:\n    Queue();\n    Type &amp;front();\n    const Type &amp;front()const;\n    void push(const Type &amp;);\n    void pop();\n    bool empty()const\nprivate:\n    ...\n};</code></pre>\n<h2>2.使用类模板</h2>\n<p>与使用函数模板形成对比(1.2)，使用类模板时，必须为模板形参显式指定实参</p>\n<pre><code>queue&lt;int&gt;qi;\nQueue&lt;vector&lt;double&gt;&gt;qc;\nQueue&lt;sting&gt;qs;</code></pre>\n<p></p>\n<p></p>\n<h1>模板特化</h1>\n<p>有些时候，我们编写的模板定义并不总是适用于所有类型</p>\n<pre><code>template&lt;typename T&gt;\nint compare(const T&amp;v1,const T&amp;v2)\n{\n    if(v1&lt;v2)return -1;\n    if(v1&gt;v2)return 1;\n    return 0;\n}</code></pre>\n<p>当这个函数的参数类型是C风格字符串时，这个函数不能正常工作(这个函数将比较两个指针在内存中的相对位置，但没有比较指针指向对象的大小)，这时候我们必须提供一个针对C风格字符串的特殊定义,这就是<strong>模板特化</strong></p>\n<h2>1.函数模板的特化</h2>\n<p>特化的形式如下:</p>\n<ul><li>关键字tempalte后面接一对空的尖括号(&lt; &gt;)</li><li>函数名后接模板名和一对尖括号，尖括号中指定这个特化定义的模板形参</li><li>函数形参表</li><li>函数体</li></ul>\n<pre><code>template&lt;&gt;\nint compare&lt;const char *&gt;(const char *const &amp;v1,const char *const &amp;v2)\n{\n    return strcmp(v1,v2);\n}</code></pre>\n<h3>1.声明模板特化</h3>\n<p>与任意函数一样，函数模板特化可以声明而无须定义。</p>\n<pre><code>template&lt;&gt;\nint compare&lt;const char *&gt;(const char *const &amp;,const char *const &amp;);</code></pre>\n<h3>2.函数重载与模板特化</h3>\n<p>如果在特化中省略空的模板形参表template&lt;&gt;,那么结果是函数的重载而不是模板特化</p>\n<pre><code>int compare(const char *const&amp;,const char *const&amp;);\n//声明了该函数的重载版本而不是模板版本</code></pre>\n<h3>3.特化的作用域规则</h3>\n<p>在调用模板的这个特化版本之前，特化的声明必须在作用域中</p>\n<pre><code>template&lt;class T&gt;\nint compare(const T&amp;t1,const T&amp; t2)\n{\n    ...\n}\n\nint main()\n{\n    int i=compare(\"hello\",\"world\");\n    ...\n}\n\ntemplate&lt;&gt;\nint compare&lt;const char *&gt;(const char *const &amp;s1,const char *const &amp;s2)\n{\n    ...\n}\n\n</code></pre>\n<p>这个程序有错误，这个函数将会调用未特化的原模板函数</p>\n<p>特化出现在对该模板实例的调用之后是错误的</p>\n<p></p>\n<h2>2.类模板的特化</h2>\n<h3>1.类特化的定义</h3>\n<pre><code>template&lt;&gt; class Queue&lt;const char*&gt;{\npublic:\n    void push(const char *);\n    void pop();{real_queue.pop();}\n    bool empty()const{return real_queue.empty();}\n    std::string front(){return real_queue.front();}\n    const std::string &amp;front()const{return real_queue.front();}\nprivate:\n    Queue&lt;std::string&gt;real_queue;\n};\n</code></pre>\n<p>类模板特化应该与它所特化的模板定义相同的接口，否则当用户试图使用未定义的成员时会感到奇怪</p>\n<h3>2.在类特化外部定义成员</h3>\n<pre><code>void Queue&lt;const char *&gt;::push(const char*val)\n{\n    return real_queue.push(val);\n}</code></pre>\n<p>在类特化外部定义成员时，成员之前不能加template&lt;&gt;标记</p>\n<p></p>\n<h2>3.特化成员而不特化类</h2>\n<pre><code>template&lt;&gt;\nvoid Queue&lt;const char*&gt;::push(const char *const &amp;val)\n{\n    ...\n}\n\ntemplate&lt;&gt;\nvoid Queue&lt;const char *&gt;::pop()\n{\n    ...\n}</code></pre>\n<p>现在，类类型Queue&lt;const char *&gt;将从通用类模板定义实例化而来，而push和pop函数例外。调用Queue&lt;const char *&gt;对象的push或pop函数时，将调用特化版本；调用其他任意成员时，将从类模板为const char*实例化一个通用版本。</p>\n<p></p>\n<h2>4.类模板的部分特化</h2>\n<p>如果类模板有一个以上的模板形参，我们也许想要特化某些模板形参而非全部，使用类模板的部分特化可以做到这一点:</p>\n<pre><code>template&lt;class T1,class T2&gt;\nclass some_template{\n    //...\n};\n\n\n//部分特化\ntemplate &lt;class T1&gt;\nclass some_template&lt;T1,int&gt;{\n    //...\n}</code></pre>\n<p></p>\n<h3>使用类模板的部分特化</h3>\n<pre><code>some_template&lt;int,string&gt;foo;//使用类模板\nsome_template&lt;string,int&gt;bar;//使用部分特化</code></pre>\n<p>1.foo的实例化类型与提供的部分特化类型不匹配，因此，foo的类型必然从通用类模板实例化</p>\n<p>2.bar选择部分特化模板来实例化。当声明了部分特化的时候，编译器将为实例化选择最特化的模板定义，当没有部分特化可以使用的时候，就使用通用模板定义。</p>\n<p></p>\n<p>ps:函数模板是没有部分特化的，如果声明了一个部分特化的函数模板,编译器会报错</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-11-21 14:05:05", "summary": "假如我们有以下函数这个函数比较两个值并指出两个值的大于，小于或者等于关系。函数模板使用函数模板是是函数模板关键字放在之后，函数类型之前正确写法错误写法类模板定义使用类模板与使用函数模板形成对比，使用类"}