{"blogid": "125259745", "writerAge": "码龄2年", "writerBlogNum": "48", "writerCollect": "2512", "writerComment": "4018", "writerFan": "8743", "writerGrade": "6级", "writerIntegral": "7335", "writerName": "小杰312", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125259745.jpg", "writerRankTotal": "3536", "writerRankWeekly": "8086", "writerThumb": "2664", "writerVisitNum": "112415", "blog_read_count": "1077", "blog_time": "已于 2022-06-22 09:45:09 修改", "blog_title": "设计模式必知必会系列终章", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\">装饰器模式</a></p>\n<p id=\"%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\">工厂方法模式</a></p>\n<p id=\"%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\">抽象工厂模式</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\">适配器模式</a></p>\n<p id=\"%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\">代理模式</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span style=\"color:#0d0016;\"><strong>装饰器模式</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>官方定义:   动态地给⼀个对象增加⼀些额外的职责。就增加功能而言，装饰器模式比生成子类更为灵活。 —— 《设计模式》GoF</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>通俗解释:  装饰器是为了给对象增加额外职责而产生的, 有点粉刷的意思, 房子已经存在了, 在房子的表面加上一层粉刷.      (而且它的优势是相较于继承而言的, 相比直接继承, 装饰器更加灵活, 耦合度更低)                      </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>应对与  ”过度的采取类继承扩展对象的功能“ 的情况</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致子类数量的膨胀。</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>(继承下来就是实实在在的一份负担, 代码的膨胀， 类的膨胀.)  但是很多时候其实我们没有必要去继承， 完全可以使用组合的方式来根据需求动态的实现对象功能的扩展, 以解决子类数量膨胀的问题. 使得功能扩展所带来的影响，代价最小，没必要说来一个新的功能扩展就新创建一个类。</strong></span></p>\n<p><img alt=\"\" height=\"845\" src=\"..\\..\\static\\image\\65344c90f58f4f99a972a4d0e1d65d92.png\" width=\"1200\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>这个类图其实很奇怪, 我刚看见的时候就在想，为啥又是继承, 又是组合的， 继承是为了复用之前的框架, 接口, 裸机 你只有有了之前的房子，才能粉刷装饰吧, 继承体现的是最初的裸机, 接口, 组合完成动态的修饰, 装饰。</strong> <strong>  </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>这个组合还是组合抽象类本身，绝对看的让人很迷，组合的虽然是抽象类本身, 但是抽象类是一个接口，它可以代表它的一切派生类, 这样便使得这个组合对象可扩展性很强.</strong></span></p>\n<p><img alt=\"\" height=\"207\" src=\"..\\..\\static\\image\\6d75e92bcffa47f993eaa1bfa9eef3dc.png\" width=\"945\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>模式要点:</strong></span></p>\n<ol><li><span style=\"color:#0d0016;\"><strong>通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</strong></span></li></ol>\n<p><span style=\"color:#0d0016;\"><strong>记忆技巧:  继承复用接口，组合复用实现细节，动态组合</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>代码场景: 工资计算, 基本员工的工资是天数*100</strong></span><span style=\"color:#0d0016;\"><strong>, 经理员工是基本工资 + 加成add. 老板更是在经理员工的基础上增加10倍加成</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>实现代码如下:</strong></span></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\n//此处我没有再写componet类了, 想写的兄弟可以添加喔\nclass Context {\npublic:\n\tint day;//天数\n\tint add;//加成\n};\n\n//分发奖金: 普通员工仅仅只是day * 100  \n//经理  还有加成\n//老总等等加成更加牛逼， 在经理的基础上再10倍加成\n\n//基础员工工资\n//DecoratorClass装饰器基类\nclass BaseWocker {\npublic:\n\tBaseWocker(BaseWocker* _base) : base(_base) {\n\n\t}\n\tvirtual int CalculateSlary(Context&amp; ctx) {\n\t\t//计算基本工资\n\t\treturn ctx.day * 100;\n\t}\n\tvirtual ~BaseWocker() {}\nprotected:\n\tBaseWocker* base;\n};\n\n//继承复用接口\n//BaseWocker继承下来的是裸机, 最初框架， 接口\n//组合扩展细节. 运算.\nclass Manager : BaseWocker {\npublic:\n\tManager(BaseWocker* _base = nullptr) : BaseWocker(_base) {\n\n\t}\n\n\tvirtual int CalculateSalary(Context&amp; ctx) {\n\t\tint basesalary = base-&gt;CalculateSlary(ctx);\n\t\t//...在组合对象的基础上进行扩展运算\n\t\treturn basesalary + ctx.add;\n\t}\n};\n\n//Decorator\nclass Boss : public BaseWocker {\npublic:\n\tBoss(BaseWocker* _base) : BaseWocker(_base) {\n\n\t}\n\n\tvirtual int CalculateSalary(Context&amp; ctx) {\n\t\tint basesalary = base-&gt;CalculateSlary(ctx);\n\t\t//...在组合对象的基础上进行扩展运算\n\t\treturn (basesalary + (ctx.add * 10));\n\t}\n};\n</code></pre>\n<p>如下是大佬写的一份代码: 大家也可以赏析一下:</p>\n<pre><code class=\"language-cpp\">//业务操作, Component抽象基类\nclass Stream{\n\npublic：\n    virtual char Read(int number)=0;\n    virtual void Seek(int position)=0;\n    virtual void Write(char data)=0;\n    \n    virtual ~Stream(){}\n};\n\n//主体类具体的Component类\nclass FileStream: public Stream{\npublic:\n    virtual char Read(int number){\n        //读文件流\n    }\n    virtual void Seek(int position){\n        //定位文件流\n    }\n    virtual void Write(char data){\n        //写文件流\n    }\n\n};\n\nclass NetworkStream :public Stream{\npublic:\n    virtual char Read(int number){\n        //读网络流\n    }\n    virtual void Seek(int position){\n        //定位网络流\n    }\n    virtual void Write(char data){\n        //写网络流\n    }\n    \n};\n\nclass MemoryStream :public Stream{\npublic:\n    virtual char Read(int number){\n        //读内存流\n    }\n    virtual void Seek(int position){\n        //定位内存流\n    }\n    virtual void Write(char data){\n        //写内存流\n    }\n    \n};\n\n//扩展操作\n//扩展操作采取的是装饰器类, has a 的特征\nDecoratorStream: public Stream{\nprotected:\n    Stream* stream;//...\n    \n    DecoratorStream(Stream * stm):stream(stm){\n    \n    }\n    \n};\n\n//具体的decorator类\nclass CryptoStream: public DecoratorStream {\n \n\npublic:\n    CryptoStream(Stream* stm):DecoratorStream(stm){\n    \n    }\n    \n    \n    virtual char Read(int number){\n       \n        //额外的加密操作...\n        stream-&gt;Read(number);//读文件流\n    }\n    virtual void Seek(int position){\n        //额外的加密操作...\n        stream::Seek(position);//定位文件流\n        //额外的加密操作...\n    }\n    virtual void Write(byte data){\n        //额外的加密操作...\n        stream::Write(data);//写文件流\n        //额外的加密操作...\n    }\n};\n\n\n\nclass BufferedStream : public DecoratorStream{\n    \n    Stream* stream;//...\n    \npublic:\n    BufferedStream(Stream* stm):DecoratorStream(stm){\n        \n    }\n    //...\n};</code></pre>\n<h1 id=\"%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\"><span style=\"color:#0d0016;\"><strong>工厂方法模式</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>官方定义: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。——《设计模式》GoF</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>通俗解释：简单来说就是在工厂基类中定义一个抽象接口,  将整个接口的实例化延迟到一个具体的子类工厂(具体工厂)，解耦合.                     ----    之后对于工厂的依赖都是依赖稳定的工厂基类</strong></span></p>\n<p><img alt=\"\" height=\"688\" src=\"..\\..\\static\\image\\46ccac010b464b89adbed5bf49ee12ad.png\" width=\"1200\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>这个类图感觉不算特别完善, 最好可以在Factory下面在继承具体的Factory感觉比较好.</strong></span></p>\n<p><strong><span style=\"color:#0d0016;\">实现代码如下：</span></strong></p>\n<pre><code class=\"language-cpp\">//抽象产品类\nclass Operator {\npublic:\n\tOperator(int l, int r) \n\t\t: lhs(l)\n\t\t, rhs(r) {\n\t}\n\n\t//抽象操作\n\tvirtual int Operation() = 0; \n\tvirtual ~Operator() {}\nprotected:\n\tint lhs;\n\tint rhs;\n};\n\n//具体产品类\nclass AddOperator : public Operator{\npublic:\n\tAddOperator(int l, int r)\n\t\t: Operator(l, r) {\n\n\t}\n\tvirtual int Operation() {\n\t\treturn lhs + rhs;\n\t}\n};\n\nclass SubOperator : public Operator{\n\npublic:\n\tSubOperator(int l, int r)\n\t\t: Operator(l, r) {\n\n\t}\n\tvirtual int Operation() {\n\t\treturn lhs - rhs;\n\t}\n};\n\nclass MulOperator : public Operator{\n\npublic:\n\tMulOperator(int l, int r)\n\t\t: Operator(l, r) {\n\n\t}\n\tvirtual int Operation() {\n\t\treturn lhs * rhs;\n\t}\n};\n\n\nclass DivOperator : public Operator{\npublic:\n\tDivOperator(int l, int r)\n\t\t: Operator(l, r) {\n\n\t}\n\tvirtual int Operation() {\n\t\tif (rhs == 0) {\n\t\t\tcerr &lt;&lt; \"zero div\" &lt;&lt; endl;\n\t\t\treturn 0;\n\t\t}\n\t\treturn lhs / rhs;\n\t}\n};\n\n\n//工厂基类\nclass OperatorFactory {\npublic:\n\t//创建对象的接口, 实例化延迟到子类， 工厂方法FactoryMethod\n\tvirtual Operator* CreateMethod(int, int) = 0;\n};\n\n//具体工厂\nclass AddOperatorFactory : public OperatorFactory {\npublic:\n\tvirtual Operator* CreateMethod(int lhs, int rhs) override {\n\t\treturn new AddOperator(lhs, rhs);\n\t}\n};\n\nclass SubOperatorFactory : public OperatorFactory {\npublic:\n\tvirtual Operator* CreateMethod(int lhs, int rhs) {\n\t\treturn new SubOperator(lhs, rhs);\n\t}\n};\n\nclass MulOperatorFactory : public OperatorFactory {\npublic:\n\tvirtual Operator* CreateMethod(int lhs, int rhs) {\n\t\treturn new MulOperator(lhs, rhs);\n\t}\n};\n\nclass DivOperatorFactory : public OperatorFactory {\npublic:\n\tvirtual Operator* CreateMethod(int lhs, int rhs) {\n\t\treturn new DivOperator(lhs, rhs);\n\t}\n};\n\n\nint main() {\n\n\tint l;\n\tint r;\n\tchar op;\n\n\twhile (1) {\n\t\tcout &lt;&lt; \"请输入lhs, rhs: \" &lt;&lt; endl;\n\t\tcin &gt;&gt; l &gt;&gt; r;\n\t\tcout &lt;&lt; \"请输入操作方法op: \" &lt;&lt; endl;\n\t\tcin &gt;&gt; op;\n\t\tOperatorFactory* factory = nullptr;\n\t\t//创建工厂\n\t\tswitch (op) {\n\t\t\tcase '+': {\n\t\t\t\tfactory = new AddOperatorFactory();\n\t\t\t} break;\n\t\t\tcase '-': {\n\t\t\t\tfactory = new SubOperatorFactory();\n\t\t\t} break;\n\t\t\tcase '*': {\n\t\t\t\tfactory = new MulOperatorFactory();\n\t\t\t} break;\n\t\t\tcase '/': {\n\t\t\t\tfactory = new DivOperatorFactory();\n\t\t\t} break;\n\t\t}\n\t\t//生产产品运行Operaction\n\t\tcout &lt;&lt; factory-&gt;CreateMethod(l, r)-&gt;Operation() &lt;&lt; endl;\n\t}\n\tgetchar();\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#0d0016;\"><strong> 要点:</strong></span></p>\n<ol><li><span style=\"color:#0d0016;\"><strong>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。</strong></span></li></ol>\n<p><span style=\"color:#0d0016;\"><strong>使用场景:</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>解决创建过程比较复杂，希望对外隐藏这些细节； </strong></span></p>\n<ol><li><span style=\"color:#0d0016;\"><strong>比如连接池，线程池；</strong></span></li><li><span style=\"color:#0d0016;\"><strong>隐藏对象真实类型； </strong></span></li><li><span style=\"color:#0d0016;\"><strong>对象创建会有很多参数来决定如何创建； </strong></span></li><li><span style=\"color:#0d0016;\"><strong>创建对象有复杂的依赖关系；</strong></span></li></ol>\n<p><span style=\"color:#0d0016;\"><strong>本质记忆技巧:  延迟到子类进行创建实现</strong></span></p>\n<h1 id=\"%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span style=\"color:#0d0016;\"><strong>抽象工厂模式</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。——《设计模式》GoF</strong></span></p>\n<p><strong><span style=\"color:#0d0016;\">通俗解释：本质上来讲, 无论是抽象工厂模式, 还是简工厂方法模式，均是属于对象创建模式. 抽象工厂模式相对于工厂方法而言核心差别在于它是负责相关联的一系列的产品, 对象的创建. 不再是单个产品的创建, 而是系列产品的创建, 两者差别仅此而已.</span></strong></p>\n<h1 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"863\" src=\"..\\..\\static\\image\\973d172f6c7c4a15b7a6b21dd01e2153.png\" width=\"1136\"/></h1>\n<p><strong><span style=\"color:#0d0016;\">一个抽象工厂下面的两个具体工厂生产的两种产品是搭配产品。好比如说：瓶身与瓶盖两个产品的加工厂. 产品相互依赖，配套.  可以进行扩展, 比如说瓶子也有种类，矿泉水瓶，可口可乐瓶子，芬达瓶子等等. 这个瓶身瓶盖一定是配套生产的.       (对应一系列相关，相互依赖的对象)</span></strong></p>\n<pre><code class=\"language-cpp\">//产品抽象类A\nclass IProductA {\npublic:\n\t//对于产品的操作\n\tvirtual void Operation() = 0;\n\tvirtual ~IProductA() {}\n};\n\n//产品抽象类B\nclass IProductB {\npublic:\n\t//对于产品的操作\n\tvirtual void Operation() = 0;\n\tvirtual ~IProductB() {}\n};\n\n//抽象工厂 A 瓶身, B 瓶盖\nclass IFactory {\npublic:\n\tvirtual IProductA* FactoryMethodA() = 0;//创建产品A\n\tvirtual IProductB* FactoryMethodB() = 0;//创建产品B\n\tvirtual ~IFactory() {}\n};\n\n\n//具体的产品\nclass PingSheng : public IProductA {\npublic:\n\tvirtual void Operation() {\n\t\tcout &lt;&lt; \"我是瓶身\" &lt;&lt; endl;\n\t}\n};\n\nclass PingGai : public IProductB {\npublic:\n\tvirtual void Operation() {\n\t\tcout &lt;&lt; \"我是瓶盖\" &lt;&lt; endl;\n\t}\n\t\n};\n\n//具体的工厂\nclass PingZiFactory : public IFactory {\n\tvirtual IProductA* FactoryMethodA() {\n\t\treturn new PingSheng();\n\t}\n\tvirtual IProductB* FactoryMethodB() {\n\t\treturn new PingGai();\n\t}\n};</code></pre>\n<p><span style=\"color:#0d0016;\"><strong>记忆技巧:  配套产品生产</strong></span></p>\n<h1 id=\"%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span style=\"color:#0d0016;\"><strong>适配器模式</strong></span></h1>\n<p><span style=\"color:#0d0016;\"><strong>定义: 将一个类的接口转换为用户需要的另一个接口。Adapter使得原本由于接口不兼容不能在一起工作的那些类可以一起工作。 ——《设计模式》GoF</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>通俗解释：简单来说就是适配接口, 本来一个类的接口是和用户需要的接口不统一的, 但是现在需要使用这个类的一些功能， 于是可以抽象出来一个中间的适配器类, 进行组合这个需要使用的类对象，并且适配接口，进而实现接口不兼容的类功能, 接口也可以使用.</strong></span></p>\n<p><img alt=\"\" height=\"523\" src=\"..\\..\\static\\image\\f2a8cb9f860c42658e2919860ae432b9.png\" width=\"1200\"/></p>\n<p><strong><span style=\"color:#0d0016;\">说到适配器模式，我还想说所有学习C++的大家，只要学了STL, 容器适配器学的还不错的，仿写过stack,queue两个容器适配器的实现的，你们都已经使用了适配器模式了. 只是当时还不知道自己用的是适配器模式. 想想好像确实就是适配新的接口.       </span></strong></p>\n<p><strong><span style=\"color:#0d0016;\">push_back-----&gt; push   pop_back ----&gt; pop   针对stack而言</span></strong></p>\n<p><span style=\"color:#0d0016;\"><strong>场景引入, 简单实现一下适配器模式</strong></span></p>\n<pre><code class=\"language-cpp\">//目标接口, 新接口.\nclass ITarget {\npublic:\n\tvirtual void Request() = 0;\n};\n\n//需要复用的老旧接口\nclass Adaptee {\npublic:\n\tvirtual void RequestOne() = 0;\n\tvirtual void RequestTwo() = 0;\n};\n\n//具体的旧类型, 老旧的库， 需要适配复用其中的Request\nclass Old : public Adaptee {\npublic:\n\tvirtual void RequestOne() {\n\t\tcout &lt;&lt; \"处理需求1\" &lt;&lt; endl;\n\t}\n\n\tvirtual void RequestTwo() {\n\t\tcout &lt;&lt; \"处理需求2\" &lt;&lt; endl;\n\t}\n};\n\n//接口的不一致，需要产生一个Adapter接口适配器类, 适配接口\n//适配ITarget目标类接口\n\n//继承目标类适配接口\nclass Adapter : public ITarget {\nprotected:\n\tAdaptee* adaptee;//组合复用老旧接口\npublic:\n\tvirtual void Request() {\n\t\tadaptee-&gt;RequestOne();\n\t\tadaptee-&gt;RequestTwo();\n\t}\n};\n\nclass Client {\nprivate:\n\tITarget* target;\npublic:\n\tvoid Click() {// 客户点击, 目标执行需求\n\t\ttarget-&gt;Request();\n\t}\n};</code></pre>\n<p> <span style=\"color:#0d0016;\"><strong>要点总结:</strong></span></p>\n<ol><li><span style=\"color:#0d0016;\"><strong>Adapter模式主要应用于 \"希望复用一些现成类， 但是接口又与复用环境不一致的情况\", 在遗留代码复用, 类库迁移方面非常有用</strong></span></li><li><span style=\"color:#0d0016;\"><strong>适配的方式使用的是对象组合的方式， 更加符合松耦合的设计原则</strong></span></li><li><span style=\"color:#0d0016;\"><strong>原来的接口是稳定的，新的外来的需求是变化的，那么可以通过继承原来的接口，让原来的接口继续保持稳定，在子类通过组合的方式来扩展功能。   </strong></span>  <span style=\"color:#0d0016;\"><strong>继承原来的接口(用户需要使用的接口， 复用其他类对象的接口，子类中组合扩展)</strong></span></li></ol>\n<p><span style=\"color:#0d0016;\"><strong>记忆技巧:  继承使得接口转换匹配, 组合复用已有类功能</strong></span></p>\n<h1 id=\"%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span style=\"color:#0d0016;\">代理模式</span></h1>\n<p><span style=\"color:#0d0016;\"><strong>官方定义：为其他对象提供⼀种代理以控制（隔离, 使用接口）对这对象的访问。</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>——《设计模式》GoF</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>通俗解释：代理完成职责，代理一个具体类完成职责(接口职责, 相同的接口), 常见的代理, 婚庆代理， 代理商.</strong></span></p>\n<p><img alt=\"\" height=\"442\" src=\"..\\..\\static\\image\\4d0040c2809e4a5e9c98a11856ce65b1.png\" width=\"1119\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>代理层出现的原因，背景，优势.</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>在有些系统中，为了某些对象的纯粹性，只进行了功能相关封装（稳定点），后期添加了其他功能 需要对该对象进行额外操作（变化点），为了隔离变化点（也就是不直接在稳定点进行修改，这样 会让稳定点也变得不稳定），可以抽象一层代理层</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>首先解释一下纯粹性：纯粹性指的是接口中仅仅只是实现功能，而不需要进行权限判断，引用计数等等其他的额外操作</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>代理类是一个中介层, 并不做具体的业务细节实现。而是介于客户类和具体的委托代理类之间的中间层. 作用在于对委托代理类使用前后的一些处理扩展, 让真正的RealSubject类保持纯粹  真正的业务功能其实还是委托代理类实现的。代理类是做中间处理和扩展的.        (对已有对象的额外操作, 放在代理层)</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>简单实现:</strong></span></p>\n<pre><code class=\"language-cpp\">class ISubject {\npublic:\n\tvirtual void Handle() = 0;\n\tvirtual ~ISubject() {}\n};\n\n\n//真实的Subject对象\n//是一个很纯粹的类. 很稳定.\nclass RealSubject : public ISubject {\npublic:\n\tvirtual void Handle() {\n\t\t//纯粹的功能实现\n\t}\n};\n\n//代理类. 扩展变化\nclass Proxy1 : public  ISubject {\npublic:\n\tProxy1(ISubject* subject) : _subject(subject) {\n\t}\n\n\t//实现功能扩展.\n\n\tvirtual void Handle() {\n\t\t//在访问RealSubject之前的一些操作\n\n\t\t//if (是否不可以访问) return;\n\t\t_subject-&gt;Handle();\n\n\t\t//访问玩之后的一些操作\n\t\t++count;//++访问计数等等\n\t}\nprivate:\n\tISubject* _subject;\n\tstatic int count;\n};\n\nint Proxy1::count = 0;\n\n\n//代理模式2扩展处理\n//在分布式系统中出现的，skynet actor等\n\n// 在分布式系统当中  skynet actor\nclass Proxy2 : public ISubject {\npublic:\n\tvirtual void Handle() {\n\t\t// 在访问 RealSubject 之前做一些处理\n\n\t\t// 发送到数据到远端  网络处理  同步非阻塞 ntyco c协程\n\t\t//IResult * val = rpc-&gt;call(\"RealSubject\", \"Handle\");\n\n\t\t// 在访问 RealSubject 之后做一些处理\n\t}\nprivate:\n\t/*void callback(IResult * val) {\n\t// 在访问 RealSubject 之后做一些处理\n\t}*/\n};\n</code></pre>\n<p><span style=\"color:#0d0016;\"><strong>模式要点：</strong></span></p>\n<ol><li><span style=\"color:#0d0016;\"><strong>远程代理（隐藏⼀个对象存在不同的地址空间的事实），虚代理（延迟加载lazyload），保护代理（在代理前后做额外操作，权限管理，引用计数等）</strong></span></li><li><span style=\"color:#0d0016;\"><strong>在分布式系统中，actor模型（skynet）等常用的设计模式</strong></span></li></ol>\n<p><span style=\"color:#0d0016;\"><strong>本质：控制对象访问, 代理RealSubject， 处理对RealSubject访问前后的扩展需求. 权限验证, 引用计数等</strong></span></p>\n<blockquote>\n<ol><li><span style=\"color:#0d0016;\"><strong>好了各位老铁们，设计模式到此结束了.感谢各位兄弟们从一到现在的陪伴</strong></span></li><li><span style=\"color:#0d0016;\"><strong>设计模式的学习确实是有点虚无的.  特别是我们这些没啥工作经验的，学完之后根本不知道咋用到实际项目中实现重构项目的设计，持续重构形成自己的设计模式。 我们也没有经历过没有任何设计原则的Bad Smell Code的维护，所以体会是没有实践过的前辈们深入的</strong></span></li><li><span style=\"color:#0d0016;\"><strong>但是我觉得提早了解和具备遵循设计原则这样的大思想是我们需要具备的，不一定强行套入设计模式，可以先是我们的代码遵循设计原则。    遵循设计原则的代码往往更容易重构和维护</strong></span></li><li><span style=\"color:#0d0016;\"><strong>IT技术路漫长久远。。                 ----  感谢各位大佬的支持，让我们继续加油，工作的前辈升职加薪，学习的友友学业有成，争取保研</strong></span></li></ol>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-22 09:45:09", "summary": "目录装饰器模式工厂方法模式抽象工厂模式编辑适配器模式代理模式装饰器模式官方定义动态地给个对象增加些额外的职责。就增加功能而言，装饰器模式比生成子类更为灵活。《设计模式》通俗解释装饰器是为了给对象增加额"}