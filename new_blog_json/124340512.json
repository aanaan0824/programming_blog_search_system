{"blogid": "124340512", "writerAge": "码龄4年", "writerBlogNum": "35", "writerCollect": "208", "writerComment": "40", "writerFan": "41", "writerGrade": "4级", "writerIntegral": "1001", "writerName": "浪迹_", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124340512.jpg", "writerRankTotal": "54296", "writerRankWeekly": "46772", "writerThumb": "63", "writerVisitNum": "75875", "blog_read_count": "2285", "blog_time": "已于 2022-04-24 17:53:24 修改", "blog_title": "Unity zSpace 开发", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1></h1>\n<h1>本篇博客适合没有zSpace开发经验的朋友，从下载SDK到配置发布、UI事件、触控笔事件。。</h1>\n<p></p>\n<p></p>\n<h1>一、项目设置</h1>\n<p></p>\n<blockquote>\n<h2><strong>第一步：<a class=\"link-info\" href=\"https://developer.zspace.com/downloads\" title=\"官网\">官网</a>下载zCore和zView插件，下载并安装Unity2018（我的是2018.4.3）</strong></h2>\n</blockquote>\n<p><img alt=\"\" height=\"969\" src=\"..\\..\\static\\image\\7c1ebb06d21f49759063f06f472bb7d7.png\" width=\"1200\"/></p>\n<blockquote>\n<h2><strong>第二步：将下载的zCore6.0和zView6.0导入到Unity的工程中，导入后会生成两个文件夹</strong></h2>\n</blockquote>\n<p></p>\n<p><img alt=\"\" height=\"312\" src=\"..\\..\\static\\image\\0050f6ea24394de5865209c9306b164a.png\" width=\"498\"/> 3</p>\n<blockquote>\n<h2>第三步：设置你的Unity工程</h2>\n</blockquote>\n<p>1.Edit—ProjectSettings—Player—OtherSetting—Rendering—ColorSpace改为Gamma</p>\n<p>2.Edit—ProjectSettings—Player—OtherSetting—AutoGraphicsAPIforWindows取消勾选</p>\n<p>3.Edit—ProjectSettings—Player—OtherSetting—GraphicsAPIsforWindows-添加OpenGLCore，其他全部删除</p>\n<p><img alt=\"\" height=\"569\" src=\"..\\..\\static\\image\\cccdfcf648b94f00b05c8a0335612ef8.png\" width=\"839\"/></p>\n<p>4.Edit—ProjectSettings—Player—OtherSetting—Configuration—ScriptingRuntimeVersion改为4.x</p>\n<p><img alt=\"\" height=\"577\" src=\"..\\..\\static\\image\\b14a32838c21452abcd64bb1d03ded79.png\" width=\"853\"/></p>\n<p>5.Edit—ProjectSettings—Player—XRSetting中勾选Virtual Reality Supported</p>\n<p>6.Edit—ProjectSettings—Player—XRSetting—Virtual Reality SDKs添加Stereo Display (non head-mounted)</p>\n<p><img alt=\"\" height=\"569\" src=\"..\\..\\static\\image\\46d3224a61434f60b49176693ff0bec0.png\" width=\"839\"/></p>\n<p> 7.Edit—ProjectSettings—Player—Resolution and Presentation—Run In Back ground选中（如果不用zView可以不设置此项）</p>\n<p><img alt=\"\" height=\"569\" src=\"..\\..\\static\\image\\d3ada61b9bb640ac9b3ab2b3166b4e10.png\" width=\"839\"/></p>\n<blockquote>\n<h2>第四步：查看zCore自带案例，如下</h2>\n</blockquote>\n<p><img alt=\"\" height=\"311\" src=\"..\\..\\static\\image\\30223e7fd5044160a38d718ee5988826.png\" width=\"751\"/></p>\n<blockquote>\n<h2> 第五步：发布测试，找到一个适合自己想要功能的场景，发布到PC后，将发布程序拷贝到zSpace设备上运行即可</h2>\n</blockquote>\n<blockquote>\n<h2>第六步：如果你的软件不使用zView的话忽略此项</h2>\n</blockquote>\n<p>1.将zView预制体拖拽到场景中</p>\n<p>2.zView组件如下：</p>\n<p><img alt=\"\" height=\"660\" src=\"..\\..\\static\\image\\8124f1b7fe624ad1878950bc6c8fde26.png\" width=\"735\"/></p>\n<p>配置zView</p>\n<p>大多数情况下，ZView应该在你第一次测试时就能工作。然而，越来越复杂的场景更有可能遇到图形问题时，通过zView的增强现实模式。在zView的检查器字段中出现的公共属性可以用来管理这种复杂性。</p>\n<p>Ignore Layers</p>\n<p>你可以在zView中隐藏对象，方法是把它们放在可以忽略的层上。有一些常见的元素需要考虑zView忽略。在zView表示过程中，UI元素通常不是内容焦点，而是被隐藏的主要考虑因素。其他可能值得忽略的元素将是周边环境艺术，在AR模式下不能正确或清晰地呈现。</p>\n<p>Mask Layer</p>\n<p>zView在zSpace显示周围放置一个蒙版，在显示表面上有一个洞。设置到此层的对象将只通过此显示蒙版可见。这个遮罩将优先于正视差框遮罩，不管遮罩对象是负视差还是正视差。</p>\n<p>Mask Render Queue</p>\n<p>增强现实模式的框蒙版的渲染队列优先级。这只在启用ARModeEnableTransparency时使用，通常应该分配小于2000(不透明几何)的值，以确保它的深度将在渲染任何不透明几何之前进行渲染。</p>\n<p>Mask Size</p>\n<p>增强现实模式的盒子面具的尺寸，单位是米。盒子面具不同于</p>\n<p>Show Mask</p>\n<p>在Unity Editor的SceneView窗口中启用增强现实模式的框掩码的调试可视化。</p>\n<p>Enable Transparency</p>\n<p>如果未启用，则强制增强现实模式的虚拟相机渲染的所有非蒙版像素的alpha值为1。默认情况下，这是禁用的，因为大多数与不透明和透明几何相关的标准着色器要么在它们的alpha通道中有不正确的值，要么不写它们的alpha通道到帧缓冲区。</p>\n<p>Active ZCamera</p>\n<p>确保这个属性被分配给在任何时候都在积极使用的ZCamera。如果没有分配，ZView将在awake时调用. findobjectoftype()来自己找到它，但理想情况下它将手工分配。</p>\n<p> 连接到zView（放到Start()中）：</p>\n<pre><code>IntPtr connection = zView.GetCurrentActiveConnection();\nif(connection == IntPtr.Zero)\n{\n    zView.ConnectToDefaultViewer();\n}\n</code></pre>\n<p>示例：</p>\n<pre><code class=\"language-cs\">    private void Start()\n    {\n#if !UNITY_EDITOR\n        ZView _zView = GameObject.FindObjectOfType&lt;ZView&gt;();\n        IntPtr connection = _zView.GetCurrentActiveConnection();\n        if (connection == IntPtr.Zero)\n        {\n            _zView.ConnectToDefaultViewer();\n        }\n#endif\n    }\n</code></pre>\n<p> 看到此项表示你的zSpace工程已经全部配置完成，点击发布运行起来吧~</p>\n<p>上述在官网都可查到出处<a class=\"has-card\" href=\"https://developer.zspace.com/docs/unity3d-zcore-6-guide\" title=\"Unity3D zCore 6.0: Developer Guide (zspace.com)\"><span class=\"link-card-box\"><span class=\"link-title\">Unity3D zCore 6.0: Developer Guide (zspace.com)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://developer.zspace.com/docs/unity3d-zcore-6-guide</span></span></a> </p>\n<blockquote>\n<h1>二、UI系统</h1>\n</blockquote>\n<blockquote>\n<h2>1.画布设置</h2>\n</blockquote>\n<p>在zSpace-Core-Prefabs中可以看到ZCanvas预制体，拖拽到场景中，ZCanvas默认渲染模式是WorldSpace，将zSpace的相机拖拽至EventCamera即可，并确保ZCanvas添加了以下组件</p>\n<p><img alt=\"\" height=\"657\" src=\"..\\..\\static\\image\\3166612ea63240b8a4734d7d19a6554a.png\" width=\"1004\"/></p>\n<blockquote>\n<h2>2.Button事件</h2>\n</blockquote>\n<p>UI事件：经过测试，button.onClick.AddListener()的UI事件可以触发，而手动绑定的无法触发</p>\n<p><img alt=\"\" height=\"222\" src=\"..\\..\\static\\image\\7879cd28d4a5447d8e5fc1d7a60783a2.png\" width=\"880\"/></p>\n<p>3D事件：通过引入命名空间IBeginDragHandler, IDragHandler, IEndDragHandler来实现</p>\n<p><img alt=\"\" height=\"207\" src=\"..\\..\\static\\image\\5c2c1114a73c4c41a14fa921596d96f6.png\" width=\"1077\"/></p>\n<p>触控笔中键：PointerEventData.InputButton.Left</p>\n<p>触控笔左键：PointerEventData.InputButton.Middle</p>\n<p>触控笔右键：PointerEventData.InputButton.Right</p>\n<p>示例：用触控笔来实现对模型的拖拽、旋转、放大、缩小功能：</p>\n<pre><code class=\"language-cs\">\n//\n//  Copyright (C) 2007-2020 zSpace, Inc.  All Rights Reserved.\n//\n\n\nusing UnityEngine;\nusing UnityEngine.EventSystems;\n\nusing zSpace.Core.EventSystems;\nusing zSpace.Core.Input;\n\nnamespace zSpace.Core.Samples\n{\n    public class MyDraggable : ZPointerInteractable, IBeginDragHandler, IDragHandler, IEndDragHandler\n    {\n        \n        // Public Methods\n        \n\n        public override ZPointer.DragPolicy GetDragPolicy(ZPointer pointer)\n        {\n            if (pointer is ZMouse)\n            {\n                return ZPointer.DragPolicy.LockToScreenAlignedPlane;\n            }\n\n            if (pointer is ZStylus)\n            {\n                return ZPointer.DragPolicy.LockHitPosition;\n            }\n\n            return base.GetDragPolicy(pointer);\n        }\n\n        public void OnBeginDrag(PointerEventData eventData)\n        {\n            ZPointerEventData pointerEventData = eventData as ZPointerEventData;\n            if (pointerEventData == null ||\n                pointerEventData.button != PointerEventData.InputButton.Left)\n            {\n                return;\n            }\n\n            Pose pose = pointerEventData.Pointer.EndPointWorldPose;\n\n            // Cache the initial grab state.\n            this._initialGrabOffset =\n                Quaternion.Inverse(this.transform.rotation) *\n                (this.transform.position - pose.position);\n\n            this._initialGrabRotation =\n                Quaternion.Inverse(pose.rotation) *\n                this.transform.rotation;\n\n            // If the grabbable object has a rigidbody component,\n            // mark it as kinematic during the grab.\n            var rigidbody = this.GetComponent&lt;Rigidbody&gt;();\n            if (rigidbody != null)\n            {\n                this._isKinematic = rigidbody.isKinematic;\n                rigidbody.isKinematic = true;\n            }\n\n            // Capture pointer events.\n            pointerEventData.Pointer.CapturePointer(this.gameObject);\n        }\n\n        private float z;\n        private void Start()\n        {\n            z = transform.localPosition.z;\n        }\n        public void OnDrag(PointerEventData eventData)\n        {\n            ZPointerEventData pointerEventData = eventData as ZPointerEventData;\n            if (pointerEventData == null)\n            {\n                return;\n            }\n\n            if (pointerEventData.button == PointerEventData.InputButton.Left)\n            {\n                Pose pose = pointerEventData.Pointer.EndPointWorldPose;\n\n                // Update the grab object's rotation.\n                this.transform.rotation = pose.rotation * this._initialGrabRotation;\n\n                // Update the grab object's position.\n                this.transform.position = pose.position + (this.transform.rotation * this._initialGrabOffset);\n\n            }\n            if (pointerEventData.button == PointerEventData.InputButton.Right)\n            {\n                if (transform.position.z &gt; z)\n                {\n                    transform.localScale = new Vector3(transform.localScale.x + 0.01f, transform.localScale.y + 0.01f, transform.localScale.z + 0.01f);\n                }\n                else if(transform.position.z &lt; z)\n                {\n                    transform.localScale = new Vector3(transform.localScale.x - 0.01f, transform.localScale.y - 0.01f, transform.localScale.z - 0.01f);\n                }\n                //transform.localScale = new Vector3(transform.localScale.x + 0.01f, transform.localScale.y + 0.01f, transform.localScale.z + 0.01f);\n            }\n            //if (pointerEventData.button == PointerEventData.InputButton.Middle)\n            //{\n            //    transform.localScale = new Vector3(transform.localScale.x - 0.01f, transform.localScale.y - 0.01f, transform.localScale.z - 0.01f);\n            //}\n        }\n\n        public void OnEndDrag(PointerEventData eventData)\n        {\n            ZPointerEventData pointerEventData = eventData as ZPointerEventData;\n            if (pointerEventData == null ||\n                pointerEventData.button != PointerEventData.InputButton.Left)\n            {\n                return;\n            }\n\n            // Release the pointer.\n            pointerEventData.Pointer.CapturePointer(null);\n\n            // If the grabbable object has a rigidbody component,\n            // restore its original isKinematic state.\n            var rigidbody = this.GetComponent&lt;Rigidbody&gt;();\n            if (rigidbody != null)\n            {\n                rigidbody.isKinematic = this._isKinematic;\n            }\n        }\n\n        \n        // Private Members\n        \n\n        private Vector3 _initialGrabOffset = Vector3.zero;\n        private Quaternion _initialGrabRotation = Quaternion.identity;\n        private bool _isKinematic = false;\n    }\n}\n</code></pre>\n<p>上述皆参考ZCore自带脚本：Draggable</p>\n<p class=\"img-center\"><img alt=\"\" height=\"467\" src=\"..\\..\\static\\image\\c7844e6c2a5b40d8aae06f76977ec71d.png\" width=\"228\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>目前也在学习阶段，有问题随时留言讨论学习~ </p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-24 17:53:24", "summary": "本篇博客适合没有开发经验的朋友，从下载到配置发布、事件、触控笔事件。。一、项目设置第一步：官网官网下载和插件，下载并安装我的是第二步：将下载的和导入到的工程中，导入后会生成两个文件夹第三步：设置你的工"}