{"blogid": "126669695", "writerAge": "码龄9年", "writerBlogNum": "725", "writerCollect": "5262", "writerComment": "609", "writerFan": "23065", "writerGrade": "7级", "writerIntegral": "19341", "writerName": "Bruceoxl", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126669695.jpg", "writerRankTotal": "432", "writerRankWeekly": "484", "writerThumb": "1157", "writerVisitNum": "1509098", "blog_read_count": "232", "blog_time": "于 2022-09-02 20:33:08 发布", "blog_title": "《嵌入式 – GD32开发实战指南》第20章 GD32的存储结构", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-dracula\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>开发环境：</strong><br/> MDK：Keil 5.30<br/> 开发板：GD32F207I-EVAL<br/> MCU：GD32F207IK</p>\n<h2><a id=\"201_GD32_6\"></a>20.1 GD32存储结构的工作原理</h2>\n<h3><a id=\"2011_CortexM_7\"></a>20.1.1 Cortex-M内核的存储器映射</h3>\n<p>存储器映射是指把芯片中或芯片外的FLASH，RAM，外设，BOOTBLOCK等进行统一编址。即用地址来表示对象。这个地址绝大多数是由厂家规定好的，用户只能用而不能改。用户只能在挂外部RAM或FLASH的情况下可进行自定义。</p>\n<p>如下图，是Cortex-M3存储器映射结构图。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3bcce458d6e9492da36b1b6aa1e15547.png\"/></p>\n<p>Cortex-M3是32位的内核，因此其PC指针可以指向2^32=4G的地址空间，也就是0x0000_0000 - 0xFFFF_FFFF这一大块空间。根据图中描述，Cortex-M3内核将0x0000_0000 - 0xFFFF_FFFF这块4G大小的空间分成8大块：代码、SRAM、外设、外部RAM、外部设备、专用外设总线-内部、专用外设总线-外部、特定厂商等，因此使用该内核的设计者必须按照这个进行各自芯片的存储器结构设计。</p>\n<h3><a id=\"2012_GD32_17\"></a>20.1.2 GD32存储器结构</h3>\n<p>首先，我们对比一下Cortex-M3存储器结构和GD32存储器结构：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9dffd850a2614fde8bda00a338c9017f.jpeg\"/></p>\n<p>图中可以很清晰的看到，GD32的存储器结构和Cortex-M3的很相似，不同的是，GD32加入了很多实际的东西，如：Flash、SRAM等。只有加入了这些东西，才能成为一个拥有实际意义的、可以工作的处理芯片-GD32。</p>\n<p>GD32的存储器地址空间被划分为大小相等的8块区域，每块区域大小为512MB。</p>\n<p>对GD32存储器知识的掌握，实际上就是对Flash和SRAM这两个区域知识的掌握。</p>\n<h2><a id=\"202_FLASH_29\"></a>20.2 FLASH读写数据</h2>\n<h3><a id=\"2021_GD32Flash_30\"></a>20.2.1 GD32的Flash</h3>\n<p>GD32的Flash，严格说，应该是Flash模块。该Flash模块包括：Flash主存储区（Main memory）、Flash信息区（Information block），以及Flash存储接口寄存器区（Flash memory interface）。三个组成部分分别在0x0000 0000 - 0xFFFF FFFF不同的区域，GD32F2的Flash结构如下表所示。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1cb83b77a13407daefa2b7ab8bb981c.png\"/></p>\n<p>【注】信息块存储了boot loader，不能被用户编程或擦除。</p>\n<p>GD32的闪存模块由：<strong>主存储闪存块、信息块和选项字节块3部分组成</strong>。</p>\n<p><strong>主存储器</strong>，该部分用来存放代码和数据常数（如加const类型的数据）。对于主存储闪存容量不多于512KB的GD32F20x_CL，闪存页大小为2KB。对于主存储闪存容量不少于768KB的GD32F20x_CL，使用了两片闪存；前512KB容量在第一片闪存（bank0）中，后续的容量在第二片闪存（bank1）中。其中bank0的闪存页大小为2KB， bank1的闪存页大小为4KB。主存储闪存的每页都可以单独擦除。</p>\n<p><strong>信息块</strong>，是用来存储GD自带的启动程序，用于串口下载，当B0接3.3V，B1接GND时，运行的就这部分代码，用户选择字节，则一般用于配置保护等功能。</p>\n<p><strong>选项字节块</strong>，该部分用于控制闪存储器读取等，是整个闪存储器的控制机构。</p>\n<p>对于主存储器和信息块的写入有内嵌的闪存编程管理；编程与擦除的高压由内部产生。</p>\n<p>在执行闪存写操作时，任何对闪存的读操作都会锁定总线，在写完成后才能正确进行，在进行读取或擦除操作时，不能进行代码或者数据的读取操作。</p>\n<p>下面对GD32的存储器进行总结。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1061110dd78542758835214dad2f98fe.jpeg\"/></p>\n<p>图中淡蓝色就是你需要知道的。</p>\n<blockquote>\n<p> Peripherals：外设的存储器映射，对该区域操作，就是对相应的外设进行操作；<br/>  SRAM：运行时临时存放代码的地方；<br/>  Flash：存放代码的地方；<br/>  System Memory：GD32出厂时自带的你只能使用，不能写或擦除；<br/>  Option Bytes：可以按照用户的需要进行配置（如配置看门狗为硬件实现还是软件实现）；</p>\n</blockquote>\n<p>今后，你的编写代码、程序运行、寄存器设置、ICP、IAP都依靠这些东西。</p>\n<h3><a id=\"2022_FLASH_66\"></a>20.2.2 FLASH读写实现</h3>\n<p>GD32F20x 系列产品的片上 Flash 起始地址时 0x0800 0000，最大容量可达 3072 KB。读操作为 0 等待，可支持字节、半字(16 bits)和字(32 bits)访问。 Flash 编程以半字(16 bits)或字(32bits)为单位。擦除可以以页(page)为单位，也可以进行全片擦除（information blocks 除外）。</p>\n<p>Flash的寄存器有很多，当时GD的工程师已经封装好了，直接用就可以，我这里就不在贴出来了。</p>\n<p>Flash操作很简单，我们将数据写入到Flash中，再将其读出来。主要有以下步骤：</p>\n<blockquote>\n<p>1.Flash解锁操作<br/> 2.清除Flash标志<br/> 3.页擦除<br/> 4.读写操作<br/> 5.锁定</p>\n</blockquote>\n<p>核心代码如下：</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">FLASH_ADR</span> <span class=\"token expression\"><span class=\"token number\">0x0807F800</span></span></span>\n\n<span class=\"token comment\">/**\n  * @brief  flash test\n  * @param  WriteAddr, InData\n  * @retval OutData\n  */</span>\n<span class=\"token class-name\">uint32_t</span> <span class=\"token function\">flash_test</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint32_t</span> WriteAddr<span class=\"token punctuation\">,</span> <span class=\"token class-name\">uint32_t</span> InData<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">uint32_t</span> OutData <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//解锁</span>\n    <span class=\"token function\">fmc_unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//清除标志位</span>\n    <span class=\"token function\">fmc_flag_clear</span><span class=\"token punctuation\">(</span>FMC_FLAG_BANK0_PGERR <span class=\"token operator\">|</span> FMC_FLAG_BANK0_WPERR <span class=\"token operator\">|</span> FMC_FLAG_BANK0_END <span class=\"token operator\">|</span> FMC_FLAG_BANK1_PGERR <span class=\"token operator\">|</span> FMC_FLAG_BANK1_WPERR <span class=\"token operator\">|</span> \n\tFMC_FLAG_BANK1_END<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//要擦出页的起始地址</span>\n    <span class=\"token function\">fmc_page_erase</span><span class=\"token punctuation\">(</span>WriteAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//写数据</span>\n    <span class=\"token function\">fmc_word_program</span><span class=\"token punctuation\">(</span>WriteAddr<span class=\"token punctuation\">,</span> InData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//锁定</span>\n    <span class=\"token function\">fmc_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n    OutData<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>__IO <span class=\"token class-name\">uint32_t</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>WriteAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> OutData<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>程序就不讲了，这里需要注意一个C语言的知识点。</p>\n<pre><code class=\"prism language-c\">OutData<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>__IO <span class=\"token class-name\">uint32_t</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>WriteAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这一句很多新手很懵逼，也就是从一个地址中读取数据，多看看指针相关的知识就好理解了。</p>\n<p>主函数如下：</p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">/*\n    brief      main function\n    param[in]  none\n    param[out] none\n    retval     none\n*/</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">uint32_t</span> InData <span class=\"token operator\">=</span> <span class=\"token number\">12345678</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">uint32_t</span> OutData<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// systick init</span>\n    <span class=\"token function\">sysTick_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// UART1 init</span>\n    <span class=\"token function\">com_init</span><span class=\"token punctuation\">(</span>COM1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// led1 init</span>\n    <span class=\"token function\">led_init</span><span class=\"token punctuation\">(</span>LED1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"InData = %d\\r\\n\"</span><span class=\"token punctuation\">,</span>InData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// flash test</span>\n    OutData<span class=\"token operator\">=</span> <span class=\"token function\">flash_test</span><span class=\"token punctuation\">(</span>FLASH_ADR<span class=\"token punctuation\">,</span> InData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"OutData = %d\\r\\n\"</span><span class=\"token punctuation\">,</span>OutData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>OutData <span class=\"token operator\">==</span> InData<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Flash test success !\\r\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Flash test fail !\\r\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">led_on</span><span class=\"token punctuation\">(</span>LED1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t  <span class=\"token comment\">// 亮</span>\n        <span class=\"token function\">delay_ms</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">led_off</span><span class=\"token punctuation\">(</span>LED1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t  <span class=\"token comment\">// 灭 </span>\n        <span class=\"token function\">delay_ms</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"2023_167\"></a>20.2.3实验结果</h3>\n<p>将程序边看一完成后下载到板子中，通过串口助手，按下板子的复位按键可以看到如下现象。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\60855f43149f4f808d9d5bebc225f46c.png\"/></p>\n<h2><a id=\"203_SRAM_173\"></a>20.3 SRAM启动</h2>\n<h3><a id=\"2031_GD32_174\"></a>20.3.1 GD32的启动模式</h3>\n<p>首先要回顾一下GD32的启动模式，因为启动模式决定了向量表的位置，GD32有三种启动模式：</p>\n<p>1)<strong>主闪存存储器(Main Flash)启动</strong>：从GD32内置的Flash启动(0x0800 0000-0x0807 FFFF)，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。以0x08000000 对应的内存为例，则该块内存既可以通过0x00000000 操作也可以通过0x08000000 操作，且都是操作的同一块内存。</p>\n<p>2)<strong>系统存储器(System Memory)启动</strong>：从系统存储器启动(0x1FFFF000 - 0x1FFF F7FF)，这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的ISP程序中，提供了串口下载程序的固件，可以通过这个ISP程序将用户程序下载到系统的Flash中。以0x1FFFFFF0对应的内存为例，则该块内存既可以通过0x00000000 操作也可以通过0x1FFFFFF0操作，且都是操作的同一块内存。</p>\n<p>3)<strong>片上SRAM启动</strong>：从内置SRAM启动(0x2000 0000-0x3FFFFFFF)，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。SRAM 只能通过0x20000000进行操作，与上述两者不同。从SRAM 启动时，需要在应用程序初始化代码中重新设置向量表的位置。</p>\n<p>用户可以通过设置BOOT0和BOOT1的引脚电平状态，来选择复位后的启动模式。如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\77b1c16b1f8d49d191b6e3a11abdd4a1.png\"/></p>\n<p>启动模式只决定程序烧录的位置，加载完程序之后会有一个重映射(映射到0x00000000地址位置)；真正产生复位信号的时候，CPU还是从开始位置执行。</p>\n<p>值得注意的是GD32上电复位以后，代码区都是从0x00000000开始的，三种启动模式只是将各自存储空间的地址映射到0x00000000中。</p>\n<h3><a id=\"2032_GD32SRAM_192\"></a>20.3.2 GD32的SRAM</h3>\n<p>不同类型的Cortex-M单片机的SRAM大小是不一样的，但是他们的起始地址都是0x2000 0000，终止地址都是0x2000 0000+其固定的容量大小。</p>\n<p>SRAM的理解比较简单，其作用是用来存取各种动态的输入输出数据、中间计算结果以及与外部存储器交换的数据和暂存数据。设备断电后，SRAM中存储的数据就会丢失。</p>\n<p>GD32F20x 系列产品的片上 SRAM 起始地址是 0x2000 0000，最大容量可达 384KB，可支持字节、半字(16bits)和字(32bits)访问。 片上 SRAM 被分为 SRAM0、 SRAM1 和 SRAM2 等三个模块，且每个模块都有一个与 AHB 总线矩阵连接的专用接口，这意味着它们可以被同时访问。</p>\n<table><thead><tr><th align=\"left\">模块</th><th align=\"left\">容量</th><th align=\"left\">地址范围</th></tr></thead><tbody><tr><td align=\"left\">SRAM1</td><td align=\"left\">112KB</td><td align=\"left\">0x2000 0000 ~ 0x2001 BFFF</td></tr><tr><td align=\"left\">SRAM2</td><td align=\"left\">16KB</td><td align=\"left\">0x2001 C000 ~ 0x2001 FFFF</td></tr><tr><td align=\"left\">SRAM3</td><td align=\"left\">256KB</td><td align=\"left\">0x2002 0000 ~ 0x2005 FFFF</td></tr></tbody></table>\n<h3><a id=\"2033SRAM_206\"></a>20.3.3片上SRAM启动实现</h3>\n<p>在使用片上SRAM调试之前，需要了解为何要使用片上SARM来启动程序，因此GD32的片上Flash的擦写次数有限，若超过最大擦除次数则会损坏内部Flash，因此在平时的程序调试阶段，最好使用SRAM启动。</p>\n<p>总的来说，SRAM启动程序有如下用途：</p>\n<blockquote>\n<p>1.调试阶段，需要频繁更新程序，可以SRAM启动，加快调试，减少flash擦写损耗<br/> 2.程序SWD/JTAG接口已经配置为普通端口，程序启动后无法程序更新，可在SRAM中启动后，再更新flash程序<br/> 3.程序已经开启了读保护，可在SRAM启动后，进行读保护关闭</p>\n</blockquote>\n<p>片上SRAM启动实现的方法很简单，这里以GDF207+Keil5举例，实现方法如下：</p>\n<p><strong>1.修改内存分配</strong></p>\n<p>修改了内存分配，也就是修改分散加载文件xxx.sct文件。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2474605d67874c65aac182caae816f7e.png\"/></p>\n<p>修改后再次生成工程，分散文件也会修改。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4e543792e8f245d5a982b226b648fc51.png\"/></p>\n<p>下面谈谈SRAM参数的分配，首先确定MCU的RAM大小，笔者使用的MCU是GD32F207，因此SRAM大小是256KB，然后还需要根据程序的编译大小来分配SRAM空间。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\62d6f034c3cd49dba0c78c9b761b3475.png\"/></p>\n<p>如果想方便点可以直接看MAP文件。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3c2aa64c55b542f29f1c11907c4ba730.png\"/></p>\n<p>FLASH和RAM的大小分别如下：<br/> Flash = Code + RO Data + RW Data = 3.88KB(3968)<br/> RAM = RW-data + ZI-data=8.07KB(8264)</p>\n<p>因此笔者这里分配空间如下：</p>\n<p>IROM1地址为0x2000 0000, 大小是0x10000=65536=64kB<br/> IRAM1地址为0x2000 3000, 大小是0x20000=131072=128kB</p>\n<p>当然啦，SRAM空间分配需要根据自己的 MCU来决定。</p>\n<p><strong>2.修改debug配置</strong><br/> 新建RAM.ini文件，配置如下：</p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">/*----------------------------------------------------------------------------\n * Name:    RAM.ini\n * Purpose: RAM Debug Initialization File\n * Note(s):\n *----------------------------------------------------------------------------*/</span>\n<span class=\"token comment\">/*----------------------------------------------------------------------------\n  Setup()  configure PC &amp; SP for RAM Debug\n *----------------------------------------------------------------------------*/</span>\nFUNC <span class=\"token keyword\">void</span> <span class=\"token function\">Setup</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  SP <span class=\"token operator\">=</span> <span class=\"token function\">_RDWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x20000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// Setup Stack Pointer</span>\n  PC <span class=\"token operator\">=</span> <span class=\"token function\">_RDWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x20000004</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// Setup Program Counter</span>\n  <span class=\"token function\">_WDWORD</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xE000ED08</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x20000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// Setup Vector Table Offset Register</span>\n<span class=\"token punctuation\">}</span>\n\nFUNC <span class=\"token keyword\">void</span> <span class=\"token function\">OnResetExec</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{<!-- --></span>      <span class=\"token comment\">// executes upon software RESET</span>\n  <span class=\"token function\">Setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                           <span class=\"token comment\">// Setup for Running</span>\n<span class=\"token punctuation\">}</span>\n\nload <span class=\"token operator\">%</span>L incremental\n\n<span class=\"token function\">Setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                             <span class=\"token comment\">// Setup for Running</span>\n\ng<span class=\"token punctuation\">,</span> main\n</code></pre>\n<p>然后加载进来。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1573693e3eed47c58174d5ab18435682.png\"/></p>\n<p>RAM.ini文件主要是初始化SP和PC指针。Cortex-M3复位时会从0x00000000和0x00000004的相对位置取出MSP初值以及将复位向量地址赋给PC，在SRAM中的绝对位置就是0x20000000和0x20000004。GD32F207需要手动配置。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\66308a106d7a4873a70a3ad2b5763421.png\"/></p>\n<p><strong>3.修改下载配置</strong><br/> 需要把程序下载到SRAM，修改相应的下载地址。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bc1840ad1d8d43499ee0cd51812fea49.png\"/></p>\n<p><strong>4.修改中断向量表指针</strong><br/> 由启动文件可知，程序启动首先执行Reset_Handler函数，SRAM启动硬件强制将PC指针赋值为0x200001E0，PC指针加1开始执行启动文件，故Reset_Handler函数的运行地址需为0x200001E1才行，否则程序就会跑飞。</p>\n<p>因此需要在中断向量表的末尾添加SPACE 0x96。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\409d81b796d54d1390a480e08644ba17.png\"/></p>\n<p>同时在在main函数中添加设置中断向量表以及系统初化函数。</p>\n<pre><code class=\"prism language-c\"><span class=\"token function\">nvic_vector_table_set</span><span class=\"token punctuation\">(</span>NVIC_VECTTAB_RAM<span class=\"token punctuation\">,</span><span class=\"token number\">0x00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">SystemInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>5.修改启动模式</strong><br/> 这里选择SRAM启动，因此BOOT0-&gt;1 BOOT1-&gt;1。</p>\n<p>最后编译下载程序，然后就可以运行程序了。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a5d4a0902bba48308c077f9ed50a3e85.png\"/></p>\n<br/>\n<hr/>\n<h3><a id=\"centercenter_322\"></a>\n<center>\n  欢迎访问我的网站\n </center></h3>\n<p><a href=\"https://space.bilibili.com/338944611\">BruceOu的哔哩哔哩</a><br/> <a href=\"https://www.bruceou.cn/\">BruceOu的主页</a><br/> <a href=\"https://blog.bruceou.cn/\">BruceOu的博客</a><br/> <a href=\"https://blog.csdn.net/bruceoxl\">BruceOu的CSDN博客</a><br/> <a href=\"https://www.jianshu.com/u/d8ad9ddc8647\">BruceOu的简书</a><br/> <a href=\"https://www.zhihu.com/people/Bruceoxl\">BruceOu的知乎</a></p>\n<hr/>\n<h3><a id=\"centercenter_333\"></a>\n<center>\n  资源获取方式\n </center></h3>\n<p>1.关注公众号[<strong>嵌入式实验楼</strong>]<br/> 2.在公众号回复关键词[<strong>GD32开发实战指南</strong>]获取资料提取码</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-02 20:33:08", "summary": "开发环境：：开发板：：存储结构的工作原理内核的存储器映射存储器映射是指把芯片中或芯片外的，，外设，等进行统一编址。即用地址来表示对象。这个地址绝大多数是由厂家规定好的，用户只能用而不能改。用户只能在挂"}