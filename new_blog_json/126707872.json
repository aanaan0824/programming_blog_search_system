{"blogid": "126707872", "writerAge": "码龄4年", "writerBlogNum": "411", "writerCollect": "3129", "writerComment": "196", "writerFan": "2288", "writerGrade": "7级", "writerIntegral": "9065", "writerName": "前端技术栈", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126707872.jpg", "writerRankTotal": "1504", "writerRankWeekly": "804", "writerThumb": "414", "writerVisitNum": "772683", "blog_read_count": "382", "blog_time": "于 2022-09-05 16:22:53 发布", "blog_title": "【面试题】Vue2为什么能通过this访问到data、methods的属性或方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>在我没接触vue之前我不着调this是啥压根就没有接触过，在我学过了vue之后我知道了this，那时候理解的this就是你要使用data中的属性或调用methods中的方法等其他东西都要用this去调用，那时候其实我还是不知道this是啥，后面慢慢的才知道，当然我知道应该就是八股文背出来的，通过今天读这个源码，让我理解的更加深刻了，原来还可以这么用。</p>\n<h3>一、vue的使用</h3>\n<p>看这一段代码我们能知道有个Vue的构造函数 ，然后我们使用new Vue创建了它的实例，并给它传了一个对象参数，里面有data和methods，那么在这个Vue构造函数做了什么才能让我使用this可以直接访问里面的属性或者方法呢？</p>\n<pre><code class=\"language-javascript\">    //创建vue的实例\n    const vm = new Vue({\n        data: {\n            desc: '为什么this能够直接访问data中的属性',\n        },\n        methods: {\n            sayName() {\n                console.log(this.desc);\n            }\n        },\n    });\n    console.log(vm.name);\n    console.log(vm.sayName());\n</code></pre>\n<h3>二、Vue的构造函数</h3>\n<p>接收一个options参数</p>\n<ul><li>使用 instanceof 判断 this对象上是否出现了Vue的prototype，我们都知道this的指向是取决于谁调用</li><li>this._init(options) 证明在这调用要么我们创建的实例上有_init方法要么方法在Vue的prototype上，但是我们可以看到实例上并没有_init方法 ,那么肯定在一个地方给Vue的prototype上加上了_init方法 继续往下看</li></ul>\n<pre><code class=\"language-javascript\"> function Vue(options) {\n        if (!(this instanceof Vue)\n        ) {\n            warn('Vue是一个构造函数，应使用“new”关键字调用');\n        }\n        this._init(options);\n}\n//Vue() //错误的调用方式 进入警告判断 此时this指向window 然后window的 window.__proto__的指向的Window构造函数的prototype\n</code></pre>\n<h3>三 初始化initMixin(Vue)</h3>\n<p>在源码中会看到很多初始化的函数在这我们initMixin()</p>\n<p>这个函数就是在Vue的原型上增加了_init方法，方法接收一个参数，然后定义了vm变量，在我看的时候就想看看这个函数的this指向谁，其实也不难函数挂在Vue构造函数的原型上，调用还是在构造函数里面使用this调用，构造函数的this指向Vue实例，根据this的指向规则 此时的vm就指向了Vue构造函数的实例。</p>\n<p>使用this的访问规则如果实例上没有就去原型上找</p>\n<p>然后执行 initState(vm)</p>\n<pre><code class=\"language-javascript\">initMixin(Vue)\nfunction initMixin(Vue) {\n        //prototype上增加init方法\n        Vue.prototype._init = function (options) {\n            var vm = this; //Vue实例\n          \tvm.age = 30\n          //代码进行了删减\n            initState(vm);\n        }\n}\n//这里只是举例测试\nconst vm = new Vue({})\nconsole.log(vm.age) //30\n</code></pre>\n<h3>四 initState(vm)</h3>\n<p>这里就是对我们传入的data 或者methods进行不同的处理</p>\n<pre><code class=\"language-javascript\"> //initState方法代码进行了删减\n    function initState(vm) {\n        vm._watchers = [];\n        var opts = vm.$options; //这里是我们在创建实例的时候传的参数\n        //如果传了methods 则去调用\n        if (opts.methods) { initMethods(vm, opts.methods); }\n        if (opts.data) {\n            initData(vm);\n        } else {\n            observe(vm._data = {}, true /* asRootData */);\n        }\n    }\n</code></pre>\n<h3>五 initMethods(vm, opts.methods)</h3>\n<p>如果有methods则取调用initMethods方法</p>\n<p>前面主要是判断 methods中的值是不是函数，key有没有跟props冲突等</p>\n<p>最后一段代码就是在vm的实例上增加方法vm[key]=methods[key]，在读的时候我有这样一个以为为什么还要用bind改变this指向呢不本来就是写在vm实例上的方法吗 只能使用vm调用 那么方法的this不就指向vm吗？</p>\n<pre><code class=\"language-javascript\">/*\n    vm:构造函数实例\n    methods：我们传的methods对象\n    */\n    function initMethods(vm, methods) {\n        var props = vm.$options.props;\n        //循环methods对象\n        for (var key in methods) {\n            {\n                //判断是否是函数 不是的化则作出警告\n                if (typeof methods[key] !== 'function') {\n                    warn(\n                        \"Method \"\" + key + \"\" has type \"\" + (typeof methods[key]) + \"\" in the component definition. \" +\n                        \"Did you reference the function correctly?\",\n                        vm\n                    );\n                }\n                //判断 methods 中的每一项是不是和 props 冲突了，如果是，警告。\n                if (props &amp;&amp; hasOwn(props, key)) {\n                    warn(\n                        (\"Method \"\" + key + \"\" has already been defined as a prop.\"),\n                        vm\n                    );\n                }\n                //判断 methods 中的每一项是不是已经在 new Vue实例 vm 上存在，而且是方法名是保留的 _ $ （在JS中一般指内部变量标识）开头，如果是警告。\n                if ((key in vm) &amp;&amp; isReserved(key)) {\n                    warn(\n                        \"Method \"\" + key + \"\" conflicts with an existing Vue instance method. \" +\n                        \"Avoid defining component methods that start with _ or $.\"\n                    );\n                }\n            }\n            //给实例增加methods中的方法 这样其实我们就已经可以用vm访问 到methods中的方法了\n            vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n        }\n    }\n</code></pre>\n<p>问了群里大佬之后原来这步操作时为了防止用户改变this指向，专门做了个例子</p>\n<p>在这我有定义了对象a里面有个age属性和fn，fn我赋值vm实例上的sayHi，然后a.fn()调用很明显this的指向已经被改变了，使用bind之后则不会</p>\n<pre><code class=\"language-javascript\">  const vm = new Vue({\n        methods: {\n            sayHi() {\n                console.log(this.age, 'hello-this')\n            }\n        }\n    });\n    let a = {\n        age: 15,\n        fn: vm.sayHi\n    }\n    console.log(a.fn(), 'vm') //打印15\n</code></pre>\n<h3>六 initData(vm)</h3>\n<p>data是如何做到的使用this可以直接访问的，其实原理都一样，</p>\n<p>首先在vm实例上增加了_data，里面存的我们传入的data参数</p>\n<pre><code class=\"language-javascript\"> function initData(vm) {\n        var data = vm.$options.data;\n        data = vm._data = typeof data === 'function'\n            ? getData(data, vm)\n            : data || {};\n        //如果不是对象则警告\n        if (!isPlainObject(data)) {\n            data = {};\n            warn(\n                'data functions should return an object:\\n' +\n                'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n                vm\n            );\n        }\n        // proxy data on instance\n        var keys = Object.keys(data);\n        var props = vm.$options.props;\n        var methods = vm.$options.methods;\n        var i = keys.length;\n        while (i--) {\n            var key = keys[i];\n            //判断key值有没有跟methods中的key重名\n            {\n                if (methods &amp;&amp; hasOwn(methods, key)) {\n                    warn(\n                        (\"Method \"\" + key + \"\" has already been defined as a data property.\"),\n                        vm\n                    );\n                }\n            }\n            //判断key值有没有跟props中的key重名\n            if (props &amp;&amp; hasOwn(props, key)) {\n                warn(\n                    \"The data property \"\" + key + \"\" is already declared as a prop. \" +\n                    \"Use prop default value instead.\",\n                    vm\n                );\n                //是否是内部私有保留的字符串$ 和 _ 开头\n            } else if (!isReserved(key)) {\n              //代理\n                proxy(vm, \"_data\", key);\n            }\n        }\n        // observe data\n        observe(data, true /* asRootData */);\n    }\n</code></pre>\n<h3>七 proxy(vm, \"_data\", key)</h3>\n<p>get 和 set 方法 注意里面的this 指向vm实例对象，上面已经在vm实例对象上增加了_data 所有在获取或者设置属性值的时候 都是this._data[key] 也就是vm._data[key],</p>\n<p>然后通过Object.defineProperty往实例对象上添加属性，所以当我们访问vm[key] 也就是 vm._data[key]</p>\n<pre><code class=\"language-javascript\">  function proxy (target, sourceKey, key) {\n      sharedPropertyDefinition.get = function proxyGetter () {\n        return this[sourceKey][key]\n      };\n      sharedPropertyDefinition.set = function proxySetter (val) {\n        this[sourceKey][key] = val;\n      };\n      Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n</code></pre>\n<pre><code class=\"language-javascript\">//创建vue构造函数\n    function Vue(options) {\n        if (!(this instanceof Vue)\n        ) {\n            warn('Vue是一个构造函数，应使用“new”关键字调用');\n        }\n        this._init(options);\n    }\n    //初始化\n    initMixin(Vue);\n    function initMixin(Vue) {\n        //prototype上增加init方法\n        Vue.prototype._init = function (options) {\n            var vm = this; //Vue实例\n            let methods = options.methods\n            initState(vm);\n        }\n    }\n    //initState方法代码进行了删减\n    function initState(vm) {\n        vm._watchers = [];\n        var opts = vm.$options; //这里是我们在创建实例的时候传的参数\n        //如果传了methods 则去调用\n        if (opts.methods) { initMethods(vm, opts.methods); }\n        if (opts.data) {\n            initData(vm);\n        } else {\n            observe(vm._data = {}, true /* asRootData */);\n        }\n    }\n    /*\n    vm:构造函数实例\n    methods：我们传的methods对象\n    */\n    function initMethods(vm, methods) {\n        var props = vm.$options.props;\n        //循环methods对象\n        for (var key in methods) {\n            {\n                //一些条件判断\n            }\n            //给实例增加methods中的方法 这样其实我们就已经可以用vm访问 到methods中的方法了\n            vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n        }\n    }\n    const vm = new Vue({\n        methods: {\n            sayHi() {\n                console.log('hello-this')\n            }\n        }\n    });\n    vm.sayHi() //hello-this\n</code></pre>\n<h3>总结</h3>\n<p>其实看明白了Methods是怎么做到直接用this可以直接访问的后面的都是差不多的，主要就是一个构造函数，然后创建一个实例，在实例上增加属性或者方法，这样我们就可以用实例对象直接访问了。原理就是那么简单。</p>\n<p></p>\n<p></p>\n<h1>  总结给大家一个实用面试题库</h1>\n<h3><strong> 1、前端面试题库 （</strong>面试必备）<strong>            <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://mp.weixin.qq.com/s?__biz=MzU5NzA0NzQyNg==&amp;mid=2247485824&amp;idx=3&amp;sn=70cd26a7c0c683de64802f6cb9835003&amp;scene=21#wechat_redirect\" title=\"前端面试题库\">前端面试题库</a></p>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 16:22:53", "summary": "在我没接触之前我不着调是啥压根就没有接触过，在我学过了之后我知道了，那时候理解的就是你要使用中的属性或调用中的方法等其他东西都要用去调用，那时候其实我还是不知道是啥，后面慢慢的才知道，当然我知道应该就"}