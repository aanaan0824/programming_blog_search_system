{"blogid": "123009040", "writerAge": "码龄4年", "writerBlogNum": "148", "writerCollect": "457", "writerComment": "24", "writerFan": "93", "writerGrade": "5级", "writerIntegral": "2058", "writerName": "qw&jy", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123009040.jpg", "writerRankTotal": "9470", "writerRankWeekly": "16036", "writerThumb": "164", "writerVisitNum": "88870", "blog_read_count": "1785", "blog_time": "于 2022-04-17 23:45:00 发布", "blog_title": "C++——deque", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-dracula\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p> <br/> </p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#Deque__vector__34\">Deque 与 vector 的异同点</a></li><li><a href=\"#_63\">构造操作</a></li><li><a href=\"#_86\">非更易型操作</a></li><li><a href=\"#_124\">更易型操作</a></li><li><a href=\"#_163\">使用例子</a></li></ul>\n</div>\n<br/>  \n<br/>  \n<p></p>\n<p>  容器 deque (发音为“deck”)和 vector 非常相似。它也采用dynamic array来管理元素，提供随机访问，并有着和 vector 几乎一模一样的接口。不同的是 deque 的 dynamic array 头尾都开放，因此能在头尾两端进行快速安插和删除（如下图所示)。<br/> <img alt=\"deque的逻辑结构\" src=\"..\\..\\static\\image\\d01e7a8a8c40474e99ef87f7008409b9.png\"/><br/> 为了提供这种能力， deque 通常实现为一组独立区块，第一区块朝某方向扩展，最末区块朝另一方向扩展，如下图所示。<br/> <img alt=\"deque的内部结构\" src=\"..\\..\\static\\image\\5eccfd3d40884248aa394104028f890a.png\"/>deque 包含在头文件&lt; deque &gt;中：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;deque&gt;</span></span>\n</code></pre>\n<p>其中，deque 类型定义于命名空间 std 内的一个class template：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span>\n\t\t\t\t<span class=\"token keyword\">typename</span> <span class=\"token class-name\">Allocator</span> <span class=\"token operator\">=</span> allocator<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">&gt;</span> <span class=\"token operator\">&gt;</span>\n\t\t\t<span class=\"token keyword\">class</span> <span class=\"token class-name\">deque</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>和 vector 相同，这里的第一个 template 参数用来表明元素类型。第二个 template 实参可有可无，用来指定内存模型，默认为 allocator。</p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<h1><a id=\"Deque__vector__34\"></a>Deque 与 vector 的异同点</h1>\n<p>Deque 与 vector 相比，功能上的差异如下：</p>\n<ul><li>deque 两端都能快速安插元素和移除元素（vector 只在尾端逞威风)。这些操作可以在摊提的常量时间内完成。</li><li>访问元素时 deque 内部结构会多一个间接过程，所以元素的访问和迭代器的动作会稍稍慢一些。</li><li>迭代器需要在不同区块间跳转，所以必须是个 smart pointer，不能是寻常 pointer。</li><li>在内存区块大小有限制的系统中（例如PC系统）, deque 可以内含更多元素，因为它使用不止一块内存。因此 deque 的 max_size() 可能更大。</li><li>Deque 不支持对容量和内存重新分配时机的控制。特别要注意的是，除了头尾两端，在任何地点安插或删除元素都将导致指向 deque 元素的任何 pointer、reference 和 iterator 失效。不过，deque 的内存重分配优于 vector，因为其内部结构显示, deque 不必在内存重新分配时复制所有元素。</li><li>Deque 会释放不再使用的内存区块。Deque 的内存大小是可缩减的，但要不要这么做，以及如何做，由实现决定。</li></ul>\n<p>Deque 的以下特性跟 Vector 差不多：</p>\n<ul><li>在中段安插、移除元素的速度相对较慢，因为所有元素都需移动以腾出或填补空间。</li><li>迭代器属于 random-access iterator (随机访问迭代器)。</li></ul>\n<p>以下情形最好采用 deque：</p>\n<ul><li>你需要在两端安插和移除元素(这是 deque 的拿手好戏)。</li><li>无须指向(refer to)容器内的元素。</li><li>要求“不再使用的元素必须释放”(不过 C++ standard 对此无任何保证)。</li></ul>\n<p><strong>Vector 和 deque 的接口几乎一样，所以如果你不需要什么特殊性质，两者都可试试。</strong></p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<h1><a id=\"_63\"></a>构造操作</h1>\n<table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>deque&lt; Elem &gt; c</td><td>Default 构造函数，产生一个空 deque，没有任何元素</td></tr><tr><td>deque&lt; Elem &gt; c(c2)</td><td>Copy 构造函数，建立 c2 的同型 deque 并成为 c2 的一份拷贝(所有元素都被复制)</td></tr><tr><td>deque&lt; Elem &gt; c= c2</td><td>Copy 构造函数，建立一个新的 deque 作为 c2 的拷贝(每个元素都被复制)</td></tr><tr><td>deque&lt; Elem &gt; c(rv)</td><td>Move 构造函数，建立一个新的 deque，取 rvalue rv 的内容(<strong>始自C++11</strong>)</td></tr><tr><td>deque&lt; Elem &gt; c = rv</td><td>Move 构造函数,建立一个新的 deque，取 rvalue rv 的内容(<strong>始自C++11</strong>)</td></tr><tr><td>deque&lt; Elem &gt; c(n)</td><td>利用元素的 default 构造函数生成一个大小为 n 的 deque</td></tr><tr><td>deque&lt; Elem &gt; c(n, elem)</td><td>建立一个大小为 n 的 deque，每个元素值都是 elem</td></tr><tr><td>deque&lt; Elem &gt; c(beg, end)</td><td>建立一个 deque，以区间 [beg, end) 作为元素初值</td></tr><tr><td>deque&lt; Elem &gt; c(initlist)</td><td>建立一个 deque，以初值列 initlist 的元素为初值(<strong>始自C++11</strong>)</td></tr><tr><td>deque&lt; Elem &gt; c = initlist</td><td>建立一个 deque，以初值列 initlist 的元素为初值(<strong>始自C++11</strong>)</td></tr><tr><td>c.~deque()</td><td>销毁所有元素，释放内存</td></tr></tbody></table>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<h1><a id=\"_86\"></a>非更易型操作</h1>\n<table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>c.empty()</td><td>返回是否容器为空（相当于 size()==0 但也许较快)</td></tr><tr><td>c.size()</td><td>返回目前的元素个数</td></tr><tr><td>c.max_size()</td><td>返回元素个数之最大可能量</td></tr><tr><td>c.shrink_to_fit()</td><td>要求降低容量，以符合元素个数（<strong>始自C++11</strong>)</td></tr><tr><td></td><td></td></tr><tr><td>c1 == c2</td><td>返回 c1 是否等于 c2（对每个元素调用==)</td></tr><tr><td>c1 != c2</td><td>返回 c1 是否不等于 c2（相当于!(c1==c2))</td></tr><tr><td>c1 &lt; c2</td><td>返回 c1 是否小于 c2</td></tr><tr><td>c1 &gt; c2</td><td>返回 c1 是否大于 c2（相当于c2&lt;c1)</td></tr><tr><td>c1 &lt;= c2</td><td>返回 c1 是否小于等于 c2（相当于!(c2&lt;c1))</td></tr><tr><td>c1 &gt;= c2</td><td>返回 c1 是否大于等于 c2（相当于! (c1&lt;c2))</td></tr><tr><td></td><td></td></tr><tr><td>c[idx]</td><td>返回索引 idx 所指的元素（不检查范围)</td></tr><tr><td>c.at(idx)</td><td>返回索引 idx 所指的元素（如果 idx 超出范围就抛出 range-error 异常)</td></tr><tr><td>c.front()</td><td>返回第一元素（不检查是否存在第一元素)</td></tr><tr><td>c.back()</td><td>返回最末元素（不检查是否存在最未元素)</td></tr><tr><td></td><td></td></tr><tr><td>c.begin()</td><td>返回一个 random-access iterator 指向第一元素</td></tr><tr><td>c.end()</td><td>返回一个 random-access iterator 指向最末元素的下一位置</td></tr><tr><td>c.cbegin()</td><td>返回一个 const random-access iterator 指向第一元素（<strong>始自C++11</strong>)</td></tr><tr><td>c.cend(</td><td>返回一个 const random-access iterator 指向最末元素的下一位置（<strong>始自C++11</strong>)</td></tr><tr><td>c.rbegin()</td><td>返回一个反向的 (reverse) iterator 指向反向迭代的第一元素</td></tr><tr><td>c.rend()</td><td>返回一个反向的 (reverse) iterator 指向反向迭代的最末元素的下一位置</td></tr><tr><td>c.crbegin()</td><td>返回一个 const reverse iterator 指向反向迭代的第一元素（<strong>始自C++11</strong>)</td></tr><tr><td>c.crend()</td><td>返回一个 const reverse iterator 指向反向迭代的最末元素的下一位置（<strong>始自C++11</strong>)</td></tr></tbody></table>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<h1><a id=\"_124\"></a>更易型操作</h1>\n<table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>c = c2</td><td>将 c2 的全部元素赋值给 c</td></tr><tr><td>c = rv</td><td>将 rvalue rv 的所有元素以 move assign 方式给予 c（<strong>始自C++11</strong>)</td></tr><tr><td>c = initlist</td><td>将初值列 inittist 的所有元素赋值给 c（<strong>始自C++11</strong>)</td></tr><tr><td>c.assign(n, elem)</td><td>复制 n 个 elem，赋值给 c</td></tr><tr><td>c.assign(beg , end)</td><td>将区间 [beg, end) 内的元素赋值给 c</td></tr><tr><td>c.assign(initlist)</td><td>将初值列 initlist 的所有元素赋值给 c</td></tr><tr><td>c1.swap( c2)</td><td>置换 c1 和 c2 的数据</td></tr><tr><td>swap(c1, c2)</td><td>置换 c1 和 c2 的数据</td></tr><tr><td></td><td></td></tr><tr><td>c.push_back(elem)</td><td>附加一个 elem 的拷贝于末尾</td></tr><tr><td>c.pop_back()</td><td>移除最后一个元素，但是不返回它</td></tr><tr><td>c.push_front(elem)</td><td>在头部插入 elem 的一个拷贝</td></tr><tr><td>c.pop_front()</td><td>移除第一元素（但不返回)</td></tr><tr><td></td><td></td></tr><tr><td>c.insert(pos, elem)</td><td>在 iterator 位置 pos 之前方插入一个 elem 拷贝，并返回新元素的位置</td></tr><tr><td>c.insert(pos, n, elem)</td><td>在 iterator 位置 pos 之前方插入 n 个 elem 拷贝，并返回第一个新元素的位置（或返回 pos——如果没有新元素的话)</td></tr><tr><td>c.insert(pos, beg, end)</td><td>在 iterator 位置 pos 之前方插入区间 [beg, end) 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 pos——如果没有新元素的话)</td></tr><tr><td>c.insert(pos, initlist)</td><td>在 iterator 位置 pos 之前方插入初值列 initlist 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 pos———如果没有新元素的话；<strong>始自C++11</strong>)</td></tr><tr><td>c.emplace(pos, args . . .)</td><td>在 iterator 位置 pos 之前方插入一个以 args 为初值的元素，并返回新元素的位置（<strong>始自C++11</strong>)</td></tr><tr><td>c.emplace_back(args . . .)</td><td>附加一个以 args 为初值的元素于末尾，不返回任何东西（<strong>始自C++11</strong>)</td></tr><tr><td>c.emplace_front(args . . .)</td><td>插入一个以 args 为初值的元素于起点，不返回任何东西（<strong>始自C++11</strong>)</td></tr><tr><td>c.erase(pos)</td><td>移除 iterator 位置 pos 上的元素，返回下一元素的位置</td></tr><tr><td>c.erase(beg, end)</td><td>移除 [beg, end) 区间内的所有元素，返回下一元素的位置</td></tr><tr><td>c.resize(num)</td><td>将元素数量改为 num（如果 size() 变大，多出来的新元素都需以 default 构造函数完成初始化)</td></tr><tr><td>c.resize(num, elem)</td><td>将元素数量改为 num（如果 size() 变大，多出来的新元素都是 elem 的拷贝)</td></tr><tr><td>c.clear()</td><td>移除所有元素，将容器清空</td></tr></tbody></table>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<p> <br/>  </p>\n<h1><a id=\"_163\"></a>使用例子</h1>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;algorithm&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;deque&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\tdeque<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">&gt;</span> c<span class=\"token punctuation\">;</span><span class=\"token comment\">//创建一个空deque </span>\n\tc<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"qwjy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//复制3个qwjy复制给c </span>\n\tc<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"qw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//尾部插入一个元素 </span>\n\tc<span class=\"token punctuation\">.</span><span class=\"token function\">push_front</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"qy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//头部插入一个元素 </span>\n\t\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\tc<span class=\"token punctuation\">.</span><span class=\"token function\">pop_front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//移除最后一个元素 </span>\n\tc<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//移除第一个元素 </span>\n\t\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\tc<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"666\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"运行结果\" src=\"..\\..\\static\\image\\086989a2436147e68e82a4fbb79d02cb.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-17 23:45:00", "summary": "文章目录与的异同点构造操作非更易型操作更易型操作使用例子容器发音为和非常相似。它也采用来管理元素，提供随机访问，并有着和几乎一模一样的接口。不同的是的头尾都开放，因此能在头尾两端进行快速安插和删除如下"}