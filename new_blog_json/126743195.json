{"blogid": "126743195", "writerAge": "码龄6年", "writerBlogNum": "836", "writerCollect": "11257", "writerComment": "9977", "writerFan": "46084", "writerGrade": "8级", "writerIntegral": "34282", "writerName": "Lansonli", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743195.jpg", "writerRankTotal": "141", "writerRankWeekly": "24", "writerThumb": "9301", "writerVisitNum": "1323722", "blog_read_count": "63", "blog_time": "于 2022-09-07 12:43:27 发布", "blog_title": "大数据ClickHouse进阶（二）：MergeTree表引擎", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\09504e3773e9467dba150ceed958220e.jpeg\"/></p>\n<p id=\"main-toc\"><strong>文章目录</strong></p>\n<p id=\"MergeTree%E8%A1%A8%E5%BC%95%E6%93%8E-toc\" style=\"margin-left:0px;\"><a href=\"#MergeTree%E8%A1%A8%E5%BC%95%E6%93%8E\">MergeTree表引擎</a></p>\n<p id=\"%E4%B8%80%E3%80%81MergeTree-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%80%E3%80%81MergeTree\">一、MergeTree</a></p>\n<p id=\"%E4%BA%8C%E3%80%81MergeTree%E5%BC%95%E6%93%8E%E8%A1%A8%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E3%80%81MergeTree%E5%BC%95%E6%93%8E%E8%A1%A8%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90\">二、MergeTree引擎表目录解析</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1><strong>MergeTree表引擎</strong></h1>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在所有的表引擎中，最为核心的当属MergeTree系列表引擎，这些表引擎拥有最为强大的性能和最广泛的使用场合。对于非MergeTree系列的其他引擎而言，主要用于特殊用途，场景相对有限。而MergeTree系列表引擎是官方主推的存储引擎，有主键索引、数据分区、数据副本、数据采样、删除和修改等功能，支持几乎所有ClickHouse核心功能。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">MergeTree系列表引擎包含：MergeTree、ReplacingMergeTree、SummingMergeTree（汇总求和功能）、AggregatingMergeTree（聚合功能）、CollapsingMergeTree（折叠删除功能）、VersionedCollapsingMergeTree（版本折叠功能）引擎，在这些的基础上还可以叠加Replicated和Distributed。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">MergeTree在写入一批数据时，数据总会以数据片段的形式写入磁盘，且数据片段在磁盘上不可修改。为了避免片段过多，ClickHouse会通过后台线程，定期合并这些数据片段，属于相同分区的数据片段会被合成一个新的片段。这种数据片段往复合并的特点，也正是合并树名称的由来。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<h2 id=\"%E4%B8%80%E3%80%81MergeTree\" style=\"margin-left:.0001pt;text-align:justify;\"><strong>一、MergeTree</strong></h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><span style=\"color:#ff0000;\"><strong>MergeTree作为家族系列最基础的表引擎</strong></span></strong>，主要有以下特点：</p>\n<ul><li style=\"text-align:justify;\">存储的数据按照主键排序：创建稀疏索引加快数据查询速度。</li><li style=\"text-align:justify;\">支持数据分区，可以通过PARTITION BY语句指定分区字段。</li><li style=\"text-align:justify;\">支持数据副本。</li><li style=\"text-align:justify;\">支持数据采样。</li></ul>\n<p style=\"text-align:justify;\"><strong>MergeTree建表语句：</strong></p>\n<pre><code class=\"language-java\">CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n(\n    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1] [TTL expr1],\n    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2] [TTL expr2],\n    ...\n    INDEX index_name1 expr1 TYPE type1(...) GRANULARITY value1,\n    INDEX index_name2 expr2 TYPE type2(...) GRANULARITY value2\n) ENGINE = MergeTree()\nORDER BY expr\n[PARTITION BY expr]\n[PRIMARY KEY expr]\n[SAMPLE BY expr]\n[TTL expr [DELETE|TO DISK 'xxx'|TO VOLUME 'xxx'], ...]\n[SETTINGS name=value, ...]</code></pre>\n<p style=\"text-align:justify;\"><strong>关于以上建表语句的解释如下：</strong></p>\n<p style=\"text-align:justify;\"><strong>1、ENGINE：</strong>ENGINE = MergeTree()，MergeTree引擎没有参数。</p>\n<p style=\"text-align:justify;\"></p>\n<p style=\"text-align:justify;\"><strong>2、ORDER BY：</strong>排序字段。比如ORDER BY (Col1, Col2)，值得注意的是，如果没有使用 PRIMARY KEY 显式的指定主键ORDER BY排序字段自动作为主键。如果不需要排序，则可以使用 ORDER BY tuple() 语法，这样的话，创建的表也就不包含主键。这种情况下，ClickHouse会按照插入的顺序存储数据。<strong><span style=\"color:#ff0000;\"><strong>必选项。</strong></span></strong></p>\n<p style=\"text-align:justify;\"></p>\n<p style=\"text-align:justify;\"><strong>3、PARTITION BY：</strong>分区字段，例如要按月分区，可以使用表达式 toYYYYMM(date_column)，这里的date_column是一个Date类型的列，分区名的格式会是\"YYYYMM\"。<strong><span style=\"color:#ff0000;\"><strong>可选。</strong></span></strong></p>\n<p style=\"text-align:justify;\"></p>\n<p style=\"text-align:justify;\"><strong>4、PRIMARY KEY：</strong>指定主键，如果排序字段与主键不一致，可以单独指定主键字段。否则默认主键是排序字段。大部分情况下不需要再专门指定一个 PRIMARY KEY 子句，注意，<strong><strong>在MergeTree中主键并不用于去重，而是用于索引，加快查询速度。</strong></strong><strong><span style=\"color:#ff0000;\"><strong>可选。</strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">另外，<strong><span style=\"color:#ff0000;\"><strong>如果指定了PRIMARY KEY与排序字段不一致，要保证PRIMARY KEY 指定的主键是ORDER BY 指定字段的前缀</strong></span></strong>，比如：</p>\n<pre><code class=\"language-sql\">--允许\n... ...\nORDER BY (A,B,C)\nPRIMARY KEY A\n\n--报错\n... ...\nORDER BY (A,B,C)\nPRIMARY KEY B\nDB::Exception: Primary key must be a prefix of the sorting key</code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\">这种强制约束保障了即便在两者定义不同的情况下，主键仍然是排序键的前缀，不会出现索引与数据顺序混乱的问题。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"text-align:justify;\"><strong>5、SAMPLE BY：</strong>采样字段，如果指定了该字段，那么主键中也必须包含该字段。比如 SAMPLE BY intHash32(UserID) ORDER BY (CounterID, EventDate, intHash32(UserID))。<strong><span style=\"color:#ff0000;\"><strong>可选。</strong></span></strong></p>\n<p> </p>\n<p style=\"text-align:justify;\"><strong>6、TTL：</strong>数据的存活时间。在MergeTree中，可以为某个列字段或整张表设置TTL。当时间到达时，如果是列字段级别的TTL，则会删除这一列的数据；如果是表级别的TTL，则会删除整张表的数据。<strong><span style=\"color:#ff0000;\"><strong>可选。</strong></span></strong></p>\n<p> </p>\n<p style=\"text-align:justify;\"><strong>7、SETTINGS：</strong>额外的参数配置。<strong><span style=\"color:#ff0000;\"><strong>可选。</strong></span></strong></p>\n<p style=\"text-align:justify;\"></p>\n<h2 id=\"%E4%BA%8C%E3%80%81MergeTree%E5%BC%95%E6%93%8E%E8%A1%A8%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90\" style=\"text-align:justify;\">二、<strong><strong><strong>MergeTree引擎表目录解析</strong></strong></strong></h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">这里我们介绍下MergeTree引擎表对应到磁盘的数据目录，Clikchouse新版本与之前版本对比，数据对应的磁盘目录略有不同。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">创建表t_mt，并加载数据：</p>\n<pre><code class=\"language-sql\">CREATE TABLE t_mt\n(\n    `id` UInt8,\n    `name` String,\n    `age` UInt8,\n    `birthday` Date,\n    `location` String\n)\nENGINE = MergeTree\nPARTITION BY toYYYYMM(birthday)\nORDER BY (id, age)\n\n#向表t_mt中插入数据\ninsert into t_mt values (1,'张三',18,'2021-06-01','上海'), (2,'李四',19,'2021-02-10','北京'), (3,'王五',12,'2021-06-01','天津'), (1,'马六',10,'2021-06-18','上海'), (5,'田七',22,'2021-02-09','广州');</code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\">以上创建好表t_mt，当插入数据完成后，在ClickHouse节点/var/lib/ClickHouse/data/newdb/路径下会生成对应目录“t_mt”,进入此目录下，可以看到对应的分区目录，如图示：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"152\" src=\"..\\..\\static\\image\\3a6cec8fe92c4dc6b5e3c733fb01d64f.png\" width=\"920\"/></p>\n<p>以上分区目录也可以在系统表“system.parts”中查询得到：</p>\n<pre><code class=\"language-sql\">#在系统表 system.part中查询表 t_mt的分区信息：\nselect table ,partition ,name ,active from system.parts where table = 't_mt';</code></pre>\n<p><img alt=\"\" height=\"141\" src=\"..\\..\\static\\image\\70e050d030b94db2899df0e5f4d6d2e8.png\" width=\"692\"/></p>\n<p> 进入到某一个分区目录片段“202102_2_2_0”中，我们可以看到如下目录：</p>\n<p><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\ff57c34d71bf46f9827fb73b3022b1eb.png\" width=\"1058\"/></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong>对以上目录的解释如下：</strong></p>\n<p style=\"text-align:justify;\"><strong><strong>1、checksums.txt</strong></strong>：校验文件，使用二进制格式存储。它保存了余下各类文件(primary. idx、count.txt等)的size大小及size的哈希值，用于快速校验文件的完整性和正确性。</p>\n<p> </p>\n<p style=\"text-align:justify;\"><strong><strong>2、columns.txt</strong></strong>： 存储当前分区所有列信息。使用明文格式存储。</p>\n<pre><code class=\"language-bash\">[root@node1 202102_2_2_0]# cat columns.txt \ncolumns format version: 1\n5 columns:\n`id` UInt8\n`name` String\n`age` UInt8\n`birthday` Date\n`location` String</code></pre>\n<p> </p>\n<p style=\"text-align:justify;\"><strong><strong>3、count.txt</strong></strong>：计数文件，使用明文格式存储。用于记录当前数据分区目录下数据的总行数。</p>\n<pre><code class=\"language-bash\">[root@node1 202102_2_2_0]# cat count.txt \n2</code></pre>\n<ul><li style=\"text-align:justify;\"><strong><strong>data</strong></strong><strong><strong>.bin</strong></strong>：数据文件，使用压缩格式存储，默认为LZ4压缩格式，用于存储某一列的数据。<strong><span style=\"color:#ff0000;\"><strong>之前clickhoue版本是</strong></span></strong><strong><span style=\"color:#ff0000;\"><strong>每一个列字段都拥有独立的.bin数据文件，并以列字段名称命名</strong></span></strong><strong><span style=\"color:#ff0000;\"><strong>，在新版本ClickHouse中所有数据合并到data.bin中。</strong></span></strong></li></ul>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong>之前ClickHouse版本此目录数据如下：</strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"485\" src=\"..\\..\\static\\image\\545f8cf54b704843905c8fdd382f35c9.png\" width=\"1076\"/></p>\n<p></p>\n<p style=\"text-align:justify;\"><strong><strong>4、data</strong></strong><strong><strong>.mrk</strong></strong><strong><strong>3</strong></strong>：列字段标记文件，使用二进制格式存储。标记文件中保存了data.bin文件中数据的偏移量信息</p>\n<p style=\"text-align:justify;\"><strong><strong>5、default_compression_codec.txt</strong></strong>:存储数据压缩格式</p>\n<p style=\"text-align:justify;\"><strong><strong>6、partition.dat与minmax_[Column].idx</strong></strong>：如果指定了分区键，则会额外生成partition.dat与minmax索引文件，它们均使用二进制格式存储。partition.dat用于保存当前分区下分区表达式最终生成的值，即分区字段值；而minmax索引用于记录当前分区下分区字段对应原始数据的最小和最大值。比如当使用birthday字段对应的原始数据为2021-02-17、2021-02-23，分区表达式为PARTITION BY toYYYYMM(birthday)，即按月分区。partition.dat中保存的值将会是202102，而minmax索引中保存的值将会是2021-02-17、2021-02-23。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">ClickHouse MergeTree引擎表支持分区，索引，修改，并发查询数据，<strong><span style=\"color:#ff0000;\"><strong>当查询MergeTree表数据时，首先向</strong></span></strong><strong><span style=\"color:#ff0000;\"><strong>primary.idx</strong></span></strong><strong><span style=\"color:#ff0000;\"><strong>文件中获取对应的索引，根据索引找到【data</strong></span></strong><strong><span style=\"color:#ff0000;\"><strong>.mrk</strong></span></strong><strong><span style=\"color:#ff0000;\"><strong>3】文件获取对应的数据块偏移量，然后再根据偏移量从【data.bin】文件中读取块数据。</strong></span></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>7、primary.idx</strong></strong>：一级索引文件，使用二进制格式存储。用于存放稀疏索引，一张MergeTree表只能声明一次一级索引，即通过ORDER BY或者PRIMARY KEY指定字段。借助稀疏索引，在数据查询的时能够排除主键条件范围之外的数据文件，从而有效减少数据扫描范围，加速查询速度。</p>\n<hr/>\n<ul><li>📢博客主页：<a href=\"https://lansonli.blog.csdn.net/\" title=\"https://lansonli.blog.csdn.net\">https://lansonli.blog.csdn.net</a></li><li>📢欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！</li><li>📢本文由 Lansonli 原创，首发于 CSDN博客🙉</li><li>📢停下休息的时候不要忘了别人还在奔跑，希望大家抓紧时间学习，全力奔赴更美好的生活✨</li></ul>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-09-07 12:43:27", "summary": "文章目录表引擎一、二、引擎表目录解析表引擎在所有的表引擎中，最为核心的当属系列表引擎，这些表引擎拥有最为强大的性能和最广泛的使用场合。对于非系列的其他引擎而言，主要用于特殊用途，场景相对有限。而系列表"}