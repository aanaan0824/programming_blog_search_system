{"blogid": "126743331", "writerAge": "码龄24天", "writerBlogNum": "51", "writerCollect": "0", "writerComment": "1", "writerFan": "19", "writerGrade": "3级", "writerIntegral": "501", "writerName": "web13293720476", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743331.jpg", "writerRankTotal": "41258", "writerRankWeekly": "11761", "writerThumb": "1", "writerVisitNum": "2063", "blog_read_count": "3", "blog_time": "于 2022-09-07 12:45:23 发布", "blog_title": "JVM 双亲委派机制（通俗易懂）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"_2\"></a>类加载器</h1>\n<p>Java是运行在Java的虚拟机(JVM)中的，我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后ClassLoader负责将这些class文件加载到JVM中去执行。JVM中提供了自上而下提供了三层的ClassLoader：</p>\n<ol><li>BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。</li><li>ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。</li><li>AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol>\n<h1><a id=\"_12\"></a>双亲委派机制</h1>\n<p>当一个.class文件要被加载时。不考虑自定义的类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器ExtClassLoader。父类中同样会先检查自己是否已经加载过，如果没有再往上到BootstrapclassLoader这一层，先检查是否可以加载，如果可以则加载。反之，如果父加载器无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p>\n<p>下面这张图可以很好的解释双亲委派机制</p>\n<p>（图片来源：<a href=\"https://blog.csdn.net/codeyanbao/article/details/82875064\">https://blog.csdn.net/codeyanbao/article/details/82875064</a>）</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210120112853873.png\"/></p>\n<h1><a id=\"_23\"></a>双亲委派模型的好处</h1>\n<p>双亲委派机制保证了Java程序的稳定运行，可以避免类的重复加载，也保证了Java的核心API不被篡改。如果有人想替换系统级别的类：String.java，篡改它的实现。在这种机制下这些系统的类已经被BootstrapclassLoader加载过了，所以并不会再去加载。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 12:45:23", "summary": "类加载器是运行在的虚拟机中的，我们在中编写的源代码被编译器编译成的字节码文件。然后负责将这些文件加载到中去执行。中提供了自上而下提供了三层的：启动类加载器：最顶层的加载类，由实现，负责加载目录下的包和"}