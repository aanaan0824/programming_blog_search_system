{"blogid": "123221399", "writerAge": "码龄3年", "writerBlogNum": "53", "writerCollect": "86", "writerComment": "17", "writerFan": "15", "writerGrade": "3级", "writerIntegral": "680", "writerName": "c铁柱同学", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123221399.jpg", "writerRankTotal": "28914", "writerRankWeekly": "9456", "writerThumb": "115", "writerVisitNum": "34777", "blog_read_count": "6011", "blog_time": "已于 2022-06-18 09:35:27 修改", "blog_title": "什么是时间复杂度与空间复杂度", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>目录</h3>\n<ul><li><a href=\"#_2\">算法效率</a></li><li><a href=\"#_5\">时间复杂度</a></li><li><ul><li><a href=\"#_6\">概念</a></li><li><a href=\"#O_10\">大O的线性表示法</a></li><li><a href=\"#_61\">时间复杂度举例</a></li></ul>\n</li><li><a href=\"#_157\">空间复杂度</a></li><li><ul><li><a href=\"#_158\">空间复杂度的定义</a></li><li><a href=\"#_160\">空间复杂度举例</a></li></ul>\n</li></ul>\n</div>\n<br/> 时间复杂度与空间复杂度是用来分析一个算法的效率的。\n<p></p>\n<h1><a id=\"_2\"></a>算法效率</h1>\n<p>算法效率分析分为两种：第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度，而空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。</p>\n<h1><a id=\"_5\"></a>时间复杂度</h1>\n<h2><a id=\"_6\"></a>概念</h2>\n<p>时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。 一个算法执行所耗费的时间理论上来说是算不出来的，因为它不仅仅与你写的算法有关，还与运行这个算法的机器也有关系，如果你的机器很好，那么你所耗费的时间就可能会更少，所以，一个算法耗费的时间是需要放在机器上实际测验才能知道的，但是我们总不能每个算法都拿来上机测试，来记录该算法的时间，所以我们就有了时间复杂度这样的分析方式。<br/> <strong>一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。</strong></p>\n<h2><a id=\"O_10\"></a>大O的线性表示法</h2>\n<p>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。<br/> 我们来计算一下下面代码的时间复杂度</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">Func1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> N<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> M <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>M<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这个函数在调用的过程中使用了三个for循环和一个while循环，每循环一次我们说它进行了一次基本操作。那么这个函数执行基本操作的次数为F(N)=N²+2*N+10<br/> 那么我们如何用大O的线性表示法来表示这个函数的时间复杂度呢？</p>\n<blockquote>\n<p>推导大O阶方法：<br/> 1、用常数1取代运行时间中的所有加法常数。<br/> 2、在修改后的运行次数函数中，只保留最高阶项。<br/> 3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</p>\n</blockquote>\n<p>按照上面的规则，那么上述代码的时间复杂度就为O(N²)。<br/> 我们发现，通过上面的规则，我们就使用N²来代替了N²+2*N+10，我们为什么要这样规定呢，我们以上面的表达式为例，当N为不同的值时，表达式的结果为多少</p>\n<p>N=100 F(N)=10210<br/> N=1000 F(N)=1002010<br/> N=10000 F(N)=100020010</p>\n<p>我们发现，当N不断变大时，表达式的值也不断变大，而对表达式的结果影响最大的一项就是这个表达式中阶数最高的那一项。</p>\n<p>那我们为什么只保留对结果影响最大的那一项呢？我们知道时间复杂度描述的对象是一个算法，而不是某一次的运算，那么当我们使用这个算法并向里面传入一个能够影响算法基本操作执行次数的变量时，我们并不能确定我们输入的N的值是多少，N就有可能是任何值，当N比较小时，也许别的项与最高阶项的结果差距并没有那么大，但是当N的值越来越大时，最高阶项的值与其他项的值的差距也就越来越大了，我们还是以上面的代码为例，当我们的N在不断的变大时，因为其余项对结果的影响相对来说比较小，那么我们就可以忽略他们对结果的影响，只保留对结果影响最大的那一项来表示我们的时间复杂度。</p>\n<p>那么为什么我们要用1来表示所以的常数呢，这是因为计算机的运行速度是非常快的，每秒可能就可以执行上亿此的运算，那么常数次的执行次数与我们计算机的运算速度相比，可能与执行一次的运行速度相差不会太大，所以我们就使用1来代替所有的常数项，那么只有循环次数为常数的算法的时间复杂度相应的就是O(1)。</p>\n<p>去掉与最高阶项相乘的常数的原因也是因为对结果影响最大的是这个最高阶项，而不是这个最高阶项前面的系数，所以也要把它去掉。</p>\n<h2><a id=\"_61\"></a>时间复杂度举例</h2>\n<p>现在我们就大概明白了如何来计算一个算法的时间复杂度，下面我们来看几个代码练习一下。</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> N<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> M<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> M<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在这个算法中，我们在传入了两个变量，导致两个循环的循环次数分别由两个变量来决定，这时我们认为时间复杂度为O(N+M)，因为我们不知道M和N谁大，所以我们谁都无法省略。</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">my_strchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> str<span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>str <span class=\"token operator\">!=</span> <span class=\"token char\">'\\0'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>str <span class=\"token operator\">==</span> c<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        str<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这是一个简单的字符串查找函数，在这个算法中，并没有一个变量值来描述我们需要进行循环的次数，而觉得我们循环次数的是被查找字符串的长度，在时间复杂度的计算中，我们通常假设数组或字符串的长度为N，还有一个问题是这个算法中即使我们知道了字符串的长度但是我们执行循环的次数也是不一定的，因为我们不知道什么时候能够在字符串中找到我们寻找的元素，可能我们在第一个位置就找到了，也有可能我们要遍历整个字符串在最后一个元素的位置才能找到，出现这种情况时默认时间复杂度要以最坏的情况为准，即O(N)。</p>\n<p>冒泡排序的时间复杂度？</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">BubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> end <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> end <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>end<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">int</span> exchange <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                exchange <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>exchange <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面的是一个冒泡排序的函数，我们知道在进行冒泡排序时，我们首先要进行N次排序，然后在每次排序时，我们又要遍历这个数组，但是我们每进行一次排序，在下一次排序时我们就可以少遍历一个元素，所以我们可以得到实际的运算次数F(N)=N+(N-1)+(N-2)……+2+1。这是一个等差数列，结果化简为F(N)=N*(N+1)/2，所以时间复杂度为O(N²)</p>\n<p>二分查找的时间复杂度？</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">BinarySearch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> begin <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> begin <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> begin<span class=\"token punctuation\">)</span> <span class=\"token operator\">&gt;&gt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">)</span>\n            begin <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> x<span class=\"token punctuation\">)</span>\n            end <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面的是一个二分查找函数的代码，我们知道二分查找是在一个有序数组中查找某一个元素时的比较高效的方法，在进行二分查找时，我们每次都取数组的中间值，然后再根据中间值与查找值的大小来确定我们要查找的元素在那一半，然后在对找到的哪一半数组进行重复的操作，直到找到我们需要的元素，使用二分查找时，最坏的情况是我们把数组除的只剩最后一个元素，这时表达式为N÷2÷2÷2÷2…÷2÷2=1我们把这个式子换算一下为<br/> N=1×2×2×2…×2×2我们每相乘一次，就进行了一次基本操作，所以上式中我们一共进行了log₂N次，所以时间复杂度为O(log₂N)。</p>\n<p>递归的时间复杂度？</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">Fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> N<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">return</span> N <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> N <span class=\"token operator\">:</span> <span class=\"token function\">Fibonacci</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token function\">Fibonacci</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面的代码是一个计算斐波那契数列的函数，使用的是递归的方法，我们知道递归的方法来计算斐波那契数列是非常低效的，最好还是使用循环的方法，但是递归的时间复杂度是多少呢？<br/> 我们知道每一次调用这个函数时，我们的时间复杂度是一个常数，那么这个递归的时间复杂度就是我们一共调用了多少次函数，现在我们来分析一下我们到底调用了多少次这个函数。<br/> 其调用结构如图所示<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4610fd74195446fa8f711052f096a50c.png\"/><br/> 当我们输入N时，函数会进行两调用，然后不断地调用，其调用的结果如图所示，在右下角是有一个空缺区域的，但是我们可以把这一块空缺的区域看作一个常数，假设它是满的，那么我们执行调用的总次数为F(N)=2⁰+2¹+2²+…+2<sup>N-1</sup>=2<sup>N</sup>-1，所以该算法的时间按复杂度为O(2<sup>N</sup>)。<br/> 由以上的计算我们就可以发现用递归来算斐波那契数的算法的时间复杂度太高了，也就说明了这个算法的低效。</p>\n<h1><a id=\"_157\"></a>空间复杂度</h1>\n<h2><a id=\"_158\"></a>空间复杂度的定义</h2>\n<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。</p>\n<h2><a id=\"_160\"></a>空间复杂度举例</h2>\n<p>冒泡排序的空间复杂度？</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">BubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> end <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> end <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>end<span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{<!-- --></span>\n         <span class=\"token keyword\">int</span> exchange <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{<!-- --></span>\n             <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">{<!-- --></span>\n                 <span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 exchange <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">}</span>\n         <span class=\"token punctuation\">}</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>exchange <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n         <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>还是刚刚冒泡排序的代码，我们刚刚计算了它的时间复杂度，现在再来看一下它的空间复杂度，根据定义我们知道，空间复杂度是用来估算占用空间的大小的，那么我们就可以根据算法中创建的变量的个数来表示算法的空间复杂度，这个冒泡排序算法创建了3个变量，根据大O的渐进表示法的规则，该算法的空间复杂度就为O(1)。</p>\n<p>循环方法计算斐波那契数列的空间复杂度？<br/> 在计算时间复杂度时，我们知道使用递归的方法计算斐波那契数是一种非常低效的方法，而使用循环的方法就高效一些，那么循环的方法的空间复杂度又为多少？</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token operator\">*</span> <span class=\"token function\">Fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token operator\">*</span> fibArray <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    fibArray<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    fibArray<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        fibArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fibArray<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> fibArray<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> fibArray<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这就是循环方法计算斐波那契数的代码，我们发现在这个算法中，我们使用malloc开辟了一块元素个数为n+1的空间，那就相当于创建了n+1个变量，根据大O的线性表示法，该算法的空间复杂度就为O(N)。<br/> 那么我们使用递归的方法时的空间复杂度又是多少呢</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">Factorial</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> N<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token keyword\">return</span> N <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> N <span class=\"token operator\">:</span> <span class=\"token function\">Factorial</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>N<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们知道在调用函数时，是会创建栈帧的，简单来说就是我们每调用一次函数，就会为调用的那个函数创建一块空间，在计算递归算法的空间复杂度时，我们可以认为每次函数调用时都会创建常数个变量，那么影响我们算法空间复杂度的就是我们调用递归的次数，那么以上面的算法为例，该算法的空间复杂度就是O(N)。递归算法的空间复杂度通常是递归的深度</p>\n<p>空间复杂度一般只有两种情况：<br/> 创建了常数个变量：O(1)<br/> 创建了N个变量：O(N)</p>\n<p>以上就是本篇的全部内容。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-18 09:35:27", "summary": "目录算法效率时间复杂度概念大的线性表示法时间复杂度举例空间复杂度空间复杂度的定义空间复杂度举例时间复杂度与空间复杂度是用来分析一个算法的效率的。算法效率算法效率分析分为两种：第一种是时间效率，第二种是"}