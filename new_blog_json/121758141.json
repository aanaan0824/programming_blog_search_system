{"blogid": "121758141", "writerAge": "码龄1年", "writerBlogNum": "144", "writerCollect": "609", "writerComment": "35", "writerFan": "804", "writerGrade": "5级", "writerIntegral": "2383", "writerName": "IT孔乙己", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121758141.jpg", "writerRankTotal": "68236", "writerRankWeekly": "162821", "writerThumb": "121", "writerVisitNum": "181993", "blog_read_count": "12417", "blog_time": "于 2021-12-09 14:06:26 发布", "blog_title": "python 继承（史上最详细版本）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>目录</p>\n<h2>继承</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\21f3d5b0bec9404bb111ae0c14daf04f.png\"/></p>\n<h2>继承简介</h2>\n<ol><li>继承是一种创建新类的方式，新建的类可称为子类或派生类，父类可称为基类或超类</li><li><strong>python支持多继承，新建的类可以支持一个或多个父类</strong></li></ol>\n<pre>'''单继承和多继承简单定义'''\nclass Parent1:\n    pass\nclass Parent2:\n    pass\nclass Sub1(Parent1): #单继承\n    pass\nprint(Sub1.__bases__)  # 查看自己的父类----&gt;(&lt;class '__main__.Parent1'&gt;,)\n\nclass Sub2(Parent1,Parent2): # 多继承\n    pass\nprint(Sub2.__bases__)    # 查看自己的父类----&gt;(&lt;class '__main__.Parent1'&gt;, &lt;class '__main__.Parent2'&gt;)</pre>\n<h2>经典类与新式类</h2>\n<p><a class=\"has-card\" href=\"https://docs.qq.com/pdf/DR1doYmNBYUZ3RVNX\" title=\"python学习资源汇总 需要的伙伴自取\"><span class=\"link-card-box\"><span class=\"link-title\">python学习资源汇总 需要的伙伴自取</span><span class=\"link-desc\">腾讯文档-在线PDF</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://docs.idqqimg.com/tim/docs/docs-design-resources/pc/svg/file_pdf_16-e0863a743b.svg\"/>https://docs.qq.com/pdf/DR1doYmNBYUZ3RVNX</span></span></a></p>\n<p>在py2中有经典类和新式类的区别：</p>\n<ul><li> <p>新式类：继承了object类的子类，以及该子类的子类，子子类</p> </li><li> <p>经典类：没有继承object类的子类，以及该子类的子类，子子类</p> </li></ul>\n<pre>'''py2中'''\nclass Foo:\n    pass     # 经典类\nclass Bar(object):\n    pass     # 新式类</pre>\n<p>注意：在py3中没有继承任何类，默认继承object类，所以python3中都是新式类</p>\n<pre>'''py3中'''\nclass Foo():\n    pass\nprint(Foo.__bases__) # ---&gt;(&lt;class 'object'&gt;,),默认继承object类\n\nclass Sub(Foo):\n    pass\n\nprint(Sub.__bases__) # ----&gt;(&lt;class '__main__.Foo'&gt;,)</pre>\n<h2>类继承解决了什么问题</h2>\n<ul><li>类解决对象与对象之间代码冗余的问题,子类可以遗传父类的属性</li><li>继承解决的是类与类之间代码冗余的问题</li><li>object类丰富了代码的功能</li></ul>\n<p>示例如下：</p>\n<pre>'''学生选课系统和老师打分功能'''\n# 学生类\nclass Student():\n    def __init__(self,name,age,gender,course = None):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.course = course\n    # 定义一个选课的方法\n    def choose_course(self,course):\n        if self.course is None:\n            self.course = []\n        self.course.append(course)\n        print(f\"Student choice class ---&gt;{self.course}\")\n\n# 教师类\nclass Teacher():\n    def __init__(self,name,age,gender,level):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.level = level\n    # 定义一个打分方法\n    def make_score(self,stu_obj,score):\n        stu_obj.score = score\n        print(f'Teacher{self.name} make {stu_obj.score} to {stu_obj.name}! ')\n    \n'''有很多冗余的代码，优化一下，定义一个人的类整合一下重复的代码'''\n# 人类\nclass Human():\n    def __init__(self, name, age, gender):\n        self.name = name\n        self.age = age\n        self.gender = gender\n\n\n# 学生类\nclass Student(Human):\n    def __init__(self, name, age, gender, score=None, course=None):\n        Human.__init__(self, name, age, gender)\n        self.score = score\n        self.course = course\n\n    # 定义一个选课的方法\n    def choose_course(self, course):\n        if self.course is None:\n            self.course = []\n        self.course.append(course)\n        print(f\"Student choice class ---&gt;{self.course}\")\n\n\n# 教师类\nclass Teacher(Human):\n    def __init__(self, name, age, gender, level):\n        Human.__init__(self, name, age, gender)\n        self.level = level\n\n    # 定义一个打分方法\n    def make_score(self, stu_obj, score):\n        stu_obj.score = score\n        print(f'Teacher{self.name} make {stu_obj.score}marks to {stu_obj.name}! ')\n\n\n# 学生类实例化\nstu = Student('HammerZe', 18, 'male')\nstu.choose_course('python')\n\n# 教师类实例化\nteacher = Teacher('li', 18, 'male', 10)\nteacher.make_score(stu, 90)\n\nStudent choice class ---&gt;['python']\nTeacherli make 90marks to HammerZe!</pre>\n<h2>多继承的优缺点</h2>\n<ul><li> <p>优点：子类可以同时遗传多个父类的属性，最大限度的重用代码</p> </li><li> <p>缺点：违反人的思维习惯，一个人有两个爹，代码的可读性会变差，不建议使用多继承，如果不可避免多个父类的继承，应该使用 <code>Mixins机制</code> <a href=\"https://blog.csdn.net/u010377372/article/details/70256043\" title=\"参考\">参考</a></p> </li><li> <p>继承表达的是一种“是”什么关系</p> </li></ul>\n<h2>继承的查找顺序</h2>\n<ul><li> <p>对象&gt;子类&gt;父类&gt;父父类</p> </li><li> <p>单继承背景下属性查找</p> </li></ul>\n<p>示例如下：</p>\n<pre>class Foo():\n    def f1(self):\n        print('Foo.f1')\n\n    def f2(self):\n        print('Foo.f2')\n        self.f1()\n\nclass Bar(Foo):\n    def f1(self):\n        print('Bar.f1')\n\n\nobj = Bar()\nobj.f2()\n# 结果\nFoo.f2\nBar.f1\n\n'''查找顺序：\n1.obj先从obj名称空间找，再从Bar名称空间中找，没有f2去他爹(Foo)中找\n2.执行Foo中得f2，遇到self.f1()此时self是obj，是Bar的对象\n3.执行Bar中的f1\n'''\n\n\n# 区别下:父类不想让子类的方法覆盖，可以私有化\nclass Foo:\n    def __f1(self):  # _Foo__f1()\n        print('Foo.f1')\n\n    def f2(self):\n        #\n        print('Foo.f2')\n        self.__f1()  # _Foo__f1()\n\n\nclass Bar(Foo):\n    def __f1(self):  # # _Bar__f1()\n        print('Bar.f1')\n\nobj = Bar()\nobj.f2()\n\n# 结果\nFoo.f2\nFoo.f1\n'''Foo中f1私有化，所以输出的是Foo中的f1'''</pre>\n<h2>多继实现原理</h2>\n<h3>菱形结构</h3>\n<p>在python中可以继承多个类，这样就会引发下面的结构：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\d3510b276bb1f69d3be0d584e748c2b6.png\"/></p>\n<ul><li>当D继承B和C，B、C分别继承A就会组成一个菱形的继承关系，这样就会涉及到查找属性的顺序问题，A、B、C、中如果方法重名，输出的顺序是按 <code>mro</code> 列表输出的顺序继承</li></ul>\n<p>示例如下：</p>\n<pre>'''py3中'''\n\nclass A():\n    def out_text(self):\n        print('from A')\n\nclass B(A):\n    def out_text(self):\n        print('from B')\n\nclass C(A):\n    def out_text(self):\n        print('from C')\n\nclass D(B,C):\n    pass\n\nobj = D()\nobj.out_text() # 结果----&gt;from B\n''' 可以打印出mro列表查看顺序'''\nprint(D.mro())\n# [&lt;class '__main__.D'&gt;,\n# &lt;class '__main__.B'&gt;, \n# &lt;class '__main__.C'&gt;, \n# &lt;class '__main__.A'&gt;,\n# &lt;class 'object'&gt;]\n\n'''这样看来查找顺序就显而易见了，\n1、从D中找out_text方法，没有直接去B\n2、B中有out_text方法，直接输出停止查找'''</pre>\n<ul><li> <p>mro列表查找准则：</p>\n<ol><li> <p>子类先查，再查父类</p> </li><li> <p>当继承多个父类的时候，按mro列表顺序被检查</p> </li><li> <p>如果继承多个类，被继承类内具有相同的方法，先输出mro列表左边类的方法</p> </li></ol></li><li> <p>注意：mro列表可以写成 <code>__mro__</code> 也可以，调用mro方法的必须是起始类，obj是D的对象，所以用D.mro()</p> </li><li> <p>mro列表是通过一个C3线性算法来实现的</p> </li></ul>\n<h3>非菱形结构</h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\f5106691fee5826391e0e1d8d6a16858.png\"/></p>\n<p>代码实现如下：</p>\n<pre>'''py3中'''\n\n\nclass E:\n    pass\n\n\nclass F:\n    pass\n\n\nclass B(E):\n    pass\n\n\nclass C(F):\n    pass\n\n\nclass D:\n    def test(self):\n        print('from D')\n\n\nclass A(B, C, D):\n    pass\n\n\nprint(A.mro())\n'''\n查找顺序如下：\n[&lt;class '__main__.A'&gt;, \n&lt;class '__main__.B'&gt;, \n&lt;class '__main__.E'&gt;, \n&lt;class '__main__.C'&gt;, \n&lt;class '__main__.F'&gt;, \n&lt;class '__main__.D'&gt;,\n &lt;class 'object'&gt;]\n'''\n\nobj = A()\nobj.test()  \n# 结果为：from D</pre>\n<h3>深度优先和广度优先</h3>\n<p>深度优先：</p>\n<ul><li><strong>经典类：按深度优先查询</strong></li></ul>\n<p>经典类查找顺序如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\c36efae8334b0d92e2b2b0b4afdf615b.png\"/></p>\n<p>在py2中，没有继承object的类及其子类都是经典类</p>\n<p>代码实现：</p>\n<pre>'''py2中'''\nclass G:\n    def test(self):\n        print('from G')\nclass E(G):\n    def test(self):\n        print('from E')\nclass F(G):\n    def test(self):\n        print('from F')\nclass B(E):\n    def test(self):\n        print('from B')\nclass C(F):\n    def test(self):\n        print('from C')\nclass D(G):\n    def test(self):\n        print('from D')\n\nclass A(B, C, D):\n    pass\n\n\nobj = A()\nobj.test()  # 查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object\n\n# 结果\nfrom B</pre>\n<p>广度优先：</p>\n<ul><li>新式类：按广度优先顺序查找</li></ul>\n<p>新式类查找顺序如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\e4d0cf7f4bb1ff0431abeedcf7468f41.png\"/></p>\n<p>在py3中，默认为新式类</p>\n<p>代码实现如下：</p>\n<pre>'''py3中'''\nclass G:\n    def test(self):\n        print('from G')\nclass E(G):\n    pass\nclass F(G):\n    pass\nclass B(E):\n    pass\nclass C(F):\n    pass\nclass D(G):\n    def test(self):\n        print('from D')\n\nclass A(B, C, D):\n    pass\n\n\nobj = A()\nobj.test() # 查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object\n\n# 结果\nfrom D</pre>\n<h2><a class=\"has-card\" href=\"https://docs.qq.com/pdf/DR1doYmNBYUZ3RVNX\" title=\"python学习资源汇总 需要的伙伴自取\"><span class=\"link-card-box\"><span class=\"link-title\">python学习资源汇总 需要的伙伴自取</span><span class=\"link-desc\">腾讯文档-在线PDF</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://docs.idqqimg.com/tim/docs/docs-design-resources/pc/svg/file_pdf_16-e0863a743b.svg\"/>https://docs.qq.com/pdf/DR1doYmNBYUZ3RVNX</span></span></a></h2>\n<h2>super（）方法</h2>\n<p>super（）方法的存在就是为了解决多重继承的问题，在一个父类中使用super（）方法用于调用下一个父类的方法</p>\n<ul><li>super方法</li></ul>\n<pre>class A:\n    def test(self):\n        print('from A')\n        super().test()\n'''用于调用下一个父类的方法B.test'''\n\nclass B:\n    def test(self):\n        print('from B')\n\n\nclass C(A, B):\n    pass\n\n\nc = C()\nc.test()\nprint(C.mro())\n# 查找顺序如下\n#[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;]\n\n# 结果\nfrom A\nfrom B</pre>\n<h2>方法补充：</h2>\n<ol><li> <p><code>sel.__class__</code> 查看对象所属类</p> </li><li> <p><code>类名/对象名.__dict__</code> 查看类/对象名称空间</p> </li><li> <p><code>类名/对象名.__bases__</code> 查看父类</p> </li><li> <p><code>起始类名.__mro__</code> 打印继承顺序，py3从左到右查找</p> </li><li> <p><code>locals()</code> 查看局部名称空间</p> </li><li> <p><code>globals()</code> 查看全局名称空间</p> </li><li> <p><code>dirs(str)</code> 查看字符串所搭配的内置方法有哪些，查看内容可换</p> </li></ol>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/728b0666929d919cf4413d6d6ee8be41.gif\"/></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-12-09 14:06:26", "summary": "目录继承继承简介继承是一种创建新类的方式，新建的类可称为子类或派生类，父类可称为基类或超类支持多继承，新建的类可以支持一个或多个父类单继承和多继承简单定义单继承查看自己的父类多继承查看自己的父类经典类"}