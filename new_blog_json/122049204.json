{"blogid": "122049204", "writerAge": "码龄5年", "writerBlogNum": "33", "writerCollect": "423", "writerComment": "37", "writerFan": "791", "writerGrade": "3级", "writerIntegral": "535", "writerName": "CSSDCC", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122049204.jpg", "writerRankTotal": "45081", "writerRankWeekly": "11078", "writerThumb": "160", "writerVisitNum": "49262", "blog_read_count": "5433", "blog_time": "已于 2022-04-18 13:50:14 修改", "blog_title": "C++ 知识点/面试题目总结 （八股文）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>C++ 知识点/面试题目总结 （八股文）</h3>\n<ul><li><a href=\"#1_CC_5\">1. C和C++的区别</a></li><li><a href=\"#2__15\">2. 构造函数后面的冒号有什么用</a></li><li><a href=\"#3___default_delete_33\">3. 函数后面 = default和= delete有什么用？</a></li><li><a href=\"#4__60\">4. 类的大小和什么有关系？</a></li><li><a href=\"#5_structtypedef_struct_78\">5. struct和typedef struct什么区别</a></li><li><a href=\"#6_const_94\">6. 函数后面加const</a></li><li><a href=\"#7__110\">7. 共享数据的保护</a></li><li><a href=\"#8__130\">8. 运算符重载注意</a></li><li><a href=\"#9__137\">9. 程序内存分配方式以及它们的区别</a></li><li><a href=\"#10__147\">10. 全局变量、全局静态变量、静态变量、静态函数</a></li><li><ul><li><a href=\"#101__148\">10.1 全局静态变量和全局变量的区别</a></li><li><a href=\"#102_static_155\">10.2 请说一下static的作用</a></li><li><a href=\"#103__175\">10.3 静态成员函数与普通成员函数的区别</a></li></ul>\n</li><li><a href=\"#11_new_delete__malloc_free_180\">11. new delete 与 malloc free的联系与区别</a></li><li><a href=\"#12_explicit_186\">12. explicit</a></li><li><a href=\"#13_CC_211\">13. C/C++中指针和引用的区别：</a></li><li><a href=\"#14_ccast_215\">14. c++的四中cast转换</a></li><li><a href=\"#15_mutable_234\">15. mutable关键字</a></li><li><a href=\"#16_const_238\">16. 用const修饰函数的返回值</a></li><li><a href=\"#17_constenum_246\">17. 宏、const、enum</a></li><li><a href=\"#18_stack_282\">18. stack的生存期</a></li><li><a href=\"#19_STL_296\">19. STL相关</a></li><li><a href=\"#20__340\">20. 程序编译</a></li><li><a href=\"#21_classstruct_344\">21. class和struct的区别</a></li></ul>\n</div>\n<p></p>\n<blockquote>\n<p><font color=\"red\">持续更新，欢迎纠正~ </font><br/> 有需要的同学可以看目录找到相应的知识点</p>\n</blockquote>\n<hr/>\n<h1><a id=\"1_CC_5\"></a>1. C和C++的区别</h1>\n<p>设计思想上：</p>\n<blockquote>\n<p>C++是面向对象的语言，而C是面向过程的结构化编程语言。</p>\n</blockquote>\n<p>语法上：</p>\n<blockquote>\n<p>C++具有封装、继承和多态三大特性。<br/> C++相比较C，增加了许多类型安全的功能，比如强制类型转换、智能指针。<br/> C++支持泛型编程，比如模板类，函数模板等。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"2__15\"></a>2. 构造函数后面的冒号有什么用</h1>\n<p>在<code>构造函数</code>后面加冒号，表示冒号后面接构造函数初始化列表（constructor initialize list），主要有三种应用场景：</p>\n<ul><li>对基类进行初始化</li><li>对类成员进行初始化</li><li>对类的const成员变量进行初始化<br/> 由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或者使用初始化列表赋值。</li></ul>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">thread_guard</span> <span class=\"token punctuation\">{<!-- --></span>\n\tstd<span class=\"token operator\">::</span>thread<span class=\"token operator\">&amp;</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">explicit</span> <span class=\"token function\">thread_guard</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>thread<span class=\"token operator\">&amp;</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">t</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">thread_guard</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>​</p>\n<hr/>\n<h1><a id=\"3___default_delete_33\"></a>3. 函数后面 = default和= delete有什么用？</h1>\n<p><a href=\"https://blog.csdn.net/lixiaogang_theanswer/article/details/81090622\">https://blog.csdn.net/lixiaogang_theanswer/article/details/81090622</a><br/> <a href=\"https://blog.csdn.net/weixin_38339025/article/details/89161324?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base\">https://blog.csdn.net/weixin_38339025/article/details/89161324?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base</a><br/> = default：</p>\n<blockquote>\n<p>当我们编写一个类时，若不显著写明，则类会默认为我们提供如下几个函数：构造函数、析构函数、拷贝构造函数、拷贝赋值函数（operator=）、移动构造函数。<br/> 简单来说：<font color=\"red\">=defalut是使得函数为编译器默认的形式。</font><br/> = default只能用于（类的）特殊的成员函数（默认构造函数，复制构造函数，析构函数等）。例如，<font color=\"red\">当我们声明了一个有参构造函数时，编译器就不会创建默认构造函数（无参）</font>。这个时候声明对象时不带参就会出错，此时我们就要自己声明一个无参构造函数。但是自己声明默认构造函数就会失去编译器对于默认构造函数的一些优化，跟POD有关，所以我们可以在自己声明的无参构造函数后面加上=defalut来说明为默认构造函数，这样他就会做默认构造函数会做的一些事情。<br/> ​</p>\n</blockquote>\n<p>= delete：</p>\n<blockquote>\n<p>= delete就是禁用该种函数使用，比如<br/> ① 禁用拷贝构造函数<br/> {A&amp; operator=(const A&amp;) = delete}<br/> A a1, a2, a3;<br/> a1 = a2;//错<br/> ② 禁用不需要用的参数转换<br/> {A(int) {}<br/> A(double) {}}<br/> A a1(1);//正确<br/> A a2(2.2);//错误，被禁用了<br/> ​</p>\n</blockquote>\n<p>总结：<br/> =defalut使得被修饰的函数为编译器默认的形式。=delete使得编译器禁止该类型的成员函数生成。<br/> 对特殊成员函数使用以上修饰符使得代码更容易阅读。</p>\n<hr/>\n<h1><a id=\"4__60\"></a>4. 类的大小和什么有关系？</h1>\n<p>类的大小计算没那么简单，涉及到虚函数成员、静态成员、虚继承、多继承以及空类等，不同情况有对应的计算方式，在此对各种情况进行总结。<br/> 首先明确一个概念，<strong>平时所声明的类只是一种类型定义，它本身是没有大小可言的</strong>。我们这里所说的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。<br/> <font color=\"red\">记住以下几点：</font></p>\n<ul><li>首先，类的大小遵循结构体的对齐原则</li><li>类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常亮数据成员均对类的大小无影响。</li><li>虚函数对类的大小有影响，是因为虚函数表指针带来的影响</li><li>虚继承对类的大小有影响，是因为虚基表指针带来的影响</li><li>空类的大小是一个特殊情况，空类的大小为</li></ul>\n<p>解释：</p>\n<ul><li>静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类的所有对象共享，并不属于哪个对象。</li></ul>\n<p><a href=\"https://blog.csdn.net/fengxinlinux/article/details/72836199\">https://blog.csdn.net/fengxinlinux/article/details/72836199</a></p>\n<hr/>\n<h1><a id=\"5_structtypedef_struct_78\"></a>5. struct和typedef struct什么区别</h1>\n<p>在C中定义一个结构体类型要用typedef：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">student</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>Stu<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这时声明变量就可以：Stu stu1;<br/> 如果上面没有加typedef就必须用struct Student stu1来声明。这里的Stu实际上就是struct Student的别名。<br/> 另外这里也可以不写Student（typedef struct {}Stu;那声明变量的时候就不能struct Student stu1;了只能Stu stu1;）<br/> 而C++中，直接struct name {}就行了。<br/> 另外，在C++中加了typedef又会不一样<br/> ① struct name {int a;}stu; 这里stu是一个变量。<br/> ② typedef struct name{int a;}std;这里的stu是一个结构体类型。</p>\n<hr/>\n<h1><a id=\"6_const_94\"></a>6. 函数后面加const</h1>\n<p>const只能加在类的成员函数后面（普通函数不可以），也就是说这些成员函数是只读函数。<br/> 1、非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）<br/> 2、加了cosnt的成员函数，表示成员函数<font color=\"red\">隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的</font>（因为隐含了对this指针的const引用）<br/> 费静态成员函数后面加const和mutable是反义词<br/> ​</p>\n<p>加了const的成员函数可以被<code>非const**对象**</code>和<code>const对象</code>调用。注意是对象。<br/> 但不加const的成员函数只能被<code>非const对象</code>调用。<br/> ​</p>\n<p>函数前面加cosnt表示返回值是const，函数后面加const表示不可以修改class的成员。<br/> 什么时候用？<br/> 当不改变数据成员的函数都加上cosnt关键字，提高程序的可读性，提高程序的可靠性，保护数据。比如函数为get_a, get_b, get_sum；</p>\n<hr/>\n<h1><a id=\"7__110\"></a>7. 共享数据的保护</h1>\n<p>1、常引用：所引用的形参不能被更新</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span><span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>2、常对象：在生存期内不能被更新，但必须被初始化</p>\n<pre><code class=\"prism language-cpp\">A <span class=\"token keyword\">const</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>3、常成员函数：不能修改对象中数据成员，也不能调用类中没有被const修饰的成员函数（常对象唯一的对外接口）。如果声明了一个常对象，则该对象只能调用它的常函数！另外，可以用于对重载函数的区分。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>4、extern int a;使得其他文件也能访问该变量</p>\n<p>声明一个函数或定义函数时，冠以static的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数（每一个cpp文件就是一个编译单元）</p>\n<hr/>\n<h1><a id=\"8__130\"></a>8. 运算符重载注意</h1>\n<ul><li>单目运算符最好重载为成员函数，双目最好为友元函数。</li><li>=、[]只能重载成员函数，&lt;&lt;和&gt;&gt;只能重载为友元函数。<br/> ​</li></ul>\n<hr/>\n<h1><a id=\"9__137\"></a>9. 程序内存分配方式以及它们的区别</h1>\n<p>内存分配大致上可以分成5块：</p>\n<ol><li><code>栈区（stack）</code>。栈，就是那些由编译器在需要时分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）</li><li><code>堆区（heap）</code>。一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆时两回事，分配方式类似于链表。</li><li><code>全局区（静态区）（static）</code>。全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。</li><li><code>常量存储区</code>。常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。</li><li><code>程序代码区</code>。存放函数体的二进制代码。</li></ol>\n<hr/>\n<h1><a id=\"10__147\"></a>10. 全局变量、全局静态变量、静态变量、静态函数</h1>\n<h2><a id=\"101__148\"></a>10.1 全局静态变量和全局变量的区别</h2>\n<ol><li>若程序由一个源文件构成时，全局变量与全局静态变量没有区别。</li><li>若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的原文见所独享，即全局静态变量对组成改程序的其他源文件时无效的。</li><li>具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。</li></ol>\n<p>—静态变量只被所属源文件使用。</p>\n<h2><a id=\"102_static_155\"></a>10.2 请说一下static的作用</h2>\n<p>static关键字有如下几种作用：<br/> 1、全局静态变量<br/> 在全局变量前加上关键字static，全局变量就被定义成一个全局静态变量。<br/> 存放区：存放在静态存储区，在整个程序运行期间一直存在。<br/> 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）<br/> 作用域：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。<br/> 2、局部静态变量<br/> 在局部变量前加上关键字static，局部变量就被定义成一个局部静态变量。<br/> 存放区：静态存储区。<br/> 初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）<br/> 作用域：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。<br/> 3、静态函数<br/> 在函数返回类型前加static，函数就被定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。<br/> 这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。<br/> warning：（没懂）不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件中去，否则cpp内部声明需加上static修饰。<br/> 4、类的静态成员<br/> 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。<br/> 5、类的静态函数<br/> 静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用class_name::static_func()就可以访问。</p>\n<h2><a id=\"103__175\"></a>10.3 静态成员函数与普通成员函数的区别</h2>\n<p>静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）<br/> 普通成员函数有this指针，可以访问类中的任意成员（普通成员变量和静态成员变量，好像静态成员函数没有this指针不能通过this访问，但是可以通过类名::访问）；而静态成员函数没有this指针。</p>\n<hr/>\n<h1><a id=\"11_new_delete__malloc_free_180\"></a>11. new delete 与 malloc free的联系与区别</h1>\n<ul><li>new delete 和 malloc free都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄漏或者二次释放。</li><li>不同的是，new delete是C++中定义的操作符，new除了分配空间外，还会调用类的构造函数来完成初始化工作，delete除了释放空间外还会调用类的西沟函数。而malloc和free是C语言中定义的函数</li></ul>\n<hr/>\n<h1><a id=\"12_explicit_186\"></a>12. explicit</h1>\n<p><font color=\"red\">explicit关键字只能用于类的构造函数的声明上。<br/> 它的作用是防止构造函数进行的隐式转换。</font><br/> 在C++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担了两个角色。<br/> ① 第一是构造<br/> ② 第二是默认且隐含的类型转换操作符。即如果构造函数接收到的参数会默认进行隐式转换。<br/> 隐式转换看起来很方便，但是某些情况下违背了程序员的本意。这个时候就要加上explicit修饰，指定这个构造器只能被明确的调用/使用，不能进行隐式转换。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">explicit</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">m_a</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">m_b</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> m_a<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> m_b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    A <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//正确</span>\n    A <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token number\">2.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 错误，存在double-&gt;int的隐式转换。</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h1><a id=\"13_CC_211\"></a>13. C/C++中指针和引用的区别：</h1>\n<p>待更新</p>\n<hr/>\n<h1><a id=\"14_ccast_215\"></a>14. c++的四中cast转换</h1>\n<p>四中cast转换是C++的强制转换。<br/> cast-name&lt;target_type&gt;(expression);<br/> <strong>1、const_cast</strong><br/> 唯一一个可以改变const性质的转换<br/> <strong>2、static_cast</strong><br/> 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast<br/> <strong>3、dynamic_cast</strong><br/> 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果时非法的对于指针返回null，对于引用抛出异常。要深入理解内部转换的原理<br/> 向上转换：指的是子类向基类的转换。<br/> 向下转换：指的是基类向子类的转换。<br/> 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。<br/> <strong>4、reinterpret_cast</strong><br/> 几乎什么都可以转，可能会出问题，尽量少用。<br/> <strong>5、为什么不用C的强制转换？</strong><br/> C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。<br/> C的强制转换 (type_name) expression</p>\n<hr/>\n<h1><a id=\"15_mutable_234\"></a>15. mutable关键字</h1>\n<p>mutable的中文意思时可变的、易变的，跟constant（即C++里的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量（<font color=\"red\">mutable只能用于修饰类的非静态数据成员</font>），将永远处于可变的状态（可以修改成员数据之类的），即使在一个const函数中。</p>\n<hr/>\n<h1><a id=\"16_const_238\"></a>16. 用const修饰函数的返回值</h1>\n<p>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能修改，且该返回值只能被赋给加const的同类型指针。一般只在返回值为引用或指针时使用，返回其他值时没有必要。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> <span class=\"token function\">get_string</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str <span class=\"token operator\">=</span> <span class=\"token function\">get_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//编译报错</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str <span class=\"token operator\">=</span> <span class=\"token function\">get_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//正确</span>\n</code></pre>\n<hr/>\n<h1><a id=\"17_constenum_246\"></a>17. 宏、const、enum</h1>\n<ol><li>#define不被视为语言的一部分（#define属于预处理器）。对于单纯常量，最好用const对象或者enum替换#define。</li><li>对于类似函数的宏，尽量使用内联函数替换掉#define</li></ol>\n<p>​</p>\n<ol><li>编译器处理方式不同<br/> define宏是在预处理阶段展开。<br/> const常量是在编译运行阶段使用</li><li>类型<br/> define宏没有类型，不做任何类型检查，仅仅是展开。<br/> const常量没有具体的类型，在编译阶段会执行类型检查。</li><li>起作用的方式<br/> #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以别面一些低级的错误。正因为define只是简单的字符串替换，会导致边界效应，很容易犯错。具体可以参考以下代码</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">N</span> <span class=\"token expression\"><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">3</span></span></span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> a <span class=\"token operator\">=</span> N<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//结果是2+3/2 = 2+1 = 3</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span>N <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//我们预想的答案是2.5，可实际输出的值是2 + 3 / 2 = 3.5</span>\n</code></pre>\n<ol start=\"4\"><li>占用空间<br/> define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。占用代码段空间<br/> const常量会在内存中分配（可以是在堆中也可以是在栈中） 占用数据段空间</li><li>调试角度<br/> const常量是可以进行调试的，#define不能进行调试，因为在预编译阶段就已经替换掉了。</li><li>作用域<br/> const变量是由作用域的，define在没有遇到#undefine之前是没有作用域限制的</li></ol>\n<p>在C++程序中一般只使用const常量而不是用宏常量，即const常量完全取代宏常量。<br/> 宏可以提高程序的易读性，比如数组大小，模式mode</p>\n<hr/>\n<h1><a id=\"18_stack_282\"></a>18. stack的生存期</h1>\n<p>C++中的static对象是指存储区不属于stack和heap、“寿命”从被构造出来直至程序结束为止的对象。这些对象包括全局对象，定义于namespace作用域的对象，在class、function以及file作用域中被声明为static的对象。其中，函数内的static对象成为local static对象，而其他static对象成为non-local static对象。<br/> 这两者在何时初始化（构造）的问题上存在细微的差别：</p>\n<ul><li>对于local static对象，在其所属的函数被调用之前，该对象并不存在，即只有在第一次调用对应函数时，local static对象才被构造出来。</li><li>而对于non-local static对象，在main()函数开始前就已经被构造出来，并在main()函数结束后被析构。</li></ul>\n<p>建议：</p>\n<ol><li>对内置对象进行手动初始化，因为c++不保证初始化它们。</li><li>构造函数最好使用成员初值列，而不要在构造函数本体中使用赋值操作。初值列中列出的成员变量，其排序次序应该和它们在class中的声明次序相同（初始化顺序与声明变量顺序一致）。</li><li>为免除“跨编译单元的初始化次序问题”，尽量以local static对象替换non-local static对象。</li></ol>\n<hr/>\n<h1><a id=\"19_STL_296\"></a>19. STL相关</h1>\n<ol><li>STL被组织成12个头文件。algorithm, deque, functional, iterator, vector, list, map, memory, numeric, queue, set, stack, utility。</li><li>STL时C++通用库，由容器，算法，迭代器，仿函数，内存配置器构成。</li><li>容器<br/> 作为STL最主要的组成部分——容器，分为向量（vector），双端队列（deque），表（list），队列（queue），堆栈（stack），set，multiset，map，multimap</li></ol>\n<blockquote>\n<p>关联式容器：map，multimap，set，multiset（代表允许重复元素）<br/> <map>中包含pair&lt;typename T1, typename T2&gt;这种对组的结构体。<br/> 函数get_allocator()用于获取map或multimap的内存配置器，内存配置器类似于指针的首地址<br/> 没写文，更多请看原文</map></p>\n</blockquote>\n<ol start=\"4\"><li>算法<br/> 算法部分主要由头文件，组成。（numeric，数字，数值，分数。是用于数值计算的小库）。是所有STL头文件中最大的一个，它是由一大堆模板函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到：比较、交换、遍历操作、复制、修改、移除、反转、排序、合并等等。numeric体积很小，只包括几个在序列上面进行简单数字运算的模板函数，包括加法和乘法在序列上的一些操作。XX中则定义了一些模板类，用以声明函数对象。</li></ol>\n<blockquote>\n<p>auto_ptr只能对new分配的内存使用，不能对new[]的使用<br/> algorithm中的for_each(T.begin(), T.end(), function); find(T.begin(), T.end(), value)<br/> T.reserve(x)：预留空间。实际空间小于它则扩充。</p>\n</blockquote>\n<ol start=\"5\"><li>迭代器<br/> 在头文件iterator中，迭代器类型：输入型迭代器，输出型迭代器，前向迭代器（前两者结合），双向迭代器（可回头），随机存取迭代器。</li></ol>\n<blockquote>\n<p>没写完，更多请看原文。</p>\n</blockquote>\n<ol start=\"6\"><li>仿函数<br/> 就是函数对象，类重载了操作符();</li><li>适配器<br/> 适配器时用来修改其他组件接口的STL组件，是带有一个参数的类模板（这个参数是操作的值的数据类型）。STL定义了3种形式的适配器：容器适配器，迭代器适配器，函数适配器。</li></ol>\n<blockquote>\n<ul><li>容器适配器：包括栈（stack）、队列（queue）、优先队列（priority_queue）。使用容器适配器，stack就可以被实现为基本容器类型（vector、dequeue、list）的适配。可以把stack看做是某种特殊的vector、deque或者list容器，只是其操作仍然收到stack本身属性的限制。queue和priority_queue与之类似。容器适配器的接口更为简单，只是受限比一般容器更多。</li></ul>\n</blockquote>\n<p>容器适配器也是同样的道理，简单的理解容器适配器，其就是将不适用的序列式容器（包括vector、deque和list）变得适用。容器适配器的底层实现和模板A,B的关系也是完全相同的，即通过封装某个序列式容器，病重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。</p>\n<p>容器适配器本质上还是容器，只不过次容器模板类的实现，利用了大量其他基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。</p>\n<p>需要注意的时，STL中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。</p>\n<blockquote>\n<ul><li>迭代器适配器：修改为某些基本容器定义的迭代器的接口的一种STL组件。反向迭代器和插入迭代器都属于迭代器适配器，迭代器适配器扩展了迭代器的功能。</li><li>函数适配器：通过转换或者修改其他函数对象使其功能得到扩展。这一类适配器由否定器（相当于“非”操作）、帮顶起、函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或者将多参数的函数对象转化为少参数的函数对象。</li></ul>\n</blockquote>\n<ol start=\"8\"><li>空间/内存配置器（allocator）<br/> 分为一级配置器和二级配置器。没写完</li></ol>\n<blockquote>\n<p>STL的分配器（allocator）用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：</p>\n<ul><li>new运算分两个阶段：① 调用::operator new配置内存；② 调用对象构造函数构造对象内容</li><li>delete运算分两个阶段：① 调用对象析构函数；② 调用::operator delete释放内存。<br/> 为了精密分工，STL allocator将两个阶段操作区分开来：内存配置由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</li><li>同时为了提升内存管理的效率，较少申请小内存造成的内存碎片问题，SGI STL采用了两级适配器，当分配的空间大小炒作128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器会直接使用malloc()，realloc()，free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</li></ul>\n</blockquote>\n<hr/>\n<h1><a id=\"20__340\"></a>20. 程序编译</h1>\n<p>程序编译是指将源文件翻译成二进制目标代码的过程。主要是检查语法错误，正确的源程序文件经过编译后在磁盘上生成目标文件。便已产生的目标文件是可重定位的程序模块，不能直接运行。链接则是把目标文件和其他分别进行编译生成的目标程序模块以及系统提供的标准库函数链接在一起，生成可运行的可执行文件。</p>\n<hr/>\n<h1><a id=\"21_classstruct_344\"></a>21. class和struct的区别</h1>\n<p>c++中，class和struct都可以定义一个类。它们有以下两点区别：<br/> 1、默认继承权限，如果不指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理。<br/> 2、成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。<br/> 以上两点<font color=\"red\">（权限）是struct和class最基本的差别，也是最本质的差别</font>。<br/> 但是语义上一般倾向于把struct昂做C时代的struct来用，即只有成员变量，没有逻辑（或只有极其简单的数据存入读取逻辑），用来把多个变量打包成一个类型，而不用struct来做面向对象变成意义上的class。这个是编码风格的范畴，为的是方便代码阅读。</p>\n<hr/>\n<blockquote>\n<p>都看到这句话了不如点个赞吧~~（收藏不赞，增益减半）</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-18 13:50:14", "summary": "知识点面试题目总结八股文和的区别构造函数后面的冒号有什么用函数后面和有什么用？类的大小和什么有关系？和什么区别函数后面加共享数据的保护运算符重载注意程序内存分配方式以及它们的区别全局变量、全局静态变量"}