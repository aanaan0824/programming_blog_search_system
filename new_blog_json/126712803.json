{"blogid": "126712803", "writerAge": "码龄2年", "writerBlogNum": "46", "writerCollect": "1", "writerComment": "1", "writerFan": "54", "writerGrade": "3级", "writerIntegral": "473", "writerName": "阿磊学不会001", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126712803.jpg", "writerRankTotal": "39963", "writerRankWeekly": "19726", "writerThumb": "10", "writerVisitNum": "4747", "blog_read_count": "97", "blog_time": "于 2022-09-05 20:59:56 发布", "blog_title": "redis的解决分布式锁的bug 和 redis面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1.redis的解决分布式锁的bug</h1>\n<p>        Redis分布式锁不能解决超时问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>\n<p>        可以使用：redission依赖，redission解决redis超时问题的原理。</p>\n<p><img alt=\"\" height=\"532\" src=\"..\\..\\static\\image\\9d8c4b75d6bb43bf8318dea38c30f785.png\" width=\"1179\"/></p>\n<p>         为持有锁的线程开启一个人守护线程，守护线程会每隔10秒检查当前线程是否持有锁，如果持有则延迟生存时间。</p>\n<p>        使用：</p>\n<pre><code class=\"language-java\">  &lt;dependency&gt;\n            &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n            &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n            &lt;version&gt;3.13.4&lt;/version&gt;\n        &lt;/dependency&gt;\n        \n         //获取redisson对象并交于spring容器管理\n    @Bean\n    public Redisson redisson(){\n        Config config =new Config();\n        config.useSingleServer().\n                setAddress(\"redis://localhost:6379\").\n                //redis默认有16个数据库\n                setDatabase(0);\n        return (Redisson) Redisson.create(config);\n    }</code></pre>\n<pre><code class=\"language-java\">@Override\n    public String decreaseStock(Integer productId) {\n        //获取锁对象\n        RLock lock = redisson.getLock(\"aaa::\" + productId);\n        try {\n            lock.lock(30, TimeUnit.SECONDS);\n            //查看该商品的库存数量\n            Integer stock = productStockDao.findStockByProductId(productId);\n            if (stock &gt; 0) {\n                //修改库存每次-1\n                productStockDao.updateStockByProductId(productId);\n                System.out.println(\"扣减成功！剩余库存数:\" + (stock - 1));\n                return \"success\";\n            } else {\n                System.out.println(\"扣减失败！库存不足！\");\n                return \"fail\";\n            }\n        } finally {\n            lock.unlock();\n        }\n\n\n    }</code></pre>\n<h1>2. redis面试题</h1>\n<p><strong>        redis中常见的面试题</strong></p>\n<h2>2.1 什么是缓存穿透？怎么解决？</h2>\n<blockquote>\n<p>1. 数据库中没有该记录，缓存中也没有该记录，这时候有人恶意的大量访问这样的数据。这样就会导致请求绕过缓存，直接访问数据，从而造成数据库压力过大。</p>\n<p></p>\n<p>2.解决方法：</p>\n<p> 【1】在controller加数据校验。</p>\n<p> 【2】我们可以在redis中存入一个空对象，返回值为空，只不过这个对象的过期时间不能太长，最多不超过5分钟。</p>\n<p> 【3】使用布隆过滤器。底层：有一个bitmap数组，里面存储了该表的所有id。</p>\n</blockquote>\n<pre><code class=\"language-java\">//伪代码\nString get(String key) { //布隆过滤器钟存储的是数据库表钟对应的id\n    String value = redis.get(key);  //先从缓存获取。  \n    if (value  == null) { //缓存没有命中\n        if(!bloomfilter.mightContain(key)){//查看布隆过滤器钟是否存在\n            return null; \n        }else{\n            value = db.get(key); //查询数据库\n            redis.set(key, value); \n        }    \n    }\n    return value；\n}</code></pre>\n<h2>2.2 什么是缓存雪崩？如何解决？</h2>\n<blockquote>\n<p>        缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至造成down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据过期了，很多数据都查不到需要从数据库查询。</p>\n<p>        1.什么情况下会发生缓存雪崩</p>\n<p>                【1】项目刚上线，缓存中没有任何数据。</p>\n<p>                【2】缓存出现大量过期时间</p>\n<p>                【3】redis宕机</p>\n<p>        2.解决方法：</p>\n<p>                【1】上线前先把一些热点数据放入缓存。</p>\n<p>                【2】设置过期时间为散列值。</p>\n<p>                【3】搭建redis集群</p>\n</blockquote>\n<h1>2.3 什么是缓存击穿？如何解决？</h1>\n<blockquote>\n<p>        缓存击穿是指缓存中没有但数据库中有数据（一般是缓存时间到），这是由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库中取数据，引起数据库压力瞬间增大，造成过大压力。</p>\n<p>        缓存击穿解决方案：</p>\n<p>                【1】设置永久不过期。【这种适合内存】</p>\n<p>                【2】使用互斥锁（muten key）业界比较常用的做法。</p>\n</blockquote>\n<p><img alt=\"\" height=\"795\" src=\"..\\..\\static\\image\\58585f672ba34846a3dc92d07c245c14.png\" width=\"841\"/></p>\n<h1> 2.4 Redis 淘汰策略有哪些？</h1>\n<p><img alt=\"\" height=\"572\" src=\"..\\..\\static\\image\\4c0d72164c554b078943ebc6b483e09c.png\" width=\"837\"/></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-05 20:59:56", "summary": "的解决分布式锁的分布式锁不能解决超时问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。可以使用：依赖，解决超时问题的原理。为持有锁的线程开启一个人守护线程，守护线程会每隔秒检"}