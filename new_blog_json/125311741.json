{"blogid": "125311741", "writerAge": "码龄5年", "writerBlogNum": "19", "writerCollect": "29", "writerComment": "1", "writerFan": "5", "writerGrade": "2级", "writerIntegral": "211", "writerName": "不是杠杠", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125311741.jpg", "writerRankTotal": "66972", "writerRankWeekly": "106640", "writerThumb": "3", "writerVisitNum": "7700", "blog_read_count": "1909", "blog_time": "于 2022-06-16 15:09:02 发布", "blog_title": "c++ 模板", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>什么是模板？</h1>\n<p>模板是c++的一种特性，允许函数或者类（对象）通过泛型（generic types）的形式表现或者运行</p>\n<p>模板可以使得函数或类在对应不同的类型（types）的时候正常工作，而无需为每一种类型分别写一份代码。</p>\n<h2>c++ 有两种类型的模板</h2>\n<p>1：函数模板（function tempalte）：使用泛型参数的函数（function with generic parameters）</p>\n<p>2：类模板（class template）：使用泛型参数的类（class with generic parameters）</p>\n<p></p>\n<h2>模板实例化</h2>\n<p>模板的声明（declaration）其实并未给出一个函数或者类的完全定义（definition），只是提供了一个函数或者类的语法框架（syntactical skeleton）</p>\n<p>实例化是指从模板构建出一个真正的函数或者类的过程。用具体类型代替模板参数的过程叫做实例化；从而产生一个模板实例。</p>\n<p><strong>如果实例化一种类型，而该类型并不支持函数所使用的操作，那么就会导致一个编译错误</strong>。</p>\n<h3>实例化有两种类型</h3>\n<p>1：显示实例化-在代码中明确指定要针对哪种类型进行实例化</p>\n<p>2：隐式实例化-在首次使用时根据具体情况使用一种合适的类型进行实例化</p>\n<p></p>\n<h1>函数模板</h1>\n<h3>什么是函数模板？</h3>\n<p>函数模板是参数化的一族函数（a famliy of functions）</p>\n<p>通过函数模板，可以实例化一系类函数，这些函数都给予同一套模板框架，但是作用在不通类型的参数上</p>\n<p>示例 ：（针对不同的数据类型 比较两个数据的大小）</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\ntemplate &lt;typename T&gt; //模板参数由关键字typename（也可以使用class） 定义 定义一个函数模板 返回两个数中数值大的那一个 \ninline T max(const T &amp;a,const T &amp;b)//函数有两个参数 ，类型为定义 \n{\n    return a&gt;b?a:b;\n}\nint main()\n{\n    int a =1;\n    int b =2;\n    auto ret = max&lt;int&gt;(a,b);\n    std::cout&lt;&lt;\"int ret = \"&lt;&lt;ret&lt;&lt;std::endl;\n    double da=1;\n    double db =2;\n    auto ret1 = max(da,db);\n    std::cout&lt;&lt;\"double ret1 = \"&lt;&lt;ret1&lt;&lt;std::endl;\n    return 0;\n}</code></pre>\n<h3>参数推导</h3>\n<p>模板参数是由传递给模板函数的实参决定的</p>\n<p>不允许自动类型转换：每个T必须严格匹配</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\ntemplate &lt;typename T&gt; //模板参数由关键字typename（也可以使用class） 定义 定义一个函数模板 返回两个数中数值大的那一个 \ninline T max(const T &amp;a,const T &amp;b)//函数有两个参数 ，类型为定义 \n{\n    return a&gt;b?a:b;\n}\nint main()\n{\n    int a =1;\n    double b =2.0;\n    //auto ret = max(a,b); //error 模板只有一种参数 但是这里传入了两种类型的参数\n    //解决办法\n    //用static_cast 强制转换参数类型使得 参数匹配\n    auto ret1 = max(static_cast&lt;double&gt;(a),b);\n    \n    //显示指定T的类型\n    auto ret2 =  max&lt;double&gt;(a,b);\n   \n    return 0;\n}\n</code></pre>\n<p>参数不匹配报错</p>\n<p><img alt=\"\" height=\"112\" src=\"..\\..\\static\\image\\d5f79cdcf17e4a2b9277cf3be6797ffa.jpeg\" width=\"445\"/></p>\n<p></p>\n<p>函数模板重载</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\ntemplate &lt;typename T&gt; //模板参数由关键字typename（也可以使用class） 定义 定义一个函数模板 返回两个数中数值大的那一个 \ninline T max(const T &amp;a,const T &amp;b)//函数有两个参数 ，类型为定义 \n{\n    return a&gt;b?a:b;\n}\n\n#include &lt;iostream&gt;\ntemplate &lt;typename T&gt; \n\ninline T max(const T &amp;a,const T &amp;b,const T &amp;c)\n{\n   T temp;\n   if(a&lt;b)\n   {\n         temp = b;       \n   }\n   else\n   {\n        temp = a;\n   }\n   return temp &gt;c?temp :c;\n\n}\n\ninline int max(const int &amp;a,const int &amp;b)\n{\n    return a&gt;b?a:b;\n}\n\ntemplate &lt;typename T,typename T1=double&gt;\ninline T max(const T &amp;a,const T1 &amp;b)\n{   \n    std::cout&lt;&lt;\"template &lt;typename T,typename T1=double&gt; \"&lt;&lt;std::endl;\n    return a&gt;b?a:b;\n}\n\nint main()\n{\n   max(1,2,3);     // max(const T &amp;a,const T &amp;b,const T &amp;c) max&lt;int&gt;\n   max(1.0,2.3);     //max(const T &amp;a,const T &amp;b) max&lt;double&gt;\n   max('a','b');    //max(const T &amp;a,const T &amp;b)  max&lt;char&gt;\n   max(1,2);    //inline int max(const int &amp;a,const int &amp;b)\n   max&lt;&gt;(1,2);    //max(const T &amp;a,const T &amp;b) max&lt;int&gt;\n   max&lt;int&gt;(1,2);    //max(const T &amp;a,const T &amp;b) max&lt;int&gt;\n   max('a',2);    //inline int max(const int &amp;a,const int &amp;b)\n   return 0;\n}\n</code></pre>\n<p></p>\n<h1>类模板</h1>\n<p>与函数模板类似，类也可以通过参数泛化，从而可以构建出一族不同的类实例（对象）</p>\n<p>类模板实参可以是某一类型或常量（仅限int或enum）</p>\n<p>示例</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n/*********************************************************\n*T可以是任意类型\n*模板实参也可以是一个int或enum类型的常量 size_t实际是int类型\n*n是编译时定义的常量\n*n可以有默认值\n*size_t类型的成员变量可以用n初始化\n***********************************************************/\nconst std::size_t DefaultStackSize = 1024;\ntemplate &lt;typename T,std::size_t n = DefaultStackSize&gt;\nclass Stack\n{\npublic:\n    void Push(const T &amp;element);\n    int Pop(T &amp;element);\n    //int Top(T &amp;element) const;\nprivate:\n    std::vector&lt;T&gt; m_Members;\n    std::size_t m_mMaxSize = n; \n};\n\ntemplate &lt;typename T,std::size_t nMaxSize&gt;\nvoid Stack&lt;T,nMaxSize&gt;::Push(const T &amp;element)\n{\n    if(m_mMaxSize &lt;= m_Members.size())\n    {\n        return;\n    }\n    m_Members.push_back(element);\n}\n\ntemplate &lt;typename T,std::size_t nMaxSize&gt;\nint Stack&lt;T,nMaxSize&gt;::Pop(T&amp; element)\n{\n    if(m_Members.empty())\n    {\n        return -1;\n    }\n    element = m_Members.back();\n    m_Members.pop_back();\n    return 0;\n}\n\n\nint main()\n{\n    Stack&lt;int&gt; stack;\n    Stack&lt;int,100&gt; stack1;\n    for(int i =0;i&lt;100;i++)\n    {\n        stack.Push(i);\n    }\n   int i;\n   stack.Pop(i);\n   std::cout&lt;&lt;i&lt;&lt;std::endl;\n   stack.Pop(i);\n   std::cout&lt;&lt;i&lt;&lt;std::endl;\n   return 0;\n}</code></pre>\n<h2>类模板特化</h2>\n<p>允许对一个类模板的某些模板参数类型做特化</p>\n<h3>特化的作用和好处</h3>\n<p>对于某种特殊的类型，可能可以做些特别的优化或提供不同的实现</p>\n<p>避免在实例化的时候引起一些可能不好的行为</p>\n<p>特化一个类模板的时候也意味着需要特化其所有参数化的成员函数</p>\n<p>示例：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n/*********************************************************\n*T可以是任意类型\n*模板实参也可以是一个int或enum类型的常量 size_t实际是int类型\n*n是编译时定义的常量\n*n可以有默认值\n*size_t类型的成员变量可以用n初始化\n***********************************************************/\nconst std::size_t DefaultStackSize = 1024;\ntemplate &lt;typename T,std::size_t n = DefaultStackSize&gt;\nclass Stack\n{\npublic:\n    void Push(const T &amp;element);\n    int Pop(T &amp;element);\n    //int Top(T &amp;element) const;\nprivate:\n    std::vector&lt;T&gt; m_Members;\n    std::size_t m_mMaxSize = n; \n};\n\ntemplate &lt;typename T,std::size_t nMaxSize&gt;\nvoid Stack&lt;T,nMaxSize&gt;::Push(const T &amp;element)\n{\n    if(m_mMaxSize &lt;= m_Members.size())\n    {\n        return;\n    }\n    m_Members.push_back(element);\n}\n\ntemplate &lt;typename T,std::size_t nMaxSize&gt;\nint Stack&lt;T,nMaxSize&gt;::Pop(T&amp; element)\n{\n    if(m_Members.empty())\n    {\n        return -1;\n    }\n    element = m_Members.back();\n    m_Members.pop_back();\n    return 0;\n}\ntemplate &lt;&gt;\nclass Stack&lt;std::string&gt;\n{\npublic:\n    void Push(const T &amp;element);\n    int Pop(T &amp;element);\n    //int Top(T &amp;element) const;\nprivate:\n    std::list&lt;string&gt; m_Members;\n    std::size_t m_mMaxSize; \n};\n\nint main()\n{\n    Stack&lt;int&gt; stack;\n    Stack&lt;int,100&gt; stack1;\n    for(int i =0;i&lt;100;i++)\n    {\n        stack.Push(i);\n    }\n   int i;\n   stack.Pop(i);\n   std::cout&lt;&lt;i&lt;&lt;std::endl;\n   stack.Pop(i);\n   std::cout&lt;&lt;i&lt;&lt;std::endl;\n   return 0;\n}</code></pre>\n<p></p>\n<p>类模板也可以偏特化 </p>\n<pre><code>template &lt;typename T1,typename T2&gt; \nclass MyClass\n{\n};\n\n//偏特化\ntemplate &lt;typename T&gt;\nclass MyClass&lt;T,T&gt;\n{};\n\ntemplate &lt;typename T1,typename T2&gt;\nclass MyClass&lt;T1*,T2*&gt;\n{};\n\n\ntemplate &lt;typename T&gt;\nclass MyClass&lt;T,int&gt;\n{};\n\n\n</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-16 15:09:02", "summary": "什么是模板？模板是的一种特性，允许函数或者类对象通过泛型的形式表现或者运行模板可以使得函数或类在对应不同的类型的时候正常工作，而无需为每一种类型分别写一份代码。有两种类型的模板：函数模板：使用泛型参数"}