{"blogid": "121828838", "writerAge": "码龄7年", "writerBlogNum": "232", "writerCollect": "991", "writerComment": "80", "writerFan": "8256", "writerGrade": "6级", "writerIntegral": "4848", "writerName": "Charles Ren", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121828838.jpg", "writerRankTotal": "3318", "writerRankWeekly": "797", "writerThumb": "260", "writerVisitNum": "355905", "blog_read_count": "1098", "blog_time": "已于 2022-05-04 09:57:07 修改", "blog_title": "C语言常见面试题汇总", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><ul><li><a href=\"#gcc_1\">gcc的编译过程？</a></li><li><a href=\"#static_8\">static关键字</a></li><li><a href=\"#_14\">变量/函数的声明和定义之间有什么区别</a></li><li><a href=\"#_18\">各种指针</a></li><li><a href=\"#_30\">指针常量与常量指针</a></li><li><a href=\"#_36\">“引用”与指针的区别是什么？</a></li><li><a href=\"#C_43\">C语言参数传递方式：</a></li><li><a href=\"#_58\">结构体的浅拷⻉与深拷⻉</a></li><li><a href=\"#include_include__65\">#include&lt;&gt; 与#include \"\"的区别？</a></li><li><a href=\"#define_72\">宏定义define</a></li><li><ul><li><a href=\"#ifndefdefineendif__74\">ifndef/define/endif 的作用？</a></li><li><a href=\"#_76\">与内联区别</a></li><li><a href=\"#typedef_82\">与typedef区别</a></li><li><a href=\"#const_86\">与const区别</a></li></ul>\n</li><li><a href=\"#c_94\">c语⾔中有符号和⽆符号的区别？</a></li><li><a href=\"#_98\">谈谈计算机中补码的意义</a></li><li><a href=\"#_104\">描述⼀下指针与指针变量的区别</a></li><li><a href=\"#_114\">描述⼀下内存分区</a></li><li><a href=\"#_121\">解释堆和栈的区别</a></li><li><a href=\"#_137\">堆和栈的速度</a></li><li><a href=\"#vectorarray_143\">vector和array区别</a></li><li><a href=\"#_147\">结构体与共⽤体的区别</a></li><li><a href=\"#extern_151\">extern关键字</a></li><li><a href=\"#const_165\">关键字const</a></li><li><a href=\"#_175\">数组特点</a></li><li><a href=\"#__181\">谈谈数组名作为类型、作为地址、对数组名取地址的 区别？</a></li><li><a href=\"#_195\">字节对齐规则</a></li><li><a href=\"#violate_209\">violate关键字</a></li><li><a href=\"#attribute_221\">attribute</a></li><li><a href=\"#_232\">函数调用过程</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h3><a id=\"gcc_1\"></a>gcc的编译过程？</h3>\n<p>gcc编译过程分为4个阶段：预处理、编译、汇编、链接。<br/> 预处理：头⽂件包含、宏替换、条件编译、删除注释<br/> 编译：主要进⾏词法、语法、语义分析等，检查⽆误后将预处理好的⽂件编译成汇编⽂件。<br/> 汇编：将汇编⽂件转换成 ⼆进制⽬标⽂件<br/> 链接：将项⽬中的各个⼆进制⽂件+所需的库+启动代码链接成可执⾏⽂件</p>\n<h3><a id=\"static_8\"></a>static关键字</h3>\n<p>全局变量存储在静态存储区中，局部变量在堆栈中</p>\n<ul><li><strong>静态局部变量</strong>：和普通局部变量不同。静态局部变量也是定义在函数内部的，<strong>静态局部变量所在的函数在调用多次时，只有第一次才经历变量定义和初始化</strong>，以后多次在调用时不再定义和初始化，而是维持之前上一次调用时执行后这个变量的值。下次接着来使用。但是他的作用域仅限于当前函数内。</li><li><strong>静态全局变量</strong>也只初始化一次，但是作用域在当前文件/模块中。每次调用当前文件时，会使用上一次保存的值。</li><li><strong>静态函数</strong>：只在本模块或者文件中使用。被限定了范围。</li></ul>\n<h3><a id=\"_14\"></a>变量/函数的声明和定义之间有什么区别</h3>\n<p>变量/函数的声明仅声明变量/函数存在于程序中的某个位置也就是后面程序会知道这个函数或者变量的类型，但<strong>不分配内存</strong>。<br/> 关于定义，当我们定义变量/函数时，除了声明的作用外，它还为该变量/函数分配内存。</p>\n<h3><a id=\"_18\"></a>各种指针</h3>\n<ul><li> <p>NULL指针<br/> NULL用于指示<strong>指针未指向有效位置</strong>。理想情况下，如果在声明时不知道指针的值，则应将指针初始化为NULL。<br/> 当由它指向的内存在程序中间被释放时，我们应该使指针为NULL。</p> </li><li> <p>悬空指针<br/> 悬空指针是<strong>没有指向正确内存位置</strong>的指针。当删除或释放对象时，如果不修改指针的值或者不置为NULL，就会出现悬空指针。<br/> 这时这个指针指向的内存可能被分配给了其他变量就会造成错误。所以是比较危险的。</p> </li><li> <p>野指针<br/> 就是<strong>只声明没有被初始化过的指针</strong>，他可能指向任何内存。</p> </li></ul>\n<h3><a id=\"_30\"></a>指针常量与常量指针</h3>\n<p>int * const p //指针常量：指针在前，常量在后<br/> 这个<strong>p只能指向一个位置</strong>，而不能指向其他位置。指向的变量值可以改变。<br/> const int *p = &amp;a; //常量指针 ： 常量在前，指针在后<br/> <strong>指向的变量值不能改变</strong>，但是可以改变这个指针指向的位置。</p>\n<h3><a id=\"_36\"></a>“引用”与指针的区别是什么？</h3>\n<p>引用是C++的概念在C中叫取地址符号</p>\n<ol start=\"2\"><li>本质：引用是别名，指针是地址</li><li>指针是独立的可以指向空值，这时我们为指针分配了内存。而引用必须初始化指定的对象自始至终只能依附于同一个变量，他只是别名。标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器</li></ol>\n<h3><a id=\"C_43\"></a>C语言参数传递方式：</h3>\n<p>值传递(swap1函数)<br/> 地址/指针传递(swap2函数)<br/> 引用传递(swap3函数)<br/> void swap1(int,int); //值传递<br/> void swap2(int *p1,int *p2); //地址传递<br/> void swap3(int &amp;a,int &amp;b); //引用传递</p>\n<p>这也就证明了地址传递和引用传递都是直接传递的变量所在的地址，函数的主要的作用就是对存储在地址中的变量进行直接的操作<br/> 而按值传递则不会修改原值<br/> 实际上指针传递也是值传递，他传递的是指针变量的值。<br/> 而引用则相当于间接寻址，他直接传递的是地址</p>\n<p><strong>c语言没有引用传递,只有c++有</strong></p>\n<h3><a id=\"_58\"></a>结构体的浅拷⻉与深拷⻉</h3>\n<p>当结构体中有指针成员的时候容易出现浅拷⻉与深拷⻉的问题。</p>\n<p>浅拷贝存在的问题：当出现类的<strong>等号赋值</strong>时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数<strong>据成员中有指针时</strong>，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，此时teacher2已经是野指针，指向的内存空间已经被释放掉，再次free会报错；这时，必须采用深拷贝</p>\n<p>深拷⻉就是，让两个结构体变量的指针成员分别指向不同的堆区空间，只是空间内容拷⻉⼀份，这样在各个结构体变量释放的时候就不会出现多次释放同⼀段堆区空间的问题</p>\n<h3><a id=\"include_include__65\"></a>#include&lt;&gt; 与#include \"\"的区别？</h3>\n<p>include&lt;&gt;到系统指定⽬录寻找头⽂件，#include \"\"先到项⽬所在⽬录寻找头⽂件，如果没有找再到系统指定的⽬录下寻找</p>\n<h3><a id=\"define_72\"></a>宏定义define</h3>\n<p>宏定义又称为宏代换、宏替换，简称“宏”。</p>\n<h4><a id=\"ifndefdefineendif__74\"></a>ifndef/define/endif 的作用？</h4>\n<p>防止头文件被重复包含和编译。 头文件重复包含会增大程序大小，重复编译增加编译时间。</p>\n<h4><a id=\"_76\"></a>与内联区别</h4>\n<ol><li>内联函数在编译时展开，宏在预处理时展开；</li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换；</li><li>内联函数有类型检测、语法判断等功能，而宏没有；</li><li>inline函数是函数，宏不是；</li></ol>\n<h4><a id=\"typedef_82\"></a>与typedef区别</h4>\n<p>#define 用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p>\n<ul><li>typedef 仅限于为类型定义符号名称， 定义一种类型的别名，而不只是简单的宏替换 。#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li><li>typedef 编译阶段会检查错误，#define 预处理阶段不检查错误。</li></ul>\n<h4><a id=\"const_86\"></a>与const区别</h4>\n<p>1.数据类型：const修饰的变量有明确的类型，而宏没有明确的数据类型<br/> 2.安全方面：const修饰的变量会被编译器检查，而宏没有安全检查<br/> 3.内存分配：const修饰的变量只会在第一次赋值时分配内存，而宏是直接替换，每次替换后的变量都会分配内存<br/> 4.作用场所：const修饰的变量作用在编译、运行的过程中，而宏作用在预编译中。从编译器的角度讲，最大的优势是简单，方便。因为预处理就可以解决掉#define，不必让编译器来处理这个。<br/> 5.代码调试：const方便调试，而宏在预编译中进行所以没有办法进行调试。</p>\n<p>在程序语句中使用的常量的地方, 最好是使用const定义,在这方面来说, const只有优势,没有劣势.如果要说const劣势的地方,那就是它不能做上面3中的define的需要在预处理的时候做的事情.其实,这并非它的劣势,而只是不是它所要担负的工作罢了.</p>\n<h3><a id=\"c_94\"></a>c语⾔中有符号和⽆符号的区别？</h3>\n<p>有符号：数据的最⾼位为符号位，0表示正数，1表示负数<br/> ⽆符号：数据的最⾼位不是符号位，⽽是数据的⼀部分，只有正数，所以范围更大</p>\n<h3><a id=\"_98\"></a>谈谈计算机中补码的意义</h3>\n<p>计算机只有加法处理方式<br/> 将符号位与其他位统⼀处理将<strong>减法运算转换成加法运算</strong></p>\n<h3><a id=\"_104\"></a>描述⼀下指针与指针变量的区别</h3>\n<p>指针：内存中每⼀个字节都会分配编号，这个编号就是地址, ⽽指针就是内存单元的编号。<strong>一个变量的地址就称为该变量的指针</strong>他保存的是一个地址。<br/> 指针变量：：c语言有很多种变量，每种变量都会储存一种数据，<strong>而指针变量就是专门来储存指针的变量</strong>，本质是变量 只是该变量存放的是空间的地址编号<br/> 二级指针：指针本身也是一个变量，也要占用内存空间，而二级指针就是指向这块变量的指针。一般二级指针用在二维数组中。<br/> int *p;<br/> p=&amp;a;</p>\n<p>int *p就是指针变量<br/> 对a取地址，p就是一个指针用来保存地址。</p>\n<h3><a id=\"_114\"></a>描述⼀下内存分区</h3>\n<p>C语言开发对内存使用有区域划分，分别是栈区(stack)、堆区(heap)、BSS、数据段(data)、代码段(text)。</p>\n<p>BSS段 未初始化全局变量，未初始化全局静态变量<br/> 数据段 已初始化全局变量、已初始化全局静态变量、局部静态变量、常量数据<br/> 代码段 可执行代码、字符串常量<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\58bd99689cc54f20b91a6674652655a2.png\"/></p>\n<h3><a id=\"_121\"></a>解释堆和栈的区别</h3>\n<ol><li> <p>申请方式<br/> stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间<br/> heap:需要程序员自己申请，并指明大小，在c中malloc函数</p> </li><li> <p>申请大小的限制<br/> 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br/> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p> </li><li> <p>申请效率的比较：<br/> 栈:由系统自动分配，速度较快。但程序员是无法控制的。<br/> 堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p> </li><li> <p>堆和栈中的存储内容<br/> 栈：局部变量和形参<br/> 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p> </li></ol>\n<h3><a id=\"_137\"></a>堆和栈的速度</h3>\n<p><a href=\"https://blog.csdn.net/blunt1991/article/details/14005995?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4\">https://blog.csdn.net/blunt1991/article/details/14005995?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4</a></p>\n<ol><li>分配和释放，堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。栈效率更高，因为堆分配分配了之后还要与存储器之间建立映射，而栈分配则是之前就建立好了。</li><li>访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</li><li>栈有专门的寄存器，压栈和出栈的指令效率很高，而堆需要由OS动态调度，堆内存可能被OS调度在非物理内存中，或是申请内存不连续，造成碎片过多等问题。</li></ol>\n<h3><a id=\"vectorarray_143\"></a>vector和array区别</h3>\n<ol><li>array的元素存在于栈上， 而vector只有元信息存在于栈上，数据存在于堆上。所以vector不会爆栈</li><li>vector是顺序容器，其利用连续的内存空间来存储元素，但是其内存空间大小是能够改变的。</li><li>vector效率偏低，因为当向vector中添加新元素的时候，内存空间不够，需要重新申请更大的空间，由于vector是连续内存空间的，因此其申请更多空间的时候，可能整个位置发生改变，需要将原来空间里的数据拷贝过去。</li></ol>\n<h3><a id=\"_147\"></a>结构体与共⽤体的区别</h3>\n<p>结构体中的成员拥有独⽴的空间，共⽤体的成员共享同⼀块空间，但是每个共⽤体成员能访问共⽤区的空间⼤⼩是由成员⾃身的类型决定。<br/> 共用体使用覆盖技术，成员变量相互覆盖。</p>\n<h3><a id=\"extern_151\"></a>extern关键字</h3>\n<ol><li>extern修饰变量的声明。<br/> 举例来说，如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。能够被其他模块以extern修饰符引用到的变量通常是全局变量。还有很重要的一点是，extern int v可以放在a.c中的任何地方，比如你可以在a.c中的函数fun定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在函数fun作用域中引用v罢了，这还是变量作用域的问题。</li></ol>\n<ul><li>c语言函数调用过程<br/> 一个C语言程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条。这个链条的起点是 main()，终点也是 main()。<br/> 总结起来整个过程就三步：<br/> 1）根据调用的函数名找到函数入口；<br/> 2）在栈中申请调用函数中的参数及函数体内定义的变量的内存空间<br/> 3）函数执行完后，释放栈中的申请的参数和变量的空间，最后返回值（如果有的话）</li></ul>\n<h3><a id=\"const_165\"></a>关键字const</h3>\n<p>意味着只读。防止被修饰的成员的内容被改变。明确的告诉使用者不要修改这个变量。</p>\n<ol><li> <p>在函数声明时修饰参数，表示在函数访问时参数（包括指针和实参）的值不会发生变化。</p> </li><li> <p>对于指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，const修饰的都是后面的值<br/> const int *b = &amp;a; <em>b不能修改<br/> 或者int</em> const b = &amp;a;，b不能修改</p> </li></ol>\n<h3><a id=\"_175\"></a>数组特点</h3>\n<p>同⼀个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的<br/> 不初始化：如果是<strong>局部数组</strong> 数组元素的<strong>内容随机</strong> ，如果是<strong>全局数组，数组的元素内容自动赋为0</strong><br/> 完全初始化：如果⼀个数组全部初始化 可以省略元素的个数 数组的⼤⼩由初始化的个数确定</p>\n<h3><a id=\"__181\"></a>谈谈数组名作为类型、作为地址、对数组名取地址的 区别？</h3>\n<p>数组名作为类型：代表的是整个数组的⼤⼩<br/> 数组名作为地址：代表的是数组⾸元素的地址<br/> 对数组名取地址：代表的是数组的⾸地址</p>\n<ul><li>数组首地址与数组首元素地址<br/> char arr[]={‘1’,‘2’,‘3’,‘4’,‘5’,‘6’};<br/> char * b = arr; //只能写成这样而不能写成 = &amp;arr</li></ul>\n<p>arr //获得数组首元素地址等同于&amp;arr[0]<br/> <em>arr、arr[0]、</em>(arr+0) //获得数组首元素值<br/> &amp;arr //获得数组地址<br/> arr+1 //获得数组第二个元素地址<br/> arr[1]、*(arr+1) //获得数组第二个元素值</p>\n<h3><a id=\"_195\"></a>字节对齐规则</h3>\n<p>公式1:前面的地址必须是后面的地址正数倍,不是就补齐<br/> 公式2:整个Struct的地址必须是最大字节的整数倍<br/> int 4<br/> double 8<br/> char 1<br/> 占用字节为24</p>\n<p>int 4<br/> char 1<br/> double 8<br/> 这样占用就是16节省了内存空间</p>\n<h3><a id=\"violate_209\"></a>violate关键字</h3>\n<p><a href=\"https://blog.csdn.net/ijn842/article/details/81273232\">https://blog.csdn.net/ijn842/article/details/81273232</a><br/> volatile是一个类型修饰符（type specifier）, 防止编译器对代码进行优化。</p>\n<p>在编译期间，编译器可能对代码进行优化<br/> 当编译器看到此处的n被const修饰，从语义上来讲，n是不期望被修改的<br/> 所以优化的时候<strong>把n的值存放到寄存器中</strong>，以提高访问的效率<br/> 只要以<strong>后使用n的地方都去寄存器中</strong>取，即使n在内存中的值发生变化，<strong>寄存器也不受影</strong>响，所以输出的n的值为10。也就是多线程其他线程可能读到的值是修改之前的。</p>\n<p>使用volatile修饰之后，就不会将此值拷贝到寄存器中，那么其他线程可以读到修改后的值，也就是可见性。<br/> volatile的作用就是被设计用来修饰被不同线程访问和修改的变量</p>\n<h3><a id=\"attribute_221\"></a>attribute</h3>\n<p><a href=\"https://www.jianshu.com/p/29eb7b5c8b2d\">https://www.jianshu.com/p/29eb7b5c8b2d</a><br/> attribute：属性，主要是用来在函数或数据声明中设置其属性，与编译器相关<br/> 可以设置多种属性：比如</p>\n<ol><li>attribute((unused))如果定义了一个静态函数，而没有去使用，编译时会有一个告警：而使用attribute((unused))可以告诉编译器忽略此告警</li><li>attribute((always_inline))的意思是强制内联，所有加了attribute((always_inline))的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如我定义了函数<br/> attribute((always_inline)) void a()和<br/> void b()<br/> ｛<br/> a();｝</li></ol>\n<h3><a id=\"_232\"></a>函数调用过程</h3>\n<pre><code class=\"prism language-c\"> <span class=\"token number\">1</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n <span class=\"token number\">2</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token number\">3</span>     <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n <span class=\"token number\">4</span>     sum <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n <span class=\"token number\">5</span>     <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n <span class=\"token number\">6</span> <span class=\"token punctuation\">}</span>\n <span class=\"token number\">7</span> \n <span class=\"token number\">8</span> <span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token number\">9</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token number\">10</span>     <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">11</span>     <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">12</span>     <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">13</span>     ret <span class=\"token operator\">=</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">14</span>     <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">15</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>1、参数拷贝（参数实例化）分配内存。<br/> 2、保存当前指令的下一条指令，并跳转到被调函数。<br/> 这些操作均在main函数中进行。</p>\n<p>接下来是调用Add函数并执行的一些操作，包括：<br/> 1、移动ebp、esp形成新的栈帧结构。<br/> 2、压栈（push）形成临时变量并执行相关操作。<br/> 在一个栈中，依据函数调用关系，发起调用的函数（caller）的栈帧在下面（高地址方向），被调用的函数的栈帧在上面。<br/> 每发生一次函数调用，便产生一个新的栈帧，当一个函数返回时，这个函数所对应的栈帧被清除（eliminated）<br/> 3、return一个值。<br/> 这些操作在Add函数中进行。</p>\n<p>被调函数完成相关操作后需返回到原函数中执行刚才保存的下一条指令，操作如下：<br/> 1、出栈（pop）。<br/> 2、恢复main函数的栈帧结构。（pop ）<br/> 3、返回main函数<br/> 这些操作也在Add函数中进行。 至此，在main函数中调用Add函数的整个过程已经完成。<br/> 总结起来整个过程就三步：<br/> 1）根据调用的函数名找到函数入口；<br/> 2）在栈中审请调用函数中的参数及函数体内定义的变量的内存空间<br/> 3）函数执行完后，释放函数在栈中的申请的参数和变量的空间，最后返回值（如果有的话）</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-04 09:57:07", "summary": "文章目录的编译过程？关键字变量函数的声明和定义之间有什么区别各种指针指针常量与常量指针引用与指针的区别是什么？语言参数传递方式：结构体的浅拷与深拷与的区别？宏定义的作用？与内联区别与区别与区别语中有符"}