{"blogid": "126268729", "writerAge": "码龄2年", "writerBlogNum": "57", "writerCollect": "1162", "writerComment": "2161", "writerFan": "3567", "writerGrade": "6级", "writerIntegral": "8380", "writerName": "哎呀是小张啊", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126268729.jpg", "writerRankTotal": "1745", "writerRankWeekly": "177", "writerThumb": "2507", "writerVisitNum": "89523", "blog_read_count": "272", "blog_time": "于 2022-08-14 01:00:00 发布", "blog_title": "【JavaEE初阶】多线程 _ 基础篇 _ 线程安全问题（上篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>☕导航小助手☕</strong></p>\n<p id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-toc\" style=\"margin-left:0px;\"><strong>  🍚</strong><a href=\"#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:0px;\"><strong>        🍛</strong><a href=\"#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0\">一、线程安全概述</a></p>\n<p id=\"1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:0px;\"><strong>                   🧇🧇</strong><a href=\"#1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\">1.1 什么是线程安全问题</a></p>\n<p id=\"1.2%20%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E4%BE%8B-toc\" style=\"margin-left:0px;\"><strong>                   🦪🦪</strong><a href=\"#1.2%20%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E4%BE%8B\">1.2 存在线程安全问题的实例</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-toc\" style=\"margin-left:0px;\"><strong>        🍜</strong><a href=\"#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">二、线程安全问题及其解决办法</a></p>\n<p id=\"2.1%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-toc\" style=\"margin-left:0px;\"><strong>                   🍣🍣</strong><a href=\"#2.1%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90\">2.1 案例分析</a></p>\n<p id=\"2.2%20%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0-toc\" style=\"margin-left:0px;\"><strong>                   🍤🍤</strong><a href=\"#2.2%20%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0\">2.2 造成线程不安全的原因</a></p>\n<p id=\"2.3%20%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:0px;\"><strong>                   🥩🥩</strong><a href=\"#2.3%20%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\">2.3 线程加锁操作解决 原子性问题</a></p>\n<p id=\"2.3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E9%94%81-toc\" style=\"margin-left:0px;\"><strong>                                   🧀🧀🧀</strong><a href=\"#2.3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E9%94%81\">2.3.1 什么是加锁</a></p>\n<p id=\"2.3.2%20%E4%BD%BF%E7%94%A8%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97%20%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81-toc\" style=\"margin-left:0px;\"><strong>                                   🍞🍞🍞</strong><a href=\"#2.3.2%20%E4%BD%BF%E7%94%A8%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97%20%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81\">2.3.2 使用 synchronized关键字 进行加锁</a></p>\n<p id=\"2.3.3%C2%A0synchronized%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-toc\" style=\"margin-left:0px;\"><strong>                                   🍰🍰🍰</strong><a href=\"#2.3.3%C2%A0synchronized%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B\">2.3.3 synchronized 使用示例</a></p>\n<p id=\"%E4%B8%89%E3%80%81Java%E6%A0%87%E5%87%86%E5%BA%93%E9%87%8C%E9%9D%A2%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB-toc\" style=\"margin-left:0px;\"><strong>        🍱</strong><a href=\"#%E4%B8%89%E3%80%81Java%E6%A0%87%E5%87%86%E5%BA%93%E9%87%8C%E9%9D%A2%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB\">三、Java标准库里面的线程安全类</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</h1>\n<p><strong>线程的安全性问题</strong>，是多线程编程中 最最重要的部分，也是线程中最最复杂的部分~</p>\n<p>据说，它是一种挑战人脑智商的极限的问题~</p>\n<p>同时，对于这个问题，将分为两篇博客 一一的介绍开来~</p>\n<p>下面，让我们一起来看看吧 ......</p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0\">一、线程安全概述</h1>\n<h1 id=\"1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\">1.1 什么是线程安全问题</h1>\n<p>线程安全问题 出现的 \"罪魁祸首\"，正是 调度器的 <strong>随机调度 / 抢占式执行</strong> 这个过程~</p>\n<p>在随机调度之下，多线程程序执行的时候，有无数种可能性，有无数种可能的排列方式~</p>\n<p>在这些排列顺序中，有的排列方式 逻辑是正确的，但是有的排列方式 可能会引出 bug~</p>\n<p>对于多线程并发时，会使程序出现 bug 的代码 称作线程不安全的代码，这就是线程安全问题~</p>\n<p>接下来，举出一个典型的例子，来观察一番 到底什么是线程安全问题~</p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<h1 id=\"1.2%20%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E4%BE%8B\">1.2 存在线程安全问题的实例</h1>\n<blockquote>\n<p>创建两个线程，让这两个线程 同时并发 对一个变量，自增 5w 次，最终预期能够一共自增 10w 次~</p>\n</blockquote>\n<pre><code>package thread;\n\nclass Counter {\n    //用来保存计数的变量\n    public int count;\n\n    public void increase() {\n        count++;\n    }\n}\n\npublic class Demo14 {\n    public static void main(String[] args) {\n        //这个实例用来进行累加\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 5_0000; i++) {\n                counter.increase();\n            }\n        });\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 5_0000; i++) {\n                counter.increase();\n            }\n        });\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"count：\" + counter.count);\n    }\n}</code></pre>\n<p> 运行结果：</p>\n<p><img alt=\"\" height=\"334\" src=\"..\\..\\static\\image\\74cf082c956f4c5fa5a85461b281632f.png\" width=\"796\"/></p>\n<p>很明显，我们可以发现 程序运行的结果 都是 小于 10w 次的，即便是运行多次，结果也都是小于 10w 次~</p>\n<p><strong>事实上，正确的结果是，得到的数字 count 在 5w 到 10w 之间~</strong></p>\n<p>这是怎么回事呢？ </p>\n<p>我们接下来慢慢分析~</p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">二、线程安全问题及其解决办法</h1>\n<h1 id=\"2.1%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90\">2.1 案例分析</h1>\n<p>按理来说，上述实例 运行的结果 count 应该等于 10w~</p>\n<p>可是 连续运行多次，就会发现 每一次运行的结果都不一样，但都是小于 10w，这是为什么呢？</p>\n<p>这个就是 线程不安全的问题~</p>\n<p>其原因主要是：随机调度的顺序不一样，就导致程序运行的结果不一样~</p>\n<p>上述的 bug 是怎么形成的呢？</p>\n<p>这个得需要站在硬件的角度来理解：</p>\n<blockquote>\n<p>像 count++ 这一行代码，其实对应的是 三个机器指令：</p>\n<ol><li>首先 需要从内存中读取数据到 CPU，这个指令称为 load指令</li><li>其次 在 CPU 寄存器中，完成加法运算，这个指令称为 add指令</li><li>最后 把寄存器的指令 写回到内存中，这个指令称为 save指令</li></ol>\n</blockquote>\n<blockquote>\n<p>这个在 JavaEE初阶 的第一篇文章中提到过，不清楚的可以跳转过去看一看~</p>\n<p><a href=\"https://blog.csdn.net/qq_53362595/article/details/126017594\" title=\"🚪传送门：【JavaEE初阶】计算机是如何工作的🚪\">🚪传送门：【JavaEE初阶】计算机是如何工作的🚪</a></p>\n</blockquote>\n<p>这三个步骤，如果是在单线程下执行，那是没有任何问题的~</p>\n<p>但是如果是在多线程下执行，那就不一定了~ </p>\n<hr/>\n<p><strong>现在，我们可以以一条时间轴，来画一下其中常见的情况：</strong></p>\n<p><strong>load 是把内存中的数据读到 寄存器里，add是在寄存器里面进行加法操作，save是把寄存器里面的值放回到内存~</strong></p>\n<p><span style=\"color:#956fe7;\"><strong>情况一：</strong></span></p>\n<p><strong>对两个数进行自增操作，内存 初始值为 0，两个线程进行并发执行，进行两次自增~</strong></p>\n<p><strong>寄存器A 表示 线程1 所用的寄存器，寄存器B 表示 线程2 所用的寄存器~</strong></p>\n<p><img alt=\"\" height=\"368\" src=\"..\\..\\static\\image\\9736692e60254dd9b61208914f5b1daa.png\" width=\"1200\"/></p>\n<p><strong>通过上述的执行过程，我们可以看到，两个线程 各自增一次，预期 自增两次，实际上的结果是 2，没有任何问题~</strong></p>\n<p><strong>看起来是没有任何问题的，可是实际情况下 这个可是多线程，只是出现无数种情况的其中一种而已，只是这种排列方式恰好没有问题（其他的排列方式就不一定了）~ </strong></p>\n<hr/>\n<p><span style=\"color:#956fe7;\"><strong>情况二：</strong></span></p>\n<p><strong>对两个数进行自增操作，内存 初始值为 0，两个线程进行并发执行，进行两次自增~</strong></p>\n<p><strong>寄存器A 表示 线程1 所用的寄存器，寄存器B 表示 线程2 所用的寄存器~</strong></p>\n<p><img alt=\"\" height=\"344\" src=\"..\\..\\static\\image\\de3ee5e1a80a42fc98e27e8020a8b881.png\" width=\"1200\"/></p>\n<p></p>\n<p><strong>如上所示，明明在内存里面自增了两次，但是最终内存的值 仍然是 1~</strong></p>\n<p><strong>这就是典型的线程不安全导致的 bug~</strong></p>\n<hr/>\n<p><span style=\"color:#956fe7;\"><strong>情况三：</strong></span></p>\n<p><strong>对两个数进行自增操作，内存 初始值为 0，两个线程进行并发执行，进行两次自增~</strong></p>\n<p><strong>寄存器A 表示 线程1 所用的寄存器，寄存器B 表示 线程2 所用的寄存器~</strong></p>\n<p><img alt=\"\" height=\"352\" src=\"..\\..\\static\\image\\b417ec3a22484e6fb5c2761f6ffef25e.png\" width=\"1200\"/></p>\n<p><strong>如上所示，最终的内存中保存的是 1~</strong></p>\n<p><strong>这是典型的线程不安全的问题~ </strong></p>\n<hr/>\n<p><span style=\"color:#956fe7;\"><strong>其他的情况：</strong></span></p>\n<p><img alt=\"\" height=\"366\" src=\"..\\..\\static\\image\\27d6018e49c3492da07965857b494e4d.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"356\" src=\"..\\..\\static\\image\\8dfecc9ed7154e34a0f803c9d77ee3a0.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"364\" src=\"..\\..\\static\\image\\f960902e6eda45aeb3d5ef9a39bffe27.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"365\" src=\"..\\..\\static\\image\\871432485a374e128741cabfd8891bd1.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"73\" src=\"..\\..\\static\\image\\98bedd1c01864125ab915a1ac52bc0f5.png\" width=\"1200\"/></p>\n<p><strong>由于是多线程，所以有无数种情况 ~</strong></p>\n<p><strong>总之，在无数中的排列顺序情况下，只有<span style=\"color:#956fe7;\"> \"先执行完第一个线程，再执行完第二个线程\" 以及 \"先执行完第二个线程\"</span>，再执行完第一个线程 的这两种情况，是没有问题的~</strong></p>\n<p><strong>剩下的情况，全部都是和正确结果不匹配~</strong></p>\n<hr/>\n<p> 回到最初的代码程序，我们就可以知道：</p>\n<p>在极端情况下，如果所有的执行排列都是 <span style=\"color:#956fe7;\">\"先执行完第一个线程，再执行完第二个线程\" 以及 \"先执行完第二个线程\"</span><span style=\"color:#0d0016;\">，那么此时的总和就是 10w~</span></p>\n<p><span style=\"color:#0d0016;\">在极端情况下，如果所有的执行排列顺序 </span><span style=\"color:#956fe7;\">是不包括这两种情况的其他情况</span><span style=\"color:#0d0016;\">，那么此时总和就是 5w~</span></p>\n<p>更实际的情况下，调度器具体调度出多少种这两种极端的情况，我们是无法确定的~</p>\n<p>因此 最终的结果是 5w ~ 10w ！！！！！！</p>\n<hr/>\n<blockquote>\n<p>操作系统的随机调度，其实不是 \"真随机\"，而是 操作系统内核的调度器调度线程，其内部是有一套 逻辑 / 算法，来支持这一调度过程 ~</p>\n<p>即 每种出现的排列情况下不是均等的，所以不可以通过排列组合的情况下算出每种情况 出现的概率的 ~</p>\n</blockquote>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"2.2%20%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0\">2.2 造成线程不安全的原因</h1>\n<p><span style=\"color:#956fe7;\"><strong>（一）操作系统的 随机调度 / 抢占式执行~</strong></span></p>\n<p><strong>这个是 万恶之源、罪魁祸首！！！！！！</strong></p>\n<p>这个是 操作系统内核 实现的时候，就是这样设计的，因此 我们改不了（就算可以改得了自己的电脑，也改不了其他的人的那么多电脑），对此 我们是无能为力的~</p>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（二）多个线程 修改 同一个变量~</strong></span></p>\n<p>如果只是一个线程修改变量，没有线程安全问题！！！</p>\n<p>如果是多个线程读同一个变量，也没有线程安全问题！！！</p>\n<p>如果是多个线程修改不同的变量，还是没有线程安全问题！！！</p>\n<p>但是，多个线程修改同一个变量，那就有了线程安全问题了~</p>\n<p>所以，在写代码的时候，我们可以针对这个要点进行控制（可以通过调整程序的设计，来去<strong>规避 多个线程修改同一个变量</strong>）~</p>\n<p>但是，此时的 \"规避方法\" 是有适用范围的，不是所有的场景都可以规避掉（这个得要看具体的场景）~</p>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（三）有些修改操作，不是 原子的修改，更容易触发 线程安全问题~</strong></span></p>\n<p>在 MySQL数据库中说过，不可拆分的最小单位 就叫做原子~</p>\n<p>如：赋值操作来修改（=，只对应一条机器指令），就是视为原子的~</p>\n<p>像之前通过 ++操作 来修改（对应三条机器指令），就不是原子的~</p>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（四）内存可见性 引起的线程安全问题~</strong></span></p>\n<blockquote>\n<p>内存可见性，这个就是另外一个场景了：一个线程写，一个线程读的场景~</p>\n<p>这个场景 就特别容易因为 内存可见性 而引发问题~</p>\n</blockquote>\n<blockquote>\n<p>线程1：进行反复的 读 和 判断 ~</p>\n<p>线程2：在某个环节下进行修改~</p>\n<p>如果是正常的情况下，线程1 在读和判断，线程2 突然写了一下 =&gt; 这是正常的，在线程2 写完之后，线程1 就能立即读到内存的变化，从而让判断出线变化~</p>\n<p><img alt=\"\" height=\"129\" src=\"..\\..\\static\\image\\7b3d5f9e9d8f46d5a1ed0ae526a97d4f.png\" width=\"975\"/>但是，在程序运行过程中，可能会涉及到一个操作 —— \"优化\" （可能是编译器 javac，也可能是 JVM java，也可能是操作系统 的行为）~</p>\n<p>那么 由于 线程1 频繁的进行 <strong>load   test 操作</strong>，就很有可能会被优化成 <strong>load   test   test......操作</strong>（会认为 一直读的都是一样的值，所以不需要再读了）~<img alt=\"\" height=\"127\" src=\"..\\..\\static\\image\\529bed19cd8541c4bcd16dbdd3bcb5d3.png\" width=\"970\"/></p>\n<p>每次 load操作 都是读内存操作，每次 test操作 都是在读寄存器，读内存操作 要比 读寄存器操作 慢上几千倍、上万倍~</p>\n<p>正是由于 load操作 读的太慢，再加上 反复读，每一次读到的数据又一样，所以 JVM 就做出了这样的优化，就不再重复的从内存中读了，直接就复用第一次从内存读到寄存器的数据就好了~ </p>\n<p>那么，如果在优化之后，线程2 突然又写了一个数据~</p>\n<p>由于 线程1 已经优化成读寄存器了，因此 线程2 的修改，线程1 感知不到 =&gt;这就叫做 内存可见性问题（内存改了，但是在 优化 的背景下，读不到、看不见了）~</p>\n</blockquote>\n<blockquote>\n<p>所谓优化，是指在执行正确的前提下，来做出变化 使得性能更优~</p>\n<p>一定要保证程序的逻辑是正确的，再说效率问题！！！</p>\n<p>上述场景的优化，在单线程场景下，没有问题；但是在多线程情况下，就可能会出现问题：多线程环境太复杂，编译器 / JVM / 操作系统 进行优化的时候就可能产生误判~</p>\n<p><strong>针对这个问题，Java 引入了 volatile关键字，让程序猿手动的禁止 编译器 / JVM / 操作系统 对某个变量进行上述优化！！！ </strong></p>\n</blockquote>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（五）指令重排序，也可能引起线程不安全</strong></span></p>\n<p>指令重排序，也是 操作系统 / 编译器 / JVM <strong>优化操作</strong>！！！</p>\n<p>它调整了代码的执行顺序，达到加快速度的效果~</p>\n<blockquote>\n<p>比如说，张三媳妇 要张三去到超市买一些蔬菜，并且给了他一张清单：</p>\n<ol><li>西红柿</li><li>鸡蛋</li><li>茄子</li><li>小芹菜</li></ol>\n<p><img alt=\"\" height=\"691\" src=\"..\\..\\static\\image\\328fc73004b84013b10c0410442ed9e9.png\" width=\"1200\"/>调整顺序后，也是符合张三媳妇 对张三的要求：买到了四样菜，并且效率也是得到了提高~</p>\n<p>至于买的过程是什么样子的，张三媳妇并不关心~</p>\n<p>这个就叫做 指令重排序！！！</p>\n</blockquote>\n<blockquote>\n<p>指令重排序，也会引发线程不安全~</p>\n<p>如：</p>\n<p><img alt=\"\" height=\"346\" src=\"..\\..\\static\\image\\b8e468c8086f424d984bfaf308f9a351.png\" width=\"1061\"/></p>\n<p>此处，就容易出现指令重排序引入的问题：</p>\n<p>2 和 3 的顺序是可以调换的~</p>\n<p>在单线程下，调换这两的顺序，是没有影响的；但是如果在多线程条件下，那么是会出现 多线程不安全：</p>\n<p>假设 另一个线程，尝试读取 t 的引用，如果是按照 2、3的顺序，第二个线程读到 t 为 非null 的时候，此时 t 就一定是一个有效对象；如果是按照 3、2的顺序，第二个线程读到 t 为 非null 的时候，仍然可能是一个无效对象！！！</p>\n</blockquote>\n<hr/>\n<p><strong>总结：</strong></p>\n<p>线程安全问题出现的五种原因：</p>\n<p>前三种原因 是更普遍的~</p>\n<ol><li>系统的随机调度（万恶之源、无能为力）</li><li>多个线程同时修改同一个变量（部分规避）</li><li>修改操作不是原子的（有办法改善的）</li></ol>\n<p>后两种原因，是 编译器 / JVM / 操作系统 搞出的幺蛾子（但是 总体上来说还是利大于弊的）</p>\n<ol><li>内存可见性</li><li>指令重排序</li></ol>\n<p>编译器 / JVM / 操作系统 误判了，导致把不应该优化的地方给优化了，逻辑就变了，bug 就出现了（当然，后两种原因 也可以用 volatile关键字 来进行解决）~</p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<h1 id=\"2.3%20%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\">2.3 线程加锁操作解决 原子性问题</h1>\n<p>现在先重点来介绍一下 <span style=\"color:#956fe7;\"><strong>解决线程安全问题出现的第三种原因的方法（原子性），</strong></span>通过 加锁操作，来把一些不是原子的操作打包成一个原子的操作！！！</p>\n<p>加锁在 Java 中有很多方式来实现，其中最常用的就是 synchronized（用法其实也挺简单的，我们需要注意的是它的拼写和发音）~ </p>\n<hr/>\n<h1 id=\"2.3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E9%94%81\">2.3.1 什么是加锁</h1>\n<p>举个简单明了的例子，假设 你要去银行ATM机 取钱（我们都知道，ATM机 是放在一个单独的小房子里面的，每个小房子都有一把锁），如果你进去了，那么这个锁就会自动的锁起来，别人就进不去了，除非是 你已经取钱成功了 并且 自己已经出来了，下一个人才可以继续使用到 ATM机~</p>\n<p>取钱成功了，说明 取钱的几个步骤是成功了的，那么我们希望，去 ATM机 取钱的这些步骤，是能够一气呵成的（如果 不一气呵成，万一走的时候忘记啥步骤，取钱没有成功，大大咧咧的走了；后面的人一顿操作猛如虎，把你的钱取走了咋搞）~</p>\n<p>为了使这些步骤一气呵成，引入的办法就是<strong> 加锁</strong>~</p>\n<blockquote>\n<p><strong>加锁：</strong></p>\n<p>即 在你进去的时候，门就被锁了，其他的人就进不去了~</p>\n<p>然后你就可以完成 刷卡、输入密码 等等的操作，等这些操作都完成了之后，再把锁给打开，然后你就可以出去了~</p>\n<p>下一个人也就可以进来重复和你一样的操作了~</p>\n<p>实际上，银行里面的 ATM机 就是这样设计的~</p>\n<p>此时的 \"你\" 指的就是 \"线程\"，\"ATM机\" 指的就是 \"对象\"，\"门上的锁\" 指的就是 \"锁\"，\"其他人\" 指的就是 \"其他的线程\"~</p>\n</blockquote>\n<p>在 Java中，加锁的方式有很多种，其中最常见的加锁方式就是用 <span style=\"color:#be191c;\"><strong><span style=\"background-color:#fef2f0;\">synchronized</span></strong></span>关键字 进行加锁~</p>\n<p></p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<h1 id=\"2.3.2%20%E4%BD%BF%E7%94%A8%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97%20%E8%BF%9B%E8%A1%8C%E5%8A%A0%E9%94%81\">2.3.2 使用 synchronized关键字 进行加锁</h1>\n<p>synchronized 从字面意思上翻译叫做 \"同步\"，其实 实际上它所起的是 互斥的效果~</p>\n<p>在一开始的时候，列举了一个典型的线程不安全的例子：<strong>创建两个线程，让这两个线程 同时并发 对一个变量，自增 5w 次，最终预期能够一共自增 10w 次~</strong></p>\n<pre><code>package thread;\n\nclass Counter {\n    //用来保存计数的变量\n    public int count;\n\n     public void increase() {\n        count++;\n    }\n}\n\npublic class Demo14 {\n    public static void main(String[] args) {\n        //这个实例用来进行累加\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 5_0000; i++) {\n                counter.increase();\n            }\n        });\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 5_0000; i++) {\n                counter.increase();\n            }\n        });\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"count：\" + counter.count);\n    }\n}\n</code></pre>\n<p>那么，怎么使用 synchronized关键字 来解决这个线程不安全的问题呢？</p>\n<p>—— 很简单，我们在上面的 increase() 方法 前面加上 synchronized关键字即可（写在 void 之前都可以）：</p>\n<p><img alt=\"\" height=\"147\" src=\"..\\..\\static\\image\\79b06235ef8c4d0b939105006c94fc91.png\" width=\"463\"/></p>\n<p><img alt=\"\" height=\"148\" src=\"..\\..\\static\\image\\f6f63f73bdc14a1facac644f6e7e8447.png\" width=\"486\"/></p>\n<p>此时，我们再执行程序，发现无论再运行多少次，发现运行结果是正确的了：</p>\n<p><img alt=\"\" height=\"237\" src=\"..\\..\\static\\image\\9cd0b826f95c41dabc75998f79ecc2ad.png\" width=\"719\"/></p>\n<p></p>\n<hr/>\n<p><strong>那么，为什么加锁之后，就可以来实现 线程安全的保障呢？</strong></p>\n<blockquote>\n<p><strong>LOCK 这个指令是互斥的，当 线程t1 进行 LOCK 之后，t2 也尝试 LOCK，那么 t2 的 LOCK 就不会直接成功！！！</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"634\" src=\"..\\..\\static\\image\\05fcf017129e4f23834058a27a566b03.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\9b67205a62ad4f109c7a06f95e9bef86.png\" width=\"1049\"/><strong>所以说，在加锁的情况下，线程的三个指令就被岔开了，就可以保证 一个线程 save 之后，另一个线程才 load，于是此时的计算结果就准了~</strong></p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<h1 id=\"2.3.3%C2%A0synchronized%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B\">2.3.3 synchronized 使用示例</h1>\n<p><span style=\"color:#956fe7;\"><strong>（一）synchronized 直接修饰普通方法</strong></span></p>\n<pre><code>public class Demo14 {\n    public synchronized void methond() {\n\n   }\n}</code></pre>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（二）synchronized 修饰静态方法</strong></span></p>\n<pre><code>public class Demo14 {\n    public synchronized static void method() {\n\n   }\n}</code></pre>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>（三）修饰代码块</strong></span></p>\n<pre><code>public class Demo14 {\n    public void method() {\n        synchronized (this) {\n            \n       }\n   }\n}</code></pre>\n<blockquote>\n<p><strong>() 里面的 this 指的是：是针对哪个对象进行加锁！！！</strong></p>\n<p><strong>加锁操作，是针对一个对象来进行的！！！</strong></p>\n<p><strong>我们要重点理解，synchronized 锁的是什么：两个线程竞争的是同一把锁，才会产生阻塞操作（即 两个线程尝试使用两把不同的锁，不会产生阻塞操作）~</strong></p>\n<p><strong>如：</strong></p>\n<p><img alt=\"\" height=\"629\" src=\"..\\..\\static\\image\\892ab324e6d94526b895a46ac13f8b89.png\" width=\"1200\"/></p>\n<p>换句话说，1号滑稽 进入1号坑位，只是针对 1号坑位 进行了加锁，别人想要进入 1号坑位，就需要阻塞等待；但是 如果想要进入其他的 空闲坑位，那么则不需要等待~</p>\n<p><strong>这里的 滑稽老铁 指的就是 线程，坑位（的门上的锁，其实就是 synchronized() 括号里面的东西）  指的就是 要加锁的对象~</strong></p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>注意：</strong></span></p>\n<ol><li><strong>在Java里，任何一个对象，都可以用来做 锁对象，即 都可以放在  synchronized() 的括号中</strong>；其它的主流语言 都是专门搞了一类特殊的对象，用来作为 锁对象（大部分的正常对象 不能用来加锁）！</li><li>每个对象，内存空间中都会有一个特殊的区域 —— 对象头（JVM自带的，对象的一些特殊的信息）<img alt=\"\" height=\"434\" src=\"..\\..\\static\\image\\805f977efe78404983627c2eaccefac5.png\" width=\"979\"/></li><li>synchronized 写到普通方法上 相当于是对 this(可创建出多个实例) 进行加锁，synchronized 写到静态方法上 相当于是对 类对象(整个 JVM 里只有一个) 进行加锁，synchronized (类名.class)~</li></ol>\n<p></p>\n</blockquote>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81Java%E6%A0%87%E5%87%86%E5%BA%93%E9%87%8C%E9%9D%A2%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB\">三、Java标准库里面的线程安全类</h1>\n<p>在Java标准库里面，很多线程都是不安全的，如：例如，ArrayList，LinkedList，HashMap，TreeMap，HashSet，TreeSet，StringBuilder~</p>\n<p>当然，还是有一些是线程安全的，如：Vector (不推荐使用)，HashTable (不推荐使用)，ConcurrentHashMap (推荐)，StringBuffer，String~</p>\n<p>需要注意的是，加锁也是有代价的，它会牺牲很大的运行速度（毕竟，加锁涉及到了一些线程的阻塞等待，以及 线程的调度），所以可以视为，一旦使用了锁，我们的代码基本上就和 \"高性能\" 说再见了~</p>\n<p><img alt=\"\" height=\"58\" src=\"..\\..\\static\\image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p>这一篇博客暂时就介绍到这里了，关于 线程安全性 的剩下的内容，将会在下一篇博客中细细介绍~</p>\n<p>如果感觉这一篇博客对你有帮助的话，可以一键三连走一波，非常非常感谢啦 ~</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\84e32edfc59b4f32a313a842cea018b4.png\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-14 01:00:00", "summary": "导航小助手写在前面一、线程安全概述什么是线程安全问题存在线程安全问题的实例二、线程安全问题及其解决办法案例分析造成线程不安全的原因线程加锁操作解决原子性问题什么是加锁使用关键字进行加锁使用示例三、标准"}