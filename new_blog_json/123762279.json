{"blogid": "123762279", "writerAge": "码龄2年", "writerBlogNum": "35", "writerCollect": "283", "writerComment": "733", "writerFan": "1465", "writerGrade": "5级", "writerIntegral": "2772", "writerName": "Soryu_Shikinami", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123762279.jpg", "writerRankTotal": "41089", "writerRankWeekly": "214964", "writerThumb": "934", "writerVisitNum": "17390", "blog_read_count": "3411", "blog_time": "于 2022-03-26 21:50:31 发布", "blog_title": "【STL详解】string类", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"1.%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB\">1.标准库中的string类</a></p>\n<p id=\"string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%3A-toc\" style=\"margin-left:0px;\"><a href=\"#string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%3A\">string类的常用接口说明:</a></p>\n<p id=\"1.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0\">1. string类对象的常见构造</a></p>\n<p id=\"2.2string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#2.2string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C\">2.2string类对象的容量操作</a></p>\n<p id=\"3.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%C2%A0\">3. string类对象的访问及遍历操作 </a></p>\n<p id=\"4.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:0px;\"><a href=\"#4.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C\">4. string类对象的修改操作</a></p>\n<p id=\"5.%20string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#5.%20string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">5. string类非成员函数</a></p>\n<hr id=\"hr-toc\"/>\n<p><img alt=\"\" height=\"387\" src=\"..\\..\\static\\image\\572240241a8c4ee9ae0feedc4ac18ee3.png\" width=\"457\"/></p>\n<p> </p>\n<hr/>\n<h1 id=\"1.%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB\">1.标准库中的string类</h1>\n<blockquote>\n<p><strong>总结：</strong><br/> 1.) string是表示字符串的字符串类。<br/> 2. )该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</p>\n<p>3. ）string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char,char_traits, allocator&gt;string;<br/> 4. ）不能操作多字节或者变长字符的序列。</p>\n</blockquote>\n<h1 id=\"string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%3A\">string类的常用接口说明:</h1>\n<h2 id=\"1.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0\">1. string类对象的常见构造</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>(constructor)<strong>函数名称 </strong></td><td><strong>功能说明</strong></td></tr><tr><td><strong>string() （重点）</strong></td><td><strong>构造空的string类对象，即空字符串</strong></td></tr><tr><td><strong>string(const char* s) （重点）</strong></td><td><strong>用C-string来构造string类对象</strong></td></tr><tr><td><strong>string(size_t n, char c) </strong></td><td><strong>string类对象中包含n个字符c</strong></td></tr><tr><td><strong>string(const string&amp;s) （重点） </strong></td><td><strong>拷贝构造函数</strong></td></tr></tbody></table>\n<pre><code class=\"language-cpp\">string();  //构造一个空字符串\n\nstring(const char* s);  //复制s所指的字符序列\n\nstring(const char* s, size_t n);  //复制s所指字符序列的前n个字符\n\nstring(size_t n, char c);  //生成n个c字符的字符串\n\nstring(const string&amp; str);  //生成str的复制品\n\nstring(const string&amp; str, size_t pos, size_t len = npos);  //复制str中从字符位置pos开始并跨越len个字符的部分\n</code></pre>\n<p>使用示例：</p>\n<pre><code class=\"language-cpp\">string s1;                     //构造空字符串\nstring s2(\"hello\");            //复制\"hello string\"\nstring s3(\"hello\", 3);         //复制\"hello string\"的前3个字符\nstring s4(10, 's');            //生成10个's'字符的字符串\nstring s5(s2);                 //生成s2的复制品\nstring s6(s2, 1, 4);           //复制s2中从字符位置1开始并跨越4个字符的部分\n</code></pre>\n<h2 id=\"2.2string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C\">2.2string类对象的容量操作</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px;\"><tbody><tr><td><strong>函数名称 </strong></td><td><strong>功能说明</strong></td></tr><tr><td><strong>size</strong></td><td><strong>返回字符串有效字符长度</strong></td></tr><tr><td><strong>length</strong></td><td><strong>返回字符串有效字符长度</strong></td></tr><tr><td><strong>capacity</strong></td><td><strong>返回空间总大小</strong></td></tr><tr><td><strong>empty</strong></td><td><strong>检测字符串释放为空串，是返回true，否则返回false</strong></td></tr><tr><td><strong>clear</strong></td><td><strong>清空有效字符</strong></td></tr><tr><td><strong>reserve</strong></td><td><strong>为字符串预留空间</strong></td></tr><tr><td><strong>resize</strong></td><td><strong>将有效字符的个数该成n个，多出的空间用字符c填充</strong></td></tr></tbody></table>\n<p>使用示例：</p>\n<p><strong>1、使用size函数或length函数获取当前有效字符的个数</strong></p>\n<blockquote>\n<p><strong>size_t size() const;</strong><br/><strong>size_t length() const;</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">\tstring s(\"CSDN\");\n\tcout &lt;&lt; s.size() &lt;&lt; endl; //4\n\tcout &lt;&lt; s.length() &lt;&lt; endl; //4\n</code></pre>\n<p><strong>2、</strong> <strong>使用capacity函数获取当前对象所分配的存储空间的大小</strong></p>\n<blockquote>\n<p>size_t capacity() const;</p>\n</blockquote>\n<pre><code class=\"language-cpp\">\tstring s(\"CSDN\");\n\tcout &lt;&lt; s.capacity() &lt;&lt; endl; //15\n</code></pre>\n<p><strong>3、使用resize改变当前对象的有效字符的个数</strong></p>\n<blockquote>\n<p>void resize (size_t n);<br/> void resize (size_t n, char c);</p>\n</blockquote>\n<p> <strong>resize规则：</strong><br/>  1、当n大于对象当前的size时，将size扩大到n，扩大的字符为c，若c未给出，则默认为’\\0’。<br/>  2、当n小于对象当前的size时，将size缩小到n。</p>\n<p>使用实例：</p>\n<pre><code class=\"language-cpp\">\tstring s1(\"ABCD\");\n\t//resize(n)n大于对象当前的size时，将size扩大到n，扩大的字符默认为'\\0'\n\ts1.resize(20);\n\tcout &lt;&lt; s1 &lt;&lt; endl; //ABCD\n\tcout &lt;&lt; s1.size() &lt;&lt; endl; //20\n\tcout &lt;&lt; s1.capacity() &lt;&lt; endl; //31\n\n\tstring s2(\"ABCD\");\n\t//resize(n, char)n大于对象当前的size时，将size扩大到n，扩大的字符为char\n\ts2.resize(20, 'x');\n\tcout &lt;&lt; s2 &lt;&lt; endl; //ABCDxxxxxxxxxxxxxxxx\n\tcout &lt;&lt; s2.size() &lt;&lt; endl; //20\n\tcout &lt;&lt; s2.capacity() &lt;&lt; endl; //31\n\n\tstring s3(\"ABCD\");\n\t//resize(n)n小于对象当前的size时，将size缩小到n\n\ts3.resize(2);\n\tcout &lt;&lt; s3 &lt;&lt; endl; //AB\n\tcout &lt;&lt; s3.size() &lt;&lt; endl; //2\n\tcout &lt;&lt; s3.capacity() &lt;&lt; endl; //15\n</code></pre>\n<p><strong>        注意</strong>：若给出的n大于对象当前的capacity，则capacity也会根据自己的增长规则进行扩大。</p>\n<p><strong>4、使用reserve改变当前对象的容量大小</strong></p>\n<blockquote>\n<p>void reserve (size_t n = 0);</p>\n</blockquote>\n<p> <strong>reserve规则：</strong><br/>  1、当n大于对象当前的capacity时，将capacity扩大到n或大于n。<br/>  2、当n小于对象当前的capacity时，什么也不做。</p>\n<p>使用示例：</p>\n<pre><code class=\"language-cpp\">\tstring s(\"ABCD\");\n\tcout &lt;&lt; s &lt;&lt; endl; //ABCD\n\tcout &lt;&lt; s.size() &lt;&lt; endl; //4\n\tcout &lt;&lt; s.capacity() &lt;&lt; endl; //15\n\n\t//reverse(n)当n大于对象当前的capacity时，将当前对象的capacity扩大为n或大于n\n\ts.reserve(20);\n\tcout &lt;&lt; s &lt;&lt; endl; //ABCD\n\tcout &lt;&lt; s.size() &lt;&lt; endl; //4\n\tcout &lt;&lt; s.capacity() &lt;&lt; endl; //31\n\n\t//reverse(n)当n小于对象当前的capacity时，什么也不做\n\ts.reserve(2);\n\tcout &lt;&lt; s &lt;&lt; endl; //ABCD\n\tcout &lt;&lt; s.size() &lt;&lt; endl; //4\n\tcout &lt;&lt; s.capacity() &lt;&lt; endl; //31\n</code></pre>\n<p><strong>        注意</strong>：此函数对字符串的size没有影响，并且无法更改其内容。</p>\n<p></p>\n<p>以上小结：</p>\n<blockquote>\n<p>1. ）size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。</p>\n<p><br/> 2. ）clear()只是将string中有效字符清空，不改变底层空间大小。</p>\n<p><br/> 3.） resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间。        注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</p>\n<p><br/> 4. ）reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小。</p>\n</blockquote>\n<h1 id=\"3.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%C2%A0\">3. string类对象的访问及遍历操作 </h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px;\"><tbody><tr><td><strong>函数名称</strong></td><td><strong>功能说明</strong></td></tr><tr><td><strong>operator[] </strong></td><td><strong>返回pos位置的字符，const string类对象调用</strong></td></tr><tr><td><strong>begin</strong></td><td><strong>获取第一个字符的迭代器</strong></td></tr><tr><td><strong>end</strong></td><td><strong>获取最后一个字符下一个位置的迭代器</strong></td></tr><tr><td><strong>rbegin</strong></td><td><strong>返回指向字符串最后一个字符的‎<em>‎反向迭代器‎</em></strong></td></tr><tr><td><strong>rend</strong></td><td><strong>‎返回指向字符串第一个字符前面的理论元素的‎<em>‎反向迭代器‎</em></strong></td></tr><tr><td><strong>范围for</strong></td><td><strong>C++11支持更简洁的范围for的新遍历方式</strong></td></tr></tbody></table>\n<p><strong>1、[ ]+下标</strong><br/>  因为string类对[ ]运算符进行了重载，所以我们可以直接使用[ ]+下标访问对象中的元素。并且该重载使用的是引用返回，所以我们可以通过[ ]+下标修改对应位置的元素。</p>\n<blockquote>\n<p>char&amp; operator[] (size_t pos);<br/> const char&amp; operator[] (size_t pos) const;</p>\n</blockquote>\n<pre><code class=\"language-cpp\">\tstring s(\"ABCD\");\n\t//[]+下标访问对象元素\n\tfor (size_t i = 0; i &lt; s.size(); i++)\n\t{\n\t\tcout &lt;&lt; s[i];\n\t}\n\tcout &lt;&lt; endl;\n\n\t//[]+下标修改对象元素内容\n\tfor (size_t i = 0; i &lt; s.size(); i++)\n\t{\n\t\ts[i] = 'a';\n\t}\n\tcout &lt;&lt; s &lt;&lt; endl; //aaaa\n</code></pre>\n<p><strong>2、使用迭代器访问对象中的元素</strong></p>\n<blockquote>\n<p>    iterator begin();<br/>  const_iterator begin() const;<br/>     iterator end();<br/>  const_iterator end() const;<br/>     reverse_iterator rbegin();<br/>  const_reverse_iterator rbegin() const;<br/>     reverse_iterator rend();<br/>  const_reverse_iterator rend() const; </p>\n</blockquote>\n<pre><code class=\"language-cpp\">\tstring s(\"ABCD\");\n\n\t//使用迭代器访问对象元素\n\tstring::iterator it1 = s.begin();\n\twhile (it1 != s.end())\n\t{\n\t\tcout &lt;&lt; *it1;\n\t\tit1++;\n\t}\n\tcout &lt;&lt; endl; //ABCD\n\n\t//使用迭代器访问对象元素，并对其进行修改\n\tstring::iterator it2 = s.begin();\n\twhile (it2 != s.end())\n\t{\n\t\t*it2 += 1;\n\t\tit2++;\n\t}\n\tcout &lt;&lt; s &lt;&lt; endl; //DCBA\n</code></pre>\n<p><strong>3、使用范围for访问对象中的元素</strong><br/>  需要注意的是：若是需要通过范围for修改对象的元素，则用于接收元素的变量e的类型必须是引用类型，否则e只是对象元素的拷贝，对e的修改不会影响到对象的元素。</p>\n<pre><code class=\"language-cpp\">\tstring s(\"ABCD\");\n\t//使用范围for访问对象元素\n\tfor (auto e : s)\n\t{\n\t\tcout &lt;&lt; e;\n\t}\n\tcout &lt;&lt; endl; //CSDN\n\n\t//使用范围for访问对象元素，并对其进行修改\n\tfor (auto&amp; e : s) //需要修改对象的元素，e必须是引用类型\n\t{\n\t\te = 'x';\n\t}\n\tcout &lt;&lt; s &lt;&lt; endl; //xxxx\n</code></pre>\n<h1 id=\"4.%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C\">4. string类对象的修改操作</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px;\"><tbody><tr><td><strong>函数名称 </strong></td><td><strong>功能说明</strong></td></tr><tr><td><strong>push_back</strong></td><td><strong>在字符串后尾插字符c</strong></td></tr><tr><td><strong>append</strong></td><td><strong>在字符串后追加一个字符串</strong></td></tr><tr><td><strong>operator+=</strong></td><td><strong>在字符串后追加字符串str</strong></td></tr><tr><td><strong>c_str</strong></td><td><strong>返回C格式字符串</strong></td></tr><tr><td><strong>find + npos</strong></td><td><strong>从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</strong></td></tr><tr><td><strong>rfind</strong></td><td><strong>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</strong></td></tr><tr><td><strong>substr</strong></td><td><strong>在str中从pos位置开始，截取n个字符，然后将其返回</strong></td></tr></tbody></table>\n<p>使用实例：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid Teststring()\n{\n\tstring str;\n\tstr.push_back(' ');\t\t\t// 在str后插入空格\n\tstr.append(\"hello\");\t\t// 在str后追加一个字符\"hello\"\n\tstr += 'l';\t\t\t\t\t// 在str后追加一个字符'l'\n\tstr += \"xy\";\t\t\t\t// 在str后追加一个字符串\"xy\"\n\tcout &lt;&lt; str &lt;&lt; endl;\t\t//  hellolxy\n\tcout &lt;&lt; str.c_str() &lt;&lt; endl; // 以C语言的方式打印字符串\n\n\t// 获取file的后缀\n\tstring file(\"string.cpp\");\n\tsize_t pos = file.rfind('.');\n\tstring suffix(file.substr(pos, file.size() - pos));\n\tcout &lt;&lt; suffix &lt;&lt; endl; //cpp\n\t// npos是string里面的一个静态成员变量\n\t// static const size_t npos = -1;\n\t// 取出url中的域名\n\tstring url(\"http://www.cplusplus.com/reference/string/string/find/\");\n\tcout &lt;&lt; url &lt;&lt; endl;\n\tsize_t start = url.find(\"://\");\n\tif (start == string::npos)\n\t{\n\t\tcout &lt;&lt; \"invalid url\" &lt;&lt; endl;\n\t\treturn;\n\t}\n\tstart += 3; // 指向W\n\tsize_t finish = url.find('/', start); //从start向后开始找'/'\n\tstring address = url.substr(start, finish - start);\n\tcout &lt;&lt; address &lt;&lt; endl; //www.cplusplus.com\n\t// 删除url的协议前缀\n\tpos = url.find(\"://\");\n\turl.erase(0, pos + 3);\n\tcout &lt;&lt; url &lt;&lt; endl; //www.cplusplus.com/reference/string/string/find/\n}\n\nint main()\n{\n\tTeststring();\n\treturn 0;\n}</code></pre>\n<p><strong>1、使用c_str或data将string转换为字符串</strong></p>\n<blockquote>\n<p>const char* c_str() const;<br/> const char* data() const;</p>\n</blockquote>\n<p>区别：</p>\n<ul><li>在C++98中，c_str()返回 const char* 类型，返回的字符串会以空字符结尾。</li><li>在C++98中，data()返回 const char* 类型，返回的字符串不以空字符结尾。</li><li>但是在C++11版本中，c_str()与data()用法相同。</li></ul>\n<pre><code class=\"language-cpp\">    string s(\"hello world \");\n\tconst char* str1 = s.data();\n\tconst char* str2 = s.c_str();\n\n\tcout &lt;&lt; str1 &lt;&lt; endl;\n\tcout &lt;&lt; str2 &lt;&lt; endl;</code></pre>\n<p><strong>2、使用substr函数提取string中的子字符串</strong></p>\n<blockquote>\n<p>string substr (size_t pos = 0, size_t len = npos) const;</p>\n</blockquote>\n<pre><code class=\"language-cpp\">    string s1(\"abcdef\");\n\tstring s2;\n\n\t//substr(pos, n)提取pos位置开始的n个字符序列作为返回值\n\ts2 = s1.substr(2, 3);\n\tcout &lt;&lt; s2 &lt;&lt; endl; //cde</code></pre>\n<p><strong>注意：</strong><br/>         1. ）在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += 'c'三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。<br/>         2. ）对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好。</p>\n<p></p>\n<h1 id=\"5.%20string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">5. string类非成员函数</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px;\"><tbody><tr><td><strong>函数</strong></td><td><strong>功能说明</strong></td></tr><tr><td><strong>operator+</strong></td><td><strong>尽量少用，因为传值返回，导致深拷贝效率低</strong></td></tr><tr><td><strong>operator&gt;&gt;</strong></td><td><strong>输入运算符重载</strong></td></tr><tr><td><strong>operator&lt;&lt;</strong></td><td><strong>输出运算符重载</strong></td></tr><tr><td><strong>getline</strong></td><td><strong>获取一行字符串</strong></td></tr><tr><td><strong>relational operators</strong></td><td><strong>大小比较</strong></td></tr></tbody></table>\n<p><strong>1、operator+</strong></p>\n<p>string类中对+运算符进行了重载，重载后的+运算符支持以下几种类型的操作：<br/>     1.)string类 + string类<br/>   2.)string类 + 字符串<br/>   3.)字符串 + string类<br/>   4.)string类 + 字符<br/>   5.)字符 + string类<br/> 它们相加后均返回一个string类对象。</p>\n<p><strong>2、operator&gt;&gt; 和 operator&lt;&lt;</strong></p>\n<p>string类中也对&gt;&gt;和&lt;&lt;运算符进行了重载，这就是为什么我们可以直接使用&gt;&gt;和&lt;&lt;对string类进行输入和输出的原因。</p>\n<p><strong>3、relational operators</strong></p>\n<p>        string类中还对一系列关系运算符进行了重载，它们分别是==、!=、&lt;、&lt;=、&gt;、&gt;=。重载后的关系运算符支持string类和string类之间的关系比较、string类和字符串之间的关系比较、字符串和string类之间的关系比较。</p>\n<p><strong>4、getline函数</strong></p>\n<p><strong>1.）istream&amp; getline (istream&amp; is, string&amp; str);</strong></p>\n<p>getline函数将从is中提取到的字符存储到str中，直到读取到换行符’\\n’为止。</p>\n<pre><code class=\"language-cpp\">string s;\ngetline(cin, s); //输入：hello lxy\ncout &lt;&lt; s &lt;&lt; endl; //输出：hello lxy</code></pre>\n<p><strong>2.) istream&amp; getline (istream&amp; is, string&amp; str, char delim);</strong></p>\n<p>getline函数将从is中提取到的字符存储到str中，直到读取到分隔符delim或换行符’\\n’为止。</p>\n<pre><code class=\"language-cpp\">string s;\ngetline(cin, s, 'x'); //输入：hello lxy\ncout &lt;&lt; s &lt;&lt; endl; //输出：hello l</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-26 21:50:31", "summary": "目录标准库中的类类的常用接口说明类对象的常见构造类对象的容量操作类对象的访问及遍历操作类对象的修改操作类非成员函数标准库中的类总结：是表示字符串的字符串类。该类的接口与常规容器的接口基本相同，再添加了"}