{"blogid": "123132592", "writerAge": "码龄8年", "writerBlogNum": "424", "writerCollect": "5043", "writerComment": "415", "writerFan": "1297", "writerGrade": "7级", "writerIntegral": "13684", "writerName": "牛奶咖啡13", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123132592.jpg", "writerRankTotal": "861", "writerRankWeekly": "7439", "writerThumb": "764", "writerVisitNum": "1617022", "blog_read_count": "5808", "blog_time": "已于 2022-02-25 17:35:53 修改", "blog_title": "C#中的动态类型(Dynamic)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、动态类型简介</h1>\n<p>    <span style=\"color:#1a439c;\"><strong> .NET 4 中引入了动态类型。动态对象（</strong></span><span style=\"color:#fe2c24;\"><strong><code>dynamicObject</code></strong></span><span style=\"color:#1a439c;\"><strong>）使您可以处理诸如 JSON 文档之类的结构内容，这些结构的组成可能要到运行时才能知道【 </strong></span><span style=\"color:#ff9900;\"><strong>该类型是一种静态类型，但类型为 <code>dynamic</code> 的对象会跳过静态类型检查。 大多数情况下，该对象就像具有类型 <code>object</code> 一样。 在编译时，将假定类型化为 <code>dynamic</code> 的元素支持任何操作。 因此，不必考虑对象是从 COM API、从动态语言（例如 IronPython）、从 HTML 文档对象模型 (DOM)、从反射还是从程序中的其他位置获取自己的值。 但是，如果代码无效，则在运行时会捕获到错误。</strong></span><span style=\"color:#1a439c;\"><strong>】</strong></span></p>\n<p>     .NET 4.0 中引入的 <span style=\"color:#fe2c24;\"><strong><code>dynamic</code></strong></span> 关键字为 C# 编程带来了一个范式转变。对于 C# 程序员来说，强类型系统之上的动态行为可能会让人感到不适 —— 当您在编译过程中失去类型安全性时，这似乎是一种倒退。【动态编程可能使您面临运行时错误。声明一个在执行过程中会发生变化的动态变量是可怕的，当开发人员对数据做出错误的假设时，代码质量就会受到影响】。</p>\n<p><span style=\"color:#ff9900;\"><strong>   对 C# 程序员来说，避免代码中的动态行为是合乎逻辑的，具有强类型的经典方法有很多好处。通过类型检查得到的数据类型的良好反馈对于正常运行的程序是至关重要的，一个好的类型系统可以更好地表达意图并减少代码中的歧义。</strong></span></p>\n<p>    随着动态语言运行时（Dynamic Language Runtime，DLR）的引入，这对 C# 意味着什么呢？ .NET 提供了丰富的类型系统，可用于编写企业级软件。让我们来仔细看看 <code>dynamic</code> 关键字，并探索一下它的功能。</p>\n<h1>二、类型层次结构</h1>\n<p><a class=\"has-card\" href=\"https://download.csdn.net/download/xiaochenXIHUA/82343997\" title=\"C#中的动态类型(Dynamic)的项目工程\"><span class=\"link-card-box\"><span class=\"link-title\">C#中的动态类型(Dynamic)的项目工程</span><span class=\"link-link\"><img alt=\"icon-default.png?t=M1L8\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://download.csdn.net/download/xiaochenXIHUA/82343997</span></span></a><span style=\"color:#fe2c24;\"><strong>    公共语言运行时（Common Language Runtime，CLR）中的每种类型都继自 <code>System.Object</code>，【这意味着 <code>object</code> 类型是整个类型系统的公共父类】</strong></span>。当我们研究更神奇的动态行为时，这一事实本身就能为我们提供帮助。这里的想法是开发这种“代码感”，以便于您了解如何驾驭 C# 中的动态类型。</p>\n<p><span style=\"color:#fe2c24;\"><strong><code>  C#的基础数据类型继承自ValueType;而ValueType</code> 重写来自 <code>object</code> 类的默认行为。<code>ValueType</code> 的子类在栈（stack）上运行，它们的生命周期较短，效率更高。而string则是派生自object。</strong></span></p>\n<p>以下为演示程序：</p>\n<pre><code class=\"language-cs\">        //1-基础类型 是否继承 ValueType\n        private static void BaseTypeInheritValueType&lt;T&gt;()\n        {\n            string str = $\"{typeof(T).Name}\\t继承于 ValueType：{typeof(T).IsSubclassOf(typeof(ValueType))}\";\n\n            Print(str);\n        }\n\n\n        //2-ValueType 是否继承 System.Object\n        private static void ValueTypeInheritObject()\n        {\n            string str = $\"ValueType 继承于 System.Object：{typeof(ValueType).IsSubclassOf(typeof(System.Object))}\";\n\n            Print(str);\n        }\n\n\n        //3-string 是否继承 System.Object\n        private static void StringInheritObject()\n        {\n            string str = $\"string 继承于 System.Object：{typeof(string).IsSubclassOf(typeof(System.Object))}\";\n\n            Print(str);\n        }</code></pre>\n<pre><code class=\"language-cs\">            //1-byte 是否继承 ValueType\n            BaseTypeInheritValueType&lt;byte&gt;();\n            //1-short 是否继承 ValueType\n            BaseTypeInheritValueType&lt;short&gt;();\n            //1-int 是否继承 ValueType\n            BaseTypeInheritValueType&lt;int&gt;();\n            //2-uint 是否继承 ValueType\n            BaseTypeInheritValueType&lt;uint&gt;();\n            //1-Long 是否继承 ValueType\n            BaseTypeInheritValueType&lt;long&gt;();\n            //1-float 是否继承 ValueType\n            BaseTypeInheritValueType&lt;float&gt;();\n            //1-double 是否继承 ValueType\n            BaseTypeInheritValueType&lt;double&gt;();\n            //1-bool 是否继承 ValueType\n            BaseTypeInheritValueType&lt;bool&gt;();\n            //1-Enum 是否继承 ValueType\n            BaseTypeInheritValueType&lt;Enum&gt;();\n            //1-char 是否继承 ValueType\n            BaseTypeInheritValueType&lt;char&gt;();\n            //1-string 是否继承 ValueType\n            BaseTypeInheritValueType&lt;string&gt;();</code></pre>\n<p><img alt=\"\" height=\"191\" src=\"..\\..\\static\\image\\b9e4fbddfaab4a20889fd1517dd9194c.png\" width=\"416\"/></p>\n<p><span style=\"color:#1a439c;\"><strong> 值类型和引用类型都是 CLR 的基本构建块，这种优雅的类型系统在 .NET 4.0 和动态类型之前就有了。</strong></span>如下是公共语言运行时(CLR) 的类型系统：</p>\n<h1><img alt=\"\" height=\"422\" src=\"..\\..\\static\\image\\bd0764346d484aa29c4017963d80bca8.png\" width=\"1200\"/>三、动态语言运行时</h1>\n<h2>3.1、动态语言运行时基础</h2>\n<p>    <span style=\"color:#1a439c;\"><strong>动态语言运行时（Dynamic Language Runtime, DLR）是处理动态对象的一种便捷方法。比如：您有 XML 或 JSON 格式的数据，但是数据其中的成员你并不知道。此时DLR 允许您使用自然代码来处理对象和访问成员。</strong></span></p>\n<p>    对于 C#，这使您可以处理在编译时不知道其类型的库。动态类型消除了自然 API 代码中的万能字符串。这就开启了像 IronPython 一样位于 CLR 之上的动态语言。</p>\n<p>可以将 DLR 视为支持三项主要服务：</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:660px;\"><caption>\n  动态语言运行时的三项主要服务\n </caption><tbody><tr><td style=\"width:45px;\">序号</td><td style=\"width:319px;\">内容</td><td style=\"width:294px;\">说明</td></tr><tr><td style=\"width:45px;\">1</td><td style=\"width:319px;\">表达式树</td><td style=\"width:294px;\">表达式树，来自 System.Linq.Expressions 命名空间。编译器在运行时生成具有动态语言互操作性的表达式树</td></tr><tr><td style=\"width:45px;\">2</td><td style=\"width:319px;\">调用站点缓存</td><td style=\"width:294px;\">调用站点缓存，即缓存动态操作的结果。DLR 缓存像 <code>a + b</code> 之类的操作，并存储 <code>a</code> 和 <code>b</code> 的特征。当执行动态操作时，DLR 将检索先前操作中可用的信息。</td></tr><tr><td style=\"width:45px;\">3</td><td style=\"width:319px;\">动态对象互操作性是可用于访问 DLR 的 C# 类型</td><td style=\"width:294px;\">动态对象互操作性是可用于访问 DLR 的 C# 类型。这些类型包括 <code>DynamicObject</code> 和 <code>ExpandoObject</code>。可用的类型还有很多</td></tr></tbody></table>\n<p><span style=\"color:#4d4d4d;\">DLR 和 CLR 的结合图如下：</span></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\d84dc0a6646ced1f8ace1f690e284a4d.png\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong>每种类型都是从 <code>System.Object</code> 派生而来的。嗯，这句话对于 CLR 是适用的，但是对于 DLR 呢？ </strong></span></p>\n<p>示例代码如下：</p>\n<pre><code class=\"language-cs\">        //4-测试DLR 是否继承 System.Object\n        private static void DLRObjectInheritObject&lt;T&gt;()\n        {\n            string str = $\"{typeof(T).Name}\\t继承于 System.Object：{typeof(T).IsSubclassOf(typeof(System.Object))}\";\n\n            Print(str);\n        }</code></pre>\n<pre><code class=\"language-cs\">            //4-测试DynamicObject 是否继承 System.Object\n            DLRObjectInheritObject&lt;System.Dynamic.DynamicObject&gt;();\n            //4-测试ExpandoObject 是否继承 System.Object\n            DLRObjectInheritObject&lt;System.Dynamic.ExpandoObject&gt;();</code></pre>\n<p>运行结果如下：</p>\n<p><img alt=\"\" height=\"48\" src=\"..\\..\\static\\image\\edabc54f990544a198b5fce3fb792846.png\" width=\"445\"/></p>\n<h2> 3.2、动态语言运行时应用场景</h2>\n<p>    <span style=\"color:#ff9900;\"><strong>动态类型解决的一个问题是，当您有一个不知道其成员的 JSON HTTP 请求时，假设要在 C# 中使用此任意的 JSON。要解决这个问题，请将此 JSON 序列化为 C# 动态类型。</strong></span></p>\n<p>我将使用 Newtonsoft 序列化库，您可以通过 NuGet 添加此依赖项。</p>\n<p>    您可以使用这个序列化程序来处理 <code>ExpandoObject</code> 和 <code>DynamicObject</code>。探索每种动态类型给动态编程带来了什么。</p>\n<h2>3.3、ExpandoObject 动态类型</h2>\n<p><code>  <span style=\"color:#1a439c;\"><strong>【ExpandoObject</strong></span></code><span style=\"color:#1a439c;\"><strong><code>】</code>是一种方便的类型，允许设置和检索动态成员。它实现了 <code>IDynamicMetaObjectProvider</code>，该接口允许在 DLR 中的语言之间共享实例。因为它实现了 <code>IDictionary</code> 和 <code>IEnumerable</code>，所以它也可以处理 CLR 中的类型。</strong></span></p>\n<p>    举例来说，它允许将 <code>ExpandoObject</code> 的实例转换为 <code>IDictionary</code>，然后像其它任意的 <code>IDictionary</code> 类型一样枚举成员。</p>\n<p>要用 <code>ExpandoObject</code> 处理任意 JSON，您可以编写以下程序：</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Test_Dynamic\n{\n    class PeopleInfo\n    {\n        public string Id { get; set; }\n        public string Name { get; set; }\n        public string Sex { get; set; }\n        public int Age { get; set; }\n        public string TelNumber { get; set; }\n        public string Address { get; set; }\n\n\n    }//Class_end\n\n}</code></pre>\n<pre><code class=\"language-cs\">        //获取人员信息\n        private static PeopleInfo GetPeopleInfo()\n        {\n            PeopleInfo peopleInfo = new PeopleInfo();\n            peopleInfo.Id = Guid.NewGuid().ToString(\"N\");\n            peopleInfo.Name = \"牛奶咖啡\";\n            peopleInfo.Sex = \"男\";\n            peopleInfo.Age = 27;\n            peopleInfo.TelNumber = \"13115672345\";\n            peopleInfo.Address = \"中华人民共和国测试省测试市测试街道测试号\";\n\n            return peopleInfo;\n        }\n\n        //将一个对象序列化为Json字符串\n        private static string GetJsonStrOfObject&lt;T&gt;(T t)\n        {\n            string str = Newtonsoft.Json.JsonConvert.SerializeObject(t);\n            return str;\n\n        }\n\n        //将一个Json字符串反序列化为动态类型(通过ExpandoObject类型)\n        private static dynamic GetExpandoObjectResultOfJsonStr(string jsonStr)\n        {\n            if (string.IsNullOrEmpty(jsonStr)) return null;\n\n            dynamic result = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;System.Dynamic.ExpandoObject&gt;(jsonStr);\n           \n            return result;\n        }\n\n        //输出ExpandoObject类型的解析内容\n        private static void PrintExpandoObjectInfo(dynamic dc)\n        {\n            string str = $\"编号：{dc?.Id}\\t姓名：{dc?.Name}\\t性别：{dc?.Sex}\\t年龄：{dc?.Age}\\t\" +\n                $\"电话：{dc?.TelNumber}\\t住址：{dc?.Address}\";\n\n            Print(str);\n            \n        }\n\n        //输出ExpandoObject类型的解析内容(IDictionary)\n        private static void PrintExpandoObjectInfo2(dynamic dc)\n        {\n            if (dc == null) return;\n\n            foreach (var item in dc as System.Collections.Generic.IDictionary&lt;string, object&gt;??\n                new System.Collections.Generic.Dictionary&lt;string, object&gt;())\n            {\n                string str=$\"IDictionary={item.Key}：{item.Value}\"; \n\n                Print(str);\n            }\n        }</code></pre>\n<p>   调用方法示例如下：</p>\n<pre><code class=\"language-cs\">       //5-ExpandoObject示例\n        private static void ExpandoObjectSample()\n        {\n\n            //1-将一个PeopleInfo对象序列化为Json字符串\n            string jsonStr = GetJsonStrOfObject(GetPeopleInfo());\n\n            //2-将一个Json字符串反序列化为动态类型(通过ExpandoObject类型)\n            dynamic dc = GetExpandoObjectResultOfJsonStr(jsonStr);\n\n            //3-输出ExpandoObject类型的解析内容\n            PrintExpandoObjectInfo(dc);\n\n            //4-输出ExpandoObject类型的解析内容(IDictionary)\n            PrintExpandoObjectInfo2(dc);\n        }\n</code></pre>\n<p>运行结果如下：</p>\n<p><img alt=\"\" height=\"134\" src=\"..\\..\\static\\image\\704b79024e12435ba465a6d3d276ea96.png\" width=\"1200\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong>请注意：尽管它是一个动态 JSON，但它会绑定到 CLR 中的 C# 类型。由于数字的类型未知，因此序列化程序默认会选择支持的最大类型（比如Age字段就使用的是long类型）。</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>    我们成功地将序列化结果转换成了具有 null 检查的 <code>dynamic</code> 类型，其原因是序列化程序返回来自 CLR的 <code>object</code> 类型。因为 <code>ExpandoObject</code> 继承自 <code>System.Object</code>，所以可以被拆箱成 DLR 类型。</strong></span></p>\n<p>  <span style=\"color:#fe2c24;\"><strong>  更奇妙的是，可以用 <code>IDictionary</code> 枚举 <code>dynamic，如下图所示：</code></strong></span></p>\n<pre><code class=\"language-cs\">        //输出ExpandoObject类型的解析内容(IDictionary)\n        private static void PrintExpandoObjectInfo2(dynamic dc)\n        {\n            if (dc == null) return;\n\n            foreach (var item in dc as System.Collections.Generic.IDictionary&lt;string, object&gt;??\n                new System.Collections.Generic.Dictionary&lt;string, object&gt;())\n            {\n                string str=$\"IDictionary={item.Key}：{item.Value}\"; \n\n                Print(str);\n            }\n        }</code></pre>\n<h2>3.4、DynamicObject 动态类型</h2>\n<p><code>  <span style=\"color:#1a439c;\"><strong>【DynamicObject】</strong></span></code><span style=\"color:#1a439c;\"><strong> 提供对动态类型的精确控制。您可以继承该类型并重写动态行为。例如：您可以定义如何设置和获取类型中的动态成员。<code>DynamicObject</code> 允许您通过重写选择实现哪些动态操作。这比实现 <code>IDynamicMetaObjectProvider</code> 的语言实现方式更易访问。它是一个抽象类，需要继承它而不是实例化它。该类有 14 个虚方法，它们定义了类型的动态操作，每个虚方法都允许重写以指定动态行为。</strong></span></p>\n<p>    假设您想要精确控制动态 JSON 中的内容。尽管事先不知道其属性，您却可以使用 <code>DynamicObject</code> 来控制类型。</p>\n<p>让我们来重写三个方法，<code>TryGetMember</code>、<code>TrySetMember</code> 和 <code>GetDynamicMemberNames</code>：</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Dynamic;\nusing System.Text;\n\nnamespace Test_Dynamic\n{\n    class OpcJsonOfDynamic&lt;T&gt;: System.Dynamic.DynamicObject\n    {\n        private readonly IDictionary&lt;string, T&gt; _objProperty;\n\n        public OpcJsonOfDynamic()\n        {\n            _objProperty = new Dictionary&lt;string,T&gt;();\n        }\n\n        public override bool TryGetMember(GetMemberBinder binder, out object result)\n        {\n            T typeObj;\n\n            if (_objProperty.TryGetValue(binder.Name,out typeObj))\n            {\n                result = typeObj;\n                return true;\n            }\n\n            result = null;\n\n            return false;\n        }\n\n        public override bool TrySetMember(SetMemberBinder binder, object value)\n        {\n            if (value.GetType()!=typeof(T))\n            {\n                return false;\n            }\n\n            _objProperty[binder.Name]=(T)value;\n\n            return true;\n        }\n\n        public override IEnumerable&lt;string&gt; GetDynamicMemberNames()\n        {\n            return _objProperty.Keys;\n        }\n\n        public IDictionary&lt;string, T&gt; GetKeyValues()\n        {\n            return _objProperty;\n        }\n\n    }//Class_end\n\n}</code></pre>\n<p> C# 泛型强类型 <code>_objProperty</code> 以泛型的方式驱动成员类型。这意味着其属性类型来自泛型类型 <code>T</code>。动态 JSON 成员位于字典中，并且仅存储泛型类型。此动态类型允许同一类型的同类成员集合。尽管它允许动态成员集，但您可以强类型其行为。假设您只关心任意 JSON 中的 <code>string</code> 类型：</p>\n<pre><code class=\"language-cs\">        //获取人员信息\n\n        private static PeopleInfo GetPeopleInfo()\n        {\n            PeopleInfo peopleInfo = new PeopleInfo();\n            peopleInfo.Id = Guid.NewGuid().ToString(\"N\");\n            peopleInfo.Name = \"牛奶咖啡\";\n            peopleInfo.Sex = \"男\";\n            peopleInfo.Age = 27;\n            peopleInfo.TelNumber = \"13115672345\";\n            peopleInfo.Address = \"中华人民共和国测试省测试市测试街道测试号\";\n\n            return peopleInfo;\n        }\n\n\n        //输出DynamicObject类型的内容\n        private static void PrintDynamicObjectInfo(System.Dynamic.DynamicObject dc)\n        {\n            if (dc == null) return;\n\n            if (dc is OpcJsonOfDynamic&lt;string&gt;)\n            {\n                OpcJsonOfDynamic&lt;string&gt; opcJsonOfDynamic = (dc as OpcJsonOfDynamic&lt;string&gt;);\n\n                foreach (var item in opcJsonOfDynamic.GetKeyValues())\n                {\n                    string str = $\"键：{item.Key}\\t值：{item.Value}\";\n                    Print(str);\n                }\n                \n            }\n        }</code></pre>\n<p>调用方法示例如下：</p>\n<pre><code class=\"language-cs\">        //6-DynamicObject示例\n        private static void DynamicObjectSample()\n        {\n            //1-将一个PeopleInfo对象序列化为Json字符串\n            string jsonStr = GetJsonStrOfObject(GetPeopleInfo());\n\n            //2-通过Dynamic对象操作Json\n            System.Dynamic.DynamicObject dcObj = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;OpcJsonOfDynamic&lt;string&gt;&gt;(jsonStr);\n\n            //3-输出dcObj内容\n            PrintDynamicObjectInfo(dcObj);\n\n        }</code></pre>\n<p>运行结果如下：</p>\n<p><img alt=\"\" height=\"117\" src=\"..\\..\\static\\image\\4f15c02e17a44e4cb2b8868131705ac9.png\" width=\"526\"/></p>\n<h2>3.5、类型结果</h2>\n<ul><li>CLR 和 DLR 中的所有类型都继承自 <code>System.Object</code></li><li>DLR 是所有动态操作发生的地方</li><li><code>ExpandoObject</code> 实现了 CLR 中诸如 <code>IDictionary</code> 的可枚举类型</li><li><code>DynamicObject</code> 通过虚方法对动态类型进行精确控制</li></ul>\n<h1> 四、参考文档</h1>\n<p><a class=\"has-card\" href=\"https://www.red-gate.com/simple-talk/development/dotnet-development/working-with-the-dynamic-type-in-c/\" title=\"Working with the Dynamic Type in C# - Simple Talk (red-gate.com)\"><span class=\"link-card-box\"><span class=\"link-title\">Working with the Dynamic Type in C# - Simple Talk (red-gate.com)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://www.red-gate.com/simple-talk/development/dotnet-development/working-with-the-dynamic-type-in-c/</span></span></a><a class=\"has-card\" href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/using-type-dynamic\" title=\"使用类型 dynamic - C# 编程指南 | Microsoft Docs\"><span class=\"link-card-box\"><span class=\"link-title\">使用类型 dynamic - C# 编程指南 | Microsoft Docs</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/using-type-dynamic</span></span></a></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 1, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-02-25 17:35:53", "summary": "一、动态类型简介中引入了动态类型。动态对象使您可以处理诸如文档之类的结构内容，这些结构的组成可能要到运行时才能知道该类型是一种静态类型，但类型为的对象会跳过静态类型检查。大多数情况下，该对象就像具有类"}