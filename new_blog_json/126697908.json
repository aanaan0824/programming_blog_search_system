{"blogid": "126697908", "writerAge": "码龄1年", "writerBlogNum": "57", "writerCollect": "19", "writerComment": "10", "writerFan": "17", "writerGrade": "3级", "writerIntegral": "610", "writerName": "要自律！", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126697908.jpg", "writerRankTotal": "36589", "writerRankWeekly": "379429", "writerThumb": "20", "writerVisitNum": "17769", "blog_read_count": "63", "blog_time": "已于 2022-09-05 11:29:17 修改", "blog_title": "单链表笔试题（是否相交，求交点；是否有环，求入环点）C++", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>1. 判断两个单链表是否相交，若相交求交点。</strong></p>\n<p>（1）首先仅判断是否相交？</p>\n<p><strong>方法：</strong>令两个单链表均走到末尾，看两者尾结点是否相同即可。</p>\n<p>（2）判断是否相交+求交点。（此处已知单链表构造）</p>\n<p><strong>方法：</strong><span style=\"color:#fe2c24;\"><strong>先让较长的链表走(两个链表长度之差)步，若</strong></span><span style=\"color:#1a439c;\"><strong>两个指针不相等</strong></span><span style=\"color:#fe2c24;\"><strong>且</strong></span><span style=\"color:#1a439c;\"><strong>任一指针!=NULL</strong></span><span style=\"color:#fe2c24;\"><strong>就一同向后走，如果退出循环是两者相等则返回（相等的指针指向两个单链表交点）</strong></span>；否则返回NULL。</p>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">struct Node\n{\n\tNode(int val):data(val),next(NULL){}//带参构造函数\n\tNode(){}//无参构造函数\n\tint data;\n\tNode* next;\n};\nint Get_length(Node* p)\n{\n\tint count = 0;\n\twhile (p != NULL)\n\t{\n\t\tcount++;\n\t\tp = p-&gt;next;\n\t}\n\treturn count;\n}\nNode* Get_Node(Node* headA, Node* headB)\n{\n\tint len = Get_length(headA) - Get_length(headB);//已知headA指向的单链表较长\n\tfor (int i = 0; i &lt; len; ++i)\n\t{\n\t\theadA = headA-&gt;next;//较长单链表先走长度差值步\n\t}\n\twhile (headA!=headB&amp;&amp;headA!=NULL)//两者不相等且任意一者不为空（由于两者剩余长度相同），则一同往后走\n\t{\n\t\theadA = headA-&gt;next;\n\t\theadB = headB-&gt;next;\n\t}\n\tif (headA == headB) return headA;\n\telse return NULL;\n}\nvoid main()\n{\n\t//已知较长单链表：1 2 3 5 8 9 10\n\t//已知较短单链表：4 6 9 10\n\tNode a(1), b(2), c(3), d(5), e(8), f(9), g(10);//调用带参构造函数初始化节点\n\tNode x(4), y(6);\n\n\tNode* headA = &amp;a;\n\ta.next = &amp;b;\n\tb.next = &amp;c;\n\tc.next = &amp;d;\n\td.next = &amp;e;\n\te.next = &amp;f;\n\tf.next = &amp;g;\n\n\tNode* headB = &amp;x;\n\tx.next = &amp;y;\n\ty.next = &amp;f;//令两个单链表相交\n\t\n\tNode* h = Get_Node(headA, headB);\n\tif (h != NULL)\n\t{\n\t\tcout &lt;&lt; \"两个单链表相交，且交点为：\" &lt;&lt; h-&gt;data &lt;&lt; endl;\n\t}\n\telse cout &lt;&lt; \"两个单链表不相交\" &lt;&lt; endl;\n}</code></pre>\n<p> 示例：两个链表相交（如图）</p>\n<p><img alt=\"\" height=\"193\" src=\"..\\..\\static\\image\\24ef487dbf5a46608ba2e2220fd7fe47.png\" width=\"435\"/></p>\n<p>  示例：两个链表不相交（如图）</p>\n<p><img alt=\"\" height=\"213\" src=\"..\\..\\static\\image\\c64375a7e3c7446f9a4b17012944ca97.png\" width=\"447\"/></p>\n<p><strong>2. 判断单链表是否有环，若存在环 则返回入环点。</strong></p>\n<p>（1）判断是否存在环：</p>\n<p><strong>【快慢指针法】</strong>快指针fast初始化从头结点向后走两步，慢指针slow初始化走一步。while(fast!=slow&amp;&amp;<strong>fast!=NULL</strong>)就让fast走两步，slow走一步。若退出循环是二者相等：代表有环存在。</p>\n<p><strong>注意：</strong>在while循环要判断fast!=NULL是由于如果单链表不存在环，则fast指针会先走到末尾结束循环。也保证了在while循环中fast走两步时不会出现空指针指向。</p>\n<p>（2）求入环点（如图）</p>\n<p><img alt=\"\" height=\"358\" src=\"..\\..\\static\\image\\448071740a1045898e90a25a2691559a.png\" width=\"1200\"/></p>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">struct Node\n{\n\tNode(int val):data(val),next(NULL){}\n\tNode(){}\n\tint data;\n\tNode* next;\n};\nNode* Get_Cir_Node(Node* head)\n{\n\t//快慢指针\n\tNode* fast = head-&gt;next-&gt;next;//快指针初始化走两步\n\tNode* slow = head-&gt;next;\n\t\n\t//判断是否存在环？\n\twhile (fast != slow &amp;&amp; fast != NULL)//如果单链表不存在环，则fast指针会先走到末尾结束循环。也保证了在while循环中fast走两步时不会出现空指针指向。\n\t{\n\t\tfast = fast-&gt;next-&gt;next;\n\t\tslow = slow-&gt;next;\n\t}\n\tif (fast == NULL) return NULL;\n\t\n\t//有环，找入环点：x=z+(n-1)(y+z); 距离相同，速度相同~同时相遇在入环点\n\tNode* p = head;\n\tNode* q = fast;//或者Node*q=slow; 此刻fast和slow均指向快慢指针相遇点\n\twhile (p != q)\n\t{\n\t\tp = p-&gt;next;\n\t\tq = q-&gt;next;\n\t}\n\treturn p;\n}\nvoid main()\n{\n\t//带环单链表：1 2 3 4 5 6 4\n\tNode a(1), b(2), c(3), d(4), e(5), f(6);\n\tNode* head = &amp;a;\n\ta.next = &amp;b;\n\tb.next = &amp;c;\n\tc.next = &amp;d;\n\td.next = &amp;e;\n\te.next = &amp;f;\n\tf.next = &amp;d;//构成环\n\n\tNode* p = Get_Cir_Node(head);\n\tif (p != NULL) cout &lt;&lt; \"该单链表有环，入环点为：\" &lt;&lt; p-&gt;data &lt;&lt; endl;\n\telse cout &lt;&lt; \"该单链表无环\" &lt;&lt; endl;\n}</code></pre>\n<p> 示例：单链表有环（如图）</p>\n<p><img alt=\"\" height=\"189\" src=\"..\\..\\static\\image\\1336eb1806a748689dbaaecf14a29f2e.png\" width=\"439\"/></p>\n<p> 示例：单链表无环（如图）</p>\n<p><img alt=\"\" height=\"199\" src=\"..\\..\\static\\image\\f98ea5d45884450cb6eb987129b90eac.png\" width=\"440\"/></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 11:29:17", "summary": "判断两个单链表是否相交，若相交求交点。首先仅判断是否相交？方法：令两个单链表均走到末尾，看两者尾结点是否相同即可。判断是否相交求交点。此处已知单链表构造方法：先让较长的链表走两个链表长度之差步，若两个"}