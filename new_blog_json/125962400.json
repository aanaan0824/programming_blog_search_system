{"blogid": "125962400", "writerAge": "码龄1年", "writerBlogNum": "195", "writerCollect": "3405", "writerComment": "3097", "writerFan": "9832", "writerGrade": "7级", "writerIntegral": "12690", "writerName": "Dark And Grey", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125962400.jpg", "writerRankTotal": "869", "writerRankWeekly": "179", "writerThumb": "4671", "writerVisitNum": "222986", "blog_read_count": "1056", "blog_time": "于 2022-07-31 19:37:12 发布", "blog_title": "JavaEE进阶 - Spring MVC 程序开发 - 细节狂魔", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_Spring_MVC_1\">什么是 Spring MVC？</a></li><li><ul><li><a href=\"#MVC__44\">MVC 定义</a></li><li><a href=\"#MVC__Spring_MVC__70\">MVC 和 Spring MVC 的关系</a></li><li><a href=\"#_79\">总结</a></li></ul>\n</li><li><a href=\"#_Spring_MVC_88\">为什么要学 Spring MVC？</a></li><li><a href=\"#Spring_MVC__156\">Spring MVC 项目的创建</a></li><li><a href=\"#_Spring_MVC___165\">学习 Spring MVC 的 三个目标</a></li><li><a href=\"#Spring_MVC_____174\">Spring MVC项目的连接(用户 和 程序 的 映射)</a></li><li><ul><li><a href=\"#1RequestMappingxx_176\">方法1：@RequestMapping(\"/xx\")</a></li><li><ul><li><a href=\"#RequestMapping__post__get__228\">@RequestMapping 是 post 还是 get 请求？</a></li><li><a href=\"#___240\">总结 &amp;&amp; 拓展</a></li></ul>\n</li><li><a href=\"#2___3GetMapping__PostMapping_270\">方法2 和 方法 3：@GetMapping 和 PostMapping</a></li></ul>\n</li><li><a href=\"#_280\">获取用户请求参数</a></li><li><ul><li><a href=\"#_281\">传递单个参数</a></li><li><a href=\"#___301\">获取多个参数 / 表单参数传递（非对象）</a></li><li><a href=\"#___317\">获取多个参数 / 获取对象</a></li></ul>\n</li><li><a href=\"#_326\">拓展</a></li><li><ul><li><a href=\"#RequestParam_327\">后端参数重命名（后端参数映射：@RequestParam）</a></li><li><a href=\"#RequestParam__required_400\">@RequestParam 的进一步理解: required属性</a></li></ul>\n</li><li><a href=\"#_404\">表单参数传递（对象）</a></li><li><a href=\"#RequestBody_JSON___415\">@RequestBody 接收JSON对象 - 特殊</a></li><li><a href=\"#URLPathVariable___440\">获取URL中参数@PathVariable - 特殊</a></li><li><a href=\"#__RequestPart_485\">上传文件 - @RequestPart</a></li><li><ul><li><a href=\"#___505\">拓展：不同平台运行的配置文件设置 - 优化存储目录</a></li><li><a href=\"#____517\">图片名称不能重复 &amp;&amp; 获取原图格式 问题</a></li></ul>\n</li><li><a href=\"#CookieSessionheader_558\">获取Cookie/Session/header</a></li><li><ul><li><a href=\"#_Request__Response__591\">知识铺垫：获取 Request 和 Response 对象</a></li><li><a href=\"#_Cookie_602\">获取 Cookie</a></li><li><a href=\"#_header_623\">获取 header（获取请求头中的信息）</a></li><li><a href=\"#___Session_633\">存储 和 获取 Session</a></li></ul>\n</li><li><a href=\"#_665\">返回数据给前端</a></li><li><a href=\"#_694\">练习</a></li><li><ul><li><a href=\"#___form__695\">实现计算器功能 - form 表单</a></li><li><a href=\"#_Spring_MVC____741\">拓展： Spring MVC 的 热部署 设置</a></li><li><ul><li><a href=\"#1_768\">1.添加热部署框架⽀持</a></li><li><a href=\"#2Settings__780\">2、Settings 开启项⽬⾃动编译</a></li><li><a href=\"#3_784\">3.开启运⾏中热部署</a></li><li><a href=\"#4_Debug_Run_798\">4.使⽤ Debug 启动项目（⾮Run）</a></li><li><a href=\"#_807\">效果展示</a></li></ul>\n</li><li><a href=\"#_ajax_json__813\">模拟登录功能，前端使⽤ ajax，后端返回 json 给前端。</a></li><li><ul><li><a href=\"#_815\">前端代码</a></li><li><a href=\"#_879\">后端代码</a></li><li><a href=\"#_884\">效果图</a></li><li><a href=\"#json_888\">小拓展：前端返回一个json数据，后端可以接收。</a></li></ul>\n</li></ul>\n</li><li><a href=\"#___911\">请求转发或请求重定向 - 重点</a></li><li><ul><li><a href=\"#forward_VS_redirect_912\">forward VS redirect</a></li><li><a href=\"#forward___918\">forward 请求转发 实现</a></li><li><a href=\"#redirect__953\">redirect：请求重定向 实现</a></li><li><a href=\"#_990\">区别总结</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_Spring_MVC_1\"></a>什么是 Spring MVC？</h1>\n<blockquote>\n<p><font size=\"4\">官⽅对于 Spring MVC 的描述是这样的：</font></p>\n<blockquote>\n<p><font color=\"red\"> Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, “Spring Web MVC,” comes from the name of its source module (spring-webmvc), but it is more commonly known as “Spring MVC”.</font></p>\n</blockquote>\n<p><font size=\"4\">翻译为中⽂：</font></p>\n<blockquote>\n<p><font color=\"red\">Spring Web MVC 是基于 Servlet API 构建的原始 Web 框架，从⼀开始就包含在 Spring 框架中。它的正式名称“Spring Web MVC”来⾃其源模块的名称(Spring-webmvc)，但它通常被称为“Spring MVC”。<br/>  <font color=\"blue\"><br/> 题外话：<br/> 1、因为 Spring Web MVC 是基于 Servlet API，所以 Servlet 是 Spring MVC 的 “父亲”。<br/> 因此，Servlet 那一套编程方法，在 Spring MVC 中，也是可以使用的！！！<br/> 但是，一般不推荐使用 servlet 的编程方式。<br/> 因为，Spring MVC 更简单！<br/>  <br/> 2、Spring Web MVC，从⼀开始就包含在 Spring 框架中。<br/> 即：Spring 是一个很大体系（框架），Spring MVC 只是属于 Spring 体系中的一个 Web 模块。<br/> 这也是为什么在学习 Spring 的时候，我们都都是通过 main 方法去访问bean方法的原因。因为我们没有引入 web 模块，因此想要通过 浏览器输入 URL 来访问 方法，是不行的。</font></font></p>\n</blockquote>\n<p><font size=\"4\">从上述定义我们可以得出两个关键信息：<br/> <font color=\"red\">1、 Spring MVC 是⼀个 Web 框架。（基于 Servlet 实现的）</font></font></p>\n<blockquote>\n<p>web框架，就是基于 HTTP 协议的。<br/> 通俗来说：当用户在浏览器上输入一个 URL 地址之后，URL 地址 能够和 程序映射起来。<br/> 能够让用户的请求 被 程序接受到。<br/> 并且，经过程序的处理，能把结果返回给前端（浏览器）。<br/> 这一次基于 HTTP 的交互，就可以认为是一个 web 项目。<br/> <font color=\"red\">Spring MVC 也是一个 web 框架（spring 的 一个 web 模块）。<br/> 那么，一个 web 项目，只做三件事:<br/> 1、实现用户请求 到 程序 的 链接。（用户请求 可以 被 程序接收到，也就是上面讲的）<br/> 2、在前后端建立联系的情况下，拿到用户请求的参数。<br/> 3、拿到参数之后，进行业务处理，并将其结果返回给前端。<br/>  <br/> 这也是 本文讲解 Spring MVC 的重点。<br/>  </font><br/> 如果有看过我前面博客的读者，回想一下：我在将 spring 的时候，并没有涉及 前端。<br/> 只有在讲解 Spring Boot 的时候，涉及到 web内容。<br/> 我们不是引入了一个 spring web 嘛，那个就是 前端框架。<br/> 有了这个 框架的支持，那么，项目就是一个 Spring MVC 的项目。<br/> 也就是说：其实前面创建的 Spring Boot 项目 是 一个 Spring MVC 项目。</p>\n</blockquote>\n<p> <br/> <font color=\"red\" size=\"4\">2、 Spring MVC 是基于 Servlet API 构建的。<br/> 然⽽要真正的理解什么是 Spring MVC？我们⾸先要搞清楚什么是 MVC？</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"MVC__44\"></a>MVC 定义</h2>\n<blockquote>\n<p><font size=\"4\">MVC 是 Model View Controller （模型视图控制器）的缩写，它是软件⼯程中的⼀种软件架构模式，它把软件系统分为模型、视图和控制器三个基本部分。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d26cd3dc9a0a4c9397b16dab147cc05c.png\"/><br/> <font color=\"red\" size=\"4\"><strong>Model（模型）</strong> 是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。<br/>  <br/> <strong>View（视图）</strong> 是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。<br/>  <br/> <strong>Controller（控制器）</strong> 是应⽤程序中处理⽤户交互的部分。通常控制器负责从视图读取数据，控制⽤户输⼊，并向模型发送数据。<br/>  <br/> 下面我们来进一步分析 四者之间的关系。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bdc73ef67e62460099159121eb2d30d8.png\"/><br/> 通过这个 MVC 模型，就可以让 用户 与 程序 之间，是可以进行完美的交互的 。</font></font></p>\n<blockquote>\n<p>间接来说：（忽略细节）<br/> 前端发送的请求数据，会先给 controller。<br/> controller 验证完数据之后，就会将其给 Model。<br/> Model 在和 数据库交互之后，将其得到的结果返回给 controller。<br/> 此时 controller 收到的数据，还不能直接返回给前端。<br/> controller 需要将数据 交给 服务器的视图（View），进行处理和渲染。<br/> 最终，将渲染得到的结果，返回给前端。<br/> 此时，用户就看到的源码 就是 html标签 的内容。（浏览器的开发者工具可以查看）<br/> 看到的页面，就是浏览器对 HTML标签内容的解析。</p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">此时，我们基于 MVC 这三个部分，就可以实现一个 web 项目了。</font></p>\n<blockquote>\n<p>web 项目：用户通过浏览器输入一个 URL，发送一个 HTTP请求，能够与 服务器 进行一次交互 和 响应。</p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"MVC__Spring_MVC__70\"></a>MVC 和 Spring MVC 的关系</h2>\n<blockquote>\n<p><font size=\"4\">两者之间的关系，就像是 <a href=\"https://blog.csdn.net/DarkAndGrey/article/details/125621681?spm=1001.2014.3001.5501\">IOC(控制反转) 和 DI（依赖注入）</a>之间的关系。</font></p>\n<blockquote>\n<p><font color=\"red\"> IOC 是思想，DI 是具体实现。<br/> MVC 和 Spring MVC 的关系，也是如此。<br/> MVC 是一种 <strong>设计思想</strong>（策略）。<br/> Spring MVC 是 <strong>具体实现</strong>的框架。</font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_79\"></a>总结</h2>\n<blockquote>\n<p><font color=\"red\" size=\"4\">Spring MVC 是⼀个实现了 MVC 模式，并继承了 Servlet API 的 Web 框架。既然是 Web 框架，那么当⽤户在浏览器中输⼊了 url 之后，我们的 Spring MVC 项 ⽬就可以感知到⽤户的请求。<br/>  <br/> 同时 Spring MVC 又是 Spring 框架中的 一个 WEB 模块，它是随着 Spring 的 诞生 而 存在的一个框架。</font></p>\n<blockquote>\n<p>Spring 和 Spring MVC 诞生的历史是比较久远的，在它们之后才有了 Spring Boot。<br/> Spring 大概是在 2002 年 上市的，而 Spring Boot，大概比 Spring 晚 十年 诞生的。<br/> Spring Boot 是在 2.0 版本的时候，占据了中国市场。</p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"_Spring_MVC_88\"></a>为什么要学 Spring MVC？</h1>\n<blockquote>\n<p><font color=\"red\" size=\"4\">现在绝大部分的 Java 项目都是基于 Spring（或 Spring Boot）的，而 Spring 的核心就是 Spring MVC。<br/>  <br/> <font color=\"red\" size=\"4\">也就是说 Spring MVC 是 Spring 框架的核心模块，而 Spring Boot 是 Spring 的“脚手架”，因此我们可以推断出，现在市面上绝大部分的 Java 项目 都是 Spring MVC 项目，这是我们要学 Spring MVC 的原因。</font></font></p>\n<blockquote>\n<p>现在的项目，有两种：1、PC，电脑上运行的项目，2、移动端，手机上的运行的项目。<br/>  <font color=\"red\"><br/> PC 项目，又可以分为2种：1、网页版项目，2、客户端的项目<br/> <font color=\"blue\">但是不管你 PC 项目 属于哪一种，只要你需要 数据持久化，就是用到 Spring MVC。<br/> 而那种小工具（对本地文件进行查找和管理的工具），是用不到 数据库的，它肯定是不会使用到 Java 程序。这种小项目（个人项目 / 小工具），我们大概率是不从事这方面的开发。<br/> 因为 能要你的公司，它肯定是能赚到钱的。<br/> 赚不到钱，人家招你干嘛？赔钱嘛。。。<br/> 工作之后，不管是 做 哪一种 PC 开发，都是要连接数据库的。<br/> 只要是用到了 数据库的，那一定是前后端分离的。<br/> 所以说：我们提供的就是 后端程序。<br/> 那后端程序是基于什么协议呢？》》》 HTTP协议<br/> 所以说，<a href=\"https://blog.csdn.net/DarkAndGrey/article/details/124752822?spm=1001.2014.3001.5501\">HTTP协议</a> 需要使用什么框架？<br/> 一定 web（Spring MVC） 框架嘛！</font><br/>  </font><br/> 手机项目也是一样，拿着手机去刷抖音，看头条。。。<br/> 这些内容都是来自于数据库的。<br/> 数据库，这个东西实在我们手机上存的吗？很显然，不现实！<br/> 数据库，这东西一定是存储在服务器端的。<br/> 而服务器端是水提供的？<br/> 是 手机开发工程师，他自己做后端开发吗？<br/> 肯定不做啊！手机开发工程师 做的是 PC时代的前端（做网页的）。<br/> 很早以前，PC 的前端是做网页的。<br/> 现在，PC 的前端是 做 APP的，就是说现在的网页，已经不是一个简简单单 HTML 页面，而是可以视为是一个 APP，具有很多复杂的功能。<br/> 但是，后端一定是调用 服务接口，而 服务接口 大部分调用额是 HTTP协议。HTTP 协议 就需要用到 Spring MVC 框架，因为它底层就是针对 Servlet 封装的。<br/> 因此 它 一定是一个 web 项目。<br/>  <br/> 由此可知，我们到公司之后，大部分项目，大约 99% 都是 Spring MVC 项目。<br/> 那么，你觉得 Spring MVC 重不重要呢？ 非常重要！！！！<br/>  <br/> <font color=\"red\">这里简洁的说一下：APP 项目也可以分为两种。<br/> 1、基于 iOS 开发，最早使用 ObjectC，但是写法极其恶心。<br/> 所以，苹果公司，在后面又推出了 自己的语言 Swift。<br/>  <br/> 2、安卓开发，最早是基于 Java 开发，但是现在 谷歌 被 Oracle 给搞了。<br/> 所以，自己 和 idea 的公司合作，做了一门新语言 Dart。<br/> 但是！底层也还是 基于 JVM 的。<br/> 与 java 编译生成的 字节码文件，可以视为是一样的。<br/> 而且，Dart 与 Java 是非常相似的！<br/> 可以说：这门语言就是为了 堵住 Oracle 的 “嘴”。<br/>  <br/> 但是呢，现在APP发展的趋势，趋近两者的混合开发。<br/> 就是 苹果 和 安卓 手机，都能安装这个 APP。<br/> 关于 混合开发，已经是陈年旧事了。<br/> 最早推出的 是 Facebook 的 React Native。<br/> 也是属于 门面模式的一种实现。<br/> 你可以写 React Native 自己的语法，在项目打包的时候，它有一个选择平台的功能。<br/> 根据 我们写的代码，去生成 IOS 的 代码，或者是安卓 的 代码。<br/> 不同的平台，我给你生成不同的代码，就行了。<br/>  </font><br/> 因此，移动端开发组 是很头疼的，做一个 APP，需要分2组（IOS，安卓）。<br/> 那么问题来了：一个组里是有一个 leader 的。<br/> 那么，对于 这个 leader 来说：他需要对这两种开发方式 精通！！<br/> 这对leader的压力，就非常大了！！！！</p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">回过头，我们在创建 Spring Boot 项⽬时，我们勾选的 Spring Web 框架其实就是 Spring MVC 框架，如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\029bee6c6dd241bcbc0416c5260bcf47.png\"/><br/> 从宏观来说：<br/> 即使 Spring Boot 添加 Spring Web 框架，也可以说它是一个 Spring 项目，或者是 Spring Web 和 Spring MVC 项目，都可以！不算错！<br/> 从微观来说：<br/> Spring MVC 项目，是基于 Spring Boot 框架 所实现的。</font></p>\n<blockquote>\n<p>简单来说，咱们之所以要学习 Spring MVC 是因为它是⼀切项⽬的基础，我们以后创建的所有 Spring、Spring Boot 项⽬基本都是基于 Spring MVC 的。</p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"Spring_MVC__156\"></a>Spring MVC 项目的创建</h1>\n<blockquote>\n<p><font size=\"4\">Spring MVC 项⽬创建和 Spring Boot 创建项⽬相同（Spring MVC 使⽤ Spring Boot 的⽅式创建），在创建的时候选择 Spring Web 就相当于创建了 Spring MVC 的项⽬<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3a4ce77cc1824f7b8f6ba462f1caa18c.png\"/><br/> 删除几个不常用文件。（可不删，根据实际情况决定）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9a071aca94254d81809c9f7f03d574e3.png\"/></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"_Spring_MVC___165\"></a>学习 Spring MVC 的 三个目标</h1>\n<blockquote>\n<p><font size=\"4\">学习 Spring MVC 我们只需要掌握以下 3 个功能：</font></p>\n<blockquote>\n<p><font color=\"red\" size=\"3\">1、 连接的功能：将⽤户（浏览器）和 Java 程序连接起来，也就是访问⼀个地址能够调⽤到我们的Spring 程序。<br/> 2、 获取参数的功能：⽤户访问的时候会带⼀些参数，在程序中要想办法获取到参数。<br/> 3、输出数据的功能：执⾏了业务逻辑之后，要把程序执⾏的结果返回给⽤户。<br/> 对于 Spring MVC 来说，掌握了以上 3 个功能就相当于掌握了 Spring MVC</font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"Spring_MVC_____174\"></a>Spring MVC项目的连接(用户 和 程序 的 映射)</h1>\n<p> </p>\n<h2><a id=\"1RequestMappingxx_176\"></a>方法1：@RequestMapping(“/xx”)</h2>\n<blockquote>\n<p><font size=\"4\">在 Spring MVC 中使⽤ @RequestMapping 来实现 URL 路由映射.</font></p>\n<blockquote>\n<p>这个我在讲 Spring Boot 知识的时候，已经用过了。<br/> 这里，我们再来稳固一下。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\053d81f0571d4778887de49b641eab31.png\"/><br/> 这里徐亚提醒的是： 一级路径，通常是为了辅助 二级路径。<br/> 因为一个项目，需要访问的东西有很多。<br/> 不可能全写在一个类里面，而且类也很多<br/> 为了避免混淆，所以通过这样的方式，来锁定要访问的类中方法。</p>\n</blockquote>\n<p><font size=\"4\">在这里，我再 给你们加强一下记忆。</font></p>\n<blockquote>\n<p><font color=\"red\">@ResponseBody注解<br/> 1、放在方法上，表示该方法返回的数据，只是一个普通的数据，而非一个静态页面。<br/> 2、放在类上，表示该类中所有的方法返回的数据，都是一个普通的数据，而非静态页面。<br/> 3、如果未加上这个注解，在我们访问方法的时候，默认就会去寻找一个名称叫做 Hello World！的页面，它发现找不到之后，就会报错。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\febb64b56dfb40bc88cae50015075f48.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">问题来了：为什么默认情况下，返回的是一个静态页面呢？</font></p>\n<blockquote>\n<p>请思考一个问题：<br/> Spring MVC 是随着 Spring 诞生，而创建的。<br/> Spring 是 2002 年 诞生的，也就是说 2003 年就有了 Spring MVC 了。<br/> 20年前，我们才刚出生不久，或者没出生。<br/> <font color=\"red\">20年前，前后端分离吗？<br/> 没有！！！<br/> 09 ~ 10 年的时候，才是前后端分离，逐渐普及的时间。<br/> 也就是在那个时间，有些公司使用了 前后端分离，有些公司没有 前后端分离。<br/> 直到 14 年 的时候，形式就一边倒了，全部支持前后端分离了。<br/> </font><br/> 这就原因所在，Spring MVC 在诞生之初，还没有前后端分离的概念。<br/> 作为一个 Java 程序员，既要写 后端代码，还要去写前端的页面。<br/> 那个时候，模板用的非常多！！<br/> 那时候是没有前后端工程师的，只要有一个 Java 工程师，就够了。<br/> 最多，在配置一个美工（设计）就OK了。<br/> 所以，那个时候，不用多想，我肯定是返回的一个页面。<br/> <font color=\"red\">为什么默认返回一个静态页面，就是一个历史遗留问题。<br/> 到今天，格局全然不同！<br/> 前后端已经分离，再去返回一个静态页面，肯定是不行的，<br/> 但是！又不能舍弃 这个设置。<br/> 因为，前面开发的项目，你不能说 不要 就 不要啊！！<br/> 那都是钱砸出来的。<br/> 因此，保留这个机制，是为了以前的代码还可以用。<br/> 而 添加 @ResponseBody，即实现了前后端分离。又能保存以前返回页面的机制。<br/> 这样就实现 项目 与 时代的兼容！</font></p>\n</blockquote>\n<p><font size=\"4\">虽然不用返回宇哥界面了，但还是要写两个注解，稍微有点麻烦。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3e61b09381024b6aad260114faf8d469.png\"/><br/> <font color=\"red\">我们还要更简单的写法、是一个组合注解。<br/> 现在暂时放放，后面再讲。<br/>  <br/> 先继续深入了解 @RequestMapping。</font></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"RequestMapping__post__get__228\"></a>@RequestMapping 是 post 还是 get 请求？</h3>\n<blockquote>\n<p><font color=\"red\" size=\"4\">@RequestMapping 默认是 get ⽅式的请求。<br/> 这一点其实在 浏览器通过 URL 访问方法的时候，就已经证明了这一点。</font></p>\n<blockquote>\n<p>通过 直接向浏览器的地址栏输入URL，默认生成 get 请求。<br/> 不相信，可以使用postman 来验证。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6c011ef2aad342b3b9faaa4c021d41c6.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">那么，@RequestMapping 支持 POST 方法吗？<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f93f4b64e9184ea49e560d13bb30207d.png\"/><br/> 答案：@RequestMapping，不仅支持 GET 方法，还支持 POST 方法的！</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"___240\"></a>总结 &amp;&amp; 拓展</h3>\n<blockquote>\n<p><font color=\"red\" size=\"4\">@RequestMapping 特征：<br/> 1、既能修饰类（可选），也能修饰方法。<br/> 2、默认情况下，@RequestMapping 既支持POST 方法，也支持 GET 请求方法。</font></p>\n<blockquote>\n<p>但是问题来了：如果公司制定只能使用 POST 方法，不能使用 GET 方法。<br/> 这种公司是存在的，目的就是为了方便管理 。<br/>  <br/> 像 @RequestMapping 这种 两种都支持，就还好。<br/> 但是，有些接口只支持 一种 方法 的请求，可能是 POST，也可能是 GET，这都说不准。<br/> 主要看实际情况。<br/> 但是，这就会造成一个项目中，既有支持 get，又有支持post 的方法。<br/> 这就会导致一个问题：<br/> 每个人对代码的理解是不一样的。这就会增加程序员（前后端都包括）的负担。<br/> 因为 在看每个接口在进行调用的时候，他要去看 说明文档，然后，才能确定你当前这个接口是支持 GET，还是POST的 。<br/> <font color=\"red\"> 一些公司指定使用 一种 方法，就是为了避免这种情况。<br/> 程序不用去思考使用那种方法来写代码，直接按照公司的要求来。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">那么，我的问题就是：能不能让 @RequestMapping 只支持一种方法。</font></p>\n<blockquote>\n<p><font color=\"blue\" size=\"3\">答案是可以的！<br/> 通过设置属性值，就可以做到！！！<br/> 这个属性叫做 method<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\af2c3a2108e342e5baf98dea4df55c77.png\"/><br/> <font color=\"red\">需要注意的是：@RequestMapping 直接给路由参数，默认就是给 value 属性赋值，前面只是我偷油了。。</font></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">还有一个细节：<br/> 类上的 RequestMapping 的路由参数，可以省略 / 的。<br/> （虽然可以不加，但是还是建议加，2个字规范。）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c92ce2ae4fcf46319c93352695b60c53.png\"/></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"2___3GetMapping__PostMapping_270\"></a>方法2 和 方法 3：@GetMapping 和 PostMapping</h2>\n<blockquote>\n<p><font size=\"4\">你想的没有错，就是@RequestMapping 分解出来的 两个注解。<br/> 意思很直白，你们应该是能懂的。<br/> @GetMapping ：只支持 Get 方法</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\56583b2908934c9783e6651ec1da1287.png\"/></p>\n</blockquote>\n<p><font size=\"4\">@PostMapping：只支持 Post 方法。</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\46d19e9891b74c8e838998f191908700.png\"/></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"_280\"></a>获取用户请求参数</h1>\n<h2><a id=\"_281\"></a>传递单个参数</h2>\n<blockquote>\n<p><font color=\"red\" size=\"4\">在 Spring MVC 中可以直接⽤⽅法中的参数来实现传参.</font></p>\n<blockquote>\n<p>在传递单个参数的时候，最常传递的参数是 id。<br/> 因为 id 通常是通过 primary key’（主键）来设置的，具有唯一性。<br/> 有助于我们获取到唯一的数据。<br/> <font color=\"red\"> 这里我们不去访问数据，直接通过访问方法来演示一下就行，<br/> 主要是了解用法<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ad13bdb241bf4a0c8d57d84d7b6164e1.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">上述这种方式，只要 获取的参数名称，与前端传输的参数名称一致，就能获取到对应的参数值。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b5a4cff1c2ea4369ab8c40cce23dd5df.png\"/><br/> 如果 前端参数名称 和 映射方法的参数名称，不一样。<br/> 不但获取不到，还会报错！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\927421de574c47239762ae19f3050c11.png\"/></font></p>\n<blockquote>\n<p>图中说到 映射方法的参数类型，不能使用基本数据类型。<br/> 虽然正常情况下，代码运行没问题，和 使用 包装类 的效果一样。<br/> 但是像遇到上述这种特殊问题（前端传输参数名称 和 映射方法名称 不相符），代码就会报错。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6cce82f4af5649deaf90a32c57ccaa8c.png\"/></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"___301\"></a>获取多个参数 / 表单参数传递（非对象）</h2>\n<blockquote>\n<p><font size=\"4\">我们简单实现 回显服务。<br/> 传递什么参数，就返回什么参数。</font></p>\n<blockquote>\n<p><font color=\"red\">方法还是一样的，只要 前端传递的参数名称 和 后端映射方法参数名称相同，就能够获取一个，甚至多个参数。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a037490204a24635b3ab4bec804ca26f.png\"/><br/> 如果你看这个 URL 有点懵，建议你还是先去看看 我的 <a href=\"https://blog.csdn.net/DarkAndGrey/article/details/124752822?spm=1001.2014.3001.5501\">HTTP协议的文章</a>，再来看这个。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">但是目前这个代码存在很大的问题，就是参数一旦增加。<br/> 我们就得手动去添加，还可能漏掉某个参数，<br/> 而且，维护的时候，也很难看清楚代码，参数太多了！维护性极低。<br/>  <br/> 那么，我们该怎么去处理呢？<br/> 接着往下看！</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"___317\"></a>获取多个参数 / 获取对象</h2>\n<blockquote>\n<p><font size=\"4\">获取对象，那就很简单了！！！<br/> 映射方法 只需要 一个 对象参数 就行了。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2392bd0fa38643fb921d5d91bcbab700.png\"/><br/> <font color=\"red\">获取对象参数的重点，还是在 前端传参的时候，参数名称 要与 对象中的属性名称相对应，Spring MVC 就会自动 对 对象的属性 进行赋值。<br/> 如果名称不匹配，那么，这个参数传输的毫无意义。</font></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"_326\"></a>拓展</h1>\n<h2><a id=\"RequestParam_327\"></a>后端参数重命名（后端参数映射：@RequestParam）</h2>\n<blockquote>\n<p><font size=\"4\">跟给 Bean 对象重命名 是一样的意思。<br/> 就是给 参数 改个名字。</font></p>\n<blockquote>\n<p><font color=\"red\" size=\"3\">某些特殊的情况下，前端传递的参数 key 和我们后端接收的 key 可以不⼀致！<br/>  <br/> ⽐如前端传递了⼀个time 给后端，⽽后端⼜是由 createtime 字段来接收的，这样就会出现参数接收不到的情况.<br/> 如果出现这种情况，我们就可以使⽤ @RequestParam 来重命名前后端的参数值。<br/> </font><br/> 特殊情况，比如：<br/> 在将来的某一天，公司晚上突然加班，需要紧急添加一个需求。<br/> 更重要的是：产品明天就要上线了。<br/> 紧急加班嘛，代码就写的有点“粗”。<br/> 前后端，并没沟通好。<br/> 假设，做的一个登录功能的扩展<br/> 然后，产品是凌晨 2点上线的。<br/> <font color=\"red\">代码也就没有经过严格的测试。<br/> 因为 测试可能都下班，都是研发人员 去硬怼的。<br/>  <br/> 第二天用的时候，运维发现了问题，通知 开发 / 测试 人员，某某功能有问题。<br/> 比如：无论用户怎么输入，一直提示填写用户名。<br/>  <br/> 最终，排查出的问题：<br/> 前端在传输参数的时候，参数名字 叫做 name，而后端参数是叫做 username。<br/> 这样就会导致一直拿不到 用户名的值。<br/> <font color=\"blue\">这个时候，我们有两种解决方案。<br/> 1、让后端的代码适应前端的代码，修改映射方法的参数名称（username &gt;&gt; name）。<br/> 但是一个问题也随之而来。<br/> 就是啊，这个 username 已经在映射方法中，使用了很多次了。<br/> 这一改，方法中的代码全都得动！<br/> 而且存在漏改的风险！<br/>  <br/> 2、让前端的代码，适应后端的代码。<br/> 让前端传回的参数 name &gt;&gt; username<br/> 这也会存在一个问题，像这种做完一个大项目的时候。<br/> 前端的人都休假，回到家直接关手机睡觉了。<br/> 但是这个bug 又很紧急！<br/> </font></font><br/> 总结：前端失联，后端不想改。</p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">这个时候，就可以使用 后端参数重命名了。</font></p>\n<blockquote>\n<p><font color=\"blue\">后端参数重命名，就是把前端传过来的参数名称，进行转移赋值。<br/>  <br/> 就是说：前端参数名称不变，还是name；后端接收到之后，将其参数名称的数值，赋值到 后端的 username 参数上。<br/> 此时，对于 后端来说，前端的 name，就是 username 了。<br/> 因为两者的value 值，都是一样的。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">具体的实现方法，还是通过注解的方式来解决。<br/> 使用 @RequestParam 注解，就可以搞定了。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\57013d7322a44a05ba7dff3de48cc349.png\"/><br/> 这里有一个细节：<br/> 如果这个重命名操作的属性，是对象里面的，就不能这么去用！！！</font></p>\n<blockquote>\n<p><font size=\"4\">上面的那个 username ，并不是 UserInfo 中的属性，只是一个普通的 字符串变量名.<br/> 我都没将 UserInfo 类注入到Spring 中，更别提获取到类中的属性。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2b75855671be42eeac892f052f4f5fed.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">虽然也有方法可以处理这种情况，但不是这个注解，是另一个。<br/> （后面在 讲 MyBatis 的时候，会说这个）<br/>  <br/> 但如果映射方法的参数是一个对象，那就没办法了。<br/> 这个你就只能和前端交流了，让他配合你的操作。<br/> 将 前端参数名称 修改成 和 后端对象中的属性名称 一样。<br/> 或者你配合他的代码。。。。<br/> 将类中的属性名修改成 和 前端参数一样的名称。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\db25105d0f424437b9f859057ef3d874.png\"/><br/> 总之，看谁能说服谁。。。总会有一方妥协的。</font></p>\n<blockquote>\n<p>口才，对于开发人员，也是非常重要的。<br/> 开发人员，不仅要和 产品经理 据理力争，还要和前端讲道理，讲配合。<br/> 测试，也同样需要沟通。<br/> 有时候他认为这是一个bug，然而并不是，或者说不重要。<br/> 因为压根就不会出现这种情况，没人会这样去使用软件。<br/> 因此这个bug等同于虚设。</p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"RequestParam__required_400\"></a>@RequestParam 的进一步理解: required属性</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\faa8db2ee93141faa1ef12a9e75b2764.png\"/></p>\n<hr/>\n<p> </p>\n<h1><a id=\"_404\"></a>表单参数传递（对象）</h1>\n<blockquote>\n<p><font color=\"red\" size=\"4\">表单传递对象参数，还是一样的。<br/> 接受对象参数时，前端参数该怎么传，就这么传。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\aabe13b62baa48039a2a8abad329121a.png\"/><br/> 上面是一个 get 方法的请求。<br/>  <br/> 下面我们来通过 postman 构造一个 post 方法的 表单请求<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\70e2be8fc3d5404998281200280346e3.png\"/><br/> 总的来说，没有难点。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"RequestBody_JSON___415\"></a>@RequestBody 接收JSON对象 - 特殊</h1>\n<blockquote>\n<p><font color=\"red\" size=\"4\">有的人看到这个，感觉so easy！<br/> 既然 JSON 也是一个对象，这跟上面没有区别嘛。<br/> 还是一样的，前端直接传输一个 JSON 对象，映射方法这边还是使用一个对象去接收。<br/> 下面，我就来验证一下，程序能不能接收一个 JSON 对象的数据？<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\13913685a9f4478f8436d0528a2fdb9d.png\"/><br/> 通过获取普通对象的方法，来获取一个 json 格式的对象参数。显然是不行的！</font></p>\n<blockquote>\n<p><font color=\"blue\">由此，不难得出结论:<br/> 只要不是 json 格式的数据，无论是 GET 还是 POST 方法的请求，都没有问题！<br/> 这一点在前面的例子中，就已经充分体现出来了。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">也就是说：想要通过接收 json 对象，需要通过其它的方法来实现。<br/> 当然还是注解，这个注解就是标题的 @ RequestBody 注解<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ce30e6c033914886b3b855877921bfb2.png\"/></font></p>\n<blockquote>\n<p><font color=\"blue\" size=\"3\">PS：注意！不要迷糊了！！！！<br/> 我们使用的 @RequestBody，不是 @ResponseBody。。。<br/> @ResponseBody： 表示返回的数据是一个非静态的页面。<br/>  <br/> 而 @RequestBody，是告诉 映射方法接下来接收到的数据是一个JSON 格式的数据。<br/> 方便对 JSON 数据，进行解析。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">结论：<br/> 服务器端想要实现 json 数据的接收，就需要使用 @RequestBody 注解。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"URLPathVariable___440\"></a>获取URL中参数@PathVariable - 特殊</h1>\n<blockquote>\n<p><font size=\"4\">这个就厉害了，它不满足于从 请求的正文 和 URL 中的查询字符串 中 获取参数了。<br/> <font color=\"red\"> 而是从 URL 中获取参数。</font></font></p>\n<blockquote>\n<p><font color=\"red\">注意！我的描述：<br/> @PathVariable注解，不满足从 请求的正文 和 URL 中的查询字符串（参数部分），获取 参数。<br/> 而是直接从 URL地址 中 获取参数。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c06aaa39f1ff4021bafee8b3dfd72b42.png\"/><br/> 不得不说：这种sao操作，作者也是第一次听闻。</font></p>\n</blockquote>\n<p><font size=\"4\">举个例子：DOTA 都知道吧？一个推塔游戏。</font></p>\n<blockquote>\n<p><font color=\"red\">比如，<br/> 我们现在想要获取到一个 英雄的信息。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e7fac8c20e594c8b8ad167b6be9806f6.png\"/><br/> 一般情况下，我们获取英雄信息的方式，都是同 URL 的 查询字符串部分来获取的。<br/> 如：http://data2.uuu9.com?heroname=影魔<br/>  <br/> 而通过 URL地址的方式来获取英雄信息：http://data2.uuu9.com / 66 / 影魔 /<br/> 假设 66 是它的 ID。<br/> 那么，通过以往的方式去获取这个英雄的信息，可以吗？<br/> 很明显，是不可以！！！！<br/> 我们前面所学的方法，就没有一个针对 URL地址部分的！</font></p>\n</blockquote>\n<p><font size=\"4\">那么问题来了，为什么有正常的方式不用，用这种非主流的方式来获取参数呢？</font></p>\n<blockquote>\n<p><font color=\"red\">这个就涉及到 SU（搜索引擎） 的优化。<br/> 什么是 SU 的优化呢？<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3af56d86866e44da851138b0e43c8ee5.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">需要注意的是：<br/> 使用 第二种形式的URL，也是存在 \" 缺点 \" 的！</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\94d20ebe4d3c4bc2ba38447f8a35a19e.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">不过 Spring MVC 又提供了一个新的注解 @PathVariable。</font></p>\n<blockquote>\n<p><font color=\"blue\">其实也很好理解：path variable == 路径变量。<br/>  <br/> 随之而来的是：路径肯定是存在两种形式的。<br/> 1、参数<br/> 2、路径<br/> 那我们该如何区分 那个是参数，那个是路径呢？<br/> <font color=\"red\">路径的写法不变，还是 “/xxx”<br/> 而参数的，就是在 / 后面，加上 大括号，将其后面的内容括起来： “/{xxx}”<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fa0263e75c2e453ea4b75418486a4580.png\"/><br/> <font size=\"3\">需要注意的一点：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6f1ccf337f2e4e67a5a27eb2e0889b1a.png\"/></font></font></font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"__RequestPart_485\"></a>上传文件 - @RequestPart</h1>\n<blockquote>\n<p><font size=\"4\"> 现在不是之前那种简单数据了，它可能是一个数据流。<br/> 它传过来的是一个 “流”。</font></p>\n<blockquote>\n<p>比如：<br/> 我们在进行用户注册的时候，要上传一个头像（图片）。<br/> 也就是说：上传的数据，就是这个图片的字节流。<br/> <font color=\"red\">类似于这种上传文件的形式，我应该怎么去获取呢？<br/> 通过 @RequestPart 注解，并将 文件名称 作为 参数放入其中，同时还需要借助 Spring 提供 MultipartFile对象。<br/> MultipartFile，就是专门用来接收文件的。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d98f9a604b3a4696b6638cfbd8f8d342.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">还没完，其实上述操作，还存在问题。</font></p>\n<blockquote>\n<p><font color=\"blue\">问题就出在 图片 和 存储路径，都被写死了。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\35d70e43c9514d208d8488092116ba3c.png\"/><br/> 我们再来想象一个场景。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ec79ecfd9f24424e8969c0191e4db927.png\"/><br/> <font size=\"3\">所以，不能这么去写！！！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\26e0fb5aa65644e594d7d268a3366a66.png\"/></font></font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"___505\"></a>拓展：不同平台运行的配置文件设置 - 优化存储目录</h2>\n<blockquote>\n<p><font color=\"red\" size=\"4\">首先，我们先来补充 关于<a href=\"https://blog.csdn.net/DarkAndGrey/article/details/125932854?spm=1001.2014.3001.5501\">日志文件</a>的知识补充。</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e4b0a389c6f840009acd90938c030d70.png\"/><br/> <font color=\"red\" size=\"4\">这样做的好处：<br/> 哪怕配置文件再多，我们也就只需要修改 主配置文件中的一个参数，就可以调用对应的配置文件了 。</font></p>\n</blockquote>\n<p><font color=\"blue\" size=\"4\">总结：<br/> 1、针对各个平台，创建专属的配置文件<br/> 2、配置文件的命名规则：application + 分隔符“ - ” + 平台名称（可简写） + .格式【必须这么去写 】<br/> 3、在主配置文件中设置 运行的配置文件。【spring.profiles.active】</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"____517\"></a>图片名称不能重复 &amp;&amp; 获取原图格式 问题</h2>\n<blockquote>\n<p><font color=\"red\" size=\"4\">先把 主配置文件中 的 参数 改成 develop （开发环境）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ae0a2502e7c64f629509cfff5cebd14e.png\"/><br/> 要不然识别不了，毕竟我们现在是在本地操作。</font></p>\n</blockquote>\n<blockquote>\n<p><font color=\"red\" size=\"4\">下面，我们先来解决 图片名称 问题。<br/> 第一种：时间戳</font></p>\n<blockquote>\n<p>通过 时间戳 来命名图片，是存在问题的。<br/> 其实 “巧合”，在互联网中是很常见的。<br/> 因此，很有可能就有那么几个人，同时，上传图片。<br/> 还是会造成 图片名称 的重复，导致 原先的图片被覆盖。<br/> 只是发生的概率要小一些。<br/> 因此，不可取的。<br/> 因为 它不适合用于 并发执行的情况。</p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">第二种：UUID（全局唯一标识符）</font></p>\n<blockquote>\n<p>UUID就不会从出现 时间戳的情况。<br/> UUID 会使用 你的网卡，随机数，等等，，，各种各样的信息来对 文件 进行命名。<br/> 在这种条件下，命名重复的概率，几乎不可能出现。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><font color=\"red\" size=\"4\"> 现在 存储路径的问题 搞定了，图片名称重复的问题 搞定了。<br/> 就剩下 获取 原上传图片 的 格式 了。</font></p>\n<blockquote>\n<p>其实 MultipartFile 对象中，提供了 一个 API（getOriginalFilename）。<br/> getOriginalFilename：获取原始的文件名称<br/> 名称里面都有什么？有文件后缀啊！<br/> 想办法截取文件后缀，不就可以了嘛。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><font color=\"red\" size=\"4\">问题都有了解决方案，接下来就是实施环节。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d2ef599a66d247409d49ee77e30fd4c6.png\"/><br/> 注意！我们通过取巧的方式，来做的。<br/> 其实 uid 来也可以进行操作。</font></p>\n<blockquote>\n<p>但是 局限性很强！<br/> 使用 uid 来 命名 图片，只能使用一次。【唯一性】<br/> 但是！可能还有其它图片，都是与用户相关的。<br/> 当然，你可以通过添加前缀的方式来实现。<br/>  <br/> <font color=\"red\"> 总的来说：还是更推荐使用 UUID 的方式，因为它更通用性更强。</font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"CookieSessionheader_558\"></a>获取Cookie/Session/header</h1>\n<blockquote>\n<p><font size=\"4\">这三个是比较特殊，在有些场合，才会用到，<br/> 其中 获取 Session 是比较常见的。</font></p>\n<blockquote>\n<p><font color=\"red\">这三项，通常都不是（使用的一方）用户 自动去上传的。<br/> 都是由 前端工程师，或者是由系统给我们上传的。<br/>  <br/> 比如说：<br/> Cookie，是浏览器自身去实现的。<br/> 它会在每一次请求中，都会把域名底下所有的 cookie 都带上。<br/> 这都属于 浏览器自身的行为。<br/> 当然，如果前端工程师愿意的话，他也可以 发送 cookie 给后端。<br/>  <br/> Session，也是一样。<br/> 也是前端的浏览器自动发送给后端的。<br/> 但是后端是需要获取到 Session 的。<br/> 毕竟，它用的比较多。<br/> 因为，用户在登录的时候，是需要通过 session 来验证用户信息的。<br/>  <br/> header，有些场景下，前端还会在 header 里面，设置自定义的header。<br/> 然后，传递到后端。<br/> 系统的header信息，有些时候，也是需要获取的。<br/> 至于为什么要获取 header，因为 header 里面有一个 userAge。<br/> userAge 里面就记录了当前访问用户的操作系统信息，以及他所使用的浏览器信息。<br/> 那我就可以每一次请求一个接口的时候，统计用户 的 浏览器 和 操作系统 的信息。<br/> 在拿到 用户 浏览器 和 操作系统的信息之后，方便对其进行分析。<br/> 根据 分析的结果，做一个排列，看看哪种浏览器的永辉最多，那个操作系统的用户最多。<br/> 来进行针对性处理和优化。<br/> 就是说：产品能够更好的兼容这些比较热门的操作系统 和 浏览器。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">总之，一句话：我可以不用，但是不能不会！<br/> 至少我是知道有这么几个东西的。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_Request__Response__591\"></a>知识铺垫：获取 Request 和 Response 对象</h2>\n<blockquote>\n<p><font size=\"4\"> 因为 Spring MVC 就是 基于 Servlet API 来实现的。<br/> 也就是说：Servlet 那一套 是 完全适用于 Spring MVC 的。</font></p>\n<blockquote>\n<p><font color=\"red\">在 Spring MVC 里面，每一个方法都有2个 “隐藏参数”、<br/> 【HttpServletRequest 和 HttpServletResponse】<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\07a1b49030874217ab5941d564f788ef.png\"/><br/> 下面我们就来验证一下功能。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c0e58f9b0086416399a3469fd99466aa.png\"/><br/> 根据结果，更加证明了 Spring MVC 是 支持 Servlet API 的。</font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_Cookie_602\"></a>获取 Cookie</h2>\n<blockquote>\n<p><font size=\"4\">获取 Cookie 的方式有两种：<br/> <font color=\"red\">1、基于 Servlet 提供 的 API 来获取 Cookie</font></font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c22c6c63ecc34512bc5e0ed9cea39d54.png\"/><br/> <font color=\"blue\" size=\"3\">虽然，方法是可以的.。<br/> 但是这种读取的方式，其实是有点“繁琐的”！<br/> 因为需要先获取 请求对象，通过对象提供的方法，来获取 所有的cookie。<br/> 而 繁琐，就体现在这一步！<br/> 通常情况，我们获取 cookie 数据的时候，不会全拿，只拿取其中的一个。<br/>  <br/> 由此，Spring MVC 提供一个新的注解，来往下看。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">2、简洁的获取 Cookie - @CookieValue</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4b3779cd88da45ca803cca79d4c96180.png\"/><br/> <font size=\"4\">这就很方便了！<br/> 想要那个 cookie 值，将其 cookieName 作为 @CookieValue 注解 的 参数，就能获取到对应的value值。<br/> 当然，你还需要准备一个 “参数” 来接收。</font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_header_623\"></a>获取 header（获取请求头中的信息）</h2>\n<blockquote>\n<p><font size=\"4\">获取 header 的 方法，也有两种：<br/> <font color=\"red\">1、 基于 Servlet API</font></font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f3f6bff36cb84c2fa8504c937614c077.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">2、简洁获取 Header—@RequestHeader</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7bd2f31835544db9a8d3b2d079965e37.png\"/><br/> <font color=\"blue\" size=\"3\">相比于 Servlet API，注解的方式，还是更简单一点的.</font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"___Session_633\"></a>存储 和 获取 Session</h2>\n<blockquote>\n<p><font size=\"4\">为什么 Session 多出一个 存储 的 操作呢？</font></p>\n<blockquote>\n<p><font color=\"red\">原因很简单！<br/> 就跟获取 cookie 的 时候一样！<br/> 你都没有 session，我还获取干什么？？<br/> 所以，才会多出这一步。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">更特别的是：关于 存储 操作，只能通过 servlet API。<br/> 因为存储操作，是没有办法用参数来表示的。</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fd8221991f854bff9c478c4c91c2bc58.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">读取操作，是有两种方法的。<br/> 1、servlet API</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7da85b79e508456987e04252e13f58df.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">2、更简洁的获取 session - 使用 注解 ：@SessionAttribute</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b0b958ae0d514948b4994c95f391e5c3.png\"/><br/> <font color=\"blue\" size=\"3\">至于为什么需要加上一个 required 属性，并置为 false！<br/> 这因为 在使用 注解 获取 session 对象的时候，没有判断句！<br/> 即：如果访问 getSession2 方法的时候，没有设置 session 会话，并且内置属性。<br/> 此时，它就直接报错！因为它找不到对应 key 值！<br/> 这是因为 @SessionAttribute 注解中，有required的属性。<br/> 这个前面在讲 @RequestParam 的时候，就讲了。<br/> 不会像 servlet 那样，返回一个 空值（页面什么都不显示）。<br/> 这个值，必须得有！！！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cf6302d0be0d4315987d5abd532ffdbd.png\"/><br/> <font color=\"red\">解决的方法，就是将 required 属性，置为false。<br/> 表示这个 key 值，并不是非要找到！<br/> 而是找不到就算了！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c083c941b5a445e0966a14038989ad57.png\"/></font></font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"_665\"></a>返回数据给前端</h1>\n<blockquote>\n<p><font size=\"4\">通过上⾯的学习我们知道，默认请求下⽆论是 Spring MVC 或者是 Spring Boot 返回的是视图（xxx.html），<font color=\"red\">⽽现在都是前后端分离的，后端只需要返给给前端数据即可，这个时候我们就需要使⽤@ResponseBody 注解了。</font></font></p>\n<blockquote>\n<p><font color=\"blue\" size=\"3\">这我们已经在前面演示了。<br/> 这里再稳固一下。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dc2d89985a6642a594e82da0bae60410.png\"/><br/> 当我们加上 @ResponseBody 注解的时候，它认为我们返回的是一个非静态页面数据。<br/> 它就会直接显示。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ae18c76ac09c406eb0f91ba88f459a5d.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">既可以修饰类，也可以修饰方法。<br/> 修饰类，表示 类中所有的方法的返回值，都是一个非静态页面的数据。<br/> 修饰方法，表示 该方法的返回值，是一个非静态页面的数据。<br/>  <br/> 但是，还是有点麻烦。。<br/> 毕竟，还是需要写两个注解。<br/>  <br/> </font><font color=\"blue\" size=\"4\">于是，Spring MVC 又提供了一个新的注解。<br/> 结合了 @Controller 和 @ResponseBody，两者之间的功能。<br/> 这个新的组合注解叫做 @RestController</font></p>\n<blockquote>\n<p><font size=\"3\"> 简单来说：可以将 @RestController 理解为是 HTTP 的 controller 类注解。<br/> <img alt=\" \" src=\"..\\..\\static\\image\\1e8d2c8583e847568cb7cc2d5a483ba9.png\"/><br/> 这是目前主流的使用注解。<br/>  <br/> <font color=\"red\">那么，什么@RestController 能够代替两个注解的工作呢？<br/> 这四因为 @RestController 里面实现了这两个 注解。<br/> 【按住 Ctrl，左键点击 RestController，就可以进入源码。】<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\28baf2f557674266b2ca8c2a97656cc0.png\"/></font></font></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"_694\"></a>练习</h1>\n<h2><a id=\"___form__695\"></a>实现计算器功能 - form 表单</h2>\n<blockquote>\n<p><font size=\"4\">可使⽤ postman 传递参数，或使⽤ form 表单的⽅式提交参数。<br/> 前端⻚⾯代码：</font></p>\n</blockquote>\n<pre><code class=\"prism language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">doctype</span> <span class=\"token name\">html</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>width=device-width, user-scalable=no, initialscale=1.0, maximum-scale=1.0, minimum-scale=1.0<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>X-UA-Compatible<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ie=edge<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">&gt;</span></span>计算器示例<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span> <span class=\"token attr-name\">action</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/calc<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">&gt;</span></span>计算器<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">&gt;</span></span>\n    数字1：<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>num1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span><span class=\"token punctuation\">&gt;</span></span>\n    数字2：<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>num2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span> 点击相加 <span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre>\n<blockquote>\n<p><font size=\"4\">代码，我已经给你了，下面来跟着我的脚步来看具体的实现步骤。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cbed6fbd67004469a0f26edd170c305b.png\"/><br/> <font color=\"red\">是不是非常简单？！<br/> 我们不用再去 写一些获取参数的操作了，直接当成一个普通方法来处理.<br/> 需要强调的是：参数名称 要与前端传输的参数名称 一致，<br/> 不一样也行，使用 @RequestParam 来进行重命名操作，记得将 required 属性置为 false。<br/>  <br/> 另外，方法的参数，需要使用包装类。<br/> 如果使用 基础数据类型来接收前端参数，如果前端返回一个 null，就会 数值 与 类型不匹配。<br/> 还有，因为使用 包装类，所以允许前端返回一个 null 值。<br/> 因此，我们需要做一步 校验（验证 数据是否非空），避免造成空指针异常。<br/> 所以，我们再稍微修改一下代码。</font></font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\520eefb5debb40439035a59cbdb7ff08.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">此时，计算器的功能，才算真正完成了！</font></p>\n<blockquote>\n<p>这里，我们还可做一个业务优化。<br/> 在显示结果的页面，设置一个返回键。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\39c496eefd3744b48d211a722bc65780.png\"/></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_Spring_MVC____741\"></a>拓展： Spring MVC 的 热部署 设置</h2>\n<blockquote>\n<p><font size=\"4\">在经过上述的学习，我们不难发现：每次修改代码之后，都需要重启 项目。<br/> 这就麻烦！这里我们就可以通过设置热部署来解法双手。</font></p>\n<blockquote>\n<p><font color=\"red\">在这里需要明白一件事：<br/> 为什么需要重启项目，我们的效果才是根据最新的代码来呈现的。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1d40206d72e488eb856fb7e6e4620d8.png\"/></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">因此，作为一个“合格”的程序员，怎么可以让自己那么累呢！<br/> 当然是 配置热部署。让它 “实时更新” target 目录中的内容。</font></p>\n<blockquote>\n<p>“实时更新”：修改完代码之后，大概在 3 ~ 4 s 之后，才会热部署完成。<br/> 即：自动更新了 target 中的内容（实际上，自动生成了一个新的target。将原来的覆盖，所以才会那么耗时！）<br/>  <br/> <font color=\"red\">热部署的运行原理：<br/> 它会检测 当前源代码中，有没有发生改动？<br/> 如果改动了，热部署 就会拿到一个 改动事件。<br/> 在拿到源代码改动事件之后，它会自动帮我们重启项目。<br/>  <br/> 虽然，还是通过重启项目的方式，来让改动的代码生效。<br/> 但是！我们不需要再去手动点击重启了！<br/>  <br/> 自动重启项目消耗的时间，前面也说了。<br/> 大概 3~4 s 的样子，热部署就完成了。<br/> 此时，你再去访问，看到的效果，就是最新的了。</font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">下面，我们就来配置热部署。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"1_768\"></a>1.添加热部署框架⽀持</h3>\n<blockquote>\n<p><font size=\"4\">在 pom.xml 中添加如下框架引⽤：<br/> <font color=\"red\">PS: 一般我们在创建 Spring Boot（Spring MVC） 项目的时候，就已经添加了这个框架。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\593f1ace4d0945f2bfab8c00b054c6eb.png\"/><br/> 如果你忘记加了，或者是一个老项目，也不要紧。<br/> 前面在讲 <a href=\"https://blog.csdn.net/DarkAndGrey/article/details/125932854?spm=1001.2014.3001.5501\">日志文件</a> 添加 lombok 依赖的时候，给你们介绍了一款插件 Edit Starters<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5b75be5a0e0c45e3bf054999f8af273f.png\"/><br/> 可以快捷插入所需的框架支持。<br/> 这个我就不多讲，如果你没装，你就先去看这个部分。<br/> 看完，你就知道怎么操作了。</font></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"2Settings__780\"></a>2、Settings 开启项⽬⾃动编译</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\011220c59c1c41b6a607ba3ed85d6322.png\"/></p>\n<hr/>\n<p> </p>\n<h3><a id=\"3_784\"></a>3.开启运⾏中热部署</h3>\n<blockquote>\n<p><font size=\"4\">刚才开启的是 idea 的热部署。<br/> 和 程序运行热部署设置没关系。<br/> <font color=\"red\" size=\"4\">设置情况分为两种。</font></font></p>\n<p><font color=\"red\" size=\"4\">1、低版本 Idea 设置（IntelliJ IDEA 2021.2 之前的版本）</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\894cf05a1ded4992a602ead57951cab5.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">2、⾼版本 Idea 设置（IntelliJ IDEA 2021.2 之后版本）</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ac5c8419946842d3b232c82a860d51ac.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">经过上述操作，我们的热部署就完成了。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"4_Debug_Run_798\"></a>4.使⽤ Debug 启动项目（⾮Run）</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\678ab4c19a254380a1a61f15e56c1319.png\"/></p>\n<blockquote>\n<p><font color=\"red\" size=\"4\">这是因为有些人的idea，即使前面三步都完成了，热部署仍然无法生效。<br/> 使用 debug 运行项目，就不会存在这个问题。</font></p>\n<blockquote>\n<p>当然 你 使用 run ，热部署也能生效。<br/> 那就随便了。</p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"_807\"></a>效果展示</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5a0eb2d15b3b49a0a84edfa77dfda569.png\"/></p>\n<blockquote>\n<p><font size=\"4\">看到这个效果，说明热部署已经设置成功了，并且已经运行了。<br/> 以后，就不用我们去手动重启项目了。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_ajax_json__813\"></a>模拟登录功能，前端使⽤ ajax，后端返回 json 给前端。</h2>\n<h3><a id=\"_815\"></a>前端代码</h3>\n<blockquote>\n<p><font size=\"4\">知识铺垫：<a href=\"https://blog.csdn.net/DarkAndGrey/article/details/124548667?spm=1001.2014.3001.5501\">前端三剑客之 JavaScript</a><br/> ，<a href=\"https://blog.csdn.net/DarkAndGrey/article/details/124482318?spm=1001.2014.3001.5501\">前端三剑客之 CSS</a>，<a href=\"https://blog.csdn.net/DarkAndGrey/article/details/124390460?spm=1001.2014.3001.5501\">前端三剑客之 HTML </a></font></p>\n</blockquote>\n<pre><code class=\"prism language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">doctype</span> <span class=\"token name\">html</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>width=device-width, user-scalable=no, initialscale=1.0, maximum-scale=1.0, minimum-scale=1.0<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>X-UA-Compatible<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ie=edge<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>js/jquery-1.9.1.min.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">&gt;</span></span>Document<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token script\"><span class=\"token language-javascript\">\n        <span class=\"token comment\">// ajax 提交</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">mysub</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">//1、判空</span>\n            <span class=\"token comment\">// 输入框中的值</span>\n            <span class=\"token keyword\">let</span> username <span class=\"token operator\">=</span>  <span class=\"token function\">jQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#username'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">let</span> password <span class=\"token operator\">=</span> <span class=\"token function\">jQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#password'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// jQuery.trim 去空格</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"请输入用户名！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"请输入密码！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token comment\">// 请求使用方法</span>\n                <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">,</span>\n                <span class=\"token comment\">//  映射方法路径</span>\n                <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'/user/login2'</span><span class=\"token punctuation\">,</span>\n                <span class=\"token comment\">// 请求正文</span>\n                <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token string-property property\">\"username\"</span><span class=\"token operator\">:</span> username<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string-property property\">\"password\"</span><span class=\"token operator\">:</span> password<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token comment\">// 除了 服务器范湖的结果</span>\n                <span class=\"token function-variable function\">success</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    </span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value css language-css\"><span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">&gt;</span></span>登录<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">&gt;</span></span>\n    ⽤户：<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>username<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span><span class=\"token punctuation\">&gt;</span></span>\n    密码：<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>password<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>password<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>button<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span> 提交 <span class=\"token punctuation\">\"</span></span> <span class=\"token special-attr\"><span class=\"token attr-name\">onclick</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token function\">mysub</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token punctuation\">\"</span></span></span>\n           <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value css language-css\"><span class=\"token property\">margin-top</span><span class=\"token punctuation\">:</span> 20px<span class=\"token punctuation\">;</span><span class=\"token property\">margin-left</span><span class=\"token punctuation\">:</span> 50px<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre>\n<blockquote>\n<p><font color=\"red\" size=\"4\"> 将上述的代码，放入一个 HTML 文件中。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ce7496824e2040da80d624af2a4ac17e.png\"/><br/> 需要注意的是 ajax 是需要依赖于 jQuery 的。<br/> 所以我创建一个 js 包，用来存储 jQuery。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7106f65fe4844c6dad5beb0a35ff6ae1.png\"/></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h3><a id=\"_879\"></a>后端代码</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4af857a3d01e4266bbd882fa3ef794b6.png\"/></p>\n<hr/>\n<p> </p>\n<h3><a id=\"_884\"></a>效果图</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\956c44b599dd4d75908237d18e748e83.png\"/></p>\n<hr/>\n<p> </p>\n<h3><a id=\"json_888\"></a>小拓展：前端返回一个json数据，后端可以接收。</h3>\n<blockquote>\n<p><font size=\"4\">前面，我们是直接接收 参数的。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\77d21ba63d6c4c2287c6ded7ae7fe018.png\"/><br/> 前面也讲过，要想接收一个 JSON 数据，是需要借助 @RequestBody 注解的。<br/> 问题，就在于，前端如何构造一个 JSON 数据。（了解）</font></p>\n</blockquote>\n<blockquote>\n<p><font color=\"red\" size=\"4\">后端代码支持获取 JSON 格式的数据，前端整体不改，值修改访问路径。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3ee5bf02d707451caa8168f91cefe08c.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\83cc881ae34d4813ab62cdba1fc82d73.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d16a2cb5eb7f4809b9f612b0a963b213.png\"/><br/> 得出结论：<br/> 前后端的数据格式要匹配。<br/> 不然会报错！<br/> 回到最初的问题：<br/> 前端如果构造一个Json格式的数据。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1e7813e9f19406ba80e14085b230b41.png\"/><br/> 得出结论：<br/> 前端在构造 json 格式的数据的时候，不经要将返回的数据设置成 json格式的数据，并且返回值的类型也需要设置成 JSON 格式。<br/>  <br/> 而后端在接收 json 数据的时候，需要使用 @RequestBody 注解</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h1><a id=\"___911\"></a>请求转发或请求重定向 - 重点</h1>\n<h2><a id=\"forward_VS_redirect_912\"></a>forward VS redirect</h2>\n<blockquote>\n<p><font size=\"4\">return 不但可以返回⼀个视图，还可以实现跳转，跳转的⽅式有两种：<br/> <font color=\"red\">1、forward 是请求转发；<br/> 2、redirect：请求重定向。</font></font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"forward___918\"></a>forward 请求转发 实现</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f4ec649177124fe5b3e85c76d7132ad1.png\"/></p>\n<blockquote>\n<p><font color=\"red\" size=\"4\">当我们访问到 myForward 方法，执行到return 语句的时候。<br/> 请求转发，是 服务器端的一个行为。</font></p>\n<blockquote>\n<p>服务器端会访问这个页面，并且将页面的数据 返回给 客户端。<br/>  <br/> 这个就好比，我们在大学时期，我们想吃饭的时候，叫室友爸爸带饭一样。<br/> <font color=\"blue\">此时，我们就相当于是客户端，室友爸爸就是服务器。<br/> 食堂的饭菜，就是想要的网页数据。<br/> 当我们向室友爸爸提出带饭请求，室友爸爸接收到请求之后，他就会去访问食堂大妈。<br/> 获取 大妈手中的饭菜，将其带回给我们。<br/>  <br/> 简单来说：服务器端（室友）就是 一个中间商，客户端（我们）想要获取的数据（饭菜），并非来自服务器端自身。<br/> 只是说：不用我们（客户端）去打饭（获取数据），他（服务器端）会帮我们找到它，将它带回来给我们。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c189c11a18ae4464bf77f4adbe9ff53f.png\"/><br/> 由张图我们可以看出，对于 目标服务的数据，是共享的。<br/> 无论是谁访问，都可以访问该页面的数据。<br/>  </font><br/> 我们再来看看fiddler抓包的结果<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ee0cf50a9db94beeba6d44eff82089d2.png\"/></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">除了使用注解的方式来实现 请求转发，我们还可以基于 Servlet API 来实现请求转发。</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\beb08d6c214b46838c996d33a2990f71.png\"/><br/> <font size=\"4\">相比与注解，servlet 就比较麻烦了！<br/> servlet，先是要获取请求调度器，来获取转发资源，最后，通过 forward方法，将 请求获取的资源，写入 响应中。<br/>  <br/> 而 Spring MVC 直接一个键值对，就完事了。<br/>  </font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">其实最简单直接的方法，就是 通过 return 直接返回 页面。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e52e501fa18c4a7681deaafedda4ee72.png\"/><br/> 至于效果，我就不展示了。<br/> 前面已经玩过了。</font></p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"redirect__953\"></a>redirect：请求重定向 实现</h2>\n<blockquote>\n<p><font size=\"4\"> 请求重定向，也有两种实现方式。<br/> <font color=\"red\" size=\"4\">1、 注解方式<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\25793a25e935428188989a452914a821.png\"/></font></font></p>\n<blockquote>\n<p><font size=\"3\">通过上述操作，展示出来的效果。其实就已经体现出 转发 与 重定向的区别了。<br/> <font color=\"red\">转发，它的URL 是不会改变的；<br/> 重定向，URL地址变成了 访问页面的地址<br/> 这是其一。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\28d13afcdc3e4ae08a17e3c86bf299ac.png\"/><br/> 其二：<br/> 转发，浏览器只需要发送一条请求，就能获取到网页信息。<br/> 重定向，浏览器需要发送两条请求，才能获取网页信息。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\127767fd3d154b1691ff5290c0a66e2e.png\"/><br/>  <br/> 还是举那个例子：<br/> 我们代表客户端，室友弟弟代表服务器端，饭菜就是网页数据。<br/> 此时，我们像往常一样，向室友爸爸发送一个 带饭请求。<br/> 但是！他这个弟弟居然居然拒绝了，而且说是要去约会！！！<br/> 告诉我们，只能自己去食堂买饭了。（这就是第一个请求，返回的302响应）<br/> 那我们还能怎么办，当然弟弟的幸福重要。。。<br/> 于是我们只能自己去买饭了。（这就对应着第二个请求）<br/>  <br/> 简单来说：<br/> 重定向，是前端的一种行为。<br/> 直白来说：前端 向 后端索要数据，后端只告诉了它去哪里拿，前端需要自己去获取。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d70713871470441b912a3d00d7f7a7c5.png\"/><br/> 这就好比 问路，别人只告诉了我们怎么走，并不会领着我们去往目的地。<br/> 【PS：别人怕你套路他，你也怕别人套路你】<br/> <font color=\"blue\">需要注意的是：重定向，数据是不共享的。<br/> 就是我给你的地址，你能不能访问到数据，是不确定的。<br/> 万一，这份数据是需要权限的，但是你没有，那就访问不了了。<br/> 或者这网站，被注销了，你也是访问不了的！</font></font></font></p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">2、 Servlet API</font></p>\n<blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fe8beaee29354795b923fdcdf6a85d71.png\"/></p>\n</blockquote>\n</blockquote>\n<hr/>\n<p> </p>\n<h2><a id=\"_990\"></a>区别总结</h2>\n<blockquote>\n<p><font size=\"4\">forward 和 redirect 具体区别如下：<br/> <font color=\"red\">1、 请求重定向（redirect）将请求重新定位到资源；请求转发（forward）服务器端转发。</font></font></p>\n<blockquote>\n<p>直白来说：定义不同。<br/> 请求转发（Forward）：发生在服务端程序内部，当服务器端收到一个客户端的请求之后，会先将请求，转发给目标地址，再将目标地址返回的结果转发给客户端。<br/> 重定向：甩给你目标地址，其它事情与我无关。</p>\n</blockquote>\n<p> <br/> <font color=\"red\" size=\"4\">2、 请求重定向地址发⽣变化，请求转发地址不发⽣变化。<br/> 3、重定向浏览器会发送两条请求，转发，只有一条请求。<br/> 4、重定向，数据不共享；转发，数据共享。<br/>  <br/> <font color=\"red\" size=\"4\">5、 请求重定向与直接访问新地址效果一致，不存在原来的外部资源不能访问；请求转发服务器端转发有可能造成原外部资源不能访问。</font></font></p>\n<blockquote>\n<p>请求转发 forward 导致的问题:<br/> 请求转发如果资源和转发的⻚⾯不在⼀个⽬录下，会导致外部资源不可访问。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d00ceffa82c34968b5a75b6bf7ac20af.png\"/><br/> 我们写的这种，是相对路径。<br/> <font color=\"red\"> 如果访问的资源，分级（分包）存储。<br/> 此时，就需要根据当前路径做出改变。<br/> 保险的做法就是写绝对路径。<br/> 当然，相对路径写起来要简单一些。<br/> 看个人选择。<br/>  <br/> <font color=\"blue\">重定向，是直接给你目标访问的地址，它本身的地址并没有被改变。<br/> 而 转发，假设我们 实现请求转发的方法，是处于 一级路径，访问的源在 二级目录。<br/> 所以，它的地址发生了改变，从二级目录 变成 一级目录，<br/> 那么，一级目录中的相对资源就会丢失了。<br/> 这就是 请求转发存在的一个问题。<br/>  <br/> </font><br/> 这就跟借钱一样。<br/> 重定向：<br/> 张三 找李四 借钱，但李四确实没钱；<br/> 李四 告诉 张三，去王五那里看看。<br/> 张三接到了。<br/> 结果张三跑了。。。<br/> 这个时候，李四是不担责任了。<br/> 因为 钱 是张三借的。<br/>  <br/> 转发：<br/> 张三 找李四 借钱，但李四确实没钱；<br/> 李四 去找王五那里借了一些钱，然后，给了张三。<br/> 结果张三跑了。。。<br/> 王五找谁还？<br/> 肯定找李四啊！因为是 李四找他借的钱。<br/> 李四肯定是脱不了关系的！！！<br/> </font><br/> 请求转换，就存在这样的问题。<br/> 如果目录的层级是不一样的，那么它的相对地址也是不一样的。<br/> 此时，使用请求转发，就有可能出问题。</p>\n</blockquote>\n<p><font color=\"red\" size=\"4\">6、代码实现不同。</font></p>\n<blockquote>\n<p>这个很明显！<br/> 关键字都不一样，好吧！！！！<br/> 一个 forward（转发），一个 redirect（重定向）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c28b60d701394197a2b1b67d87b13781.png\"/></p>\n</blockquote>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-07-31 19:37:12", "summary": "文章目录什么是？定义和的关系总结为什么要学？项目的创建学习的三个目标项目的连接用户和程序的映射方法：是还是请求？总结拓展方法和方法：和获取用户请求参数传递单个参数获取多个参数表单参数传递非对象获取多个"}