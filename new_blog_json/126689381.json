{"blogid": "126689381", "writerAge": "码龄6年", "writerBlogNum": "18", "writerCollect": "440", "writerComment": "100", "writerFan": "1336", "writerGrade": "4级", "writerIntegral": "807", "writerName": "托马斯拉丁", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126689381.jpg", "writerRankTotal": "28028", "writerRankWeekly": "16831", "writerThumb": "397", "writerVisitNum": "54906", "blog_read_count": "715", "blog_time": "已于 2022-09-07 00:58:52 修改", "blog_title": "Python初级教程-廖雪峰Python教程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:80px;\"></p>\n<p id=\"main-toc-toc\" style=\"margin-left:80px;\"><a href=\"#main-toc\">demo1-输入输出</a></p>\n<p id=\"demo2-%E5%B8%83%E5%B0%94%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#demo2-%E5%B8%83%E5%B0%94%E5%8F%98%E9%87%8F\">demo2-布尔变量</a></p>\n<p id=\"demo3-%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#demo3-%E5%8F%98%E9%87%8F\">demo3-变量</a></p>\n<p id=\"demo4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#demo4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96\">demo4-字符串格式化</a></p>\n<p id=\"demo5-%E5%88%97%E8%A1%A8-toc\" style=\"margin-left:80px;\"><a href=\"#demo5-%E5%88%97%E8%A1%A8\">demo5-列表</a></p>\n<p id=\"demo6-%E5%85%83%E7%BB%84-toc\" style=\"margin-left:80px;\"><a href=\"#demo6-%E5%85%83%E7%BB%84\">demo6-元组</a></p>\n<p id=\"demo7-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#demo7-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%C2%A0\">demo7-条件判断 </a></p>\n<p id=\"demo8-for%E5%BE%AA%E7%8E%AF%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#demo8-for%E5%BE%AA%E7%8E%AF%C2%A0\">demo8-for循环 </a></p>\n<p id=\"demo9-%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88-toc\" style=\"margin-left:80px;\"><a href=\"#demo9-%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88\">demo9-字典与集合</a></p>\n<p id=\"demo10-%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\"><a href=\"#demo10-%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1\">demo10-可变对象与不可变对象</a></p>\n<p id=\"demo11-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo11-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0\">demo11-内置函数</a></p>\n<p id=\"demo12-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%B8%8Eisinstance-toc\" style=\"margin-left:80px;\"><a href=\"#demo12-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%B8%8Eisinstance\">demo12-定义函数与isinstance</a></p>\n<p id=\"demo13-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo13-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0\">demo13-默认参数</a></p>\n<p id=\"demo14-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\"><a href=\"#demo14-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1\">demo14-默认参数必须指向不可变对象</a></p>\n<p id=\"demo15-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo15-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\">demo15-可变参数</a></p>\n<p id=\"demo16-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E4%B8%8E%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo16-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E4%B8%8E%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0\">demo16-关键字参数与命名关键字参数</a></p>\n<p id=\"demo17-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F-toc\" style=\"margin-left:80px;\"><a href=\"#demo17-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F\">demo17-函数参数顺序</a></p>\n<p id=\"demo18-random%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo18-random%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0\">demo18-random常见函数</a></p>\n<p id=\"demo19-%E5%88%87%E7%89%87-toc\" style=\"margin-left:80px;\"><a href=\"#demo19-%E5%88%87%E7%89%87\">demo19-切片</a></p>\n<p id=\"demo20-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1Iterable-toc\" style=\"margin-left:80px;\"><a href=\"#demo20-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1Iterable\">demo20-可迭代对象Iterable</a></p>\n<p id=\"demo21-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#demo21-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F\">demo21-列表生成式</a></p>\n<p id=\"demo22-%E7%94%9F%E6%88%90%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#demo22-%E7%94%9F%E6%88%90%E5%99%A8\">demo22-生成器</a></p>\n<p id=\"demo23-%E8%BF%AD%E4%BB%A3%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#demo23-%E8%BF%AD%E4%BB%A3%E5%99%A8\">demo23-迭代器</a></p>\n<p id=\"demo24-map%E4%B8%8Ereduce%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo24-map%E4%B8%8Ereduce%E5%87%BD%E6%95%B0\">demo24-map与reduce函数</a></p>\n<p id=\"demo25-filter%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo25-filter%E5%87%BD%E6%95%B0\">demo25-filter函数</a></p>\n<p id=\"demo26-sorted%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo26-sorted%E5%87%BD%E6%95%B0\">demo26-sorted函数</a></p>\n<p id=\"demo27-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0lambda-toc\" style=\"margin-left:80px;\"><a href=\"#demo27-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0lambda\">demo27-匿名函数lambda</a></p>\n<p id=\"demo28-%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B-toc\" style=\"margin-left:80px;\"><a href=\"#demo28-%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B\">demo28-类和实例</a></p>\n<p id=\"demo29-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:80px;\"><a href=\"#demo29-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85\">demo29-数据封装</a></p>\n<p id=\"demo30-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6-toc\" style=\"margin-left:80px;\"><a href=\"#demo30-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6\">demo30-访问限制</a></p>\n<p id=\"demo31-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:80px;\"><a href=\"#demo31-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81\">demo31-继承与多态</a></p>\n<p id=\"demo32-%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:80px;\"><a href=\"#demo32-%E5%AD%97%E7%AC%A6%E4%B8%B2\">demo32-字符串</a></p>\n<p id=\"demo33-%E5%88%97%E8%A1%A8del%2Fremove%2Freverse%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#demo33-%E5%88%97%E8%A1%A8del%2Fremove%2Freverse%C2%A0\">demo33-列表del/remove/reverse </a></p>\n<p id=\"demo34-%E5%88%A0%E9%99%A4%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#demo34-%E5%88%A0%E9%99%A4%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%C2%A0\">demo34-删除包含特定值的所有列表元素 </a></p>\n<p id=\"demo35-%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%88%97%E8%A1%A8%E3%80%81%E5%AD%97%E5%85%B8%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#demo35-%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%88%97%E8%A1%A8%E3%80%81%E5%AD%97%E5%85%B8%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\">demo35-可变对象（列表、字典）作为函数参数</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h3 id=\"main-toc\">demo1-输入输出</h3>\n<pre><code class=\"language-python\">#demo-1\n#输入输出\n#print函数参数\n#转义字符\n#正数 浮点数 字符串\n\nname = input(\"Please enter your name:\")\nprint(\"hello,\",name)\n\nprint(\"2**10 =\",2**10) #注意：print函数的逗号默认为一个空格，这是因为sep参数默认为空格\nprint(\"2**10=\",2**10,sep=\"\")#因此可以将sep参数设置为\"\"\n\nprint(2**5) #正数\nprint(3.1415926)#浮点数：IEEE754 浮点数的存储不精确\nprint(\"hello world\") #打印字符串:字符串可以用单引号也可以用双引号，每个pritn后默认换行\n\nprint(\"hello \",end=\"\") #注意：可以将end参数设置为\"\"，这样就不会换行\nprint(\"world\")\n\nprint(\"i'm ok\")#\"\"中含有'\nprint('i\" ok')#''中含有“\nprint(\"i\\' \\\"ok\\\"\") #既有单引号与双引号 则使用转义字符\\\n\nprint('\\\\\\t\\\\')\nprint(r'\\\\\\t\\\\')#r表示原生字符串，不转义，可以对比输出结果</code></pre>\n<blockquote>\n<pre>Please enter your name:ddd\nhello, ddd\n2**10 = 1024\n2**10=1024\n32\n3.1415926\nhello world\nhello world\ni'm ok\ni\" ok\ni' \"ok\"\n\\\t\\\n\\\\\\t\\\\</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo2-%E5%B8%83%E5%B0%94%E5%8F%98%E9%87%8F\">demo2-布尔变量</h3>\n<pre><code class=\"language-python\">#demo-2\n#Bool变量\n#注意大小写\n#布尔值可以用and or not运算\n#if语句\n\nTrue\nFalse\n\nprint(3&gt;2)\nprint(3&lt;2)\n\nprint(\"----and----\")\nprint(True and True)\nprint(False and True)\nprint(True and False)\nprint(False and False)\nprint(\"----or----\")\nprint(True or True)\nprint(False or True)\nprint(True or False)\nprint(False or False)\nprint(\"----not----\")\nprint(not True)\nprint(not False)\n\n#布尔值常用if结合使用\n#if首先判断条件为True或者Fasle，然后执行相应语句\nprint(\"*\"*20)#字符串还可以这样，使用*重复打印\nage = 22\nif age&gt;0:\n    print(\"Positive\")\nelif age&lt;0:\n    print(\"negative \")\nelse:\n    print(\"zeros\")\nprint(\"*\"*20)</code></pre>\n<blockquote>\n<pre>True\nFalse\n----and----\nTrue\nFalse\nFalse\nFalse\n----or----\nTrue\nTrue\nTrue\nFalse\n----not----\nFalse\nTrue\n********************\nPositive\n********************</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo3-%E5%8F%98%E9%87%8F\">demo3-变量</h3>\n<pre><code class=\"language-python\">#demo-3\n#变量\n#变量名由大小写字母、数字和_组成，不能以数字开头\n#变量赋值：对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向\n#除法\n\n\"\"\"getVar可以由int变为float，这是因为Python是动态语言，变量本身类型不固定\n    例如C或C++,变量声明或初始化时需要首先指定变量类型，且类型不可变\n\"\"\"\ngetVar = 5 #驼峰命名法  # =为赋值，相当于在内存中创建了一个getVar的变量与5，并将getVar变量指向5\nprint(getVar)\ngetVar = 3.1415\nprint(getVar)\n\n#两种写法均为将getVar加上5后再重新赋给getVar\ngetVar = getVar + 5 \ngetVar += 5\nprint(getVar)\n\n\n#把一个变量a赋值给另一个变量b，实际上是把变量b指向变量a所指向的数据\nprint(\"！！！重要！！！\")\ntempA = \"tempValue\" #此时tempA指向tempValue\ntempB = tempA       #此时tempB也指向tempValue\nprint(tempA,tempB)\ntempA = \"hello world\" #此时tempA指向hello world，但tempB仍然指向tempValue\nprint(tempA,tempB)\n\nprint(\"\\n*****除法*****\")\nprint(10/3) #精确的除法\nprint(10//3)#地板除 向下取floor，只取整数部分\nprint(10%3) #mod求模得余数</code></pre>\n<blockquote>\n<pre>5\n3.1415\n13.1415\n！！！重要！！！\ntempValue tempValue\nhello world tempValue\n\n*****除法*****\n3.3333333333333335\n3\n1</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96\">demo4-字符串格式化</h3>\n<pre><code class=\"language-python\">#demo-4\n#字符串格式化\n#爬虫中结构化的URL中常用\nurlList = [\"https://www.renrendai.com/loan-{}.html\".format(i)  for i in range(5)]\nfor eachList in urlList:\n    print(eachList)\n    \ntestStr = \"my name is {},my age is {}\".format(\"zsl\",999)\nprint(testStr)\n\n#使用索引\ntestStr = \"my name is {1},my age is {0}\".format(\"zsl\",999)\nprint(testStr)\n</code></pre>\n<blockquote>\n<pre><a href=\"https://www.renrendai.com/loan-0.html\" title=\"https://www.renrendai.com/loan-0.html\">https://www.renrendai.com/loan-0.html</a>\n<a href=\"https://www.renrendai.com/loan-1.html\" title=\"https://www.renrendai.com/loan-1.html\">https://www.renrendai.com/loan-1.html</a>\n<a href=\"https://www.renrendai.com/loan-2.html\" title=\"https://www.renrendai.com/loan-2.html\">https://www.renrendai.com/loan-2.html</a>\n<a href=\"https://www.renrendai.com/loan-3.html\" title=\"https://www.renrendai.com/loan-3.html\">https://www.renrendai.com/loan-3.html</a>\n<a href=\"https://www.renrendai.com/loan-4.html\" title=\"https://www.renrendai.com/loan-4.html\">https://www.renrendai.com/loan-4.html</a>\nmy name is zsl,my age is 999\nmy name is 999,my age is zsl</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo5-%E5%88%97%E8%A1%A8\">demo5-列表</h3>\n<pre><code class=\"language-python\">#demo-5\n#列表list-有序集合\nprint(\"*****创建列表*****\")\ntest = [10,3.1415,\"a\",[\"C\",\"C++\"],{\"key\":\"value\",}] #Python中的列表可以是不同类型\nscoresList = [60,80,100]\nprint(test)\nprint(test[3][1]) #取列表中的列表\nprint(scoresList)\nprint(\"*****列表长度*****\")\nprint(len(scoresList)) #列表长度\nprint(\"*****正向索引*****\")\nprint(scoresList[0])#正向索引/从0开始\nprint(scoresList[1])\nprint(scoresList[2])\nprint(\"*****反向索引*****\")\nprint(scoresList[-1])#反向索引:-1代表最后一个\nprint(scoresList[-2])#-2代表倒数第二个\nprint(scoresList[-3])#PS：若越界则报错\nprint(\"*****append追加*****\")\nprint(scoresList)\nscoresList.append(120)\nprint(scoresList)\nprint(\"*****insert插入*****\")\nprint(scoresList)\nscoresList.insert(0,0)#在索引为0处插入0\nprint(scoresList)\nscoresList.insert(3,999)#在索引为0处插入0\nprint(scoresList)\nprint(\"*****pop删除*****\")\nprint(scoresList)\nscoresList.pop()#默认弹出最尾部元素\nprint(scoresList)\nscoresList.pop(3) #弹出索引为0的元素\nprint(scoresList)\nprint(\"*****替换列表元素*****\")\nprint(scoresList)\nscoresList[0] = 9999\nprint(scoresList)\n</code></pre>\n<blockquote>\n<p></p>\n<pre>*****创建列表*****\n[10, 3.1415, 'a', ['C', 'C++'], {'key': 'value'}]\nC++\n[60, 80, 100]\n*****列表长度*****\n3\n*****正向索引*****\n60\n80\n100\n*****反向索引*****\n100\n80\n60\n*****append追加*****\n[60, 80, 100]\n[60, 80, 100, 120]\n*****insert插入*****\n[60, 80, 100, 120]\n[0, 60, 80, 100, 120]\n[0, 60, 80, 999, 100, 120]\n*****pop删除*****\n[0, 60, 80, 999, 100, 120]\n[0, 60, 80, 999, 100]\n[0, 60, 80, 100]\n*****替换列表元素*****\n[0, 60, 80, 100]\n[9999, 60, 80, 100]</pre>\n</blockquote>\n<h3 id=\"demo6-%E5%85%83%E7%BB%84\">demo6-元组</h3>\n<pre><code class=\"language-python\">#demo-6\n#tuple元组\n#tuple与list非常相似，但tuple一旦初始化后无法修改\nscoresTuple = (60,80,100)\nprint(scoresTuple)\n\n#初始化后无法修改，也无insert append pop等方法\n#scoresTuple[0]=999 #T会报错ypeError: 'tuple' object does not support item assignment\n\n#定义只有一个元素的tuple\noneTuple = (1)\nprint(oneTuple,type(oneTuple))\noneTuple = (1,) #需要加个， 因为（）既可以生成tuple，也可以认为是表达式的小括号，有ambiguous\nprint(oneTuple,type(oneTuple))\n\nprint(\"****有趣的例子*****\")\ntestTuple = (1,2,[3,4])\nprint(testTuple)\ntestTuple[2][0] = 666\ntestTuple[2][1] = 999\nprint(testTuple) #实质变的不是tuple，tuple始终指向两个整数一个列表，变的只是tuple中列表元素所指向的值\n# testTuple[2] = [666,999] #这样则会报错，因为这是修改tuple所指向的元素，而tuple在初始化后就不能修改所指向的值</code></pre>\n<blockquote>\n<p></p>\n<pre>(60, 80, 100)\n1 &lt;class 'int'&gt;\n(1,) &lt;class 'tuple'&gt;\n****有趣的例子*****\n(1, 2, [3, 4])\n(1, 2, [666, 999])</pre>\n</blockquote>\n<h3 id=\"demo7-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%C2%A0\">demo7-条件判断 </h3>\n<pre><code class=\"language-python\">#demo-7\n#条件判断\n\n#if语句从上往下执行，如果有个判断语句为True，则执行相应语句\n#往后的elif与else则忽略\n#例如下面的if中，num也满足大于0，但不会输出statement2\n#所以注意if语句中各个判断条件的顺序或者具体判断内容\nnum = 10\nif num &gt; 5:\n    print(\"statement1\")\nelif num &gt; 0:\n    print(\"statement2\")\nelse:\n    print(\"else\")\n    \nboolValue = 4&gt;3\n\nif boolValue: #关键是只要判断内容是True则会执行\n    print(\"test\")\n</code></pre>\n<blockquote>\n<pre>statement1\ntest</pre>\n</blockquote>\n<h3 id=\"demo8-for%E5%BE%AA%E7%8E%AF%C2%A0\">demo8-for循环 </h3>\n<pre><code class=\"language-python\">#demo-8\n#for循环\n\nprint(\"*****打印列表的每个值*****\")\nscoresLists = [0,60,80,100]\nfor eachScore in scoresLists:\n    print(eachScore)\n    \nprint(\"*****求列表数字总和*****\")\nscoresLists = [0,60,80,100]\nscoresSum = 0\nfor eachScore in scoresLists:\n    scoresSum += eachScore\nprint(scoresSum)\nprint(\"*****求1-100和*****\")\nmySum = 0\nfor each in range(1,101): #range(start,end)-左开右闭即[start,end)\n    mySum += each\nprint(mySum)\nprint(\"*****for循环常见用法-enumerate：既要每个元素的值也要每个元素对应的索引*****\")\nfor index,each in enumerate(range(1,21,3)): #range(start,end,step) 其中step为步长\n    print(index,each)\n    \nprint(\"*****for循环常见用法-zip：同时遍历两个可迭代对象*****\")\nfor x,y in zip([1,2,3],[4,5,6]): #\n    print(x,y)\n\n#break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用”\nprint(\"*****continue:计算1-100的偶数和*****\")\nmySum = 0\nfor each in range(1,101):\n    if each % 2 != 0:#计算偶数和，则遇到奇数时continue进入下一次循环\n        continue\n    mySum += each #只有偶数情况时才会执行该语句\nprint(mySum)\nprint(\"*****break*****\")\nmySum = 0\nfor each in range(1,101):\n    if each % 2 != 0:\n        break #第一次碰见奇数时就break结束循环，因此mySum仍为0\n    mySum += each \nprint(mySum)</code></pre>\n<blockquote>\n<pre>*****打印列表的每个值*****\n0\n60\n80\n100\n*****求列表数字总和*****\n240\n*****求1-100和*****\n5050\n*****for循环常见用法-enumerate：既要每个元素的值也要每个元素对应的索引*****\n0 1\n1 4\n2 7\n3 10\n4 13\n5 16\n6 19\n*****for循环常见用法-zip：同时遍历两个可迭代对象*****\n1 4\n2 5\n3 6\n*****continue:计算1-100的偶数和*****\n2550\n*****break*****\n0</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo9-%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88\">demo9-字典与集合</h3>\n<pre><code class=\"language-python\">#demo-9\n#字典dict与集合set\n#dict key:value 键值对 map\nscoresDict = {\n    \"tom\":100,\n    \"david\":80,\n    \"green\":60\n}\nprint(scoresDict)\nscoresDict[\"selly\"] = 99\nprint(scoresDict)\n\nprint(\"*****判断key是否在字典里*****\")\nprint(\"selly\" in scoresDict)\nprint(\"test\" in scoresDict)\nprint(scoresDict.get(\"test\",999))\nprint(scoresDict.get(\"selly\",999))#get函数若存在key，则放回value,否则返回自己设置的值\nprint(\"*****删除key*****\")\nprint(scoresDict)\nscoresDict.pop(\"tom\")\nprint(scoresDict)\n\n#set无序集合\nprint(\"*\"*50)\n# mySet = set(1,3,4,4,4,4,5,5) #TypeError: set expected at most 1 arguments, got 8\nmySet = set([1,3,4,4,4,4,5,5,6,7,8,8,8,9]) #使用列表List创建集合\nprint(mySet)\nprint(\"*****使用add与remove*****\")\nprint(mySet)\nmySet.add(999)\nprint(mySet)\nmySet.remove(999)\nprint(mySet)\nprint(\"*****集合交、并、差操作*****\")\naSet = set([1,2,3,4])\nbSet = set([3,4,5,6])\nprint(aSet &amp; bSet)\nprint(aSet | bSet)\nprint(aSet-bSet)\nprint(bSet-aSet)</code></pre>\n<blockquote>\n<pre>{'tom': 100, 'david': 80, 'green': 60}\n{'tom': 100, 'david': 80, 'green': 60, 'selly': 99}\n*****判断key是否在字典里*****\nTrue\nFalse\n999\n99\n*****删除key*****\n{'tom': 100, 'david': 80, 'green': 60, 'selly': 99}\n{'david': 80, 'green': 60, 'selly': 99}\n**************************************************\n{1, 3, 4, 5, 6, 7, 8, 9}\n*****使用add与remove*****\n{1, 3, 4, 5, 6, 7, 8, 9}\n{1, 3, 4, 5, 6, 7, 8, 9, 999}\n{1, 3, 4, 5, 6, 7, 8, 9}\n*****集合交、并、差操作*****\n{3, 4}\n{1, 2, 3, 4, 5, 6}\n{1, 2}\n{5, 6}</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo10-%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1\">demo10-可变对象与不可变对象</h3>\n<pre><code class=\"language-python\">#demo-10\n#不可变对象 ！！重要\n\n#可变对象\ntestList = [9,10,6,4,5]\nprint(testList)\ntestList.sort()\nprint(testList)\n\n#不可变对象:对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。\n#相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。\ntestStr = \"hello world\"\nprint(testStr)\ntestAnotherStr = testStr.replace(\"l\",\"L\")\nprint(testStr)\nprint(testAnotherStr)</code></pre>\n<blockquote>\n<p></p>\n<pre>[9, 10, 6, 4, 5]\n[4, 5, 6, 9, 10]\nhello world\nhello world\nheLLo worLd</pre>\n</blockquote>\n<p></p>\n<h3 id=\"demo11-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0\">demo11-内置函数</h3>\n<p></p>\n<pre><code class=\"language-python\">#demo-11\n#内置函数+函数别名\n# abs?\n# help(abs)\n\nprint(abs(-111))\nprint(max(1,2,3,4,5,5,3,1,2,4,5,78,))\nprint(min(1,2,3,4,5,5,3,1,2,4,5,78,))\n\n#类型转换\nprint(int(\"123\"),type(int(\"123\")))\nprint(int(12.3))\nprint(str(123),type(str(123)))\n\n#函数名是指向一个函数对象的引用\nmyAbs = abs #myAbs相当于函数abs的别名\nprint(myAbs(-123))\n\nprint(hex(65535))</code></pre>\n<blockquote>\n<pre>111\n78\n1\n123 &lt;class 'int'&gt;\n12\n123 &lt;class 'str'&gt;\n123\n0xffff</pre>\n</blockquote>\n<h3 id=\"demo12-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%B8%8Eisinstance\">demo12-定义函数与isinstance</h3>\n<pre><code class=\"language-python\">#demo-12\n#定义函数+isinstance\n\ndef myAbs(x):\n    if not isinstance(x,(float,int)):\n        raise TypeError('bad Type') \n    if x&gt;= 0:\n        return x\n    else:\n        return -x\n\nprint(myAbs(5))\nprint(myAbs(0))\nprint(myAbs(-5))\n\n# print(myAbs(-5,2))#TypeError: myAbs() takes 1 positional argument but 2 were given\n# print(myAbs(\"test\"))\n\n#isinstance的用法\nprint(isinstance(123,int))\nprint(isinstance(123,float))\nprint(isinstance(\"hello wolrd\",str))\n\n#函数返回多个值\nimport random\ndef getRandomPosition():\n    return random.randint(1,10),random.randint(1,10) #其实是返回一个tuple\nprint(getRandomPosition()[0],getRandomPosition()[1],type(getRandomPosition()))\n\n\n#求解一元二次方程\nimport math\ndef quadratic(a,b,c):\n    return (-b+math.sqrt(b**2-4*a*c))/(2*a),(-b-math.sqrt(b**2-4*a*c))/(2*a)\nprint(quadratic(3,9,2))</code></pre>\n<blockquote>\n<p></p>\n<pre>5\n0\n5\nTrue\nFalse\nTrue\n5 10 &lt;class 'tuple'&gt;\n(-0.24169426078820835, -2.758305739211792)</pre>\n</blockquote>\n<h3 id=\"demo13-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0\">demo13-默认参数</h3>\n<pre><code class=\"language-python\">#demo-13\n#函数参数-默认参数\n\n#x**n\ndef powN(x,n=2): #必选参数在前，默认参数在后/因为在后面才可省略\n    if n == 0:\n        return 1\n    sum = 1\n    for each in range(1,n+1):\n        sum *= x\n    return sum\nprint(powN(5,5),5**5)\nprint(powN(8,3),8**3)\nprint(powN(8)) #若无实际参数，则形式参数n默认为2\n\ndef enroll(name,gender,age=6,city=\"fuzhou\"):\n    print(\"name:\",name,sep=\"\")\n    print(\"gender:\",gender,sep=\"\")\n    print(\"age:\",age,sep=\"\")\n    print(\"city:\",city,sep=\"\")\n\nprint(\"*\"*20)\nenroll(\"xiaoming\",\"F\")\nprint(\"*\"*20)\nenroll(\"xiaoming\",\"F\",9)\nprint(\"*\"*20)\nenroll(\"xiaoming\",\"F\",9,\"beijing\")\nprint(\"*\"*20)\nenroll(\"xiaoming\",\"F\",city=\"beijing\") #可以不按顺序提供默认参数，此时需要把参数名写上\nprint(\"*\"*20)\nenroll(\"xiaoming\",\"F\",city=\"xiamen\",age=15)\n</code></pre>\n<blockquote>\n<p></p>\n<pre>3125 3125\n512 512\n64\n********************\nname:xiaoming\ngender:F\nage:6\ncity:fuzhou\n********************\nname:xiaoming\ngender:F\nage:9\ncity:fuzhou\n********************\nname:xiaoming\ngender:F\nage:9\ncity:beijing\n********************\nname:xiaoming\ngender:F\nage:6\ncity:beijing\n********************\nname:xiaoming\ngender:F\nage:15\ncity:xiamen</pre>\n</blockquote>\n<h3 id=\"demo14-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1\">demo14-默认参数必须指向不可变对象</h3>\n<pre><code class=\"language-python\">#demo-14\n#默认参数必须指向不可变对象\n\ndef add_end(L=[]):\n    L.append('END')\n    return L\n\ntempList = [1,2,3]\nadd_end(tempList)\nadd_end()\nprint(tempList)\n#ython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]\n#每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了\nadd_end()\nadd_end()\nadd_end()\nprint(add_end())\n\n#改进\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append(\"END\")\n    return L\nadd_end()\nadd_end()\nadd_end()\nprint(add_end())\n</code></pre>\n<blockquote>\n<p></p>\n<pre>[1, 2, 3, 'END']\n['END', 'END', 'END', 'END', 'END']\n['END']</pre>\n</blockquote>\n<h3 id=\"demo15-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\">demo15-可变参数</h3>\n<pre><code class=\"language-python\">#demo-15\n#可变参数\n#计算a2 + b2 + c2 + ……\n\n#定义可变参数仅在参数前加*\n#在函数内部，可变参数为一个tuple元组\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\nprint(calc(1,2,3,4))\ntempList = [1,2,3,4]\nprint(calc(tempList[2],tempList[3]))\nprint(calc(*tempList))  #若原本存在列表，则在其前面加*即可把列表或者元组的元组变为可变参数传入\n</code></pre>\n<blockquote>\n<pre>30\n25\n30\n</pre>\n</blockquote>\n<h3 id=\"demo16-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E4%B8%8E%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0\">demo16-关键字参数与命名关键字参数</h3>\n<pre><code class=\"language-python\">#demo-16\n#关键字参数与命名关键字参数\n\n#关键字参数\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n    \nperson(\"Tom\",20)\nperson(\"Tom\",20,city=\"fuzhou\",gender=\"F\")\n\nmyDict = {\"city\":\"xiamen\",\"tel\":13000000000,\"gender\":\"F\"}\nperson(\"Tom\",20,**myDict)\n\nprint(\"*\"*50)\n#和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数\n#此时命名关键字参数则必须存在，且命名关键字参数必须传入参数名\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\nperson(\"Tom\",20,city=\"fuzhou\",job=\"none\")\n\n#如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\nperson(\"Tom\",25,*[1,2,3,4],city=\"fuzhou\",job=\"none\")\n\n#命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n\nperson(\"Tom\",20,job=\"none\")\n\n#</code></pre>\n<blockquote>\n<p></p>\n<pre>name: Tom age: 20 other: {}\nname: Tom age: 20 other: {'city': 'fuzhou', 'gender': 'F'}\nname: Tom age: 20 other: {'city': 'xiamen', 'tel': 13000000000, 'gender': 'F'}\n**************************************************\nTom 20 fuzhou none\nTom 25 (1, 2, 3, 4) fuzhou none\nTom 20 Beijing none</pre>\n</blockquote>\n<h3 id=\"demo17-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F\">demo17-函数参数顺序</h3>\n<pre><code class=\"language-python\">#demo-17\n#参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数\n#注意是先命名关键字参数后关键字参数，因为命名关键字参数需要指定参数名，而关键字参数抛在最后即可\n#可变参数在中间，因为前面是位置参数或默认参数，按位置进行解析，后面为关键字参数需要指定key，中间剩余的则为可变参数\n\n#arg为可变参数；kw为关键字参数\ndef f1(a, b, c=0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\n    \nf1(100,200)\nf1(1,2,3,*[1,2,3,4,5])\nf1(1,2,3,*[1,2,3,4,5],city=\"fuzhou\",gender=\"F\",job=\"None\")\n\n#无可变参数，d为命名关键字参数，kw为关键字参数；注：关键字参数在命名关键字参数后面，大杂烩\ndef f2(a, b, c=0, *, d, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n    \nf2(1,2,3,d=\"dddd\",city=\"fuzhou\",gender=\"F\",job=\"None\") #d为命名关键字参数，必须指定该参数值，否则报错\nf2(1,2,3,d=\"dddd\") </code></pre>\n<blockquote>\n<pre>a = 100 b = 200 c = 0 args = () kw = {}\na = 1 b = 2 c = 3 args = (1, 2, 3, 4, 5) kw = {}\na = 1 b = 2 c = 3 args = (1, 2, 3, 4, 5) kw = {'city': 'fuzhou', 'gender': 'F', 'job': 'None'}\na = 1 b = 2 c = 3 d = dddd kw = {'city': 'fuzhou', 'gender': 'F', 'job': 'None'}\na = 1 b = 2 c = 3 d = dddd kw = {}</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo18-random%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0\">demo18-random常见函数</h3>\n<pre><code class=\"language-python\">#demo-18\n#random常见函数\nimport random\n\nprint( random.randint(1,10) )        # 产生 1 到 10 的一个整数型随机数  [1,10]\nprint( random.random() )             # 产生 0 到 1 之间的随机浮点数[0,1)\nprint( random.uniform(1.1,5.4) )     # 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数\nprint( random.choice('tomorrow') )   # 从序列中随机选取一个元素\nprint( random.choice([1,2,3]) )   # 从序列中随机选取一个元素\nprint( random.randrange(1,100,2) )   # 生成从1到100的间隔为2的随机整数\n\na=[1,3,5,6,7]                # 将序列a中的元素顺序打乱\nrandom.shuffle(a)\nprint(a)\n# random.uniform?</code></pre>\n<blockquote>\n<pre>1\n0.5632331524744293\n2.7294567751257137\nr\n2\n3\n[5, 7, 6, 1, 3]</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo19-%E5%88%87%E7%89%87\">demo19-切片</h3>\n<pre><code class=\"language-python\">#demo-19\n#切片slice\ntestList = [\"fujian\",\"anhui\",\"shanghai\",\"beijing\",\"shenzhen\"]\nprint(testList[:3]) #左闭右开\nprint(testList[1:3])\nprint(testList[-2:-1]) #反向\nprint(testList[-2:])\n\ntestList = list(range(1,101))\nprint(testList)\nprint(testList[:10])  #前10个\nprint(testList[-10:]) #后10个\nprint(testList[:10:2])  #前10个,步长为2\nprint(testList[::5])   #间隔5个取一个\n\n\n#重要；注意对比\n#引用与复制\nprint(\"*\"*50)\ntestList = [\"fujian\",\"anhui\",\"shanghai\",\"beijing\",\"shenzhen\"]\ntempList = testList   #tempList与testList均指向同一个list[]\nprint(tempList)\ntestList.append(\"test\")\nprint(tempList)\nprint(\"*\"*50)\ntestList = [\"fujian\",\"anhui\",\"shanghai\",\"beijing\",\"shenzhen\"]\ntempList = testList[:]  #拷贝；重新复制\nprint(tempList)\ntestList.append(\"test\")\nprint(tempList)\nprint(\"*\"*50)\nprint(\"hello world\"[::2]) #字符串也可以当作一个list进行切片处理\n</code></pre>\n<blockquote>\n<p></p>\n<pre>['fujian', 'anhui', 'shanghai']\n['anhui', 'shanghai']\n['beijing']\n['beijing', 'shenzhen']\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n[1, 3, 5, 7, 9]\n[1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 51, 56, 61, 66, 71, 76, 81, 86, 91, 96]\n**************************************************\n['fujian', 'anhui', 'shanghai', 'beijing', 'shenzhen']\n['fujian', 'anhui', 'shanghai', 'beijing', 'shenzhen', 'test']\n**************************************************\n['fujian', 'anhui', 'shanghai', 'beijing', 'shenzhen']\n['fujian', 'anhui', 'shanghai', 'beijing', 'shenzhen']\n**************************************************\nhlowrd</pre>\n</blockquote>\n<h3 id=\"demo20-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1Iterable\">demo20-可迭代对象Iterable</h3>\n<pre><code class=\"language-python\">#demo-20\n#可迭代对象\nmyDict = {'a': 1, 'b': 2, 'c': 3}\nfor key in myDict:#默认迭代key\n    print(key,myDict[key])\n    \nfor value in myDict.values():#迭代value\n    print(value)\n\nfor key,value in myDict.items(): #迭代键值对\n    print(key,value)\n    \nfor each in list(range(1,5)):\n    print(each)\n    \nfor eachChar in \"hello\":\n    print(eachChar)\n\nprint(\"*****判断是否为可迭代对象*****\")\nfrom collections.abc import Iterable\nprint(isinstance([1,2,23],Iterable))\nprint(isinstance(5,Iterable))\nprint(\"*****enumerate*****\")\nfor index,value in enumerate([\"a\",\"b\",\"c\"]):\n    print(index,value)</code></pre>\n<blockquote>\n<p></p>\n<pre>a 1\nb 2\nc 3\n1\n2\n3\na 1\nb 2\nc 3\n1\n2\n3\n4\nh\ne\nl\nl\no\n*****判断是否为可迭代对象*****\nTrue\nFalse\n*****enumerate*****\n0 a\n1 b\n2 c</pre>\n</blockquote>\n<h3 id=\"demo21-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F\">demo21-列表生成式</h3>\n<pre><code class=\"language-python\">#demo-21\n#列表生成式List Comprehensions\n\nprint([i*i for i in range(1,11)])\nprint([i*i for i in range(1,11) if i % 2 == 0]) #只有偶数 \nprint([x + y  for x in [1,2,3] for y in [4,5,6]]) #注意该种用法\n\nL = ['Hello', 'World', 'TEST', 'XYZ']\nprint([each.lower() for each in L])\n\nprint( [x if x % 2 == 0 else -x for x in range(1, 11)])\n\nL = ['Hello', 'World',999, 'TEST', 'XYZ']\nprint([each.lower() for each in L if isinstance(each,str)])</code></pre>\n<blockquote>\n<p></p>\n<pre>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n[4, 16, 36, 64, 100]\n[5, 6, 7, 6, 7, 8, 7, 8, 9]\n['hello', 'world', 'test', 'xyz']\n[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]\n['hello', 'world', 'test', 'xyz']</pre>\n</blockquote>\n<h3 id=\"demo22-%E7%94%9F%E6%88%90%E5%99%A8\">demo22-生成器</h3>\n<pre><code class=\"language-python\">#demo-22\n#生成器\n#若列表元素规模大，则一次占用过多内存\n#因此可以使用生成器generator，在循环的过程中计算元素值\nL = [x * x for x in range(10)]\nprint(L,type(L))\n\ng = (x * x for x in range(10)) #把[]替换为（）即为generator生成器\nprint(g,type(g))\n\nfor each in g:#遍历生成器\n    print(each)\n    \n    \n#斐波拉契数列\n#如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator函数\n#1 1 2 3 5 8\ndef fib(n):\n    i,left,right = 0,0,1 \n    while(i&lt;n):\n        yield(right)\n        left,right = right,left+right\n        i += 1\n        \nfor each in fib(10):\n    print(each)\n\n#调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。\nprint(next(fib(5)))\nprint(next(fib(5)))\nprint(next(fib(5)))\n</code></pre>\n<blockquote>\n<p></p>\n<pre>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class 'list'&gt;\n&lt;generator object &lt;genexpr&gt; at 0x000001E22B2B5BC8&gt; &lt;class 'generator'&gt;\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n1\n1\n1</pre>\n</blockquote>\n<h3 id=\"demo23-%E8%BF%AD%E4%BB%A3%E5%99%A8\">demo23-迭代器</h3>\n<pre><code class=\"language-python\">#demo-23\n#迭代器\n\n#可以直接用于for循环：\n#①生成器generator 与 带yield的generator function\n#②集合数据类型：list tuple dict set str\n\nprint(\"*****判断是否为可迭代对象Iterable*****\")\nfrom collections.abc import Iterable\nprint(isinstance([],Iterable))\nprint(isinstance(\"\",Iterable))\nprint(isinstance((),Iterable))\nprint(isinstance({},Iterable))\nprint(isinstance(5,Iterable))\n\n\n#生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator\n#可以使用iter()函数将Iterable变为Iterator\nprint(\"*****判断是否为迭代器对象Iterator*****\")\nfrom collections.abc import Iterator\nprint(isinstance([],Iterator))\nprint(isinstance(iter([]),Iterator)) #使用iter函数变为迭代器\nprint(isinstance(\"\",Iterator))\nprint(isinstance((),Iterator))\nprint(isinstance({},Iterator))\nprint(isinstance(5,Iterator))\nprint(isinstance(fib(10),Iterator))\n\n#Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误\n#可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据\n#所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。\n#Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的</code></pre>\n<blockquote>\n<p></p>\n<pre>*****判断是否为可迭代对象Iterable*****\nTrue\nTrue\nTrue\nTrue\nFalse\n*****判断是否为迭代器对象Iterator*****\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue</pre>\n</blockquote>\n<h3 id=\"demo24-map%E4%B8%8Ereduce%E5%87%BD%E6%95%B0\">demo24-map与reduce函数</h3>\n<pre><code class=\"language-python\">#demo-24\n#高阶函数之map与reduce\n#一个函数就可以接收另一个函数作为参数\n\n#变量可以指向函数\nmyAbs = abs  #函数名是指向函数的变量\nprint(myAbs(-10))\n\n#高阶函数\ndef add(x,y,f):  #接收另一个函数作为参数\n    return f(x)+f(y)\n\nprint(add(-5,-8,abs))\n\n\n#map函数\n#map函数接收两个参数，一个是函数，另一个是Iterable\n#map将函数依次作用到可迭代对象的每个元素上\n#并把结果作为新的Iterator返回\n\ndef mySqure(x):\n    return x**2\n\nprint(list(map(mySqure,[1,2,3,4]))) #将iterator转换为list;把函数mySqure作为参数传入map\nprint(list(map(str,[1,2,3,4])))\n\nprint(list(map(lambda x:x.lower(),['adam', 'LISA', 'barT'])))\nprint(list(map(str.lower,['adam', 'LISA', 'barT'])))  #str.lower\n\n\n\n#reduce函数\n#reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n#把结果和序列的下一个元素进行运算\nfrom functools import reduce\n\ndef fn(x,y):\n    return 10 * x + y\nprint(reduce(fn,[1,3,5,7,9]))\n\n</code></pre>\n<blockquote>\n<p></p>\n<pre>10\n13\n[1, 4, 9, 16]\n['1', '2', '3', '4']\n['adam', 'lisa', 'bart']\n['adam', 'lisa', 'bart']\n13579</pre>\n</blockquote>\n<h3 id=\"demo25-filter%E5%87%BD%E6%95%B0\">demo25-filter函数</h3>\n<pre><code class=\"language-python\">#demo-25\n#filter函数：用于过滤序列\n#和map()类似，filter()也接收一个函数和一个序列。\n#和map()不同的是，filter()把传入的函数依次作用于每个元素\n#然后根据返回值是True还是False决定保留还是丢弃该元素。\n\ndef is_odd(x):\n    return x % 2 == 1\n\n#注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，\n#所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。\nprint(list(filter(is_odd,list(range(1,12)))))\n\n#回数\ndef is_palindrome(x):\n    if str(x) == str(x)[::-1]:  #[::-1]倒序\n        return True\nprint(list(filter(is_palindrome,list(range(1,1000)))))</code></pre>\n<blockquote>\n<p></p>\n<pre>[1, 3, 5, 7, 9, 11]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]</pre>\n</blockquote>\n<h3 id=\"demo26-sorted%E5%87%BD%E6%95%B0\">demo26-sorted函数</h3>\n<pre><code class=\"language-python\">#demo-26\n#sorted:key参数接收函数作为排列依据\n\ntempList = [36, 5, -12, 9, -21]\nprint(tempList)\nprint(sorted(tempList)) #不改变原始列表\nprint(tempList)\ntempList.sort() #排列原始列表\nprint(tempList)\n\n\ntempList = [36, 5, -12, 9, -21]\nprint(sorted(tempList,key=abs)) #key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序\nprint(sorted(tempList,key=abs,reverse=True)) #反向</code></pre>\n<blockquote>\n<p></p>\n<pre>[36, 5, -12, 9, -21]\n[-21, -12, 5, 9, 36]\n[36, 5, -12, 9, -21]\n[-21, -12, 5, 9, 36]\n[5, 9, -12, -21, 36]\n[36, -21, -12, 9, 5] </pre>\n</blockquote>\n<h3 id=\"demo27-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0lambda\">demo27-匿名函数lambda</h3>\n<pre><code class=\"language-python\">#demo-27\n#匿名函数lambda\n#无需显式定义函数，使用匿名函数更为方便\n\nprint(list(map(lambda x:x.lower(),['adam', 'LISA', 'barT'])))\n\n\ndef mySqure(x):\n    return x**2\nprint(list(map(mySqure,[1,2,3,4])))\nprint(list(map(lambda x:x**2,[1,2,3,4])))\n\n\ndef is_odd(x):\n    return x % 2 == 1\nprint(list(filter(is_odd,list(range(1,12)))))\nprint(list(filter(lambda x:x%2==1,list(range(1,12)))))\n\n#匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数\nf = lambda x:x**2\nprint(f(5))\n</code></pre>\n<blockquote>\n<p></p>\n<pre>['adam', 'lisa', 'bart']\n[1, 4, 9, 16]\n[1, 4, 9, 16]\n[1, 3, 5, 7, 9, 11]\n[1, 3, 5, 7, 9, 11]\n25</pre>\n</blockquote>\n<h3 id=\"demo28-%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B\">demo28-类和实例</h3>\n<pre><code class=\"language-python\">#demo-28\n#类和实例\n\nclass Student(object):  #定义类-&gt;相当于模板\n    pass \n\nstd1 = Student()  #类的实例化-&gt;对象\nstd2 = Student()\n\nprint(std1)\nprint(std2) #每个实例有不同的内存地址\nprint(Student)\n\nstd1.socre = 99  #可以自由的给实例绑定变量\nprint(std1.socre)\n\n#类起到模板作用，可以设置初始化实例时必须的参数\nclass StudentV1(object):\n    \n    def __init__(self,name,age):  #self指向对象本身\n        self.name = name\n        self.age = age\n        \n# std1 = StudentV1() #报错：TypeError: __init__() missing 2 required positional arguments: 'name' and 'age'\nstd1 = StudentV1(\"Tom\",6)\nprint(std1.name,std1.age) #打印对象属性；但该种方法不好，直接访问了数据；</code></pre>\n<blockquote>\n<pre>&lt;__main__.Student object at 0x000001E22B27D648&gt;\n&lt;__main__.Student object at 0x000001E22B24D6C8&gt;\n&lt;class '__main__.Student'&gt;\n99\nTom 6</pre>\n<p></p>\n</blockquote>\n<h3 id=\"demo29-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85\">demo29-数据封装</h3>\n<pre><code class=\"language-python\">#demo-29\n#数据封装\n\n#对对象属性或数据的访问应该通过调用类的方法进行\n#从而实现对数据的封装，避免从外部访问对象的数据\n\nclass StudentV2(object):\n    \n    def __init__(self,name,age):  #self指向对象本身\n        self.name = name\n        self.age = age\n    \n    def printScore(self):\n        print(self.name,self.age)\n        \n    def isAdult(self):\n        if self.age &gt;= 18:\n            print(\"Adult\")\n        else:\n            print(\"hhh\")\n\nstd1 = StudentV2(\"Tom\",6)\nstd1.printScore() #通过method方法访问对象内部数据\nstd1.isAdult()</code></pre>\n<blockquote>\n<pre>Tom 6\nhhh\n</pre>\n</blockquote>\n<h3 id=\"demo30-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6\">demo30-访问限制</h3>\n<pre><code class=\"language-python\">#demo-30\n#访问限制\n\nclass StudentV2(object):\n    \n    def __init__(self,name,age):  #self指向对象本身\n        self.name = name\n        self.age = age\n    \n    def printScore(self):\n        print(self.name,self.age)\n        \n    def isAdult(self):\n        if self.age &gt;= 18:\n            print(\"Adult\")\n        else:\n            print(\"hhh\")\n\nstd1 = StudentV2(\"Tom\",6)\nstd1.isAdult()\nstd1.age = 20  #外部可以直接操作对象内部的数据\nstd1.isAdult()\n\n#可以在实例变量名前加上__（两个下划线），从而将变量变为私有变量\n#数据封装， 此时数据只能内部访问，无法外部访问\n#__varName__以双下划线开头与结尾的是特殊变量，因此不使用该种命名方式\n\n\nclass StudentV3(object):\n    \n    def __init__(self,name,age):  #self指向对象本身\n        self.__name = name\n        self.__age = age\n        \n    def printScore(self):\n        print(self.__name,self.__age)\n        \n    def isAdult(self):\n        if self.__age &gt;= 18:\n            print(\"Adult\")\n        else:\n            print(\"hhh\")\n            \n    def getScore(self):\n        return self.__age\n    \n    def setScore(self,age):  #采用数据封装的方式，内部方法可以对传入的参数进行更多的操作\n        \n        if 0 &lt;= age and age&lt;=100: #0 &lt;= score and &lt;=100\n            self.__age = age\n        else:\n            raise ValueError(\"value error\")\n            \nstd1 = StudentV3(\"Tom\",6)\n# print(std1.__age)  #'StudentV3' object has no attribute '__age' #此时从外部无法访问__age\nstd1.printScore()\nprint(std1.getScore())\nstd1.setScore(20)\nprint(std1.getScore())\n\n\n#从外部其实也可以直接方法私有变量 : _ClassName__VarName\nprint(std1._StudentV3__age)  #Python解释器对外把__name变量改成了_Student__name\n\nstd1.__age = 999 #所以这种方法只是增加了一个__age变量，但并非更改了类内属性__age\nprint(std1.getScore(),std1.__age) #可以发现类内属性_age并未改成999，因为此时该变量全称变为_StudentV3__age\n</code></pre>\n<blockquote>\n<pre>hhh\nAdult\nTom 6\n6\n20\n20\n20 999\n</pre>\n</blockquote>\n<h3 id=\"demo31-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81\">demo31-继承与多态</h3>\n<pre><code class=\"language-python\">#demo-31\n#继承与多态\n#多态：为不同数据类型的实体提供统一的接口\n\nclass Animal(object):\n    def run(self):\n        print('Animal is running...')\n        \nclass Dog(Animal):  #继承于Animal类\n    def eat(self):\n        print('Eating meat...')\n        \n    def run(self):\n        print('dog is running...')\n        \nclass Cat(Animal):\n    def run(self):\n        print('cat is running...')\n\ndog = Dog()\ndog.run()  #当子类与父类存在同样的方法时，子类会覆盖父类的方法-&gt;多态\ndog.eat()\n\ncat = Cat()\ncat.run()\n\n#既是子类也是父类\nprint(isinstance(dog,Animal))\nprint(isinstance(dog,Dog))\n\ndef run_twice(animal):\n    animal.run()\n    animal.run()\n    \nrun_twice(Animal())\nrun_twice(Dog())\nrun_twice(Cat())</code></pre>\n<blockquote>\n<pre>dog is running...\nEating meat...\ncat is running...\nTrue\nTrue\nAnimal is running...\nAnimal is running...\ndog is running...\ndog is running...\ncat is running...\ncat is running...</pre>\n</blockquote>\n<h3 id=\"demo32-%E5%AD%97%E7%AC%A6%E4%B8%B2\">demo32-字符串</h3>\n<pre><code class=\"language-python\">#demo1-字符串\n\nprint(\"*****str.title()*****\")\nmyStr = \"hello world\"\nprint(myStr)\nprint(myStr.title())#单词首字母大写\n\nprint(\"*****upper()与lower()*****\")\nmyStr = \"hello world\"\nprint(myStr)\nprint(myStr.upper())  #全部大写\nmyStr = \"HELLO WORLD\"\nprint(myStr.lower())  #全部小写\nprint(myStr)          #使用lower()并不会修改字符串对象的数据，只是重新传回一个新字符串，这是因为str为不可变对象\n\nprint(\"*****合并字符串*****\")\nfirstStr = \"hello\"\nlastStr = \"world\"\nprint(firstStr + lastStr)   #采用+连接字符串中间无空格\nprint(firstStr + \" \" + lastStr)\n\nprint(\"*****删除空白****\")\ntestStr = \"Python \"\nprint(len(testStr))\nprint(len(testStr.rstrip()) )#返回的只是新对象，并非在testStr对象上修改数据\nprint(len(testStr))          #长度仍为7\ntestStr = testStr.rstrip()   #有效修改\nprint(len(testStr))          #长度仍为6\n\n#rstrip lstrip strip\ntestStr = \" Python \"\nprint(len(testStr))    #8\ntestStr = testStr.strip()   \nprint(len(testStr))    #6      \n\n\n#彩蛋-Python之禅\nimport this</code></pre>\n<blockquote>\n<pre>*****str.title()*****\nhello world\nHello World\n*****upper()与lower()*****\nhello world\nHELLO WORLD\nhello world\nHELLO WORLD\n*****合并字符串*****\nhelloworld\nhello world\n*****删除空白****\n7\n6\n7\n6\n8\n6\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!</pre>\n</blockquote>\n<h3 id=\"demo33-%E5%88%97%E8%A1%A8del%2Fremove%2Freverse%C2%A0\">demo33-列表del/remove/reverse </h3>\n<pre><code class=\"language-python\">#demo2-列表\n\nprint(\"*****采用del删除列表元素*****\")\ntestList = [\"a\",\"b\",\"c\",\"d\"]\nprint(testList)\ndel testList[0]  #采用del删除后，无法再访问该值\nprint(testList)\n\nprint(\"*****采用pop()删除列表元素*****\")\ntestList = [\"a\",\"b\",\"c\",\"d\"]\nprint(testList)\ntestList.pop() #默认删除最后一个元素\nprint(testList)\ntemp = testList.pop(1) #接收被弹出的元素/参数为删除元素的索引\nprint(testList)\nprint(temp)  \n\n\nprint(\"*****根据值删除元素remove()*****\")\ntestList = [\"a\",\"b\",\"c\",\"d\",\"a\",\"b\",\"c\",\"d\"]\nprint(testList)\ntestList.remove(\"a\") #只删除第一个指定的值\nprint(testList)\n\nprint(\"*****反转列表*****\")\ntestList = [\"a\",\"b\",\"c\",\"d\"]\nprint(testList)\ntestList.reverse()          #永久性修改列表\nprint(testList)\ntestList = testList[::-1] #[::-1]反转\nprint(testList)\n</code></pre>\n<blockquote>\n<p> </p>\n<pre>*****采用del删除列表元素*****\n['a', 'b', 'c', 'd']\n['b', 'c', 'd']\n*****采用pop()删除列表元素*****\n['a', 'b', 'c', 'd']\n['a', 'b', 'c']\n['a', 'c']\nb\n*****根据值删除元素remove()*****\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n['b', 'c', 'd', 'a', 'b', 'c', 'd']\n*****反转列表*****\n['a', 'b', 'c', 'd']\n['d', 'c', 'b', 'a']\n['a', 'b', 'c', 'd']</pre>\n</blockquote>\n<h3 id=\"demo34-%E5%88%A0%E9%99%A4%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%C2%A0\">demo34-删除包含特定值的所有列表元素 </h3>\n<pre><code class=\"language-python\">#demo3-删除包含特定值的所有列表元素\n#for循环中不应该修改可迭代对象，否则难以跟踪其中的元素\n#若要在遍历的同时修改可迭代对象，可使用while循环\n\ntestList = [\"a\",\"b\",\"c\",\"d\",\"a\",\"b\",\"c\",\"d\"]\nprint(testList)\nwhile \"a\" in testList:\n    testList.remove(\"a\") \nprint(testList)\n</code></pre>\n<blockquote>\n<p> </p>\n<pre>['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n['b', 'c', 'd', 'b', 'c', 'd']</pre>\n</blockquote>\n<h3 id=\"demo35-%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%88%97%E8%A1%A8%E3%80%81%E5%AD%97%E5%85%B8%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\">demo35-可变对象（列表、字典）作为函数参数</h3>\n<pre><code class=\"language-python\">#demo4-可变对象（列表、字典）作为函数参数\n#python的参数，如果传递的是不可修改变量则无法改，可变变量则可以改\n#如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值\n#如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象\n\ndef modifyList(testList):\n    testList.append(\"test\")\n\nprint(\"*****函数修改可变对象*****\")\nmyList = [1,2,3,4]\nprint(myList)\nmodifyList(myList) #对传入的可变对象的修改是永久性的\nprint(myList)\n\nprint(\"*****禁止函数修改可变对象*****\")\nmyList = [1,2,3,4]\nprint(myList)\nmodifyList(myList[:]) #传入副本，不修改原始对象；尽量避免，尤其是大列表，耗时与费内存\nprint(myList)</code></pre>\n<blockquote>\n<pre>*****函数修改可变对象*****\n[1, 2, 3, 4]\n[1, 2, 3, 4, 'test']\n*****禁止函数修改可变对象*****\n[1, 2, 3, 4]\n[1, 2, 3, 4]</pre>\n</blockquote>\n</div>\n</div>", "first_tag": "Python", "cpp": 1, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-07 00:58:52", "summary": "目录输入输出布尔变量变量字符串格式化列表元组条件判断循环字典与集合可变对象与不可变对象内置函数定义函数与默认参数默认参数必须指向不可变对象可变参数关键字参数与命名关键字参数函数参数顺序常见函数切片可迭"}