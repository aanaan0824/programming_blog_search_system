{"blogid": "126260295", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5473", "writerComment": "4194", "writerFan": "7302", "writerGrade": "7级", "writerIntegral": "13155", "writerName": "三分苦", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126260295.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4504", "writerVisitNum": "116704", "blog_read_count": "70", "blog_time": "于 2022-09-04 20:37:20 发布", "blog_title": "【 C++ 】AVL树", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84\">1、底层结构</a></p>\n<p id=\"2%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">2、AVL树的概念</a></p>\n<p id=\"3%E3%80%81AVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81AVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89\">3、AVL树节点的定义</a></p>\n<p id=\"4%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6\">4、基本框架</a></p>\n<p id=\"5%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc\" style=\"margin-left:80px;\"><a href=\"#5%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5\">5、AVL树的插入</a></p>\n<p id=\"6%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC-toc\" style=\"margin-left:80px;\"><a href=\"#6%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC\">6、AVL树的旋转</a></p>\n<p id=\"%E5%B7%A6%E5%8D%95%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%B7%A6%E5%8D%95%E6%97%8B\">        </a><a href=\"#%E5%B7%A6%E5%8D%95%E6%97%8B\">左单旋</a></p>\n<p id=\"%E5%8F%B3%E5%8D%95%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8F%B3%E5%8D%95%E6%97%8B\">        </a><a href=\"#%E5%8F%B3%E5%8D%95%E6%97%8B\">右单旋</a></p>\n<p id=\"%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B\">        </a><a href=\"#%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B\">左右双旋</a></p>\n<p id=\"%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B\">        </a><a href=\"#%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B\">右左双旋</a></p>\n<p id=\"7%E3%80%81AVL%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81-toc\" style=\"margin-left:80px;\"><a href=\"#7%E3%80%81AVL%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81\">7、AVL树的验证</a></p>\n<p id=\"8%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:80px;\"><a href=\"#8%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE\">8、AVL树的查找</a></p>\n<p id=\"9%E3%80%81AVL%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#9%E3%80%81AVL%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\">9、AVL树的删除（了解）</a></p>\n<p id=\"10%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD-toc\" style=\"margin-left:80px;\"><a href=\"#10%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD\">10、AVL树的性能</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">11、源码链接</a></p>\n<hr/>\n<h3>1、底层结构</h3>\n<blockquote>\n<p>前面对map、multimap、set、multiset进行了简单的介绍，这几个容器有个共同点是：其底层都是按照<span style=\"color:#956fe7;\">二叉搜索树</span>来实现的，但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成<span style=\"color:#956fe7;\">单支树</span>，时间复杂度会退化成O(N)，因此map、set等关联式容器的底层结构是对二叉树进行了平衡处理，即采用<span style=\"color:#fe2c24;\">平衡树</span>来实现。</p>\n</blockquote>\n<hr/>\n<h3 id=\"2%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">2、AVL树的概念</h3>\n<blockquote>\n<p>二叉搜索树虽可以缩短查找的效率，但如果数据<span style=\"color:#ff9900;\">有序</span>或<span style=\"color:#ff9900;\">接近有序</span>二叉搜索树将<span style=\"color:#ff9900;\">退化为单支树</span>，查找元素<span style=\"color:#ff9900;\">相当于在顺序表中搜索元素</span>，<span style=\"color:#ff9900;\">效率低下</span>。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证<span style=\"color:#956fe7;\">每个结点的左右子树高度之差的绝对值不超过1</span>(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。</p>\n<p>一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p>\n<ol><li>它的左右子树都是AVL树</li><li>任何一颗左右子树<span style=\"color:#fe2c24;\">高度之差</span>(简称平衡因子)的<span style=\"color:#fe2c24;\">绝对值不超过1</span>(-1/0/1)</li></ol>\n<ul><li>0代表左右高度相等</li><li>1代表右子树高1</li><li>-1代表左子树高1</li></ul>\n<p>下面给出一幅图来判断是否为AVL树：</p>\n<p><img alt=\"\" height=\"259\" src=\"..\\..\\static\\image\\572782434ad9432e95d55d2187b35dc5.png\" width=\"1142\"/></p>\n<p>如果一棵二叉搜索树是高度平衡的（相对平衡），它就是AVL树。如果它有n个结点，其<span style=\"color:#956fe7;\">高度可保持在<br/> O(logN)</span>，搜索<span style=\"color:#fe2c24;\">时间复杂度O(logN)</span>。</p>\n</blockquote>\n<hr/>\n<h3 id=\"3%E3%80%81AVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89\">3、AVL树节点的定义</h3>\n<blockquote>\n<p>这里我们实现的AVL树为KV模型，自然节点的模板参数有两个，并且节点定义为<span style=\"color:#fe2c24;\">三叉连结构</span>（左孩子，右孩子，父亲），在二叉链表的基础上加了一个指向父结点的指针域，使得即便于查找孩子结点，又便于查找父结点。接着还需要创建一个变量_bf作为<span style=\"color:#fe2c24;\">平衡因子</span>（<span style=\"color:#956fe7;\">右子树 - 左子树的高度差</span>）。最后写一个构造函数初始化变量即可。</p>\n<pre><code class=\"language-cpp\">//节点类\ntemplate&lt;class K, class V&gt;\nstruct AVLTreeNode\n{\n\t//存储的键值对\n\tpair&lt;K, V&gt; _kv;\n\t//三叉连结构\n\tAVLTreeNode&lt;K, V&gt;* _left;//左孩子\n\tAVLTreeNode&lt;K, V&gt;* _right;//右孩子\n\tAVLTreeNode&lt;K, V&gt;* _parent;//父亲\n\t//平衡因子_bf\n\tint _bf;//右子树 - 左子树的高度差\n\t//构造函数\n\tAVLTreeNode(const pair&lt;K, V&gt;&amp; kv)\n\t\t:_kv(kv)\n\t\t, _left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _bf(0)\n\t{}\n};</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"4%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6\">4、基本框架</h3>\n<blockquote>\n<p>此部分内容为AVL树的类，主要作用是来完成后续的<span style=\"color:#956fe7;\">插入旋转删除……</span>操作：</p>\n<pre><code class=\"language-cpp\">//AVL树的类\ntemplate&lt;class K, class V&gt;\nclass AVLTree\n{\n\ttypedef AVLTreeNode&lt;K, V&gt; Node;\npublic:\n    //……\nprivate:\n\tNode* _root;\n};</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"5%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5\">5、AVL树的插入</h3>\n<blockquote>\n<p>插入主要分为这几大步骤：</p>\n<ul><li>1、一开始为空树，直接new新节点</li><li>2、一开始非空树，寻找插入的合适位置</li><li>3、找到插入的合适位置后，进行父亲与孩子的双向链接</li><li>4、更新新插入的节点祖先的平衡因子</li><li>5、针对不合规的平衡因子进行旋转调整</li></ul>\n<p>接下来对其进行逐个分析：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、一开始为空树，直接new新节点：</span></li></ul>\n<p>因为树为空的，所以直接new一个新插入的节点，将其作为根_root即可，接着更新平衡因子_bf为0，最后返回true。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、一开始非空树，寻找插入的合适位置：</span></li></ul>\n<p>这里和二叉搜索树的寻找合适的插入位置的思想一样，都要遵循以下几步：</p>\n<ol><li>插入的值 &gt; 节点的值，更新到右子树查找</li><li>插入的值 &lt; 节点的值，更新到左子树查找</li><li>插入的值 = 节点的值，数据冗余插入失败，返回false</li></ol>\n<p>当<span style=\"color:#956fe7;\">循环结束的时候，就说明已经找到插入的合适位置</span>，即可进行下一步链接。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">3、找到插入的合适位置后，进行父亲与孩子的双向链接：</span></li></ul>\n<p>注意这里节点的构成为三叉链，因此最后链接后端孩子和父亲是双向链接，具体操作如下：</p>\n<ol><li>插入的值 &gt; 父亲的值，把插入的值链接在父亲的右边</li><li>插入的值 &lt; 父亲的值，把插入的值链接在父亲的左边</li><li>因为是三叉连，插入后记得双向链接（孩子链接父亲）</li></ol>\n<p>走到这，说明节点已经插入完毕，但是接下来就要更新平衡因子了</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">4、更新新插入的节点祖先的平衡因子：</span></li></ul>\n<p>当我们插入新节点后，子树的高度可能会发生变化，针对这一变化，我们给出以下要求：</p>\n<ol><li>子树的高度变了，就要继续往上更新</li><li>子树的高度不变，则更新完成</li><li>子树违反平衡规则（平衡因子的绝对值 &gt;= 2），则停止更新，需要旋转子树进行调整</li></ol>\n<p>具体的更新规则如下：</p>\n<ol><li>新增结点在parent的<span style=\"color:#956fe7;\">右边</span>，parent的平衡因子<span style=\"color:#956fe7;\">++</span></li><li>新增结点在parent的<span style=\"color:#956fe7;\">左边</span>，parent的平衡因子 <span style=\"color:#956fe7;\">--</span></li></ol>\n<p>每更新完一个节点的平衡因子后，都要进行如下判断：</p>\n<ol><li>如果parent的平衡因子等于-1或者1（说明原先是<span style=\"color:#956fe7;\">0</span>，左右登高，插入节点后使左子树或右子树增高了）。表明还需要<span style=\"color:#fe2c24;\">继续往上更新平衡因子</span>。</li><li>如果parent的平衡因子等于0（说明原先是<span style=\"color:#956fe7;\">1或-1</span>，一高一低，插入节点后<span style=\"color:#956fe7;\">填上了矮的那一方</span>）表明<span style=\"color:#fe2c24;\">无需更新平衡因子</span>了。</li><li>如果parent的平衡因子等于-2或者2（说明原先是<span style=\"color:#956fe7;\">1或-1</span>，一高一低，插入节点后<span style=\"color:#956fe7;\">填上了高的那一方</span>），表明此时以parent结点为根结点的子树<span style=\"color:#956fe7;\">已经不平衡了</span>，<span style=\"color:#fe2c24;\">需要进行旋转处理</span>。</li></ol>\n<p>图示如下：</p>\n<p><img alt=\"\" height=\"486\" src=\"..\\..\\static\\image\\b43656bbe46e4b04b8baa60fe51acdc6.png\" width=\"1002\"/></p>\n<ul><li><span style=\"background-color:#fbd4d0;\">5、针对不合规的平衡因子进行旋转调整：</span></li></ul>\n<p>当父亲parent的平衡因子为2或-2时，就要进行旋转调整了，而又要分为以下4类进行旋转：</p>\n<ol><li>当parent的平衡因子为2，cur的平衡因子为1时，进行左单旋。</li><li>当parent的平衡因子为-2，cur的平衡因子为-1时，进行右单旋</li><li>当parent的平衡因子为-2，cur的平衡因子为1时，进行左右双旋。</li><li>当parent的平衡因子为2，cur的平衡因子为-1时，进行右左双旋。</li></ol>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">//Insert插入\nbool Insert(const pair&lt;K, V&gt;&amp; kv)\n{\n\t//1、一开始为空树，直接new新节点\n\tif (_root == nullptr)\n\t{\n\t\t//如果_root一开始为空树，直接new一个kv的节点，更新_root和_bf\n\t\t_root = new Node(kv);\n\t\t_root-&gt;_bf = 0;\n\t\treturn true;\n\t}\n\t//2、寻找插入的合适位置\n\tNode* cur = _root;//记录插入的位置\n\tNode* parent = nullptr;//保存parent为cur的父亲\n\twhile (cur)\n\t{\n\t\tif (cur-&gt;_kv.first &lt; kv.first)\n\t\t{\n\t\t\t//插入的值 &gt; 节点的值\n\t\t\tparent = cur;\n\t\t\tcur = cur-&gt;_right;//更新到右子树查找\n\t\t}\n\t\telse if (cur-&gt;_kv.first &gt; kv.first)\n\t\t{\n\t\t\t//插入的值 &lt; 节点的值\n\t\t\tparent = cur;\n\t\t\tcur = cur-&gt;_left;//更新到左子树查找\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//插入的值 = 节点的值，数据冗余插入失败，返回false\n\t\t\treturn false;\n\t\t}\n\t}\n\t//3、找到了插入的位置，进行父亲与插入节点的链接\n\tcur = new Node(kv);\n\tif (parent-&gt;_kv.first &lt; kv.first)\n\t{\n\t\t//插入的值 &gt; 父亲的值，链接在父亲的右边\n\t\tparent-&gt;_right = cur;\n\t}\n\telse\n\t{\n\t\t//插入的值 &lt; 父亲的值，链接在父亲的左边\n\t\tparent-&gt;_left = cur;\n\t}\n\t//因为是三叉连，插入后记得双向链接（孩子链接父亲）\n\tcur-&gt;_parent = parent;\n\t//4、更新新插入节点的祖先的平衡因子\n\twhile (parent)//最远要更新到根\n\t{\n\t\tif (cur == parent-&gt;_right)\n\t\t{\n\t\t\tparent-&gt;_bf++;//新增结点在parent的右边，parent的平衡因子++\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent-&gt;_bf--;//新增结点在parent的左边，parent的平衡因子 --\n\t\t}\n\t\t//判断是否继续更新？\n\t\tif (parent-&gt;_bf == 0)// 1 or -1 -&gt; 0 填上了矮的那一方\n\t\t{\n\t\t\t//1 or -1 -》 0 填上了矮的那一方，此时正好，无需更新\n\t\t\tbreak;\n\t\t}\n\t\telse if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)\n\t\t{\n\t\t\t//0 -》 1或-1  此时说明插入节点导致一边变高了，继续更新祖先\n\t\t\tcur = cur-&gt;_parent;\n\t\t\tparent = parent-&gt;_parent;\n\t\t}\n\t\telse if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)\n\t\t{\n\t\t\t//1 or -1 -》2或-2 插入节点导致本来高的一边又变更高了\n\t\t\t//此时子树不平衡，需要进行旋转\n\t\t\tif (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)\n\t\t\t{\n\t\t\t\tRotateL(parent);//右边高，左单旋\n\t\t\t}\n\t\t\telse if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)\n\t\t\t{\n\t\t\t\tRotateR(parent);//左边高，右单旋\n\t\t\t}\n\t\t\telse if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1)\n\t\t\t{\n\t\t\t\tRotateLR(parent);//左右双旋\n\t\t\t}\n\t\t\telse if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1)\n\t\t\t{\n\t\t\t\tRotateRL(parent);//右左双旋\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//插入之前AVL树就存在不平衡树，|平衡因子| &gt;= 2的节点\n\t\t\t//实际上根据前面的判断不可能走到这一步，不过这里其实是为了检测先前的插入是否存在问题\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn true;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"6%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC\">6、AVL树的旋转</h3>\n<blockquote>\n<p>AVL树的旋转分为4种：</p>\n<ol><li>左单旋</li><li>右单旋</li><li>左右双旋</li><li>右左双旋</li></ol>\n<p>AVL树的旋转要遵循下面两个原则：</p>\n<ul><li>1、保持搜索树的规则</li><li>2、子树变平衡</li></ul>\n</blockquote>\n<hr/>\n<h3 id=\"%E5%B7%A6%E5%8D%95%E6%97%8B\">左单旋</h3>\n<blockquote>\n<ul><li>条件：<span style=\"color:#fe2c24;\">新节点插入较高右子树的右侧</span></li></ul>\n<p>图示：</p>\n<p><img alt=\"\" height=\"331\" src=\"..\\..\\static\\image\\f96cd4787d1240b998c431d01ee1d9b8.png\" width=\"836\"/></p>\n<p>鉴于左单旋的情况非常多，这里我们画一张抽象图来演示：</p>\n<p><img alt=\"\" height=\"243\" src=\"..\\..\\static\\image\\e0a6290a80e2485893c6577ebad80e97.png\" width=\"1004\"/></p>\n<p>这里的长方形条（<span style=\"color:#fe2c24;\">a、b、c</span>）<span style=\"color:#fe2c24;\">表示的是子树</span>，<span style=\"color:#fe2c24;\">h为子树的高度</span>，而30和60为实打实的节点。上述左单旋操作主要是完成了四件事：</p>\n<ol><li>让subRL变成parent的右子树，更新subRL的父亲为parent</li><li>让subR变成根节点</li><li>让parent变成subR的左子树，更新parent的父亲为subR</li><li>更新平衡因子</li></ol>\n<p><span style=\"color:#0d0016;\"><strong>注意：</strong></span></p>\n<ol><li><span style=\"color:#fe2c24;\">parent可能为整棵树的一个子树</span>，则<span style=\"color:#0d0016;\">需要</span><span style=\"color:#fe2c24;\">链接parent的父亲和subR</span>。</li><li><span style=\"color:#956fe7;\">subRL可能为空</span>，但是更新subRL的父亲为parent是建立在subRL<span style=\"color:#956fe7;\">不为空</span>的前提下完成的。</li></ol>\n<p>解释为何上述左单旋的可行性：</p>\n<ul><li>首先，根据底层二叉搜索树的结构：b节点的值肯定是在30~60之间的，b去做30的右子树没有任何问题，且这里把60挪到根部，随即把30作为60的右子树，这样整体的变化就像是一个左旋一样，而且也满足二叉搜索树的性质且均平衡。</li></ul>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">void RotateL(Node* parent)\n{\n\tNode* subR = parent-&gt;_right;\n\tNode* subRL = subR-&gt;_left;\n\tNode* ppNode = parent-&gt;_parent;//提前保持parent的父亲\n\t//1、建立parent和subRL之间的关系\n\tparent-&gt;_right = subRL;\n\tif (subRL)//防止subRL为空\n\t{\n\t\tsubRL-&gt;_parent = parent;\n\t}\n\t//2、建立subR和parent之间的关系\n\tsubR-&gt;_left = parent;\n\tparent-&gt;_parent = subR;\n\t//3、建立ppNode和subR之间的关系\n\tif (parent == _root)\n\t{\n\t\t_root = subR;\n\t\t_root-&gt;_parent = nullptr;\n\t}\n\telse\n\t{\n\t\tif (parent == ppNode-&gt;_left)\n\t\t{\n\t\t\tppNode-&gt;_left = subR;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tppNode-&gt;_right = subR;\n\t\t}\n\t\tsubR-&gt;_parent = ppNode;//三叉链双向链接关系\n\t}\n\t//4、更新平衡因子\n\tsubR-&gt;_bf = parent-&gt;_bf = 0;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E5%8F%B3%E5%8D%95%E6%97%8B\">右单旋</h3>\n<blockquote>\n<ul><li>条件：<span style=\"color:#fe2c24;\">新节点插入较高左子树的左侧</span></li></ul>\n<p>图示：</p>\n<p><img alt=\"\" height=\"242\" src=\"..\\..\\static\\image\\e4e4c8c58c694d6cb933f3f7e50f7560.png\" width=\"1065\"/></p>\n<p>同样这里的长方形条（<span style=\"color:#fe2c24;\">a、b、c</span>）<span style=\"color:#fe2c24;\">表示的是子树</span>，<span style=\"color:#fe2c24;\">h为子树的高度</span>，而30和60为实打实的节点。上述左单旋操作主要是完成了四件事：</p>\n<ol><li>让subLR变成parent的左子树，更新subLR的父亲为parent</li><li>让subL变成根节点</li><li>让parent变成subL的右子树，更新parent的父亲为subL</li><li>更新平衡因子</li></ol>\n<p><span style=\"color:#0d0016;\"><strong>注意：</strong></span></p>\n<ol><li><span style=\"color:#fe2c24;\">parent可能为整棵树的一个子树</span>，则<span style=\"color:#0d0016;\">需要</span><span style=\"color:#fe2c24;\">链接parent的父亲和subL</span>。</li><li><span style=\"color:#956fe7;\">subLR可能为空</span>，但是更新subLR的父亲为parent是建立在subLR<span style=\"color:#956fe7;\">不为空</span>的前提下完成的。</li></ol>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">//2、右单旋\nvoid RotateR(Node* parent)\n{\n\tNode* subL = parent-&gt;_left;\n\tNode* subLR = subL-&gt;_right;\n\tNode* ppNode = parent-&gt;_parent;\n\t//1、建立parent和subLR之间的关系\n\tparent-&gt;_left = subLR;\n\tif (subLR)\n\t{\n\t\tsubLR-&gt;_parent = parent;\n\t}\n\t//2、建立subL和parent之间的关系\n\tsubL-&gt;_right = parent;\n\tparent-&gt;_parent = subL;\n\t//3、建立ppNode和subL的关系\n\tif (parent == _root)\n\t{\n\t\t_root = subL;\n\t\t_root-&gt;_parent = nullptr;\n\t}\n\telse\n\t{\n\t\tif (parent == ppNode-&gt;_left)\n\t\t{\n\t\t\tppNode-&gt;_left = subL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tppNode-&gt;_right = subL;\n\t\t}\n\t\tsubL-&gt;_parent = ppNode;//三叉链双向关系\n\t}\n\t//4、更新平衡因子\n\tsubL-&gt;_bf = parent-&gt;_bf = 0;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B\">左右双旋</h3>\n<blockquote>\n<ul><li>条件：<span style=\"color:#fe2c24;\">新节点插入较高左子树的右侧</span></li></ul>\n<p>接下来图示解析左右双旋的具体解法。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、插入新节点：</span></li></ul>\n<p><img alt=\"\" height=\"290\" src=\"..\\..\\static\\image\\6b05048f28574d46a5cc34a88d112fcc.png\" width=\"765\"/></p>\n<p>此类模型既不满足左单旋的条件也不满足右单旋的条件，但是我们可以将其组合起来，即<span style=\"color:#956fe7;\">左右双旋</span>（<span style=\"color:#fe2c24;\">先左单旋，再右单旋</span>）的办法重新建立平衡。接下来执行下一步<span style=\"color:#956fe7;\">左单旋</span>：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、以节点30（subL）为旋转点左单旋：</span></li></ul>\n<p><img alt=\"\" height=\"296\" src=\"..\\..\\static\\image\\eca0c7638cc24190a1725447ecf86175.png\" width=\"844\"/></p>\n<p>此时再观察这幅图，这部就是一个妥妥的右单旋模型吗，把60的左子树看成一个整体，此时新插入的<span style=\"color:#956fe7;\">节点即插入较高左子树的左侧</span>，刚好<span style=\"color:#fe2c24;\">符合右单旋的性质</span>，接下来即可进行<span style=\"color:#956fe7;\">右单旋</span>：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">3、以节点90（parent）为旋转点进行右单旋：</span></li></ul>\n<p><img alt=\"\" height=\"296\" src=\"..\\..\\static\\image\\9a24efad22144f208e45edd56a6e99ba.png\" width=\"902\"/></p>\n<p>此时左右双旋已经完成，最后一步为<span style=\"color:#956fe7;\">更新平衡因子</span>，但是更新平衡因子又分如下三类：</p>\n<ul><li>1、当<span style=\"color:#fe2c24;\">subLR原始平衡因子是-1</span>时，<span style=\"color:#956fe7;\">左右双旋</span>后parent、subL、subLR的平衡因子分别更新为<span style=\"color:#956fe7;\">1</span>、<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">0</span>。</li></ul>\n<p><img alt=\"\" height=\"299\" src=\"..\\..\\static\\image\\62b100222ec8499ea5cebe96c6ff5b18.png\" width=\"778\"/></p>\n<ul><li>2、当<span style=\"color:#fe2c24;\">subLR原始平衡因子是1</span>时，<span style=\"color:#956fe7;\">左右双旋</span>后parent、subL、subLR的平衡因子分别更新为<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">-1</span>、<span style=\"color:#956fe7;\">0</span>。</li></ul>\n<p><img alt=\"\" height=\"295\" src=\"..\\..\\static\\image\\fc75be577b934faa8112a24701c5a206.png\" width=\"779\"/></p>\n<ul><li>3、当<span style=\"color:#fe2c24;\">subLR原始平衡因子是0</span>时，<span style=\"color:#956fe7;\">左右双旋</span>后parent、subL、subLR的平衡因子分别更新为<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">0</span>。  </li></ul>\n<p><img alt=\"\" height=\"207\" src=\"..\\..\\static\\image\\c869f0d8311e4f418eecbb0edd639fdf.png\" width=\"774\"/></p>\n<p>这里可以看出唯有subLR平衡因子为0的情况下在进行左右旋转后，三个节点的平衡因子都要更新为0。</p>\n<ul><li>代码如下：</li></ul>\n<pre><code class=\"language-cpp\">//3、左右双旋\nvoid RotateLR(Node* parent)\n{\n\tNode* subL = parent-&gt;_left;\n\tNode* subLR = subL-&gt;_right;\n\tint bf = subLR-&gt;_bf;//提前记录subLR的平衡因子\n\t//1、以subL为根传入左单旋\n\tRotateL(subL);\n\t//2、以parent为根传入右单旋\n\tRotateR(parent);\n\t//3、重新更新平衡因子\n\tif (bf == 0)\n\t{\n\t\tparent-&gt;_bf = 0;\n\t\tsubL-&gt;_bf = 0;\n\t\tsubLR-&gt;_bf = 0;\n\t}\n\telse if (bf == 1)\n\t{\n\t\tparent-&gt;_bf = 0;\n\t\tsubL-&gt;_bf = -1;\n\t\tsubLR-&gt;_bf = 0;\n\t}\n\telse if (bf == -1)\n\t{\n\t\tparent-&gt;_bf = 1;\n\t\tsubL-&gt;_bf = 0;\n\t\tsubLR-&gt;_bf = 0;\n\t}\n\telse\n\t{\n\t\tassert(false);//此时说明旋转前就有问题，检查\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B\">右左双旋</h3>\n<blockquote>\n<ul><li>条件：<span style=\"color:#fe2c24;\">新节点插入较高右子树的左侧</span></li></ul>\n<p>接下来图示解析左右双旋的具体解法。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、插入新节点：</span></li></ul>\n<p><img alt=\"\" height=\"307\" src=\"..\\..\\static\\image\\91ce7bfd398142e49b1f408be483cfb0.png\" width=\"741\"/></p>\n<p>注意这里的新节点插在了较高右子树的左侧，不能用上文的单旋转以及左右旋转，相反而应使用<span style=\"color:#956fe7;\">右左旋转</span>（<span style=\"color:#fe2c24;\">先右单旋</span>，<span style=\"color:#fe2c24;\">再左单旋</span>）来解决，接下来执行下一步右单旋：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、以节点90（subR）为旋转点右单旋：</span></li></ul>\n<p><img alt=\"\" height=\"303\" src=\"..\\..\\static\\image\\1ef2f749e7554e56bb2bda723fc3c54b.png\" width=\"810\"/></p>\n<p>此时再观察这幅图，这部就是一个妥妥的左单旋模型吗，把60的右子树看成一个整体，此时新插入的<span style=\"color:#956fe7;\">节点即插入较高右子树的右侧</span>，刚好<span style=\"color:#fe2c24;\">符合左单旋的性质</span>，接下来即可进行<span style=\"color:#956fe7;\">左单旋</span>：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">3、以节点30（parent）为旋转点左单旋：</span></li></ul>\n<p><img alt=\"\" height=\"302\" src=\"..\\..\\static\\image\\45cc75049d9c40f58c09fe26064709d2.png\" width=\"856\"/></p>\n<p>此时左右双旋已经完成，最后一步为<span style=\"color:#956fe7;\">更新平衡因子</span>，但是更新平衡因子又分如下三类：</p>\n<ul><li>1、当<span style=\"color:#fe2c24;\">subRL原始平衡因子是-1</span>时，<span style=\"color:#956fe7;\">右左双旋</span>后parent、subR、subRL的平衡因子分别更新为<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">1</span>、<span style=\"color:#956fe7;\">0</span>。</li></ul>\n<p><img alt=\"\" height=\"304\" src=\"..\\..\\static\\image\\0438c8d1e60a454295c4e6fc1b6a62f7.png\" width=\"789\"/></p>\n<ul><li>2、当<span style=\"color:#fe2c24;\">subRL原始平衡因子是1</span>时，<span style=\"color:#956fe7;\">右左双旋</span>后parent、subR、subRL的平衡因子分别更新为<span style=\"color:#956fe7;\">-1</span>、<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">0</span>。</li></ul>\n<p><img alt=\"\" height=\"301\" src=\"..\\..\\static\\image\\9b442389e1cb4709a90c7e58c8d8c951.png\" width=\"762\"/></p>\n<ul><li>3、当<span style=\"color:#fe2c24;\">subRL原始平衡因子是0</span>时，<span style=\"color:#956fe7;\">右左双旋</span>后parent、subR、subRL的平衡因子分别更新为<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">0</span>、<span style=\"color:#956fe7;\">0</span>。 </li></ul>\n<p><img alt=\"\" height=\"201\" src=\"..\\..\\static\\image\\ca694fca3bad4e9ea9e0ff40363b9248.png\" width=\"815\"/></p>\n<p>这里可以看出唯有subRL平衡因子为0的情况下在进行左右旋转后，三个节点的平衡因子都要更新为0。</p>\n<ul><li>代码如下：</li></ul>\n<pre><code class=\"language-cpp\">//4、右左双旋\nvoid RotateRL(Node* parent)\n{\n\tNode* subR = parent-&gt;_right;\n\tNode* subRL = subR-&gt;_left;\n\tint bf = subRL-&gt;_bf;//提前记录subLR的平衡因子\n\t//1、以subL为根传入左单旋\n\tRotateR(subR);\n\t//2、以parent为根传入右单旋\n\tRotateL(parent);\n\t//3、重新更新平衡因子\n\tif (bf == 0)\n\t{\n\t\tparent-&gt;_bf = 0;\n\t\tsubR-&gt;_bf = 0;\n\t\tsubRL-&gt;_bf = 0;\n\t}\n\telse if (bf == 1)\n\t{\n\t\tparent-&gt;_bf = -1;\n\t\tsubR-&gt;_bf = 0;\n\t\tsubRL-&gt;_bf = 0;\n\t}\n\telse if (bf == -1)\n\t{\n\t\tparent-&gt;_bf = 0;\n\t\tsubR-&gt;_bf = 1;\n\t\tsubRL-&gt;_bf = 0;\n\t}\n\telse\n\t{\n\t\tassert(false);//此时说明旋转前就有问题，检查\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"7%E3%80%81AVL%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81\">7、AVL树的验证</h3>\n<blockquote>\n<p>AVL树是在二叉搜索树的基础上加入了平衡性的限制，因此要验证AVL树，就是看它<span style=\"color:#fe2c24;\">是否为二叉搜索树</span>，以及<span style=\"color:#fe2c24;\">是否为一颗平衡树</span>。接下来分别讨论：</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、验证其为二叉搜索树：</span></li></ul>\n<p>这里我们只需要进行<span style=\"color:#956fe7;\">中序遍历</span>看看结果是否可得到一个<span style=\"color:#956fe7;\">有序的序列</span>，如果可以则证明是二叉搜索树，而中序遍历的实现非常简单，先前的二叉搜索树的实现已然完成过，这里直接给出代码：</p>\n<pre><code class=\"language-cpp\">//中序遍历的子树\nvoid _InOrder(Node* root)\n{\n\tif (root == nullptr)\n\t\treturn;\n\n\t_InOrder(root-&gt;_left);\n\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; \" \";\n\t_InOrder(root-&gt;_right);\n}\n//中序遍历\nvoid InOrder()\n{\n\t_InOrder(_root);\n\tcout &lt;&lt; endl;\n}</code></pre>\n<p>检测是否为二叉搜索树的代码实现后，接下来开始验证是否为平衡树。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、验证其为平衡树：</span></li></ul>\n<p>规则如下：（递归的思想）</p>\n<ol><li>空树也是平衡树，一开始就要判断</li><li>封装一个专门计算高度的函数（递归计算高度）后续用来计算<span style=\"color:#956fe7;\">高度差</span>（<span style=\"color:#fe2c24;\">平衡因子</span>diff）</li><li>如过<span style=\"color:#fe2c24;\">diff不等于root的平衡因子</span>（root-&gt;_bf），或<span style=\"color:#fe2c24;\">root平衡因子的绝对值超过1</span>，则<span style=\"color:#956fe7;\">一定不是AVL树</span></li><li>继续递归到子树&amp;&amp;右树，直至结束</li></ol>\n<p>代码如下：</p>\n<pre><code class=\"language-cpp\">//验证一棵树是否为平衡树\nbool IsBalanceTree()\n{\n\treturn _IsBalanceTree(_root);\n}\n//判读是否平衡的子树\nbool _IsBalanceTree(Node* root)\n{\n\t//空树也是AVL树\n\tif (nullptr == root)\n\t\treturn true;\n\t//计算root节点的平衡因子diff：即root左右子树的高度差\n\tint leftHeight = _Height(root-&gt;_left);\n\tint rightHeight = _Height(root-&gt;_right);\n\tint diff = rightHeight - leftHeight;\n\t//如果计算出的平衡因子与root的平衡因子不相等，或root平衡因子的绝对值超过1，则一定不是AVL树\n\tif ((abs(diff) &gt; 1))\n\t{\n\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; \"节点平衡因子异常\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\tif (diff != root-&gt;_bf)\n\t{\n\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; \"节点平衡因子与root的平衡因子不等，不符合实际\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t//继续递归检测，直到结束\n\treturn _IsBalanceTree(root-&gt;_left) &amp;&amp; _IsBalanceTree(root-&gt;_right);\n}\n//求高度的子树\nint _Height(Node* root)\n{\n\tif (root == nullptr)\n\t\treturn 0;\n\tint lh = _Height(root-&gt;_left);\n\tint rh = _Height(root-&gt;_right);\n\treturn lh &gt; rh ? lh + 1 : rh + 1;\n}</code></pre>\n<p>综合上述两大步骤的操作即可对一棵树充分的验证是否为AVL树。</p>\n</blockquote>\n<hr/>\n<h3 id=\"8%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE\">8、AVL树的查找</h3>\n<blockquote>\n<p>Find查找函数的思路很简单，定义cur指针从根部开始按如下规则遍历：</p>\n<ol><li>若key值小于当前结点的值，则应该在该结点的左子树当中进行查找。</li><li>若key值大于当前结点的值，则应该在该结点的右子树当中进行查找。</li><li>若key值等于当前结点的值，则查找成功，返回true。</li><li>若遍历一圈cur走到nullptr了说明没有此结点，返回false</li></ol>\n<pre><code class=\"language-cpp\">//Find查找\nbool Find(const K&amp; key)\n{\n\tNode* cur = _root;\n\twhile (cur)\n\t{\n\t\tif (cur-&gt;_key &lt; key)\n\t\t{\n\t\t\tcur = cur-&gt;_right;//若key值大于当前结点的值，则应该在该结点的右子树当中进行查找。\n\t\t}\n\t\telse if (cur-&gt;_key &gt; key)\n\t\t{\n\t\t\tcur = cur-&gt;_left;//若key值小于当前结点的值，则应该在该结点的左子树当中进行查找。\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;//若key值等于当前结点的值，则查找成功，返回true。\n\t\t}\n\t}\n\treturn false;//遍历一圈没找到返回false\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"9%E3%80%81AVL%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\">9、AVL树的删除（了解）</h3>\n<blockquote>\n<p>因为AVL树也是二叉搜索树，主要是三个大思路：</p>\n<ol><li>按二叉搜索树的规则删除</li><li>更新平衡因子</li><li>出现不平衡，需要旋转调整</li></ol>\n<p>只不过与搜索二叉树的删除不同的是，删除节点后的平衡因子需要不断更新，<span style=\"color:#956fe7;\">最差情况下一直要调整到根节点的位置</span>。具体这里就不再实现了，因为着实有点复杂。不过《算法导论》或《数据结构-用面向对象方法与C++描述》殷人昆版这两本书上是有详细的讲解的哈。</p>\n</blockquote>\n<hr/>\n<h3 id=\"10%E3%80%81AVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD\">10、AVL树的性能</h3>\n<blockquote>\n<p>AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即<span style=\"color:#956fe7;\">O(logN)</span>。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：<span style=\"color:#956fe7;\">如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树</span>，<span style=\"color:#fe2c24;\">但一个结构经常修改，就不太适合</span>。</p>\n</blockquote>\n<hr/>\n<h3 id=\"11\">11、源码链接</h3>\n<blockquote>\n<p>链接直达：<a class=\"link-info\" href=\"https://gitee.com/bit-zy/xzy--c/blob/master/AVLTree/AVLTree/AVLTree.h\" title=\"AVL树的模拟实现完整版\">AVL树的模拟实现完整版</a></p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-04 20:37:20", "summary": "目录、底层结构、树的概念、树节点的定义、基本框架、树的插入、树的旋转左单旋右单旋左右双旋右左双旋、树的验证、树的查找、树的删除了解、树的性能、源码链接、底层结构前面对、、、进行了简单的介绍，这几个容器"}