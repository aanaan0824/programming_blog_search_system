{"blogid": "126528484", "writerAge": "码龄4年", "writerBlogNum": "162", "writerCollect": "4567", "writerComment": "2514", "writerFan": "25415", "writerGrade": "6级", "writerIntegral": "8022", "writerName": "fanstuck", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126528484.jpg", "writerRankTotal": "1632", "writerRankWeekly": "25", "writerThumb": "2591", "writerVisitNum": "326419", "blog_read_count": "150", "blog_time": "于 2022-08-26 11:18:14 发布", "blog_title": "一文速学-Python联通调用JAVA的桥梁PyJnius库详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81PyJnius-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81PyJnius\">一、PyJnius</a></p>\n<p id=\"1.%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\">1.下载方式</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%B8%80-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%B8%80\">方法一</a></p>\n<p id=\"%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C\"> 方法二</a></p>\n<p id=\"2.%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96\">2.相关依赖</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95\">二、使用测试</a></p>\n<p id=\"%E4%B8%89%E3%80%81Reflection%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81Reflection%E7%B1%BB\">三、Reflection类</a></p>\n<p id=\"%E5%9B%9B%E3%80%81Reflection%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81Reflection%E5%87%BD%E6%95%B0\">四、Reflection函数</a></p>\n<p id=\"1.jnius.autoclass(name)-toc\" style=\"margin-left:40px;\"><a href=\"#1.jnius.autoclass%28name%29\">1.jnius.autoclass(name)</a></p>\n<p id=\"%C2%A0Python%E4%B8%AD%E7%9A%84Java%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0Python%E4%B8%AD%E7%9A%84Java%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0\"> Python中的Java类实现 </a></p>\n<p id=\"jnius.java_method-toc\" style=\"margin-left:80px;\"><a href=\"#jnius.java_method\">jnius.java_method</a></p>\n<p id=\"Java%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#Java%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F%C2%A0\">Java签名格式 </a></p>\n<p id=\"JVM%E9%80%89%E9%A1%B9%E5%92%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#JVM%E9%80%89%E9%A1%B9%E5%92%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%C2%A0\">JVM选项和类路径 </a></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%3A\">完整使用案例:</a></p>\n<p id=\"%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2\">点关注，防走丢，如有纰漏之处，请留言指教，非常感谢</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_7\"></a>前言</h1>\n<p>最近一直在研究HiveSQL的源码以及ANTLR包的源码，比较无奈的是工程上我还是偏向于使用Pycharm和python编程语言。其实编程语言选择都无所谓只是工具罢了，主要的是其中解析抽象树AST的思想以及方法。但是基础的语法方法需要掌握，比如Python调库以及引用，JAVA的import规则以及jar包的引用。要做成工程化的程序，程序员就必须有一定的工具使用能力，比如anaconda和IDEA的基础使用方法，做HiveSQL血缘分析的时候遇到了很多大坑以及众多BUG报错，对于自身代码能力和解决问题的能力也有一定的成长。好了废话不多说，就让我们来研究如何来使用该库实现相应功能吧。<strong>博主将长期维护自己博客的文章，如有披露错误或者不理解之处请尽情在评论区留下发言</strong>。希望能够帮助到需要掌握该库的各位。</p>\n<hr/>\n<h1 id=\"%E4%B8%80%E3%80%81PyJnius\">一、PyJnius</h1>\n<p>PyJnius库正如文章标题，是一个用于访问Java类的Python库。PyJnius官网：<a href=\"https://pyjnius.readthedocs.io/en/stable/\" title=\"Welcome to Pyjnius — Pyjnius 1.0a1 documentation\">Welcome to Pyjnius — Pyjnius 1.0a1 documentation</a></p>\n<p>github：</p>\n<p><a href=\"https://github.com/kivy/pyjnius\" title=\"GitHub - kivy/pyjnius: Access Java classes from Python\">GitHub - kivy/pyjnius: Access Java classes from Python</a></p>\n<p>PyJnius库主要分为三个部分：</p>\n<ul><li>jnius</li><li>jnius_config</li><li>setup_sdist</li></ul>\n<p>现在的PyJnius库的版本为1.4.2。该库通过JVM虚拟机实现调用。</p>\n<h2 id=\"1.%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\">1.下载方式</h2>\n<h3 id=\"%E6%96%B9%E6%B3%95%E4%B8%80\">方法一</h3>\n<p>直接通过在cmd命令提示符里面输入：</p>\n<pre><code>pip install pyjnius</code></pre>\n<p>但是这种方式很可能由于连接不稳定失败，建议换个源再下载：</p>\n<pre><code>pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyjnius\n</code></pre>\n<p>conda的下载：</p>\n<pre><code>conda install -c conda-forge pyjnius</code></pre>\n<h3 id=\"%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C\"> 方法二</h3>\n<p>直接去Pypi上面下载whl文件也很快，毕竟现在连外网很不稳定，网速很慢。大家可以在本人资源列表上面下载whl匹配版本的文件：</p>\n<p><a href=\"https://download.csdn.net/download/master_hunter/86438210\" title=\"pyjnius-1.4.2-cp37-cp37m-win32.whl-Python文档类资源-CSDN下载\">pyjnius-1.4.2-cp37-cp37m-win32.whl-Python文档类资源-CSDN下载</a></p>\n<p>下载whl文件之后进入cmd上面cd到当前下载的目录下面，pip该文件就好了。</p>\n<h2 id=\"2.%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96\">2.相关依赖</h2>\n<p>由于是调用的JAVA的Class类那肯定需要的依赖比较多，需要安装cython这个库，如果大家有装acaconda的话去环境里面下载就好了，而pyjnius在anaconda里面是没有的，也不知道是不是我版本太低了没有找到。当然网络连接稳定的直接pip就好了，接连的话要在下载一个gcc编译器：</p>\n<pre><code>yum install gcc gcc-++\npip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple cython\n</code></pre>\n<p> 当然自然需要JAVA环境了，需要大家自行下载JDK，我相信这个是个程序员应该都装过，那么JAVA_HOME应该都配置过了，但是这里需要再额外配置一下环境变量PATH，需要找到jvm.dll：</p>\n<pre><code>C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\bin\\server </code></pre>\n<p>其中java的中的bin目录下server里面就有java的jvm.dll文件了。</p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95\">二、使用测试</h1>\n<p>我们可以试试调用JAVA自身的一些类来使用，就类似于python自带的原始库。我建议是如果大家想要使用其他的jar包的话最好是使用pycharm来实现，Jupyter是我主要用的一个编译器但是使用jnius的话config设置路径的话会报错，如果使用pycharm就没有事。</p>\n<pre><code class=\"language-python\">from jnius import autoclass\n\nStack = autoclass('java.util.Stack')\nstack = Stack()\nstack.push('hello world')</code></pre>\n<p><img alt=\"\" height=\"75\" src=\"..\\..\\static\\image\\fe800335d7fd4276852eef0678418550.png\" width=\"339\"/></p>\n<p> 如果返回类型不是Python类型，Pyjnius使用Java反射提供一个新的autoclass（）。</p>\n<pre><code class=\"language-python\">System = autoclass('java.lang.System')\nSystem</code></pre>\n<p><img alt=\"\" height=\"52\" src=\"..\\..\\static\\image\\3db0d39dbca7495e955d4e2400835a95.png\" width=\"376\"/></p>\n<pre><code class=\"language-python\">System.out</code></pre>\n<p><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\83481d5d76e746609ee21699d01a1aed.png\" width=\"1197\"/></p>\n<p> 递归反射可以提供一个Reflection返回的Java对象的适当对象。</p>\n<h1 id=\"%E4%B8%89%E3%80%81Reflection%E7%B1%BB\"><a id=\"2_34\"></a>三、Reflection类</h1>\n<p>用于反映Java类的基。其思想是对这个JavaClass进行子类化，添加一些JavaMethod、JavaStaticMethod，JavaField和JavaStaticField。</p>\n<p>类似这种形式：</p>\n<pre><code class=\"language-python\">from jnius import JavaClass, MetaJavaClass\n\nclass Stack(JavaClass):\n    __javaclass__ = 'java/util/Stack'\n    __metaclass__ = MetaJavaClass</code></pre>\n<ul><li>__metaclass__: 必须设置为MetaJavaClass，否则，声明的所有方法/字段将不会链接到JavaClass。</li><li>__javaclass__:表示Java类名，格式为“org/lang/class”（例如“Java/util/Stack”），而不是“org.lang.class”。</li><li>__javaconstructor__:如果未设置，假设默认构造函数不带参数。否则，它可以是构造函数的所有可能签名的列表。</li></ul>\n<p>例如，字符串java类的反射如下所示：</p>\n<pre><code class=\"language-python\">class String(JavaClass):\n    __javaclass__ == 'java/lang/String'\n    __metaclass__ = MetaJavaClass\n    __javaconstructor__ == (\n        '()V',\n        '(Ljava/lang/String;)V',\n        '([C)V',\n        '([CII)V',\n        # ...\n    )</code></pre>\n<p>  </p>\n<p>还有更多类就不一一详说了，核心类就这三个，更多的类都是基于此衍生出来的</p>\n<h1 id=\"%E5%9B%9B%E3%80%81Reflection%E5%87%BD%E6%95%B0\">四、Reflection函数</h1>\n<h2 id=\"1.jnius.autoclass(name)\">1.jnius.autoclass(name)</h2>\n<p>返回表示从name传递的类的JavaClass。名称必须采用a.b.c格式，而不是a/b/c格式。</p>\n<pre><code class=\"language-python\">from jnius import autoclassQ\nautoclass('java.lang.System')</code></pre>\n<p> <img alt=\"\" height=\"49\" src=\"..\\..\\static\\image\\af20477c99344783852bec1070e146ee.png\" width=\"467\"/></p>\n<p>当JAVA出现了Python的关键字时（例如from、class等）的成员。需要使用getattr（）来访问该成员，然后才能调用它：</p>\n<pre><code class=\"language-python\">from jnius import autoclass\nfunc_from = getattr(autoclass('some.java.Class'),'from')\nfunc_from()</code></pre>\n<p> SomeClass还有一个特例。类文本，可以将其作为SomeClass的结果找到。getClass（）或__javaclass__ python属性中。</p>\n<h2 id=\"%C2%A0Python%E4%B8%AD%E7%9A%84Java%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0\"> Python中的Java类实现 </h2>\n<p>从Python类创建Java类的基础。可以完全用Python实现java接口。<br/> 实际上，将创建一个Python类，它模仿声明的__javainterfaces__列表。当将这个类的实例提供给Java时，Java将只接受它并调用声明的接口方法。在幕后，我们正在捕获调用，并将其重定向到使用声明的Python方法。创建的类将充当Java接口的代理。<br/> 但是需要至少定义__javainterfaces__属性，并使用java_method（）修饰符声明java方法。</p>\n<pre><code class=\"language-python\">from jnius import PythonJavaClass, java_method\n\nclass PythonListIterator(PythonJavaClass):\n    __javainterfaces__ = ['java/util/ListIterator']\n\n    def __init__(self, collection, index=0):\n        super(TestImplemIterator, self).__init__()\n        self.collection = collection\n        self.index = index\n\n    @java_method('()Z')\n    def hasNext(self):\n        return self.index &lt; len(self.collection.data) - 1\n\n    @java_method('()Ljava/lang/Object;')\n    def next(self):\n        obj = self.collection.data[self.index]\n        self.index += 1\n        return obj</code></pre>\n<ul><li>__javainterfaces__:要代理的Java接口列表，格式为“org/lang/Class”（例如“Java/util/Iterator”），而不是“org.lang.Class”。</li><li>__javacontext__:指示要使用的类加载器，“系统”或“应用程序”。默认值为“系统”。</li></ul>\n<h3 id=\"jnius.java_method\">jnius.java_method</h3>\n<p>与PythonJavaClass一起使用的装饰函数。java_signature必须与接口的所需签名匹配。默认情况下，方法的名称将是Python方法的名称。如果多个签名具有相同的Java方法名，仍然可以强制执行。</p>\n<pre><code class=\"language-python\">class PythonListIterator(PythonJavaClass):\n    __javainterfaces__ = ['java/util/ListIterator']\n\n    @java_method('()Ljava/lang/Object;')\n    def next(self):\n        obj = self.collection.data[self.index]\n        self.index += 1\n        return obj</code></pre>\n<h2 id=\"Java%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F%C2%A0\">Java签名格式 </h2>\n<p>Java签名有一种特殊的格式，一开始可能很难理解。让我们看看细节。签名的格式为：</p>\n<pre><code class=\"language-python\">(&lt;argument1&gt;&lt;argument2&gt;&lt;...&gt;)&lt;return type&gt;</code></pre>\n<p> 签名任何部分的所有类型都可以是以下类型之一：</p>\n<ul><li>L&lt;java class&gt;; = represent a Java object of the type &lt;java class&gt;</li><li>Z = represent a java/lang/Boolean;</li><li>B = represent a java/lang/Byte;</li><li>C = represent a java/lang/Character;</li><li>S = represent a java/lang/Short;</li><li>I = represent a java/lang/Integer;</li><li>J = represent a java/lang/Long;</li><li>F = represent a java/lang/Float;</li><li>D = represent a java/lang/Double;</li><li>V = represent void, available only for the return type</li></ul>\n<p>所有类型都可以具有[前缀以指示数组。返回类型可以是V或空。</p>\n<pre><code class=\"language-python\">(ILjava/util/List;)V\n-&gt; argument 1 is an integer\n-&gt; argument 2 is a java.util.List object\n-&gt; the method doesn't return anything.\n\n(java.util.Collection;[java.lang.Object;)V\n-&gt; argument 1 is a Collection\n-&gt; argument 2 is an array of Object\n-&gt; nothing is returned\n\n([B)Z\n-&gt; argument 1 is a Byte []\n-&gt; a boolean is returned</code></pre>\n<p> 在Python中实现Java时，Java方法的签名必须匹配。Java提供了一个名为javap的工具来获取任何Java类的签名。例如：</p>\n<pre><code class=\"language-java\">$ javap -s java.util.Iterator\nCompiled from \"Iterator.java\"\npublic interface java.util.Iterator{\npublic abstract boolean hasNext();\n  Signature: ()Z\npublic abstract java.lang.Object next();\n  Signature: ()Ljava/lang/Object;\npublic abstract void remove();\n  Signature: ()V\n}</code></pre>\n<h2 id=\"JVM%E9%80%89%E9%A1%B9%E5%92%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%C2%A0\">JVM选项和类路径 </h2>\n<p>在调用导入JNIU之前需要设置JVM选项，因为它们在VM启动后无法更改。为此，可以：</p>\n<pre><code class=\"language-python\">#antlrtest.py\nimport jnius_config\njnius_config.add_options('-Xms4096m')\njnius_config.set_classpath('./','./jar_package/antlr-3.5.2-complete.jar')\nimport jnius</code></pre>\n<p>其中 ：</p>\n<p>jnius_config.add_options():此选项为Jvm参数：</p>\n<ul><li>-Xms4096m：初始堆内存4g</li><li>-Xmx4096m：最大堆内存4g</li><li>-Xmn1024m：年轻代1g</li><li>-Xss256K：每个线程占用的空间</li><li>-XX:+DisableExplicitGC：禁止显示调用gc</li><li>-XX:MaxTenuringThreshold=15：在年轻代存活次数</li><li>-XX:+UseParNewGC：对年轻代采用多线程并行回收</li><li>-XX:+UseConcMarkSweepGC：年老代采用CMS回收</li><li>-XX:+CMSParallelRemarkEnabled：在使用UseParNewGC 的情况下, 尽量减少 mark 的时间</li><li>-XX:+UseCMSCompactAtFullCollection：在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少</li><li>-XX:LargePageSizeInBytes=128m：指定 Java heap的分页页面大小</li><li>-XX:+UseFastAccessorMethods：get,set 方法转成本地代码</li><li>-XX:+UseCMSInitiatingOccupancyOnly：指示只有在 oldgeneration 在使用了初始化的比例后concurrent collector 启动收集</li><li>-XX:CMSInitiatingOccupancyFraction=70：年老代到达70%进行gc</li><li>-Djava.awt.headless=true ：Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li><li>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/home/gclogs/gc.log：打印日志信息</li></ul>\n<p>jnius_config.set_classpath():JAVAclassPATH，路径可为想要运行的所有jar包。</p>\n<p>如果使用这些函数设置了类路径，它将覆盖任何类路径环境变量。应将多个选项或路径条目作为多个参数提供给add_和set_函数。如果未提供类路径且未设置类路径，则路径默认为“.”。此功能在Android上不可用。</p>\n<h2 id=\"%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%3A\">完整使用案例:</h2>\n<p>pyjnius库的实际内容没有多少，主要是桥梁作用，这里放上一段使用pyjnius来调用JAVAjar包的实际案例：</p>\n<pre><code class=\"language-python\">#antlrtest.py\nimport jnius_config\njnius_config.set_classpath('./','./grammar/hive310/antlr-3.5.2-complete.jar')\nimport jnius\nStringStream = jnius.autoclass('org.antlr.runtime.ANTLRStringStream')\nLexer  = jnius.autoclass('grammar.hive310.HiveLexer')\nTokenStream  = jnius.autoclass('org.antlr.runtime.CommonTokenStream')\n\ncstream = StringStream(\"select * from new_table;\")\ninst = Lexer(cstream)\nts = TokenStream()\nts.setTokenSource(inst)\nts.fill()\n\njlist = ts.getTokens()\ntsize = jlist.size()\nfor i in range(tsize):\n    print(jlist.get(i).getText())\n\n</code></pre>\n<blockquote>\n<p>select<br/>  <br/> *<br/>  <br/> from<br/>  <br/> new_table<br/> ;<br/> &lt;EOF&gt;</p>\n<p>Process finished with exit code 0</p>\n</blockquote>\n<hr/>\n<p> </p>\n<h2 id=\"%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2\">点关注，防走丢，<strong>如有纰漏之处，请留言指教，非常感谢</strong></h2>\n<p>以上就是本期全部内容。我是fanstuck ，有问题大家随时留言讨论 ，我们下期见。</p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-26 11:18:14", "summary": "目录前言一、下载方式方法一方法二相关依赖二、使用测试三、类四、函数中的类实现签名格式选项和类路径完整使用案例点关注，防走丢，如有纰漏之处，请留言指教，非常感谢前言最近一直在研究的源码以及包的源码，比较"}