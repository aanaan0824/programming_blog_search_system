{"blogid": "126698761", "writerAge": "码龄8年", "writerBlogNum": "225", "writerCollect": "1969", "writerComment": "420", "writerFan": "11062", "writerGrade": "7级", "writerIntegral": "14248", "writerName": "A叶子叶", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126698761.jpg", "writerRankTotal": "751", "writerRankWeekly": "2422", "writerThumb": "1117", "writerVisitNum": "1728347", "blog_read_count": "83", "blog_time": "已于 2022-09-05 15:56:09 修改", "blog_title": "SpringBoot实践（三十二）：5分钟搭建springboot单体应用开发框架", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>熟悉语言和开发工具上基础快速使用框架构建应用是个机械工作，5分钟完成开发准备工作，没有冗余动作。</p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%C2%A0\">准备工作 </a></p>\n<p id=\"%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA\">开发框架搭建</a></p>\n<p id=\"%C2%A0spring%E5%88%9D%E5%A7%8B%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0spring%E5%88%9D%E5%A7%8B%E5%8C%96\"> spring初始化</a></p>\n<p id=\"%C2%A0%E5%B8%B8%E8%A7%84%E4%BE%9D%E8%B5%96-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E5%B8%B8%E8%A7%84%E4%BE%9D%E8%B5%96\"> 常规依赖</a></p>\n<p id=\"%C2%A0%C2%A0%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96\">  其他依赖</a></p>\n<p id=\"%E8%A7%84%E8%8C%83%E5%8C%96%E5%BC%80%E5%8F%91-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%A7%84%E8%8C%83%E5%8C%96%E5%BC%80%E5%8F%91\">规范化开发</a></p>\n<p id=\"%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">目录结构</a></p>\n<p id=\"%E4%BE%9D%E8%B5%96%E9%80%82%E9%85%8D-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BE%9D%E8%B5%96%E9%80%82%E9%85%8D\">依赖适配</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8\">代码生成器</a></p>\n<p id=\"%E5%93%8D%E5%BA%94%E4%BD%93%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%93%8D%E5%BA%94%E4%BD%93%E5%B0%81%E8%A3%85\">响应体封装</a></p>\n<p id=\"github%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#github%E4%BB%A3%E7%A0%81\">github代码</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2>准备工作 </h2>\n<p>后端开发需要数据持久化，数据库使用mysql，这也是生产环境大部分的选择，本地开发如果没有mysql可以直接在idea上创建h2数据库，具体创建方式可以参考：<a href=\"https://blog.csdn.net/weixin_42479595/article/details/104464647\" title=\"使用IDEA创建H2数据库_断浮的博客-CSDN博客_idea配置h2数据库\">使用IDEA创建H2数据库_断浮的博客-CSDN博客_idea配置h2数据库</a></p>\n<h2 id=\"%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA\">开发框架搭建</h2>\n<h3 id=\"%C2%A0spring%E5%88%9D%E5%A7%8B%E5%8C%96\"> spring初始化</h3>\n<p><a href=\"https://start.aliyun.com\" title=\"https://start.spring.com\">https://start.spring.com</a> 这个地址实际中不快，改用<a href=\"https://start.aliyun.com\" title=\"https://start.aliyun.com\">https://start.aliyun.com</a> ，选择它好处是：依赖选择时分类，非常的详细，而且生成的maven-pom文件有版本管理（基于统一的spring-boot版本号基础上扩展其他依赖包），不然需要自己分类管理，并且生成的项目中yaml有注释。</p>\n<h3 id=\"%C2%A0%E5%B8%B8%E8%A7%84%E4%BE%9D%E8%B5%96\"> 常规依赖</h3>\n<p>往下走选择这几个组件，作用分别是：</p>\n<blockquote>\n<p>spring web，最主要的依赖，基于spring的web后端开发所有包都会自动引用</p>\n<p>mysql driver 是mysql驱动，如果没有本地mysql，可以使用h2，idea可以创建h2</p>\n<p>spring configuration-processor 依赖写配置文件会有提示；</p>\n<p>lombok 完成自动getter setter 还有hashcode等类处理功能；</p>\n<p>spring-boot-devtools  能提供热部署能力；</p>\n<p>mybatis-plus 完成dao层处理，在mybatis基础上优化，极大简化数据库操作；</p>\n<p>freemarker模板引擎用于mybaits-plus自动代码生成器，默认是velocity</p>\n<p>security用于登录相关用户验证和鉴权；</p>\n<p>Fastjson和commons lang进行是基本的处理包；</p>\n</blockquote>\n<p><img alt=\"\" height=\"675\" src=\"..\\..\\static\\image\\452bb8b445c2435ab9d781e70ad30f68.png\" width=\"954\"/></p>\n<h3 id=\"%C2%A0%C2%A0%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96\">  其他依赖</h3>\n<p>在此基础上增加其他依赖的准则是提高开发效率，让工具更加趁手，根据开发经验最好集成以下几个辅助工具：</p>\n<blockquote>\n<p>swagger2和swagger-ui，两个都必须加，用户接口的梳理和规范化；</p>\n<p>swagger-boostrap-ui，一个国产的api管理工具，界面更友好；</p>\n<p>mybatis-plus-join，mybatis plus的一个多表关联插件，在写多表查询很简单；</p>\n<p>mybatis-plus-generator，mybatis-plus的代码生成器；</p>\n<p>mybatis-plus-extension，mybatis的分页扩展；</p>\n</blockquote>\n<p>因为我们上面选择的spring-boot的2.3.7，其他依赖是我们手动要增加的，直接在pom中增加：</p>\n<pre><code class=\"language-XML\">       &lt;dependency&gt;\n            &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n            &lt;version&gt;2.4.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n            &lt;version&gt;2.4.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-join&lt;/artifactId&gt;\n            &lt;version&gt;1.2.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.3.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;\n            &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;\n            &lt;version&gt;1.9.5&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--velocity模板引擎--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;\n            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;\n            &lt;version&gt;2.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt;\n            &lt;version&gt;3.4.2&lt;/version&gt;\n        &lt;/dependency&gt;</code></pre>\n<p>到此为止，直接在主类DemoApplication.class上ctrl+shift+F10就可以运行这个工程了，<strong>如果不纠结后续的开发标准化，那么框架搭建就结束了。</strong>纯粹的后端开发是很简单的，如果在别人规划基础上搞开发，就是机械的写方法和实现。</p>\n<p><img alt=\"\" height=\"284\" src=\"..\\..\\static\\image\\73de96734e1f461baf506c2ed303aaa9.png\" width=\"1200\"/></p>\n<h2 id=\"%E8%A7%84%E8%8C%83%E5%8C%96%E5%BC%80%E5%8F%91\">规范化开发</h2>\n<p>完成搭建和使用还是有很大距离的，目前为止我们没有开发1行代码，工程却可以运行，但必然不是我们想要的运行方式和结果，依赖也没有真正地发挥作用，每个包的使用需要学习成本，比如security集成进来后会为我们分配用户名和密码，如果不进行修改和适配，接口会被拦截，swagger2需要进行拦截器配置才可以自动扫描接口，mybatis的代码生成器也需要进行个性化配置，此部分都可以定义为规范化开发工作。</p>\n<h3 id=\"%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">目录结构</h3>\n<p>目录规划目的是代码管理层面的统一，这个是所有使用的基础：</p>\n<blockquote>\n<p>client：第三方集成和调用，一般用feign</p>\n<p>config：放拦截器比如security，mybatis和swagger都是对Http请求的拦截和处理；</p>\n<p>controller：请求的入口</p>\n<p>entity：POJO类，建议跟数据库对象一一对应，使用mybatis-plus可以绑定表，非常方便；</p>\n<p>framework：次级管理目录，将其他异常，常量，请求体，响应体封装统一放置管理；</p>\n<p>mapper：数据库操作的mapper存放位置；</p>\n<p>service：请求的实现方法；</p>\n<p>utils：工具类，这个地方会存很多通用和专用的工具；</p>\n<p>VO：面向展示层的封装体；</p>\n</blockquote>\n<p> <img alt=\"\" height=\"501\" src=\"..\\..\\static\\image\\d306bc587e08441783986cad49f28a96.png\" width=\"386\"/></p>\n<h3 id=\"%E4%BE%9D%E8%B5%96%E9%80%82%E9%85%8D\">依赖适配</h3>\n<p>目录规划好后，就要进行依赖适配，因为增加的几个依赖包都有各自的最佳实践或者正确使用姿势，具体而言就是security，mybatis-plus和swagger2的拦截配置，security因为要重写很多方法，这里先不详细介绍，可以直接在xml里面配置其登录名和密码，登录后进行其他依赖配置。</p>\n<blockquote>\n<p>spring.security.user.name=root</p>\n<p>spring.security.user.password=123456</p>\n</blockquote>\n<p>关于security框架本身其复杂度高，后续可以参考之前的博客做完整适配：<a href=\"https://blog.csdn.net/yezonggang/article/details/126055197?spm=1001.2014.3001.5501\" title=\"SpringBoot实践（二十六）：Security实现Vue-Element-Admin登录拦截(适合单体应用)_A叶子叶的博客-CSDN博客_springsecurity路由拦截\">SpringBoot实践（二十六）：Security实现Vue-Element-Admin登录拦截(适合单体应用)_A叶子叶的博客-CSDN博客_springsecurity路由拦截</a></p>\n<p>mybatis有分页器和自动填充的配置要自定义，这里也可以不写；swagger2和最定义UI需要进行配置才会生效，swagger2的配置类：</p>\n<pre><code class=\"language-java\">@Configuration\n@EnableSwagger2\npublic class Swagger2 {\n     // 配置扫描的包\n     @Bean\n     public Docket createRestApi() {\n          return new Docket(DocumentationType.SWAGGER_2)\n                   .apiInfo(apiInfo())\n                   .select()\n                   .apis(RequestHandlerSelectors.basePackage(\"com.quick.start.demo.controller\")).paths(PathSelectors.any())\n                   .build();\n     }\n     private ApiInfo apiInfo() {\n          return new ApiInfoBuilder()\n                   .title(\"测试Swagger的API.\")\n                   // 创建人信息\n                   .contact(new Contact(\"yzg\",  \"https://blog.csdn.net/yezonggang\",  \"717818895@qq.com\"))\n                   // 版本号\n                   .version(\"2.0\")\n                   // 描述\n                   .description(\"描述\")\n                   .build();\n     }\n}</code></pre>\n<blockquote>\n<p><a href=\"http://localhost:8089/swagger-ui.html\" title=\"http://localhost:8089/swagger-ui.html\">http://localhost:8089/swagger-ui.html</a></p>\n<p><a href=\"http://localhost:8089/doc.html\" title=\"http://localhost:8089/doc.html\">http://localhost:8089/doc.html</a></p>\n</blockquote>\n<p>两个UI界面的对比如下： </p>\n<p><img alt=\"\" height=\"118\" src=\"..\\..\\static\\image\\e502358b0efe4bc5b1c9b4362b9494a1.png\" width=\"238\"/><img alt=\"\" height=\"145\" src=\"..\\..\\static\\image\\39c2eec2e1c74a2fa307eb6079769431.png\" width=\"391\"/></p>\n<p></p>\n<h3 id=\"%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8\">代码生成器</h3>\n<p>mybatis-plus代码生成器单独讲因为这个工具能够节省很多时间，在进行项目开发前关系库应该首先被设计出来，也就是表结构，按照范式要求进行设计后代码开发，表对应entity，mapper映射和实现类都可以被mp标准化输出；</p>\n<pre><code class=\"language-java\">package com.quick.start.demo;\nimport com.baomidou.mybatisplus.annotation.DbType;\nimport com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;\nimport com.baomidou.mybatisplus.core.toolkit.StringPool;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\nimport com.baomidou.mybatisplus.generator.config.*;\nimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\nimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\nimport org.apache.commons.lang3.StringUtils;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass CodeGeneratorTest {\n    public static final String FILE_NAME_MODEL = \"%sEntity\";\n\n    public static String scanner(String tip) {\n        Scanner scanner = new Scanner(System.in);\n        StringBuilder help = new StringBuilder();\n        help.append(\"请输入\" + tip + \"：\");\n        System.out.println(help.toString());\n        if (scanner.hasNext()) {\n            String ipt = scanner.next();\n            if (StringUtils.isNotBlank(ipt)) {\n                return ipt;\n            }\n        }\n        throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\");\n    }\n    public static void main(String[] args) {\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        // 不改\n        String projectPath = System.getProperty(\"user.dir\");\n        gc.setOutputDir(projectPath + \"/src/main/java\");\n        gc.setAuthor(\"yzg\");\n        gc.setOpen(false);\n        // 支持swagger2\n        gc.setSwagger2(true);\n        // pojo类后接Entity\n        gc.setEntityName(\"%sEntity\");\n        gc.setFileOverride(true);\n        gc.setEnableCache(true);\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(\"jdbc:mysql://10.10.10.10:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8\");\n        dsc.setSchemaName(\"security\");\n        dsc.setDbType(DbType.MYSQL);\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        dsc.setUsername(\"root\");\n        dsc.setPassword(\"1q2w!Q@W\");\n        mpg.setDataSource(dsc);\n\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        //pc.setModuleName(scanner(\"模块名\"));\n        pc.setParent(\"com.quick.start.demo\");\n        mpg.setPackageInfo(pc);\n\n        // 自定义配置\n        InjectionConfig cfg = new InjectionConfig() {\n            @Override\n            public void initMap() {\n                // to do nothing\n            }\n        };\n\n        // 如果模板引擎是 freemarker\n        String templatePath = \"/templates/mapper.xml.ftl\";\n        // 如果模板引擎是 velocity\n        //String templatePath = \"/templates/mapper.xml.vm\";\n\n        // 自定义输出配置\n        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();\n        // 自定义配置会被优先输出\n        focList.add(new FileOutConfig(templatePath) {\n            @Override\n            public String outputFile(TableInfo tableInfo) {\n                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                return projectPath + \"/src/main/resources/mapper/\"\n                        + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\n            }\n        });\n\n\n        cfg.setFileOutConfigList(focList);\n        mpg.setCfg(cfg);\n\n        // 配置模板\n        TemplateConfig templateConfig = new TemplateConfig();\n\n        templateConfig.setXml(null);\n        mpg.setTemplate(templateConfig);\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setNaming(NamingStrategy.underline_to_camel);// 表名生成策略\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n        //strategy.setSuperEntityClass(\"你自己的父类实体,没有就不用设置!\");\n        strategy.setEntityLombokModel(true);\n        strategy.setRestControllerStyle(true);\n        // 公共父类\n        //strategy.setSuperControllerClass(\"你自己的父类控制器,没有就不用设置!\");\n        // 写于父类中的公共字段\n        //strategy.setSuperEntityColumns(\"id\");\n        //strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\n        strategy.setControllerMappingHyphenStyle(true);\n        // 根据表名的_下划线命名成类名\n        strategy.setTablePrefix(pc.getModuleName() + \"_\");\n        strategy.setInclude(\"role\"); // 需要生成的表\n        //strategy.setExclude(new String[]{\"test\"}); // 排除生成的表\n        // 开启tableFileld就是表名对应关系\n        strategy.setEntityTableFieldAnnotationEnable(true);\n        //strategy.setTablePrefix(new String[] { \"SYS_\" });// 此处可以修改为您的表前缀\n        strategy.setEntityLombokModel(true);\n        //strategy.setCapitalMode(true);// 全局大写命名 ORACLE 注意\n        strategy.setEnableSqlFilter(true);\n        mpg.setStrategy(strategy);\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n        mpg.execute();\n    }\n\n}</code></pre>\n<p>代码自动化生成，非常地便利： </p>\n<p><img alt=\"\" height=\"591\" src=\"..\\..\\static\\image\\63b35dba78b84734a85a2caecc570b0d.png\" width=\"299\"/></p>\n<p> 以RoleEntity.class为例：</p>\n<pre><code class=\"language-java\">@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\n@TableName(\"role\")\n@ApiModel(value=\"RoleEntity对象\", description=\"\")\npublic class RoleEntity implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Long id;\n\n    @TableField(\"name\")\n    private String name;\n\n    @TableField(\"code\")\n    private String code;\n\n    @TableField(\"des\")\n    private String des;\n    \n}</code></pre>\n<h3 id=\"%E5%93%8D%E5%BA%94%E4%BD%93%E5%B0%81%E8%A3%85\">响应体封装</h3>\n<p>响应体建议要封装一层，因为直接返回dataHttpServletResponse是不符合生产规范的，提前捕获，定义，返回正常或有问题的数据才是规范的；</p>\n<pre><code class=\"language-java\">@Data\n@NoArgsConstructor\npublic class ResponseData implements Serializable {\n    private final static String SUCCESS = \"success\";\n    private final static String ERROR = \"error\";\n    private final static String WARN = \"warn\";\n\n    private  int code;\n    private  String msg ;\n    private  Object data;\n\n    public ResponseData(int code, String msg, Object data) {\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    }\n\n    public ResponseData(String msg, Object data) {\n        this.msg = msg;\n        this.data = data;\n    }\n\n    public static ResponseData success(Object data){\n        return new ResponseData(200,SUCCESS,data);\n    }\n    public static ResponseData fail(Object data){\n        return new ResponseData(200,ERROR,data);\n    }\n    public static ResponseData fail(ApiError apiError){\n        return new ResponseData(apiError.getErrorCode(),apiError.getErrorMsg(),apiError.getErrorName());\n    }\n}</code></pre>\n<h2 id=\"github%E4%BB%A3%E7%A0%81\">github代码</h2>\n<p><a href=\"https://github.com/yezonggang/demo20220905real\" title=\"GitHub - yezonggang/demo20220905real: 最新整理的spirngboot开发脚手架，开发框架\">GitHub - yezonggang/demo20220905real: 最新整理的spirngboot开发脚手架，开发框架</a></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-09-05 15:56:09", "summary": "熟悉语言和开发工具上基础快速使用框架构建应用是个机械工作，分钟完成开发准备工作，没有冗余动作。目录准备工作开发框架搭建初始化常规依赖其他依赖规范化开发目录结构依赖适配代码生成器响应体封装代码准备工作后"}