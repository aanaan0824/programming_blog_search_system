{"blogid": "126441795", "writerAge": "码龄3年", "writerBlogNum": "85", "writerCollect": "2338", "writerComment": "2028", "writerFan": "4581", "writerGrade": "6级", "writerIntegral": "6215", "writerName": "赵四司机", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126441795.jpg", "writerRankTotal": "2434", "writerRankWeekly": "19", "writerThumb": "2058", "writerVisitNum": "204089", "blog_read_count": "5803", "blog_time": "已于 2022-08-29 20:47:38 修改", "blog_title": "【Spring Cloud】新闻头条微服务项目：使用Reids延迟队列实现文章定时发布（上）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"8420b26844034fab91b6df661ae68671.png\" src=\"..\\..\\static\\image\\8420b26844034fab91b6df661ae68671.png\"/></p>\n<p><strong>个人简介： </strong></p>\n<blockquote>\n<p>&gt; 📦个人主页：<a class=\"link-info\" href=\"https://blog.csdn.net/weixin_45750572?type=blog\" title=\"赵四司机\">赵四司机</a><br/> &gt; 🏆学习方向：JAVA后端开发 <br/> &gt; ⏰往期文章：<a class=\"link-info\" href=\"https://blog.csdn.net/weixin_45750572/article/details/125534014\" title=\"SpringBoot项目整合微信支付\">SpringBoot项目整合微信支付</a><br/> &gt; 🔔博主推荐网站：<a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_zssj_sf\" title=\"牛客网 刷题|面试|找工作神器\">牛客网 刷题|面试|找工作神器</a><br/> &gt; 📣种一棵树最好的时间是十年前，其次是现在！<br/> &gt; 💖喜欢的话麻烦点点关注喔，你们的支持是我的最大动力。</p>\n</blockquote>\n<p><strong>前言：</strong></p>\n<blockquote>\n<p>最近在做一个基于SpringCloud+Springboot+Docker的新闻头条微服务项目，用的是黑马的教程，现在项目开发进入了尾声，我打算通过写文章的形式进行梳理一遍，并且会将梳理过程中发现的Bug进行修复，有需要改进的地方我也会继续做出改进。这一系列的文章我将会放入微服务项目专栏中，这个项目适合刚接触微服务的人作为练手项目，假如你对这个项目感兴趣你可以订阅我的专栏进行查看，需要资料可以私信我，当然要是能给我点个小小的关注就更好了，你们的支持是我最大的动力。</p>\n<p>如果你想要一个可以系统学习的网站，那么我推荐的是牛客网，个人感觉用着还是不错的，页面很整洁，而且内容也很全面，语法练习，算法题练习，面试知识汇总等等都有，论坛也很活跃，传送门链接：<a href=\"https://www.nowcoder.com/link/pc_csdncpt_zssj_sf\" title=\"牛客刷题神器\">牛客刷题神器</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E4%B8%80%EF%BC%9A%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%EF%BC%9A%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87\">一：前期准备</a></p>\n<p id=\"1.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90\">1.需求分析</a></p>\n<p id=\"2.%20%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0\">2. 延迟任务概述</a></p>\n<p id=\"3.%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94\">3.技术对比</a></p>\n<p id=\"DelayQueue-toc\" style=\"margin-left:80px;\"><a href=\"#DelayQueue\">DelayQueue</a></p>\n<p id=\"RabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#RabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1\">RabbitMQ实现延迟任务</a></p>\n<p id=\"Redis%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#Redis%E5%AE%9E%E7%8E%B0\">Redis实现</a></p>\n<p id=\"4.%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\">4.实现思路</a></p>\n<p id=\"%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\">二：环境搭建</a></p>\n<p id=\"1.%E6%90%AD%E5%BB%BA%E6%A8%A1%E5%9D%97-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%90%AD%E5%BB%BA%E6%A8%A1%E5%9D%97\">1.搭建模块</a></p>\n<p id=\"2.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%86%E5%A4%87%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%86%E5%A4%87%C2%A0\">2.数据库准备 </a></p>\n<p id=\"%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.%E5%9C%A8docker%E4%B8%AD%E5%AE%89%E8%A3%85redis-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.%E5%9C%A8docker%E4%B8%AD%E5%AE%89%E8%A3%85redis\"> ​编辑 3.在docker中安装redis</a></p>\n<p id=\"4.%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90redis-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90redis\">4.项目中集成redis</a></p>\n<p id=\"%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99\">三：代码编写</a></p>\n<p id=\"1.%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%AF%BC%E5%85%A5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%AF%BC%E5%85%A5\">1.实体类导入</a></p>\n<p id=\"2.%E5%88%9B%E5%BB%BAtaskService-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%88%9B%E5%BB%BAtaskService\">2.创建taskService</a></p>\n<p id=\"3.%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\">3.功能实现</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%EF%BC%9A%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87\">一：前期准备</h1>\n<h2 id=\"1.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90\">1.需求分析</h2>\n<p>        当创作者创作好文章之后可以选择立马发布，还能选择定时发布（见下图），这个相信大家在CSDN创作时候都知道，我们需要使用延迟任务来实现文章的定时发布。</p>\n<p><img alt=\"\" height=\"592\" src=\"..\\..\\static\\image\\b5894aa9341f46be96515ccada215975.png\" width=\"484\"/></p>\n<h2 id=\"2.%20%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E6%A6%82%E8%BF%B0\">2. 延迟任务概述</h2>\n<p>在介绍延迟任务之前，我们先了解一下定时任务，定时任务就是有固定的的执行频率，每隔一段时间就执行一次，定时任务与延迟任务区别如下：</p>\n<ul><li>定时任务：有固定周期的，有明确的触发时间</li><li> <p>延迟任务：没有固定的开始时间，它常常是由一个事件触发的，而在这个事件触发之后的一段时间内触发另一个事件，任务可以立即执行，也可以延迟。</p> </li><li> <p>延迟任务使用场景：  </p> </li></ul>\n<ol><li> <p>商品下单30分钟之内没有付款则将订单取消</p> </li><li> <p>接口对接出现网络问题，1分钟之后重试，如果再失败则2分钟之后重试，直至达到阈值       </p> </li></ol>\n<h2 id=\"3.%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94\">3.技术对比</h2>\n<ul><li> <h3 id=\"DelayQueue\">DelayQueue</h3> JDK自带DelayQueue 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 PriorityQueue 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。 <p>DelayQueue属于排序队列，它的特殊之处在于队列的元素必须实现Delayed接口，该接口需要实现compareTo和getDelay方法</p> <p>getDelay方法：获取元素在队列中的剩余时间，只有当剩余时间为0时元素才可以出队列。</p> <p>compareTo方法：用于排序，确定元素出队列的顺序。</p> </li></ul>\n<p>        需要注意的是，使用线程池或者原生DelayQueue程序挂掉之后，任务都是放在内存，需要考虑未处理消息的丢失带来的影响，要保证数据不丢失，就需要持久化（磁盘）。</p>\n<p></p>\n<ul><li> <h3 id=\"RabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1\">RabbitMQ实现延迟任务</h3> </li></ul>\n<p>          RabbitMQ实现延迟任务有两种形式，一种是传统的TTL+DLX（死信交换机）来实现，另一种是直接使用插件。TTL+DLX的实现原理是给每个队列设置过期时间，当消息过期之后变成Dead message，就将死信消息发送到另一个交换机，这个交换机叫做死信交换机。 </p>\n<p>        不过更方便的还是直接使用RabbitMQ提供的延迟队列插件比较方便，实践过程可以翻看我前面关于微信支付的文章，里面就是使用了RabbitMQ提供的延迟插件来实现订单的管理。</p>\n<ul><li> <h3 id=\"Redis%E5%AE%9E%E7%8E%B0\">Redis实现</h3> </li></ul>\n<p>          由于项目后面还需要用到Redis缓存热度靠前的文章，所以这里我选择了使用Redis来实现延迟队列，也正好可以了解其实现原理。</p>\n<p>        我们都知道Redis中的ZSet数据类型可以实现对数据的排序，那么我们就可以利用这个特点来实现延迟队列，使用时间戳作为score来进行排序。</p>\n<h2 id=\"4.%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\">4.实现思路</h2>\n<p> <img alt=\"\" height=\"493\" src=\"..\\..\\static\\image\\02b008b35f2949568e53e99038dfdbb0.png\" width=\"1058\"/> </p>\n<p>1.为什么任务需要存储在数据库中？</p>\n<p>延迟任务是一个通用的服务，任何需要延迟得任务都可以调用该服务，需要考虑数据持久化的问题，存储数据库中是一种数据安全的考虑。</p>\n<p>2.为什么redis中使用两种数据类型，list和zset？</p>\n<p>效率问题，算法的时间复杂度</p>\n<p>3.在添加zset数据的时候，为什么不需要预加载？</p>\n<p>任务模块是一个通用的模块，项目中任何需要延迟队列的地方，都可以调用这个接口，要考虑到数据量的问题，如果数据量特别大，为了防止阻塞，只需要把未来几分钟要执行的数据存入缓存即可。</p>\n<h1 id=\"%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\">二：环境搭建</h1>\n<h2 id=\"1.%E6%90%AD%E5%BB%BA%E6%A8%A1%E5%9D%97\">1.搭建模块</h2>\n<p>①在service模块下创建一个tbug-headlines-schedule模块</p>\n<p> <img alt=\"\" height=\"455\" src=\"..\\..\\static\\image\\01254f17737c4a0eb6b6b0f9e6df7c94.png\" width=\"421\"/> </p>\n<p>②添加bootstrap.yml</p>\n<pre><code>server:\n  port: 51701\nspring:\n  application:\n    name: headlines-schedule\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 49.234.52.192:8848\n      config:\n        server-addr: 49.234.52.192:8848\n        file-extension: yml</code></pre>\n<p>③在nacos添加相关配置</p>\n<pre><code class=\"language-XML\">spring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/headlines_schedule?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false\n    username: root\n    password: 440983\n# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置\nmybatis-plus:\n  mapper-locations: classpath*:mapper/*.xml\n  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名\n  type-aliases-package: com.my.model.schedule.pojos</code></pre>\n<h2 id=\"2.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%86%E5%A4%87%C2%A0\">2.数据库准备 </h2>\n<p>taskinfo任务表 </p>\n<p><img alt=\"\" height=\"171\" src=\"..\\..\\static\\image\\40379a927d3349188ab941bd4b6cd48f.png\" width=\"1200\"/></p>\n<p>taksinfo_log任务日志表</p>\n<h2 id=\"%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.%E5%9C%A8docker%E4%B8%AD%E5%AE%89%E8%A3%85redis\"> <img alt=\"\" height=\"206\" src=\"..\\..\\static\\image\\0e5995bbfc0c4e7489258a89d9fc7450.png\" width=\"1200\"/> 3.在docker中安装redis</h2>\n<p>略</p>\n<h2 id=\"4.%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90redis\">4.项目中集成redis</h2>\n<p>①在项目中导入redis依赖</p>\n<pre><code class=\"language-XML\">&lt;!--spring data redis &amp; cache--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;!-- redis依赖commons-pool 这个依赖一定要添加 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>②在nacos添加redis配置信息</p>\n<pre><code class=\"language-XML\">spring:\n  redis:\n    host: 49.234.52.192\n    password: 440983\n    port: 6379</code></pre>\n<p>③拷贝CacheService类到tbug-headlines-common模块下，并添加自动配置</p>\n<pre><code class=\"language-java\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  com.my.common.exception.ExceptionCatch,\\\n  com.my.common.swagger.SwaggerConfiguration,\\\n  com.my.common.swagger.Swagger2Configuration,\\\n  com.my.common.tencentcloud.TextDetection,\\\n  com.my.common.tencentcloud.ImageDetection,\\\n  com.my.common.tess4j.Tess4jClient,\\\n  com.my.common.redis.CacheService,\\</code></pre>\n<h1 id=\"%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99\">三：代码编写</h1>\n<h2 id=\"1.%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%AF%BC%E5%85%A5\">1.实体类导入</h2>\n<p>①创建task类，用于接收添加任务的参数</p>\n<pre><code class=\"language-java\">package com.my.model.schedule.dtos;\n\nimport lombok.Data;\n\nimport java.io.Serializable;\n\n@Data\npublic class Task implements Serializable {\n\n    /**\n     * 任务id\n     */\n    private Long taskId;\n    /**\n     * 类型\n     */\n    private Integer taskType;\n\n    /**\n     * 优先级\n     */\n    private Integer priority;\n\n    /**\n     * 执行id\n     */\n    private long executeTime;\n\n    /**\n     * task参数\n     */\n    private byte[] parameters;\n    \n}</code></pre>\n<p>②创建mapper</p>\n<pre><code class=\"language-java\">package com.my.schedule.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.my.model.schedule.pojos.Taskinfo;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * &lt;p&gt;\n *  Mapper 接口\n * &lt;/p&gt;\n *\n * @author itheima\n */\n@Mapper\npublic interface TaskInfoMapper extends BaseMapper&lt;Taskinfo&gt; {\n\n    List&lt;Taskinfo&gt; queryFutureTime(@Param(\"taskType\")int type, @Param(\"priority\")int priority, @Param(\"future\")Date future);\n}\n</code></pre>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.my.schedule.mapper.TaskInfoMapper\"&gt;\n\n    &lt;select id=\"queryFutureTime\" resultType=\"com.my.model.schedule.pojos.Taskinfo\"&gt;\n        select *\n        from taskinfo\n        where task_type = #{taskType}\n          and priority = #{priority}\n          and execute_time &lt;![CDATA[&lt;]]&gt; #{future,javaType=java.util.Date}\n    &lt;/select&gt;\n\n&lt;/mapper&gt;</code></pre>\n<p></p>\n<pre><code class=\"language-java\">package com.my.schedule.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.my.model.schedule.pojos.TaskinfoLogs;\nimport org.apache.ibatis.annotations.Mapper;\n\n/**\n * &lt;p&gt;\n *  Mapper 接口\n * &lt;/p&gt;\n *\n * @author itheima\n */\n@Mapper\npublic interface TaskInfoLogsMapper extends BaseMapper&lt;TaskinfoLogs&gt; {\n\n}\n</code></pre>\n<h2 id=\"2.%E5%88%9B%E5%BB%BAtaskService\">2.创建taskService</h2>\n<pre><code class=\"language-java\">package com.my.schedule.service;\n\nimport com.my.model.schedule.dtos.Task;\n\n/**\n * 对外访问接口\n */\npublic interface TaskService {\n    /**\n     * 添加任务接口\n     * @param task  任务对象\n     * @return  任务ID\n     */\n    long addTask(Task task);\n\n    /**\n     * 取消任务\n     * @param taskId        任务id\n     * @return              取消结果\n     */\n    boolean cancelTask(long taskId);\n\n    /**\n     * 按照类型和优先级来拉取任务\n     * @param type\n     * @param priority\n     * @return\n     */\n    Task poll(int type,int priority);\n\n}\n</code></pre>\n<h2 id=\"3.%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\">3.功能实现</h2>\n<p> ScheduleConstants常量类</p>\n<pre><code class=\"language-java\">package com.my.model.common.enums;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@Getter\n@AllArgsConstructor\npublic enum TaskTypeEnum {\n\n    NEWS_SCAN_TIME(1001, 1,\"文章定时审核\"),\n    REMOTEERROR(1002, 2,\"第三方接口调用失败，重试\");\n    private final int taskType; //对应具体业务\n    private final int priority; //业务不同级别\n    private final String desc; //描述信息\n}</code></pre>\n<p>TaskServiceImpl</p>\n<pre><code class=\"language-java\">package com.my.schedule.service.serviceImpl;\n\nimport com.alibaba.fastjson.JSON;\nimport com.baomidou.mybatisplus.core.toolkit.Wrappers;\nimport com.my.common.constans.ScheduleConstants;\nimport com.my.common.redis.CacheService;\nimport com.my.model.schedule.dtos.Task;\nimport com.my.model.schedule.pojos.Taskinfo;\nimport com.my.model.schedule.pojos.TaskinfoLogs;\nimport com.my.schedule.mapper.TaskInfoLogsMapper;\nimport com.my.schedule.mapper.TaskInfoMapper;\nimport com.my.schedule.service.TaskService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang.StringUtils;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport javax.annotation.PostConstruct;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\n@Slf4j\n@Service\n@Transactional\npublic class TaskServiceImpl implements TaskService {\n    /**\n     * 添加延迟任务\n     * @param task  任务对象\n     * @return\n     */\n    @Override\n    public long addTask(Task task) {\n        //1.将任务添加到数据库中\n        boolean success = addTaskToDb(task);\n\n        if(success) {\n            //2.将任务添加到redis\n            addTaskToCache(task);\n        }\n        return task.getTaskId();\n    }\n\n    @Autowired\n    private TaskInfoMapper taskInfoMapper;\n    @Autowired\n    private TaskInfoLogsMapper taskInfoLogsMapper;\n    /**\n     * 将任务添加到数据库中\n     * @param task\n     * @return\n     */\n    private boolean addTaskToDb(Task task) {\n        boolean flag = false;\n\n        try {\n            //1.保存任务表\n            Taskinfo taskinfo = new Taskinfo();\n            BeanUtils.copyProperties(task,taskinfo);\n            taskinfo.setExecuteTime(new Date(task.getExecuteTime()));\n            taskInfoMapper.insert(taskinfo);\n\n            //2.设置任务id\n            task.setTaskId(taskinfo.getTaskId());\n\n            //3.保存任务日志数据\n            TaskinfoLogs taskinfoLogs = new TaskinfoLogs();\n            BeanUtils.copyProperties(taskinfo,taskinfoLogs);\n            taskinfoLogs.setVersion(1);\n            taskinfoLogs.setStatus(ScheduleConstants.SCHEDULED);\n            taskInfoLogsMapper.insert(taskinfoLogs);\n\n            flag = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return flag;\n    }\n\n    @Autowired\n    private CacheService cacheService;\n    /**\n     * 将任务添加到redis\n     * @param task\n     */\n    private void addTaskToCache(Task task) {\n        //1.构造key\n        String key = task.getTaskType()+\"_\"+task.getPriority();\n\n        //2.获取5分钟之后的时间 毫秒级\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MINUTE,5);\n        long nextScheduleTime = calendar.getTimeInMillis();\n\n        //3.如果任务执行时间小于等于当前时间，存入list\n        if(task.getExecuteTime() &lt;= System.currentTimeMillis()) {\n            cacheService.lLeftPush(ScheduleConstants.TOPIC + key, JSON.toJSONString(task));\n        } else if(task.getExecuteTime() &lt;= nextScheduleTime) {\n            //4.如果任务执行时间在5分钟之内，存入zSet\n            cacheService.zAdd(ScheduleConstants.FUTURE + key,JSON.toJSONString(task),task.getExecuteTime());\n        }\n    }\n\n    /**\n     * 删除任务\n     * @param taskId      任务id\n     * @return\n     */\n    @Override\n    public boolean cancelTask(long taskId) {\n        boolean flag = false;\n        //1.删除任务并更新日志\n        Task task = UpdateDb(taskId,ScheduleConstants.EXECUTED);\n\n        //2.从Redis中删除任务\n        if(task != null) {\n            removeFromCache(task);\n            log.info(\"删除Redis中的任务成功:{}\",taskId);\n            flag = true;\n        }\n\n        return flag;\n    }\n\n    /**\n     * 从redis中删除任务\n     * @param task\n     */\n    private void removeFromCache(Task task) {\n        String key = task.getTaskType() + \"_\" + task.getPriority();\n\n        if(task.getExecuteTime() &lt;= System.currentTimeMillis()) {\n            log.info(\"删除正要执行的任务...\");\n            cacheService.lRemove(ScheduleConstants.TOPIC + key,0,JSON.toJSONString(task));\n        } else {\n            log.info(\"删除将要执行的任务...\");\n            cacheService.zRemove(ScheduleConstants.FUTURE + key,JSON.toJSONString(task));\n        }\n    }\n\n    /**\n     * 删除任务，更新日志\n     * @param taskId\n     * @param status\n     * @return\n     */\n    private Task UpdateDb(long taskId, int status) {\n        Task task = null;\n        try {\n            //1.删除任务\n            log.info(\"删除数据库中的任务...\");\n            taskInfoMapper.deleteById(taskId);\n\n            //2.更新日志\n            log.info(\"更新任务日志...\");\n            TaskinfoLogs taskinfoLogs = taskInfoLogsMapper.selectById(taskId);\n            taskinfoLogs.setStatus(status);\n            taskInfoLogsMapper.updateById(taskinfoLogs);\n\n            //3.设置返回值\n            task = new Task();\n            BeanUtils.copyProperties(taskinfoLogs,task);\n            task.setExecuteTime(taskinfoLogs.getExecuteTime().getTime());\n        } catch (BeansException e) {\n            throw new RuntimeException(e);\n        }\n\n        return task;\n    }\n\n    /**\n     * 消费任务\n     * @param type  任务类型\n     * @param priority 任务优先级\n     * @return  Task\n     */\n    @Override\n    public Task poll(int type, int priority) {\n        Task task = null;\n        try {\n            String key = type + \"_\" + priority;\n\n            String task_json = cacheService.lRightPop(ScheduleConstants.TOPIC + key);\n            if(StringUtils.isNotBlank(task_json)) {\n                task = JSON.parseObject(task_json,Task.class);\n                //更新数据库\n                UpdateDb(task.getTaskId(),ScheduleConstants.EXECUTED);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"poll task exception\");\n        }\n        return task;\n    }\n}\n</code></pre>\n<p>主要包括添加任务、取消任务、消费任务三个功能。</p>\n<p></p>\n<p>下篇预告：实现数据定时刷新</p>\n<p>友情链接： <a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_zssj_sf\" title=\"牛客网  刷题|面试|找工作神器\">牛客网  刷题|面试|找工作神器</a></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-29 20:47:38", "summary": "个人简介：个人主页：赵四司机赵四司机学习方向：后端开发往期文章：项目整合微信支付项目整合微信支付博主推荐网站：牛客网刷题面试找工作神器牛客网刷题面试找工作神器种一棵树最好的时间是十年前，其次是现在！喜"}