{"blogid": "125085880", "writerAge": "码龄4年", "writerBlogNum": "310", "writerCollect": "797", "writerComment": "37", "writerFan": "74", "writerGrade": "6级", "writerIntegral": "4592", "writerName": "文丑颜不良啊", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125085880.jpg", "writerRankTotal": "4827", "writerRankWeekly": "19082", "writerThumb": "189", "writerVisitNum": "264657", "blog_read_count": "4904", "blog_time": "已于 2022-06-02 20:03:02 修改", "blog_title": "创建线程池的七种方式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>在 Java 语言中，并发编程往往都是通过床架线程池来实现的，而线程池的创建方式也有很多种，每种线程池的创建方式都对应了不同的使用场景。总结来说线程池的创建可以分为两大类：</p>\n<p><strong>通过 Executors 创建</strong></p>\n<p><strong>通过 ThreadPoolExecutor 创建</strong></p>\n<p>以上这两类创建线程池的方式有 7 种具体实现方法，这 7 种方法便是本文要说的创建线程池的七种方式。分别是：</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px;\"><thead><tr><th style=\"text-align:center;vertical-align:middle;\">方法</th><th style=\"text-align:center;vertical-align:middle;\">含义</th></tr></thead><tbody><tr><td style=\"text-align:center;vertical-align:middle;\">Executors.newFixedThreadPool()</td><td style=\"text-align:center;vertical-align:middle;\">创建一个大小固定的线程池，可控制并发的线程数，超出的线程会在队列中等待</td></tr><tr><td style=\"text-align:center;vertical-align:middle;\">Executors.newCachedThreadPool()</td><td style=\"text-align:center;vertical-align:middle;\">创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程</td></tr><tr><td style=\"text-align:center;vertical-align:middle;\">Executors.newSingleThreadExecutor()</td><td style=\"text-align:center;vertical-align:middle;\">创建单个线程的线程池，可以保证先进先出的执行顺序</td></tr><tr><td style=\"text-align:center;vertical-align:middle;\">Executors.newScheduledThreadPool()</td><td style=\"text-align:center;vertical-align:middle;\">创建一个可以执行延迟任务的线程池</td></tr><tr><td style=\"text-align:center;vertical-align:middle;\">Executors.newSingleThreadScheduledExecutor()</td><td style=\"text-align:center;vertical-align:middle;\">创建一个单线程的可以执行延迟任务的线程池</td></tr><tr><td style=\"text-align:center;vertical-align:middle;\">Executors.newWorkStealingPool()</td><td style=\"text-align:center;vertical-align:middle;\">创建一个抢占式执行的线程池</td></tr><tr><td style=\"text-align:center;vertical-align:middle;\">ThreadPoolExecutor()</td><td style=\"text-align:center;vertical-align:middle;\">手动创建线程池，可自定义相关参数</td></tr></tbody></table>\n<p><strong>Executors.newFixedThreadPool()</strong>：创建一个固定大小的线程池，可控制并发的线程数。</p>\n<pre><code class=\"language-java\">public class FixedThreadPoolDemo {\n\n    public static void main(String[] args) {\n\n        // 创建 2 个线程的线程池\n        ExecutorService threadPool = Executors.newFixedThreadPool(2);\n        // 创建任务\n        Runnable runnable = () -&gt; System.out.println(\"任务被执行,线程:\" + Thread.currentThread().getName());\n        // 线程池执行任务(一次添加 8 个任务)\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n        threadPool.execute(runnable);\n    }\n\n}\n</code></pre>\n<p>创建一个具有 2 个线程的线程池，执行 8 个任务，执行结果为：</p>\n<p><img alt=\"\" height=\"235\" src=\"..\\..\\static\\image\\26901836b93e4d6c9a648646074ada65.png\" width=\"647\"/></p>\n<p><strong>Executors.newCachedThreadPool()</strong>：创建一个可缓存的线程池，若线程数超过人物所需，那么多余的线程会被缓存一段时间后再回收，若线程数不够，则会新建线程。</p>\n<pre><code class=\"language-java\">public class CachedThreadPoolDemo {\n\n    public static void main(String[] args) {\n\n        // 创建线程池\n        ExecutorService threadPool = Executors.newCachedThreadPool();\n        // 执行任务\n        for (int i = 0; i &lt; 5; i++) {\n            threadPool.execute(() -&gt; {\n                System.out.println(\"任务被执行,线程:\" + Thread.currentThread().getName());\n            });\n        }\n    }\n\n}</code></pre>\n<p>创建了一个具有 5 个线程的线程池来执行相应的任务。</p>\n<p><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\f0f808acb24545e6a5640cd3551d27ef.png\" width=\"711\"/></p>\n<p><strong>使用场景</strong></p>\n<p>CachedThreadPool 是根据短时间的任务量来决定创建的线程数量的，所以它适合短时间内有突发大量任务的处理场景。</p>\n<p><strong>Executors.newSingleThreadExecutor()</strong>：创建只有单个线程的线程池，可以保证先进先出的顺序。</p>\n<pre><code class=\"language-java\">public class SingleThreadExecutorDemo {\n\n    public static void main(String[] args) {\n\n        // 创建线程池\n        ExecutorService threadPool = Executors.newSingleThreadExecutor();\n        // 执行任务\n        for (int i = 0; i &lt; 10; i++) {\n            int index = i;\n            threadPool.execute(() -&gt; {\n                System.out.println(index + \": 任务被执行: \" + Thread.currentThread().getName());\n            });\n        }\n    }\n\n}\n</code></pre>\n<p><img alt=\"\" height=\"274\" src=\"..\\..\\static\\image\\4198c0e949804b3992f9dd89c3bec2fc.png\" width=\"887\"/></p>\n<p>如果在打印语句下再加一行睡眠的语句，就会看到每个一段时间输出任务被执行的过程~</p>\n<pre><code class=\"language-java\">try {\n    TimeUnit.SECONDS.sleep(1);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}</code></pre>\n<p><strong>Executors.newScheduledThreadPool()</strong>：创建一个可以执行延迟任务的线程池。</p>\n<pre><code class=\"language-java\">public class ScheduledThreadPoolDemo {\n\n    public static void main(String[] args) {\n        // 创建线程池\n        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);\n        // 添加定时执行任务(1s 后执行)\n        System.out.println(\"添加任务,时间:\" + new Date());\n        threadPool.schedule(() -&gt; {\n            System.out.println(\"任务被执行,时间:\" + new Date());\n        }, 2, TimeUnit.SECONDS);\n    }\n\n}</code></pre>\n<p>创建一个延迟 2 秒执行任务的线程池。</p>\n<p><img alt=\"\" height=\"540\" src=\"..\\..\\static\\image\\6e76235ab40f4622899fcaaf183a4c92.png\" width=\"1200\"/></p>\n<p><strong>Executors.newSingleThreadScheduledExecutor()</strong>：创建一个单线程的可以执行延迟任务的线程池。这种线程池可以看做是 ScheduledThreadPool 的单线程版本。</p>\n<pre><code class=\"language-java\">public class SingleThreadScheduledExecutorDemo {\n\n    public static void main(String[] args) {\n        // 创建线程池\n        ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();\n        // 添加定时执行任务(2s 后执行)\n        System.out.println(\"添加任务,时间:\" + new Date());\n        threadPool.schedule(() -&gt; {\n            System.out.println(\"任务被执行,时间:\" + new Date());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n            }\n        }, 2, TimeUnit.SECONDS);\n    }\n\n}</code></pre>\n<p><img alt=\"\" height=\"196\" src=\"..\\..\\static\\image\\1d2ed367531b430b80f8100bfd24f67e.png\" width=\"757\"/></p>\n<p><strong>Executors.newWorkStealingPool()</strong>：创建一个抢占式执行的线程池，执行任务的顺序不确定。需要注意的是此方法是 JDK 1.8 版本新增的，所以 1.8 版本之前的程序中不能使用。</p>\n<pre><code class=\"language-java\">public class WorkStealingPoolDemo {\n\n    public static void main(String[] args) {\n        // 创建线程池\n        ExecutorService threadPool = Executors.newWorkStealingPool();\n        // 执行任务\n        for (int i = 0; i &lt; 10; i++) {\n            final int index = i;\n            threadPool.execute(() -&gt; {\n                System.out.println(index + \" 被执行,线程名:\" + Thread.currentThread().getName());\n            });\n        }\n        // 确保任务执行完成\n        while (!threadPool.isTerminated()) {\n        }\n    }\n\n}\n</code></pre>\n<p>需注意与 SingleThreadExecutor 单个线程的线程池的比较。</p>\n<p><img alt=\"\" height=\"297\" src=\"..\\..\\static\\image\\eacff6cb162d4c13b1642f3d58551e7d.png\" width=\"757\"/></p>\n<p>可以看到，任务的执行顺序并不是确定的，因为这是抢占式的线程池，哪个任务抢到，哪个任务先执行。</p>\n<p><strong>ThreadPoolExecutor()</strong>：这是最原始，也是最推荐的手动创建线程池的方法。创建时支持自定义某些属性，比如核心线程数、最大线程数等。</p>\n<pre><code class=\"language-java\">public class ThreadPoolExecutorDemo {\n\n    public static void main(String[] args) {\n\n        // 创建线程池\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10, 100, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(10));\n        // 执行任务\n        for (int i = 0; i &lt; 10; i++) {\n            final int index = i;\n            threadPool.execute(() -&gt; {\n                System.out.println(index + \" 被执行,线程名:\" + Thread.currentThread().getName());\n            });\n        }\n    }\n\n}</code></pre>\n<p>创建一个具有 10 个核心线程、最大线程数为 10 的线程池。具体可设置的参数请参考：<a href=\"https://blog.csdn.net/jiaomubai/article/details/125070545?spm=1001.2014.3001.5501\" title=\"线程池七大参数_文丑颜不良啊的博客-CSDN博客\">线程池七大参数_文丑颜不良啊的博客-CSDN博客</a></p>\n<p><img alt=\"\" height=\"275\" src=\"..\\..\\static\\image\\71c78c6164a9496b929e3cd15b9a1c46.png\" width=\"799\"/></p>\n<p>本文参考自：<a href=\"https://juejin.cn/post/7072180640115851278\" title=\"Java 中线程池的 7 种创建方式！ - 掘金\">Java 中线程池的 7 种创建方式！ - 掘金</a></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-06-02 20:03:02", "summary": "在语言中，并发编程往往都是通过床架线程池来实现的，而线程池的创建方式也有很多种，每种线程池的创建方式都对应了不同的使用场景。总结来说线程池的创建可以分为两大类：通过创建通过创建以上这两类创建线程池的方"}