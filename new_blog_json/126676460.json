{"blogid": "126676460", "writerAge": "码龄4年", "writerBlogNum": "41", "writerCollect": "32", "writerComment": "16", "writerFan": "17", "writerGrade": "3级", "writerIntegral": "721", "writerName": "夏赞恩", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126676460.jpg", "writerRankTotal": "25917", "writerRankWeekly": "20106", "writerThumb": "26", "writerVisitNum": "13256", "blog_read_count": "264", "blog_time": "已于 2022-09-06 15:42:11 修改", "blog_title": "计算机网络常考协议(HTTP&HTTPs、TCP/UDP、DNS)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#HTTPHTTPs_1\">HTTP&amp;HTTPs</a></li><li><ul><li><a href=\"#1HTTP_10__HTTP_11__2\">（1）HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</a></li><li><ul><li><a href=\"#HTTP_8\">补充：常见的HTTP请求方法</a></li></ul>\n</li><li><a href=\"#2HTTP_11__HTTP_20__23\">（2）HTTP 1.1 和 HTTP 2.0 之间有哪些区别？</a></li><li><ul><li><a href=\"#_28\">补充：队头阻塞</a></li><li><a href=\"#WebsocketHTTP_37\">补充：Websocket和HTTP的联系和区别</a></li></ul>\n</li><li><a href=\"#3HTTP_20_HTTP30_53\">（3）HTTP 2.0 和HTTP3.0之间有哪些区别？</a></li><li><a href=\"#4HTTPHTTPs_59\">（4）HTTP和HTTPs的区别</a></li><li><ul><li><a href=\"#HTTPs_72\">补充：HTTPs通信（握手过程）</a></li></ul>\n</li></ul>\n</li><li><a href=\"#TCPUDP_75\">TCP&amp;UDP</a></li><li><ul><li><a href=\"#1TCPUDP_76\">（1）TCP和UDP的区别</a></li><li><ul><li><a href=\"#UDP_85\">补充：UDP协议为什么不可靠？</a></li></ul>\n</li><li><a href=\"#2TCP_91\">（2）TCP三次握手</a></li><li><ul><li><a href=\"#_103\">补充：为什么不能两次握手？</a></li></ul>\n</li><li><a href=\"#3TCP_110\">（3）TCP四次挥手</a></li></ul>\n</li><li><a href=\"#DNS_122\">DNS域名解析系统</a></li><li><ul><li><a href=\"#1DNS_123\">（1）DNS作用</a></li><li><a href=\"#2_125\">（2）各级域名</a></li><li><a href=\"#3_138\">（3）域名服务器</a></li><li><a href=\"#4_144\">（4）域名解析过程</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"HTTPHTTPs_1\"></a>HTTP&amp;HTTPs</h1>\n<h2><a id=\"1HTTP_10__HTTP_11__2\"></a>（1）HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h2>\n<ul><li>连接方面：http1.0 默认使用<strong>非持久连接</strong>，而 http1.1 默认使用<strong>持久连接</strong>。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li>资源请求方面：在http1.0 中，存在浪费带宽的现象，如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且<strong>不支持断点续传功能</strong>，http1.1 则在请求头引入了 range头域，它<strong>允许只请求资源的某个部分</strong>，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>缓存方面：在 http1.0 中主要使用 header 里的 <strong>If-Modified-Since、Expires</strong> 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 <strong>Etag、If-Unmodified-Since、If-Match、If-None-Match</strong>等可供选择的缓存头。</li><li>http1.0 中认为每台服务器都绑定一个唯一的IP 地址，因此，请求消息中的 URL 并没有传递主机名。但随着虚拟主机技术的发展，<strong>在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址</strong>。http1.1 中<strong>新增了 host 字段</strong>，用来<strong>指定服务器的域名</strong>。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。<h3><a id=\"HTTP_8\"></a>补充：常见的HTTP请求方法</h3> <pre><code>  GET: 向服务器获取数据\n  POST：将实体提交到指定的资源，通常会造成服务器资源的修改\n  PUT：上传文件，更新数据\n  DELETE：删除服务器上的对象\n  HEAD：获取报文首部，与GET相比，不返回报文主体部分\n  OPTIONS：询问支持的请求方法，用来跨域请求\n  CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信\n  TRACE: 回显服务器收到的请求，主要⽤于测试或诊断\n</code></pre> </li></ul>\n<table><thead><tr><th>区别</th><th>HTTP1.0</th><th>HTTP1.1</th></tr></thead><tbody><tr><td>连接</td><td>非持久连接</td><td>持久连接</td></tr><tr><td>资源请求</td><td>服务器返回全部资源，不支持断点续传</td><td>允许只请求资源的某个部分</td></tr><tr><td>缓存</td><td>主要使用 header 里的 If-Modified-Since、Expires</td><td>更多的缓存控制策略，如 Etag、If-Unmodified-Since、If-Match、If-None-Match等。</td></tr><tr><td>新增</td><td>/</td><td>host字段；请求方法（如PUT、HEAD、OPTIONS）</td></tr></tbody></table>\n<h2><a id=\"2HTTP_11__HTTP_20__23\"></a>（2）HTTP 1.1 和 HTTP 2.0 之间有哪些区别？</h2>\n<ul><li> <p>二进制协议：在 HTTP/1.1 版中，报文的<strong>头信息必须是文本（ASCII编码）</strong>，<strong>数据体可以是文本，也可以是二进制</strong>。HTTP2.0则是一个彻底的二进制协议，<strong>头信息和数据体都是二进制</strong>，统称为\"帧\"，可以分为头信息帧和数据帧。 <strong>帧的概念是它实现多路复用的基础。</strong></p> </li><li> <p>多路复用： HTTP2.0 实现了<strong>多路复用</strong>，HTTP2.0 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以<strong>同时发送多个请求或回应，而且不用按照顺序一一发送</strong>，这样就避免了\"队头堵<br/> 塞\"的问题。</p> <h3><a id=\"_28\"></a>补充：队头阻塞</h3>\n<blockquote>\n<p>队头阻塞是由 HTTP 基本的“请求 -<br/> 应答”模型所导致的。<strong>HTTP规定报文必须是“一发一收”</strong>，这就形成了一个<strong>先进先出</strong>的队列。队列里的请求是<strong>没有优先级的</strong>，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求处理的太慢而耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，<strong>结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</strong></p>\n</blockquote> </li><li> <p>数据流： HTTP2.0引入了数据流的概念。因为 HTTP2.0 的数据包是不按顺序发送的，<strong>同一个连接里面连续的数据包，可能属于不同的请求</strong>。因此，必须要对数据包做标记，指出它属于哪个请求。**HTTP2.0将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。**数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p> </li><li> <p>头信息压缩： HTTP2.0 实现了头信息压缩。因为 <strong>HTTP 1.1 协议不带状态，每次请求都必须附上所有信息</strong>。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP2.0 对这一点做了优化，<strong>引入了头信息压缩机制</strong>。一方面，<strong>头信息使用 gzip 或 compress 压缩后再发送</strong>；另一方面，客户端和服务器同时<strong>维护一张头信息表</strong>，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p> </li><li> <p>服务器推送：即HTTP2.0 允许服务器未经请求，主动向客户端发送资源。可以提前给客户端推送必要的资源（静态资源），这样就可以相对减少一些延迟时间。Note：HTTP2.0，服务器主动推送的是<strong>静态资源</strong>，和 WebSocket 以及使用 SSE 等方式向客户端发送<strong>即时数据的推送</strong>是不同的。</p> <h3><a id=\"WebsocketHTTP_37\"></a>补充：Websocket和HTTP的联系和区别</h3> <pre><code>- 联系：\n\t- 都是基于TCP协议的\n\t- 都是可靠传输协议\n\t- 都是应用层协议\n- 区别：\n\t- websocket是持久连接，http是短连接\n\t- websocket对应的协议是 以ws、wss开头，http以http、https开头\n\t- websocket是有状态的双向连接，http是无状态的单向连接\n\t- websocket是可以跨域的\n</code></pre> </li></ul>\n<table><thead><tr><th>区别</th><th>HTTP1.1</th><th>HTTP2.0</th></tr></thead><tbody><tr><td>二进制协议</td><td>报文头信息是文本，数据体可以是文本、二进制</td><td>报文头信息、数据体必须是二进制</td></tr><tr><td>新增：</td><td>/</td><td>多路复用、数据流、头信息压缩、服务器推送</td></tr></tbody></table>\n<h2><a id=\"3HTTP_20_HTTP30_53\"></a>（3）HTTP 2.0 和HTTP3.0之间有哪些区别？</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a615ac4852064f58955ecc5087bb2c2e.png\"/></p>\n<ul><li>基于的传输层协议不同：<strong>HTTP2基于TCP，HTTP3基于UDP</strong>。</li><li>HTTP3.0基于UDP协议实现了类似于HTTP2.0基于TCP的多路复用、流量控制、拥塞控制等传输可靠性等功能，这套功能被称为QUIC协议。</li><li>建立连接时延不同：HTTP2.0基于TCP要通过三次握手建立连接，HTTP3.0基于UDP，可以使用0~1个RTT来<strong>快速握手</strong>，建立连接。</li></ul>\n<h2><a id=\"4HTTPHTTPs_59\"></a>（4）HTTP和HTTPs的区别</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ea9a4a666cad4fa297d5e572159ffb57.png\"/></p>\n<ul><li>HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了web浏览器和服务器之间的传输报文，就可以直接读懂其中的信息（即存在信息窃听、信息篡改、信息劫持的风险），因此HTTP不适合传输一些敏感信息。HTTPs利用具有安全性的SSL/TLS（具有身份验证、信息加密和完整性验证功能）来加密传输数据，安全性较好。</li><li>HTTP页面响应速度比HTTPs快。HTTPS协议需要CA证书，费用较高，而HTTP协议不需要。</li><li>HTTP使用的端口号是80，HTTPs使用的端口号是443。</li></ul>\n<table><thead><tr><th>区别</th><th>HTTP</th><th>HTTPs</th></tr></thead><tbody><tr><td>传输内容</td><td>明文</td><td>SSL/TLS加密（非对称加密）</td></tr><tr><td>响应速度</td><td>快</td><td>慢</td></tr><tr><td>端口号</td><td>80</td><td>443</td></tr></tbody></table>\n<h3><a id=\"HTTPs_72\"></a>补充：HTTPs通信（握手过程）</h3>\n<p><img alt=\"Https连接过程\" src=\"..\\..\\static\\image\\2d6078f615c344bc86762b3a799face3.png\"/></p>\n<h1><a id=\"TCPUDP_75\"></a>TCP&amp;UDP</h1>\n<h2><a id=\"1TCPUDP_76\"></a>（1）TCP和UDP的区别</h2>\n<table><thead><tr><th>区别</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向无连接</td></tr><tr><td>连接对象个数</td><td>只能一对一通信</td><td>支持一对一、一对多、多对一、多对多通信</td></tr><tr><td>是否可靠</td><td>可靠传输(数据顺序和正确性,使用流量控制和拥塞控制</td><td>不可靠传输(不保证数据顺序和正确性),不使用流量控制和拥塞控制</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>首部最小20字节，最大60字节</td><td>首部开销小，仅8字节</td></tr><tr><td>使用场景</td><td>文件传输等要求可靠传输的应用</td><td>实时应用、视频会议、直播</td></tr></tbody></table>\n<h3><a id=\"UDP_85\"></a>补充：UDP协议为什么不可靠？</h3>\n<pre><code>1. 不保证消息交付：不确认，不重传，无超时\n2. 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞\n3. 不跟踪连接状态：不必建立连接或重启状态机\n4. 不进行拥塞控制：不内置客户端或网络反馈机制\n</code></pre>\n<h2><a id=\"2TCP_91\"></a>（2）TCP三次握手</h2>\n<p>三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>\n<ul><li>客户端发起请求，SYN=1，seq=x</li><li>服务器响应请求，并发出新请求，SYN=1，ACK=1，seq=y，ack=x+1</li><li>客户端相应请求，并发送数据，SYN=1，ACK=1， seq=x+1，ack=y+1</li></ul>\n<p>具体三次握手过程如下：</p>\n<ul><li>第一次握手： 客户端向服务端<strong>发送连接请求报文段</strong>。该报文段中包含<strong>自身的数据通讯初始序列号</strong>。请求发送后，客户端便进入 <strong>SYN-SENT</strong> 状态。</li><li>第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会<strong>包含自身的数据通讯初始序列号</strong>，发送完成后便进入 <strong>SYN-RECEIVED</strong> 状态。</li><li>第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个<strong>确认报文</strong>。<strong>客户端</strong>发完这个报文段后便进入<strong>ESTABLISHED</strong> 状态，<strong>服务端</strong>收到这个应答后也进入 <strong>ESTABLISHED</strong> 状态，此时连接建立成功。</li></ul>\n<p><img alt=\"TCP三次握手\" src=\"..\\..\\static\\image\\269db70c3aa84efb9350099c70733f5d.png\"/></p>\n<h3><a id=\"_103\"></a>补充：为什么不能两次握手？</h3>\n<blockquote>\n<p>三次握手主要是防止历史连接，两次握手<strong>无法判断当前连接是否是历史连接且客服端不响应服务器端发来的确认，浪费资源</strong>。<br/> 如果是用两次握手，则会出现下面这种情况：</p>\n<ol><li>客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求，后来收到了确认，建立了连接，数据传输完毕后，就释放了连接。</li><li>客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。即服务器无法判断当前连接是否是历史连接。</li><li>此时服务端发出确认，就建立新的连接了，但客服端认为自己没有发送连接请求，因此忽略服务端发来的确认，也不发送数据，则服务端一直在等待客户端发送数据，浪费资源。</li></ol>\n</blockquote>\n<h2><a id=\"3TCP_110\"></a>（3）TCP四次挥手</h2>\n<ul><li>客户端发起结束请求，FIN= 1，seq=u</li><li>服务器端响应客户端的请求，并发出自己的数据，seq=v，ACK=1，ack=u+1</li><li>服务器端数据传输完毕，向客户端发起结束请求，FIN=1，seq=w，ACK=1，ack=u+1</li><li>客户端响应服务器端的请求，ACK=1，seq=u+1，ack=w+1</li></ul>\n<p>具体四次挥手过程如下：</p>\n<ul><li>第一次挥手：若客户端认为数据发送完成，则它需要向服务端<strong>发送连接释放请求</strong>。</li><li>第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <strong>CLOSE_WAIT</strong> 状态，此时<strong>表明客户端到服务端的连接已经释放，不再接收客户端发的数据了</strong>。但是因为 TCP 连接是双向的，所以服务端仍旧可发送数据给客户端。</li><li>第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后<strong>服务端便进入 LAST-ACK 状态</strong>。</li><li>第四次挥手：客户端收到释放请求后，<strong>向服务端发送确认应答</strong>，此时客户端进入 <strong>TIME-WAIT</strong> 状态。该状态会持续 <strong>2MSL</strong>（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，<strong>客户端</strong>就进入 <strong>CLOSED</strong>状态。<strong>当服务端收到确认应答后，也便进入 CLOSED</strong> 状态。<br/> <img alt=\"TCP四次挥手\" src=\"..\\..\\static\\image\\bdef36453d3a40c681f95d8a425c8937.png\"/></li></ul>\n<h1><a id=\"DNS_122\"></a>DNS域名解析系统</h1>\n<h2><a id=\"1DNS_123\"></a>（1）DNS作用</h2>\n<p>将<strong>域名解析为IP地址</strong>，客户端向DNS服务器发送域名查询请求，DNS服务器告知客户端Web服务器的 IP 地址。</p>\n<h2><a id=\"2_125\"></a>（2）各级域名</h2>\n<pre><code>- 根：.\n- 顶级域名：\n\t- 国家顶级域名 cn,us,uk\n\t- 通用顶级域名 com,net,org,gov\n\t- 基础结构域名/反向域名 arpa\n</code></pre>\n<ul><li>二级域名： \n  <ul><li>类别域名 ac,com,edu,gov,net,org</li><li>行政区域名 用于我国各省、自治区、直辖市 bj，js</li><li>自己注册的域名（全球唯一）</li></ul> </li><li>三级域名： \n  <ul><li>pku.mail</li></ul> </li><li>四级域名…</li></ul>\n<h2><a id=\"3_138\"></a>（3）域名服务器</h2>\n<ul><li>根域名服务器：（管理该根服务器注册的所有顶级域名）：</li><li>顶级域名服务器（管理该顶级域名服务器注册的所有二级域名）：</li><li>权限域名服务器（负责一个区的域名服务器）：</li><li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。</li></ul>\n<h2><a id=\"4_144\"></a>（4）域名解析过程</h2>\n<ul><li>递归查询（交给别人查询）</li><li>浏览器首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到则 <strong>浏览器</strong>将请求发送给<strong>本地域名服务器</strong>， <strong>本地域名服务器</strong>将请求发送给<strong>根域名服务器</strong>，<strong>根域名服务器</strong>将请求发送给<strong>顶级域名服务器</strong>，<strong>顶级域名服务器</strong>将请求发送给<strong>权限域名服务器</strong>，在<strong>权限域名服务器缓存</strong>中查询， 然后将结果原路返回给请求查询的浏览器。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f263650db6944b1cba3510c286b4ba15.png\"/><br/> 递归与迭代相结合（有来有回）（第一步是递归查询，递给本地域名服务器去查询）</li><li>浏览器首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li><strong>浏览器</strong>将请求发送给<strong>本地域名服务器</strong>，在<strong>本地域名服务器缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li><strong>本地域名服务器</strong>向<strong>根域名服务器</strong>发送请求，根域名服务器会<strong>返回一个所查询域的顶级域名服务器地址</strong></li><li><strong>本地域名服务器</strong>向<strong>顶级域名服务器</strong>发送请求，顶级服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就<strong>返回下一级权限域名服务器的地址</strong></li><li><strong>本地域名服务器</strong>向<strong>权限域名服务器</strong>发送请求，权限服务器查询自己的缓存去<strong>返回对应的结果给本地域名服务器</strong></li><li><strong>本地域名服务器</strong>将<strong>返回结果保存在缓存中，便于下次使用</strong></li><li><strong>本地域名服务器</strong>将返回结果返回给<strong>浏览器</strong></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-06 15:42:11", "summary": "文章目录和之间有哪些区别？补充：常见的请求方法和之间有哪些区别？补充：队头阻塞补充：和的联系和区别和之间有哪些区别？和的区别补充：通信握手过程和的区别补充：协议为什么不可靠？三次握手补充：为什么不能两"}