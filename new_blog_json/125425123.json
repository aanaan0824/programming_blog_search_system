{"blogid": "125425123", "writerAge": "码龄2年", "writerBlogNum": "6", "writerCollect": "8", "writerComment": "0", "writerFan": "3", "writerGrade": "1级", "writerIntegral": "64", "writerName": "没有感情的代码", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125425123.jpg", "writerRankTotal": "121849", "writerRankWeekly": "547553", "writerThumb": "2", "writerVisitNum": "2843", "blog_read_count": "1507", "blog_time": "已于 2022-07-29 23:10:17 修改", "blog_title": "学习笔记：C++环境下OpenCV的findContours函数的参数详解及优化", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>这个是Visual Studio2019版本在OpenCV环境配置好后所显示的<strong><span style=\"color:#fe2c24;\">6个参数</span></strong><span style=\"color:#0d0016;\">，也即为全部参数</span></p>\n<p style=\"text-align:center;\"><u>但是，<strong><span style=\"color:#fe2c24;\">常用参数仅有四个</span></strong>(参见程序里的第二行注释)</u></p>\n<pre><code class=\"language-cpp\">cv::void findContours(cv::InputOutputArray image,\n                      cv::OutputArrayOfArray contours,\n                      cv::OutputArray hierarchy,\n                      int mode,     int method,\n                      cv::Point offset = cv::Point())\n\n\n//完整形式findContours(image, countours，hierarchy, mode，method, offset);\n//一般使用时仅输入这四个参数即可findContours(image,countours，mode，method);\n\n//image:单通道图像矩阵，可以是灰度图，建议二值图像（最好是Canny/拉普拉斯等边缘检测算子处理后的）\n//countours:\"vector&lt;vector&lt;Point&gt;&gt;contours\"一个双重向量，向量内每个元素保存了一组由连续的point点构成的点的集合的向量，每一组point点集就是一个轮廓\n//hierarchy:\"vector&lt;Vec4i&gt;hierarchy\",\"Vec4i\"是Vec&lt;int,4&gt;的别名，定义了一个“向量内每一个元素包含了四个int型变量”的向量\n//mode:定义轮廓的检索模式</code></pre>\n<p></p>\n<p><span style=\"color:#fefcd8;\"><strong><span style=\"background-color:#0d0016;\"> 参数1    image </span></strong></span>：</p>\n<p>单通道图像矩阵。待提取轮廓的图像,可以是灰度图，<strong>常用的是二值图</strong>(C++中可选择使用Canny，拉普拉斯等边缘检测算法进行二值化)</p>\n<p></p>\n<p><strong><span style=\"color:#e7fafa;\"><span style=\"background-color:#0d0016;\"> 参数2    contours </span></span></strong>：</p>\n<p>定义为一个双重向量  <strong>vector&lt;vector&lt;Point&gt;&gt; contours  </strong>每一组<strong>Point</strong>都连续，构成一组向量集合，在图像上的显示即为一个<strong>轮廓（点集）</strong>，由于一张图像往往包含很多对象，因此一个轮廓不足以描述图像中的所有对象，因此还需要一个容器去包含所有的轮廓，我们称这个包含所有轮廓的容器为<strong>轮廓集</strong>。所以我们有上述的双重向量的定义方式。    轮廓数量=contours的元素个数<br/>  </p>\n<p></p>\n<p></p>\n<p><span style=\"color:#fff5e6;\"><strong><span style=\"background-color:#0d0016;\"> 参数3    hierarchy </span></strong></span>：</p>\n<p>定义为  <strong>vector&lt;vector&lt;int,4&gt;&gt;hierarchy  或  vector&lt;Vec4i&gt;hierarchy</strong>，相当于hierarchy中的<strong>每个元素都是一个</strong>由4个int型组成的<strong>集合</strong>。直观的表示可以参考<strong>列数为4，行数为n的二维矩阵</strong>。这四个int型数hierarchy[i][0]~hierarchy[i][3]分别表示<strong>后一个轮廓，前一个轮廓，父轮廓，内嵌轮廓的索引编号</strong>，如果当前轮廓所对应的这四个轮廓之一有缺失，比如说容器内的第一个轮廓为没有前一个轮廓，则相应位置hierarchy[i][1]=-1。</p>\n<p>此参数通常不需要进行传值。</p>\n<p></p>\n<p></p>\n<p> <span style=\"color:#fef2f0;\"><strong><span style=\"background-color:#0d0016;\"> 参数4     mode </span></strong></span>：</p>\n<p>该参数用于定义轮廓的检索模式，一般有<span style=\"color:#fe2c24;\"><strong>4种取值</strong></span>（也称为4个<strong>宏</strong>）</p>\n<p>        <strong>取值一：CV_RETR_EXTERNAL</strong><br/>         CV_RETR_EXTERNAL只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</p>\n<p>        官方解释为：CV_RETR_EXTERNAL retrieves only the extreme outer contours. It sets         hierarchy[i][2]=hierarchy[i][3]=-1 for all the contours. <br/>         翻译过来就是：CV_RETR_EXTERNAL  只检测最外层轮廓，对所有轮廓设置hierarchy[i][2]=         hierarchy[i][3]=-1</p>\n<p>        直观的解释就是：图像检测到一个同心圆的<strong>内轮廓</strong>和<strong>外轮廓</strong>，由于外轮廓完全把内轮廓包含            住了，因此<strong>只显示外轮廓</strong>，</p>\n<hr/>\n<p><strong>        取值二：CV_RETR_LIST </strong>  <br/>         CV_RETR_LIST检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关              系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，            所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1（即hierarchy[i][2]=                          hierarchy[i][3]=-1）</p>\n<p>        官方解释为：CV_RETR_LIST retrieves all of the contours without establishing any                        hierarchical relationships. <br/>         翻译过来就是：CV_RETR_LIST：返回所有的轮廓，但是不建立轮廓的拓扑关系，所以                  hierarchical为空。</p>\n<hr/>\n<p><strong>        取值三：CV_RETR_CCOMP</strong>  </p>\n<p>        检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包            含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</p>\n<p>        官方解释为：CV_RETR_CCOMP retrieves all of the contours and organizes them into a              two-level hierarchy. At the top level, there are external boundaries of the components. At the          second level, there are boundaries of the holes. If there is another contour inside a hole of a          connected component, it is still put at the top level. <br/>         翻译过来就是：CV_RETR_CCOMP：提取所有轮廓，并且将其组织为双层结构。顶层(the            top levell)为连通域的外围边界，次层(the second level)为孔(hole)的内层边界，如果孔(hole)          中还有其它轮廓，那么这个轮廓被划分为顶层(the top levell)。</p>\n<hr/>\n<p>        <strong>取值四：CV_RETR_TREE</strong></p>\n<p><strong>        </strong>检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继            续包含内嵌轮廓。</p>\n<p>        官方解释为：CV_RETR_TREE retrieves all of the contours and reconstructs a full hierarchy          of nested contours. This full hierarchy is built and shown in the OpenCV contours.c demo. <br/>         翻译过来就是：CV_RETR_TREE：返回所有的轮廓，并且建立完整的拓扑结构</p>\n<p></p>\n<p></p>\n<p><span style=\"color:#efedf6;\"><strong><span style=\"background-color:#0d0016;\">参数5     method </span></strong></span>：</p>\n<p>用于定义轮廓的近似方法</p>\n<p>        <strong>取值一：CV_CHAIN_APPROX_NONE</strong> <br/>         保存物体边界上所有连续的轮廓点一般用的比较多</p>\n<p>        官方解释为：CV_CHAIN_APPROX_NONE stores absolutely all the contour points. That is,          any 2 subsequent points (x1,y1) and (x2,y2) of the contour will be either horizontal, vertical            or diagonal neighbors, that is, max(abs(x1-x2),abs(y2-y1))==1. <br/>         翻译过来为：存储所有的轮廓点。这种方法下，两个连续的轮廓点，要么是水平相邻的，要            么是垂直相邻的， 要么是对角相邻的，即满足max(abs(x1-x2),abs(y2-y1))==1. </p>\n<hr/>\n<p><strong>        取值二：CV_CHAIN_APPROX_SIMPLE </strong><br/>         仅保存轮廓的拐点信息，把所有轮廓拐点保存至contours向量内，拐点与拐点之间直线段上            的信息点不予保留</p>\n<p>        官方解释为：CV_CHAIN_APPROX_SIMPLE compresses horizontal, vertical, and diagonal          segments and leaves only their end points. For example, an up-right rectangular contour is            encoded with 4 points. <br/>         翻译过来为：压缩水平方向、垂直方向和对角线方向的中间点，只保留某个方向的终点坐              标，例如一个矩形轮廓只需4个点来保持轮廓信息。</p>\n<hr/>\n<p><strong>        取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS</strong></p>\n<p>        使用teh-Chinl chain 近似算法</p>\n<p>        官方解释为：CV_CHAIN_APPROX_TC89_L1,CV_CHAIN_APPROX_TC89_KCOS applies          one of the flavors of the Teh-Chin chain approximation algorithm. See [TehChin89] for                    details. <br/>         翻译过来为：使用The-Chinl链逼近算法中的一个</p>\n<p></p>\n<p></p>\n<p> <span style=\"color:#fbd4d0;\"><strong><span style=\"background-color:#0d0016;\">参数6    offset </span></strong></span>：Point类型，轮廓相对于原轮廓的偏移量（    通常使用默认的值 (0，0)    ）</p>\n<p>通常以一个坐标形式 Point 的参数(40,30)出现。(40,30)意思是将轮廓向右移动40个像素，再向下移动30个像素，若数值过大可能会出现溢出报错。</p>\n<p></p>\n<p></p>\n<p>本篇学习笔记，答谢以下两位作者：（第一个链接包含官方解释及翻译，第二个链接包含部分宏名的效果图及一些比较好理解的解释方式。</p>\n<p><a href=\"https://blog.csdn.net/wenhao_ir/article/details/51798533\" title=\"利用OpenCV的函数findContours()和函数drawContours()进行轮廓的检测与绘制_昊虹图像算法的博客-CSDN博客\">利用OpenCV的函数findContours()和函数drawContours()进行轮廓的检测与绘制_昊虹图像算法的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/dcrmg/article/details/51987348?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165596352316781685318940%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165596352316781685318940&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51987348-null-null.142%5Ev20%5Erank_v33,157%5Ev15%5Enew_3&amp;utm_term=findcontours&amp;spm=1018.2226.3001.4187\" title=\"findContours函数参数详解_-牧野-的博客-CSDN博客_findcontours函数\">findContours函数参数详解_-牧野-的博客-CSDN博客_findcontours函数</a></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-29 23:10:17", "summary": "这个是版本在环境配置好后所显示的个参数，也即为全部参数但是，常用参数仅有四个参见程序里的第二行注释完整形式，，一般使用时仅输入这四个参数即可，，单通道图像矩阵，可以是灰度图，建议二值图像最好是拉普拉斯"}