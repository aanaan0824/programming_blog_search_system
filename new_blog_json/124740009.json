{"blogid": "124740009", "writerAge": "码龄4年", "writerBlogNum": "111", "writerCollect": "1101", "writerComment": "1427", "writerFan": "2444", "writerGrade": "5级", "writerIntegral": "3686", "writerName": "百思不得小赵", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124740009.jpg", "writerRankTotal": "5296", "writerRankWeekly": "975", "writerThumb": "945", "writerVisitNum": "89302", "blog_read_count": "6637", "blog_time": "已于 2022-05-25 19:21:33 修改", "blog_title": "Java实现俄罗斯方块小游戏。（附完整源代码）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p style=\"text-align:center;\">大家好，我是百思不得小赵。</p>\n<p>创作时间：2022 年 5 月 12 日<br/> 博客主页： 🔍<a class=\"link-info\" href=\"https://blog.csdn.net/Zp_insist?spm=1010.2135.3001.5343\" title=\"点此进入博客主页\">点此进入博客主页</a><br/> —— 新时代的农民工 🙊<br/> —— 换一种思维逻辑去看待这个世界 👀<br/> 今天是加入CSDN的第1167天。觉得有帮助麻烦👏点赞、🍀评论、❤️收藏</p>\n</blockquote>\n<hr/>\n<p id=\"main-toc\" style=\"text-align:center;\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E4%B8%80%E3%80%81%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF\">一、游戏背景</a></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\">二、功能实现</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E4%B8%89%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA\">三、效果展示</a></p>\n<hr/>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\2ff2e5ccdecebec9b1c3ab996e264959.png\"/></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF\">一、游戏背景</h1>\n<p>俄罗斯方块是俄罗斯人发明的。这人叫阿列克谢·帕基特诺夫（Алексей Пажитнов 英文：Alexey Pazhitnov）。俄罗斯方块原名是俄语Тетрис（英语是Tetris），这个名字来源于希腊语tetra，意思是“四”，而游戏的作者最喜欢网球（tennis）。于是，他把两个词tetra和tennis合而为一，命名为Tetris，这也就是俄罗斯方块名字的由来。</p>\n<blockquote>\n<p>规则说明：</p>\n</blockquote>\n<p>由小方块组成的不同形状的板块陆续从屏幕上方落下来，玩家通过调整板块的位置和方向，使它们在屏幕底部拼出完整的一条或几条。这些完整的横条会随即消失，给新落下来的板块腾出空间，与此同时，玩家得到分数奖励。没有被消除掉的方块不断堆积起来，一旦堆到屏幕顶端，玩家便告输，游戏结束。</p>\n<h1 id=\"%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\">二、功能实现</h1>\n<p>开发工具：idea、jdk8</p>\n<p>技术汇总：Java基础知识、数组、面向对象、多线程、IO流、Swing。</p>\n<p>整体代码分为三个模块：方格模块，七种图形模块，俄罗斯方块主模块。</p>\n<p>小方块类：Cell</p>\n<pre><code class=\"language-java\">public class Cell {\n    // 行\n    private int row;\n    // 列\n    private int col;\n    private BufferedImage image;\n\n    public Cell() {\n    }\n\n    public Cell(int row, int col, BufferedImage image) {\n        this.row = row;\n        this.col = col;\n        this.image = image;\n    }\n\n    public int getRow() {\n        return row;\n    }\n\n    public void setRow(int row) {\n        this.row = row;\n    }\n\n    public int getCol() {\n        return col;\n    }\n\n    public void setCol(int col) {\n        this.col = col;\n    }\n\n    public BufferedImage getImage() {\n        return image;\n    }\n\n    public void setImage(BufferedImage image) {\n        this.image = image;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cell{\" +\n                \"row=\" + row +\n                \", col=\" + col +\n                \", image=\" + image +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof Cell)) {\n            return false;\n        }\n        Cell cell = (Cell) o;\n        return getRow() == cell.getRow() &amp;&amp;\n                getCol() == cell.getCol() &amp;&amp;\n                Objects.equals(getImage(), cell.getImage());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(getRow(), getCol(), getImage());\n    }\n\n    //左移动一格\n    public void left(){\n        col--;\n    }\n\n    //右移动一格\n    public void right(){\n        col++;\n    }\n\n    //下移动一格\n    public void down(){\n        row++;\n    }\n}\n</code></pre>\n<p> 四方格图形的父类：Tetromino</p>\n<pre><code class=\"language-java\">public class Tetromino {\n\n    public Cell[] cells = new Cell[4];\n\n    //旋转的状态\n    protected State[] states;\n    //声明旋转次数\n    protected int count = 10000;\n\n\n    //左移方法\n    public void moveLeft() {\n        for (Cell cell : cells) {\n            cell.left();\n        }\n    }\n\n    //右移方法\n    public void moveRight() {\n        for (Cell cell : cells) {\n            cell.right();\n        }\n    }\n\n    //单元格下落\n    public void moveDrop() {\n        for (Cell cell : cells) {\n            cell.down();\n        }\n    }\n\n    //编写随机生成四方格\n    public static Tetromino randomOne() {\n        int num = (int) (Math.random() * 7);\n        Tetromino tetromino = null;\n        switch (num) {\n            case 0:\n                tetromino = new I();\n                break;\n            case 1:\n                tetromino = new J();\n                break;\n            case 2:\n                tetromino = new L();\n                break;\n            case 3:\n                tetromino = new O();\n                break;\n            case 4:\n                tetromino = new S();\n                break;\n            case 5:\n                tetromino = new T();\n                break;\n            case 6:\n                tetromino = new Z();\n                break;\n        }\n\n        return tetromino;\n    }\n\n    //顺时针旋转的方法\n    public void rotateRight() {\n        if (states.length == 0) {\n            return;\n        }\n\n        //旋转次数+1\n        count++;\n        State s = states[count % states.length];\n        Cell cell = cells[0];\n        int row = cell.getRow();\n        int col = cell.getCol();\n        cells[1].setRow(row + s.row1);\n        cells[1].setCol(col + s.col1);\n        cells[2].setRow(row + s.row2);\n        cells[2].setCol(col + s.col2);\n        cells[3].setRow(row + s.row3);\n        cells[3].setCol(col + s.col3);\n    }\n\n    //逆时针旋转的方法\n    public void rotateLeft() {\n        if (states.length == 0) {\n            return;\n        }\n\n        //旋转次数+1\n        count--;\n        State s = states[count % states.length];\n        Cell cell = cells[0];\n        int row = cell.getRow();\n        int col = cell.getCol();\n        cells[1].setRow(row + s.row1);\n        cells[1].setCol(col + s.col1);\n        cells[2].setRow(row + s.row2);\n        cells[2].setCol(col + s.col2);\n        cells[3].setRow(row + s.row3);\n        cells[3].setCol(col + s.col3);\n    }\n\n    //四方格旋转状态的内部类\n    protected class State {\n        //存储四方格各元素的位置\n        int row0, col0, row1, col1, row2, col2, row3, col3;\n\n        public State() {\n        }\n\n        public State(int row0, int col0, int row1, int col1, int row2, int col2, int row3, int col3) {\n            this.row0 = row0;\n            this.col0 = col0;\n            this.row1 = row1;\n            this.col1 = col1;\n            this.row2 = row2;\n            this.col2 = col2;\n            this.row3 = row3;\n            this.col3 = col3;\n        }\n\n        public int getRow0() {\n            return row0;\n        }\n\n        public void setRow0(int row0) {\n            this.row0 = row0;\n        }\n\n        public int getCol0() {\n            return col0;\n        }\n\n        public void setCol0(int col0) {\n            this.col0 = col0;\n        }\n\n        public int getRow1() {\n            return row1;\n        }\n\n        public void setRow1(int row1) {\n            this.row1 = row1;\n        }\n\n        public int getCol1() {\n            return col1;\n        }\n\n        public void setCol1(int col1) {\n            this.col1 = col1;\n        }\n\n        public int getRow2() {\n            return row2;\n        }\n\n        public void setRow2(int row2) {\n            this.row2 = row2;\n        }\n\n        public int getCol2() {\n            return col2;\n        }\n\n        public void setCol2(int col2) {\n            this.col2 = col2;\n        }\n\n        public int getRow3() {\n            return row3;\n        }\n\n        public void setRow3(int row3) {\n            this.row3 = row3;\n        }\n\n        public int getCol3() {\n            return col3;\n        }\n\n        public void setCol3(int col3) {\n            this.col3 = col3;\n        }\n\n        @Override\n        public String toString() {\n            return \"State{\" +\n                    \"row0=\" + row0 +\n                    \", col0=\" + col0 +\n                    \", row1=\" + row1 +\n                    \", col1=\" + col1 +\n                    \", row2=\" + row2 +\n                    \", col2=\" + col2 +\n                    \", row3=\" + row3 +\n                    \", col3=\" + col3 +\n                    '}';\n        }\n    }\n}</code></pre>\n<p>七种图形类：I、J、L、O、S、T、Z</p>\n<pre><code class=\"language-java\">public class I extends Tetromino {\n\n    public I() {\n        cells[0] = new Cell(0,4, Tetris.I);\n        cells[1] = new Cell(0,3, Tetris.I);\n        cells[2] = new Cell(0,5, Tetris.I);\n        cells[3] = new Cell(0,6, Tetris.I);\n\n        //共有两种旋转状态\n        states =new State[2];\n        //初始化两种状态的相对坐标\n        states[0]=new State(0,0,0,-1,0,1,0,2);\n        states[1]=new State(0,0,-1,0,1,0,2,0);\n    }\n\n}</code></pre>\n<pre><code class=\"language-java\">public class J extends Tetromino {\n    public J() {\n        cells[0] = new Cell(0,4, Tetris.J);\n        cells[1] = new Cell(0,3, Tetris.J);\n        cells[2] = new Cell(0,5, Tetris.J);\n        cells[3] = new Cell(1,5, Tetris.J);\n\n        states=new State[4];\n        states[0]=new State(0,0,0,-1,0,1,1,1);\n        states[1]=new State(0,0,-1,0,1,0,1,-1);\n        states[2]=new State(0,0,0,1,0,-1,-1,-1);\n        states[3]=new State(0,0,1,0,-1,0,-1,1);\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class L extends Tetromino {\n    public L() {\n        cells[0] = new Cell(0,4, Tetris.L);\n        cells[1] = new Cell(0,3, Tetris.L);\n        cells[2] = new Cell(0,5, Tetris.L);\n        cells[3] = new Cell(1,3, Tetris.L);\n\n        states=new State[4];\n        states[0]=new State(0,0,0,-1,0,1,1,-1);\n        states[1]=new State(0,0,-1,0,1,0,-1,-1);\n        states[2]=new State(0,0,0,1,0,-1,-1,1);\n        states[3]=new State(0,0,1,0,-1,0,1,1);\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class O extends Tetromino {\n    public O() {\n        cells[0] = new Cell(0, 4, Tetris.O);\n        cells[1] = new Cell(0, 5, Tetris.O);\n        cells[2] = new Cell(1, 4, Tetris.O);\n        cells[3] = new Cell(1, 5, Tetris.O);\n\n        //无旋转状态\n        states = new State[0];\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class S extends Tetromino {\n    public S() {\n        cells[0] = new Cell(0,4, Tetris.S);\n        cells[1] = new Cell(0,5, Tetris.S);\n        cells[2] = new Cell(1,3, Tetris.S);\n        cells[3] = new Cell(1,4, Tetris.S);\n\n        //共有两种旋转状态\n        states =new State[2];\n        //初始化两种状态的相对坐标\n        states[0]=new State(0,0,0,1,1,-1,1,0);\n        states[1]=new State(0,0,1,0,-1,-1,0,-1);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class T extends Tetromino {\n    public T() {\n        cells[0] = new Cell(0,4, Tetris.T);\n        cells[1] = new Cell(0,3, Tetris.T);\n        cells[2] = new Cell(0,5, Tetris.T);\n        cells[3] = new Cell(1,4, Tetris.T);\n\n        states=new State[4];\n        states[0]=new State(0,0,0,-1,0,1,1,0);\n        states[1]=new State(0,0,-1,0,1,0,0,-1);\n        states[2]=new State(0,0,0,1,0,-1,-1,0);\n        states[3]=new State(0,0,1,0,-1,0,0,1);\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class Z extends Tetromino {\n    public Z() {\n        cells[0] = new Cell(1,4, Tetris.Z);\n        cells[1] = new Cell(0,3, Tetris.Z);\n        cells[2] = new Cell(0,4, Tetris.Z);\n        cells[3] = new Cell(1,5, Tetris.Z);\n\n        //共有两种旋转状态\n        states =new State[2];\n        //初始化两种状态的相对坐标\n        states[0]=new State(0,0,-1,-1,-1,0,0,1);\n        states[1]=new State(0,0,-1,1,0,1,1,0);\n    }\n}\n</code></pre>\n<p>俄罗斯方块游戏主类：Tetris</p>\n<pre><code class=\"language-java\">public class Tetris extends JPanel {\n\n    //正在下落的方块\n    private Tetromino currentOne = Tetromino.randomOne();\n    //将要下落的方块\n    private Tetromino nextOne = Tetromino.randomOne();\n    //游戏主区域\n    private Cell[][] wall = new Cell[18][9];\n    //声明单元格的值\n    private static final int CELL_SIZE = 48;\n\n    //游戏分数池\n    int[] scores_pool = {0, 1, 2, 5, 10};\n    //当前游戏的分数\n    private int totalScore = 0;\n    //当前消除的行数\n    private int totalLine = 0;\n\n    //游戏三种状态 游戏中、暂停、结束\n    public static final int PLING = 0;\n    public static final int STOP = 1;\n    public static final int OVER = 2;\n    //当前游戏状态值\n    private int game_state;\n    //显示游戏状态\n    String[] show_state = {\"P[pause]\", \"C[continue]\", \"S[replay]\"};\n\n\n    //载入方块图片\n    public static BufferedImage I;\n    public static BufferedImage J;\n    public static BufferedImage L;\n    public static BufferedImage O;\n    public static BufferedImage S;\n    public static BufferedImage T;\n    public static BufferedImage Z;\n    public static BufferedImage background;\n\n    static {\n        try {\n            I = ImageIO.read(new File(\"images/I.png\"));\n            J = ImageIO.read(new File(\"images/J.png\"));\n            L = ImageIO.read(new File(\"images/L.png\"));\n            O = ImageIO.read(new File(\"images/O.png\"));\n            S = ImageIO.read(new File(\"images/S.png\"));\n            T = ImageIO.read(new File(\"images/T.png\"));\n            Z = ImageIO.read(new File(\"images/Z.png\"));\n            background = ImageIO.read(new File(\"images/background.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(background, 0, 0, null);\n        //平移坐标轴\n        g.translate(22, 15);\n        //绘制游戏主区域\n        paintWall(g);\n        //绘制正在下落的四方格\n        paintCurrentOne(g);\n        //绘制下一个将要下落的四方格\n        paintNextOne(g);\n        //绘制游戏得分\n        paintSource(g);\n        //绘制当前游戏状态\n        paintState(g);\n    }\n\n    public void start() {\n        game_state = PLING;\n        KeyListener l = new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int code = e.getKeyCode();\n                switch (code) {\n                    case KeyEvent.VK_DOWN:\n                        sortDropActive();\n                        break;\n                    case KeyEvent.VK_LEFT:\n                        moveleftActive();\n                        break;\n                    case KeyEvent.VK_RIGHT:\n                        moveRightActive();\n                        break;\n                    case KeyEvent.VK_UP:\n                        rotateRightActive();\n                        break;\n                    case KeyEvent.VK_SPACE:\n                            hadnDropActive();\n                        break;\n                    case KeyEvent.VK_P:\n                        //判断当前游戏状态\n                        if (game_state == PLING) {\n                            game_state = STOP;\n                        }\n                        break;\n                    case KeyEvent.VK_C:\n                        if (game_state == STOP) {\n                            game_state = PLING;\n                        }\n                        break;\n                    case KeyEvent.VK_S:\n                        //重新开始\n                        game_state = PLING;\n                        wall = new Cell[18][9];\n                        currentOne = Tetromino.randomOne();\n                        nextOne = Tetromino.randomOne();\n                        totalScore = 0;\n                        totalLine = 0;\n                        break;\n                }\n            }\n        };\n        //将窗口设置为焦点\n        this.addKeyListener(l);\n        this.requestFocus();\n\n        while (true) {\n            if (game_state == PLING) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                if (camDrop()) {\n                    currentOne.moveDrop();\n                } else {\n                    landToWall();\n                    destroyLine();\n                    if (isGameOver()) {\n                        game_state = OVER;\n                    } else {\n                        //游戏没有结束\n                        currentOne = nextOne;\n                        nextOne = Tetromino.randomOne();\n                    }\n                }\n            }\n            repaint();\n        }\n    }\n\n    //创建顺时针旋转\n    public void rotateRightActive() {\n        currentOne.rotateRight();\n        if (outOFBounds() || coincide()) {\n            currentOne.rotateLeft();\n        }\n    }\n\n    //瞬间下落\n    public void hadnDropActive() {\n        while (true) {\n            //判断能否下落\n            if (camDrop()) {\n                currentOne.moveDrop();\n            } else {\n                break;\n            }\n        }\n        //嵌入到墙中\n        landToWall();\n        destroyLine();\n        if (isGameOver()) {\n            game_state = OVER;\n        } else {\n            //游戏没有结束\n            currentOne = nextOne;\n            nextOne = Tetromino.randomOne();\n        }\n    }\n\n    //按键一次，下落一格\n    public void sortDropActive() {\n        if (camDrop()) {\n            //当前四方格下落一格\n            currentOne.moveDrop();\n        } else {\n            landToWall();\n            destroyLine();\n            if (isGameOver()) {\n                game_state = OVER;\n            } else {\n                //游戏没有结束\n                currentOne = nextOne;\n                nextOne = Tetromino.randomOne();\n            }\n        }\n    }\n\n    //单元格嵌入墙中\n    private void landToWall() {\n        Cell[] cells = currentOne.cells;\n        for (Cell cell : cells) {\n            int row = cell.getRow();\n            int col = cell.getCol();\n            wall[row][col] = cell;\n        }\n    }\n\n    //判断四方格能否下落\n    public boolean camDrop() {\n        Cell[] cells = currentOne.cells;\n        for (Cell cell : cells) {\n            int row = cell.getRow();\n            int col = cell.getCol();\n            //判断是否到达底部\n            if (row == wall.length - 1) {\n                return false;\n            } else if (wall[row + 1][col] != null) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //消除行\n    public void destroyLine() {\n        int line = 0;\n        Cell[] cells = currentOne.cells;\n        for (Cell cell : cells) {\n            int row = cell.getRow();\n            if (isFullLine(row)) {\n                line++;\n                for (int i = row; i &gt; 0; i--) {\n                    System.arraycopy(wall[i - 1], 0, wall[i], 0, wall[0].length);\n                }\n                wall[0] = new Cell[9];\n            }\n        }\n        //分数池获取分数，累加到总分\n        totalScore += scores_pool[line];\n        //总行数\n        totalLine += line;\n    }\n\n    //判断当前行是否已经满了\n    public boolean isFullLine(int row) {\n        Cell[] cells = wall[row];\n        for (Cell cell : cells) {\n            if (cell == null) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //判断游戏是否结束\n    public boolean isGameOver() {\n        Cell[] cells = nextOne.cells;\n        for (Cell cell : cells) {\n            int row = cell.getRow();\n            int col = cell.getCol();\n            if (wall[row][col] != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void paintState(Graphics g) {\n        if (game_state == PLING) {\n            g.drawString(show_state[PLING], 500, 660);\n        } else if (game_state == STOP) {\n            g.drawString(show_state[STOP], 500, 660);\n        } else {\n            g.drawString(show_state[OVER], 500, 660);\n            g.setColor(Color.RED);\n            g.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 60));\n            g.drawString(\"GAME OVER!\", 30, 400);\n        }\n    }\n\n    private void paintSource(Graphics g) {\n        g.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 30));\n        g.drawString(\"分数: \" + totalScore, 500, 250);\n        g.drawString(\"行数: \" + totalLine, 500, 430);\n    }\n\n    private void paintNextOne(Graphics g) {\n        Cell[] cells = nextOne.cells;\n        for (Cell cell : cells) {\n            int x = cell.getCol() * CELL_SIZE + 370;\n            int y = cell.getRow() * CELL_SIZE + 25;\n            g.drawImage(cell.getImage(), x, y, null);\n        }\n    }\n\n    private void paintCurrentOne(Graphics g) {\n        Cell[] cells = currentOne.cells;\n        for (Cell cell : cells) {\n            int x = cell.getCol() * CELL_SIZE;\n            int y = cell.getRow() * CELL_SIZE;\n            g.drawImage(cell.getImage(), x, y, null);\n        }\n    }\n\n    private void paintWall(Graphics g) {\n        for (int i = 0; i &lt; wall.length; i++) {\n            for (int j = 0; j &lt; wall[i].length; j++) {\n                int x = j * CELL_SIZE;\n                int y = i * CELL_SIZE;\n                Cell cell = wall[i][j];\n                //判断是否有小方块\n                if (cell == null) {\n                    g.drawRect(x, y, CELL_SIZE, CELL_SIZE);\n                } else {\n                    g.drawImage(cell.getImage(), x, y, null);\n                }\n            }\n        }\n    }\n\n    //判断是否出界\n    public boolean outOFBounds() {\n        Cell[] cells = currentOne.cells;\n        for (Cell cell : cells) {\n            int col = cell.getCol();\n            int row = cell.getRow();\n            if (row &lt; 0 || row &gt; wall.length - 1 || col &lt; 0 || col &gt; wall[0].length-1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //按键一次，左移一次\n    public void moveleftActive() {\n        currentOne.moveLeft();\n        //判断是否越界或重合\n        if (outOFBounds() || coincide()) {\n            currentOne.moveRight();\n        }\n    }\n\n    //按键一次，右移一次\n    public void moveRightActive() {\n        currentOne.moveRight();\n        //判断是否越界或重合\n        if (outOFBounds() || coincide()) {\n            currentOne.moveLeft();\n        }\n    }\n\n    //判断是否重合\n    public boolean coincide() {\n        Cell[] cells = currentOne.cells;\n        for (Cell cell : cells) {\n            int row = cell.getRow();\n            int col = cell.getCol();\n            if (wall[row][col] != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        JFrame jFrame = new JFrame(\"俄罗斯方块\");\n        //创建游戏界面\n        Tetris panel = new Tetris();\n        jFrame.add(panel);\n        //设置可见\n        jFrame.setVisible(true);\n        //设置窗口大小\n        jFrame.setSize(810, 940);\n        //设置剧中\n        jFrame.setLocationRelativeTo(null);\n        //设置窗口关闭时停止\n        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        //游戏主要开始逻辑\n        panel.start();\n    }\n}</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA\">三、效果展示</h1>\n<p>游戏开始，方快下落，右边区域展示即将下落的方块图、分数、消除的行数以及游戏切换的状态。</p>\n<p><img alt=\"\" height=\"940\" src=\"..\\..\\static\\image\\b6f626fbbb48419f913998d755f4cc66.png\" width=\"810\"/></p>\n<p>按下空格键，方块瞬间下落， 按下P键游戏暂停，消除一行分数为1（此处由分数池进行控制）</p>\n<p><img alt=\"\" height=\"940\" src=\"..\\..\\static\\image\\df61f707551341b6b23bd9968cbd164d.png\" width=\"810\"/></p>\n<p> 按下C键游戏继续。</p>\n<p><img alt=\"\" height=\"940\" src=\"..\\..\\static\\image\\5d9b74402ce14740972b2165c24d6e6d.png\" width=\"810\"/></p>\n<p> 按下S键，游戏重新开始。</p>\n<p><img alt=\"\" height=\"940\" src=\"..\\..\\static\\image\\fb440fab4309436d973c5c4d43bb945c.png\" width=\"810\"/></p>\n<p> 方块占满，游戏结束，此时可以按下S键重新开始游戏。</p>\n<p><img alt=\"\" height=\"940\" src=\"..\\..\\static\\image\\b5ade60916e8419c8e8baf081139cd37.png\" width=\"810\"/></p>\n<p>本次游戏中所使用的素材文件以及所有的源代码文件都已经同步到Github,小伙伴们点击下方链接直接获取。</p>\n<p>Github链接地址：<a class=\"link-info\" href=\"https://github.com/xiaoZ-zhao/Tetris\" title=\"点击获取完整源代码，下载到本地即可运行\">点击获取完整源代码，下载到本地即可运行</a></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/f2abcf9cd3e342dc93d0744fe4b5d37d.webp\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-05-25 19:21:33", "summary": "大家好，我是百思不得小赵。创作时间：年月日博客主页：点此进入博客主页点此进入博客主页新时代的农民工换一种思维逻辑去看待这个世界今天是加入的第天。觉得有帮助麻烦点赞、评论、收藏目录一、游戏背景二、功能实"}