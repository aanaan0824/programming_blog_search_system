{"blogid": "123653870", "writerAge": "码龄4年", "writerBlogNum": "15", "writerCollect": "78", "writerComment": "56", "writerFan": "17", "writerGrade": "3级", "writerIntegral": "451", "writerName": "地心铁头娃", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123653870.jpg", "writerRankTotal": "48470", "writerRankWeekly": "87041", "writerThumb": "35", "writerVisitNum": "38615", "blog_read_count": "17455", "blog_time": "已于 2022-04-29 12:12:29 修改", "blog_title": "Android串口通讯SerialPort(使用篇)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\dc799c34a5ea4e199f0342365bef4166.png\"/></h2>\n<p></p>\n<p></p>\n<p></p>\n<h2>1.什么是串口？</h2>\n<p>在不会使用串口通讯之前，暂且可以把它理解为“一个可通讯的口”；使用篇不深入探讨理论及原理。能理解串口如何使用之后，可以查看<a class=\"link-info\" href=\"https://blog.csdn.net/qq_42111674/article/details/123737732\" title=\"Android串口通讯SerialPort(浅谈原理)\">Android串口通讯SerialPort(浅谈原理)</a></p>\n<h2>2.添加依赖</h2>\n<p>1.）在 module 中的 build.gradle 中的 dependencies 中添加以下依赖：</p>\n<pre><code>dependencies {\n    //串口\n    implementation 'com.github.licheedev:Android-SerialPort-API:2.0.0'\n}</code></pre>\n<p>2.）低版本的 gradle 在Project 中的 build.gradle 中的 allprojects 中添加以下 maven仓库 (不添加任然无法加载SerialPort)；</p>\n<pre><code>allprojects {\n    repositories {\n        maven { url \"https://jitpack.io\" }//maven仓库\n    }\n}</code></pre>\n<p>高版本的 gradle 已经废弃了 allprojects 在 settings.gradle 中 repositories 添加以下maven仓库(不添加任然无法加载SerialPort)；</p>\n<pre><code>dependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n        jcenter() // Warning: this repository is going to shut down soon\n        maven { url \"https://jitpack.io\" }//maven仓库\n    }\n}</code></pre>\n<h2>3.编写串口处理类</h2>\n<p>1.）串口处理类：SerialHandle ；简单概括这个类，就是通过串口对象去获取两个流(输入流、输出流)，通过者两个流来<strong><span style=\"color:#f3f3f4;\"><span style=\"background-color:#fe2c24;\">监听数据</span></span></strong>或者<strong><span style=\"color:#f3f3f4;\"><span style=\"background-color:#fe2c24;\">写入指令</span></span></strong>，硬件收到后执行。同时注意配置参数(只要支持串口通讯的硬件，一般说明书上都会有写)</p>\n<pre><code class=\"language-java\">package com.chj233.serialmode.serialUtil;\n\nimport android.serialport.SerialPort;\nimport android.util.Log;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 串口实处理类\n */\npublic class SerialHandle implements Runnable {\n\n    private static final String TAG = \"串口处理类\";\n    private String path = \"\";//串口地址\n    private SerialPort mSerialPort;//串口对象\n    private InputStream mInputStream;//串口的输入流对象\n    private BufferedInputStream mBuffInputStream;//用于监听硬件返回的信息\n    private OutputStream mOutputStream;//串口的输出流对象 用于发送指令\n    private SerialInter serialInter;//串口回调接口\n    private ScheduledFuture readTask;//串口读取任务\n\n    /**\n     * 添加串口回调\n     *\n     * @param serialInter\n     */\n    public void addSerialInter(SerialInter serialInter) {\n        this.serialInter = serialInter;\n    }\n\n    /**\n     * 打开串口\n     *\n     * @param devicePath 串口地址(根据平板的说明说填写)\n     * @param baudrate   波特率(根据对接的硬件填写 - 硬件说明书上\"通讯\"中会有标注)\n     * @param isRead     是否持续监听串口返回的数据\n     * @return 是否打开成功\n     */\n    public boolean open(String devicePath, int baudrate, boolean isRead) {\n        return open(devicePath, baudrate, 7, 1, 2, isRead);\n    }\n\n    /**\n     * 打开串口\n     *\n     * @param devicePath 串口地址(根据平板的说明说填写)\n     * @param baudrate   波特率(根据对接的硬件填写 - 硬件说明书上\"通讯\"中会有标注)\n     * @param dataBits   数据位(根据对接的硬件填写 - 硬件说明书上\"通讯\"中会有标注)\n     * @param stopBits   停止位(根据对接的硬件填写 - 硬件说明书上\"通讯\"中会有标注)\n     * @param parity     校验位(根据对接的硬件填写 - 硬件说明书上\"通讯\"中会有标注)\n     * @param isRead     是否持续监听串口返回的数据\n     * @return 是否打开成功\n     */\n    public boolean open(String devicePath, int baudrate, int dataBits, int stopBits, int parity, boolean isRead) {\n        boolean isSucc = false;\n        try {\n            if (mSerialPort != null) close();\n            File device = new File(devicePath);\n            mSerialPort = SerialPort // 串口对象\n                    .newBuilder(device, baudrate) // 串口地址地址，波特率\n                    .dataBits(dataBits) // 数据位,默认8；可选值为5~8\n                    .stopBits(stopBits) // 停止位，默认1；1:1位停止位；2:2位停止位\n                    .parity(parity) // 校验位；0:无校验位(NONE，默认)；1:奇校验位(ODD);2:偶校验位(EVEN)\n                    .build(); // 打开串口并返回\n            mInputStream = mSerialPort.getInputStream();\n            mBuffInputStream = new BufferedInputStream(mInputStream);\n            mOutputStream = mSerialPort.getOutputStream();\n            isSucc = true;\n            path = devicePath;\n            if (isRead) readData();//开启识别\n        } catch (Throwable tr) {\n            close();\n            isSucc = false;\n        } finally {\n            return isSucc;\n        }\n    }\n\n    // 读取数据\n    private void readData() {\n        if (readTask != null) {\n            readTask.cancel(true);\n            try {\n                Thread.sleep(160);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //此处睡眠：当取消任务时 线程池已经执行任务，无法取消，所以等待线程池的任务执行完毕\n            readTask = null;\n        }\n        readTask = SerialManage\n                .getInstance()\n                .getScheduledExecutor()//获取线程池\n                .scheduleAtFixedRate(this, 0, 150, TimeUnit.MILLISECONDS);//执行一个循环任务\n    }\n\n    @Override//每隔 150 毫秒会触发一次run\n    public void run() {\n        if (Thread.currentThread().isInterrupted()) return;\n        try {\n            int available = mBuffInputStream.available();\n            if (available == 0) return;\n            byte[] received = new byte[1024];\n            int size = mBuffInputStream.read(received);//读取以下串口是否有新的数据\n            if (size &gt; 0 &amp;&amp; serialInter != null) serialInter.readData(path, received, size);\n        } catch (IOException e) {\n            Log.e(TAG, \"串口读取数据异常:\" + e.toString());\n        }\n    }\n\n    /**\n     * 关闭串口\n     */\n    public void close(){\n        try{\n            if (mInputStream != null) mInputStream.close();\n        }catch (Exception e){\n            Log.e(TAG,\"串口输入流对象关闭异常：\" +e.toString());\n        }\n        try{\n            if (mOutputStream != null) mOutputStream.close();\n        }catch (Exception e){\n            Log.e(TAG,\"串口输出流对象关闭异常：\" +e.toString());\n        }\n        try{\n            if (mSerialPort != null) mSerialPort.close();\n            mSerialPort = null;\n        }catch (Exception e){\n            Log.e(TAG,\"串口对象关闭异常：\" +e.toString());\n        }\n    }\n\n    /**\n     * 向串口发送指令\n     */\n    public void send(final String msg) {\n        byte[] bytes = hexStr2bytes(msg);//字符转成byte数组\n        try {\n            mOutputStream.write(bytes);//通过输出流写入数据\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 把十六进制表示的字节数组字符串，转换成十六进制字节数组\n     *\n     * @param\n     * @return byte[]\n     */\n    private byte[] hexStr2bytes(String hex) {\n        int len = (hex.length() / 2);\n        byte[] result = new byte[len];\n        char[] achar = hex.toUpperCase().toCharArray();\n        for (int i = 0; i &lt; len; i++) {\n            int pos = i * 2;\n            result[i] = (byte) (hexChar2byte(achar[pos]) &lt;&lt; 4 | hexChar2byte(achar[pos + 1]));\n        }\n        return result;\n    }\n\n    /**\n     * 把16进制字符[0123456789abcde]（含大小写）转成字节\n     * @param c\n     * @return\n     */\n    private static int hexChar2byte(char c) {\n        switch (c) {\n            case '0':\n                return 0;\n            case '1':\n                return 1;\n            case '2':\n                return 2;\n            case '3':\n                return 3;\n            case '4':\n                return 4;\n            case '5':\n                return 5;\n            case '6':\n                return 6;\n            case '7':\n                return 7;\n            case '8':\n                return 8;\n            case '9':\n                return 9;\n            case 'a':\n            case 'A':\n                return 10;\n            case 'b':\n            case 'B':\n                return 11;\n            case 'c':\n            case 'C':\n                return 12;\n            case 'd':\n            case 'D':\n                return 13;\n            case 'e':\n            case 'E':\n                return 14;\n            case 'f':\n            case 'F':\n                return 15;\n            default:\n                return -1;\n        }\n    }\n\n}\n</code></pre>\n<p>2.）串口回调SerialInter；简单概括一下这个类，就是将SerialHandle类中产生的结果，返回给上一层的业务代码，<span style=\"color:#f3f3f4;\"><strong><span style=\"background-color:#fe2c24;\">解偶合</span></strong></span></p>\n<pre><code class=\"language-java\">package com.chj233.serialmode.serialUtil;\n\n/**\n * 串口回调\n */\npublic interface SerialInter {\n\n    /**\n     * 连接结果回调\n     * @param path 串口地址(当有多个串口需要统一处理时，可以用地址来区分)\n     * @param isSucc 连接是否成功\n     */\n    void connectMsg(String path,boolean isSucc);\n\n    /**\n     * 读取到的数据回调\n     * @param path 串口地址(当有多个串口需要统一处理时，可以用地址来区分)\n     * @param bytes 读取到的数据\n     * @param size 数据长度\n     */\n    void readData(String path,byte[] bytes,int size);\n\n}\n</code></pre>\n<p> 3.）串口统一管理SerialManage；简单概括一下这个类，用于<span style=\"color:#f3f3f4;\"><span style=\"background-color:#fe2c24;\">管理串口</span></span>的连接以及发送等功能，尤其是发送指令，极短时间内发送多个指令(例如：1毫秒内发送10个指令)，多个指令之间会相互干扰。可能执行了第一个指令，可能一个都没执行。这个类不是必须的，如果有更好的方法可以自己定义。</p>\n<pre><code class=\"language-java\">package com.chj233.serialmode.serialUtil;\n\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 串口管理类\n */\npublic class SerialManage {\n\n    private static SerialManage instance;\n    private ScheduledExecutorService scheduledExecutor;//线程池 同一管理保证只有一个\n    private SerialHandle serialHandle;//串口连接 发送 读取处理对象\n    private Queue&lt;String&gt; queueMsg = new ConcurrentLinkedQueue&lt;String&gt;();//线程安全到队列\n    private ScheduledFuture sendStrTask;//循环发送任务\n    private boolean isConnect = false;//串口是否连接\n\n    private SerialManage() {\n        scheduledExecutor = Executors.newScheduledThreadPool(8);//初始化8个线程\n    }\n\n    public static SerialManage getInstance() {\n        if (instance == null) {\n            synchronized (SerialManage.class) {\n                if (instance == null) {\n                    instance = new SerialManage();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * 获取线程池\n     *\n     * @return\n     */\n    public ScheduledExecutorService getScheduledExecutor() {\n        return scheduledExecutor;\n    }\n\n    /**\n     * 串口初始化\n     *\n     * @param serialInter\n     */\n    public void init(SerialInter serialInter) {\n        if (serialHandle == null) {\n            serialHandle = new SerialHandle();\n            startSendTask();\n        }\n        serialHandle.addSerialInter(serialInter);\n\n    }\n\n    /**\n     * 打开串口\n     */\n    public void open() {\n        isConnect = serialHandle.open(\"/dev/ttyS1\", 9600, true);//设置地址，波特率，开启读取串口数据\n    }\n\n    /**\n     * 发送指令\n     *\n     * @param msg\n     */\n    public void send(String msg) {\n        /*\n         此处没有直接使用 serialHandle.send(msg); 方法去发送指令\n         因为 某些硬件在极短时间内只能响应一个指令,232通讯一次发送多个指令会有物理干扰，\n         让硬件接收到指令不准确；所以 此处将指令添加到队列中，排队执行，确保每个指令一定执行.\n         若不相信可以试试用serialHandle.send(msg)方法循环发送10个不同的指令，看看10个指令\n         的执行结果。\n         */\n        queueMsg.offer(msg);//向队列添加指令\n    }\n\n    /**\n     * 关闭串口\n     */\n    public void colse() {\n        serialHandle.close();//关闭串口\n    }\n\n    //启动发送发送任务\n    private void startSendTask() {\n        cancelSendTask();//先检查是否已经启动了任务 ？ 若有则取消\n        //每隔100毫秒检查一次 队列中是否有新的指令需要执行\n        sendStrTask = scheduledExecutor.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                if (!isConnect) return;//串口未连接 退出\n                if (serialHandle == null) return;//串口未初始化 退出\n                String msg = queueMsg.poll();//取出指令\n                if (msg == null || \"\".equals(msg)) return;//无效指令 退出\n                serialHandle.send(msg);//发送指令\n            }\n        }, 0, 100, TimeUnit.MILLISECONDS);\n    }\n\n    //取消发送任务\n    private void cancelSendTask() {\n        if (sendStrTask == null) return;\n        sendStrTask.cancel(true);\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        sendStrTask = null;\n    }\n\n}</code></pre>\n<h2>4.使用串口</h2>\n<pre><code class=\"language-java\">package com.chj233.serialmode;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\n\nimport com.chj233.serialmode.serialUtil.SerialInter;\nimport com.chj233.serialmode.serialUtil.SerialManage;\n\npublic class MainActivity extends AppCompatActivity implements SerialInter {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        SerialManage.getInstance().init(this);//串口初始化\n        SerialManage.getInstance().open();//打开串口\n        findViewById(R.id.send_but).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                SerialManage.getInstance().send(\"Z\");//发送指令 Z \n            }\n        });\n    }\n\n    @Override\n    public void connectMsg(String path, boolean isSucc) {\n        String msg = isSucc ? \"成功\" : \"失败\";\n        Log.e(\"串口连接回调\", \"串口 \"+ path + \" -连接\" + msg);\n    }\n\n    @Override//若在串口开启的方法中 传入false 此处不会返回数据\n    public void readData(String path, byte[] bytes, int size) {\n//        Log.e(\"串口数据回调\",\"串口 \"+ path + \" -获取数据\" + bytes);\n    }\n}</code></pre>\n<h2>5.总结</h2>\n<p>串口通讯对于Android开发者来说，仅需关注如何连接、操作(发送指令)、读取数据；无论是232、485还是422，对于开发者来说连接、操作、读取代码都是一样的</p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-29 12:12:29", "summary": "什么是串口？在不会使用串口通讯之前，暂且可以把它理解为一个可通讯的口；使用篇不深入探讨理论及原理。能理解串口如何使用之后，可以查看串口通讯浅谈原理串口通讯浅谈原理添加依赖在中的中的中添加以下依赖：串口"}