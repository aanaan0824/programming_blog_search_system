{"blogid": "123593713", "writerAge": "码龄5年", "writerBlogNum": "561", "writerCollect": "14215", "writerComment": "682", "writerFan": "26658", "writerGrade": "7级", "writerIntegral": "11103", "writerName": "我爱Python数据挖掘", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123593713.jpg", "writerRankTotal": "918", "writerRankWeekly": "981", "writerThumb": "2358", "writerVisitNum": "786269", "blog_read_count": "6587", "blog_time": "于 2022-03-19 13:54:14 发布", "blog_title": "【机器学习】9种回归算法及实例总结，建议学习收藏", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>我相信很多人跟我一样，学习机器学习和数据科学的第一个算法是线性回归，它简单易懂。由于其功能有限，它不太可能成为工作中的最佳选择。大多数情况下，线性回归被用作基线模型来评估和比较研究中的新方法。</p>\n<p>在处理实际问题时，你应该了解并尝试许多其他回归算法。一方面可以系统学习回归算法，另外一方面在面试中也常用到这些算法。在本文中，我们将通过使用 Scikit-learn 和 XGBoost 的动手实践来学习 9 种流行的回归算法。 <strong>喜欢本文记得收藏、关注、点赞。</strong></p>\n<p><strong>【注】文末有技术交流群</strong></p>\n<p>结构如下：</p>\n<ul><li>线性回归</li><li>多项式回归</li><li>支持向量机回归</li><li>决策树回归</li><li>随机森林回归</li><li>LASSO 回归</li><li>Ridge 回归</li><li>ElasticNet 回归</li><li>XGBoost 回归</li></ul>\n<h2><a id=\"_18\"></a>推荐文章</h2>\n<ul><li> <p><a href=\"https://blog.csdn.net/weixin_38037405/article/details/123238694?spm=1001.2014.3001.5501\">李宏毅《机器学习》国语课程(2022)来了</a></p> </li><li> <p><a href=\"https://blog.csdn.net/qq_34160248/article/details/122976343?spm=1001.2014.3001.5501\">有人把吴恩达老师的机器学习和深度学习做成了中文版</a></p> </li><li> <p><a href=\"https://blog.csdn.net/weixin_38037405/article/details/122367702?spm=1001.2014.3001.5501\">上瘾了，最近又给公司撸了一个可视化大屏(附源码)</a></p> </li><li> <p><a href=\"https://blog.csdn.net/weixin_38037405/article/details/121956510?spm=1001.2014.3001.5501\">如此优雅，4款 Python 自动数据分析神器真香啊</a></p> </li><li> <p><a href=\"https://blog.csdn.net/weixin_38037405/article/details/121805448?spm=1001.2014.3001.5501\">梳理半月有余，精心准备了17张知识思维导图，这次要讲清统计学</a></p> </li><li> <p><a href=\"https://blog.csdn.net/weixin_38037405/article/details/122103186?spm=1001.2014.3001.5501\">年终汇总：20份可视化大屏模板，直接套用真香(文末附源码)</a></p> </li></ul>\n<h4><a id=\"_27\"></a>线性回归</h4>\n<p>线性回归通常是人们学习机器学习和数据科学的第一个算法。线性回归是一种线性模型，它假设输入变量 (X) 和单个输出变量 (y) 之间存在线性关系。 一般来说，有两种情况：</p>\n<ul><li>单变量线性回归：它对单个输入变量（单个特征变量）和单个输出变量之间的关系进行建模。</li><li>多变量线性回归（也称为多元线性回归）：它对多个输入变量（多个特征变量）和单个输出变量之间的关系进行建模。</li></ul>\n<p>这个算法很常见，以至于 Scikit-learn 在 LinearRegression() 中内置了这个功能。 让我们创建一个 LinearRegression 对象并将其拟合到训练数据中：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>linear_model <span class=\"token keyword\">import</span> LinearRegression\n<span class=\"token comment\"># Creating and Training the Model</span>\nlinear_regressor <span class=\"token operator\">=</span> LinearRegression<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nlinear_regressor<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>训练完成后，我们可以在 coef_ 属性中检查 LinearRegression 找到的系数参数：</p>\n<pre><code class=\"prism language-python\">linear_regressor<span class=\"token punctuation\">.</span>coef_\narray<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.15784473</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>现在采用该模型并为训练数据拟合一条线<br/> <img alt=\"\" src=\"..\\..\\static\\image\\1ced79a8786424e7daa04e536eb80de0.png\"/><br/> 关于线性回归的几个关键点：</p>\n<ul><li>快速且易于建模</li><li>当要建模的关系不是非常复杂并且您没有大量数据时，它特别有用。</li><li>非常直观的理解和解释。</li><li>它对异常值非常敏感。</li></ul>\n<h4><a id=\"_55\"></a>多项式回归</h4>\n<p>当我们想要为非线性可分数据创建模型时，多项式回归是最受欢迎的选择之一。它类似于线性回归，但使用变量 X 和 y 之间的关系来找到绘制适合数据点的曲线的最佳方法。</p>\n<p>对于多项式回归，一些自变量的幂大于 1。例如，我们可能会提出如下二次模型：<br/> <img alt=\"\" src=\"..\\..\\static\\image\\f704e0507b1c2508916ad3980103d5bb.png\"/><br/> Scikit-learn 的 PolynomialFeatures 内置了这种方法。 首先，我们需要生成一个由所有具有指定度数的多项式特征组成的特征矩阵：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>preprocessing <span class=\"token keyword\">import</span> PolynomialFeatures\n<span class=\"token comment\"># We are simply generating the matrix for a quadratic model</span>\npoly_reg <span class=\"token operator\">=</span> PolynomialFeatures<span class=\"token punctuation\">(</span>degree <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\nX_poly <span class=\"token operator\">=</span> poly_reg<span class=\"token punctuation\">.</span>fit_transform<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>接下来，让我们创建一个LinearRegression 对象并将其拟合到我们刚刚生成的特征矩阵 X_poly 中。</p>\n<pre><code class=\"prism language-python\"><span class=\"token comment\"># polynomial regression model</span>\npoly_reg_model <span class=\"token operator\">=</span> LinearRegression<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npoly_reg_model<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X_poly<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>现在采用该模型并为训练数据 X_plot 拟合一条线，如下所示：</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\4bd37f415b3c6bc134362983ac20b844.png\"/></p>\n<p>关于多项式回归的几个关键点：</p>\n<ul><li>能够对非线性可分数据进行建模；线性回归不能做到这一点。一般来说，它更加灵活，可以对一些相当复杂的关系进行建模。</li><li>完全控制特征变量的建模（要设置的指数）。</li><li>需要精心设计。 需要一些数据知识才能选择最佳指数。</li><li>如果指数选择不当，则容易过度拟合。</li></ul>\n<h4><a id=\"_85\"></a>支持向量机回归</h4>\n<p>支持向量机在分类问题中是众所周知的。SVM 在回归中的使用称为支持向量回归(SVR)。Scikit-learn在 SVR()中内置了这种方法。</p>\n<p>在拟合 SVR 模型之前，通常最好的做法是执行特征缩放，以便每个特征具有相似的重要性。 首先，让我们使用 StandardScaler() 执行特征缩放：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>svm <span class=\"token keyword\">import</span> SVR\n<span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>preprocessing <span class=\"token keyword\">import</span> StandardScaler\n<span class=\"token comment\"># Performing feature scaling</span>\nscaled_X <span class=\"token operator\">=</span> StandardScaler<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nscaled_y <span class=\"token operator\">=</span> StandardScaler<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nscaled_X <span class=\"token operator\">=</span> scaled_X<span class=\"token punctuation\">.</span>fit_transform<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">)</span>\nscaled_y <span class=\"token operator\">=</span> scaled_y<span class=\"token punctuation\">.</span>fit_transform<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>接下来，我们创建一个 SVR 对象，内核设置为“rbf”，伽马设置为“auto”。 之后，我们调用 fit() 使其适合缩放的训练数据：</p>\n<pre><code class=\"prism language-python\">svr_regressor <span class=\"token operator\">=</span> SVR<span class=\"token punctuation\">(</span>kernel<span class=\"token operator\">=</span><span class=\"token string\">'rbf'</span><span class=\"token punctuation\">,</span> gamma<span class=\"token operator\">=</span><span class=\"token string\">'auto'</span><span class=\"token punctuation\">)</span>\nsvr_regressor<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>scaled_X<span class=\"token punctuation\">,</span> scaled_y<span class=\"token punctuation\">.</span>ravel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>现在采用该模型并为训练数据 scaled_X 拟合一条线，如下所示：<br/> <img alt=\"\" src=\"..\\..\\static\\image\\a5b0341bcc90f3e3239a2dae334575ee.png\"/><br/> 关于支持向量回归的几个关键点</p>\n<ul><li>它对异常值具有鲁棒性，并且在高维空间中有效</li><li>它具有出色的泛化能力（能够正确适应新的、以前看不见的数据）</li><li>如果特征数量远大于样本数量，则容易过拟合</li></ul>\n<h4><a id=\"_112\"></a>决策树回归</h4>\n<p>决策树是一种用于分类和回归的非参数监督学习方法。目标是创建一个模型，通过学习从数据特征推断出的简单决策规则来预测目标变量的值。 一棵树可以看作是一个分段常数近似。</p>\n<p>决策树回归也很常见，以至于 Scikit-learn 将它内置在 DecisionTreeRegressor 中,可以在没有特征缩放的情况下创建 DecisionTreeRegressor 对象，如下所示：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>tree <span class=\"token keyword\">import</span> DecisionTreeRegressor\ntree_regressor <span class=\"token operator\">=</span> DecisionTreeRegressor<span class=\"token punctuation\">(</span>random_state <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\ntree_regressor<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>现在采用该模型并将其拟合到训练数据中：<br/> <img alt=\"\" src=\"..\\..\\static\\image\\d53fbb31a8d400f809ecee4eba1f94a0.png\"/><br/> 关于决策树的几个关键点：</p>\n<ul><li>易于理解和解释。树可以可视化。</li><li>适用于分类值和连续值</li><li>使用 DT（即预测数据）的成本与用于训练树的数据点数量成对数</li><li>决策树的预测既不平滑也不连续（如上图所示为分段常数近似）</li></ul>\n<h4><a id=\"_130\"></a>随机森林回归</h4>\n<p>随机森林回归基本上与决策树回归非常相似。 它是一个元估计器，可以在数据集的各种子样本上拟合多个决策树，并使用平均来提高预测准确性和控制过拟合。</p>\n<p>随机森林回归器在回归中可能会或可能不会比决策树表现更好（虽然它通常在分类中表现更好），因为树构造算法本质上存在微妙的过拟合 - 欠拟合权衡。</p>\n<p>随机森林回归很常见，以至于 Scikit-learn 将它内置在 RandomForestRegressor 中。 首先，我们需要创建一个具有指定数量的估计器的 RandomForestRegressor 对象，如下所示：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>ensemble <span class=\"token keyword\">import</span> RandomForestRegressor\nforest_regressor <span class=\"token operator\">=</span> RandomForestRegressor<span class=\"token punctuation\">(</span>\n    n_estimators <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">,</span> \n    random_state <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">)</span>\nforest_regressor<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">.</span>ravel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>现在采用该模型并将其拟合到训练数据中：<br/> <img alt=\"\" src=\"..\\..\\static\\image\\7a39a0041895984cb3e7f16df61357b5.png\"/><br/> 关于随机森林回归的几点：</p>\n<ul><li>减少决策树中的过度拟合并提高准确性</li><li>它也适用于分类值和连续值</li><li>需要大量计算能力和资源，因为它适合许多决策树来组合它们的输出</li></ul>\n<h4><a id=\"LASSO__152\"></a>LASSO 回归</h4>\n<p>LASSO 回归是使用收缩的线性回归的变体。收缩是将数据值收缩到中心点作为平均值的过程。这种类型的回归非常适合显示重度多重共线性（特征相互之间高度相关）的模型。</p>\n<p>Scikit-learn 内置在 LassoCV 中。</p>\n<pre><code>from sklearn.linear_model import LassoCV\nlasso = LassoCV()\nlasso.fit(X, y.ravel())\n</code></pre>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\d885b4074b963f825365716fc15dc69a.png\"/></p>\n<p>关于 Lasso 回归的几点：</p>\n<ul><li>它最常用于消除自动变量和选择特征。</li><li>它非常适合显示重度多重共线性（特征相互之间高度相关）的模型。</li><li>LASSO 回归利用 L1 正则化</li><li>LASSO 回归被认为比 Ridge 更好，因为它只选择了一些特征并将其他特征的系数降低到零。</li></ul>\n<h4><a id=\"_170\"></a>岭回归</h4>\n<p>岭回归与 LASSO 回归非常相似，因为这两种技术都使用了收缩。 Ridge 和 LASSO 回归都非常适合显示重度多重共线性（特征相互之间高度相关）的模型。 它们之间的主要区别在于 Ridge 使用 L2 正则化，这意味着没有一个系数会像 LASSO 回归中那样变为零（而是接近零）。</p>\n<p>Scikit-learn 内置在 RidgeCV 中。</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>linear_model <span class=\"token keyword\">import</span> RidgeCV\nridge <span class=\"token operator\">=</span> RidgeCV<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nridge<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\f505067fbc361c34da109a785c635610.png\"/><br/> 关于岭回归的几点：</p>\n<ul><li>它非常适合显示重度多重共线性（特征相互之间高度相关）的模型。</li><li>岭回归使用 L2 正则化。 贡献较小的特征将具有接近于零的系数。</li><li>由于 L2 正则化的性质，岭回归被认为比 LASSO 更差</li></ul>\n<h4><a id=\"ElasticNet__187\"></a>ElasticNet 回归</h4>\n<p>ElasticNet 是另一个使用 L1 和 L2 正则化训练的线性回归模型。它是 Lasso 和 Ridge 回归技术的混合体，因此它也非常适合显示重度多重共线性（特征相互之间高度相关）的模型。</p>\n<p>在 Lasso 和 Ridge 之间进行权衡的一个实际优势是它允许 Elastic-Net 在旋转下继承 Ridge 的一些稳定性。Scikit-learn 内置在 ElasticNetCV 中。</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>linear_model <span class=\"token keyword\">import</span> ElasticNetCV\nelasticNet <span class=\"token operator\">=</span> ElasticNetCV<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nelasticNet<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">.</span>ravel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\20c24526511194a2e4be0464d5a08248.png\"/></p>\n<h3><a id=\"XGBoost__199\"></a>XGBoost 回归</h3>\n<p>XGBoost 是梯度提升算法的一种高效且有效的实现。梯度提升是指一类可用于分类或回归问题的集成机器学习算法。</p>\n<p>XGBoost 是一个开源库，最初由 Chen Tianqi Chen 在其 2016 年题为“XGBoost: A Scalable Tree Boosting System”的论文中开发。 该算法被设计为在计算上既高效又高效。</p>\n<p>第一步是安装 XGBoost 库（如果尚未安装）</p>\n<pre><code class=\"prism language-bash\">pip <span class=\"token function\">install</span> xgboost\n</code></pre>\n<p>可以通过创建 XGBRegressor 的实例来定义 XGBoost 模型：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> xgboost <span class=\"token keyword\">import</span> XGBRegressor\n<span class=\"token comment\"># create an xgboost regression model</span>\nmodel <span class=\"token operator\">=</span> XGBRegressor<span class=\"token punctuation\">(</span>\n    n_estimators<span class=\"token operator\">=</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> \n    max_depth<span class=\"token operator\">=</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> \n    eta<span class=\"token operator\">=</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> \n    subsample<span class=\"token operator\">=</span><span class=\"token number\">0.7</span><span class=\"token punctuation\">,</span> \n    colsample_bytree<span class=\"token operator\">=</span><span class=\"token number\">0.8</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span>\n</code></pre>\n<ul><li>n_estimators：集成中树的数量，通常会增加，直到看不到进一步的改进。</li><li>max_depth：每棵树的最大深度，通常值在 1 到 10 之间。</li><li>eta：用于加权每个模型的学习率，通常设置为较小的值，例如 0.3、0.1、0.01 或更小。</li><li>subsample：每棵树中使用的样本数，设置为 0 和 1 之间的值，通常为 1.0 以使用所有样本。</li><li>colsample_bytree：每棵树中使用的特征（列）数，设置为 0 到 1 之间的值，通常为 1.0 以使用所有特征。</li></ul>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\cbe8f3efc03531c152e2d60df8822cf5.png\"/><br/> 关于 XGBoost 的几点：</p>\n<ul><li>XGBoost 在稀疏和非结构化数据上表现不佳。</li><li>该算法被设计为计算效率和高效，但是对于大型数据集的训练时间仍然相当长</li><li>它对异常值很敏感</li></ul>\n<h3><a id=\"_235\"></a>结论</h3>\n<p>在本文中，我们介绍了 9 种流行的回归算法，并使用 Scikit-learn 和 XGBoost 进行了动手实践。最好将它们放在您的工具箱中，这样您就可以尝试不同的算法并为实际问题找到最佳回归模型。</p>\n<h2><a id=\"_238\"></a>技术交流</h2>\n<p>欢迎转载、收藏、有所收获点赞支持一下！</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\20210626085401819.png\"/></p>\n<p>目前开通了技术交流群，群友已超过<strong>2000人</strong>，添加时最好的备注方式为：来源+兴趣方向，方便找到志同道合的朋友</p>\n<ul><li>方式①、发送如下图片至微信，长按识别，后台回复：加群；</li><li>方式②、添加微信号：<strong>dkl88191</strong>，备注：来自CSDN</li><li>方式③、微信搜索公众号：<strong>Python学习与数据挖掘</strong>，后台回复：加群</li></ul>\n<p><img alt=\"长按关注\" src=\"..\\..\\static\\image\\20210617234928176.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-19 13:54:14", "summary": "我相信很多人跟我一样，学习机器学习和数据科学的第一个算法是线性回归，它简单易懂。由于其功能有限，它不太可能成为工作中的最佳选择。大多数情况下，线性回归被用作基线模型来评估和比较研究中的新方法。在处理实"}