{"blogid": "126622289", "writerAge": "码龄1年", "writerBlogNum": "294", "writerCollect": "33", "writerComment": "0", "writerFan": "19", "writerGrade": "5级", "writerIntegral": "2965", "writerName": "小迅想变强", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126622289.jpg", "writerRankTotal": "8368", "writerRankWeekly": "7164", "writerThumb": "10", "writerVisitNum": "15974", "blog_read_count": "64", "blog_time": "于 2022-08-31 13:45:04 发布", "blog_title": "​Linux·i2c驱动架构​", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"Linux-i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84-toc\" style=\"margin-left:0px;\"><a href=\"#Linux-i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84\">Linux-i2c驱动架构</a></p>\n<p id=\"%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8\">总线驱动</a></p>\n<p id=\"i2c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%AE%BE%E5%A4%87-toc\" style=\"margin-left:40px;\"><a href=\"#i2c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%AE%BE%E5%A4%87\">i2c设备驱动和设备</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p> </p>\n<h1 id=\"Linux-i2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84\">Linux-i2c驱动架构</h1>\n<p>       i2c驱动在Linux通过一个周的学习后发现i2c总线的驱动框架还是和Linux整体的驱动框架是相同的，思想并不特殊比较复杂的内容如i2c核心的内容都是内核驱动框架实现完成的，今天我们暂时只分析驱动开发需要完成的部分。iic驱动驱动开发主要是完成四个部分的内容，struct i2c_adapter（适配器），struct i2c_algorithm （通讯接口），i2c_driver（设备驱动），struct i2c_client（iic设备），其中适配器和通讯接口的实现一般SOC厂商都会针对自家的i2c控制器IP实现在Linux 内核驱动中，也就是可以参考。即使没有驱动开发人员也可以自己实现主要就是按照框架需求实现主要的接口函数就可以了。所以这里需要先明确一点的就是I2C驱动是分为总线驱动和设备驱动的，设备在I2C架构中由i2c_client描述，用户空间也可以直接使用总线驱动完成和总线上的设备的数据交换只是有些设备的i2c操作时序很复杂，如果在用户空间来操作i2c设备效率和软件分层上也是不符合常用习惯的。所以I2C的拓扑图大就是总线驱动，设备驱动和设备，设备和设备驱动都是挂接在具体的总线上的这是由硬件决定的，有了设备驱动对i2c设备的操作就编程读写普通文件一样容易从而降低了用户控件的程序开发的复杂程度并提高了执行效率。</p>\n<h2 id=\"%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8\">总线驱动</h2>\n<pre><strong>i2c_adapter </strong>主要是用来抽像的描述i2c控制器的，结合其中<strong>algo</strong>通讯接口部分一起组成i2c总线驱动，其中适配器具体结构体如下：</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/b71bcd49ed03df14fedf94c47641e94c.gif\"/></p>\n<pre>struct i2c_adapter {\n    struct module *owner;\n    unsigned int class;          /* classes to allow probing for */\n    const struct i2c_algorithm *algo; /* the algorithm to access the bus */\n    void *algo_data;\n\n    /* data fields that are valid for all devices    */\n    struct rt_mutex bus_lock;\n\n    int timeout;            /* in jiffies */\n    int retries;\n    struct device dev;        /* the adapter device */\n\n    int nr;\n    char name[48];\n    struct completion dev_released;\n\n    struct mutex userspace_clients_lock;\n    struct list_head userspace_clients;\n\n    struct i2c_bus_recovery_info *bus_recovery_info;\n};</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/5c77a1172295a3a10845e34137965bd0.gif\"/></p>\n<p>其中的algo 指向适配对应到的具体的硬件的操作接口封装。除此之外其中还有一些属性如retries重试次数，class 保存i2c的一些特有的属性标志。总线驱动的适配器的部分内容比较简单基本就是一些软件部分内容的实现设置；要完成i2c总线驱动部分最主要的还是硬件通讯接口的实现，这一部分是和具体的硬件相关的所以也是驱动开发的重点。i2c总线驱动将硬件操作接口抽象封装如下：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/c8c3e56989e5ca364efe7d28e2c1954f.gif\"/></p>\n<pre>struct i2c_algorithm {\n    /* If an adapter algorithm can't do I2C-level access, set master_xfer\n       to NULL. If an adapter algorithm can do SMBus access, set\n       smbus_xfer. If set to NULL, the SMBus protocol is simulated\n       using common I2C messages */\n    /* master_xfer should return the number of messages successfully\n       processed, or a negative value on error */\n    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,\n               int num);\n    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,\n               unsigned short flags, char read_write,\n               u8 command, int size, union i2c_smbus_data *data);\n\n    /* To determine what the adapter supports */\n    u32 (*functionality) (struct i2c_adapter *);\n};</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/23ecec550b5729dba9b5e5646ad72c52.gif\"/></p>\n<p>其中master_xfer接口就是i2c主机驱动传输数据的接口，包括收和发。其中smbus_xfer 用于smbus时序发送数据。因为i2c接口和smbus是相同的有些SOC的i2c外设控制器同时支持这两种时序发送数据。最后就是functionality 接口他会返回当前总线支持的通讯协议和特性。三星的实现如下，其中具体的标志的含义可以参考具体说明文档。I2C_FUNC_I2C  指示支持I2C时序，I2C_FUNC_SMBUS_EMUL  应该是支持smbus时序。</p>\n<pre>/* declare our i2c functionality */\nstatic u32 s3c24xx_i2c_func(struct i2c_adapter *adap)\n{\n    return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART |\n        I2C_FUNC_PROTOCOL_MANGLING;\n}</pre>\n<p>i2c总线驱动的的定义一步骤如下（前提是已经实现了接口封装中的各个通讯函数）</p>\n<ol><li>分配内存。</li><li>然后开始配置具体的成员变量。</li><li>在绑定具体的接口函数即algo。</li></ol>\n<p>最后就是总线驱动的注册接口了由i2c内核实现，完成向内核注册增加一个I2C总线适配器。</p>\n<p><strong>增加适配器</strong></p>\n<p>int i2c_add_adapter(struct i2c_adapter * adap);</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/69e03cfe785f6fdb909c3d7ae48345df.gif\"/></p>\n<pre>int i2c_add_adapter(struct i2c_adapter *adapter)\n{\n    struct device *dev = &amp;adapter-&gt;dev;\n    int id;\n　  //设备树的方式添加设备　　\n    if (dev-&gt;of_node) {\n        id = of_alias_get_id(dev-&gt;of_node, \"i2c\");\n        if (id &gt;= 0) {\n            adapter-&gt;nr = id;\n            return __i2c_add_numbered_adapter(adapter);\n        }\n    }\n    //普通将设备写在板级文件中的方式\n    mutex_lock(&amp;core_lock);\n    //分配一个总线ID 这个ID有总线驱动子系统维护\n    id = idr_alloc(&amp;i2c_adapter_idr, adapter,\n               __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\n    mutex_unlock(&amp;core_lock);\n    if (id &lt; 0)\n        return id;\n\n    adapter-&gt;nr = id;\n    //适配器的注册，前提适配器有id\n    return i2c_register_adapter(adapter);\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/c8c3e56989e5ca364efe7d28e2c1954f.gif\"/></p>\n<p>整个执行流程基本分为如下的过程，如果未指定适配器id则先申请ID然后就是调用i2c_register_adapter</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc9663d7cadd175292cd9d9cfab10c57.gif\"/></p>\n<pre>static int i2c_register_adapter(struct i2c_adapter *adap)\n{\n    int res = 0;\n\n    /* Can't register until after driver model init */\n    if (unlikely(WARN_ON(!i2c_bus_type.p))) {\n        res = -EAGAIN;\n        goto out_list;\n    }\n\n    /* Sanity checks */\n    if (unlikely(adap-&gt;name[0] == '\\0')) {\n        pr_err(\"i2c-core: Attempt to register an adapter with \"\n               \"no name!\\n\");\n        return -EINVAL;\n    }\n    if (unlikely(!adap-&gt;algo)) {\n        pr_err(\"i2c-core: Attempt to register adapter '%s' with \"\n               \"no algo!\\n\", adap-&gt;name);\n        return -EINVAL;\n    }\n\n    rt_mutex_init(&amp;adap-&gt;bus_lock);\n    //这里说明用户空间是可以直接使用总线设备 来操作总线上的设备的\n    mutex_init(&amp;adap-&gt;userspace_clients_lock);\n    INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);\n    //默认超时时间为一个系统心跳时间\n    /* Set default timeout to 1 second if not already set */\n    if (adap-&gt;timeout == 0)\n        adap-&gt;timeout = HZ;\n    //前面申请的Id，所以说ID是必须的\n    dev_set_name(&amp;adap-&gt;dev, \"i2c-%d\", adap-&gt;nr);\n    //i2c_bus_type  i2c_adapter_type 都是内核实现的一些操作的封装\n    adap-&gt;dev.bus = &amp;i2c_bus_type;\n    adap-&gt;dev.type = &amp;i2c_adapter_type;\n    //和普通的设备注册相同，有个疑问就是驱动何时注册的？\n    res = device_register(&amp;adap-&gt;dev);\n    if (res)\n        goto out_list;\n\n    dev_dbg(&amp;adap-&gt;dev, \"adapter [%s] registered\\n\", adap-&gt;name);\n    //兼容性相关\n#ifdef CONFIG_I2C_COMPAT\n    res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,\n                       adap-&gt;dev.parent);\n    if (res)\n        dev_warn(&amp;adap-&gt;dev,\n             \"Failed to create compatibility class link\\n\");\n#endif\n    //总线恢复相关\n    /* bus recovery specific initialization */\n    if (adap-&gt;bus_recovery_info) {\n        struct i2c_bus_recovery_info *bri = adap-&gt;bus_recovery_info;\n\n        if (!bri-&gt;recover_bus) {\n            dev_err(&amp;adap-&gt;dev, \"No recover_bus() found, not using recovery\\n\");\n            adap-&gt;bus_recovery_info = NULL;\n            goto exit_recovery;\n        }\n\n        /* Generic GPIO recovery */\n        if (bri-&gt;recover_bus == i2c_generic_gpio_recovery) {\n            if (!gpio_is_valid(bri-&gt;scl_gpio)) {\n                dev_err(&amp;adap-&gt;dev, \"Invalid SCL gpio, not using recovery\\n\");\n                adap-&gt;bus_recovery_info = NULL;\n                goto exit_recovery;\n            }\n\n            if (gpio_is_valid(bri-&gt;sda_gpio))\n                bri-&gt;get_sda = get_sda_gpio_value;\n            else\n                bri-&gt;get_sda = NULL;\n\n            bri-&gt;get_scl = get_scl_gpio_value;\n            bri-&gt;set_scl = set_scl_gpio_value;\n        } else if (!bri-&gt;set_scl || !bri-&gt;get_scl) {\n            /* Generic SCL recovery */\n            dev_err(&amp;adap-&gt;dev, \"No {get|set}_gpio() found, not using recovery\\n\");\n            adap-&gt;bus_recovery_info = NULL;\n        }\n    }</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/4d573af6861fe506289ae17d858d1661.gif\"/></p>\n<p>添加的过程删除了异常处理的部分，执行过程大致就是先初始化适配器中的核心成员包括超时，设备链表，指定总线和设备类型后注册适配器设备。剩下的就是总线恢复的一些内容可以暂时不看。除此之外上面还发现一个问题就是添加总线适配器的过程发现不知道在何时添加的总线适配器驱动。根据前面对Linux设备注册过程的了解这里先看一下设备注册过程的绑定的总线type中的match接口：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/f55770c9fbee06681acf0ca774f58197.gif\"/></p>\n<pre>static int i2c_device_match(struct device *dev, struct device_driver *drv)\n{\n    struct i2c_client    *client = i2c_verify_client(dev);\n    struct i2c_driver    *driver;\n\n    if (!client)\n        return 0;\n\n    /* Attempt an OF style match */\n    if (of_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    driver = to_i2c_driver(drv);\n    /* match on an id table if there is one */\n    if (driver-&gt;id_table)\n        return i2c_match_id(driver-&gt;id_table, client) != NULL;\n\n    return 0;\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/da16af4cd46b4254200ca9a3c857c03f.gif\"/></p>\n<p>发现他在不使用设备树的情况下是通过驱动的id_table来完成设备和驱动的匹配的。继续找最后找到如下的代码在drivers\\i2c\\i2c-core.c 中：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/74ea0c903952f8804a8919fba6cf1209.gif\"/></p>\n<pre>static int __init i2c_init(void)\n{\n    int retval;\n\n    retval = bus_register(&amp;i2c_bus_type);\n    if (retval)\n        return retval;\n#ifdef CONFIG_I2C_COMPAT\n    i2c_adapter_compat_class = class_compat_register(\"i2c-adapter\");\n    if (!i2c_adapter_compat_class) {\n        retval = -ENOMEM;\n        goto bus_err;\n    }\n#endif\n    retval = i2c_add_driver(&amp;dummy_driver);\n    if (retval)\n        goto class_err;\n    return 0;\n\nclass_err:\n#ifdef CONFIG_I2C_COMPAT\n    class_compat_unregister(i2c_adapter_compat_class);\nbus_err:\n#endif\n    bus_unregister(&amp;i2c_bus_type);\n    return retval;\n}\n\n\n/* We must initialize early, because some subsystems register i2c drivers\n * in subsys_initcall() code, but are linked (and initialized) before i2c.\n */\npostcore_initcall(i2c_init);\n\n#define i2c_add_driver(driver) \\\n    i2c_register_driver(THIS_MODULE, driver)\n    \n    \n\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\n{\n    int res;\n\n    /* Can't register until after driver model init */\n    if (unlikely(WARN_ON(!i2c_bus_type.p)))\n        return -EAGAIN;\n\n    /* add the driver to the list of i2c drivers in the driver core */\n    driver-&gt;driver.owner = owner;\n    //这个很关键\n    driver-&gt;driver.bus = &amp;i2c_bus_type;\n    INIT_LIST_HEAD(&amp;driver-&gt;clients);\n\n    /* When registration returns, the driver core\n     * will have called probe() for all matching-but-unbound devices.\n     */\n    //这里就是和普通的驱动注册过程相同了\n    res = driver_register(&amp;driver-&gt;driver);\n    if (res)\n        return res;\n\n    /* Drivers should switch to dev_pm_ops instead. */\n    if (driver-&gt;suspend)\n        pr_warn(\"i2c-core: driver [%s] using legacy suspend method\\n\",\n            driver-&gt;driver.name);\n    if (driver-&gt;resume)\n        pr_warn(\"i2c-core: driver [%s] using legacy resume method\\n\",\n            driver-&gt;driver.name);\n\n    pr_debug(\"i2c-core: driver [%s] registered\\n\", driver-&gt;driver.name);\n    //如果设备先注册，则这里负责匹配\n    /* Walk the adapters that are already present */\n    i2c_for_each_dev(driver, __process_new_driver);\n\n    return 0;\n}\n//设备注册过程的一个关键代码</pre>\n<pre>static int __device_attach(struct device_driver *drv, void *data)\n{\n    struct device *dev = data;\n    /* 如果总线有定义mach函数则 调用总线的mach函数 这个接口由总线提供  */\n    if (!driver_match_device(drv, dev))\n        return 0;\n    /* 前面的匹配未成功 进一步探测*/\n    return driver_probe_device(drv, dev);\n}</pre>\n<pre>\n</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/b71bcd49ed03df14fedf94c47641e94c.gif\"/></p>\n<p>上面的代码注册了一个虚拟的I2C设备，他的作用就是产生对应的总线设备如i2c-0，i2c-1等，也就完善了Linux的驱动框架的内容有了设备（I2C适配器）和驱动(dummy_driver)。适配器设备注册时会先执行总线的match接口（红色部分代码）也就是上面的i2c_device_match</p>\n<p>接口，再看底下虚拟驱动的定义可以知道总线的匹配会失败最终执行的就是驱动自己的probe接口这里就是driver_probe_device dummy_probe接口。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/465bbd71868221931c00f53b0ab7d712.gif\"/></p>\n<pre>static const struct i2c_device_id dummy_id[] = {\n    { \"dummy\", 0 },\n    { },\n};\n\nstatic int dummy_probe(struct i2c_client *client,\n               const struct i2c_device_id *id)\n{\n    return 0;\n}\n\nstatic int dummy_remove(struct i2c_client *client)\n{\n    return 0;\n}\n\nstatic struct i2c_driver dummy_driver = {\n    .driver.name    = \"dummy\",\n    .probe        = dummy_probe,\n    .remove        = dummy_remove,\n    .id_table    = dummy_id,\n};</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/7870d37e730721bcdabbb9fcb4cc5013.gif\"/></p>\n<p></p>\n<p></p>\n<p><strong>删除适配器</strong></p>\n<p>void i2c_del_adapter(struct i2c_adapter * adap)</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/20463bd7b0fda0ce2946ae031b740b3d.gif\"/></p>\n<pre>void i2c_del_adapter(struct i2c_adapter *adap)\n{\n    struct i2c_adapter *found;\n    struct i2c_client *client, *next;\n\n    /* First make sure that this adapter was ever added */\n    mutex_lock(&amp;core_lock);\n    found = idr_find(&amp;i2c_adapter_idr, adap-&gt;nr);\n    mutex_unlock(&amp;core_lock);\n    if (found != adap) {\n        pr_debug(\"i2c-core: attempting to delete unregistered \"\n             \"adapter [%s]\\n\", adap-&gt;name);\n        return;\n    }\n\n    acpi_i2c_remove_space_handler(adap);\n    /* Tell drivers about this removal */\n    mutex_lock(&amp;core_lock);\n    bus_for_each_drv(&amp;i2c_bus_type, NULL, adap,\n                   __process_removed_adapter);\n    mutex_unlock(&amp;core_lock);\n\n    /* Remove devices instantiated from sysfs */\n    mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,\n              i2c_adapter_depth(adap));\n    list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,\n                 detected) {\n        dev_dbg(&amp;adap-&gt;dev, \"Removing %s at 0x%x\\n\", client-&gt;name,\n            client-&gt;addr);\n        list_del(&amp;client-&gt;detected);\n        i2c_unregister_device(client);\n    }\n    mutex_unlock(&amp;adap-&gt;userspace_clients_lock);\n\n    /* Detach any active clients. This can't fail, thus we do not\n     * check the returned value. This is a two-pass process, because\n     * we can't remove the dummy devices during the first pass: they\n     * could have been instantiated by real devices wishing to clean\n     * them up properly, so we give them a chance to do that first. */\n    device_for_each_child(&amp;adap-&gt;dev, NULL, __unregister_client);\n    device_for_each_child(&amp;adap-&gt;dev, NULL, __unregister_dummy);\n\n#ifdef CONFIG_I2C_COMPAT\n    class_compat_remove_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,\n                 adap-&gt;dev.parent);\n#endif\n\n    /* device name is gone after device_unregister */\n    dev_dbg(&amp;adap-&gt;dev, \"adapter [%s] unregistered\\n\", adap-&gt;name);\n\n    /* wait until all references to the device are gone\n     *\n     * FIXME: This is old code and should ideally be replaced by an\n     * alternative which results in decoupling the lifetime of the struct\n     * device from the i2c_adapter, like spi or netdev do. Any solution\n     * should be throughly tested with DEBUG_KOBJECT_RELEASE enabled!\n     */\n    init_completion(&amp;adap-&gt;dev_released);\n    device_unregister(&amp;adap-&gt;dev);\n    wait_for_completion(&amp;adap-&gt;dev_released);\n\n    /* free bus id */\n    mutex_lock(&amp;core_lock);\n    idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);\n    mutex_unlock(&amp;core_lock);\n\n    /* Clear the device structure in case this adapter is ever going to be\n       added again */\n    memset(&amp;adap-&gt;dev, 0, sizeof(adap-&gt;dev));\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/b08f99edaf1e60e464042c63fb82b766.gif\"/></p>\n<p></p>\n<p>基本的执行过程和设备的删除类似，但是增加了驱动的卸载，因为有些驱动是绑定到到要删除的适配器上的，适配器已经删除了自然需要删除相关设备。剩下的两部分就是i2c具体的设备驱动和设备的相关内容了。</p>\n<h2 id=\"i2c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%AE%BE%E5%A4%87\">i2c设备驱动和设备</h2>\n<p>      不通过具体的设备驱动也是可以访问i2c设备，但是应用层就需要处理i2c设备驱动本应该处理的内容，但是此时用户空间的代码的读写写逻辑的比较复杂需要考虑设备的读写时序的问题了，这样就不符合驱动的分层考虑了。不通过具体设备直接当问i2c总线上的设备需要使用i2c核心定义一个结构体来完成对i2c具体操作的定义那就是struct i2c_msg，因为通过上面的i2c总线驱动的通讯接口部分的int(master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,int num)接口可以看出来i2c的数据传输过程就是以struct i2c_msg为单位的，这个结构在用户空间也是可以使用的，所以用户可以直接通过总线完成和总线上挂接的设备进行数据交互（有条件的）。这里先解释正常情况下的设备操作方式---通过对应的设备驱动来操作设备，而设备驱动实际上最后也是调用的适配器的algo 句柄指向的master_xfer接口来实现数据传输。i2c设备的注册在系统的板级文件中实现通过struct i2c_board_info 结构进行定义然后通过i2c_register_board_info 进行注册需要注意的是设备的添加要遭遇驱动的注册，因为阅读源码发现设备添加时未进行驱动匹配代码如下</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/20ba38503ee9dde61d446dcb12ea1ef0.gif\"/></p>\n<pre>int __init\ni2c_register_board_info(int busnum,\n    struct i2c_board_info const *info, unsigned len)\n{\n    int status;\n\n    down_write(&amp;__i2c_board_lock);\n\n    /* dynamic bus numbers will be assigned after the last static one */\n    if (busnum &gt;= __i2c_first_dynamic_bus_num)\n        __i2c_first_dynamic_bus_num = busnum + 1;\n\n    for (status = 0; len; len--, info++) {\n        struct i2c_devinfo    *devinfo;\n\n        devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);\n        if (!devinfo) {\n            pr_debug(\"i2c-core: can't register boardinfo!\\n\");\n            status = -ENOMEM;\n            break;\n        }\n\n        devinfo-&gt;busnum = busnum;\n        devinfo-&gt;board_info = *info;\n        list_add_tail(&amp;devinfo-&gt;list, &amp;__i2c_board_list);\n    }\n\n    up_write(&amp;__i2c_board_lock);\n\n    return status;\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/3ad89a2f9efa8937580d38d21beaa0a8.gif\"/></p>\n<p>然后就是struct i2c_board_info和struct i2c_msg的定义了如下：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/d9370c2bd7ee2c329cf3c7a29099200d.gif\"/></p>\n<pre>struct i2c_board_info {\n    char        type[I2C_NAME_SIZE];\n    unsigned short    flags;\n    unsigned short    addr;\n    void        *platform_data;\n    struct dev_archdata    *archdata;\n    struct device_node *of_node;\n    struct acpi_dev_node acpi_node;\n    int        irq;\n};</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/23ecec550b5729dba9b5e5646ad72c52.gif\"/></p>\n<p>这里可以参考后面的struct i2c_client 的结构进行分析。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9359ba4ede87033fe265e7abb3f41ef9.gif\"/></p>\n<pre>struct i2c_msg {\n    __u16 addr;    /* slave address            */\n    __u16 flags;\n#define I2C_M_TEN        0x0010    /* this is a ten bit chip address */\n#define I2C_M_RD        0x0001    /* read data, from slave to master */\n#define I2C_M_STOP        0x8000    /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_NOSTART        0x4000    /* if I2C_FUNC_NOSTART */\n#define I2C_M_REV_DIR_ADDR    0x2000    /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_IGNORE_NAK    0x1000    /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_NO_RD_ACK        0x0800    /* if I2C_FUNC_PROTOCOL_MANGLING */\n#define I2C_M_RECV_LEN        0x0400    /* length will be first received byte */\n    __u16 len;        /* msg length                */\n    __u8 *buf;        /* pointer to msg data            */\n};</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/afa55970cc927df630e98277ad96e551.gif\"/></p>\n<p>很简单就三个成员，然后再来看i2c设备驱动的部分。</p>\n<p>i2c设备驱动就是针对一个特定的设备定义一种操作接口由用户接口通过vfs接口调用从而完成对指定设备的读写操作，读写寄存器或存储空间的内容。他的定义如下</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/07e592b9304d42c36f4b2c612d4ff1ae.gif\"/></p>\n<pre>struct i2c_driver {\n    unsigned int class;\n\n    /* Notifies the driver that a new bus has appeared. You should avoid\n     * using this, it will be removed in a near future.\n     */\n    int (*attach_adapter)(struct i2c_adapter *) __deprecated;\n\n    /* Standard driver model interfaces */\n    int (*probe)(struct i2c_client *, const struct i2c_device_id *);\n    int (*remove)(struct i2c_client *);\n\n    /* driver model interfaces that don't relate to enumeration  */\n    void (*shutdown)(struct i2c_client *);\n    int (*suspend)(struct i2c_client *, pm_message_t mesg);\n    int (*resume)(struct i2c_client *);\n\n    /* Alert callback, for example for the SMBus alert protocol.\n     * The format and meaning of the data value depends on the protocol.\n     * For the SMBus alert protocol, there is a single bit of data passed\n     * as the alert response's low bit (\"event flag\").\n     */\n    void (*alert)(struct i2c_client *, unsigned int data);\n\n    /* a ioctl like command that can be used to perform specific functions\n     * with the device.\n     */\n    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);\n\n    struct device_driver driver;\n    const struct i2c_device_id *id_table;\n\n    /* Device detection callback for automatic device creation */\n    int (*detect)(struct i2c_client *, struct i2c_board_info *);\n    const unsigned short *address_list;\n    struct list_head clients;\n};</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/ab501af054b13a5f6fdcf14ebf7525fb.gif\"/></p>\n<p>看起来是不是和设备驱动很相似，确实这也是linux内核驱动框架的抽象意义。如果熟悉前面的platform_driver的初始化和添加流程这里也是类似的。基本上也是用户完成一些接口的实现然后绑定到指定的驱动成员上最后调用驱动注册接口。如下这是我自己实现的At24cxx系列eeprom的i2c设备驱动。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/69e03cfe785f6fdb909c3d7ae48345df.gif\"/></p>\n<pre>static struct i2c_driver eerom_driver = {\n    .driver = {\n        .name    = \"at24xx\",\n    },\n    .id_table    = at24c0xx_idtable,\n    .probe        = at24c0xx_probe,\n    .remove        = at24c0xx_remove,\n};\n\nint __init eeprom_i2c_driver_init(void)\n{\n    int retval;\n\n    retval=i2c_add_driver(&amp;eerom_driver);\n    if(retval)\n    {\n        printk(KERN_INFO \"eeprom_i2c_driver_init fail\\n\");\n    }\n    return 0;\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/6453ac843cd758700f28080febb1e716.gif\"/></p>\n<p>重点是驱动和设备的匹配操作这里和platform驱动和设备的match还是有一定的的差别的，通过i2c_add_driver 添加设备驱动到i2c总线，所有的i2c适配器都在同一个总线，由设备信息确定设备在哪一个适配器上。当驱动注册后会执行总线的match函数具体如下</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/adbf52ccbadb6d780a311e527a875997.gif\"/></p>\n<pre>static int i2c_device_match(struct device *dev, struct device_driver *drv)\n{\n    struct i2c_client    *client = i2c_verify_client(dev);\n    struct i2c_driver    *driver;\n\n    if (!client)\n        return 0;\n\n    /* Attempt an OF style match */\n    if (of_driver_match_device(dev, drv))\n        return 1;\n\n    /* Then ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n\n    driver = to_i2c_driver(drv);\n    /* match on an id table if there is one */\n    if (driver-&gt;id_table)\n        return i2c_match_id(driver-&gt;id_table, client) != NULL;\n\n    return 0;\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/6deeeef270a1a64a93d98f8f22318e69.gif\"/></p>\n<p>通过代码可以发现匹配规则除了类似platform总线的设备树和acpi模式外只支持id_table的方式匹配设备。match完成匹配后就会执行i2c总线的探测函数探测驱动和设备。总线的probe函数最后还是会调用driver的probe接口完成设备的探测。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/d9370c2bd7ee2c329cf3c7a29099200d.gif\"/></p>\n<pre>static int i2c_device_probe(struct device *dev)\n{\n    struct i2c_client    *client = i2c_verify_client(dev);\n    struct i2c_driver    *driver;\n    int status;\n\n    if (!client)\n        return 0;\n\n    driver = to_i2c_driver(dev-&gt;driver);\n    if (!driver-&gt;probe || !driver-&gt;id_table)\n        return -ENODEV;\n\n    if (!device_can_wakeup(&amp;client-&gt;dev))\n        device_init_wakeup(&amp;client-&gt;dev,\n                    client-&gt;flags &amp; I2C_CLIENT_WAKE);\n    dev_dbg(dev, \"probe\\n\");\n\n    acpi_dev_pm_attach(&amp;client-&gt;dev, true);\n    status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));\n    if (status)\n        acpi_dev_pm_detach(&amp;client-&gt;dev, true);\n\n    return status;\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9359ba4ede87033fe265e7abb3f41ef9.gif\"/></p>\n<p> 具体的probe接口就可以定义软件接口进行一系列的接口配置将用户的vfs接口映射到i2c总线的读写。下面拿我自己实现的一个eeprom的读写驱动接口实例来分析。主要看probe接口</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/69e03cfe785f6fdb909c3d7ae48345df.gif\"/></p>\n<pre>#define  BUFF_SIZE          64\n#define  EEPROM_PAGE_SIZE   8\n#define  LEN_GET(index,len)    \\\n        (((index+EEPROM_PAGE_SIZE)&lt;(len))?(EEPROM_PAGE_SIZE):(len-index))\n\nenum type\n{ \n    at24c01x,\n    at24c02x,\n    at24c04x,\n    at24c08x,\n    at24c16x,\n};\n\nenum mem_size\n{ \n    AT24C01=(1&lt;&lt;10),\n    AT24C02=(2&lt;&lt;10),\n    AT24C04=(4&lt;&lt;10),\n    AT24C08=(8&lt;&lt;10),\n    AT24C16=(16&lt;&lt;10),\n};\n\nstruct eeprom_chip {\n    struct miscdevice    devmisc;\n    struct i2c_client    *client;\n    struct iic_ops      *ops;\n    struct device       *dev;\n    struct mutex        eeprom_mutex;\n    char                buf[BUFF_SIZE];\n    enum mem_size       memsize;\n    uint8_t             is_open;\n    kernel_ulong_t      eeprom_type;\n\n};\n\nstruct iic_ops{\n    int (*send)(struct eeprom_chip *, size_t,short);\n    int (*recv)(struct eeprom_chip *, size_t,short);\n};\n</pre>\n<p>static struct i2c_device_id at24c0xx_idtable[] = {<!-- --></p>\n<p>    { \"24c04x\", at24c04x},</p>\n<p>    { \"24c08x\",at24c08x},</p>\n<p>    { \"24c16x\",at24c16x},</p>\n<p>    { }</p>\n<p>};</p>\n<pre>\n</pre>\n<p>static struct i2c_driver eerom_driver = {<!-- --></p>\n<p>    .driver = {<!-- --></p>\n<p>        .name   = \"at24xx\",</p>\n<p>    },</p>\n<p>    .id_table   = at24c0xx_idtable,</p>\n<p>    .probe      = at24c0xx_probe,</p>\n<p>    .remove     = at24c0xx_remove,</p>\n<p>};</p>\n<pre>\n</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/f77d836d944cb76db41508c68fc83916.gif\"/></p>\n<p>probe接口的实现主要是通过增加中间层使用了杂项设备驱动，将vfs的读写接口传递到i2c总线上的读写接口从而实现读写eeprom就如同读写一个普通文件一样简单，从而简化了用户空间的调用逻辑。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/e1bdb1320dde371c6d1b07f7fcd8e3b4.gif\"/></p>\n<pre>static int at24c0xx_probe(struct i2c_client *client,\n                  const struct i2c_device_id *id)\n{\n    int rc;\n    struct eeprom_chip *eeprom;\n    struct device *dev = &amp;client-&gt;dev;\n    /* check function*/\n    if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C))\n        return -ENODEV;\n    eeprom = devm_kzalloc(&amp;client-&gt;dev,sizeof(struct eeprom_chip), GFP_KERNEL);\n    if (eeprom == NULL) {\n        printk(KERN_INFO \"failed to create our eeprom_data\\n\");\n        return -ENOMEM;\n    }\n    eeprom-&gt;eeprom_type = id-&gt;driver_data;\n    eeprom-&gt;dev=get_device(dev);\n    eeprom-&gt;client = client;\n    eeprom-&gt;ops = &amp;iic_ops;\n    eeprom-&gt;devmisc.fops = &amp;eeprom_ops;\n    eeprom-&gt;devmisc.minor = 223;\n    eeprom-&gt;devmisc.name=client-&gt;name;\n    eeprom-&gt;devmisc.parent = eeprom-&gt;dev;\n    eeprom-&gt;memsize = get_eeprom_memsize(eeprom-&gt;eeprom_type);\n    // printk(KERN_INFO \"I2C:at24c0x:%d byte\\n\",eeprom-&gt;memsize);\n    mutex_init(&amp;eeprom-&gt;eeprom_mutex);\n    rc = misc_register(&amp;eeprom-&gt;devmisc);\n    if (rc) {\n        printk(KERN_INFO \"%s client created misc_register Fail\\n\",client-&gt;name);\n    }\n    i2c_set_clientdata(client, eeprom);\n    /* rest of the initialisation goes here. */\n    // printk(KERN_INFO \"%s client created\\n\",client-&gt;name);\n\n    return 0;\n}</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/ffcfe49d424776ca0ca94065039694dc.gif\"/></p>\n<p>全部驱动代码，设备就是Linux3-16-57版本内核的三星的smdkv210的板级文件添加的修改了一下兼容属性，从而使当前驱动可以匹配上。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/e4c5dd44d63bf707b925aea945421ab9.gif\"/></p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/d7e871878cfeb712a594f7f5974673d2.gif\"/></p>\n<pre>  1 #include &lt;linux/module.h&gt;\n  2 #include &lt;linux/kernel.h&gt;\n  3 #include &lt;linux/device.h&gt;\n  4 #include &lt;linux/miscdevice.h&gt;\n  5 #include &lt;linux/delay.h&gt;\n  6 #include &lt;linux/errno.h&gt;\n  7 #include &lt;linux/gpio.h&gt;\n  8 #include &lt;linux/slab.h&gt;\n  9 #include &lt;linux/i2c.h&gt;\n 10 #include &lt;linux/init.h&gt;\n 11 #include &lt;linux/fcntl.h&gt;\n 12 #include &lt;linux/io.h&gt;\n 13 #include &lt;linux/fs.h&gt;\n 14 #include &lt;linux/types.h&gt;\n 15 #include &lt;linux/mutex.h&gt;\n 16 #include &lt;linux/completion.h&gt;\n 17 #include &lt;linux/hardirq.h&gt;\n 18 #include &lt;linux/irqflags.h&gt;\n 19 #include &lt;linux/rwsem.h&gt;\n 20 #include &lt;linux/pm_runtime.h&gt;\n 21 #include &lt;asm/uaccess.h&gt;\n 22 \n 23 #define  BUFF_SIZE          64\n 24 #define  EEPROM_PAGE_SIZE   8\n 25 #define  LEN_GET(index,len)    \\\n 26         (((index+EEPROM_PAGE_SIZE)&lt;(len))?(EEPROM_PAGE_SIZE):(len-index))\n 27 \n 28 enum type\n 29 { \n 30     at24c01x,\n 31     at24c02x,\n 32     at24c04x,\n 33     at24c08x,\n 34     at24c16x,\n 35 };\n 36 \n 37 enum mem_size\n 38 { \n 39     AT24C01=(1&lt;&lt;10),\n 40     AT24C02=(2&lt;&lt;10),\n 41     AT24C04=(4&lt;&lt;10),\n 42     AT24C08=(8&lt;&lt;10),\n 43     AT24C16=(16&lt;&lt;10),\n 44 };\n 45 \n 46 struct eeprom_chip {\n 47     struct miscdevice    devmisc;\n 48     struct i2c_client    *client;\n 49     struct iic_ops      *ops;\n 50     struct device       *dev;\n 51     struct mutex        eeprom_mutex;\n 52     char                buf[BUFF_SIZE];\n 53     enum mem_size       memsize;\n 54     uint8_t             is_open;\n 55     kernel_ulong_t      eeprom_type;\n 56 \n 57 };\n 58 \n 59 struct iic_ops{\n 60     int (*send)(struct eeprom_chip *, size_t,short);\n 61     int (*recv)(struct eeprom_chip *, size_t,short);\n 62 };\n 63 \n 64 static enum mem_size get_eeprom_memsize(enum type type)\n 65 {\n 66     enum mem_size mem_size;\n 67     switch(type)\n 68     {\n 69         case at24c01x:\n 70             mem_size = AT24C01;\n 71             break;\n 72         case at24c02x:\n 73             mem_size = AT24C02;\n 74             break;\n 75         case at24c04x:\n 76             mem_size = AT24C04;\n 77             break;\n 78         case at24c08x:\n 79             mem_size = AT24C08;\n 80             break;\n 81         case at24c16x:\n 82             mem_size = AT24C16;\n 83             break;\n 84         default:\n 85             mem_size = AT24C01;\n 86             break;\n 87     }\n 88     return mem_size;\n 89 }\n 90 \n 91 static short get_device_addr(struct eeprom_chip  *chip,short pos)\n 92 {\n 93     short  addr_dataaddr;\n 94     struct i2c_client *client = chip-&gt;client;\n 95     addr_dataaddr =client-&gt;addr;\n 96 \n 97     if(chip-&gt;eeprom_type &lt;= at24c04x)\n 98     {\n 99         addr_dataaddr =addr_dataaddr|(pos&amp;0x100);\n100     }else if (chip-&gt;eeprom_type == at24c08x){\n101         addr_dataaddr =addr_dataaddr|(pos&amp;0x300);\n102     }else if (chip-&gt;eeprom_type == at24c16x){\n103         addr_dataaddr =addr_dataaddr|(pos&amp;0x700);\n104     }\n105     return addr_dataaddr;\n106 }\n107 static int i2c_eeprom_write(struct eeprom_chip *chip, size_t len,short pos)\n108 {\n109     char   w_buf[10];\n110     int    status,i=0,ret=0;\n111     short  page_cnt,write_index=0;\n112     short  align_pos = ((pos+EEPROM_PAGE_SIZE-1)/8)*8;\n113     struct i2c_client *client = chip-&gt;client;\n114     struct  i2c_msg msg={\n115         .flags = I2C_M_NOSTART,\n116         .buf = w_buf,\n117     };\n118     if(align_pos == pos){\n119         page_cnt = ((len+EEPROM_PAGE_SIZE-1)/8);\n120     }else{\n121         page_cnt = 1+((len-(align_pos-pos)+EEPROM_PAGE_SIZE-1)/8);\n122     }\n123     for(i=0;i&lt;page_cnt;i++)\n124     {\n125         if((align_pos != pos)&amp;&amp;!i){\n126             msg.len = align_pos-pos+1;\n127         }else{\n128             msg.len = LEN_GET(write_index,len)+1;\n129         }\n130         msg.addr =get_device_addr(chip,pos+write_index);\n131         w_buf[0] = pos+write_index;\n132         memcpy(&amp;w_buf[1],&amp;chip-&gt;buf[write_index],msg.len);\n133         write_index += msg.len-1;\n134         // w_buf[msg.len] = '\\0';\n135         // printk(KERN_INFO \"%02x\\n\",w_buf[0]);\n136         // printk(KERN_INFO \"%s\\n\",&amp;w_buf[1]);\n137         status = i2c_transfer(client-&gt;adapter,&amp;msg,1);\n138         if(status)\n139         {\n140             ret+=msg.len-1;\n141         }\n142         mdelay(1);\n143     }\n144     memset(chip-&gt;buf,0,BUFF_SIZE);\n145     return ret;\n146 }\n147 \n148 static int i2c_eeprom_read(struct eeprom_chip *chip, size_t count,short pos)\n149 {\n150     int rc;\n151     u8 data_addr = 0xFF&amp;pos;\n152     struct i2c_client *client = chip-&gt;client;\n153     \n154     struct i2c_msg  msg[]={\n155         [0]={\n156             .addr = get_device_addr(chip,pos),\n157             .flags = client-&gt;flags &amp; I2C_M_TEN,\n158             .len = 1,\n159             .buf = &amp;data_addr,\n160         },\n161         [1]={\n162             .addr = get_device_addr(chip,pos),\n163             .flags = I2C_M_RD,\n164             .len = count,\n165             .buf = chip-&gt;buf,\n166         },\n167     };\n168     rc= i2c_transfer(client-&gt;adapter,msg,2);\n169     if(rc==2)\n170         return count;\n171     return 0;\n172 }\n173 \n174 static int eeprom_open(struct inode *inode,struct file *filp)\n175 {\n176     struct miscdevice *misc = filp-&gt;private_data;\n177     struct eeprom_chip* chip = container_of(misc, struct eeprom_chip,\n178                          devmisc); \n179     // printk(KERN_INFO \"eeprom_open\\n\");                  \n180     if(chip-&gt;is_open){\n181         // printk(KERN_INFO \"eeprom_open busy\\n\"); \n182         return -EBUSY; \n183     }\n184     filp-&gt;private_data =  chip;\n185     chip-&gt;is_open = 1;\n186     return 0;\n187 }\n188 \n189 static ssize_t eeprom_read(struct file* filp,char* __user buf,size_t cnt,loff_t *offt)\n190 {\n191     int ret,count;\n192     loff_t new_pos = *offt +cnt;\n193     struct eeprom_chip* chip = filp-&gt;private_data;\n194     // printk(KERN_INFO \"eeprom_read\\n\");\n195     if(new_pos&gt;chip-&gt;memsize)\n196     {\n197         // printk(KERN_INFO \"eeprom_open mem\\n\"); \n198         return -ENOMEM; \n199     }\n200     if(cnt &gt; BUFF_SIZE)\n201     {\n202         // printk(KERN_INFO \"eeprom_open mem\\n\");\n203         return -ENOMEM; \n204     }\n205     // printk(KERN_INFO \"position is %ld\\n\",(size_t)*offt);\n206     mutex_lock(&amp;chip-&gt;eeprom_mutex);\n207     count=chip-&gt;ops-&gt;recv(chip,cnt, *offt);\n208     // printk(KERN_INFO \"chip-&gt;ops-&gt;recv return %d\\n\",count);\n209     ret = copy_to_user((void*)buf,(void*)chip-&gt;buf,count);\n210     if(ret){\n211         return -EIO;\n212     }\n213     mutex_unlock(&amp;chip-&gt;eeprom_mutex);\n214     *offt += count;\n215     return count;\n216 }\n217 \n218 static ssize_t eeprom_write(struct file* filp,const char*__user  buf,size_t cnt ,loff_t *offt)\n219 {\n220     int ret;\n221     loff_t new_pos = *offt +cnt; \n222     struct eeprom_chip* chip = filp-&gt;private_data;\n223     // printk(KERN_INFO \"eeprom_write\\n\");\n224     if(new_pos&gt;chip-&gt;memsize)\n225     {\n226         // printk(KERN_INFO \"eeprom_open mem\\n\");\n227         return -ENOMEM; \n228     }\n229     if(cnt&gt;BUFF_SIZE)\n230     {\n231         // printk(KERN_INFO \"eeprom_open mem\\n\");\n232         return -ENOMEM; \n233     }\n234     // printk(KERN_INFO \"position is %ld\\n\",(size_t)*offt);\n235     ret=copy_from_user((void*)chip-&gt;buf,(void*)buf,cnt);\n236     if(ret){\n237         return -EIO;\n238     }\n239     mutex_lock(&amp;chip-&gt;eeprom_mutex);\n240     ret=chip-&gt;ops-&gt;send(chip,cnt,*offt);\n241     // printk(KERN_INFO \"chip-&gt;ops-&gt; send %d\\n\",ret);\n242     mutex_unlock(&amp;chip-&gt;eeprom_mutex);\n243     *offt += ret;\n244     return ret;\n245 }\n246 \n247 static loff_t eeprom_llseek(struct file *filp,loff_t vel,int orig )\n248 {\n249     \n250     struct eeprom_chip* chip = filp-&gt;private_data;\n251     mutex_lock(&amp;chip-&gt;eeprom_mutex);\n252     switch (orig)\n253     {\n254         //cur\n255         case 1:\n256             if( (filp-&gt;f_pos + vel) &lt; 0 || (filp-&gt;f_pos + vel)&gt;chip-&gt;memsize)\n257                 return -ESPIPE;\n258             filp-&gt;f_pos += vel;\n259             /* code */\n260             break;\n261         //end\n262         case 2:\n263             if(vel &gt; 0||(vel+filp-&gt;f_pos)&lt;0)\n264                 return -ESPIPE;\n265             filp-&gt;f_pos += vel;\n266             /* code */\n267             break;\n268         //set\n269         default:\n270             if(vel&gt;chip-&gt;memsize || vel&lt;0)\n271                 return -ESPIPE;\n272             filp-&gt;f_pos = vel;    \n273             break;\n274     }\n275     mutex_unlock(&amp;chip-&gt;eeprom_mutex);\n276     return 0;\n277 }\n278 \n279 static int eeprom_close(struct inode *inode,struct file *filp)\n280 {\n281     \n282     struct eeprom_chip* chip = filp-&gt;private_data;\n283     filp-&gt;private_data = NULL;\n284     // printk(KERN_INFO \"eeprom_close\\n\");\n285     chip-&gt;is_open = 0;\n286     \n287     return 0;\n288 }\n289 \n290 struct file_operations eeprom_ops={\n291     .owner = THIS_MODULE,\n292     .open = eeprom_open,\n293     .write = eeprom_write,\n294     .read = eeprom_read,\n295     .llseek = eeprom_llseek,\n296     .release = eeprom_close ,\n297 };\n298 \n299 struct iic_ops  iic_ops={\n300     .recv = i2c_eeprom_read,\n301     .send = i2c_eeprom_write,\n302 };\n303 static struct i2c_device_id at24c0xx_idtable[] = {\n304     { \"24c04x\", at24c04x},\n305     { \"24c08x\",at24c08x},\n306     { \"24c16x\",at24c16x},\n307     { }\n308 };\n309 \n310 static int at24c0xx_probe(struct i2c_client *client,\n311                   const struct i2c_device_id *id)\n312 {\n313     int rc;\n314     struct eeprom_chip *eeprom;\n315     struct device *dev = &amp;client-&gt;dev;\n316     /* check function*/\n317     if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C))\n318         return -ENODEV;\n319     eeprom = devm_kzalloc(&amp;client-&gt;dev,sizeof(struct eeprom_chip), GFP_KERNEL);\n320     if (eeprom == NULL) {\n321         printk(KERN_INFO \"failed to create our eeprom_data\\n\");\n322         return -ENOMEM;\n323     }\n324     eeprom-&gt;eeprom_type = id-&gt;driver_data;\n325     eeprom-&gt;dev=get_device(dev);\n326     eeprom-&gt;client = client;\n327     eeprom-&gt;ops = &amp;iic_ops;\n328     eeprom-&gt;devmisc.fops = &amp;eeprom_ops;\n329     eeprom-&gt;devmisc.minor = 223;\n330     eeprom-&gt;devmisc.name=client-&gt;name;\n331     eeprom-&gt;devmisc.parent = eeprom-&gt;dev;\n332     eeprom-&gt;memsize = get_eeprom_memsize(eeprom-&gt;eeprom_type);\n333     // printk(KERN_INFO \"I2C:at24c0x:%d byte\\n\",eeprom-&gt;memsize);\n334     mutex_init(&amp;eeprom-&gt;eeprom_mutex);\n335     rc = misc_register(&amp;eeprom-&gt;devmisc);\n336     if (rc) {\n337         printk(KERN_INFO \"%s client created misc_register Fail\\n\",client-&gt;name);\n338     }\n339     i2c_set_clientdata(client, eeprom);\n340     /* rest of the initialisation goes here. */\n341     // printk(KERN_INFO \"%s client created\\n\",client-&gt;name);\n342 \n343     return 0;\n344 }\n345 \n346 static int at24c0xx_remove(struct i2c_client *client)\n347 {\n348     struct eeprom_chip *eeprom = i2c_get_clientdata(client);\n349     struct device *dev = &amp;client-&gt;dev;\n350     misc_deregister(&amp;eeprom-&gt;devmisc);\n351     put_device(dev);\n352     return 0;\n353 }\n354 \n355 static struct i2c_driver eerom_driver = {\n356     .driver = {\n357         .name    = \"at24xx\",\n358     },\n359     .id_table    = at24c0xx_idtable,\n360     .probe        = at24c0xx_probe,\n361     .remove        = at24c0xx_remove,\n362     /* if device autodetection is needed: */\n363     // .class        = I2C_CLASS_SOMETHING,\n364     // .detect        = at24_detect,\n365     // .address_list    = normal_i2c,\n366 };\n367 \n368 int __init eeprom_i2c_driver_init(void)\n369 {\n370     int retval;\n371 \n372     retval=i2c_add_driver(&amp;eerom_driver);\n373     if(retval)\n374     {\n375         printk(KERN_INFO \"eeprom_i2c_driver_init fail\\n\");\n376     }\n377     // printk(KERN_INFO \"i2c_add_driver eerom_driver\\n\");\n378     return 0;\n379 }\n380 \n381 void __exit eeprom_i2c_driver_exit(void)\n382 {\n383     i2c_del_driver(&amp;eerom_driver);\n384 }\n385 \n386 module_init(eeprom_i2c_driver_init);\n387 module_exit(eeprom_i2c_driver_exit);\n388 \n389 MODULE_LICENSE(\"GPL\");\n390 MODULE_DESCRIPTION(\"This is an general driver of atmel eeprom 24xx\");\n391 MODULE_VERSION(\"0.1\");\n392 MODULE_AUTHOR(\"smile\");</pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/e9ffc2fffb17b9d01253f96df5966b54.gif\"/></p>\n<p>设备添加部分</p>\n<pre>static struct i2c_board_info smdkv210_i2c_devs0[] __initdata = {\n    { I2C_BOARD_INFO(\"24c08x\", 0x50), },     /* Samsung S524AD0XD1 */\n    { I2C_BOARD_INFO(\"wm8580\", 0x1b), },\n};</pre>\n<p>通过这一段的学习发现Linux驱动基本都是多元部分的组合实现，学习过程是一个拼积木的过程各个部分的小知识点的不断累计最后才能看明白内核中别人实现好的一个驱动。可以看看基础的部分，如内核内部的并发控制，同步异步IO的实现，阻塞和非阻塞、中断等一些基本但是非常通用的知识点内容从而巩固整体驱动开发知识体系的完善，加深Linux驱动框架的理解，从而在驱动开发上更加自由灵活也对应用的开发提供内核实现机制的深入理解基础。</p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-31 13:45:04", "summary": "目录驱动架构总线驱动设备驱动和设备驱动架构驱动在通过一个周的学习后发现总线的驱动框架还是和整体的驱动框架是相同的，思想并不特殊比较复杂的内容如核心的内容都是内核驱动框架实现完成的，今天我们暂时只分析驱"}