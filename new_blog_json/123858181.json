{"blogid": "123858181", "writerAge": "码龄4年", "writerBlogNum": "120", "writerCollect": "64742", "writerComment": "2307", "writerFan": "27138", "writerGrade": "8级", "writerIntegral": "33123", "writerName": "Z小旋", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123858181.jpg", "writerRankTotal": "169", "writerRankWeekly": "312", "writerThumb": "22014", "writerVisitNum": "3467415", "blog_read_count": "1886", "blog_time": "于 2022-08-25 16:14:51 发布", "blog_title": "STM32状态机编程----什么是状态机？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p><strong>万事万物都有其状态</strong></p>\n</blockquote>\n<h2><a id=\"_2\"></a>什么是状态</h2>\n<p><strong>状态是人或事物表现出来的形态。是指现实（或虚拟）事物处于生成、生存、发展、消亡时期或各转化临界点时的形态或事物态势。</strong></p>\n<p><strong>通过上面那句话，我们知道了状态就是一个对象在不同情况下对应的各种形态</strong></p>\n<hr/>\n<p>做产品的时候，如果我们如果要对这个对象所有的形态进行描述，在一些对象复杂的逻辑状态下，比较复杂的逻辑问题，普通的流程图，或时序图对于对象和状态的解读缺乏直观的描述。</p>\n<p><strong>这个时候就需要状态机来对对象的各个形态进行描述，将对象的全部工作方式，分成几个场景，这些场景的工作方式不同，然后将这些场景通过数学模型表示出来</strong></p>\n<hr/>\n<p><strong>比方说一个小灯泡的开关，就是一个最基本的小型状态机</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ac82c0e115b94805836dfc98df080ed4.png\"/><br/> 这里就是两个状态：<strong>①打开开关，灯泡亮，②关闭开关，灯泡灭</strong></p>\n<p>对应的状态机图：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\797a7d15ffe940e9ab570212c19ddf77.png\"/><br/> 这就是最简单的一个状态机</p>\n<p>状态机方便的地方是，如果现在我们只有两种状态，这两个<strong>状态</strong>在 <code>打开开关/关闭开关</code>两个<strong>条件</strong>之间跳转，如果我们要加上一个新的<strong>条件</strong>，比方说我们设定了定时开关灯，多了一个跳转<strong>条件</strong>，如果灯泡开了超过8个小时就自动关闭，除非再次做打开开关，否则灯泡一致处于关闭状态，这个状态图如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0641f97c39eb422194cc8d05561d0749.png\"/></p>\n<p><strong>是不是很方便</strong></p>\n<p>再举个最简单的例子。人有三个状态<strong>健康，感冒，康复中</strong>。<br/> 触发的条件有<strong>淋雨(t1)，吃药(t2)，打针(t3)，休息(t4)</strong>。<br/> 所以状态机就是<strong>健康-&gt;(t4)-&gt;健康;健康-&gt;(t1)-&gt;感冒;感冒-&gt;(t3)-&gt;健康;感冒-&gt;(t2)-&gt;康复中;康复中-&gt;(t4)-&gt;健康</strong>，等等。就是这样状态在不同的条件下跳转到自己或不同状态的情况，就叫做状态机。</p>\n<h2><a id=\"_47\"></a>状态机要素</h2>\n<p>通过上面的举例，我们可以讲状态机可归纳为4个要素，即<strong>现态、条件、动作、次态</strong>。这样的归纳，主要是出于对状态机的内在因果关系的考虑。<strong>“现态”和“条件”是因，“动作”和“次态”是果</strong>。详解如下：</p>\n<ul><li> <p>①<strong>现态：是指当前所处的状态。</strong></p> </li><li> <p>②<strong>条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</strong></p> </li><li> <p>③<strong>动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</strong></p> </li><li> <p>④<strong>次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</strong></p> </li></ul>\n<blockquote>\n<p>状态机是一种编程思路。是现实事物运行规则抽象而成的一个数学模型。</p>\n</blockquote>\n<h2><a id=\"_63\"></a>有限状态机</h2>\n<p>有限状态机简称就是状态机，因为一般的状态机的状态都是离散和可举的，即为有限，所以后面的介绍都不加有限二字**。状态机表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型**。通俗的描述状态机就是定义了一套状态変更的流程：</p>\n<p><strong>状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。</strong></p>\n<h2><a id=\"STD_71\"></a>状态迁移图（STD）</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0923ab4c504c4193bdee079d3c13cac1.png\"/></p>\n<ul><li>（1）<strong>状态框</strong>：用方框表示状态，包括所谓的“现态”和“次态”；</li><li>（2）<strong>条件及迁移箭头</strong>：用箭头表示状态迁移的方向，并在该箭头上标注触发条件；</li><li>（3）<strong>节点圆圈</strong>：当多个箭头指向一个状态时，可以用节点符号（小圆圈）连接汇总；</li><li>（4）<strong>动作框</strong>：用椭圆框表示；</li><li>（5）<strong>附加条件判断框</strong>：用六角菱形框表示；</li></ul>\n<p><strong>状态表：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\78553d65cac649ccb65f38e56cd3a2e2.png\"/></p>\n<h2><a id=\"STM32_89\"></a>STM32中的状态机</h2>\n<p>举个简单的例子：就按键处理来说，<strong>按键动作本身</strong>也可以看做一个状态机。一个细小的击键动作包含了：<strong>释放、抖动、按下、抖动和重新释放等状态</strong>。　　当我们打开思路，把状态机作为一种思想导入到程序中去时，就会找到处理疑问的一条有效的捷径。有时候用状态机的思维去思考程序该干什么，比用控制流程的思维去思考，可能会更有效。这样一来状态机便有了更实际的功用。废话不多说，实践才是检验真理的唯一标准。</p>\n<p>也许有人觉得状态机把问题复杂化了，其实我们在编写代码的时候在无形之中已经使用了状态机的思想，比方说我们的if else 判断</p>\n<h3><a id=\"if_else_99\"></a>if else语句结构状态机</h3>\n<pre><code class=\"prism language-csharp\"><span class=\"token keyword\">if</span> 条件<span class=\"token number\">1</span>\n\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span>  条件<span class=\"token number\">2</span>\n\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span>   条件<span class=\"token number\">3</span>\n\n<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token keyword\">else</span>  条件n\n</code></pre>\n<p><strong>我们知道C语言的if else if语句是从第一条开始判断的，如果符合条件的那一行永远在后面几行，那么就要每次多执行很多次的if …而if是判断语句，括号内的判断是要执行运算的，即使是单周期指令的MCU，在进行乘除运算等都需要消耗多个时钟周期，因此，每次多执行1次判断至少浪费一个时钟周期甚至更多，因此，这样子的状态机无疑是效率低下的，系统软件设计会很复杂。</strong></p>\n<h2><a id=\"switch_case_119\"></a>switch case结构状态机</h2>\n<pre><code class=\"prism language-csharp\">　<span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>。\n\n　　case1<span class=\"token punctuation\">:</span>。\n\n　　<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span>反复执行状态<span class=\"token number\">1</span><span class=\"token punctuation\">)</span>。\n\n　　进入<span class=\"token number\">1</span>状态前要做的准备。\n\n　　进入<span class=\"token number\">1</span>状态的过程。\n\n　　<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span>反复执行状态<span class=\"token number\">1</span><span class=\"token punctuation\">)</span>。\n\n　　离开状态<span class=\"token number\">1</span>的过程。\n\n　　case2<span class=\"token punctuation\">:</span>。\n\n　　<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>。\n</code></pre>\n<p>使用Switch case 相较于if else的好处就是可以清楚的看到所有的状态，然后代码架构更清楚点，但是实际的运行效率还是没有提高</p>\n<hr/>\n<p>再说一下使用Switch编写状态机的两种写法</p>\n<p>我们假设状态机的状态转换由下表所示：<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ff7fff92a3fc4c97bf81ddefd1356830.png\"/>当处于State0时发生event0 则执行action0并将状态变成state1，当state1状态下发生event2则执行action6并将状态变成state2。以此类推。</p>\n<p>下面描述下实现上述状态机的两种不同的写法：<br/> 1）<strong>竖着写：在状态中判断事件，并执行相应的操作，完成相应的状态转换。</strong><br/> 2）<strong>横着写：在事件中根据当前的状态，执行相应的操作，完成相应的状态转换。</strong></p>\n<pre><code class=\"prism language-csharp\"><span class=\"token comment\">//竖着写</span>\n<span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>cur_state<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">case</span> State0<span class=\"token punctuation\">:</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event1<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{<!-- --></span>\n             action0<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State1<span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event2<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{<!-- --></span>\n              action4<span class=\"token punctuation\">;</span>\n              cur_state <span class=\"token operator\">=</span> State1<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event3<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{<!-- --></span>\n              action5<span class=\"token punctuation\">;</span>\n              cur_state <span class=\"token operator\">=</span> State2<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n       <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> State1<span class=\"token punctuation\">:</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event1<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{<!-- --></span>\n             action1<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State2<span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event3<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{<!-- --></span>\n              action6<span class=\"token punctuation\">;</span>\n              cur_state <span class=\"token operator\">=</span> State0<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">case</span> State2<span class=\"token punctuation\">:</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>event1<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{<!-- --></span>\n             action3<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State0<span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre><code class=\"prism language-csharp\"><span class=\"token comment\">//横着写</span>\n<span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">event0func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>cur_state<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">case</span> State0<span class=\"token punctuation\">:</span>\n             action0<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State1<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">case</span> State1<span class=\"token punctuation\">:</span>\n             action1<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State2<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">case</span> State2<span class=\"token punctuation\">:</span>\n             action1<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State0<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">event1func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>cur_state<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">case</span> State0<span class=\"token punctuation\">:</span>\n             action4<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State1<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">event2func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>cur_state<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">case</span> State0<span class=\"token punctuation\">:</span>\n             action5<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State2<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">case</span> State1<span class=\"token punctuation\">:</span>\n             action6<span class=\"token punctuation\">;</span>\n             cur_state <span class=\"token operator\">=</span> State0<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n</code></pre>\n<p>上述两种写法实现的功能完全相同，对比两种写法：</p>\n<p><strong>1）写法1（竖着写）使用了if -else if语句隐含了优先级，破坏可事件间的原有关系（各个时间应该同优先级）<br/> 2）写法1（竖着写）在结构上是顺序查询方式（查询事件），浪费大量的时间，而且时间不可估算。<br/> 写法2（横着写）因为在某个时间点上状态是唯一确定的，在时间处理函数中通过switch语句可直接定位到相同状态，执行时间也可以估算。<br/> 3）写法2（横着写）比较直观，程序执行效率较高。<br/> 总体来说：写法2要优于写法1。</strong></p>\n<p><font color=\"red\"><strong>但是不论是在事件中判断状态，在状态中判断事件，横竖两种写法的代码都比较冗长，看起来呢也不大好，一旦增减，就又要动脑子重新梳理一遍，实际编写我们并不采用这两种写法</strong></font></p>\n<hr/>\n<p>那么下一节我们将用STM32实现LED的状态机编程，用状态机的4个要素，让您了解下状态机编程的方便之处。</p>\n<p><img alt=\"请添加图片描述\" src=\"https://img-blog.csdnimg.cn/089bff25de304051b1253c89f6026c39.gif\"/></p>\n<p><img alt=\"请添加图片描述\" src=\"https://img-blog.csdnimg.cn/43bfd4102c824e8099d8934e35202750.gif\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-25 16:14:51", "summary": "万事万物都有其状态什么是状态状态是人或事物表现出来的形态。是指现实或虚拟事物处于生成、生存、发展、消亡时期或各转化临界点时的形态或事物态势。通过上面那句话，我们知道了状态就是一个对象在不同情况下对应的"}