{"blogid": "126743732", "writerAge": "码龄1年", "writerBlogNum": "418", "writerCollect": "184", "writerComment": "16", "writerFan": "6396", "writerGrade": "5级", "writerIntegral": "4363", "writerName": "web15185420056", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126743732.jpg", "writerRankTotal": "4397", "writerRankWeekly": "1398", "writerThumb": "46", "writerVisitNum": "170801", "blog_read_count": "15", "blog_time": "于 2022-09-07 13:22:16 发布", "blog_title": "JVM内存布局", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>目录</strong></p>\n<p><a href=\"#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\">内存布局</a></p>\n<p><a href=\"#Heap%EF%BC%88%E5%A0%86%EF%BC%89\">Heap（堆）</a></p>\n<p><a href=\"#Metaspace%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89\">Metaspace（元空间）</a></p>\n<p><a href=\"#JVM%20Stack%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%89\">JVM Stack（虚拟机栈）</a></p>\n<p><a href=\"#Native%20Method%20Stack%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%89\">Native Method Stack（本地方法栈）</a></p>\n<p><a href=\"#Program%20Counter%20Register%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89\">Program Counter Register（程序计数寄存器）</a></p>\n<h2><a id=\"_16\"></a>内存布局</h2>\n<p>JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM高效稳定的运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\20190108001817189.png\"/></p>\n<p>JVM内存布局</p>\n<p>从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈、本地方法栈、程序计数器是线程内部私有的。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\20190108001447427.png\"/></p>\n<p>Java的线程与内存</p>\n<hr/>\n<h2><a id=\"Heap_33\"></a>Heap（堆）</h2>\n<p>Heap是OOM故障的最主要发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆由各个子线程共享使用。</p>\n<p>堆分成两大块：新生代和老年代。</p>\n<p>对象产生之初在新生代，步入暮年时进入老年代，但老年代也接纳在新生代无法容纳的超大对象。</p>\n<p>新生代分成三部分：一个Eden区，两个Survivor区。</p>\n<p>绝大部分对象在Eden区生成，当Eden区满了的时候，会触发Young Garbage Collection，即YGC。没有被引用的对象直接回收，依然存活的对象被移送到Survivor区。</p>\n<p>Survivor区分为S0和S1两块内存空间，每次YGC时，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。另外每个对象都有一个计数器，记录了存活对象的年龄，当达到一个阈值的时候直接移至老年代，这个阈值默认是15，通过参数-XX：MaxTenuringThreshold控制。</p>\n<p>如果YGC要移送的对象大于Survivor区容量的上限，则直接移至老年代。如果老年代也无法放下，则会触发Full Garbage Collection，即FGC。如果依然无法放下，则抛出OOM。</p>\n<p>通过设置参数-XX：+HeapDumpOnOutOfMemoryError，使JVM在遇到OOM异常时能够输入堆内信息，以便分析问题原因。</p>\n<hr/>\n<h2><a id=\"Metaspace_54\"></a>Metaspace（元空间）</h2>\n<p>在JDK8中，使用元空间代替永久代。</p>\n<p>区别于永久代，元空间在本地内存中分配，永久代中的所有内容中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等都移至元空间内。</p>\n<hr/>\n<h2><a id=\"JVM_Stack_63\"></a>JVM Stack（虚拟机栈）</h2>\n<p>栈是一个先进后出的数据结构。</p>\n<p>JVM中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的。</p>\n<p><strong>栈中的数据都是以栈帧的格式存在，每个方法执行的同时都会创建一个栈帧，方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程。</strong></p>\n<p>在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，方法执行完会跳转到另一个栈帧上，栈帧是方法运行的基本结构。</p>\n<p>栈帧中又包括局部变量表、操作栈、动态连接、方法返回地址等。</p>\n<p>（1） 局部变量表：是存放方法参数和局部变量（基本数据类型与引用类型）的区域。相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显示初始化。</p>\n<p>（2） 操作栈：是一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。</p>\n<p>（3） 动态连接：每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接。</p>\n<p>（4） 方法返回地址：方法执行时有两种退出情况：第一，正常退出；第二，异常退出。无论何种退出情况，都将返回至方法当前被调用的位置，相当于弹出当前栈帧。</p>\n<p>StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。</p>\n<hr/>\n<h2><a id=\"Native_Method_Stack_88\"></a>Native Method Stack（本地方法栈）</h2>\n<p>本地方法栈在JVM内存布局中，也是线程对象私有的，但是虚拟机栈“主内”，而本地方法栈“主外”，这里“内外”是针对JVM。</p>\n<p>本地方法栈为Native方法服务，线程调用本地方法时，会进入一个不再受JVM约束的世界。</p>\n<p>本地方法可以通过JNI（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。</p>\n<p>当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为它的出错信息都比较黑盒，对于内存不足的情况，本地方法栈还是会抛出native heap OutOfMemory。</p>\n<hr/>\n<h2><a id=\"Program_Counter_Register_101\"></a>Program Counter Register（程序计数寄存器）</h2>\n<p>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 13:22:16", "summary": "目录内存布局堆元空间虚拟机栈本地方法栈程序计数寄存器内存布局内存布局规定了在运行过程中内存申请、分配、管理的策略，保证了高效稳定的运行。不同的对于内存的划分方式和管理机制存在着部分差异。内存布局从线程"}