{"blogid": "117868448", "writerAge": "码龄15年", "writerBlogNum": "277", "writerCollect": "7288", "writerComment": "2025", "writerFan": "17822", "writerGrade": "7级", "writerIntegral": "22283", "writerName": "beyondma", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_117868448.jpg", "writerRankTotal": "330", "writerRankWeekly": "5420", "writerThumb": "6169", "writerVisitNum": "1703564", "blog_read_count": "32814", "blog_time": "于 2021-06-13 11:26:39 发布", "blog_title": "C和Java没那么香了，Serverless时代Rust即将称王？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>笔者在上周参加阿里云开发者大会时，特别注意到一个现象就是Serverless这个概念被反复提及，其受关注程度提升明显，笔者仔细看了一下，Serverless的核心理念就是函数式计算，开发者不需要再关注具体的模块，云上部署的粒度变成了程序函数，自动伸缩、扩容等工作完全由云服务负责，能够想象Serverless必将在未来引领时代潮流。</p>\n<p>Serverless Computing，即”无服务器计算”，其实这一概念在刚刚提出的时候并没有获得太多的关注，直到2014年AWS Lambda这一里程碑式的产品出现。Serverless算是正式走进了云计算的舞台。2018年5月，Google在KubeCon+CloudNative 2018期间开源了gVisor容器沙箱运行时并分享了它的设计理念和原则。随后2018年的Google Next大会上Google推出了自己的 Google Serverless平台 —— gVisor。同年AWS又放了颗大炮仗-Firecracker，这是一款基于Rust语言编写的安全沙箱基础组件，用于函数计算服务Lambda和托管的容器服务。而值得注意的是Google也并没有死守自己一手缔造的Go语言平台，而是选择了Go与Rust的模式，据说Google在Rust方面也开始招兵买马，也要用Rust重写之前基于Go编写的Serverless平台。</p>\n<p>笔者写本文的初衷，其实就是要回答为什么在这个高并发大行其道的时代，以性能著称的C语言和以安全高效闻名的Java都不香了呢？</p>\n<h3>高并发模式初探</h3>\n<p>在这个高并发时代最重要的设计模式无疑是生产者、消费者模式，比如著名的消息队列kafka其实就是一个生产者消费者模式的典型实现。其实生产者消费者问题，也就是有限缓冲问题，可以用以下场景进行简要描述，生产者生成一定量的产品放到库房，并不断重复此过程；与此同时，消费者也在缓冲区消耗这些数据，但由于库房大小有限，所以生产者和消费者之间步调协调，<strong>生产者不会在库房满的情况放入端口，消费者也不会在库房空时消耗数据。</strong>详见下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"335\" src=\"..\\..\\static\\image\\20200411210623772.png\" width=\"666\"/></p>\n<p>而如果在生产者与消费者之间完美协调并保持高效，这就是高并发要解决的本质问题。</p>\n<h3>  C语言的高并发案例</h3>\n<p>     笔者在前文<a href=\"https://beyondma.blog.csdn.net/article/details/96578186\">《这位创造了Github冠军项目的老男人，堪称10倍程序员本尊》</a>曾经介绍过TDEngine的相关代码，其中Sheduler模块的相关调度算法就使用了生产、消费者模式进行消息传递功能的实现，也就是有多个生产者(producer)生成并不断向队列中传递消息，也有多个消费者（consumer）不断从队列中取消息。</p>\n<p>后面我们也会说明类型功能在Go、Java等高级语言中类似的功能已经被封装好了，但是在C语言中你就必须要用好互斥体（ mutex）和信号量（semaphore）并协调他们之间的关系。由于C语言的实现是最复杂的，先来看结构体设计和他的注释：</p>\n<pre class=\"has\"><code class=\"language-cpp\">typedef struct {\n  char            label[16];//消息内容\n  sem_t           emptySem;//此信号量代表队列的可写状态\n  sem_t           fullSem;//此信号量代表队列的可读状态\n  pthread_mutex_t queueMutex;//此互斥体为保证消息不会被误修改，保证线程程安全\n  int             fullSlot;//队尾位置\n  int             emptySlot;//队头位置\n  int             queueSize;#队列长度\n  int             numOfThreads;//同时操作的线程数量\n  pthread_t *     qthread;//线程指针\n  SSchedMsg *     queue;//队列指针\n} SSchedQueue;\n\n\n\n</code></pre>\n<p>   再来看Shceduler初始化函数，这里需要特别说明的是，两个信号量的创建，其中emptySem是队列的可写状态，初始化时其值为queueSize，即初始时队列可写，可接受消息长度为队列长度，fullSem是队列的可读状态，初始化时其值为0，即初始时队列不可读。具体代码及我的注释如下：</p>\n<pre class=\"has\"><code class=\"language-cpp\">void *taosInitScheduler(int queueSize, int numOfThreads, char *label) {\n  pthread_attr_t attr;\n  SSchedQueue *  pSched = (SSchedQueue *)malloc(sizeof(SSchedQueue));\n\n  memset(pSched, 0, sizeof(SSchedQueue));\n  pSched-&gt;queueSize = queueSize;\n  pSched-&gt;numOfThreads = numOfThreads;\n  strcpy(pSched-&gt;label, label);\n\n  if (pthread_mutex_init(&amp;pSched-&gt;queueMutex, NULL) &lt; 0) {\n    pError(\"init %s:queueMutex failed, reason:%s\", pSched-&gt;label, strerror(errno));\n    goto _error;\n  }\n   //emptySem是队列的可写状态，初始化时其值为queueSize，即初始时队列可写，可接受消息长度为队列长度。\n  if (sem_init(&amp;pSched-&gt;emptySem, 0, (unsigned int)pSched-&gt;queueSize) != 0) {\n    pError(\"init %s:empty semaphore failed, reason:%s\", pSched-&gt;label, strerror(errno));\n    goto _error;\n  }\n //fullSem是队列的可读状态，初始化时其值为0，即初始时队列不可读\n  if (sem_init(&amp;pSched-&gt;fullSem, 0, 0) != 0) {\n    pError(\"init %s:full semaphore failed, reason:%s\", pSched-&gt;label, strerror(errno));\n    goto _error;\n  }\n\n  if ((pSched-&gt;queue = (SSchedMsg *)malloc((size_t)pSched-&gt;queueSize * sizeof(SSchedMsg))) == NULL) {\n    pError(\"%s: no enough memory for queue, reason:%s\", pSched-&gt;label, strerror(errno));\n    goto _error;\n  }\n\n  memset(pSched-&gt;queue, 0, (size_t)pSched-&gt;queueSize * sizeof(SSchedMsg));\n  pSched-&gt;fullSlot = 0;//实始化时队列为空，故队头和队尾的位置都是0\n  pSched-&gt;emptySlot = 0;//实始化时队列为空，故队头和队尾的位置都是0\n\n  pSched-&gt;qthread = malloc(sizeof(pthread_t) * (size_t)pSched-&gt;numOfThreads);\n\n  pthread_attr_init(&amp;attr);\n  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);\n\n  for (int i = 0; i &lt; pSched-&gt;numOfThreads; ++i) {\n    if (pthread_create(pSched-&gt;qthread + i, &amp;attr, taosProcessSchedQueue, (void *)pSched) != 0) {\n      pError(\"%s: failed to create rpc thread, reason:%s\", pSched-&gt;label, strerror(errno));\n      goto _error;\n    }\n  }\n\n  pTrace(\"%s scheduler is initialized, numOfThreads:%d\", pSched-&gt;label, pSched-&gt;numOfThreads);\n\n  return (void *)pSched;\n\n_error:\n  taosCleanUpScheduler(pSched);\n  return NULL;\n}</code></pre>\n<p>再来看读消息的taosProcessSchedQueue函数这其实是消费者一方的实现，这个函数的主要逻辑是</p>\n<p><strong>1.使用无限循环，只要队列可读即sem_wait(&amp;pSched-&gt;fullSem)不再阻塞就继续向下处理<br/> 2.在操作msg前，加入互斥体防止msg被误用。<br/> 3.读操作完毕后修改fullSlot的值，注意这为避免fullSlot溢出，需要对于queueSize取余。同时退出互斥体。</strong><br/> 4.<strong>对emptySem进行post操作，即把emptySem的值加1，如emptySem原值为5，读取一个消息后，emptySem的值为6，即可写状态，且能接受的消息数量为6</strong></p>\n<p>具体代码及注释如下：</p>\n<pre class=\"has\"><code class=\"language-cpp\">void *taosProcessSchedQueue(void *param) {\n  SSchedMsg    msg;\n  SSchedQueue *pSched = (SSchedQueue *)param;\n //注意这里是个无限循环，只要队列可读即sem_wait(&amp;pSched-&gt;fullSem)不再阻塞就继续处理\n  while (1) {\n    if (sem_wait(&amp;pSched-&gt;fullSem) != 0) {\n      pError(\"wait %s fullSem failed, errno:%d, reason:%s\", pSched-&gt;label, errno, strerror(errno));\n      if (errno == EINTR) {\n        /* sem_wait is interrupted by interrupt, ignore and continue */\n        continue;\n      }\n    }\n     //加入互斥体防止msg被误用。\n    if (pthread_mutex_lock(&amp;pSched-&gt;queueMutex) != 0)\n      pError(\"lock %s queueMutex failed, reason:%s\", pSched-&gt;label, strerror(errno));\n\n    msg = pSched-&gt;queue[pSched-&gt;fullSlot];\n    memset(pSched-&gt;queue + pSched-&gt;fullSlot, 0, sizeof(SSchedMsg));\n    //读取完毕修改fullSlot的值，注意这为避免fullSlot溢出，需要对于queueSize取余。\n    pSched-&gt;fullSlot = (pSched-&gt;fullSlot + 1) % pSched-&gt;queueSize;\n     //读取完毕修改退出互斥体\n    if (pthread_mutex_unlock(&amp;pSched-&gt;queueMutex) != 0)\n      pError(\"unlock %s queueMutex failed, reason:%s\\n\", pSched-&gt;label, strerror(errno));\n     //读取完毕对emptySem进行post操作，即把emptySem的值加1，如emptySem原值为5，读取一个消息后，emptySem的值为6，即可写状态，且能接受的消息数量为6\n    if (sem_post(&amp;pSched-&gt;emptySem) != 0)\n      pError(\"post %s emptySem failed, reason:%s\\n\", pSched-&gt;label, strerror(errno));\n\n    if (msg.fp)\n      (*(msg.fp))(&amp;msg);\n    else if (msg.tfp)\n      (*(msg.tfp))(msg.ahandle, msg.thandle);\n  }\n}\n</code></pre>\n<p> 最后写消息的taosScheduleTask函数也就是生产的实现，其基本逻辑是</p>\n<p><strong>1.写队列前先对emptySem进行减1操作，如emptySem原值为1，那么减1后为0，也就是队列已满，必须在读取消息后，即emptySem进行post操作后，队列才能进行可写状态。<br/>  2.加入互斥体防止msg被误操作，写入完成后退出互斥体<br/> 3.写队列完成后对fullSem进行加1操作，如fullSem原值为0，那么加1后为1，也就是队列可读，咱们上面介绍的读取taosProcessSchedQueue中sem_wait(&amp;pSched-&gt;fullSem)不再阻塞就继续向下。</strong></p>\n<pre class=\"has\"><code class=\"language-cpp\">int taosScheduleTask(void *qhandle, SSchedMsg *pMsg) {\n  SSchedQueue *pSched = (SSchedQueue *)qhandle;\n  if (pSched == NULL) {\n    pError(\"sched is not ready, msg:%p is dropped\", pMsg);\n    return 0;\n  }\n  //在写队列前先对emptySem进行减1操作，如emptySem原值为1，那么减1后为0，也就是队列已满，必须在读取消息后，即emptySem进行post操作后，队列才能进行可写状态。\n  if (sem_wait(&amp;pSched-&gt;emptySem) != 0) pError(\"wait %s emptySem failed, reason:%s\", pSched-&gt;label, strerror(errno));\n//加入互斥体防止msg被误操作\n  if (pthread_mutex_lock(&amp;pSched-&gt;queueMutex) != 0)\n    pError(\"lock %s queueMutex failed, reason:%s\", pSched-&gt;label, strerror(errno));\n\n  pSched-&gt;queue[pSched-&gt;emptySlot] = *pMsg;\n  pSched-&gt;emptySlot = (pSched-&gt;emptySlot + 1) % pSched-&gt;queueSize;\n\n  if (pthread_mutex_unlock(&amp;pSched-&gt;queueMutex) != 0)\n    pError(\"unlock %s queueMutex failed, reason:%s\", pSched-&gt;label, strerror(errno));\n  //在写队列前先对fullSem进行加1操作，如fullSem原值为0，那么加1后为1，也就是队列可读，咱们上面介绍的读取函数可以进行处理。\n  if (sem_post(&amp;pSched-&gt;fullSem) != 0) pError(\"post %s fullSem failed, reason:%s\", pSched-&gt;label, strerror(errno));\n\n  return 0;\n}\n</code></pre>\n<h3>Java的高并发实现</h3>\n<p>从并发模型来看，Go和Rust都有channel这个概念，也都是通过Channel来实现线（协）程间的同步，由于channel带有读写状态且保证数据顺序，而且channel的封装程度和效率明显可以做的更高，因此Go和Rust官方都会建议使用channel（通信）来共享内存，而不是使用共享内存来通信。</p>\n<p>为了让帮助大家找到区别，我们先以Java为例来，看一下没有channel的高级语言Java，生产者消费者该如何实现，代码及注释如下：</p>\n<pre><code class=\"language-java\">public class Storage {\n \n    // 仓库最大存储量\n    private final int MAX_SIZE = 10;\n    // 仓库存储的载体\n    private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;();\n    // 锁\n    private final Lock lock = new ReentrantLock();\n    // 仓库满的信号量\n    private final Condition full = lock.newCondition();\n    // 仓库空的信号量\n    private final Condition empty = lock.newCondition();\n \n    public void produce()\n    {\n        // 获得锁\n        lock.lock();\n        while (list.size() + 1 &gt; MAX_SIZE) {\n            System.out.println(\"【生产者\" + Thread.currentThread().getName()\n\t\t             + \"】仓库已满\");\n            try {\n                full.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        list.add(new Object());\n        System.out.println(\"【生产者\" + Thread.currentThread().getName() \n\t\t\t\t + \"】生产一个产品，现库存\" + list.size());\n \n        empty.signalAll();\n        lock.unlock();\n    }\n \n    public void consume()\n    {\n        // 获得锁\n        lock.lock();\n        while (list.size() == 0) {\n            System.out.println(\"【消费者\" + Thread.currentThread().getName()\n\t\t             + \"】仓库为空\");\n            try {\n                empty.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        list.remove();\n        System.out.println(\"【消费者\" + Thread.currentThread().getName()\n\t\t         + \"】消费一个产品，现库存\" + list.size());\n \n        full.signalAll();\n        lock.unlock();\n    }\n}\n</code></pre>\n<p> </p>\n<p>在Java、C#这种面向对象，但是没有channel语言中，生产者、消费者模式至少要借助一个lock和两个信号量共同完成。其中锁的作用是保证同是时间，仓库中只有一个用户进行数据的修改，而还需要表示仓库满的信号量，一旦达到仓库满的情况则将此信号量置为阻塞状态，从而阻止其它生产者再向仓库运商品了，反之仓库空的信号量也是一样，一旦仓库空了，也要阻其它消费者再前来消费了。</p>\n<h3>Go的高并发实现</h3>\n<p>我们刚刚也介绍过了Go语言中官方推荐使用channel来实现协程间通信，所以不需要再添加lock和信号量就能实现模式了，以下代码中我们通过子goroutine完成了生产者的功能，在在另一个子goroutine中实现了消费者的功能，注意要阻塞主goroutine以确保子goroutine能够执行，从而轻而易举的就这完成了生产者消费者模式。下面我们就通过具体实践中来看一下生产者消费者模型的实现。</p>\n<pre><code class=\"language-Go\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc Product(ch chan&lt;- int) { //生产者\n\tfor i := 0; i &lt; 3; i++ {\n\t\tfmt.Println(\"Product  produceed\", i)\n\t\tch &lt;- i //由于channel是goroutine安全的,所以此处没有必要必须加锁或者加lock操作.\n\t}\n}\nfunc Consumer(ch &lt;-chan int) {\n\tfor i := 0; i &lt; 3; i++ {\n\t\tj := &lt;-ch //由于channel是goroutine安全的,所以此处没有必要必须加锁或者加lock操作.\n\t\tfmt.Println(\"Consmuer consumed \", j)\n\t}\n}\nfunc main() {\n\tch := make(chan int)\n\tgo Product(ch)//注意生产者与消费者放在不同goroutine中\n\tgo Consumer(ch)//注意生产者与消费者放在不同goroutine中\n\ttime.Sleep(time.Second * 1)//防止主goroutine退出\n\t/*运行结果并不确定，可能为\n\t\tProduct  produceed 0\n\tProduct  produceed 1\n\tConsmuer consumed  0\n\tConsmuer consumed  1\n\tProduct  produceed 2\n\tConsmuer consumed  2\n\t*/\n\n}</code></pre>\n<p>可以看到和Java比起来使用GO来实现并发式的生产者消费者模式的确是更为清爽了。</p>\n<h3>Rust的高并发实现</h3>\n<p>不得不说Rust的难度实在太高了，虽然笔者之前在汇编、C、Java等方面的经验可以帮助我快速掌握Go语言。但是假期看了两天Rust真想大呼告辞，这尼玛也太劝退了。在Rust官方提供的功能中，其实并不包括多生产者、多消费者的channel，std:sync空间下只有一个多生产者单消费者（mpsc)的channel。其样例实现如下：</p>\n<pre><code>use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let tx1 = mpsc::Sender::clone(&amp;tx);\n    let tx2 = mpsc::Sender::clone(&amp;tx);\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"1\"),\n            String::from(\"3\"),\n            String::from(\"5\"),\n            String::from(\"7\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"11\"),\n            String::from(\"13\"),\n            String::from(\"15\"),\n            String::from(\"17\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"21\"),\n            String::from(\"23\"),\n            String::from(\"25\"),\n            String::from(\"27\"),\n        ];\n\n        for val in vals {\n            tx2.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for rec in rx {\n        println!(\"Got: {}\", rec);\n    }\n}</code></pre>\n<p>可以看到在Rust下实现生产者消费者是不难的，但是生产者可以clone多个，不过消费者却只能有一个，究其原因是因为Rust下没有GC也就是垃圾回收功能，而想保证安全Rust就必须要对于变更使用权限进行严格管理。在Rust下使用move关键字进行变更的所有权转移，但是按照Rust对于变更生产周期的管理规定，线程间权限转移的所有权接收者在同一时间只能有一个，这也是Rust官方只提供MPSC的原因，</p>\n<pre><code>use std::thread;\n\nfn main() {\n    let s = \"hello\";\n   \n    let handle = thread::spawn(move || {\n        println!(\"{}\", s);\n    });\n\n    handle.join().unwrap();\n}</code></pre>\n<p>当然Rust下有一个API比较贴心就是join，他可以所有子线程都执行结束再退出主线程，这比Go中要手工阻塞还是要有一定的提高。而如果你想用多生产者、多消费者的功能，就要入手crossbeam模块了，这个模块掌握起来难度也真的不低。</p>\n<h3>总结</h3>\n<p>通过上面的比较我们可以用一张表格来说明几种主流语言的情况对比：</p>\n<table border=\"1\" cellspacing=\"0\" style=\"width:327.02pt;\"><tbody><tr><td style=\"border-color:#000000;text-align:center;vertical-align:middle;width:54pt;\"><span style=\"color:#000000;\">语言</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;width:54pt;\"><span style=\"color:#000000;\">安全性</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;width:93pt;\"><span style=\"color:#000000;\">运行速度</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;width:72pt;\"><span style=\"color:#000000;\">进程启动速度</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;width:54pt;\"><span style=\"color:#000000;\">学习难度</span></td></tr><tr><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">C</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">低</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">极快</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">极快</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">困难</span></td></tr><tr><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">Java</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">高</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">一般</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">一般</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">一般</span></td></tr><tr><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">Go</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">高</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">较快</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">较快</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">一般</span></td></tr><tr><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">Rust</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">高</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">极快(基本比肩C）</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">极快(基本比肩C）</span></td><td style=\"border-color:#000000;text-align:center;vertical-align:middle;\"><span style=\"color:#000000;\">极困难</span></td></tr></tbody></table>\n<p>可以看到Rust以其高安全性、基本比肩C的运行及启动速度必将在Serverless的时代独占鳌头，Go基本也能紧随其后，而C语言程序中难以避免的野指针，Java相对较低的运行及启动速度，可能都不太适用于函数式运算的场景，Java在企业级开发的时代打败各种C#之类的对手，但是在云时代好像还真没有之前统治力那么强了，真可谓是打败你的往往不是你的对手，而是其它空间的降维打击。</p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2021-06-13 11:26:39", "summary": "笔者在上周参加阿里云开发者大会时，特别注意到一个现象就是这个概念被反复提及，其受关注程度提升明显，笔者仔细看了一下，的核心理念就是函数式计算，开发者不需要再关注具体的模块，云上部署的粒度变成了程序函数"}