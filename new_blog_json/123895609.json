{"blogid": "123895609", "writerAge": "码龄7年", "writerBlogNum": "81", "writerCollect": "65", "writerComment": "42", "writerFan": "88", "writerGrade": "5级", "writerIntegral": "1835", "writerName": "channel_海峡", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123895609.jpg", "writerRankTotal": "48115", "writerRankWeekly": "43579", "writerThumb": "27", "writerVisitNum": "117547", "blog_read_count": "1097", "blog_time": "已于 2022-04-10 05:12:39 修改", "blog_title": "php架构师技术栈", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>数据库</h2>\n<h3><a id=\"mysql_1\"></a>mysql</h3>\n<h4><a id=\"_2\"></a>主从</h4>\n<h5><a id=\"_3\"></a>为何做主从</h5>\n<ul><li>当sql语句需要缩表，导致不能读，那么业务就受阻</li><li>当做了热备份，就算主库挂了，那么依靠从库也能快速的替换主库</li><li>i/o访问频率增加，单库压力大</li></ul>\n<h5><a id=\"_8\"></a>主从复制流程</h5>\n<ol><li>主库的更新事件(update,insert,delete)写入binlog</li><li>主库创建binglog dump thread，把binlog发送到从库</li><li>从库启动并发起连接到主库</li><li>从库启动，创建i/o线程，读取主库binlog内容写入relay_log</li><li>从库启动，创建一个sql线程，从relay_log读取内容，从exec_master_pos位置开始执行读取到的更新事件，并将更新内容写入到从库的表</li></ol>\n<h4><a id=\"pxc_15\"></a>pxc</h4>\n<h5><a id=\"pxc_16\"></a>什么是pxc</h5>\n<p>一套开源的mysql高可用集群解决方案</p>\n<h5><a id=\"_18\"></a>原理</h5>\n<ul><li>传统的主从就是我上面描述的那种，即主写从读，如果主节点因为网络问题没有同步到从节点，那么就出现了数据的不一致，底层是单向同步</li><li>pvx，强一致性，无同步延迟</li><li>通过事务解决强一致性</li></ul>\n<h4><a id=\"_22\"></a>性能调优</h4>\n<ol><li>选择合适的存储引擎<br/> 我们都知道myisam比innodb快，但是实际的数据操作是很复杂的，所以相应的业务支持也要大，比如事务，锁，innodb就优于myisam。所以我们可以针对相应的表的数据结构或者业务选择合适的引擎，单纯就存储数据业务简单就用myisam。myisam仅仅缓存索引，innodb缓存数据和索引</li><li>数据尽量从内存读取<br/> innodb_buffer_pool_size</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> <span class=\"token keyword\">global</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_buffer_pool_pages_%'</span>\nInnodb_buffer_pool_pages_data    <span class=\"token comment\">//存池中包含数据的页的数目，包括脏页。单位是page</span>\nInnodb_buffer_pool_pages_dirty   <span class=\"token comment\">//缓存池中脏页的数目。单位是page。</span>\nInnodb_buffer_pool_pages_flushed   <span class=\"token comment\">//缓存池中刷新页请求的数目。单位是page。</span>\nInnodb_buffer_pool_pages_free     <span class=\"token comment\">//剩余的页数目。单位是page。[当这个为0，说明buffer pool已经被用光，需要增大innodb_buffer_pool_size</span>\nInnodb_buffer_pool_pages_misc    <span class=\"token comment\">//缓存池中当前已经被用作管理用途或hash index而不能用作为普通数据页的数目。单位是page。</span>\nInnodb_buffer_pool_pages_total   <span class=\"token comment\">//页总数目。单位是page。</span>\n</code></pre>\n<ol start=\"3\"><li>数据预热<br/> 数据预热能够提高读取速度。<br/> 默认情况，仅仅有某条数据被读取一次，才会缓存在 innodb_buffer_pool。所以，数据库刚刚启动，须要进行数据预热，将磁盘上的全部数据缓存到内存中。</li><li>不要让数据存到 SWAP 中</li><li>提高磁盘读写速度</li><li>充分使用索引</li><li>直接数据放内存磁盘</li></ol>\n<h4><a id=\"_46\"></a>连接池</h4>\n<h5><a id=\"_47\"></a>为何使用连接池</h5>\n<ol><li>通常普通的jdbc请求Mysql，请求完成之后mysql链接就会关闭，这样mysql就是单词链接，每次使用都要重复创建关闭，当多个用户频繁此操作，mysql不停的创建销毁，资源的开销大，压力也会增大。连接池就能解决这一问题</li><li>资源重用</li><li>更快的系统反应速度</li><li>新的资源分配手段</li><li>统一管理，避免数据库连接泄露</li></ol>\n<h5><a id=\"_53\"></a>原理</h5>\n<p>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。当用户第一次获取连接时，会先请求一定数量（初始链接数量）链接池中，并且会记录每个连接的初始（未使用）时间，然后再将链接池中的连接给有需要的用户。当缓冲池中初始连接用完了,链接池会判断所创建的连接数量是否大于最大链接数如果不大于则可以继续创建连接给请求的用户使用（创建的新连接的个数可自己控制，链接池中有相应的增长参数）。如果已经到到最大链接数则当前用户需要等待直到有用户使用完之后关闭连接，这个用户才可以重复使用。当我们开始使用链接池的时候链接池内部就会进行计时（超时时间），每隔空闲链接的存活时间就会对链接池内部的连接进行一次清理。把所有（当前时间 - 链接最后使用的时间 ）&gt; 空闲链接的存活时间的连接释放掉。</p>\n<h4><a id=\"_55\"></a>索引</h4>\n<h5><a id=\"_56\"></a>索引是什么</h5>\n<ol><li>数据库可以理解为一本书，索引可以理解为书的目录章节</li></ol>\n<h5><a id=\"_58\"></a>索引优点</h5>\n<ol><li>加大数据检索速度</li><li>避免排序和创建临时表</li><li>将随机io变为顺序Io</li><li>innodb支持行级锁，可以让查询锁更少的元组，提高了表访问并发性</li></ol>\n<h5><a id=\"_63\"></a>缺点</h5>\n<ol><li>创建维护耗费时间，数据越多，时间越长</li><li>占用物理空间</li><li>增删改，索引动态维护，降低了维护速度</li><li>数据量小，索引反而降速</li></ol>\n<h5><a id=\"_68\"></a>应该创建索引的咧</h5>\n<ol><li>经常需要搜索的列</li><li>作为主键的列【通常主键本来就是索引】</li><li>join的外键</li><li>（&lt; , &lt;= , = ,&gt; , &gt;= , between,in）进行搜索的列上，因为索引已经排序，指定的范围是连续的</li><li>经常需要排序的列</li><li>where 条件列</li></ol>\n<h5><a id=\"_75\"></a>不该创建索引的列</h5>\n<ol><li>很少使用的列</li><li>数据少，数值重复的列</li><li>text imafe bit数据类型</li><li>当前列修改性能要求远高于检索时</li></ol>\n<h4><a id=\"_80\"></a>监控</h4>\n<h4><a id=\"sql_82\"></a>sql调优</h4>\n<ol start=\"8\"><li>慢查询日志找到sql \n  <ol><li>slow_query_log 是否启动查询慢日志，默认不启动</li><li>slow_query_log_file 指定日志存放路径</li><li>long_query_time 指定阈值，即查询时间大于多少即为慢日志</li><li>log_queries_not_using_indexes 是否记录未使用索引的sql</li></ol> </li><li>实时获取性能问题sql<br/> show full processlist</li><li>使用explain分析</li><li></li></ol>\n<table><thead><tr><th>id</th><th>type</th><th>key</th><th>extra</th></tr></thead><tbody><tr><td>表示mysql执行顺序。id越大越先执行</td><td>表示找到数据行的方式</td><td>实际使用的索引</td><td>额外信息</td></tr></tbody></table>\n<h4><a id=\"_95\"></a>数据备份</h4>\n<h5><a id=\"_96\"></a>目的</h5>\n<ol><li>备灾</li><li>需求改变</li><li>测试</li></ol>\n<h4><a id=\"_100\"></a>备份类型</h4>\n<ol><li>冷备 关闭mysql</li><li>温备 服务在线，仅支持读，不允许写</li><li>热备 不影响业务</li></ol>\n<h3><a id=\"mongoDB_104\"></a>mongoDB</h3>\n<h4><a id=\"_105\"></a>是什么</h4>\n<p>基于分布式文件存储的数据库，c++编写，介于关系和非关系型数据库之间的产品<br/> 默认端口 27017</p>\n<h4><a id=\"_108\"></a>特点</h4>\n<ol><li>记录为文档类型，类似于json.</li><li>多个文档组成集合，多个集合组成数据库</li></ol>\n<h3><a id=\"LDAP_111\"></a>LDAP</h3>\n<h4><a id=\"ldap_112\"></a>什么是ldap</h4>\n<p>目录数据库。</p>\n<h4><a id=\"_114\"></a>优势</h4>\n<p>读取速度非常快，写性能差</p>\n<h1><a id=\"php_116\"></a>php</h1>\n<h2><a id=\"php7_117\"></a>php7新特性</h2>\n<ol><li>速度优于Php5</li><li>低内存消耗</li><li>标准类型声明，可以强制执行参数和返回类型</li><li>异常处理优化</li><li>删除了不推荐使用的sapi和扩展</li><li>返回类型和数量类型声明</li><li>支持匿名添加</li></ol>\n<h2><a id=\"php8_125\"></a>php8新特性</h2>\n<ol><li>命名参数传参的时候可以跳过可选参数</li><li>构造方法括号中初始化对象属性，并指定属性的权限</li><li>可以同时指定形参的多种类型</li><li>match 表达式，有些情况下能替换switch</li><li>内部函数一致类型错误，以前只是警告</li><li>注解</li></ol>\n<h3><a id=\"_132\"></a>控制反转</h3>\n<h4><a id=\"_133\"></a>什么是控制反转/依赖注入</h4>\n<ul><li>是一种设计原则，用来减轻代码的耦合度</li><li>常见方式------依赖注入</li><li>简单说就是，A类把自己的控制权交给另外一个B类。之间的依赖由这个B类去解决<br/> <strong>控制反准IOC 不需要自己内容修改，外部传递 从依赖内部改为依赖外部</strong><br/> <strong>依赖注入 DI 不是由自己内部new对象或者实例，而是通过外部构造函数或者方法传入调用其他类</strong></li></ul>\n<h3><a id=\"_139\"></a>反射</h3>\n<p>类的实例化由make来创建</p>\n<h3><a id=\"_141\"></a>容器</h3>\n<p>把各种类创建放在一个闭包中，闭包的好处是使用时再创建（懒加载）</p>\n<h3><a id=\"_143\"></a>服务提供者</h3>\n<ul><li>服务提供者是食物，容器是篮子，服务提供者注册到容器。相当于把食物放到篮子里</li><li>使用场景：可以借助一个容器，提前把 log,user 都绑定到 Ioc 容器中。User 的创建交给这个容器去做。比如下面这样的，你再任何地方使用 login。都不需要关心是用什么记录日志了，哪怕后期需要修改只需要在 ioc 容器修改绑定其他记录方式日志就行了。</li></ul>\n<h3><a id=\"_facade_146\"></a>门面 facade</h3>\n<ul><li>使用 Facades 其实最主要的就是它提供了(1)简单，易记的语法，从而无需手动注入或配置长长的类名。此外，由于他们对PHP静态方法的独特调用，使得(2)测试起来非常容易。</li><li>Facade核心实现原理就是在 UserFacade 提前注入 Ioc 容器。<br/> 使用场景：需要<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         i\n        \n        \n         o\n        \n        \n         c\n        \n        \n         −\n        \n        \n         &gt;\n        \n        \n         m\n        \n        \n         a\n        \n        \n         k\n        \n        \n         e\n        \n        \n         \n          (\n         \n         \n          ′\n         \n        \n        \n         u\n        \n        \n         s\n        \n        \n         e\n        \n        \n         \n          r\n         \n         \n          ′\n         \n        \n        \n         )\n        \n        \n         才\n        \n        \n         能\n        \n        \n         拿\n        \n        \n         到\n        \n        \n         U\n        \n        \n         s\n        \n        \n         e\n        \n        \n         r\n        \n        \n         的\n        \n        \n         实\n        \n        \n         例\n        \n        \n         ，\n        \n        \n         再\n        \n        \n         去\n        \n        \n         使\n        \n        \n         用\n        \n       \n       \n        ioc-&gt;make('user')才能拿到User的实例，再去使用\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.74285em; vertical-align: -0.08333em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">c</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right: 0.277778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right: 0.277778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.00189em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mord mathdefault\">e</span><span class=\"mopen\"><span class=\"mopen\">(</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.751892em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.751892em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">才</span><span class=\"mord cjk_fallback\">能</span><span class=\"mord cjk_fallback\">拿</span><span class=\"mord cjk_fallback\">到</span><span class=\"mord mathdefault\" style=\"margin-right: 0.10903em;\">U</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">r</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">实</span><span class=\"mord cjk_fallback\">例</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">再</span><span class=\"mord cjk_fallback\">去</span><span class=\"mord cjk_fallback\">使</span><span class=\"mord cjk_fallback\">用</span></span></span></span></span>user-&gt;login();那能不能更方便点，用这种方式：UserFacade::login();<br/> 步骤：<br/> （1）定义一个服务提供者的外观类，在该类定义一个类的变量，跟 ioc 容器绑定的 key 一样；<br/> （2）通过静态魔术方法__callStatic 可以得到当前想要调用的 login；<br/> （3）使用 static::$ioc-&gt;make(‘user’);</li></ul>\n<h2><a id=\"phpfpm_154\"></a>php-fpm调优</h2>\n<h2><a id=\"swoole_155\"></a>swoole</h2>\n<h2><a id=\"composer_156\"></a>composer</h2>\n<h2><a id=\"_157\"></a>编译安装</h2>\n<h2><a id=\"PECL_158\"></a>PECL</h2>\n<h2><a id=\"_159\"></a>代码加密</h2>\n<h2><a id=\"workman_160\"></a>workman</h2>\n<h1><a id=\"redis_161\"></a>redis</h1>\n<h2><a id=\"_162\"></a>主从</h2>\n<h2><a id=\"cluster_163\"></a>cluster</h2>\n<h2><a id=\"_164\"></a>分布式锁</h2>\n<h1><a id=\"_165\"></a>中间件</h1>\n<h2><a id=\"kafka_166\"></a>kafka</h2>\n<h2><a id=\"RabbitMq_167\"></a>RabbitMq</h2>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "PHP", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 1, "time": "2022-04-10 05:12:39", "summary": "数据库主从为何做主从当语句需要缩表，导致不能读，那么业务就受阻当做了热备份，就算主库挂了，那么依靠从库也能快速的替换主库访问频率增加，单库压力大主从复制流程主库的更新事件写入主库创建，把发送到从库从库"}