{"blogid": "121920394", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "11148", "writerComment": "4682", "writerFan": "37313", "writerGrade": "7级", "writerIntegral": "14242", "writerName": "Albert Edison", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121920394.jpg", "writerRankTotal": "657", "writerRankWeekly": "248", "writerThumb": "6824", "writerVisitNum": "410344", "blog_read_count": "3530", "blog_time": "于 2021-12-14 21:30:00 发布", "blog_title": "「数据结构」八大排序之插入排序，居然这么简单？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>⭐ <strong>前言</strong></p>\n<p>本章将介绍常见八大排序中的 <strong>插入排序</strong>；</p>\n<p>可能你会好奇，为什么只介绍插入排序呢？</p>\n<p>因为我学完了所有排序以后，也看了市面上很多写排序的文章，都是一篇文章全部把所有排序都写完了的！</p>\n<p>我觉得一篇文章把所有排序全部写完的话，会存在2个问题：</p>\n<blockquote>\n<p>1、一篇文章写完所有排序，会导致某个知识点不全面，换个话来说，就是越往后写，容易产生疲劳；<br/>  <br/> 2、读者的直观感受可能不是那么好，毕竟更多的是要让大家能看懂！其次自己也能看懂！</p>\n</blockquote>\n<p>所以，先分章节，慢慢来，把多个知识点深度剖析！</p>\n<p><em>Let’s get it！</em></p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9f2b8dcab7384e3d8cf6f54fceb2e875.png\"/></p>\n<hr/>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#1__26\">1. 排序是什么</a></li><li><ul><li><a href=\"#__28\">🍑 排序的概念</a></li><li><a href=\"#__44\">🍑 排序的运用</a></li></ul>\n</li><li><a href=\"#2__60\">2. 插入排序分类</a></li><li><a href=\"#3__66\">3. 直接插入排序</a></li><li><ul><li><a href=\"#___68\">🍑 基本思想</a></li><li><a href=\"#___94\">🍑 动图演示</a></li><li><a href=\"#__105\">📃 代码实现</a></li><li><a href=\"#___138\">🍑 概括总结</a></li></ul>\n</li><li><a href=\"#4__168\">4. 希尔排序</a></li><li><ul><li><a href=\"#___170\">🍑 基本思想</a></li><li><a href=\"#___190\">🍑 动图演示</a></li><li><a href=\"#___214\">🍑 举例说明</a></li><li><a href=\"#__234\">📃 代码实现</a></li><li><a href=\"#___271\">🍑 概括总结</a></li></ul>\n</li><li><a href=\"#5__310\">5. 总结</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<h2><a id=\"1__26\"></a>1. 排序是什么</h2>\n<h3><a id=\"__28\"></a>🍑 排序的概念</h3>\n<blockquote>\n<p><strong>排序：</strong> 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p>\n<p> </p>\n<p><strong>稳定性：</strong> 假定在待排序的记录序列中，存在多个具有<strong>相同</strong>的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，<code>r[i]=r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>\n<p> </p>\n<p><strong>内部排序：</strong> 数据元素全部放在内存中的排序。</p>\n<p> </p>\n<p><strong>外部排序：</strong> 数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p>\n</blockquote>\n<h3><a id=\"__44\"></a>🍑 排序的运用</h3>\n<p>这里给大家举几个生活中，常见排序的栗子👇：</p>\n<blockquote>\n<p>购物平台里面<strong>按某个商品的维度排序</strong></p>\n<p><img alt=\"image-20211212213019712\" src=\"..\\..\\static\\image\\0e2f01913374002c1ed24f8ff2b27b7a.png\"/></p>\n<p><strong>全国高校排名</strong></p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\6bc5606fc2ec8851a8d708990bdc0d00.png\"/></p>\n</blockquote>\n<p>其实在我们平时日常生活中还有很多都会用到排序的地方；</p>\n<p>由此可见，排序与我们的生活息息相关😄</p>\n<h2><a id=\"2__60\"></a>2. 插入排序分类</h2>\n<p>插入排序可以分为：<strong>直接插入排序</strong> 和 <strong>希尔排序</strong></p>\n<p><img alt=\"image-20211212213649416\" src=\"..\\..\\static\\image\\42593aa8a38ad04d136c043965f6f585.png\"/></p>\n<h2><a id=\"3__66\"></a>3. 直接插入排序</h2>\n<h3><a id=\"___68\"></a>🍑 基本思想</h3>\n<p>🎃直接插入排序是一种简单的插入排序法；</p>\n<blockquote>\n<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。</p>\n<p> </p>\n<p>实际中我们玩扑克牌时，就用了插入排序的思想，不信你看👇</p>\n<p><img alt=\"image-20211212213858969\" src=\"..\\..\\static\\image\\a479754a991d9a0f379898f15b7f4b5d.png\"/></p>\n</blockquote>\n<p>❗❓那么怎么去理解它呢？很简单</p>\n<blockquote>\n<p><strong>直接插入排序是指</strong>：在待排序的元素中，假设前面<code>n-1</code>(其中<code>n&gt;=2</code>)个数<strong>已经是排好顺序的</strong>，现将第<strong>n</strong>个数<strong>插到前面</strong>已经排好的序列中，然后找到合适自己的位置，使得<strong>插入第n个数的这个序列也是排好顺序的</strong>。</p>\n<p> </p>\n<p>按照此法对所有元素进行插入，<strong>直到整个序列排为有序的过程</strong>，称为插入排序 。</p>\n<p> </p>\n<p>但我们并不能确定待排元素中<strong>究竟哪一部分是有序的</strong>，所以我们一开始<strong>只能认为第一个元素是有序的</strong>，<strong>依次将其后面的元素插入到这个有序序列中来</strong>，<strong>直到整个序列有序为止</strong>。</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\7a171f6bb9cf35e0ec9071151f2bc1b8.png\"/></p>\n</blockquote>\n<h3><a id=\"___94\"></a>🍑 动图演示</h3>\n<p>🍅我们先来看个动态图演示：</p>\n<p><img alt=\"img\" src=\"https://img-blog.csdnimg.cn/img_convert/df939519fc99ca7a2c4b23e0db1b8d46.gif\"/></p>\n<blockquote>\n<p>1、从图中观察的现象是如果后一个数不比前一个数小，那就不需要插入，不插入的动作就是<strong>break</strong>出循环</p>\n<p> </p>\n<p>2、如果前面的数都比<strong>pos</strong>(拿出的数)值大，那么就将前<strong>n</strong>个数都往后挪动，直到比<strong>pos</strong>值小或者相等就停止，可以用循环控制，这里防止越界需要再加判断</p>\n</blockquote>\n<h3><a id=\"__105\"></a>📃 代码实现</h3>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">InsertSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">//注意控制好终止条件，这里的end的位置是在倒数第二个位置，所以要-1</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span><span class=\"token comment\">//记录有序序列的最后一个元素的下标</span>\n\n\t\t<span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>end <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//待插入的元素</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">&gt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//还需继续比较</span>\n\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\ta<span class=\"token punctuation\">[</span>end <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tend<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token keyword\">else</span><span class=\"token comment\">//找到应插入的位置</span>\n\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\ta<span class=\"token punctuation\">[</span>end <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//代码执行到此位置有两种情况:</span>\n\t\t<span class=\"token comment\">//1.待插入元素找到应插入位置（break跳出循环到此）。</span>\n\t\t<span class=\"token comment\">//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）。</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"___138\"></a>🍑 概括总结</h3>\n<p><strong>复杂度分析：</strong></p>\n<blockquote>\n<p>元素集合越接近有序，直接插入排序算法的时间效率越高，反之越低</p>\n<p> </p>\n<p>时间复杂度：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         \n          n\n         \n         \n          2\n         \n        \n        \n         )\n        \n       \n       \n        O(n^2)\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.06411em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.814108em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p> </p>\n<p>空间复杂度：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         1\n        \n        \n         )\n        \n       \n       \n        O(1)\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p> </p>\n<p>稳定性的分析：直接插入排序在遇到相同的数时，可以就放在这个数的后面，就可以保持稳定性了，所以说这个排序是稳定的。</p>\n</blockquote>\n<p><strong>特性总结：</strong></p>\n<blockquote>\n<p>插入排序是一种最简单直观的排序算法；</p>\n<p> </p>\n<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p> </p>\n<p>也就是说：把待排序的记录<strong>按其关键码值的大小</strong>逐个<strong>插入到一个已经排好序的有序序列中</strong>，直到所有的记录插入完为止，得到一个新的有序序列 。</p>\n</blockquote>\n<h2><a id=\"4__168\"></a>4. 希尔排序</h2>\n<h3><a id=\"___170\"></a>🍑 基本思想</h3>\n<blockquote>\n<p>希尔排序，也称<strong>缩小增量法</strong>，是插入排序的一种更高效的改进版本；</p>\n<p> </p>\n<p>但希尔排序是<strong>非稳定排序算法</strong>。</p>\n</blockquote>\n<p>❗❓那么它的思路是什么呢？</p>\n<blockquote>\n<p>每次从一个有序序列开始，将待排元素与有序序列中的元素从后往前逐个比较，</p>\n<p> </p>\n<p>若有序序列中的元素大于待排元素，则将较大的元素往后覆盖；</p>\n<p> </p>\n<p>否则，将待排元素插入其前面，并结束此轮比较。</p>\n</blockquote>\n<h3><a id=\"___190\"></a>🍑 动图演示</h3>\n<p><img alt=\"img\" src=\"https://img-blog.csdnimg.cn/img_convert/c3163ddd0c32c27669636684b98ae167.gif\"/></p>\n<p>🤔<strong>实现原理</strong></p>\n<blockquote>\n<p>1、先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…</p>\n<p> </p>\n<p>2、当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</p>\n<p> </p>\n<p><strong>为什么要让gap由大到小呢？</strong></p>\n<p> </p>\n<p>答：gap越大，数据挪动得越快；gap越小，数据挪动得越慢。前期让gap较大，可以让数据更快得移动到自己对应的位置附近，减少挪动次数。</p>\n<p> </p>\n<p>注：一般情况下，取序列的一半作为增量，然后依次减半，直到增量为1（也可自己设置）。</p>\n</blockquote>\n<h3><a id=\"___214\"></a>🍑 举例说明</h3>\n<blockquote>\n<p>现在我们用<strong>希尔排序</strong>对该序列进行排序。</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\7b7cee9c30bab016292a4522f01e7e80.png\"/></p>\n<p>我们用<strong>序列长度的一半</strong>作为第一次排序时<strong>gap</strong>的值，此时<strong>相隔距离为5</strong>的元素被分为一组（共分了5组，每组有2个元素），然后分别对每一组进行直接插入排序。</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\fda66f2b6bbe8fe85110f94b37d97d24.png\"/></p>\n<p><strong>gap</strong>的值折半，此时<strong>相隔距离为2的元素被分为一组</strong>（共分了2组，每组有5个元素），然后再分别对每一组进行直接插入排序。</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\7c675e2d268ab7e7b84a1f732553a9f1.png\"/></p>\n<p><strong>gap</strong>的值再次减半，此时gap减为1，即整个序列被分为一组，进行一次直接插入排序。</p>\n<p><img alt=\"img\" src=\"..\\..\\static\\image\\c903fe4ccd6aecbea28b46df97477ab7.png\"/></p>\n</blockquote>\n<p>上述示例中，前两趟就是希尔排序的预排序，最后一趟就是希尔排序的直接插入排序。</p>\n<h3><a id=\"__234\"></a>📃 代码实现</h3>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">//希尔排序</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">ShellSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>gap <span class=\"token operator\">&gt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//别加等号，不然就是死循环</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//控制gap值的变化，让数组接近有序，gap == 1就可以直接插入排序</span>\n\t\tgap <span class=\"token operator\">=</span> gap <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//gap折半</span>\n\t\t<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//进行一趟排序</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t<span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>end <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">&gt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token comment\">//当前的end的值比tmp大就要往end+gap位置挪</span>\n\t\t\t\t<span class=\"token comment\">//所以要提前保存end+gap的值</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\t\ta<span class=\"token punctuation\">[</span>end <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\tend <span class=\"token operator\">-=</span> gap<span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t<span class=\"token keyword\">else</span>\n\t\t\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\ta<span class=\"token punctuation\">[</span>end <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"___271\"></a>🍑 概括总结</h3>\n<p><strong>复杂度分析：</strong></p>\n<blockquote>\n<p>时间复杂度：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         N\n        \n        \n         l\n        \n        \n         o\n        \n        \n         g\n        \n        \n         N\n        \n        \n         )\n        \n       \n       \n        O(NlogN)\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right: 0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right: 0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span><br/>  <br/> 空间复杂度：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         1\n        \n        \n         )\n        \n       \n       \n        O(1)\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span><br/>  <br/> 平均时间复杂度：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         \n          N\n         \n         \n          1.3\n         \n        \n        \n         )\n        \n       \n       \n        O(N^{1.3})\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.06411em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right: 0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.814108em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">.</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span><br/>  <br/> 稳定性的分析：可以这样想，相同的数被分到了不同的组，就不能保证原有的顺序了，所以说这个排序是<strong>不稳定的</strong>。</p>\n</blockquote>\n<p><strong>特性总结：</strong></p>\n<blockquote>\n<p>希尔排序是对直接插入排序的优化。</p>\n<p> </p>\n<p>当<code>gap &gt; 1</code>时都是预排序，目的是让数组更接近于有序。当<code>gap == 1</code>时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</p>\n<p> </p>\n<p>希尔排序的时间复杂度不好计算，因为<strong>gap</strong>的取值方法很多，导致很难去计算，因此在好些树中给出的 希尔排序的时间复杂度都不固定：</p>\n<p> </p>\n<p>在 <strong>《数据结构(C语言版)》</strong> 中，是这样说的：</p>\n<p><img alt=\"image-20211214101932338\" src=\"..\\..\\static\\image\\914d916255b7700fac90999d7b8ea32f.png\"/></p>\n<p>在 <strong>《数据结构-用面相对象方法与C++描述》</strong> 中，是这样说的：</p>\n<p><img alt=\"image-20211214102013752\" src=\"..\\..\\static\\image\\8b7fc3045d60c5ebb1599fd1b51f05db.png\"/></p>\n<p>因为我们的<strong>gap</strong>是按照<strong>Knuth</strong>提出的方式取值的，而且Knuth进行了大量的试验统计，我们暂时就按照：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         \n          n\n         \n         \n          1.25\n         \n        \n        \n         )\n        \n       \n       \n        O(n^{1.25})\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.06411em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.814108em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">.</span><span class=\"mord mtight\">2</span><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> 到 <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         O\n        \n        \n         (\n        \n        \n         1.6\n        \n        \n         ∗\n        \n        \n         \n          n\n         \n         \n          1.25\n         \n        \n        \n         )\n        \n       \n       \n        O(1.6*n^{1.25})\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right: 0.222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.06411em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.814108em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">.</span><span class=\"mord mtight\">2</span><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> 来计算</p>\n<p> </p>\n<p>稳定性：不稳定</p>\n</blockquote>\n<h2><a id=\"5__310\"></a>5. 总结</h2>\n<p>以上就是关于 <strong>插入排序</strong> 的全部内容，下一篇就进入到我们的 <strong>选择排序</strong></p>\n<blockquote>\n<p>🌟<em>你知道的越多，你不知道越多，我们下期见！</em></p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-12-14 21:30:00", "summary": "前言本章将介绍常见八大排序中的插入排序；可能你会好奇，为什么只介绍插入排序呢？因为我学完了所有排序以后，也看了市面上很多写排序的文章，都是一篇文章全部把所有排序都写完了的！我觉得一篇文章把所有排序全部"}