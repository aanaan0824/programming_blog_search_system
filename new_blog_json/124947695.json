{"blogid": "124947695", "writerAge": "码龄2年", "writerBlogNum": "5", "writerCollect": "16", "writerComment": "10", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "75", "writerName": "春雨惊蛰", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124947695.jpg", "writerRankTotal": "136264", "writerRankWeekly": "1058809", "writerThumb": "14", "writerVisitNum": "6839", "blog_read_count": "3616", "blog_time": "已于 2022-05-24 17:47:01 修改", "blog_title": "Spring Boot 事务详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>【自己学习事务做的笔记，方便记忆和复习】</p>\n<h2><span style=\"color:#0d0016;\"><strong>1、事务是为了解决数据安全问题而存在的。</strong></span></h2>\n<p>最经典的例子就是银行转账问题，A账户给B账户转账100元，A账户扣除100元后由于不可抗力因素导致程序中断，B账户没有收到那100元，A账户那100元凭空消失，肯定是不行的。A扣款和B收款操作要么同时成功，要么同时失败，这个时候就需要引入事务操作。</p>\n<h2><span style=\"color:#333333;\">2、事务的四个特性：</span></h2>\n<ul><li><span style=\"color:#494949;\"><strong>原子性：</strong>一个事务是一个不可分割的工作单位。</span></li><li><span style=\"color:#494949;\"><strong>一致性：</strong>事务必须是使数据库从一个一致性状态变到另一个一致性状态，一致性与原子性是密切相关的。</span></li><li><span style=\"color:#494949;\"><strong>隔离性：</strong>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</span></li><li><span style=\"color:#494949;\"><strong>持久性：</strong>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</span></li></ul>\n<h2><span style=\"color:#333333;\"><strong>3、事务管理方式</strong></span></h2>\n<p>spring支持<strong>编程式事务管理</strong>和<strong>声明式事务管理</strong>两种方式。</p>\n<p>编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p>\n<p>声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于<strong>@Transactional注解</strong>的方式)，便可以将事务规则应用到业务逻辑中。</p>\n<blockquote>\n<p style=\"text-align:justify;\"><span style=\"color:#494949;\">@Transactional注解：</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#494949;\">它是声明式事务管理编程中使用的注解，放在接口实现类或接口实现方法上，并且只对public方法才起作用。只读的接口不需要事务管理，防止影响系统性能。</span></p>\n<p style=\"text-align:justify;\"><span style=\"color:#494949;\">@Transactional 实质是使用了 JDBC 的事务来进行事务控制的，实现原理：</span></p>\n<ol><li> <p>事务开始时，通过AOP机制，生成一个代理connection对象，并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，执行所有数据库命令。<span style=\"color:#333333;\"><span style=\"background-color:#cccccc;\">[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]</span></span>（物理连接 connection 逻辑上新建一个会话session；DataSource 与 TransactionManager 配置相同的数据源）</p> </li><li> <p>事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，然后关闭该代理 connection 对象。<span style=\"background-color:#cccccc;\">（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）</span></p> </li></ol>\n</blockquote>\n<h2>4、事务的隔离级别</h2>\n<p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。隔离级别越高，数据库的并发性能就越差。</p>\n<h3><strong>第一种隔离级别：Read uncommitted(读未提交)</strong></h3>\n<p>在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。即在该级别下，事务的修改即便没有提交，对其他事务也都是可见的，可能出现脏读、不可重复读、幻读。</p>\n<h3><strong>第二种隔离级别：Read committed(读提交)</strong></h3>\n<p>该隔离级别满足了隔离的简单定义，一个事务只能看见已经提交事务所做的改变。这是Oracle数据库默认的事务隔离级别。避免了脏读，可能出现不可重复读、幻读。</p>\n<h3><strong>第三种隔离级别：Repeatable read(可重复读取)</strong></h3>\n<p>可以确保同一个事务在多次读取同样的数据时，返回同样的结果。这是MySQL数据库默认的事务隔离级别。这样避免了不可重复读和脏读，但是有时可能会出现幻读。</p>\n<h3><strong>第四种隔离级别：Serializable(可序化)</strong></h3>\n<p>它通过强制事务排序，使事务一个一个的进行，事务之间不可能再存在相互冲突，从而解决幻读问题。</p>\n<blockquote>\n<p><span style=\"color:#494949;\"><strong>脏读、不可重复读、幻读：</strong></span></p>\n<p><span style=\"color:#494949;\"><strong>1、脏读</strong></span></p>\n<p><span style=\"color:#494949;\">脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。这时候如果事务A回滚，那么B事务读到的数据是不被承认的。</span></p>\n<p><span style=\"color:#494949;\"><strong>2、不可重复读（重点在修改，体现在值不同）</strong></span></p>\n<p><span style=\"color:#494949;\">指在A事务内，多次读同一数据。在A事务还没有结束时，B事务也访问该同一数据。那么，在A事务中的两次读数据之间，由于B事务的修改，那么A事务两次读到的的数据可能是不一样的。这样就发生了在A事务内两次读到的数据是不一样的。</span></p>\n<p><span style=\"color:#494949;\"><strong>3、幻读（重点在增加或删除，体现在记录数不同）</strong></span></p>\n<p><span style=\"color:#494949;\">是指当事务不是独立执行时发生的一种现象，例如A事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作A事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</span></p>\n<p><span style=\"color:#494949;\">具体可看↓<a class=\"has-card\" href=\"https://blog.csdn.net/qq_41776884/article/details/81608777\" title=\"数据库事务隔离级别（脏读、幻读、不可重复读）_qq_41776884的博客-CSDN博客_脏读幻读不可重复读\"><span class=\"link-card-box\"><span class=\"link-title\">数据库事务隔离级别（脏读、幻读、不可重复读）_qq_41776884的博客-CSDN博客_脏读幻读不可重复读</span><span class=\"link-desc\">一、脏读、幻读和不可重复读一、脏读、不可重复读、幻读1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务...</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/qq_41776884/article/details/81608777</span></span></a></span></p>\n</blockquote>\n<h2><span style=\"color:#be191c;\"><strong>5、事务的传播行为</strong></span></h2>\n<p>事务的传播行为是针对嵌套事务而言的。具体可见↓<a class=\"has-card\" href=\"https://blog.csdn.net/jy02268879/article/details/84322459\" title=\"【十六】Spring Boot之事务（事务传播机制、嵌套事务、事务隔离机制详解）_jy02268879的博客-CSDN博客_springboot 事务嵌套\"><span class=\"link-card-box\"><span class=\"link-title\">【十六】Spring Boot之事务（事务传播机制、嵌套事务、事务隔离机制详解）_jy02268879的博客-CSDN博客_springboot 事务嵌套</span><span class=\"link-desc\">一、事务传播机制：事务的传播行为是针对嵌套事务而言。示例：@Transactional(propagation = Propagation.REQUIRED)2.1.1REQUIREDspring默认的事务传播行为就是它。支持事务。如果业务方法执行时已经在一个事务中，则加入当前事务，否则重新开启一个事务。外层事务提交了，内层才会提交。内/外只要有报错，他俩会一起回滚。...</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/jy02268879/article/details/84322459</span></span></a></p>\n<h3><span style=\"color:#fe2c24;\"><strong>1.REQUIRED</strong></span></h3>\n<p>@<span style=\"color:#494949;\">Transactional</span>(propagation = Propagation.REQUIRED)<br/> spring中的默认事务传播行为就是它。如果业务方法执行时已经在一个事务中，则加入当前事务，</p>\n<p>否则重新开启一个事务。外层事务提交了，内层才会提交。内/外只要有报错，他俩会一起回滚。</p>\n<p><span style=\"color:#494949;\"><strong>只要内层方法报错抛出异常，即使外层有try-catch，该事务也会回滚。</strong></span></p>\n<p><span style=\"color:#494949;\"><strong>因为内外层方法在同一个事务中，内层只要抛出了异常，这个事务就会被设置成rollback-only，即使外层try-catch内层的异常，该事务也会回滚。</strong></span></p>\n<h3><span style=\"color:#fe2c24;\"><strong>2.REQUIRES_NEW</strong></span></h3>\n<p>@Transactional(propagation = Propagation.REQUIRES_NEW)</p>\n<p>支持事务。每次都是创建一个新事物，如果当前已经在事务中了，会挂起当前事务。内层事务结束，内层就提交了，不用等着外层一起提交。</p>\n<p><span style=\"color:#494949;\"><strong>外层报错回滚，不影响内层。内层报错回滚，外层try-catch内层的异常，外层不会回滚。</strong></span></p>\n<p><span style=\"color:#494949;\"><strong>内层报错回滚，然后又会抛出异常，外层如果没有捕获处理内层抛出来的这个异常，外层还是会回滚的。</strong></span></p>\n<h3><span style=\"color:#fe2c24;\"><strong>3.NESTED</strong></span></h3>\n<p></p>\n<p>@Transactional(propagation = Propagation.NESTED)</p>\n<p>支持事务。如果当前事务存在，那么在嵌套的事务中执行，内层事务结束，要等着外层一起提交。如果当前事务不存在，则表现跟REQUIRED一样。</p>\n<p><strong>这个直接说，如果</strong><span style=\"color:#494949;\"><strong>外层报错</strong></span><strong>回滚，</strong><span style=\"color:#494949;\"><strong>内层</strong></span><strong>也会跟着回滚。</strong></p>\n<p><strong>如果只是内层回滚，不影响外层。这个内层回滚不影响外层的特性是有前提的，否则内外都回滚。</strong></p>\n<p><strong><span style=\"color:#494949;\">内层是NESTED模式下，外层要try-catch内层的异常，外层才不会回滚。而内层是REQUIRED模式的话，即使外层try-catch内层异常，外层同样会回滚的。</span></strong></p>\n<h3><span style=\"color:#fe2c24;\"><strong>4.SUPPORTS</strong></span></h3>\n<p>@Transactional(propagation = Propagation.SUPPORTS)</p>\n<p>支持事务。当前有事务就支持使用当前事务，若当前不存在事务，以非事务的方式执行。内层事务结束，要等着外层一起提交。</p>\n<h3><span style=\"color:#fe2c24;\">5.<strong>MANDATORY</strong></span></h3>\n<p>@Transactional(propagation = Propagation.MANDATORY)</p>\n<p>支持事务，如果业务方法执行时已经在一个事务中，则加入当前事务。否则抛出异常。内层事务结束，要等着外层一起提交。</p>\n<h3><span style=\"color:#fe2c24;\">6.<strong>NOT_SUPPORTED</strong></span></h3>\n<p>@Transactional(propagation = Propagation.NOT_SUPPORTED)</p>\n<p>不支持事务，以非事务的方式执行，若当前存在事务，则把当前事务挂起，等方法执行完毕后，事务恢复进行。</p>\n<p><strong>若A是事务执行，B（NOT_SUPPORTED非事务执行）B在A尚未提交前再操作同一条记录，会产生死锁，A、B不可操作同一条记录。</strong></p>\n<h3><span style=\"color:#fe2c24;\"><strong>7.NEVER</strong></span></h3>\n<p>@Transactional(propagation = Propagation.NEVER) </p>\n<p>不支持事务。如果当前已经在一个事务中了，抛出异常。</p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-05-24 17:47:01", "summary": "自己学习事务做的笔记，方便记忆和复习、事务是为了解决数据安全问题而存在的。最经典的例子就是银行转账问题，账户给账户转账元，账户扣除元后由于不可抗力因素导致程序中断，账户没有收到那元，账户那元凭空消失，"}