{"blogid": "126441518", "writerAge": "码龄1年", "writerBlogNum": "43", "writerCollect": "658", "writerComment": "2057", "writerFan": "2894", "writerGrade": "5级", "writerIntegral": "4005", "writerName": "令辰柒", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126441518.jpg", "writerRankTotal": "4450", "writerRankWeekly": "86", "writerThumb": "1227", "writerVisitNum": "19640", "blog_read_count": "394", "blog_time": "于 2022-08-20 19:33:30 发布", "blog_title": "【JavaSE】继承与多态（上篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✨hello，进来的小伙伴们，你们好呐！✨</p>\n<p>🍊🍊系列专栏：【JavaSE】🍵</p>\n<p>🍤🍤本篇内容：继承部分知识详解（对准知识点阅读喔！）</p>\n<p>🧀🧀作者简介：一名大二即将升大三的科班小白，我很平凡，学会努力！</p>\n<p>🌯🌯码云存放仓库gitee：<a href=\"https://gitee.com/king-zhou-of-java/java-se.git\" title=\"https://gitee.com/king-zhou-of-java/java-se.git\">https://gitee.com/king-zhou-of-java/java-se.git</a></p>\n</blockquote>\n<p style=\"margin-left:0px;\"><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5\">一、继承的概念</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95\">二、继承的语法</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98\">三、访问父类成员</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%BA%94%E3%80%81%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">四、super关键字</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%BA%94%E3%80%81%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">五、子类构造方法</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%85%AD%E3%80%81super%E5%92%8Cthis%E6%AF%94%E8%BE%83\">六、super和this比较</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%83%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\">七、代码块执行顺序</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%85%AB%E3%80%81final%20%E5%85%B3%E9%94%AE%E5%AD%97\">八、final 关键字</a></p>\n<hr/>\n<h1> 一、继承的概念</h1>\n<p>🍊继承(inheritance)机制：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：<strong>共性的抽取，实现代码复用。</strong></p>\n<p>例如：狗和猫都是动物，那么我们就可以将共性的内容进行抽取，然后采用继承的思想来达到共用</p>\n<h1>二、继承的语法</h1>\n<p>🍉在Java中如果要表示类之间的继承关系，需要借助<strong>extends</strong>关键字。</p>\n<pre><code class=\"language-cpp\">修饰符 class 子类 extends 父类 {\n……\n}</code></pre>\n<p>实例：我们定义一个父类Animal，两个子类Dog和Cat继承父类Animal。</p>\n<p>🍱1.首先我们定义了一个父类Animal，其中包含了两个成员变量name和age，两个成员方法eat()和drink()。</p>\n<pre><code class=\"language-java\">class Animal{\n    public String name;\n    public int age;\n    public void eat(){\n        System.out.println(name+\"正在吃东西\");\n    }\n    public void drink(){\n        System.out.println(name+\"正在喝水\");\n    }\n}</code></pre>\n<p>🍺2.然后我们定义两个子类(Dog和Cat）继承自Animal。</p>\n<pre><code class=\"language-cpp\">class Dog extends Animal{\n    public void barks(){\n        System.out.println(name+\"汪汪汪~\");\n    }\n}\nclass Cat extends Animal{\n    public void mew(){\n        System.out.println(name+\"喵喵喵\");\n    }\n}</code></pre>\n<p>🌯3.OK接下来定义我们的测试类。</p>\n<pre><code class=\"language-cpp\">public class Test1 {\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        System.out.println(dog.name);\n        System.out.println(dog.age);\n        dog.eat();\n        dog.drink();\n        dog.barks();\n    }\n}</code></pre>\n<blockquote>\n<p><strong>🍥🍥解答：</strong></p>\n<p><strong>dog类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的。</strong></p>\n<p><strong>dog访问的eat()和drink()方法也是从Animal中继承下来的。</strong></p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"a57a0448241544a380ddff2cc41b2c2c.png\" src=\"..\\..\\static\\image\\a57a0448241544a380ddff2cc41b2c2c.png\"/></p>\n<h1>三、访问父类成员</h1>\n<p><strong>🍼1.子类中访问父类的成员变量。</strong></p>\n<p>🚎1&gt;子类和父类不存在同名成员变量。</p>\n<pre><code class=\"language-cpp\">public class Base {\n  int a;\n  int b;\n}\npublic class Derived extends Base{\n  int c;\n  public void method(){\n    a = 10;   // 访问从父类中继承下来的a\n    b = 20;   // 访问从父类中继承下来的b\n    c = 30;   // 访问子类自己的c\n }\n}</code></pre>\n<p>🚌2&gt;子类和父类成员变量同名。</p>\n<pre><code class=\"language-cpp\">public class Base {\n  int a;\n  int b;\n  int c;\n}\n\npublic class Derived extends Base{\n  int a;        // 与父类中成员a同名，且类型相同\n  char b;       // 与父类中成员b同名，但类型不同\n  public void method(){\n    a = 100;     // 访问父类继承的a，还是子类自己新增的a？\n    b = 101;     // 访问父类继承的b，还是子类自己新增的b?\n    c = 102;     // 子类没有c，访问的肯定是从父类继承下来的c\n    // d = 103;   // 编译失败，因为父类和子类都没有定义成员变量b\n }\n}</code></pre>\n<blockquote>\n<p><strong>✈️✈️结论：</strong></p>\n<p><strong>⛵如果访问的成员变量子类中有，优先访问自己的成员变量。</strong></p>\n<p><strong>🛬如果访问的成员变量与父类中成员变量同名，则优先访问自己的。<br/> 如果访问的成员变量子类中无，则访问父类继承下来的，如果父类也没有定义，则编译报错。</strong></p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>🛰️🛰️2.子类中访问父类的成员方法。</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>规则与子类访问父类的成员变量相同，这里就不在多余介绍！</strong></span></p>\n</blockquote>\n<p>如果子类中存在与父类中相同的成员时，那如何在子类中访问父类相同名称的成员呢？</p>\n<h1>四、super关键字</h1>\n<blockquote>\n<p><span style=\"color:#956fe7;\">⛴️⛴️由于设计不好，或者因场景需要，子类和父类中可能会存在相同名称的成员，如果要在子类方法中访问父类同名成员时，该如何操作？直接访问是无法做到的，Java提供了super关键字，该关键字主要作用：<strong>在子类方法中访问父类的成员。</strong></span></p>\n</blockquote>\n<p>⛽⛽super三个用法：</p>\n<pre><code class=\"language-cpp\">super.data;访问父类普通成员变量;\nsuper.func（）;访问父类普通成员方法;\nsuper（）;调用父类的构造方法;</code></pre>\n<p>实例:</p>\n<p>🚌1.首先我们定义一个父类A。</p>\n<pre><code class=\"language-cpp\">class A{\n    public String name;\n    public  int age;\n    public void method1(){\n        System.out.println(\"这是A的method1方法\");\n    }\n    public void method2(){\n        System.out.println(\"这是A的method2方法\");\n    }\n}</code></pre>\n<p> 🚋2.然后我们定义子类B继承父类A，在这个子类中有自己的成员变量和成员方法，具体如何访问都写在注释里。</p>\n<pre><code class=\"language-cpp\">class B extends A{\n    public String name;// 与父类中成员变量同名且类型相同\n    public double age; // 与父类中成员变量同名但类型不同\n    public void method1(int a){\n        System.out.println(\"这是B中的method1方法\");\n    }\n    public void method3(){\n        name = \"张三\";// 对于同名的成员变量，直接访问时，访问的都是子类的\n        age = 18;\n        super.name = \"林青霞\";// 访问父类的成员变量时，需要借助super关键字\n        super.age = 20; // super是获取到子类对象中从基类继承下来的部分\n\n        //父类和子类中构成重载的方法，直接可以通过参数列表区分清访问父类还是子类方法\n        method1();//访问父类的method1方法\n        method1(30);//访问子类的带一个参数的method1方法\n    }\n}</code></pre>\n<blockquote>\n<p><span style=\"color:#ff9900;\"><strong>⛵⛵注意！</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>🍊1. 只能在非静态方法中使用。<br/> 🍎2. 在子类方法中，访问父类的成员变量和方法。</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>🍓3.对于父类的private成员变量，子类会继承该成员变量，但是不可以访问！</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>🍔4.java不支持多继承，即一个类只能继承一个父类。</strong></span></p>\n</blockquote>\n<h1><strong> 五、子类构造方法</strong></h1>\n<p>即子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。</p>\n<p>什么意思呢？下面给大家演示一下：</p>\n<p>🍜🍜1.我们首先定义一个父类A1，包含两个成员变量，一个成员方法。</p>\n<pre><code class=\"language-cpp\">class A1{\n    public String name;\n    public int age;\n    public void eat(){\n        System.out.println(name+\"正在吃东西\");\n    }\n}</code></pre>\n<p>🍛🍛2.然后我们定义一个子类B1继承自父类A1，子类中新增一个成员变量color。</p>\n<pre><code class=\"language-cpp\">class B1 extends A1{\n    public String color;\n}</code></pre>\n<p>🍲🍲3.那么这个时候我们想通过构造方法在子类中给color成员变量初始化，就必须先给基类中继承下来的成员变量初始化，然后初始化自己的成员变量。</p>\n<pre><code class=\"language-cpp\">class B1 extends A1{\n    public String color;\n    public B1(){\n//  super(); // 注意子类构造方法中默认会调用基类的无参构造方法：super(),\n// 用户没有写时,编译器会自动添加，而且super()必须是子类构造方法中第一条语句，\n// 并且只能出现一次\n        this.color = color;\n    }\n}</code></pre>\n<p>🍵🍵4.如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。</p>\n<pre><code class=\"language-cpp\">class A1{\n    public String name;\n    public int age;\n    public A1(String name,int age){//此时父类构造方法是带有两个参数的\n        this.age = age;\n        this.name = name;\n    }\n}\n\nclass B1 extends A1{\n    public String color;\n    public B1(String name,int age){//子类构造方法必须带有明确的基类的参数，然后通过super关键字访问父类成员变量\n        super(name,age);//必须卸载构造方法第一行\n        this.color = color;\n    }\n}</code></pre>\n<p>☕☕5. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现。</p>\n<p style=\"text-align:center;\"><img alt=\"4c3a19e5d99b46ffaa62eae1aeb49dee.png\" src=\"..\\..\\static\\image\\4c3a19e5d99b46ffaa62eae1aeb49dee.png\"/></p>\n<h1> 六、super和this比较</h1>\n<blockquote>\n<p><span style=\"color:#a2e043;\">🍰🍰【相同点】<br/> 1. 都是Java中的关键字。<br/> 2. 只能在类的非静态方法中使用，用来访问非静态成员方法和字段。<br/> 3. 在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在。</span></p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#956fe7;\">🍻🍻【不同点】<br/> 1. this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用。</span></p>\n<p><span style=\"color:#956fe7;\">2. 在非静态成员方法中，this用来访问本类的方法和属性，super用来访问父类继承下来的方法和属性。<br/> 3. 在构造方法中：this(...)用于调用本类构造方法，super(...)用于调用父类构造方法，两种调用不能同时在构造方法中出现。<br/> 4. 构造方法中一定会存在super(...)的调用，用户没有写编译器也会增加，但是this(...)用户不写则没有。</span></p>\n</blockquote>\n<p><img alt=\"2193da9e80a84c90b50e6c1e251bb58b.jpeg\" src=\"..\\..\\static\\image\\2193da9e80a84c90b50e6c1e251bb58b.jpeg\"/>🥪🥪看个图片放松一下叭!</p>\n<h1> 七、代码块执行顺序</h1>\n<p>本小节内容只需记忆便可，想详细了解原理的可以查找其他资料哈！博主在这里不过多介绍！</p>\n<blockquote>\n<p><strong>🥠1、父类静态代码块优先于子类静态代码块执行，且是最早执行。<br/> 🥐2、父类实例代码块和父类构造方法紧接着执行。<br/> 🥮3、子类的实例代码块和子类构造方法紧接着再执行。<br/> 🥞4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行。</strong></p>\n</blockquote>\n<h1> 八、final 关键字</h1>\n<p>final关键可以用来修饰变量、成员方法以及类。</p>\n<p>🍏🍏1. 修饰变量或字段，表示常量(即不能修改)。</p>\n<p style=\"text-align:center;\"><img alt=\"c70c6f8e5c7e4d25883171de2e864ccb.png\" src=\"..\\..\\static\\image\\c70c6f8e5c7e4d25883171de2e864ccb.png\"/></p>\n<p>🍑🍑 2. 修饰类：表示此类不能被继承。</p>\n<p style=\"text-align:center;\"><img alt=\"55c4fe3b0c5446dba21431dfbe25b0e4.png\" src=\"..\\..\\static\\image\\55c4fe3b0c5446dba21431dfbe25b0e4.png\"/></p>\n<p>🍒🍒3. 修饰方法：表示该方法不能被重写(后序介绍)。</p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-20 19:33:30", "summary": "，进来的小伙伴们，你们好呐！系列专栏：本篇内容：继承部分知识详解对准知识点阅读喔！作者简介：一名大二即将升大三的科班小白，我很平凡，学会努力！码云存放仓库：目录一、继承的概念二、继承的语法三、访问父类"}