{"blogid": "126258585", "writerAge": "码龄3年", "writerBlogNum": "929", "writerCollect": "107717", "writerComment": "7507", "writerFan": "131611", "writerGrade": "8级", "writerIntegral": "45734", "writerName": "川川菜鸟", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126258585.jpg", "writerRankTotal": "61", "writerRankWeekly": "56", "writerThumb": "23862", "writerVisitNum": "3181774", "blog_read_count": "7741", "blog_time": "于 2022-08-10 01:30:53 发布", "blog_title": "一种能让大型数据聚类快2000倍的方法，真不戳", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>一、问题描述</h2>\n<p>国家天文台有个聚类任务：共11份数据，每份数据是从一张照片中提取出来的，包含500多万条记录，每条记录是一个天体的坐标及属性。11张“照片”中有些天体坐标是重复的，但这些重复的坐标不完全相同，他们会有一些差别但距离不会太远。任务就是把其中一张“照片”作为基础，从其他照片中找出重复的天体，把重复天体的坐标及属性均值作为该天体的最终坐标和属性，即把距离很近的天体聚成一类再做聚合运算，这样就可以得到一张坐标清晰且信息更加准确的天体“照片”。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f6bdf12389474f0a999821a3a7ce44fe.png\"/></p>\n<h2><a id=\"_7\"></a>二、问题分析</h2>\n<p>这个任务不算复杂，只要循环基础照片中的每一个天体坐标，将其与其他照片中的每个天体坐标计算距离，不超过某个阈值就认为是同一个天体，视作一类，最后将每一类中所有天体坐标求均值就得到了该天体的坐标。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\b7f53476bf9ef3bb902ffe3ad7e71be4.png\"/></p>\n<p>但是当用计算机计算时就发现这个任务的计算量是惊人的，基础照片需要循环500多万次，其中的每个天体坐标又要与其他照片中的5000多万个坐标计算距离，计算复杂度是500多万*5000多万，这将是个天文数字。</p>\n<p>事实也确实如此，在实验阶段，把每张照片的数据量减小10倍，即每张照片的天体坐标量为50万，用Python写出代码实现上述方法计算出11张照片的聚类结果需要的时间是6.5天。按计算复杂度来算，500多万的数据量，计算量是50万数据量的100倍，即需要耗时650天，这肯定是一个无法接受的数字。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\42707ef0e1224bd9a1a8f1e411b87e0e.png\"/></p>\n<p>同样的50万数据量，被装入了某分布式数据库后用SQL实现，动用了100颗CPU后，跑了3.8小时完成了计算。看起来比Python快了很多倍，但Python的6.5天是单线程，细算下来SQL的单核性能还不如Python（3.8小时*100&gt;6.5天）。巨大的资源消耗已经难以容忍，而且计算500多万规模时也要380小时。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1968784efb704280b737cc3e5ff1ba74.png\"/></p>\n<h2><a id=\"_21\"></a>三、解决方案</h2>\n<p>我们来考虑哪里可以优化以减少计算量。基础照片中的天体坐标是必须循环的，这样才能保证每个天体都被用来聚类了，其他照片中的天体坐标不用每次都遍历，只要找到基础天体坐标附近的坐标就可以了。这类查找任务很适合二分法，它可以大量减少计算量。</p>\n<p>具体过程是这样的：先对每张照片中的天体坐标排序，用二分法找到某个阈值范围内的天体坐标，这样就排除了大多数天体，这是粗筛过程；用基础天体与粗筛结果中的天体计算距离，找出符合条件的结果，这是细筛过程。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f1bc3da4d0d8449b8823ecb287d63879.png\"/></p>\n<p>来看看粗筛加细筛方法的计算量，10张照片每张排序一次，计算量是500万*log(500万)<em>10；二分法粗筛，计算量是500万</em>log(500万)<em>10；细筛过程，计算量不确定，但根据经验，粗筛后的结果通常不超过1万个，粗筛的计算量中log(500万)还要再加1万；这样算下来，总的计算量大概是500万</em>log(500万)<em>10+500万</em>(log(500万)+1万)*10，相较于原来的方法，计算量只有原来的五百分之一。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\b3fd2285504b436d9dc5e984caf3af9e.png\"/></p>\n<h2><a id=\"_32\"></a>四、技术选型</h2>\n<p>方法有了，还要选择程序工具，之前实现时使用Python，不可否认Python很强大，有天文学计算的现成框架，比如计算距离的方法，只要调用现成的类库就可以轻松算出来。</p>\n<p>但Python也有着非常严重的弊端：</p>\n<ol><li> <p>Python中没有原生的二分法方法，第三方的类库还要结合Pandas来完成，期间需要做一些数据转换，这些都必然会带来一些不必要的开销。</p> </li><li> <p>Python的多线程是假多线程，实际上不支持多线程并行，这也是Python不能成为本任务工具的重要原因。</p> </li></ol>\n<p>关系数据库的SQL也无法高效完成。这个聚类运算本质上是个非等值连接，数据库对于等值连接还能采用HASH JOIN等优化方案来减少计算量，但对于非等值连接就只能采用遍历方案了；SQL也无法在语句中实现上面设计的复杂过程，不能识别距离的单调性而主动排序并采用二分法；再加上本来做这类数学类计算的能力不足（距离计算涉及三角函数）；所以发生了前面实验阶段中SQL的单核性能还跑不过Python的现象。</p>\n<p>Java等高级语言虽然可以实现二分法，也可以很好的并行，但代码写起来冗长，开发效率过低，会严重影响程序的可维护性。</p>\n<p>那么，还能用什么工具来完成这个任务呢？集算器SPL是个很好的选择，它内置了很多高性能算法（如二分法），也支持多线程并行，代码写起来也简单明了，还提供了友好的可视化调试机制，能有效提高开发效率，以及降低维护成本。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\22cdbc7c3a324007bf14d55b22818708.png\"/></p>\n<h2><a id=\"_53\"></a>五、实际效果</h2>\n<p>相较于Python来说，SPL为本任务提速2000倍，二分法能够提速500倍，多线程并行又提速4倍（笔者笔记本电脑的CPU只有4核），总计提速2000倍，使用SPL完成500多万目标规模的聚类任务只需要数个小时。</p>\n<p>SPL的代码不仅性能优异，而且也并不复杂，关键计算代码只要23行。</p>\n<table width=\"100%\"><tbody><tr class=\"firstRow\"><td width=\"44\"></td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr><tr><td>1</td><td>=RThd</td><td colspan=\"2\">/距离阈值</td><td></td><td></td></tr><tr><td>2</td><td>=NJob=4</td><td colspan=\"2\">/并行线程数</td><td></td><td></td></tr><tr><td>3</td><td colspan=\"2\">=file(\"BasePhoto.csv\").import@tc()</td><td></td><td></td><td></td></tr><tr><td>4</td><td colspan=\"2\">=directory@p(OtherPhotos)</td><td colspan=\"2\">/其他照片路径</td><td></td></tr><tr><td>5</td><td>for A4</td><td>=file(A4).import@tc()</td><td colspan=\"2\">/其他照片</td><td></td></tr><tr><td>6</td><td></td><td colspan=\"3\">=B5.sort@m(OnOrbitDec)</td><td>/排序</td></tr><tr><td>7</td><td></td><td colspan=\"2\">=B6.min(DEC)</td><td></td><td></td></tr><tr><td>8</td><td></td><td>=delta_ra=F(B7,RThd)</td><td colspan=\"2\">/根据DEC算RA阈值</td><td></td></tr><tr><td>9</td><td></td><td>=FK(B5,NJob)</td><td colspan=\"2\">/数据索引分段</td><td></td></tr><tr><td>10</td><td></td><td>fork B9</td><td>=B5(B10)</td><td colspan=\"2\">/照片片段</td></tr><tr><td>11</td><td></td><td></td><td>for A3</td><td>=C11.OnOrbitDec</td><td>/DEC</td></tr><tr><td>12</td><td></td><td></td><td></td><td>=D11-delta_rad</td><td>/DEC下限</td></tr><tr><td>13</td><td></td><td></td><td></td><td>=D11+delta_rad</td><td>/DEC上限</td></tr><tr><td>14</td><td></td><td></td><td></td><td>=C11.RA</td><td>/RA</td></tr><tr><td>15</td><td></td><td></td><td></td><td>=D14-delta_ra</td><td>/RA下限</td></tr><tr><td>16</td><td></td><td></td><td></td><td>=D14+delta_ra</td><td>/RA上限</td></tr><tr><td>17</td><td></td><td></td><td></td><td>=C10.select@b(between@b(OnOrbitDec,D12:D13))</td><td>/二分查找DEC</td></tr><tr><td>18</td><td></td><td></td><td></td><td>=D17.select(RA&gt;=D10&amp;&amp;RA&lt;=D11)</td><td>/查找RA</td></tr><tr><td>19</td><td></td><td></td><td></td><td>=D36.select(Dis(~,C11)&lt;=A7)</td><td>/细筛</td></tr><tr><td>20</td><td></td><td></td><td></td><td>if D19!=[]</td><td>/合并结果</td></tr><tr><td>21</td><td></td><td></td><td></td><td></td><td>=FC(C11,D37)</td></tr><tr><td>22</td><td></td><td>=@|B10</td><td colspan=\"2\">/汇总结果</td><td></td></tr><tr><td>23</td><td colspan=\"2\">=file(OFile).export@tc(B22)</td><td colspan=\"2\">/写出结果</td><td></td></tr></tbody></table>\n<p>B10格的fork是多线程并行函数，允许分段执行上述算法。B6格的sort@m()函数是并行排序方法，数据量大时可以提高效率，数据有序是二分法使用的前提条件。C17格的select@b(…)函数是二分查找方法，也是本任务提速的关键。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e51ace87d295466ea541d7ea3cac2740.png\"/></p>\n<h2><a id=\"_245\"></a>六、后记</h2>\n<p>性能优化的问题依赖于高性能的算法，只有把计算量降下来才能有效提高运行效率，而高性能算法需要在工作中慢慢积累，感兴趣的同学可以来这里学习常用的性能优化算法：<a href=\"http://www.raqsoft.com.cn/wx/course-performance-optimizing.html\">性能优化算法</a>。</p>\n<p>高性能算法需要高效的编程工具来实现，之前已经说过，Python、SQL、java等语言都有其弊端，要么无法并行，要么实现困难、维护困难。SPL有足够的算法底层支持且允许高并发，代码能做到很简洁，还提供了友好的可视化调试机制，能有效提高开发效率，以及降低维护成本。</p>\n<h2><a id=\"SPL_253\"></a>七、SPL资料</h2>\n<p>高性能算法需要高效的编程工具来实现，之前已经说过，Python、SQL、java等语言都有其弊端，要么无法并行，要么实现困难、维护困难。SPL有足够的算法底层支持且允许高并发，代码能做到很简洁，还提供了友好的可视化调试机制，能有效提高开发效率，以及降低维护成本。</p>\n<ul><li><a href=\"http://c.raqsoft.com.cn/article/1595816810031\">SPL下载</a></li><li><a href=\"https://github.com/SPLWare/esProc\">SPL源代码</a></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-10 01:30:53", "summary": "一、问题描述国家天文台有个聚类任务：共份数据，每份数据是从一张照片中提取出来的，包含多万条记录，每条记录是一个天体的坐标及属性。张照片中有些天体坐标是重复的，但这些重复的坐标不完全相同，他们会有一些差"}