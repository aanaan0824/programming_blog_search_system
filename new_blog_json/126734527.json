{"blogid": "126734527", "writerAge": "码龄1年", "writerBlogNum": "19", "writerCollect": "178", "writerComment": "222", "writerFan": "589", "writerGrade": "4级", "writerIntegral": "873", "writerName": "神偷怪盗基德", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126734527.jpg", "writerRankTotal": "23317", "writerRankWeekly": "495", "writerThumb": "202", "writerVisitNum": "9345", "blog_read_count": "155", "blog_time": "于 2022-09-07 08:15:00 发布", "blog_title": "一道线段树相关算法题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>在二维平面上的 x 轴上，放置着一些方块。</p>\n<p>给你一个二维整数数组 positions ，其中 positions[i] = [lefti, sideLengthi] 表示：第 i 个方块边长为 sideLengthi ，其左侧边与 x 轴上坐标点 lefti 对齐。</p>\n<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 另一个正方形的顶边 或者是 x 轴上 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>\n<p>在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。</p>\n<p>返回一个整数数组 ans ，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。</p>\n<p><img alt=\"\" height=\"457\" src=\"..\\..\\static\\image\\67fb5dc6b5a64bd09e015d3763682c0a.png\" width=\"369\"/></p>\n<p><img alt=\"\" height=\"103\" src=\"..\\..\\static\\image\\e0f2ef32d54c4c298e9a94bc53e6ff6d.png\" width=\"442\"/></p>\n<p> 来源：力扣（LeetCode）<br/> 链接：https://leetcode.cn/problems/falling-squares</p>\n<p></p>\n<p>随机抽了个题，题目意思并不复杂，就是不断有方块掉落，后面掉的方块会压在前面掉的方块上面，要求返回每次落完方块后的最大高度。</p>\n<p>额，虽然题目意思不难理解，但是……咳咳，我是废物，暴力的话感觉可能过不了（后面看评论区是能过的），然后就直接看大佬们写的题解咯</p>\n<p>学了个 线段树 + 离散化 的方法感觉还不错，分享一下</p>\n<p>为啥用线段树：线段树可以实现log级别的对某区间进行增加、修改、查询。</p>\n<p>为啥离散化：采用4倍叶子节点的堆式线段树，题目说了 left &lt;= 10 ^ 8 ，sideLength &lt;= 10 ^ 6，这样所占空间太大了，会超出空间限制。而使用离散化并不会影响最终结果，所以使用了离散化</p>\n<pre><code class=\"language-java\">class Solution {\n    static class SegmentTree {\n        private int[] max;\n        private int[] change;\n        private boolean[] update;\n\n        //4倍叶子节点的堆式线段树\n        public SegmentTree(int size) {\n            int N = size + 1;\n            max = new int[N];\n            //用于记录是否需要更新\n            update = new boolean[N &lt;&lt; 2];\n            //用于记录如果要更新的话，要更新为啥\n            change = new int[N &lt;&lt; 2];\n        }\n\n        // 更新 rt 位置\n        public void pushUp(int rt) {\n            max[rt] = Math.max(max[rt &lt;&lt; 1], max[rt &lt;&lt; 1 | 1]);\n        }\n\n        // 更新 rt 下面的位置\n        public void pushDown(int rt) {\n            if (update[rt]) {\n                update[rt] = false;\n                update[rt &lt;&lt; 1] = true;\n                update[rt &lt;&lt; 1 | 1] = true;\n                change[rt &lt;&lt; 1] = change[rt];\n                change[rt &lt;&lt; 1 | 1] = change[rt];\n                max[rt &lt;&lt; 1] = change[rt];\n                max[rt &lt;&lt; 1 | 1] = change[rt];\n            }\n        }\n\n        // 更新 L~R 范围内的最大值\n        public void update(int L, int R, int C, int l, int r, int rt) {\n            if (L &lt;= l &amp;&amp; r &lt;= R) {\n                max[rt] = C;\n                update[rt] = true;\n                change[rt] = C;\n                return;\n            }\n            int mid = (l + r) &gt;&gt; 1;\n            pushDown(rt);\n            if (L &lt;= mid) {\n                update(L, R, C, l, mid, rt &lt;&lt; 1);\n            }\n            if (R &gt; mid) {\n                update(L, R, C, mid + 1, r, rt &lt;&lt; 1 | 1);\n            }\n            pushUp(rt);\n        }\n\n        // 查询 L~R 范围内的最大值\n        public int query(int L, int R, int l, int r, int rt) {\n            if (L &lt;= l &amp;&amp; r &lt;= R) {\n                return max[rt];\n            }\n            int mid = (l + r) &gt;&gt; 1;\n            pushDown(rt);\n            int max = Integer.MIN_VALUE;\n            if (L &lt;= mid) {\n                max = Math.max(max, query(L, R, l, mid, rt &lt;&lt; 1));\n            }\n            if (R &gt; mid) {\n                max = Math.max(max, query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1));\n            }\n            return max;\n        }\n    }\n\n    // 离散化\n    public HashMap&lt;Integer, Integer&gt; index(int[][] positions) {\n        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();\n        for (int[] position : positions) {\n            set.add(position[0]);\n            // 减 1 是为了避免一个方块的尾位置和另一个方块的头位置粘着时不使得相邻的点位置为两个方块的累加和\n            // 所以统一每个方块右边位置减1\n            set.add(position[0] + position[1] - 1); \n        }\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        int index = 0;\n        for (Integer num : set) {\n            map.put(num, ++index);\n        }\n        return map;\n    }\n\n    public List&lt;Integer&gt; fallingSquares(int[][] positions) {\n        HashMap&lt;Integer, Integer&gt; map = index(positions); //离散化\n        int N = map.size();\n        SegmentTree segmentTree = new SegmentTree(N); //创建线段树\n        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 存储最终答案\n        int max = Integer.MIN_VALUE; // 记录方块每次落下时的最大值\n        for (int[] position : positions) { // 方块逐渐落下，线段树随之更新\n            Integer L = map.get(position[0]);\n            Integer R = map.get(position[0] + position[1] - 1);\n            int height = segmentTree.query(L, R, 1, N, 1) + position[1]; // 落下当前方块后 L~R 处的高度\n            max = Math.max(max, height);\n            res.add(max);\n            segmentTree.update(L, R, height, 1, N, 1);\n        }\n        return res;\n    }\n}\n</code></pre>\n<p>这题做下来收获还是很多的，希望大家也能有所收获呀</p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-09-07 08:15:00", "summary": "在二维平面上的轴上，放置着一些方块。给你一个二维整数数组，其中表示：第个方块边长为，其左侧边与轴上坐标点对齐。每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿轴负方向下落，直到着陆到另一"}