{"blogid": "125722258", "writerAge": "码龄1年", "writerBlogNum": "25", "writerCollect": "1917", "writerComment": "1204", "writerFan": "3389", "writerGrade": "5级", "writerIntegral": "2707", "writerName": "拼命阿紫", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125722258.jpg", "writerRankTotal": "7842", "writerRankWeekly": "1320", "writerThumb": "1070", "writerVisitNum": "93336", "blog_read_count": "3539", "blog_time": "已于 2022-07-13 14:35:17 修改", "blog_title": "【c语言】模拟实现字符串函数（上）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><strong>关关难过关关过</strong></p>\n<p style=\"text-align:center;\"><strong>前路漫漫亦灿烂</strong></p>\n<p style=\"text-align:center;\"><strong>今天 阿紫 就带领大家一起挑战字符串函数的模拟实现</strong></p>\n<p class=\"img-center\"><img alt=\"\" height=\"321\" src=\"..\\..\\static\\image\\b9e29ffb8bec40f3b4776151094e5ee4.jpeg\" width=\"321\"/></p>\n<hr/>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strlen%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strlen%C2%A0\">1.模拟实现strlen </a></p>\n<p id=\"1.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#1.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">1.1函数介绍</a></p>\n<p id=\"1.2%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#1.2%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0\">1.2函数的模拟实现 </a></p>\n<p id=\"2.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcpy-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcpy\">2.模拟实现strcpy</a></p>\n<p id=\"2.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#2.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">2.1函数介绍</a></p>\n<p id=\"2.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#2.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.2函数模拟实现</a></p>\n<p id=\"3.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcat-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcat\">3.模拟实现strcat</a></p>\n<p id=\"3.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#3.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">3.1函数介绍</a></p>\n<p id=\"3.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#3.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">3.2函数模拟实现</a></p>\n<p id=\"4.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcmp%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcmp%C2%A0\">4.模拟实现strcmp </a></p>\n<p id=\"4.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#4.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">4.1函数介绍</a></p>\n<p id=\"4.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#4.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">4.2函数模拟实现</a></p>\n<p id=\"5.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strstr-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strstr\">5.模拟实现strstr</a></p>\n<p id=\"5.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#5.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">5.1函数介绍</a></p>\n<p id=\"5.2%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#5.2%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">5.2函数的模拟实现</a></p>\n<p id=\"6.%E4%BA%86%E8%A7%A3strtok-toc\" style=\"margin-left:40px;\"><a href=\"#6.%E4%BA%86%E8%A7%A3strtok\">6.了解strtok</a></p>\n<p id=\"6.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#6.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">6.1函数介绍</a></p>\n<p id=\"6.2%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#6.2%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%C2%A0\">6.2函数使用 </a></p>\n<p id=\"7.%E4%BA%86%E8%A7%A3strerror-toc\" style=\"margin-left:40px;\"><a href=\"#7.%E4%BA%86%E8%A7%A3strerror\">7.了解strerror</a></p>\n<p id=\"7.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#7.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">7.1函数介绍</a></p>\n<p id=\"7.2%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#7.2%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8\">7.2函数使用</a></p>\n<hr/>\n<p>C语言中对 <strong>字符串 </strong>的处理很是<strong>频繁</strong>，<strong>C语言</strong>本身是<strong>没有字符串类型</strong>，但有<strong>字符类型</strong>，<strong>字符串</strong>通常放在 <strong>常量字符串</strong> 中或者 <strong>字符数组 </strong>中。</p>\n<p><strong>字符串常量</strong>：适用于那些<strong>不做修改</strong>的<strong>字符串函数</strong>，因为字符串常量是<strong>常量</strong>，常量是不允许被修改的，它存放在<strong>常量区</strong>。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\41929cf4897c4229a429548e065952d7.png\"/></p>\n<h2 id=\"1.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strlen%C2%A0\">1.模拟实现strlen </h2>\n<h3 id=\"1.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">1.1函数介绍</h3>\n<p>strlen：求字符串长度</p>\n<p>注：字符串以 <strong>\\0 </strong>作为字符串<strong>结束标志</strong>，strlen 函数返回的是 <strong>\\0</strong> <strong>之前的字符个数</strong>，不包含 \\0</p>\n<h3 id=\"1.2%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0\">1.2函数的模拟实现 </h3>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\debac3dd9b1144f2b44e7f1aae8a8cae.png\"/></p>\n<p>我们既然要模拟实现 strlen 函数，就得模拟的像一点，我们可以通过查询找到 strlen 函数的形式，通过查找，我们可以发现<strong>函数的参数</strong>是一个<strong>字符指针类型</strong>，返回值是 <strong>size_t </strong>（无符号整型）</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nsize_t my_strlen(const char* str)\n{\n\tassert(str != NULL);\n\tsize_t ret = 0;\n\twhile (*str++ != '\\0')\n\t{\n\t\tret++;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tchar arr[] = \"abcdef\";\n\tint ret = my_strlen(arr);\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>分析：函数参数前面加上 <strong>const</strong>  是<strong>避免误改字符串</strong>，因为我们只需要计算它的<strong>长度</strong>不需要改变。返回值为 <strong>size_t</strong> 因为长度不可能为负数，所以设为 size_t 最合理。*str++ != '\\0' 的运算：首先先对 <strong>str 解引用</strong>找到对应的字符然后与 <strong>\\0</strong> 比较，如果不等于 <strong>\\0</strong> 就 <strong>str++</strong> 指向下一个字符，然后依次循环，直到 *str 等于 \\0 然后跳出。</p>\n</blockquote>\n<hr/>\n<h2 id=\"2.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcpy\">2.模拟实现strcpy</h2>\n<h3 id=\"2.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">2.1函数介绍</h3>\n<p><strong>strcpy:</strong>字符串拷贝函数,将一个字符串的内容拷贝到另一个字符串中</p>\n<h3 id=\"2.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.2函数模拟实现</h3>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"..\\..\\static\\image\\2b4ec94b27ff42b0a42339c14580a4d3.png\"/></p>\n<p>通过查询 strcpy 函数，我们可以发现 strcpy 函数有两个参数分别都是指针类型，第一个指针指向的是目标空间，第二个指针指向的是源字符串，我们要把源字符串拷贝到目标空间中，所以目标空间要足够大，能存储的下源字符串，并且可修改。</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nchar* my_strcpy(char* dest, const char* source)\n{\n\tassert(dest != NULL);\n\tassert(source != NULL);\n\tchar* ret = dest;\n\twhile (*dest++ = *source++)\n\t{\n\t\t;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tchar arr1[20] = { 0 };\n\tchar arr2[] = \"abc\";\n\tmy_strcpy(arr1, arr2);\n\tprintf(\"%s\\n\", arr1);\n\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>分析：返回类型是 <strong>char*</strong>，我们用一个字符指针变量指向目标首地址，为了避免 <strong>dest</strong> 在后面指向的时候会改变指向的位置。把 <strong>*source</strong> 里面的字符 赋给 <strong>*dest</strong> ，然后在进行<strong> while</strong> 判断，如果不为 <strong>\\0 </strong>就后置<strong>++</strong>。</p>\n</blockquote>\n<p>思考：在字符串拷贝的时候会把源字符串的<span style=\"color:#0d0016;\"><strong> ‘\\0’</strong></span> 拷贝进去嘛？</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\76ea41446c2140958d929d324d6a1b53.png\"/></p>\n<p>通过调试，我们可以知道拷贝时会把 <span style=\"color:#0d0016;\"><strong>‘\\0’</strong> </span>拷贝进去。</p>\n<h2 id=\"3.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcat\">3.模拟实现strcat</h2>\n<h3 id=\"3.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">3.1函数介绍</h3>\n<p><strong>strcat：</strong>字符串追加函数，将一个字符串追加到另一个字符串的后面</p>\n<h3 id=\"3.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">3.2函数模拟实现</h3>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"..\\..\\static\\image\\dfe8f0b28f07480cbcf1e8d333f8aa61.png\"/></p>\n<p>通过查询 <strong>strcat</strong> 函数，我们可以发现 <strong>strcat </strong>函数有两个参数分别都是<strong>指针类型</strong>，第一个指针指向的是<strong>目标空间</strong>，第二个指针指向的是<strong>源字符串</strong>，我们要把源字符串追加到目标空间中，所以目标空间要<strong>足够大</strong>，能存储的下追加的源字符串，并且<strong>可修改</strong>。</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nchar* my_strcat(char* dest, const char* source)\n{\n\tassert(dest != NULL);\n\tassert(source != NULL);\n\tchar* ret = dest;\n\twhile (*dest != '\\0')\n\t{\n\t\tdest++;\n\t}\n\twhile (*dest++ = *source++)\n\t{\n\t\t;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tchar arr[20] = \"abc\";\n\tchar brr[] = \"def\";\n\tmy_strcat(arr, brr);\n\tprintf(\"%s\\n\", arr);\n\treturn 0;\n}</code></pre>\n<p>分析：找到目标空间 <strong>'\\0'</strong> 的位置，然后将源字符串的字符依次<strong>追加</strong>到目标空间里面，目标空间的 ‘\\0’ 是会被<strong>替换</strong>掉的，直到源字符串赋值到 <strong>‘\\0’</strong> 给目标空间就结束追加。</p>\n<p>思考：字符串可以自己给自己追加嘛？</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\c4dbabc92a69404a96bc87c55c630aab.png\"/></p>\n<p>结论：<strong>strcat 不可以</strong>自己给自己追加，因为一旦自己给自己追加就改变了 <strong>'\\0'</strong>，那么就一直追加下去，程序就会造成<strong>死循环</strong>。</p>\n<h2 id=\"4.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcmp%C2%A0\">4.模拟实现strcmp </h2>\n<h3 id=\"4.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">4.1函数介绍</h3>\n<p><strong>strcmp：</strong>字符串比较函数，是用来<strong>比较</strong>两个字符串大小的函数。</p>\n<p>很多人会误以为字符串比较跟整型比较的方法一样，这是不正确的 </p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\04cdd4014b3847f8bef60f5e24bf4f20.png\"/></p>\n<p>结论：上述代码充分证明了，字符串不能跟整型数据一样比较，那字符串与字符串怎么比较呢，字符串与字符串用 <strong>strcmp </strong>函数来比较。</p>\n<h3 id=\"4.2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">4.2函数模拟实现</h3>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"..\\..\\static\\image\\ee2ae3ff39e1484b9b944340249c2a1d.png\"/></p>\n<p>函数参数是两个指针，分别指向着两个需要比较的字符串，因为只需要比较不需要改变，所以前面加上了 <strong>const </strong>。返回值为<strong> int</strong> ，第一个字符串大于第二个字符串，则返回<strong>大于 0</strong> 的数字；第一个字符串等于第二个字符串，则<strong>返回0</strong>；第一个字符串小于第二个字符串，则返回<strong>小于0</strong>的数字。</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nint my_strcmp(const char* str1, const char* str2)\n{\n\tassert(str1 != NULL);\n\tassert(str2 != NULL);\n\twhile (*str1 == *str2)\n\t{\n\t\tif (*str1 == '\\0' &amp;&amp; *str2 == '\\0')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tstr1++;\n\t\tstr2++;\n\t}\n\treturn *str1 - *str2;\n}\nint main()\n{\n\tchar arr[] = \"abcdef\";\n\tchar brr[] = \"abc\";\n\tint ret = my_strcmp(arr, brr);\n\tif (ret &gt; 0)\n\t{\n\t\tprintf(\"&gt;\\n\");\n\t}\n\telse if (ret == 0)\n\t{\n\t\tprintf(\"==\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"&lt;\\n\");\n\t}\n\treturn 0;\n}</code></pre>\n<p>分析：首先如果<strong>*str1 == *str2</strong> ，就进入循环判断它们是否都为 <strong>'\\0' </strong>,如果是说明它们两个都结束了，且相等，那么就返回 <strong>0</strong>。否则就<strong> str1++，str2++</strong> 比较<strong>下一个字符</strong>是否<strong>相等</strong>，如果<strong>不相等</strong>就直接<strong>退出循环</strong>，返回 *<strong>str1 - *str2</strong>，如果返回的结果为<strong>负数</strong>，说明 <strong>*str1 小于 *str2</strong>，否则<strong>大于</strong>。</p>\n<h2 id=\"5.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strstr\">5.模拟实现strstr</h2>\n<h3 id=\"5.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">5.1函数介绍</h3>\n<p><strong>strstr：</strong>在一个字符串中找<strong>子串</strong>，例如 “abcdef”，找子串“def”，如果 “def” 在这个字符串中，则返回在这个字符串中找到子串的<strong>第一个字符的地址</strong>。</p>\n<h3 id=\"5.2%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">5.2函数的模拟实现</h3>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"..\\..\\static\\image\\783a8ac0a1a240b8ab8e55aa136fcec1.png\"/></p>\n<p>函数参数分别是两个<strong>字符指针类型</strong>，分别指向了两个字符串，第二个字符串叫做<strong>子串</strong>，就在第一个字符串中找子串，如果找到则返回在第一个字符串中查找的子串的第一个字符的地址。</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nchar* my_strstr(const char* str1, const char* str2)\n{\n\tassert(str1 &amp;&amp; str2);\n\tchar* s1 = str1;\n\tchar* s2 = str2;\n\tchar* p = str1;\n\twhile (*p)\n\t{\n\t\ts1 = p;\n\t\ts2 = str2;\n\t\twhile (*s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\n\t\t{\n\t\t\ts1++;\n\t\t\ts2++;\n\t\t}\n\t\tif (*s2 == '\\0')\n\t\t{\n\t\t\treturn p;\n\t\t}\n\t\tp++;\n\t}\n\treturn NULL;\n\n}\n\nint main()\n{\n\tchar arr[] = \"abcdefg\";\n\tchar brr[] = \"def\";\n\tchar* ret = my_strstr(arr, brr);\n\tprintf(\"%s\\n\", ret);\n\treturn 0;\n}</code></pre>\n<p>情况一：<strong>直接找到</strong>，然后对 <strong>s1</strong> 和 <strong>s2</strong> <strong>解引用</strong> 比较，当<strong> *s2 == '\\0'</strong> 时，说明<strong>查找完毕</strong>，<strong>找到了</strong>。如果找不到，当 <strong>*p == ‘\\0’</strong> <strong>退出循环</strong>，也就说明<strong>没有找到</strong>。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\e2543b711d4c40ff8d05b517ebadaad3.png\"/></p>\n<p>情况二：<strong>找多次找到</strong>，第一次找到了 ' <strong>b' </strong> ，*s1 和 *s2 都是 <strong>'b'</strong>，当 <strong>s1++</strong> 和 <strong>s2++</strong>，解引用然后它们里面的字符不相同了。然后 <strong>p</strong> 指向下一个字符，<strong>s1 = p</strong> ，<strong>s2 回到它第一个字符的位置</strong>，然后在找到与 <strong>s2</strong> 相同的字符然后在比较，直到 <strong>*s2 == '\\0' </strong>时，说明<strong>查找完毕</strong>，<strong>找到了</strong>。如果找不到，当 <strong>*p == ‘\\0’ 退出循环</strong>，也就说明<strong>没有找到</strong>。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\e719915e237c4b73a2ef0783a3c2abf8.png\"/></p>\n<h2 id=\"6.%E4%BA%86%E8%A7%A3strtok\">6.了解strtok</h2>\n<h3 id=\"6.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">6.1函数介绍</h3>\n<p><strong>strtok：</strong>字符串分割函数 </p>\n<h3 id=\"6.2%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%C2%A0\">6.2函数使用 </h3>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"..\\..\\static\\image\\85b92116b09145e69e1ddfa41d60541f.png\"/></p>\n<ul><li>delimiters 参数是个字符串，定义了用作分隔符的字符集合。</li><li>第一个参数指定一个字符串，它包含了0个或者多个由 delimiters 字符串中一个或者多个分隔符分割的标记。</li><li>strtok函数找到str中的下一个标记，并将其用 \\0 结尾，返回一个指向这个标记的指针。（注： strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容 并且可修改。）</li><li>strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串 中的位置。</li><li>strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标 记。</li><li>如果字符串中不存在更多的标记，则返回 NULL 指针。</li></ul>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main()\n{\n\tchar *p = \"I.LOVE@YOU\";\n\tconst char* sep = \".@\";\n\tchar arr[30];\n\tchar *str = NULL;\n\tstrcpy(arr, p);//将数据拷贝一份，处理arr数组的内容\n\tfor (str = strtok(arr, sep); str != NULL; str = strtok(NULL, sep))\n\t{\n\t\tprintf(\"%s\\n\", str);\n\t}\n}</code></pre>\n<h2 id=\"7.%E4%BA%86%E8%A7%A3strerror\">7.了解strerror</h2>\n<h3 id=\"7.1%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">7.1函数介绍</h3>\n<p><strong>strerror：</strong>返回错误码，所对应的错误信息。</p>\n<h3 id=\"7.2%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8\">7.2函数使用</h3>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;//必须包含的头文件\nint main()\n{\n\tFILE * pFile;\n\tpFile = fopen(\"aaa.txt\", \"r\");\n\tif (pFile == NULL)\n\t\tprintf(\"Error opening file unexist.ent: %s\\n\", strerror(errno));\n\t//errno: Last error number\n\treturn 0;\n}</code></pre>\n<p>目前我没有创建 aaa.txt 文件，这个程序就会将错误码转换为错误信息打印出来。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\663289ffc0324a119c1efc597731ead9.png\"/></p>\n<p style=\"text-align:center;\"></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-13 14:35:17", "summary": "关关难过关关过前路漫漫亦灿烂今天阿紫就带领大家一起挑战字符串函数的模拟实现目录模拟实现函数介绍函数的模拟实现模拟实现函数介绍函数模拟实现模拟实现函数介绍函数模拟实现模拟实现函数介绍函数模拟实现模拟实现"}