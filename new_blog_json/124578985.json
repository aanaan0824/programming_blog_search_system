{"blogid": "124578985", "writerAge": "码龄13年", "writerBlogNum": "34", "writerCollect": "22", "writerComment": "21", "writerFan": "8", "writerGrade": "5级", "writerIntegral": "1614", "writerName": "LeetJoe", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124578985.jpg", "writerRankTotal": "40829", "writerRankWeekly": "103788", "writerThumb": "12", "writerVisitNum": "134525", "blog_read_count": "1009", "blog_time": "于 2022-05-04 22:18:18 发布", "blog_title": "Unity脚本基础", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div>\n<div style=\"margin-left:0in;\">\n<div style=\"margin-left:0in;\">\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Awake, Start, Update, FixedUpdate，还有一个LateUpdate</span></h3>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\">Awake在游戏启动时运行一次，并且是在脚本组件未初始化完成时工作，可以用来做一些预设置；而Start是与组件相关的，当组件的脚本完成初始化且启用了脚本组件时，工作一次，并且是在第一次执行Update之前执行。</p>\n<p style=\"margin-left:0;\">Update是帧之间的更新，时间是不固定的，一般与物理引擎无关的更新都可以在Update里进行；</p>\n<p style=\"margin-left:0;\">FixedUpdate是固定周期的更新，与时间管理里的FixedTime设置有关，通常与物理引擎相关的更新都在FixedUpdate里完成，而且每次FixedUpdate执行完成后会立即执行必要的物理计算。</p>\n<p style=\"margin-left:0;\">LateUpdate应该是在一帧最后执行，也就是所有的update执行完成后执行。</p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Translate和Rotate</span></h3>\n<p style=\"margin-left:0;\">Translate是用来增量修改物体位置的，可以直接指定位移向量，也可以指定单个方向，比如transform.Translate(Vector3.forward, 10)表示向前移动10；位置除了用增量修改，也可以直接指定，如transform.localPosition = new Vector3(1,1,1);</p>\n<p style=\"margin-left:0;\">Rotrate是用来增量修改物理朝向的，也可以使用单向，如transform.Rotate(Vector3.up, 30). 其中的数字是欧拉角，90表示直角90度。但是不能像position那样直接指定rotation，比如transform.rotation = new Vector3(1,1,1);是不可以的。</p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">LookAt</span></h3>\n<p style=\"margin-left:0;\">这个方法可以实现“注视”功能，也就是朝向跟随（但是如何定义face，比如一个立方体，是它的哪个面进行朝向？这个不知道怎么设置），只需要选择一个对象，然后使用transform.LookAt(tartget)，就可以实现对target的注视功能。这个可以用来设置镜头跟随或者瞄准。</p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Mathf.Lerp</span></h3>\n<p style=\"margin-left:0;\">线性插值。有时候需要在两个位置之间按一定比例选择一个点，这就叫线性插值。比如起点是1，终点是5，按0.5的比例线性插值，就会得到3，正好在1和5之间。如果每次手动计算很麻烦，尤其是涉及三维坐标点的时候。使用</p>\n<p style=\"margin-left:0;\">Vector3 mid = Mathf.Lerp(new Vector3(1,2,3), new Vector(4,5,6), 0.5)</p>\n<p style=\"margin-left:0;\">就可以很方便地计算中间的某个点。在计算距离光源的某个点的光线强度的时候很有用。</p>\n<p style=\"margin-left:0;\">另外，还有一个叫SmoothDamp的方法也是类似的功能，还不清楚具体区别，有待进一步研究。</p>\n<p></p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Destroy, SetActive, enabled</span></h3>\n<p style=\"margin-left:0;\">Destroy用来删除一个对象或者组件。如果删除的是对象，其相关的组件也会被删除。如果对象的组件是公用的，这会影响其它引用组件的对象。</p>\n<p style=\"margin-left:0;\">SetActive用来控制一个对象是否生效。如果设置为false，对象将不活动且不可见。</p>\n<p style=\"margin-left:0;\">enabled用来设置一个组件Component是否生效，组件是对象的子对象。</p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">GetKey和GetButton</span></h3>\n<p style=\"margin-left:0;\">这两个都是用来获取按键状态的，区别在于GetKey使用的是预定义的按键名称，GetKey可以自定义按键名字。比如Input.GetKey(KeyCode.Space)表示获取空格键的状态。而GetButton可以通过在系统Edit-&gt;Project Settings-&gt;Input菜单里指定某个键特殊的名字，比如给空格键指定名字“Jump”，这样就可以通过Input.GetButton(\"Jump\")获取状态。</p>\n<p style=\"margin-left:0;\">两种方法都有三个状态：默认，Down, Up。教程里建议使用GetButton方法。</p>\n<p style=\"margin-left:0;\">第一帧，当一个键被按下时，GetButton， GetButtonDown会返回true, GetButtonUp返回的则是false；</p>\n<p style=\"margin-left:0;\">第二帧，当这个键被长按时，GetButton返回true, GetButtonDown, GetButtonUp返回false；</p>\n<p style=\"margin-left:0;\">第三帧，当这个键抬起时，GetButton, GetButtonDown返回false, GetButtonUp返回true。</p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">GetAxis和GetAxisRaw</span></h3>\n<p style=\"margin-left:0;\">这个方法应该主要用在手柄操作控制里，通过Input.GetAxis(\"Horizontal\")和Input.GetAxis(\"Vertical\")来获取手柄在两个方向上的位置，返回值是float型，范围从-1到1.</p>\n<p style=\"margin-left:0;\">这个时候，在项目设置里的input设置里，会有几个属性：Gravity, Sensitivity,Dead, Snap。Gravity控制返回值在指定方向上的归位重量，值越大，回归越快，比如将摇杆移动到最大，返回值为1时，Gavity的值越大，其返回值平滑减少到0的速度就越快；Sensitivity与Gravity刚好相反，它控制的是返回值从0增大到1或减少到-1的快慢，值越大，增加得越快；Dead用来设置一片锁定区，用来防止误触，比如摇杆摇动幅度必须超过0.1才生效，就需要把“原来的”-0.1~0.1之间设置为Dead区，这时实际上位移超过0.1时，才会返回非0值，比如无死区时返回0.05时，有死区时实际上返回0；无死区返回大于0.1时，有死区返回的才是非零值 ，但边界仍然是-1和1。 Snap的作用是如果同时按下了正负按钮时归零，比如用a和d分别表示向左移动和向右移动，但如果同时按下，保持0位不变。</p>\n<p style=\"margin-left:0;\">GetAxisRaw与GetAxis的区别就是它的返回值并不是连续的，而是要么返回0，要么返回-1或1，即有段落，适合控制有基准方格的操作。</p>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">OnMouseDown</span></h3>\n<p style=\"margin-left:0;\">这个是事件函数，类似于OnMove()这种，用于鼠标与环境的交互，当对象被左键点击时，执行方法里的代码。比如可以用来开门，等。</p>\n<p style=\"margin-left:0;\">但是关于鼠标其它按钮的定义，教程里没有介绍。</p>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">GetComponent</span></h3>\n<p style=\"margin-left:0;\">用于获取脚本所在对象的其它组件，比如一个UI对象，可以获得其输入框组件，从而控制文本内容。用法：</p>\n<p style=\"margin-left:0;\">GetComponent&lt;ComponentType&gt;()。如果要通过一个脚本组件获取其它脚本组件，ComponentType就是其它脚本的类名称。</p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Time.deltaTime</span></h3>\n<p style=\"margin-left:0;\">这是一个很有用的数字，通常用在Update方法中。由于Update函数是按帧更新的，但是帧的时间间隔并不固定，这样就会影响对速率的计算，比如要让一个物体运动，要实现每秒前进1单位，在Update方法里只需要 + 1 * Time.deltaTime就可以了。</p>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Instantiate</span></h3>\n<p style=\"margin-left:0;\">实例化一个预制件到游戏世界中。这也是一个很有用的方法，比如要扔一个手雷，就需要动态用这个方法实例化一个手雷对象，并且可以在后续代码中操纵它。使用方法示例：</p>\n<p style=\"margin-left:0;\">GameObject obj = Instantiate(PrefabName, position, rotation)</p>\n<p style=\"margin-left:0;\">obj.AddForce()</p>\n<p style=\"margin-left:0;\">如果实例化的物品是一个消耗品，还需要再次使用Desctroy方法让它在效果结束后消失。</p>\n<p style=\"margin-left:0;\">Instantiate方法经常需要设置一个public的游戏对象或者对象数组，用来告诉脚本生成什么东西。但是要注意一点，通过Inspector设置这些对象或者对象数组时，要注意设置来源是Hierarchy还是Project。如果是Hierarchy，那个这个对象会受舞台限制，如果被引用的对象本身在舞台里被Destroy了，那么将无法Instantiate，会报错，说引用对象为空。如果是从Project里引用，才可以无限Instantiate.</p>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\"></p>\n<h3 style=\"margin-left:0;\"><span style=\"color:#5b9bd5;\">Invoke</span></h3>\n<p style=\"margin-left:0;\">这是一个延时调用，可以在引擎内置的更新帧流水里完成一些自定义的执行。</p>\n<p style=\"margin-left:0;\">Invoke包含两个参数，第一个是必须返回void且没有参数的方法名，字符串类型，第二个参数是以秒计的延时；</p>\n<p style=\"margin-left:0;\">InvokeRepeating与Invoke类似，但是它有三个参数，第三个参数表示在第一次引用后，每多少秒重复进行引用。</p>\n<p style=\"margin-left:0;\">CancelInvoke用于在需要的时候，将InovkeRepeating指定的重复引用取消。</p>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\"></p>\n<p style=\"margin-left:0;\"></p>\n</div>\n</div>\n</div>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-04 22:18:18", "summary": "，还有一个在游戏启动时运行一次，并且是在脚本组件未初始化完成时工作，可以用来做一些预设置；而是与组件相关的，当组件的脚本完成初始化且启用了脚本组件时，工作一次，并且是在第一次执行之前执行。是帧之间的更"}