{"blogid": "126045779", "writerAge": "码龄3年", "writerBlogNum": "123", "writerCollect": "1831", "writerComment": "66", "writerFan": "793", "writerGrade": "5级", "writerIntegral": "2227", "writerName": "渣渣苏", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126045779.jpg", "writerRankTotal": "8516", "writerRankWeekly": "676", "writerThumb": "295", "writerVisitNum": "150556", "blog_read_count": "11066", "blog_time": "于 2022-08-27 22:45:55 发布", "blog_title": "MySQL高级篇", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#MySQL_1\">MySQL高级</a></li><li><ul><li><a href=\"#_LinuxMySQL_3\">一 Linux下MySQL的安装与使用</a></li><li><ul><li><a href=\"#1____5\">1. 安装前说明</a></li><li><a href=\"#2_MySQLLinux_44\">2. MySQL的Linux版安装</a></li><li><a href=\"#3_MySQL_105\">3. MySQL登录</a></li><li><a href=\"#4_Linux_151\">4. Linux下修改配置</a></li><li><a href=\"#5____172\">5. 字符集的相关操作</a></li><li><ul><li><a href=\"#51_174\">5.1、各级别的字符集</a></li><li><a href=\"#52_192\">5.2、请求到响应过程中字符集的变化</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_MySQL_205\">二 MySQL的数据目录</a></li><li><a href=\"#__264\">三 用户与权限管理</a></li><li><a href=\"#_438\">四、逻辑架构</a></li><li><ul><li><a href=\"#41_440\">4.1、逻辑架构剖析</a></li><li><ul><li><a href=\"#411_442\">4.1.1、服务器处理客户端请求</a></li><li><a href=\"#412Connectors_454\">4.1.2、Connectors</a></li><li><a href=\"#4131_456\">4.1.3、第1层：连接层</a></li><li><a href=\"#4142_467\">4.1.4、第2层：服务层</a></li><li><a href=\"#4153_498\">4.1.5、第3层：引擎层</a></li><li><a href=\"#416_502\">4.1.6、存储层</a></li><li><a href=\"#417_506\">4.1.7、小结</a></li></ul>\n</li><li><a href=\"#42SQL_518\">4.2、SQL执行流程</a></li><li><ul><li><a href=\"#421MySQL__SQL_520\">4.2.1、MySQL 中的 SQL执行流程</a></li><li><a href=\"#422MySQL8SQL_676\">4.2.2、MySQL8中SQL执行原理</a></li><li><a href=\"#423MySQL57SQL_748\">4.2.3、MySQL5.7中SQL执行原理</a></li><li><a href=\"#424SQL_805\">4.2.4、SQL语法顺序</a></li><li><a href=\"#425OracleSQL_815\">4.2.5、Oracle中的SQL执行流程(了解)</a></li></ul>\n</li><li><a href=\"#43buffer_pool_872\">4.3、数据库缓冲池(buffer pool)</a></li><li><ul><li><a href=\"#431vs_878\">4.3.1、缓冲池vs查询缓存</a></li><li><a href=\"#432_908\">4.3.2、缓冲池如何读取数据</a></li><li><a href=\"#433_916\">4.3.3、查看/设置缓冲池的大小</a></li><li><a href=\"#434Buffer_Pool_939\">4.3.4、多个Buffer Pool实例</a></li><li><a href=\"#435_965\">4.3.5、引申问题</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_983\">五、存储引擎</a></li><li><ul><li><a href=\"#51_989\">5.1、查看存储引擎</a></li><li><a href=\"#52_1009\">5.2、设置系统默认的存储引擎</a></li><li><a href=\"#53_1042\">5.3、设置表的存储引擎</a></li><li><a href=\"#54_1060\">5.4、引擎介绍</a></li><li><ul><li><a href=\"#541InnoDB__1062\">5.4.1、InnoDB 引擎：具备外键支持功能的事务存储引擎</a></li><li><a href=\"#542MyISAM_1076\">5.4.2、MyISAM引擎：主要的非事务处理存储引擎</a></li><li><a href=\"#543Archive___1088\">5.4.3、Archive 引擎：用于数据存档</a></li><li><a href=\"#544Blackhole___1119\">5.4.4、Blackhole 引擎：丢弃写操作，读操作会返回空内容</a></li><li><a href=\"#545CSV__1124\">5.4.5、CSV 引擎：存储数据时，以逗号分隔各个数据项</a></li><li><a href=\"#546Memory___1164\">5.4.6、Memory 引擎：置于内存的表</a></li><li><a href=\"#547Federated___1187\">5.4.7、Federated 引擎：访问远程表</a></li><li><a href=\"#548MergeMyISAM_1191\">5.4.8、Merge引擎：管理多个MyISAM表构成的表集合</a></li><li><a href=\"#549NDBMySQL_1193\">5.4.9、NDB引擎：MySQL集群专用存储引擎</a></li></ul>\n</li><li><a href=\"#55MyISAMInnoDB_1197\">5.5、MyISAM和InnoDB</a></li></ul>\n</li><li><a href=\"#_1220\">六、索引的数据结构</a></li><li><ul><li><a href=\"#61_1222\">6.1、为什么使用索引</a></li><li><a href=\"#62_1238\">6.2、索引及其优缺点</a></li><li><ul><li><a href=\"#621__1240\">6.2.1 、索引概述</a></li><li><a href=\"#622_1248\">6.2.2、优点</a></li><li><a href=\"#623_1255\">6.2.3、缺点</a></li></ul>\n</li><li><a href=\"#63InnoDB_1263\">6.3、InnoDB中索引的推演</a></li><li><ul><li><a href=\"#631_1265\">6.3.1、索引之前的查找</a></li><li><a href=\"#632_1289\">6.3.2、设计索引</a></li><li><ul><li><a href=\"#6321_1318\">6.3.2.1、一个简单的索引设计方案</a></li><li><a href=\"#6322InnoDB_1375\">6.3.2.2、InnoDB中的索引方案</a></li></ul>\n</li><li><a href=\"#633_1458\">6.3.3、常见索引概念</a></li><li><a href=\"#634InnoDBB_1571\">6.3.4、InnoDB的B+树索引的注意事项</a></li></ul>\n</li><li><a href=\"#64MyISAM_1616\">6.4、MyISAM中的索引方案</a></li><li><ul><li><a href=\"#641MyISAM_1628\">6.4.1、MyISAM索引的原理</a></li><li><a href=\"#642MyISAM_InnoDB_1643\">6.4.2、MyISAM与 InnoDB对比</a></li></ul>\n</li><li><a href=\"#65_1666\">6.5、索引的代价</a></li><li><a href=\"#66MySQL_1678\">6.6、MySQL数据结构选择的合理性</a></li><li><ul><li><a href=\"#661_1686\">6.6.1、全表遍历</a></li><li><a href=\"#662Hash_1688\">6.6.2、Hash结构</a></li><li><a href=\"#663_1740\">6.6.3、二叉搜索树</a></li><li><a href=\"#664AVL_1766\">6.6.4、AVL树</a></li><li><a href=\"#665BTree_1785\">6.6.5、B-Tree</a></li><li><a href=\"#666BTree_1830\">6.6.6、B+Tree</a></li><li><a href=\"#667R_1883\">6.6.7、R树</a></li><li><a href=\"#668_1885\">6.6.8、小结</a></li></ul>\n</li></ul>\n</li><li><a href=\"#InnoDB_1893\">七、InnoDB数据存储结构</a></li><li><ul><li><a href=\"#71_1895\">7.1、数据库的存储结构：页</a></li><li><ul><li><a href=\"#711_1901\">7.1.1、磁盘与内存交互基本单位：页</a></li><li><a href=\"#712_1911\">7.1.2、页结构概述</a></li><li><a href=\"#713_1915\">7.1.3、页的大小</a></li><li><a href=\"#714_1924\">7.1.4、页的上层结构</a></li></ul>\n</li><li><a href=\"#72_1934\">7.2、页的内部结构</a></li><li><ul><li><a href=\"#7211_1946\">7.2.1、第1部分：文件头部和文件尾部</a></li><li><ul><li><a href=\"#7211File_Header_1948\">7.2.1.1、File Header(文件头)</a></li><li><a href=\"#7212File_Trailer_1998\">7.2.1.2、File Trailer（文件尾部）</a></li></ul>\n</li><li><a href=\"#7222_2003\">7.2.2、第2部分：空闲空间、用户记录和最小最大记录</a></li><li><ul><li><a href=\"#7221Free_Space__2007\">7.2.2.1、Free Space (空闲空间)</a></li><li><a href=\"#7222User_Records__2013\">7.2.2.2、User Records (用户记录)</a></li><li><a href=\"#7223Infimum__Supremum_2019\">7.2.2.3、Infimum + Supremum（最小最大记录）</a></li></ul>\n</li><li><a href=\"#7233_2033\">7.2.3、第3部分：页目录和页面头部</a></li><li><ul><li><a href=\"#7231Page_Directory_2035\">7.2.3.1、Page Directory（页目录）</a></li><li><a href=\"#7232Page_Header_2108\">7.2.3.2、Page Header（页面头部）</a></li><li><a href=\"#B_2133\">从数据页的角度看B+树如何查询</a></li></ul>\n</li></ul>\n</li><li><a href=\"#73InnoDB_2154\">7.3、InnoDB行格式（或记录格式）</a></li><li><ul><li><a href=\"#731_2166\">7.3.1、指定行格式的语法</a></li><li><a href=\"#732COMPACT_2185\">7.3.2、COMPACT行格式</a></li><li><ul><li><a href=\"#7321_2191\">7.3.2.1、变长字段长度列表</a></li><li><a href=\"#7322NULL_2207\">7.3.2.2、NULL值列表</a></li><li><a href=\"#73235_2226\">7.3.2.3、记录头信息（5字节）</a></li><li><a href=\"#7324_2295\">7.3.2.4、记录的真实数据</a></li></ul>\n</li><li><a href=\"#733DynamicCompressed_2307\">7.3.3、Dynamic和Compressed行格式</a></li><li><ul><li><a href=\"#_2309\">行溢出</a></li></ul>\n</li><li><a href=\"#734Redundant_2352\">7.3.4、Redundant行格式</a></li></ul>\n</li><li><a href=\"#74_2406\">7.4、区、段和碎片区</a></li><li><ul><li><a href=\"#741_2408\">7.4.1、为什么要有区？</a></li><li><a href=\"#742_2414\">7.4.2、为什么要有段？</a></li><li><a href=\"#743_2424\">7.4.3、为什么要有碎片区？</a></li><li><a href=\"#744_2437\">7.4.4、区的分类</a></li></ul>\n</li><li><a href=\"#75_2450\">7.5、表空间</a></li><li><ul><li><a href=\"#751_2456\">7.5.1、独立表空间</a></li><li><a href=\"#752_2477\">7.5.2、系统表空间</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_2520\">八、索引的创建与设计原则</a></li><li><ul><li><a href=\"#81_2522\">8.1、索引的声明与使用</a></li><li><ul><li><a href=\"#811_2524\">8.1.1、索引的分类</a></li><li><a href=\"#812_2578\">8.1.2、创建索引</a></li><li><ul><li><a href=\"#1__2582\">1. 创建表的时候创建索引</a></li><li><a href=\"#2__2709\">2. 在已经存在的表上创建索引</a></li></ul>\n</li><li><a href=\"#8_13_2725\">8. 1.3、删除索引</a></li></ul>\n</li><li><a href=\"#82MySQL80_2743\">8.2、MySQL8.0索引新特性</a></li><li><ul><li><a href=\"#821_2745\">8.2.1、支持降序索引</a></li><li><a href=\"#822_2819\">8.2.2、隐藏索引</a></li></ul>\n</li><li><a href=\"#83_2899\">8.3、索引的设计原则</a></li><li><ul><li><a href=\"#831_2903\">8.3.1、哪些情况适合创建索引</a></li><li><a href=\"#832_2983\">8.3.2、限制索引的数目</a></li><li><a href=\"#833_2991\">8.3.3、哪些情况不适合创建索引</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_3006\">九、性能分析工具的使用</a></li><li><ul><li><a href=\"#91_3008\">9.1、数据库服务器的优化步骤</a></li><li><a href=\"#92_3037\">9.2、查看系统性能参数</a></li><li><a href=\"#93SQLlast_query_cost_3061\">9.3、统计SQL的查询成本：last_query_cost</a></li><li><a href=\"#94SQL_3076\">9.4、定位执行慢的SQL：慢查询日志</a></li><li><ul><li><a href=\"#941_3082\">9.4.1、开启慢查询日志参数</a></li><li><a href=\"#942_3111\">9.4.2、查看慢查询数目</a></li><li><a href=\"#943mysqldumpslow_3133\">9.4.3、慢查询日志分析工具：mysqldumpslow</a></li><li><a href=\"#944_3155\">9.4.4、关闭慢查询日志</a></li><li><a href=\"#945_3180\">9.4.5、删除慢查询日志</a></li></ul>\n</li><li><a href=\"#95SQLSHOW_PROFILE_3202\">9.5、查看SQL执行成本：SHOW PROFILE</a></li><li><a href=\"#96EXPLAIN_3245\">9.6、分析查询语句：EXPLAIN</a></li><li><ul><li><a href=\"#961_3259\">9.6.1、基本语法</a></li><li><a href=\"#962EXPLAIN_3284\">9.6.2、EXPLAIN各列作用</a></li></ul>\n</li><li><a href=\"#97EXPLAIN_3391\">9.7、EXPLAIN的进一步使用</a></li><li><ul><li><a href=\"#971EXPLAIN_3393\">9.7.1、EXPLAIN四种输出格式</a></li><li><a href=\"#972SHOW_WARNINGS_3411\">9.7.2、SHOW WARNINGS的使用</a></li></ul>\n</li><li><a href=\"#98trace_3419\">9.8、分析优化器执行计划：trace</a></li><li><a href=\"#99MySQLsys_schema_3431\">9.9、MySQL监控分析视图-sys schema</a></li></ul>\n</li><li><a href=\"#10__3488\">第10章 索引优化与查询优化</a></li><li><ul><li><a href=\"#1____3490\">1. 索引失效案例</a></li><li><ul><li><a href=\"#11_3501\">1.1、全值匹配我最爱</a></li><li><a href=\"#12_3503\">1.2、最佳左前缀法则</a></li><li><a href=\"#13_3509\">1.3、主键插入顺序</a></li><li><a href=\"#14_3513\">1.4、计算、函数、类型转换(自动或手动)导致索引失效</a></li><li><a href=\"#15_3515\">1.5、类型转换导致索引失效</a></li><li><a href=\"#16_3517\">1.6、范围条件右边的列索引失效</a></li><li><a href=\"#17__3521\">1.7、不等于(!= 或者&lt;&gt;)索引失效</a></li><li><a href=\"#18_is_nullis_not_null_3523\">1.8 is null可以使用索引，is not null无法使用索引</a></li><li><a href=\"#19_like_3529\">1.9 like以通配符%开头索引失效</a></li><li><a href=\"#110_OR_3535\">1.10 OR、前后存在非索引的列，索引失效</a></li><li><a href=\"#111utf8mb4_3539\">1.11、数据库和表的字符集统一使用utf8mb4**</a></li></ul>\n</li><li><a href=\"#2____3543\">2. 关联查询优化</a></li><li><ul><li><a href=\"#21_Index_NestedLoop_Join_3551\">2.1 Index Nested-Loop Join（索引嵌套循环连接）</a></li><li><a href=\"#22_Block_NestedLoop_Join_3557\">2.2 Block Nested-Loop Join（块嵌套循环连接）</a></li><li><a href=\"#23_Hash_Join_3565\">2.3 Hash Join</a></li></ul>\n</li><li><a href=\"#3____3575\">3. 子查询优化</a></li><li><a href=\"#4____3589\">4. 排序优化</a></li><li><a href=\"#5_GROUP_BY_3597\">5. GROUP BY优化</a></li><li><a href=\"#6____3606\">6. 优化分页查询</a></li><li><a href=\"#7____3625\">7. 优先考虑覆盖索引</a></li><li><ul><li><a href=\"#71_3627\">7.1、什么是覆盖索引？</a></li><li><a href=\"#72_3635\">7.2、覆盖索引的利弊</a></li></ul>\n</li><li><a href=\"#8____3647\">8. 索引条件下推</a></li><li><ul><li><a href=\"#81_3649\">8.1、使用前后的扫描过程</a></li></ul>\n</li><li><a href=\"#9____3663\">9. 其它查询优化策略</a></li><li><ul><li><a href=\"#91_EXISTS__IN_3665\">9.1 EXISTS、和 **IN、的区分</a></li><li><a href=\"#92_COUNTCOUNT_3669\">9.2 COUNT(\\*)与COUNT(具体字段)效率</a></li><li><a href=\"#93SELECT_3681\">9.3、关于SELECT(\\*)</a></li><li><a href=\"#94_LIMIT_1_3689\">9.4 LIMIT 1、对优化的影响</a></li><li><a href=\"#95COMMIT_3695\">9.5、多使用COMMIT**</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_3709\"></a></li><li><a href=\"#11__3711\">第11章 数据库的设计规范</a></li><li><ul><li><a href=\"#1_____3713\">1. 范 式</a></li><li><ul><li><a href=\"#11_3715\">1.1、范式简介</a></li><li><a href=\"#12_3719\">1.2、范式都包括哪些</a></li><li><a href=\"#13_3725\">1.3、键和相关属性的概念</a></li><li><a href=\"#141st_NF_3739\">1.4、第一范式(1st NF)</a></li><li><a href=\"#152nd_NF_3743\">1.5、第二范式(2nd NF)</a></li><li><a href=\"#163rd_NF_3747\">1.6、第三范式(3rd NF)</a></li><li><a href=\"#17__3751\">1.7 小结</a></li></ul>\n</li><li><a href=\"#2____3771\">2. 反范式化</a></li><li><ul><li><a href=\"#21_3773\">2.1、概述</a></li><li><a href=\"#22_3785\">2.2、反范式的新问题</a></li><li><a href=\"#23_3792\">2.3、反范式的适用场景</a></li></ul>\n</li><li><a href=\"#3_BCNF_3808\">3. BCNF(巴斯范式)</a></li><li><a href=\"#4_ER_3814\">4. ER模型</a></li><li><ul><li><a href=\"#41_ER__3818\">4.1 ER 模型包括那些要素？</a></li><li><a href=\"#42_3830\">4.2、关系的类型</a></li></ul>\n</li><li><a href=\"#5____3840\">5. 数据表的设计原则</a></li><li><a href=\"#6____3854\">6. 数据库对象编写建议</a></li><li><ul><li><a href=\"#61_3856\">6.1、关于库</a></li><li><a href=\"#62_3872\">6.2、关于表、列</a></li><li><a href=\"#63_3930\">6.3、关于索引</a></li><li><a href=\"#64_SQL_3948\">6.4 SQL编写</a></li></ul>\n</li></ul>\n</li><li><a href=\"#12__3974\">第12章 数据库其它调优策略</a></li><li><ul><li><a href=\"#1____3976\">1. 数据库调优的措施</a></li><li><ul><li><a href=\"#11_3978\">1.1、调优的目标</a></li><li><a href=\"#12_3984\">1.2、如何定位调优问题</a></li><li><a href=\"#13_3992\">1.3、调优的维度和步骤</a></li></ul>\n</li><li><a href=\"#2___MySQL_4016\">2. 优化MySQL服务器</a></li><li><ul><li><a href=\"#21_4018\">2.1、优化服务器硬件</a></li><li><a href=\"#22MySQL_4030\">2.2、优化MySQL的参数</a></li></ul>\n</li><li><a href=\"#3____4053\">3. 优化数据库结构</a></li><li><ul><li><a href=\"#31_4055\">3.1、拆分表：冷热数据分离</a></li><li><a href=\"#32_4057\">3.2、增加中间表</a></li><li><a href=\"#33_4059\">3.3、增加冗余字段</a></li><li><a href=\"#34_4061\">3.4、优化数据类型</a></li><li><a href=\"#35_4083\">3.5、优化插入记录的速度</a></li><li><a href=\"#36_4103\">3.6、使用非空约束</a></li><li><a href=\"#37_4107\">3.7、分析表、检查表与优化表</a></li></ul>\n</li></ul>\n</li><li><a href=\"#13__4141\">第13章 事务基础知识</a></li><li><ul><li><a href=\"#1____4143\">1. 数据库事务概述</a></li><li><ul><li><a href=\"#11_4145\">1.1、基本概念</a></li><li><a href=\"#12ACID_4151\">1.2、事务的ACID特性</a></li><li><a href=\"#13_4171\">1.3、事务的状态</a></li></ul>\n</li><li><a href=\"#2____4195\">2. 如何使用事务</a></li><li><ul><li><a href=\"#21_4197\">2.1、显式事务</a></li><li><a href=\"#22_4244\">2.2、隐式事务</a></li><li><a href=\"#23_4249\">2.3、隐式提交数据的情况</a></li></ul>\n</li><li><a href=\"#3____4259\">3. 事务隔离级别</a></li><li><ul><li><a href=\"#31_4261\">3.1、数据并发问题</a></li><li><a href=\"#32_SQL_4295\">3.2 SQL中的四种隔离级别</a></li><li><a href=\"#33_4306\">3.3、如何设置事务的隔离级别</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_4328\"></a></li><li><a href=\"#14_MySQL_4332\">第14章 MySQL事务日志</a></li><li><ul><li><a href=\"#1_redo_4341\">1. redo日志</a></li><li><ul><li><a href=\"#11REDO_4343\">1.1、为什么需要REDO日志</a></li><li><a href=\"#12_REDO_4353\">1.2 REDO日志的好处、特点</a></li><li><a href=\"#13_redo_4365\">1.3 redo的组成</a></li><li><a href=\"#14_redo_4377\">1.4 redo的整体流程</a></li><li><a href=\"#15_redo_log_4391\">1.5 redo log的刷盘策略</a></li><li><a href=\"#16_4401\">1.6、不同刷盘策略演示</a></li><li><a href=\"#17redo_log_buffer_4411\">1.7、写入redo log buffer过程</a></li><li><a href=\"#18_redo_log_file_4425\">1.8 redo log file**</a></li></ul>\n</li><li><a href=\"#2_Undo_4445\">2. Undo日志</a></li><li><ul><li><a href=\"#21Undo_4449\">2.1、如何理解Undo日志</a></li><li><a href=\"#22_Undo_4458\">2.2 Undo日志的作用</a></li><li><a href=\"#23_undo_4463\">2.3 undo的存储结构</a></li><li><a href=\"#24_undo_4491\">2.4 undo的类型</a></li><li><a href=\"#25_undo_log_4498\">2.5 undo log的生命周期</a></li><li><a href=\"#26_4555\">2.6、小结</a></li></ul>\n</li></ul>\n</li><li><a href=\"#15__4565\">第15章 锁</a></li><li><ul><li><a href=\"#1____4567\">1. 概述</a></li><li><a href=\"#2_MySQL_4571\">2. MySQL并发事务访问相同记录</a></li><li><ul><li><a href=\"#21_4573\">2.1、读-读情况</a></li><li><a href=\"#22_4577\">2.2、写-写情况</a></li><li><a href=\"#23_4583\">2.3、读-写或写-读情况</a></li><li><a href=\"#24_4587\">2.4、并发问题的解决方案</a></li></ul>\n</li><li><a href=\"#3____4608\">3. 锁的不同角度分类</a></li><li><ul><li><a href=\"#31_4612\">3.1、从数据操作的类型划分：读锁、写锁</a></li><li><a href=\"#32_4653\">3.2、从数据操作的粒度划分：表级锁、页级锁、行锁</a></li><li><a href=\"#33_4802\">3.3、从对待锁的态度划分:乐观锁、悲观锁</a></li><li><a href=\"#34_4834\">3.4、按加锁的方式划分：显式锁、隐式锁</a></li><li><a href=\"#35_4848\">3.5、其它锁之：全局锁</a></li><li><a href=\"#36_4858\">3.6、其它锁之：死锁</a></li></ul>\n</li><li><a href=\"#4____4872\">4. 锁的内存结构</a></li><li><a href=\"#5____4934\">5. 锁监控</a></li></ul>\n</li><li><a href=\"#16__4958\">第16章 多版本并发控制</a></li><li><ul><li><a href=\"#1___MVCC_4960\">1. 什么是MVCC**</a></li><li><a href=\"#2____4964\">2. 快照读与当前读</a></li><li><ul><li><a href=\"#21_4968\">2.1、快照读</a></li><li><a href=\"#22_4978\">2.2、当前读</a></li></ul>\n</li><li><a href=\"#3____4982\">3. 复习</a></li><li><ul><li><a href=\"#31_4984\">3.1、再谈隔离级别</a></li><li><a href=\"#32Undo_Log_4994\">3.2、隐藏字段、Undo Log版本链</a></li></ul>\n</li><li><a href=\"#4_MVCCReadView_5001\">4. MVCC实现原理之ReadView**</a></li><li><ul><li><a href=\"#41ReadView_5005\">4.1、什么是ReadView**</a></li><li><a href=\"#42_5009\">4.2、设计思路</a></li><li><a href=\"#43_ReadView_5031\">4.3 ReadView的规则</a></li><li><a href=\"#44_MVCC_5042\">4.4 MVCC整体操作流程</a></li></ul>\n</li><li><a href=\"#5____5068\">5. 举例说明</a></li><li><ul><li><a href=\"#51_READ_COMMITTED_5070\">5.1 READ COMMITTED隔离级别下</a></li><li><a href=\"#52_REPEATABLE_READ_5074\">5.2 REPEATABLE READ隔离级别下</a></li><li><a href=\"#53_5078\">5.3、如何解决幻读</a></li></ul>\n</li><li><a href=\"#6____5121\">6. 总结</a></li></ul>\n</li><li><a href=\"#17__5132\">第17章 其它数据库日志</a></li><li><ul><li><a href=\"#1_MySQL_5134\">1. MySQL支持的日志</a></li><li><ul><li><a href=\"#11_5136\">1.1、日志类型</a></li><li><a href=\"#12_5154\">1.2、日志的弊端</a></li></ul>\n</li><li><a href=\"#2___general_query_log_5160\">2. 通用查询日志(general query log)</a></li><li><ul><li><a href=\"#21_5164\">2.1、查看当前状态</a></li><li><a href=\"#22_5170\">2.2、启动日志</a></li><li><a href=\"#23_5189\">2.3、停止日志</a></li></ul>\n</li><li><a href=\"#3error_log_5205\">3.错误日志(error log)</a></li><li><ul><li><a href=\"#31_5207\">3.1、启动日志</a></li><li><a href=\"#32_5216\">3.2、查看日志</a></li><li><a href=\"#33_5222\">3.3、删除\\刷新日志</a></li></ul>\n</li><li><a href=\"#4___bin_log_5229\">4. 二进制日志(bin log)</a></li><li><ul><li><a href=\"#41_5231\">4.1、查看默认情况</a></li><li><a href=\"#42_5237\">4.2、日志参数设置</a></li><li><a href=\"#43_5273\">4.3、查看日志</a></li><li><a href=\"#44_5307\">4.4、使用日志恢复数据</a></li><li><a href=\"#45_5322\">4.5、删除二进制日志</a></li></ul>\n</li><li><a href=\"#5___binlog_5331\">5. 再谈二进制日志(binlog)</a></li><li><ul><li><a href=\"#51_5333\">5.1、写入机制</a></li><li><a href=\"#52_binlogredolog_5349\">5.2 binlog与redolog对比</a></li><li><a href=\"#53_5357\">5.3、两阶段提交</a></li></ul>\n</li><li><a href=\"#6___relay_log_5375\">6. 中继日志(relay log)</a></li><li><ul><li><a href=\"#61_5377\">6.1、介绍</a></li><li><a href=\"#62_5381\">6.2、恢复的典型错误</a></li></ul>\n</li></ul>\n</li><li><a href=\"#18__5391\">第18章 主从复制</a></li><li><ul><li><a href=\"#1____5393\">1. 主从复制概述</a></li><li><ul><li><a href=\"#11_5395\">1.1、如何提升数据库并发能力</a></li><li><a href=\"#12_5401\">1.2、主从复制的作用</a></li></ul>\n</li><li><a href=\"#2____5409\">2. 主从复制的原理</a></li><li><ul><li><a href=\"#21_5411\">2.1、原理剖析</a></li><li><a href=\"#22_5439\">2.2、复制的基本原则</a></li></ul>\n</li><li><a href=\"#3____5447\">3. 同步数据一致性问题</a></li><li><ul><li><a href=\"#31_5457\">3.1、理解主从延迟问题</a></li><li><a href=\"#32_5461\">3.2、主从延迟问题原因</a></li><li><a href=\"#33_5473\">3.3、如何减少主从延迟</a></li><li><a href=\"#34_5487\">3.4、如何解决一致性问题</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_5505\"></a></li><li><a href=\"#19__5509\">第19章 数据库备份与恢复</a></li><li><ul><li><a href=\"#1____5511\">1. 物理备份与逻辑备份</a></li><li><a href=\"#2_mysqldump_5517\">2. mysqldump实现逻辑备份</a></li><li><ul><li><a href=\"#21_5519\">2.1、备份一个数据库</a></li><li><a href=\"#22_5530\">2.2、备份全部数据库</a></li><li><a href=\"#23_5537\">2.3、备份部分数据库</a></li><li><a href=\"#24_5548\">2.4、备份部分表</a></li><li><a href=\"#25_5560\">2.5、备份单表的部分数据</a></li><li><a href=\"#26_5566\">2.6、排除某些表的备份</a></li><li><a href=\"#27_5572\">2.7、只备份结构或只备份数据</a></li><li><a href=\"#28_5586\">2.8、备份中包含存储过程、函数、事件</a></li></ul>\n</li><li><a href=\"#3_mysql_5592\">3. mysql命令恢复数据</a></li><li><ul><li><a href=\"#31_5598\">3.1、单库备份中恢复单库</a></li><li><a href=\"#32_5607\">3.2、全量备份恢复</a></li><li><a href=\"#33_5613\">3.3、从全量备份中恢复单库</a></li><li><a href=\"#34_5620\">3.4、从单库备份中恢复单表</a></li></ul>\n</li><li><a href=\"#4____5635\">4. 表的导出与导入</a></li><li><ul><li><a href=\"#41_5637\">4.1、表的导出</a></li><li><a href=\"#42_5660\">4.2、表的导入</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"MySQL_1\"></a>MySQL高级</h1>\n<h2><a id=\"_LinuxMySQL_3\"></a>一 Linux下MySQL的安装与使用</h2>\n<h3><a id=\"1____5\"></a>1. 安装前说明</h3>\n<pre><code class=\"prism language-markdown\">####  1.1查看是否安装过MySQL\n\n- 如果你是用rpm安装, 检查一下RPM PACKAGE：\nrpm -qa | grep -i mysql # -i 忽略大小写\n\n- 检查mysql service：\nsystemctl status mysqld.service\n\n#### 1.2MySQL的卸载 \n\n1. 关闭mysql服务 \nsystemctl stop mysqld.service\n\n2. 查看当前  mysql安装状况 \nrpm -qa | grep -i mysql\n# 或\nyum list installed | grep mysql\n\n3. 卸载上述命令查询出的已安装程序 \nyum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx\n\n务必卸载干净，反复执行`rpm -qa | grep -i mysql 确认是否有卸载残留\n\n4. 删除mysql相关文件 \n\n- 查找相关文件\nfind / -name mysql\n\n- 删除上述命令查找出的相关文件\nrm -rf xxx\n\n5. 删除 my.cnf**\n\nrm -rf /etc/my.cnf\n</code></pre>\n<h3><a id=\"2_MySQLLinux_44\"></a>2. MySQL的Linux版安装</h3>\n<pre><code class=\"prism language-markdown\">####  2.1 CentOS7下检查MySQL依赖  \n1. 检查/tmp临时目录权限（必不可少） \n由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限。执行 ：\nchmod -R 777 /tmp\n\n2. 安装前，检查依赖 \nrpm -qa|grep libaio\nrpm -qa|grep net-tools\n\n####  2.2 CentOS7下MySQL安装过程  \n1. 将安装程序拷贝到/opt目录下 \n在mysql的安装文件目录下执行：（必须按照顺序执行）\nrpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm \nrpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm \nrpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm \nrpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm \nrpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm\n\n- `rpm`是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。\n- `-i`, --install 安装软件包\n- `-v`, --verbose 提供更多的详细信息输出\n- `-h`, --hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条\n\n&gt; 若存在mariadb-libs问题，则执行**yum remove mysql-libs**即可\n\n####  2.3、查看MySQL版本 \nmysql --version \n#或\nmysqladmin --version\n\n####  2.4、服务的初始化 \n为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化：\nmysqld --initialize --user=mysql\n\n说明： --initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将`该密码标记为过期`，登录后你需要设置一个新的密码。生成的`临时密码`会往日志中记录一份。\n\n查看密码：\ncat /var/log/mysqld.log\n\nroot@localhost: 后面就是初始化的密码\n\n####  2.5、启动MySQL，查看状态  \n#加不加.service后缀都可以 \n启动：systemctl start mysqld.service \n关闭：systemctl stop mysqld.service \n重启：systemctl restart mysqld.service \n查看状态：systemctl status mysqld.service\n\n####  2.6、查看MySQL服务是否自启动 \nsystemctl list-unit-files|grep mysqld.service\n\n- 如不是enabled可以运行如下命令设置自启动\nsystemctl enable mysqld.service\n\n- 如果希望不进行自启动，运行如下命令设置\nsystemctl disable mysqld.service\n</code></pre>\n<h3><a id=\"3_MySQL_105\"></a>3. MySQL登录</h3>\n<pre><code class=\"prism language-markdown\">####  3.1、首次登录 \n通过`mysql -hlocalhost -P3306 -uroot -p`进行登录，在Enter password：录入初始化密码\n\n####  3.2、修改密码 \nALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password';\n\n####  3.3、设置远程登录 \n1.确认网络  \n\t1.在远程机器上使用ping ip地址`保证网络畅通`\n\t2.在远程机器上使用telnet命令`保证端口号开放`访问\n\n2. 关闭防火墙或开放端口 \n\n方式一：关闭防火墙 \n\n- CentOS6 ：\nservice iptables stop\n\n- CentOS7：\n#开启防火墙\nsystemctl start firewalld.service\n#查看防火墙状态\nsystemctl status firewalld.service\n#关闭防火墙\nsystemctl stop firewalld.service\n#设置开机启用防火墙 \nsystemctl enable firewalld.service \n#设置开机禁用防火墙 \nsystemctl disable firewalld.service\n\n方式二：开放端口 \n\n- 查看开放的端口号\nfirewall-cmd --list-all\n\n- 设置开放的端口号\nfirewall-cmd --add-service=http --permanent\nfirewall-cmd --add-port=3306/tcp --permanent\n\n- 重启防火墙\nfirewall-cmd --reload\n</code></pre>\n<h3><a id=\"4_Linux_151\"></a>4. Linux下修改配置</h3>\n<pre><code class=\"prism language-markdown\"># 修改允许远程登陆\nuse mysql;\nselect Host,User from user;\nupdate user set host = '%' where user ='root';\nflush privileges;\n\n&gt; `%`是个 通配符 ，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果`Host=%`，表示所有IP都有连接权限。\n&gt;\n&gt; 注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。\n\n配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。\n\n解决方法一： 升级远程连接工具版本\n\n解决方法二： \nALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'abc123';\n</code></pre>\n<h3><a id=\"5____172\"></a>5. 字符集的相关操作</h3>\n<h4><a id=\"51_174\"></a>5.1、各级别的字符集</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'character%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul>\n<p>小结</p>\n<ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul>\n<h4><a id=\"52_192\"></a>5.2、请求到响应过程中字符集的变化</h4>\n<div class=\"mermaid sequence-diagram\">\n<svg height=\"402\" id=\"mermaid-svg-efHXdnTrKYjT25S2\" style=\"max-width: 625.109375px;\" viewbox=\"0 0 625.109375 402\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\">\n<style>#mermaid-svg-efHXdnTrKYjT25S2 {font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-efHXdnTrKYjT25S2 .error-icon{fill:#552222;}#mermaid-svg-efHXdnTrKYjT25S2 .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-efHXdnTrKYjT25S2 .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-efHXdnTrKYjT25S2 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-efHXdnTrKYjT25S2 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-efHXdnTrKYjT25S2 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-efHXdnTrKYjT25S2 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-efHXdnTrKYjT25S2 .marker{fill:#333333;stroke:#333333;}#mermaid-svg-efHXdnTrKYjT25S2 .marker.cross{stroke:#333333;}#mermaid-svg-efHXdnTrKYjT25S2 svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-efHXdnTrKYjT25S2 .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-svg-efHXdnTrKYjT25S2 .cluster-label text{fill:#333;}#mermaid-svg-efHXdnTrKYjT25S2 .cluster-label span{color:#333;}#mermaid-svg-efHXdnTrKYjT25S2 .label text,#mermaid-svg-efHXdnTrKYjT25S2 span{fill:#333;color:#333;}#mermaid-svg-efHXdnTrKYjT25S2 .node rect,#mermaid-svg-efHXdnTrKYjT25S2 .node circle,#mermaid-svg-efHXdnTrKYjT25S2 .node ellipse,#mermaid-svg-efHXdnTrKYjT25S2 .node polygon,#mermaid-svg-efHXdnTrKYjT25S2 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-efHXdnTrKYjT25S2 .node .label{text-align:center;}#mermaid-svg-efHXdnTrKYjT25S2 .node.clickable{cursor:pointer;}#mermaid-svg-efHXdnTrKYjT25S2 .arrowheadPath{fill:#333333;}#mermaid-svg-efHXdnTrKYjT25S2 .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-efHXdnTrKYjT25S2 .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-efHXdnTrKYjT25S2 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-efHXdnTrKYjT25S2 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-efHXdnTrKYjT25S2 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-efHXdnTrKYjT25S2 .cluster text{fill:#333;}#mermaid-svg-efHXdnTrKYjT25S2 .cluster span{color:#333;}#mermaid-svg-efHXdnTrKYjT25S2 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-efHXdnTrKYjT25S2 :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}</style>\n<g>\n<g class=\"output\">\n<g class=\"clusters\"></g>\n<g class=\"edgePaths\">\n<g class=\"edgePath LS-A LE-B\" id=\"L-A-B\" style=\"opacity: 1;\">\n<path class=\"path\" d=\"M314.08203125,47.58837129377949L298.9108072916667,54.990309411482905C283.7395833333333,62.39224752918633,253.39713541666666,77.19612376459317,238.22591145833334,90.9313952156299C223.0546875,104.66666666666667,223.0546875,117.33333333333333,223.0546875,123.66666666666667L223.0546875,130\" marker-end=\"url(#arrowhead137)\" style=\"fill:none\"></path>\n<defs>\n<marker id=\"arrowhead137\" markerheight=\"6\" markerunits=\"strokeWidth\" markerwidth=\"8\" orient=\"auto\" refx=\"9\" refy=\"5\" viewbox=\"0 0 10 10\">\n<path class=\"arrowheadPath\" d=\"M 0 0 L 10 5 L 0 10 z\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></path>\n</marker>\n</defs>\n</g>\n<g class=\"edgePath LS-B LE-C\" id=\"L-B-C\" style=\"opacity: 1;\">\n<path class=\"path\" d=\"M223.0546875,176L223.0546875,182.33333333333334C223.0546875,188.66666666666666,223.0546875,201.33333333333334,223.0546875,214C223.0546875,226.66666666666666,223.0546875,239.33333333333334,223.0546875,245.66666666666666L223.0546875,252\" marker-end=\"url(#arrowhead138)\" style=\"fill:none\"></path>\n<defs>\n<marker id=\"arrowhead138\" markerheight=\"6\" markerunits=\"strokeWidth\" markerwidth=\"8\" orient=\"auto\" refx=\"9\" refy=\"5\" viewbox=\"0 0 10 10\">\n<path class=\"arrowheadPath\" d=\"M 0 0 L 10 5 L 0 10 z\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></path>\n</marker>\n</defs>\n</g>\n<g class=\"edgePath LS-C LE-D\" id=\"L-C-D\" style=\"opacity: 1;\">\n<path class=\"path\" d=\"M223.0546875,298L223.0546875,302.1666666666667C223.0546875,306.3333333333333,223.0546875,314.6666666666667,233.90775553385416,323C244.76082356770834,331.3333333333333,266.4669596354167,339.6666666666667,277.3200276692708,343.8333333333333L288.173095703125,348\" marker-end=\"url(#arrowhead139)\" style=\"fill:none\"></path>\n<defs>\n<marker id=\"arrowhead139\" markerheight=\"6\" markerunits=\"strokeWidth\" markerwidth=\"8\" orient=\"auto\" refx=\"9\" refy=\"5\" viewbox=\"0 0 10 10\">\n<path class=\"arrowheadPath\" d=\"M 0 0 L 10 5 L 0 10 z\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></path>\n</marker>\n</defs>\n</g>\n<g class=\"edgePath LS-D LE-A\" id=\"L-D-A\" style=\"opacity: 1;\">\n<path class=\"path\" d=\"M407.990966796875,348L418.8440348307292,343.8333333333333C429.6971028645833,339.6666666666667,451.4032389322917,331.3333333333333,462.2563069661458,319.1666666666667C473.109375,307,473.109375,291,473.109375,272.8333333333333C473.109375,254.66666666666666,473.109375,234.33333333333334,473.109375,214C473.109375,193.66666666666666,473.109375,173.33333333333334,473.109375,153C473.109375,132.66666666666666,473.109375,112.33333333333333,457.9381510416667,94.76472854896325C442.7669270833333,77.19612376459317,412.4244791666667,62.39224752918633,397.2532552083333,54.990309411482905L382.08203125,47.58837129377949\" marker-end=\"url(#arrowhead140)\" style=\"fill:none\"></path>\n<defs>\n<marker id=\"arrowhead140\" markerheight=\"6\" markerunits=\"strokeWidth\" markerwidth=\"8\" orient=\"auto\" refx=\"9\" refy=\"5\" viewbox=\"0 0 10 10\">\n<path class=\"arrowheadPath\" d=\"M 0 0 L 10 5 L 0 10 z\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></path>\n</marker>\n</defs>\n</g>\n</g>\n<g class=\"edgeLabels\">\n<g class=\"edgeLabel\" style=\"opacity: 1;\" transform=\"translate(223.0546875,92)\">\n<g class=\"label\" transform=\"translate(-136,-13)\">\n<rect height=\"26\" rx=\"0\" ry=\"0\" width=\"272\"></rect>\n<foreignobject height=\"26\" width=\"272\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n<span class=\"edgeLabel L-LS-A' L-LE-B\" id=\"L-L-A-B\">使用操作系统的字符集编码请求字符串</span>\n</div>\n</foreignobject>\n</g>\n</g>\n<g class=\"edgeLabel\" style=\"opacity: 1;\" transform=\"\">\n<g class=\"label\" transform=\"translate(0,0)\">\n<rect height=\"0\" rx=\"0\" ry=\"0\" width=\"0\"></rect>\n<foreignobject height=\"0\" width=\"0\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n<span class=\"edgeLabel L-LS-B' L-LE-C\" id=\"L-L-B-C\"></span>\n</div>\n</foreignobject>\n</g>\n</g>\n<g class=\"edgeLabel\" style=\"opacity: 1;\" transform=\"\">\n<g class=\"label\" transform=\"translate(0,0)\">\n<rect height=\"0\" rx=\"0\" ry=\"0\" width=\"0\"></rect>\n<foreignobject height=\"0\" width=\"0\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n<span class=\"edgeLabel L-LS-C' L-LE-D\" id=\"L-L-C-D\"></span>\n</div>\n</foreignobject>\n</g>\n</g>\n<g class=\"edgeLabel\" style=\"opacity: 1;\" transform=\"translate(473.109375,214)\">\n<g class=\"label\" transform=\"translate(-144,-13)\">\n<rect height=\"26\" rx=\"0\" ry=\"0\" width=\"288\"></rect>\n<foreignobject height=\"26\" width=\"288\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n<span class=\"edgeLabel L-LS-D' L-LE-A\" id=\"L-L-D-A\">使用操作系统的字符集解码响应的字符串</span>\n</div>\n</foreignobject>\n</g>\n</g>\n</g>\n<g class=\"nodes\">\n<g class=\"node default\" id=\"flowchart-A-72\" style=\"opacity: 1;\" transform=\"translate(348.08203125,31)\">\n<rect class=\"label-container\" height=\"46\" rx=\"5\" ry=\"5\" width=\"68\" x=\"-34\" y=\"-23\"></rect>\n<g class=\"label\" transform=\"translate(0,0)\">\n<g transform=\"translate(-24,-13)\">\n<foreignobject height=\"26\" width=\"48\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n          客户端\n         </div>\n</foreignobject>\n</g>\n</g>\n</g>\n<g class=\"node default\" id=\"flowchart-B-73\" style=\"opacity: 1;\" transform=\"translate(223.0546875,153)\">\n<rect class=\"label-container\" height=\"46\" rx=\"5\" ry=\"5\" width=\"418.359375\" x=\"-209.1796875\" y=\"-23\"></rect>\n<g class=\"label\" transform=\"translate(0,0)\">\n<g transform=\"translate(-199.1796875,-13)\">\n<foreignobject height=\"26\" width=\"398.359375\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n          从character_set_client转换为character_set_connection\n         </div>\n</foreignobject>\n</g>\n</g>\n</g>\n<g class=\"node default\" id=\"flowchart-C-75\" style=\"opacity: 1;\" transform=\"translate(223.0546875,275)\">\n<rect class=\"label-container\" height=\"46\" rx=\"5\" ry=\"5\" width=\"430.109375\" x=\"-215.0546875\" y=\"-23\"></rect>\n<g class=\"label\" transform=\"translate(0,0)\">\n<g transform=\"translate(-205.0546875,-13)\">\n<foreignobject height=\"26\" width=\"410.109375\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n          从character_set_connection转换为具体的列使用的字符集\n         </div>\n</foreignobject>\n</g>\n</g>\n</g>\n<g class=\"node default\" id=\"flowchart-D-77\" style=\"opacity: 1;\" transform=\"translate(348.08203125,371)\">\n<rect class=\"label-container\" height=\"46\" rx=\"5\" ry=\"5\" width=\"494.9375\" x=\"-247.46875\" y=\"-23\"></rect>\n<g class=\"label\" transform=\"translate(0,0)\">\n<g transform=\"translate(-237.46875,-13)\">\n<foreignobject height=\"26\" width=\"474.9375\">\n<div style=\"display: inline-block; white-space: nowrap;\">\n          将查询结果从具体的列上使用的字符集转换为character_set_results\n         </div>\n</foreignobject>\n</g>\n</g>\n</g>\n</g>\n</g>\n</g>\n</svg>\n</div>\n<h2><a id=\"_MySQL_205\"></a>二 MySQL的数据目录</h2>\n<pre><code class=\"prism language-markdown\">###  1. MySQL8的主要目录结构 \nfind / -name mysql\n\n####  1.1、数据库文件的存放路径  \nshow variables like 'datadir'; # /var/lib/mysql/\n\n####  1.2、相关命令目录 \n相关命令目录：/usr/bin 和/usr/sbin。 \n\n####  1.3、配置文件目录 \n配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf） \n\n###  2.   数据库和文件系统的关系 \n####  2.1、表在文件系统中的表示  \n#####  2.3.1 InnoDB存储引擎模式  \n1. 表结构 \n为了保存表结构，`InnoDB`在`数据目录`下对应的数据库子目录下创建了一个专门用于`描述表结构的文件`\n\n表名.frm\n\n2. 表中数据和索引 \n\t2.1 系统表空间（system tablespace） \n\t\n\t默认情况下，InnoDB会在数据目录下创建一个名为`ibdata1`、大小为`12M`的`自拓展`文件，这个文件就是对应的`系统表空间`在文件系统上的表示。\n\t\n\t2.2 独立表空间(file-per-table tablespace)  \n\t\n\t在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为`每一个表建立一个独立表空间`，也就是说我们创建了多少个表，就有多少个独立表空间。使用`独立表空间`来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。\n\t表名.ibd\n\t&gt; MySQL8.0中不再单独提供`表名.frm`，而是合并在`表名.ibd`文件中。\n\n\t2.3 系统表空间与独立表空间的设置 \n\t\n\t我们可以自己指定使用`系统表空间`还是`独立表空间`来存储数据，这个功能由启动参数`innodb_file_per_table`控制\n\t\n\t[server] \n\tinnodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间\n\n\t2.4 其他类型的表空间 \n\t\n\t随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。\n\n#####  2.3.2 MyISAM存储引擎模式  \n1. 表结构 \n- 在存储表结构方面， MyISAM 和 InnoDB 一样，也是在`数据目录`下对应的数据库子目录下创建了一个专门用于描述表结构的文件\n\n表名.frm\n\n2. 表中数据和索引 \n- 在MyISAM中的索引全部都是`二级索引`，该存储引擎的`数据和索引是分开存放`的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。\n\ntest.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sdi\ntest.MYD 存储数据 (MYData) \ntest.MYI 存储索引 (MYIndex\n</code></pre>\n<h2><a id=\"__264\"></a>三 用户与权限管理</h2>\n<pre><code class=\"prism language-markdown\">###  1.   用户管理 \n####  1.1、登录MySQL服务器 \n启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：\n\nmysql –h hostname|hostIP –P port –u username –p DatabaseName –e \"SQL语句\"\n\n- `-h参数`后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 \n- `-P参数`后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。\n- `-u参数`后面接用户名，username为用户名。\n- `-p参数`会提示输入密码。\n- `DatabaseName参数`指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。\n- `-e参数`后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。\n\nmysql -uroot -p -hlocalhost -P3306 mysql -e \"select host,user from user\"\n\n####  1.2、创建用户 \nCREATE USER 用户名 [IDENTIFIED BY '密码'][,用户名 [IDENTIFIED BY '密码']];\n\n举例：\nCREATE USER zhang3 IDENTIFIED BY '123123'; # 默认host是 %\nCREATE USER 'kangshifu'@'localhost' IDENTIFIED BY '123456';\n\n####  1.3、修改用户 \nUPDATE mysql.user SET USER='li4' WHERE USER='wang5'; \nFLUSH PRIVILEGES;\n\n####  1.4、删除用户 \n方式1：使用DROP方式删除（推荐） \nDROP USER user[,user]…;\n\n举例：\nDROP USER li4 ; # 默认删除host为%的用户\nDROP USER 'kangshifu'@'localhost';\n\n方式2：使用DELETE方式删除（不推荐，有残留信息） \nDELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;\nFLUSH PRIVILEGES;\n\n####  1.5、设置当前用户密码 \n1. 使用ALTER USER命令来修改当前用户密码 \nALTER USER USER() IDENTIFIED BY 'new_password';\n\n2. 使用SET语句来修改当前用户密码 \nSET PASSWORD='new_password';\n\n####  1.6、修改其它用户密码  \n1. 使用ALTER语句来修改普通用户的密码 \nALTER USER user [IDENTIFIED BY '新密码'] \n[,user[IDENTIFIED BY '新密码']]…;\n\n2. 使用SET命令来修改普通用户的密码 \nSET PASSWORD FOR 'username'@'hostname'='new_password';\n\n###  2. 权限管理 \n\n####  2.1、权限列表 \nshow privileges\\G\n\n- `CREATE和DROP权限`，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。\n- `SELECT、INSERT、UPDATE和DELETE权限`允许在一个数据库现有的表上实施操作。\n- `SELECT权限`只有在它们真正从一个表中检索行时才被用到。\n- `INDEX权限`允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。\n- `ALTER权限`可以使用ALTER TABLE来更改表的结构和重新命名表。\n- `CREATE ROUTINE权限`用来创建保存的程序（函数和程序），`ALTER ROUTINE权限`用来更改和删除保存的程序，`EXECUTE权限`用来执行保存的程序。\n- `GRANT权限`允许授权给其他用户，可用于数据库、表和保存的程序。\n- `FILE权限`使用户可以使用LOAD DATA INFILE和SELECT ... INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。\n\n####  2.2、授予权限的原则 \n权限控制主要是出于安全因素，因此需要遵循以下几个`经验原则`：\n1、只授予能`满足需要的最小权限`，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。\n2、创建用户的时候`限制用户的登录主机`，一般是限制成指定IP或者内网IP段。\n3、为每个用户`设置满足密码复杂度的密码`。 \n4、`定期清理不需要的用户`，回收权限或者删除用户。\n\n####  2.3、授予权限 \nGRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];\n\n- 该权限如果发现没有该用户，则会直接新建一个用户。\n- 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。\nGRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;\n\n- 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限\nGRANT ALL PRIVILEGES ON *.* TO joe@'%' IDENTIFIED BY '123';\n\n####  2.4、查看权限 \n\n- 查看当前用户权限\nSHOW GRANTS; \n# 或 \nSHOW GRANTS FOR CURRENT_USER; \n# 或 \nSHOW GRANTS FOR CURRENT_USER();\n\n- 查看某用户的全局权限\nSHOW GRANTS FOR 'user'@'主机地址';\n\n####  2.5、收回权限 \n注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。 \n\n- 收回权限命令\nREVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;\n\n- 举例\n#收回全库全表的所有权限 \nREVOKE ALL PRIVILEGES ON *.* FROM joe@'%'; \n#收回mysql库下的所有表的插删改查权限 \nREVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;\n\n\n- 注意：`须用户重新登录后才能生效` \n\n###  3. 角色管理 \n\n####  3.1、创建角色 \nCREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'host_name']]...\n\n角色名称的命名规则和用户名类似。如果`host_name省略，默认为%`，`role_name不可省略`，不可为空。\n\n####  3.2、给角色赋予权限 \nGRANT privileges ON table_name TO 'role_name'[@'host_name'];\n\n上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称\nSHOW PRIVILEGES;\n\n\n####  3.3、查看角色的权限 \nSHOW GRANTS FOR 'role_name';\n\n只要你创建了一个角色，系统就会自动给你一个“`USAGE`”权限，意思是`连接登录数据库的权限`。\n\n####  3.4、回收角色的权限 \nREVOKE privileges ON tablename FROM 'rolename';\n\n####  3.5、删除角色 \nDROP ROLE role [,role2]...\n\n注意，`如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限`。\n\n####  3.6、给用户赋予角色 \n角色创建并授权后，要赋给用户并处于`激活状态`才能发挥作用。\nGRANT role [,role2,...] TO user [,user2,...];\n\n\n查询当前已激活的角色\nSELECT CURRENT_ROLE();\n\n\n####  3.7、激活角色 \n方式1：使用set default role 命令激活角色 \nSET DEFAULT ROLE ALL TO 'kangshifu'@'localhost';\n\n方式2：将activate_all_roles_on_login设置为ON**\nSET GLOBAL activate_all_roles_on_login=ON;\n\n这条 SQL 语句的意思是，对`所有角色永久激活`。\n\n####  3.8、撤销用户的角色 \nREVOKE role FROM user;\n\n####  3.9、设置强制角色(mandatory role) \n- 方式1：服务启动前设置\n[mysqld] \nmandatory_roles='role1,role2@localhost,r3@%.atguigu.com'\n\n- 方式2：运行时设置\nSET PERSIST mandatory_roles = 'role1,role2@localhost,r3@%.example.com'; #系统重启后仍然有效\nSET GLOBAL mandatory_roles = 'role1,role2@localhost,r3@%.example.com'; #系统重启后失效\n</code></pre>\n<h2><a id=\"_438\"></a>四、逻辑架构</h2>\n<h3><a id=\"41_440\"></a>4.1、逻辑架构剖析</h3>\n<h4><a id=\"411_442\"></a>4.1.1、服务器处理客户端请求</h4>\n<p>首先Mysql是典型的C/S架构，服务器端程序使用的 <code>mysqld</code></p>\n<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本（SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p>\n<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1346ec51150a4bbfb5497f970fc80b40.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f19da844a6314b268910702fbb2ce2df.png\"/></p>\n<h4><a id=\"412Connectors_454\"></a>4.1.2、Connectors</h4>\n<h4><a id=\"4131_456\"></a>4.1.3、第1层：连接层</h4>\n<p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p>\n<p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p>\n<ul><li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li><li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul>\n<p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从连接池中获取线程，省去了创建和销毁线程的开销。</p>\n<h4><a id=\"4142_467\"></a>4.1.4、第2层：服务层</h4>\n<ul><li> <p>SQL Interface: SQL接口</p>\n<ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul> </li><li> <p>Parser: 解析器</p>\n<ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul> </li><li> <p>Optimizer：查询优化器</p>\n<ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li></ul> <pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>name <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> gender <span class=\"token operator\">=</span> <span class=\"token string\">'女'</span><span class=\"token punctuation\">;</span>\n</code></pre> <p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p> </li><li> <p>Caches &amp; Buffers： 查询缓存组件</p>\n<ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul> </li></ul>\n<h4><a id=\"4153_498\"></a>4.1.5、第3层：引擎层</h4>\n<p>插件式存储引擎层（ Storage Engines）， 真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作 ，服务层通过API与存储引擎进行通信。</p>\n<h4><a id=\"416_502\"></a>4.1.6、存储层</h4>\n<p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>\n<h4><a id=\"417_506\"></a>4.1.7、小结</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ea73eb60363b4ae1bf053720e205e403.png\"/></p>\n<p>简化为三层结构：</p>\n<ol><li> <p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p> </li><li> <p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p> </li><li> <p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p> </li></ol>\n<h3><a id=\"42SQL_518\"></a>4.2、SQL执行流程</h3>\n<h4><a id=\"421MySQL__SQL_520\"></a>4.2.1、MySQL 中的 SQL执行流程</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\569ab76044cf454a9c407b4241eea625.png\"/></p>\n<p><strong>MySQL的查询流程</strong>：</p>\n<p>1、<strong>查询缓存</strong> ：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p>\n<p>大多数情况查询缓存就是个鸡肋，为什么呢？</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> employee_id<span class=\"token punctuation\">,</span>last_name <span class=\"token keyword\">FROM</span> employees <span class=\"token keyword\">WHERE</span> employee_id <span class=\"token operator\">=</span> <span class=\"token number\">101</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 <strong>MySQL 的 查询缓存命中率不高</strong> 。</p>\n<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p>\n<p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p>\n<p>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。</p>\n<p>一般建议大家在静态表里使用查询缓存，什么叫<code>静态表</code>呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。好在MysQL也提供了这种”按需使用”的方式。你可以将my.cnf参数query_cache_type设置成DEMAND，代表当sql语句中有SQL_CACHE关键词时才缓存。比如:</p>\n<pre><code class=\"prism language-properties\"># query_cache_type有3个值，0代表关闭查询缓存OFF，1代表开启ON，2（DEMAND）\nquery_cache_type=2\n</code></pre>\n<p>这样对于默认的SQL语句都不使用查询缓存。而对于你确定要是使用查询缓存的语句，可以用SQL_CACHE显示指定，像下面这个语句一样：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> SQL_CACHE <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> test <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看当前mysql实例是否开启缓存机制</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># mysql5.7中:</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> <span class=\"token keyword\">global</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">\"%query_cache_type%\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># mysql8.0中</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> <span class=\"token keyword\">global</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">\"%query_cache_type%\"</span><span class=\"token punctuation\">;</span>\nEmpty <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.02</span> sec<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>监控查询缓存的命中率：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">like</span> <span class=\"token string\">'%Qcache%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e61423e9e6164009a8d5ef8acd8a9bbe.png\"/></p>\n<p>运行结果解析:</p>\n<p><strong>Qcache_free_blocks</strong> :表示查询缓存中还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。</p>\n<p><strong>Qcache_free_memory</strong> :查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用,是多了，还是不够用，DBA可以根据实际情况做出调整。</p>\n<p><strong>Qcache_hits</strong> :表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</p>\n<p><strong>Qcache_inserts</strong>:表示多少次未命中然后插入，意思是新来的sQL请求在缓存中未找到，不得不执行查询处理执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就理想。当然系统刚启动后，查询缓存是空的，这很正常。</p>\n<p><strong>Qcache_lowmem_prunes</strong> :该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。</p>\n<p><strong>Qcache_not_cached</strong> :表示因为query_cache_type的设置而没有被缓存的查询数量。</p>\n<p><strong>Qcache_queries.in.cache</strong> :当前缓存中缓存的查诎数量。</p>\n<p><strong>Qcache_total_blocks</strong> :当前缓存的block数量。</p>\n<p>2、<strong>解析器</strong> ：在解析器中对 SQL 语句进行语法分析、语义分析。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bc819782735045f596371b5daa031960.png\"/></p>\n<p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。SQL语句的分析分为词法分析与语法分析。</p>\n<p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的\"select\"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>\n<p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。</p>\n<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句from写成了“rom”。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 语句：</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> rom test <span class=\"token keyword\">where</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 错误：</span>\nERROR <span class=\"token number\">1064</span> <span class=\"token punctuation\">(</span><span class=\"token number\">42800</span> <span class=\"token punctuation\">)</span> : You have an error <span class=\"token operator\">in</span> your <span class=\"token keyword\">SQL</span> syntax<span class=\"token punctuation\">;</span> <span class=\"token keyword\">check</span> the manual that corresponds toyour MySQL server version <span class=\"token keyword\">for</span> the <span class=\"token keyword\">right</span> syntax <span class=\"token keyword\">to</span> <span class=\"token keyword\">use</span> near <span class=\"token string\">'fro test where id=1'</span> at line <span class=\"token number\">1</span>\n</code></pre>\n<p>如果SQL语句正确，则会生成一个语法树。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\97c25b0092854cd0bebefdd64cdc63c9.png\"/></p>\n<p>下面是SQL语法分析的过程步骤：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d2aac4c65ea549899c07c16e5298fd49.png\"/></p>\n<p>3、<strong>优化器</strong> ：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> test1 <span class=\"token keyword\">join</span> test2 <span class=\"token keyword\">using</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span> test1<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">'zhangwei'</span> <span class=\"token operator\">and</span> test2<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">'mysql高级课程'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-markdown\"># 方案1：可以先从表 test1 里面取出 name='zhangwei'的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的值是否等于 'mysql高级课程'。\n\n# 方案2：可以先从表 test2 里面取出 name='mysql高级课程' 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name的值是否等于 zhangwei。\n\n这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。\n\n如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。\n</code></pre>\n<p>在查询优化器中，可以分为 <code>逻辑查询</code> 优化阶段和 <code>物理查询</code> 优化阶段。</p>\n<ul><li> <p>逻辑查询优化：就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价交换，对查询进行 <code>重写</code>，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p> </li><li> <p>物理查询优化：是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p> </li></ul>\n<p>4、<strong>执行器</strong> ：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a99b4fd62ece4e10af6feb865e7d7258.png\"/></p>\n<p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 之前的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> test <span class=\"token keyword\">where</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎API对表进行的读写。存储引擎API只是抽象接口，下面还有个存储引擎层，具体实现还是要看表选择的存储引擎。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\47eea6b4f23b4ab184b8513ddfc323df.png\"/></p>\n<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>\n<pre><code class=\"prism language-markdown\">- 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。\n\n- 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。\n</code></pre>\n<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p>\n<p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8f9cd6fb9adc4a37aa169cad91356110.png\"/></p>\n<h4><a id=\"422MySQL8SQL_676\"></a>4.2.2、MySQL8中SQL执行原理</h4>\n<ol><li>确认profiling 是否开启</li></ol>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> @<span class=\"token variable\">@profiling</span><span class=\"token punctuation\">;</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'profiling'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> profiling<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>多次执行相同SQL查询</li></ol>\n<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> employees<span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"3\"><li>查看profiles</li></ol>\n<p>查看当前会话所产生的所有 profiles：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profiles<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 显示最近的几次查询</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\66f3960abfb1469c8d40a8c556c570e8.png\"/></p>\n<ol start=\"4\"><li>查看profile</li></ol>\n<p>显示执行计划，查看程序的执行步骤：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profile<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7c38f5ee7b16494496599626e66ea10d.png\"/></p>\n<p>此外，还可以查询更丰富的内容：</p>\n<pre><code class=\"prism language-sql\">Syntax:\n<span class=\"token keyword\">SHOW</span> PROFILE <span class=\"token punctuation\">[</span><span class=\"token keyword\">type</span> <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">,</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">[</span> <span class=\"token keyword\">FOR</span> QUERY n <span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">[</span><span class=\"token keyword\">LIMIT</span> row_count <span class=\"token punctuation\">[</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token keyword\">offset</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">type</span> : {\n\t<span class=\"token keyword\">ALL</span> <span class=\"token comment\">-- 显示所有参数的开销信息</span>\n\tBLOCK IO <span class=\"token comment\">-- 显示IO的相关开销</span>\n\tCONTEXT SWITCHES <span class=\"token comment\">-- 上下文切换相关开销</span>\n\tCPU <span class=\"token comment\">-- 显示CPU相关开销信息</span>\n\tIPC <span class=\"token comment\">-- 显示发送和接收相关开销信息</span>\n\tMEMORY <span class=\"token comment\">-- 显示内存相关开销信息</span>\n\tPAGE FAULTS <span class=\"token comment\">-- 显示页面错误相关开销信息</span>\n\tSOURCE <span class=\"token comment\">-- 显示和Source_function, Source_file,Source_line相关的开销信息</span>\n\tSWAPS <span class=\"token comment\">-- 显示交换次数相关的开销信息</span>\n}\n</code></pre>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profile cpu<span class=\"token punctuation\">,</span>block io <span class=\"token keyword\">for</span> query <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3a7228acfe7d45c9a1de865eac6c7c11.png\"/></p>\n<h4><a id=\"423MySQL57SQL_748\"></a>4.2.3、MySQL5.7中SQL执行原理</h4>\n<p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用缓存吗？这里我们需要 显式开启查询缓存模式 。在MySQL5.7中如下设置：</p>\n<ol><li>配置文件中开启查询缓存</li></ol>\n<p>在 /etc/my.cnf 中新增一行：</p>\n<pre><code class=\"prism language-properties\">query_cache_type=1\n</code></pre>\n<ol start=\"2\"><li>重启mysql服务</li></ol>\n<pre><code class=\"prism language-bash\">systemctl restart mysqld\n</code></pre>\n<ol start=\"3\"><li>开启查询执行计划</li></ol>\n<p>由于重启过服务，需要重新执行如下指令，开启profiling。</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> profiling<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"4\"><li>执行语句两次：</li></ol>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> locations<span class=\"token punctuation\">;</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> locations<span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"5\"><li>查看profiles</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a8ff09f1d3f744e1b5646bf61e84c08f.png\"/></p>\n<ol start=\"6\"><li>查看profile</li></ol>\n<p>显示执行计划，查看程序的执行步骤：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profile <span class=\"token keyword\">for</span> query <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\72868e7514a840c889c2d083f34c53ad.png\"/></p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profile <span class=\"token keyword\">for</span> query <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a9e9392bf0bd4a9ba1b4a29119b4b075.png\"/></p>\n<p>结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中获取数据。</p>\n<h4><a id=\"424SQL_805\"></a>4.2.4、SQL语法顺序</h4>\n<p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。</p>\n<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息</p>\n<p>下面是经常出现的查询顺序：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8c8a479da6fa4853ae7d375036dae188.png\"/></p>\n<h4><a id=\"425OracleSQL_815\"></a>4.2.5、Oracle中的SQL执行流程(了解)</h4>\n<p>Oracle 中采用了 共享池 来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用硬解析还是软解析。</p>\n<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a87c655f5435492b8a5d56eeaa7b5184.png\"/></p>\n<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。</p>\n<p>1.语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</p>\n<p>2.语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</p>\n<p>3.权限检查：看用户是否具备访问该数据的权限。</p>\n<p>4.共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？</p>\n<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。</p>\n<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是 硬解析 。</p>\n<p>5.优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</p>\n<p>6.执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</p>\n<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而 数据字典缓冲区 存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>\n<p>库缓存 这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p>\n<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中， 绑定变量 是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能 提升软解析的可能性 ，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>\n<pre><code class=\"prism language-sql\">举个例子，我们可以使用下面的查询语句：\n<span class=\"token keyword\">SQL</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> player <span class=\"token keyword\">where</span> player_id <span class=\"token operator\">=</span> <span class=\"token number\">10001</span><span class=\"token punctuation\">;</span>\n\n你也可以使用绑定变量，如：\n\n<span class=\"token keyword\">SQL</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> player <span class=\"token keyword\">where</span> player_id <span class=\"token operator\">=</span> :player_id<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。</p>\n<p>因此，我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。</p>\n<p>Oracle的架构图：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\14b96d220d9d45a4b857e37680c12245.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\87353c92f7f04dbeba5be1f3bfa8e312.png\"/></p>\n<p>小结：</p>\n<p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享池来判断是进行软解析，还是硬解析。</p>\n<h3><a id=\"43buffer_pool_872\"></a>4.3、数据库缓冲池(buffer pool)</h3>\n<p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p>\n<p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>\n<h4><a id=\"431vs_878\"></a>4.3.1、缓冲池vs查询缓存</h4>\n<ol><li>缓冲池（Buffer Pool）</li></ol>\n<p>在InnoDB存储引擎中有一部分会放到内存中，缓冲池则占了这部分内存的大部分，他用来存储各种数据的缓存，</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\142f62d084e44e278de036af896bdb40.png\"/></p>\n<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p>\n<p><strong>缓存池的重要性</strong>：</p>\n<p>对于使用InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以 页 的形式存放在 表空间中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢跟乌龟一样，怎么能配得上“快如风，疾如电\"的CPU呢?这里，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中,也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。</p>\n<p><strong>缓存原则</strong>：</p>\n<p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I/O 访问效率进行优化。</p>\n<p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>\n<p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p>\n<p>缓冲池的预读特性：</p>\n<p>缓冲池的作用就是为了提升I/O效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。</p>\n<ol start=\"2\"><li>查询缓存</li></ol>\n<p>查询缓存是提前把<code>查询结果缓存</code>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>\n<h4><a id=\"432_908\"></a>4.3.2、缓冲池如何读取数据</h4>\n<p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\46d630e7456c4408b5e22860655fce8a.png\"/></p>\n<p>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</p>\n<h4><a id=\"433_916\"></a>4.3.3、查看/设置缓冲池的大小</h4>\n<p>如果你使用的是MySQL MyISAM存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为key_buffer_size，你可以用它进行查看。</p>\n<p>如果你使用的是InnoDB存储引擎，可以通过查看innodb_buffer_poll_size变量来查看缓冲池的大小</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_buffer_pool_size'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>设置缓冲池的大小</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> innodb_buffer_pool_size <span class=\"token operator\">=</span> <span class=\"token number\">268435456</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>或者</p>\n<pre><code class=\"prism language-ini\">[server] \ninnodb_buffer_pool_size = 268435456\n</code></pre>\n<h4><a id=\"434Buffer_Pool_939\"></a>4.3.4、多个Buffer Pool实例</h4>\n<p>Buffer Pool 本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问Buffer Pool中的数据都需要 加锁 处理。在Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool 可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把他们 差分成若干个小的Buffer Pool，每个Buffer Pool都称为一个 实例，他们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>\n<pre><code class=\"prism language-properties\"># 我们可以在服务器启动的时候通过设置innodb_buffer_pool_instances的值来修改 Buffer Pool实例的个数\n[server] \ninnodb_buffer_pool_instances = 2\n</code></pre>\n<p>何查看缓冲池的个数</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_buffer_pool_instances'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>每个<code>Buffer Pool</code>实例实际占内存空间</p>\n<pre><code class=\"prism language-sql\">innodb_buffer_pool_size<span class=\"token operator\">/</span>innodb_buffer_pool_instances\n</code></pre>\n<p>也就是总共的大小除以实例的个数，结果就是每个Buffer Pool实例占用的大小。</p>\n<p>不过也不是说Buffer Pool实例创建的越多越好，分别管理各个Buffer Pool也是需要性能开销的，InnoDB规定:innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的L,InnoDB会默认把innodb_buffer_pool_instances的值修改为1。而我们鼓励在Buffer Pool大于或等于1G的时候设置多个Buffer Pool实例。</p>\n<h4><a id=\"435_965\"></a>4.3.5、引申问题</h4>\n<p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>\n<p>黑盒下的更新数据流程：</p>\n<p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于BufferPool，同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b1c3f8dd1d9342088a48fbc82d7afb99.png\"/></p>\n<p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MySQL宕机了，这部分数据将会永久地丢失;</p>\n<p>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p>\n<p>答案：Redo Log &amp; Undo Log</p>\n<h2><a id=\"_983\"></a>五、存储引擎</h2>\n<p>为了管理方便 ，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真是存取数据的功能划分为 存储引擎 的功能。所以在Mysql server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>\n<p>MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫作表处理器，后来改名为 存储疫情，它的功能就是接受上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>\n<h3><a id=\"51_989\"></a>5.1、查看存储引擎</h3>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 或</span>\n<span class=\"token keyword\">show</span> engines\\G\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c2ff291aa66e49dd92051b6b9308772f.png\"/></p>\n<p>查询结果显示，MySQL 8支持9种存储引擎，分别为MEMORY、MRG_MYISAM、CSV、FEDERATED、PERFORMANCE_SCHEMA、MyISAM、InnoDB、BLACKHOLE 和ARCHIVE。</p>\n<ul><li>Engine参数：表示存储引擎名称。</li><li>Support参数：表示MySQL数据库管理系统是否支持该存储引擎: YES表示支持，NO表示不支持。</li><li>DEFAULT：表示系统默认支持的存储引擎。</li><li>Comment参数：表示对存储引擎的评论。</li><li>Transactions参数：表示存储引擎是否支持事务:YES表示支持，NO表示不支持。</li><li>XA参数：表示存储引擎所支持的分布式是否符合XA规范: YES表示支持，NO表示不支持。代表着该存储引擎是否支持分布式事务。</li><li>Savepoints参数：表示存储引擎是否支持事务处理的保存点: VES表示支持，NO表示不支持。也就是说，该存储引擎是否支持部分事务回滚。</li></ul>\n<h3><a id=\"52_1009\"></a>5.2、设置系统默认的存储引擎</h3>\n<ul><li>查看默认的存储引擎：</li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%storage_engine%'</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#或</span>\n<span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@default_storage_engine</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f11bd67dd6694475800c9d36cea114a0.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f9f1f1f434044aaa8c2a09dd75ad15b1.png\"/></p>\n<ul><li>修改默认的存储引擎</li></ul>\n<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> DEFAULT_STORAGE_ENGINE<span class=\"token operator\">=</span>MyISAM<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>或者修改<code>my.cnf</code>文件：</p>\n<pre><code class=\"prism language-ini\">default-storage-engine=MyISAM \n</code></pre>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 重启服务 </span>\nsystemctl restart mysqld.service\n</code></pre>\n<h3><a id=\"53_1042\"></a>5.3、设置表的存储引擎</h3>\n<p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>\n<p>5.3.1、创建表时指定存储引擎</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名<span class=\"token punctuation\">(</span>\n    建表语句<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> 存储引擎名称<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>5.3.2、修改表的存储引擎</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> 表名 <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> 存储引擎名称<span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"54_1060\"></a>5.4、引擎介绍</h3>\n<h4><a id=\"541InnoDB__1062\"></a>5.4.1、InnoDB 引擎：具备外键支持功能的事务存储引擎</h4>\n<ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。</li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><mark>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</mark></li><li>数据文件结构： \n  <ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul> </li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。 \n  <ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul> </li><li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li></ul>\n<h4><a id=\"542MyISAM_1076\"></a>5.4.2、MyISAM引擎：主要的非事务处理存储引擎</h4>\n<ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。</li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构： \n  <ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul> </li><li>应用场景：只读应用或者以读为主的业务</li></ul>\n<h4><a id=\"543Archive___1088\"></a>5.4.3、Archive 引擎：用于数据存档</h4>\n<ul><li>archive是归档的意思，仅仅支持插入和查询两种功能（行被插入后不能再修改)。</li><li>在MySQL5.5以后支持索引功能。</li><li>拥有很好的压缩机制，使用zlib压缩库，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</li><li>创建ARCHIVE表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为.ARZ。</li><li>根据英文的测试结论来看，同样数据量下，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li><li>ARCHIVE存储引擎采用了行级锁。该ARCHIVE引擎支持 AUTO_INCRENENT列属性。AUTO_INCREMENT列可以具有唯一索引或非唯一索引。尝试在任何其他列上创建索引会导致错误。</li><li>Archive表适合日志和数据采集（档案）类应用;适合存储大量的独立的作为历史记录的数据。拥有很高的插入速度，但是对查询的支持较差。</li><li>下表展示了ARCHIVE存储引擎功能</li></ul>\n<table><thead><tr><th>特征</th><th>支持</th></tr></thead><tbody><tr><td>B树索引</td><td>不支持</td></tr><tr><td>备份/时间点恢复(在服务器中实现，而不是在存储引擎中)</td><td>支持</td></tr><tr><td>集群数据库支持</td><td>不支持</td></tr><tr><td>聚集索引</td><td>不支持</td></tr><tr><td>压缩数据</td><td>支持</td></tr><tr><td>数据缓存</td><td>不支持</td></tr><tr><td>加密数据（加密功能在服务器中实现)</td><td>支持</td></tr><tr><td>外键支持</td><td>不支持</td></tr><tr><td>全文检索索引</td><td>不支持</td></tr><tr><td>地理空间数据类型支持</td><td>支持</td></tr><tr><td>哈希索引</td><td>不支持</td></tr><tr><td>索引缓存</td><td>不支持</td></tr><tr><td>锁粒度</td><td>行锁</td></tr><tr><td>MVCC</td><td>不支持</td></tr><tr><td>存储限制</td><td>没有任何限制</td></tr><tr><td>交易</td><td>不支持</td></tr><tr><td>更新数据字典的统计信息</td><td>支持</td></tr></tbody></table>\n<h4><a id=\"544Blackhole___1119\"></a>5.4.4、Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4>\n<ul><li>Blackhole引擎没有实现任何存储机制Ⅰ它会丢弃所有插入的数据，不做任何保存。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li></ul>\n<h4><a id=\"545CSV__1124\"></a>5.4.5、CSV 引擎：存储数据时，以逗号分隔各个数据项</h4>\n<ul><li>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。</li><li>CSv引擎可以作为一种数据交换的机制，非常有用。</li><li>CSv存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取</li><li>对于数据的快速导入、导出是有明显优势的。</li></ul>\n<p>创建CSV表时，服务器会创建一个纯文本数据文件，其名称以表名开头并带有.cSV扩展名。当你将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p>\n<p>使用案例如下</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">INT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>，c <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> CSv<span class=\"token punctuation\">;</span>\nQuery <span class=\"token number\">0</span>K<span class=\"token punctuation\">,</span><span class=\"token number\">0</span> <span class=\"token keyword\">rows</span> affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.06</span> sec<span class=\"token punctuation\">)</span>\n\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> test <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">,</span> <span class=\"token string\">' record one '</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'record two '</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nQuery oK，<span class=\"token number\">2</span> <span class=\"token keyword\">rows</span> affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.05</span> sec<span class=\"token punctuation\">)</span>\nRecords : <span class=\"token number\">2</span> Duplicates: <span class=\"token number\">0</span>warnings : <span class=\"token number\">0</span>\n\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> test <span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">---+-----------+</span>\n<span class=\"token operator\">|</span> i <span class=\"token operator\">|</span> c         <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">---+-----------+</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> record one<span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">2</span> <span class=\"token operator\">|</span> record two<span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">---+-----------+</span>\n<span class=\"token number\">2</span>rows <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.00</span> sec<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>创建CSV表还会创建相应的元文件，用于存储表的状态和表中存在的行数了。此文件的名称与表的名称相同，后缀为CSM。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e7c84cb72d6f44c99f94864be8a29b54.png\"/></p>\n<p>打开如下：</p>\n<pre><code>\"1\", \"record one\"\n\"2\", \"record two\"\n</code></pre>\n<h4><a id=\"546Memory___1164\"></a>5.4.6、Memory 引擎：置于内存的表</h4>\n<p>Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</p>\n<p>主要特征:</p>\n<ul><li>Memory同时支持哈希（HASH）索引和B+树索引。 \n  <ul><li>哈希索引相等的比较快，但是对于范围的比较慢很多。</li><li>默认使用哈希（HASH）索引，其速度要比使用B型树(BTREE)索引快</li><li>如果希望使用B树索引，可以在创建索引时选择使用。</li></ul> </li><li>Memory表至少比MyISAM表要快一个数量级。</li><li>MEMORY表的大小是受到限制的。表的大小主要取决于两个参数，分别是max_rows和max_heap_table_size。其中，max_rows可以在创建表时指定; max_heap_table_size的大小默认为16MB,可以按需要进行扩大。</li><li>数据文件与索引文件分开存储。 \n  <ul><li>每个基于MEMORY存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同,类型为frm类型，该文件中只存储表的结构，而其数据文件都是存储在内存中的。</li><li>这样有利于数据的快速处理，提供整个表的处理效率。</li></ul> </li><li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</li></ul>\n<p>使用Memory存储引擎的场景:</p>\n<ol><li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数max_heap_table_size控制Memory表的大小，限制Memory表的最大的大小。</li><li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。</li></ol>\n<h4><a id=\"547Federated___1187\"></a>5.4.7、Federated 引擎：访问远程表</h4>\n<ul><li>Federated引擎是访问其他MysQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul>\n<h4><a id=\"548MergeMyISAM_1191\"></a>5.4.8、Merge引擎：管理多个MyISAM表构成的表集合</h4>\n<h4><a id=\"549NDBMySQL_1193\"></a>5.4.9、NDB引擎：MySQL集群专用存储引擎</h4>\n<p>也叫做NDB Cluster存储引擎，主要用于MysQL cluster 分布式集群环境，类似于Oracle的 RAC集群。</p>\n<h3><a id=\"55MyISAMInnoDB_1197\"></a>5.5、MyISAM和InnoDB</h3>\n<p>MySQL5.5之前的默认存储引擎是MylSAM，5.5之后改为了InnoDB。</p>\n<p>首先对于InnoDB存储引擎，提供了良好的事务管理、崩溃修复能力和并发控制。因为InnoDB存储引擎支持事务所以对于要求事务完整性的场合需要选择lnnoDB，比如数据操作除了插入和查询以外还包含有很多更新、删除操作，像财务系统等对数据准确性要求较高的系统。缺点是其读写效率稍差，占用的数据空间相对比较大。</p>\n<p>其次对于MylSAM存储引擎，如果是小型应用，系统以读操作和插入操作为主，只有很少的更新、删除操作，并且对事务的要求没有那么高，则可以选择这个存储引擎。MylISAM存储引擎的优势在于占用空间小，处理速度快﹔缺点是不支持事务的完整性和并发性。</p>\n<p>这两种引擎各有特点，当然你也可以在MysQL中，针对不同的数据表，可以选择不同的存储引擎。</p>\n<table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table>\n<h2><a id=\"_1220\"></a>六、索引的数据结构</h2>\n<h3><a id=\"61_1222\"></a>6.1、为什么使用索引</h3>\n<p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6e599bb142f64ebe8c8bd981579771b7.png\"/></p>\n<p>如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从1到6行按顺序读取，这样就相当于进行了6次I0操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col2=89这条记录，就要逐行去查找、去比较。从Col 2=34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘I/0才能找到。现在要查找Col 2=89这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/O(涉及到磁盘的旋转时间（速度快）），磁头的寻道时间（速度慢-费时）</p>\n<p>假如给数据使用二叉树这样的数据结构进行存储</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0d11105a33334e138a73d387078ddb7f.png\"/></p>\n<p>对字段Col2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是（K，V)结构，key是Col 2，value是该key所在行的文件指针（地址)。比如:该二叉搜索树的根节点就是:(34,0x07)。现在对Col 2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树〈二叉树的遍历查找)。读34到内存，89&gt;34；继续右侧数据，读89到内存，89 == 89;找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p>\n<p>这就是我们为什么要建索引，目的就是为了减少磁盘I/O的次数，加快查询速率。</p>\n<h3><a id=\"62_1238\"></a>6.2、索引及其优缺点</h3>\n<h4><a id=\"621__1240\"></a>6.2.1 、索引概述</h4>\n<p>MySQL官方对索引的定义为： 索引（Index）是帮助MySQL高效获取数据的数据结构 。</p>\n<p>索引的本质： 索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p>\n<p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的<code>最大索引数</code>和<code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>\n<h4><a id=\"622_1248\"></a>6.2.2、优点</h4>\n<ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</li><li>通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</li><li>在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li><li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</li></ol>\n<h4><a id=\"623_1255\"></a>6.2.3、缺点</h4>\n<ol><li>创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ol>\n<p>提示：索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后在创建索引。</p>\n<h3><a id=\"63InnoDB_1263\"></a>6.3、InnoDB中索引的推演</h3>\n<h4><a id=\"631_1265\"></a>6.3.1、索引之前的查找</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">[</span>列名列表<span class=\"token punctuation\">]</span> <span class=\"token keyword\">FROM</span> 表名 <span class=\"token keyword\">WHERE</span> 列名 <span class=\"token operator\">=</span> xxx<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>1.<strong>在一个页中的查找</strong></p>\n<p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>\n<ul><li>以主键为搜索条件 \n  <ul><li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul> </li><li>以其他列作为搜索条件 \n  <ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul> </li></ul>\n<p>2.<strong>在很多页中查找</strong></p>\n<p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p>\n<ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol>\n<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p>\n<h4><a id=\"632_1289\"></a>6.3.2、设计索引</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 建一个表</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> index_demo<span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> c1 <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> c2 <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> c3 <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">)</span> ROW_FORMAT <span class=\"token operator\">=</span> Compact<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d38f201c7af8472aa65cb10d2b420e55.png\"/></p>\n<ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。</li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul>\n<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a28b84d07e16417f99344bdcfb4e7720.png\"/></p>\n<p>把一些记录放到页里的示意图就是：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5a067f246cde49fe9378dbcae1eb60f6.png\"/></p>\n<h5><a id=\"6321_1318\"></a>6.3.2.1、一个简单的索引设计方案</h5>\n<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p>\n<ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li></ul>\n<p>假设:每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向index_demo表插入3条记录</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> index_demo <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'u'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'y'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nQuery OK<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token keyword\">rows</span> affected<span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span> sec<span class=\"token punctuation\">)</span>\nRecords: <span class=\"token number\">3</span> Duplicates: <span class=\"token number\">0</span> <span class=\"token keyword\">Warnings</span>: <span class=\"token number\">0</span>\n</code></pre>\n<p>那么这些记录已经按照主键值的大小串联成一个单向链表了，</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b9dc9c989a2c4179886b6a850882ccd4.png\"/></p>\n<p>从图中可以看出来，<code>index_demo</code> 表中的3条记录都被插入到编号为10的数据页中了。此时我们再来插入一条记录：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> index_demo <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>因为页10最多只能放3条记录，所以我们不得不再分配一个新页</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\54ef2dddef6c4a5484c19d45deb37c9a.png\"/></p>\n<p>注意，新分配的数据页编号可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，页10中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次记录移动，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9ac5bb6dca314de7997fe59f308992ad.png\"/></p>\n<p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为页分裂。</p>\n<ul><li>给所有的页建立一个目录项。</li></ul>\n<p>由于数据页的编号可能是不连续的，所以在向index_demo表中插入许多条记录后，可能是这样的效果:</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f6cb8f3deab14aeb81df997413f8b53a.png\"/></p>\n<p>因为这些16KB的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分:</p>\n<ul><li>页的用户记录中最小的主键值，我们用key来表示。</li><li>页号，我们用page_no表示。</li></ul>\n<p>所有我们为上边几个页做好的目录就像这个样子：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\169b91fb5ce54022a571ab5bc098318e.png\"/></p>\n<p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p>\n<ol><li> <p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。</p> </li><li> <p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p> </li></ol>\n<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p>\n<h5><a id=\"6322InnoDB_1375\"></a>6.3.2.2、InnoDB中的索引方案</h5>\n<p><strong>① 迭代1次：目录项纪录的页</strong></p>\n<pre><code class=\"prism language-markdown\"># 上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题:\n\n- InnoDB是使用页来作为管理存储空间的基本单位，最多能保证16KB的连续存储空间，而随着表中记录数量增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。\n\n- 我们时常会对记录进行增删，假设我们把页28中的记录都删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。\n</code></pre>\n<p>所以，我们需要一种可以灵活管理所有目录项的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项己录。那InnoDB怎么区分一条记录是普通的 用户记录还是目录项记录呢？使用记录头信息里的 record_type 属性，它的各个取值代表的意思如下:</p>\n<ul><li>0：普通的用户记录</li><li>1：目录项记录</li><li>2：最小记录</li><li>3：最大记录</li></ul>\n<p>把前边使用到的目录项放到数据页中：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\369626cce27947198fbd433365491c6e.png\"/></p>\n<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的 不同点 ：</p>\n<ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul>\n<p>相同点： 两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p>\n<p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>\n<ol><li> <p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</p> </li><li> <p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p> </li></ol>\n<p><strong>② 迭代2次：多个目录项纪录的页</strong></p>\n<p>虽然 目录项记录 中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页有16KB大小，能存放的目录项记录也是有限的，如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢?</p>\n<p>这里假设一个存储目录项记录的页最多只能存放4条目录项记录，如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储目录项记录的页:</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6615d76284d949f1b0484d935dcfcb52.png\"/></p>\n<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>\n<ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul>\n<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p>\n<ol><li> <p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p> </li><li> <p>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p> </li><li> <p>在真实存储用户记录的页中定位到具体的记录。</p> </li></ol>\n<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>\n<p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\beace953fc0c471fb615c68670683a91.png\"/></p>\n<p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，就是下面这种图</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\519c2142ec0a4b8493d5d09ec109167e.png\"/></p>\n<p>这个数据结构，它的名称是<code>B+树</code>。</p>\n<p>④ <strong>B+Tree</strong></p>\n<p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中B+树最上边的那个节点也称为根节点。</p>\n<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p>\n<ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul>\n<p>所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p>\n<h4><a id=\"633_1458\"></a>6.3.3、常见索引概念</h4>\n<p><strong>1、聚簇索引</strong></p>\n<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在叶子节点），也就是所谓的 索引即数据，数据即索引。</p>\n<p>特点：</p>\n<ol><li> <p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>\n<ul><li> <p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p> </li><li> <p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p> </li><li> <p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</p> </li></ul> </li><li> <p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p> <p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p> </li></ol>\n<p>优点：</p>\n<ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul>\n<p>缺点：</p>\n<ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个 自增ID列为主键</li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义 主键为不可更新</li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul>\n<p>限制：</p>\n<ul><li>对于Mysql数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只有一种，所以每个MySQL的 表只能有一个聚簇索引。 一般情况下就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择 非空的唯一所以 代替。如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，索引InnoDB表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID，MD5，HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul>\n<p><strong>2、二级索引（辅助索引、非聚簇索引）</strong></p>\n<p>聚簇索引只能在搜索条件为主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。如果想以别的列作为搜索条件该怎么办？</p>\n<p>答案：可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e4ea069612434725a582088dc9943830.png\"/></p>\n<p>这个B+树与聚簇索引有几处不同：</p>\n<ul><li>使用记录C2列的大小进行记录和页的排序，这包括三个方面的含义： \n  <ul><li>页内的记录是按照c2列的大小顺序排成一个 单向链表。</li><li>各个存放 用户记录的页 也是根据页中记录的c2列大小顺序排成一个 双向链表。</li><li>存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个 双向链表。</li></ul> </li><li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是c2列 + 主键这两个列的值。</li><li>目录项记录中不再是 主键+页号 的搭配，而变成了 C2列+页号的搭配。</li></ul>\n<p>所有如果想通过c2列的值查找某些记录的话就可以使用刚刚建好的这个B+树。</p>\n<pre><code class=\"prism language-markdown\"># 以查找c2列的值为4的记录为例，查找过程如下：\n1. 确定目录项记录页\n\t根据 根页面，也就是页44，可以快速定位到 目录项记录 所在的页为 页42（因为2&lt; 4 &lt;9）\n2. 通过目录项记录页确定用户记录真实所在的页。\n\t在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2&lt;4 ≤ 4, 所以确定实际存储用户记录的页在 页34 和页34中。\n3. 在真实存储用户记录的页中定位到具体的记录。\n \t到页34和页34中定位到具体的记录。\n4. 但是这个B+树的叶子节点中的记录只存储了c2和c1（主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。\n</code></pre>\n<p>概念：回表</p>\n<p>​ 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p>\n<pre><code class=\"prism language-markdown\"># 问题:为什么我们还需要一次回表操作呢?直接把完整的用户记录放到叶子节点不OK吗?\n\n# 回答:\n\t如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。\n\t因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引(英文名secondary index )，或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。\n</code></pre>\n<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f38c907f667144d4824e3fec27298b64.png\"/></p>\n<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>\n<ol><li>聚簇索引的叶子节点存储的就是我们的 数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序；</li><li>一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li></ol>\n<p><strong>3、联合索引</strong></p>\n<p>也可以同时为多个列建立索引，比方说想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p>\n<ul><li> <p>先把各个记录和页按照c2列进行排序。</p> </li><li> <p>在记录的c2列相同的情况下，采用c3列进行排序</p> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1727a0b59e904819a145a480e6facf4a.png\"/></p>\n<p>需要注意：</p>\n<ul><li>每条目录项记录都由c2、c3、页号三部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。</li><li>B+树 叶子节点 处的用户记录有c2、c3和主键c1列组成。</li></ul>\n<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>\n<ul><li> <p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p> </li><li> <p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p> </li></ul>\n<h4><a id=\"634InnoDBB_1571\"></a>6.3.4、InnoDB的B+树索引的注意事项</h4>\n<p><strong>1、根页面位置万年不动</strong></p>\n<p>前边为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p>\n<ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul>\n<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p>\n<p><strong>2、内节点中目录项记录的唯一性</strong></p>\n<p>B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p>\n<table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table>\n<p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6dc886d195b6498d8836e6791d2cdea0.png\"/></p>\n<p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p>\n<p>为了让新插入记录能找到自己在哪个页里，我们需要 保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。 所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>\n<ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul>\n<p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\61cec51f2f97402a92fd91c3c7e6b0e8.png\"/></p>\n<p>这样我们再插入记录<code>(9, 1, 'c')</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p>\n<p><strong>3、一个页面最少可以存储2条记录</strong></p>\n<p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p>\n<h3><a id=\"64MyISAM_1616\"></a>6.4、MyISAM中的索引方案</h3>\n<p>B树索引适用存储引擎如表所示：</p>\n<table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table>\n<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p>\n<p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p>\n<h4><a id=\"641MyISAM_1628\"></a>6.4.1、MyISAM索引的原理</h4>\n<p>InnoDB中索引即数据，也就是聚簇索引的那颗B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p>\n<ul><li>将表中的记录 按照记录的插入顺序 单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据也，有多少记录将往这个文件中塞多少记录就成了。由于在插入数据的时候并 没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</li><li>使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 主键值+数据记录地址 的组合。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\31f8417a6a7a4098892f3192a591c514.png\"/></p>\n<p>MYISAM 的索引文件仅仅保存数据记录的地址。 在MYISAM中，主键索引和二级索引（Secondary key）在结构中没有任何区别，只是主键索引要求key是唯一的 ，而二级索引的key可以重复。如果在col2上建立一个二级索引，则此索引的结构如下所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9ab0967bcb4a4935941c40855734df83.png\"/></p>\n<p>同样也是一颗B+Tree，data域保存数据记录的地址。-因此，MYISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>\n<h4><a id=\"642MyISAM_InnoDB_1643\"></a>6.4.2、MyISAM与 InnoDB对比</h4>\n<p>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</p>\n<p>两种引擎中索引的区别：</p>\n<p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。</p>\n<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p>\n<p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>\n<p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>\n<p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>\n<p>小结：</p>\n<ul><li>为什么不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</li><li>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一个B+Tree，非单调的主键会造成在插入新纪录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\46bdaa2ba80a44f08e4c4a5f6f3c7ad3.png\"/></p>\n<h3><a id=\"65_1666\"></a>6.5、索引的代价</h3>\n<p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>\n<ul><li>空间上的代价</li></ul>\n<p>​ 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>\n<ul><li>时间上的代价</li></ul>\n<p>​ 每次进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>\n<h3><a id=\"66MySQL_1678\"></a>6.6、MySQL数据结构选择的合理性</h3>\n<p>从MysQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果我们能让索引的数据结构尽量减少硬盘的IO操作，所消耗的时间也就越小。可以说，磁盘的I/0操作次数对索引的使用效率至关重要。</p>\n<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p>\n<h4><a id=\"661_1686\"></a>6.6.1、全表遍历</h4>\n<h4><a id=\"662Hash_1688\"></a>6.6.2、Hash结构</h4>\n<p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p>\n<p>Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p>\n<p>加速查找速度的数据结构，常见的有两类:</p>\n<p>（1）树，例如平衡二叉搜索树，查询/插入/修改/删除的平钧时间复杂度都是0(log2N) ;</p>\n<p>（2）哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是0( 1);</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4d22e53b1845431e880bd870263607d9.png\"/></p>\n<p>采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下一次查找，多次访问节点才能找到数据，中间需要多次I/O操作，从效率来说 Hash比B+树更快。</p>\n<p>在Hash的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[0…m-1]的槽位上。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5f547092083c43c996c9c78c90e1370a.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\898aed672a8c467397f4e6ac2e54af53.png\"/></p>\n<p>Hash结构效率高，为什么索引结构要设计成树型呢？</p>\n<ol><li>Hash索引仅能满足（=) (◇)和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为o(n);而树型的“有序\"”特性，依然能够保持o(log2N)的高效率。</li><li>Hash 索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</li><li>对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</li><li>对于等值查询来说，通常Hash 索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</li></ol>\n<p>Hash索引使用存储引擎：</p>\n<table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table>\n<p>Hash索引的适用性:</p>\n<p>Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引I效率更高，比如在键值型（Key-value）数据库中， Redis存储的核心就是 Hash表。</p>\n<p>MysQL中的Memory存储引擎支持 Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，架用Hash索引是个不错的选择。</p>\n<p>另外，InnoDB本身不支持 Hash索引，但是提供**自适应Hash索引(**Adaptive Hash lndex)。如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\aced9c29a5b741f28531f8bc17ee5a1e.png\"/></p>\n<p>采用自适应Hash索引目的是方便根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以明显提高数据的检索效率。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 查看是否开启了自适应 Hash</span>\n<span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%adaptive_hash_index'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"663_1740\"></a>6.6.3、二叉搜索树</h4>\n<p>如果利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>\n<pre><code class=\"prism language-markdown\">1. 二叉搜索树的特点\n\t- 一个节点只能有两个子节点，也就是一个节点度不能超过2\n\t- 左子节点&lt;根节点；右子节点&gt;=根节点\n2. 查找规则\n\t- 如果key大于根节点，则在右子树中进行查找；\n\t- 如果key小于根节点，则在左子树中进行查找；\n\t- 如果key等于根节点，就返回根节点\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\79ecd5412f6746c097db6350687346c2.png\"/></p>\n<p>但存在特殊情况，就是有时候二叉树的深度非常大。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4dbbf6a89cd44da796430406d688cd89.png\"/></p>\n<p>这棵树也属于二叉查找树，但是性能上已经退化成了一条链表了，查找数据的时间复杂度变成了O(n)，</p>\n<p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>\n<h4><a id=\"664AVL_1766\"></a>6.6.4、AVL树</h4>\n<p>为了解决上面二叉查找树退化成链表的问题，人们提出了 平衡二叉搜索树（Balanced Binary Tree）,又称为AVl树，它在二叉搜索树的基础上添加了约束：</p>\n<pre><code class=\"prism language-markdown\"># 它是一颗空树 或 它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树\n\n\n# 常见的平衡二叉树右很多种，包括了 平衡二叉搜索树、红黑树、树堆、伸展树。平衡二叉树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。\n</code></pre>\n<p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2575506b33ee44979400c9669ae83c9a.png\"/></p>\n<p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\72bc76ad24a7462bbd561eda9a7f53e4.png\"/></p>\n<h4><a id=\"665BTree_1785\"></a>6.6.5、B-Tree</h4>\n<p>B树的英文是Balance Tree，也就是 多路平衡查找树，简写为B-Tree（横杠表示这两个单词连起来，不是减号）。</p>\n<p>它的高度远小于平衡二叉树的高度。</p>\n<p>B 树的结构如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\04e6b72f64b54d60a3a77d7a88b1ec5d.png\"/></p>\n<pre><code class=\"prism language-markdown\">B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，`M称为B树的阶`。每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是×+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。\n</code></pre>\n<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>\n<ol><li> <p>根节点的儿子数的范围是 [2,M]。</p> </li><li> <p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。</p> </li><li> <p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</p> </li><li> <p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p> </li><li> <p>所有叶子节点位于同一层。-+</p> </li></ol>\n<pre><code class=\"prism language-markdown\"># 上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。\n\n然后我们来看下如何用 B 树进行查找。假设我们想要`查找的关键字是 9`，那么步骤可以分为以下几步：\n   1.我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； \n   2.按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； \n   3.按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。\n</code></pre>\n<p>B 树的搜索过程中，比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p>\n<p><strong>小结：</strong></p>\n<ul><li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d5b2e038cda745ae883f075713468d16.png\"/></p>\n<h4><a id=\"666BTree_1830\"></a>6.6.6、B+Tree</h4>\n<p>B+树也是一种多路搜索树，基于B树做了改进，主流的DBMS都支持B+树的索引方式，比如MySQL，相比于B-Tree，B+Tree适合文件索引系统。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\868e56a99ac04cb0a66665e268b06d5f.png\"/></p>\n<p>B+树和 B-树的差异：</p>\n<ol><li> <p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</p> </li><li> <p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p> </li><li> <p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。</p> </li><li> <p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p> </li></ol>\n<pre><code class=\"prism language-markdown\"># B+树和B树的查询过程差不多，根本差异在于B+树的中间节点并不直接存储数据，这样有什么好处？\n\n- 首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。\n\n- 其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/O 也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。\n\n- 不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。\n</code></pre>\n<blockquote>\n<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p>\n<p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>\n</blockquote>\n<pre><code class=\"prism language-markdown\"># 思考题：为了减少IO，索引树会一次性加载吗？ \n 1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。\n 2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。\n\n# 思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO\n- InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）\n\n- 实际情况中每个节点可能不能填充满，因此在数据库中，`B+Tree的高度一般都在2~4层`。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作\n\n# 思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ \n1. B+树的磁盘读写代价更低\n\tB+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。\n2. B+树的查询效率更加稳定\n\t由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n\n# 思考题：Hash索引与B+树索引的区别 \n\t1、Hash索引`不能进行范围查询`，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。\n\t2、Hash索引`不支持联合索引的最左侧原则`（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。\n\t3、Hash索引`不支持 ORDER BY 排序`，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行`模糊查询`，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。\n\t4、`InnoDB不支持哈希索引`\n</code></pre>\n<h4><a id=\"667R_1883\"></a>6.6.7、R树</h4>\n<h4><a id=\"668_1885\"></a>6.6.8、小结</h4>\n<p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利(提升查询效率）和弊（维护索引所需的代价）。</p>\n<p>在实际工作中，还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。</p>\n<h2><a id=\"InnoDB_1893\"></a>七、InnoDB数据存储结构</h2>\n<h3><a id=\"71_1895\"></a>7.1、数据库的存储结构：页</h3>\n<p>索引结构提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>\n<p><code>InnoDB</code>是MySQL的<code>默认存储引擎</code>。</p>\n<h4><a id=\"711_1901\"></a>7.1.1、磁盘与内存交互基本单位：页</h4>\n<p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p>\n<p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说， 在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。 一个页中可以存储多个行记录。</p>\n<blockquote>\n<p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\90330086ec7e42bd8b0a008cec75f3da.png\"/></p>\n<h4><a id=\"712_1911\"></a>7.1.2、页结构概述</h4>\n<p>页a、页b、页c…页n 这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p>\n<h4><a id=\"713_1915\"></a>7.1.3、页的大小</h4>\n<p>不同的数据库管理系统（DBMS）的页大小不同。比如在MySQL的InnoDB存储引擎中，默认页的大小是16KB</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 通过下面的命令来进行查看；</span>\n<span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%innodb_page_size%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"714_1924\"></a>7.1.4、页的上层结构</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5aa996f60b3a4371aebc7e0722ff29d3.png\"/></p>\n<p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。</p>\n<p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>\n<p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p>\n<h3><a id=\"72_1934\"></a>7.2、页的内部结构</h3>\n<p>页如果按类型划分的话，常见的有 数据页（保存 B+ 树节点）、系统页、Undo 页 和事务数据页等。数据页是最常使用的页。</p>\n<p>数据页的16KB大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum+supermum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\6dba22f961284808bf24025cdd9a2f2e.png\"/></p>\n<p>这七部分的作用如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\919e13789a9341c184bd47bbaa28b9c3.png\"/></p>\n<h4><a id=\"7211_1946\"></a>7.2.1、第1部分：文件头部和文件尾部</h4>\n<h5><a id=\"7211File_Header_1948\"></a>7.2.1.1、File Header(文件头)</h5>\n<p><strong>文件头部信息</strong></p>\n<p>不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页，下一个页是谁等，所有的数据页会组成一个双链表。这个部分占用固定的38字节，是中下边这些内容组成的：</p>\n<table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table>\n<p><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</p>\n<p><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c4ff246cc68a486ebb0005f552fd3705.png\"/></p>\n<p>存放记录的数据页的类型其实是<code>FIL_PAGE_INDEX</code>， 也就是所谓的 索引页 。</p>\n<p><strong>数据页的链接实现</strong></p>\n<p>在文件头部内容中有两个属性：<code>FIL_PAGE_PREV和FIL_PAGE_NEXT</code></p>\n<p>InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT 就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间 不需要是物理上的连续，而是逻辑上的连续。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3cd8f68727b24b848ee50d4651c0f538.png\"/></p>\n<p><strong>检验页的完整性</strong></p>\n<pre><code class=\"prism language-markdown\"># 什么是校验和?\n\n- 就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。\n- 在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。\n</code></pre>\n<p>文件头部和文件尾部都有：<code>FIL_PAGE_SPACE_OR_CHKSUM</code></p>\n<p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p>\n<p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p>\n<p><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</p>\n<h5><a id=\"7212File_Trailer_1998\"></a>7.2.1.2、File Trailer（文件尾部）</h5>\n<ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li></ul>\n<h4><a id=\"7222_2003\"></a>7.2.2、第2部分：空闲空间、用户记录和最小最大记录</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\071db2bfb0094496bd7fafa7ef4458fd.png\"/></p>\n<h5><a id=\"7221Free_Space__2007\"></a>7.2.2.1、Free Space (空闲空间)</h5>\n<p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e1255e13764b42a8bc95a5fada34dbcd.png\"/></p>\n<h5><a id=\"7222User_Records__2013\"></a>7.2.2.2、User Records (用户记录)</h5>\n<p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p>\n<p>具体看7.3.2.3 记录头信息 章节。</p>\n<h5><a id=\"7223Infimum__Supremum_2019\"></a>7.2.2.3、Infimum + Supremum（最小最大记录）</h5>\n<p>记录可以比较大小吗 ？</p>\n<p>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p>\n<p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b8b9b812205d4b9a9518c749b3dedf6e.png\"/></p>\n<p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8b6ffaca15884f468e19d097556b9c09.png\"/></p>\n<h4><a id=\"7233_2033\"></a>7.2.3、第3部分：页目录和页面头部</h4>\n<h5><a id=\"7231Page_Directory_2035\"></a>7.2.3.1、Page Directory（页目录）</h5>\n<p>为什么需要页目录 ？</p>\n<p>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p>\n<pre><code class=\"prism language-markdown\"># 方式1：顺序查找\n- 从Infimum记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到），在找的时候还能投机取巧，因为链表中各个记录的值是从小到大顺序排序的，所有当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。\n\n如果一个页中存储了非常多的记录，这么查找性能很差。\n\n# 方式2；使用页目录，二分法查找 \n1. 将所有的记录`分成几个组`，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。\n2. 第 1 组，也就是最小记录所在的分组只有 1 个记录；\n   最后一组，就是最大记录所在的分组，会有 1-8 条记录；\n   其余的组记录数量在 4-8 条之间。\n这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会`尽量平分`。\n3. 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。\n4. `页目录用来存储每组最后一条记录的地址偏移量`，这些地址偏移量会按照`先后顺序存储`起来，每组的地址偏移量也被称之为`槽（slot）`，每个槽相当于指针指向了不同组的最后一个记录。\n</code></pre>\n<p>举例：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1e5611f862445ea9906016ceaee3d30.png\"/></p>\n<p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\208dd57dd8ca4632b502353e6e317372.png\"/></p>\n<p>从这个图中我们需要注意这么几点：</p>\n<ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性 \n  <ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul> </li></ul>\n<p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c25378ec004a47728d50414cb274cb20.png\"/></p>\n<p>页目录分组的个数如果确定？</p>\n<p>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</p>\n<p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1~8条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。</p>\n<p>分组是按照下边的步骤进行的：</p>\n<ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul>\n<p>页目录结构下如何快速查找记录？</p>\n<pre><code class=\"prism language-markdown\"># 比方说我们想找主键值为6的记录，过程是这样的：\n1. 计算中间槽的位置:(O+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt;6，所以设置high=2，low保持不变。\n2. 重新计算中间槽的位置:(O+2)/2=1，所以查看槽1对应的主键值为4，又因为4&lt;6，所以设置low=1，high保持不变。\n3. 因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。\n\n\t但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢?别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录(主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。\n\t\n由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。\n</code></pre>\n<p>小结：</p>\n<p>在一个数据页中查找指定主键值的记录的过程分为两步：</p>\n<ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ol>\n<h5><a id=\"7232Page_Header_2108\"></a>7.2.3.2、Page Header（页面头部）</h5>\n<p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>\n<table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table>\n<p>PAGE_DIRECTION：假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来标识最后一条记录插入方向的状态就是PAGE_DIRECTION。</p>\n<p>PAGE_DIRECTION：假设连续几次插入新纪录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_DIRECTION这个状态标表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p>\n<h5><a id=\"B_2133\"></a>从数据页的角度看B+树如何查询</h5>\n<p>一颗B+树按照节点类型可以分成两部分：</p>\n<ol><li>叶子节点，B+树最底层的节点，节点的高度为0，存储行记录。</li><li>非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f1a5634cbcf84c7985124ebce19144a6.png\"/></p>\n<p>当我们从页结构来理解B+树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p>\n<ol><li> <p><strong>B+树是如何进行记录检索的？</strong></p> <p>如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用 二分查找 的方式先找到一个粗略的记录分组，然后再在分组汇总通过链表遍历的方式查找记录。</p> </li><li> <p><strong>普通索引和唯一索引在查询效率上有什不同？</strong></p> <p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p> <p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上千条记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。</p> </li></ol>\n<h3><a id=\"73InnoDB_2154\"></a>7.3、InnoDB行格式（或记录格式）</h3>\n<p>我们平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为‘ 行格式 ’ 或者 ‘记录格式’。InnoDB存储引擎设计了4种不同类型的‘ 行格式 ’，分别是‘ Compact’，’Redundant‘，’Dynamic‘’和’ compressed‘行格式。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 查看Mysql8的默认行格式</span>\n<span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@innodb_default_row_format</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># 也可以使用如下语法查看具体表使用的行格式；</span>\n<span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'表名'</span>\\G\n</code></pre>\n<h4><a id=\"731_2166\"></a>7.3.1、指定行格式的语法</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名 <span class=\"token punctuation\">(</span>列的信息<span class=\"token punctuation\">)</span> ROW_FORMAT<span class=\"token operator\">=</span>行格式名称\n\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> 表名 ROW_FORMAT<span class=\"token operator\">=</span>行格式名称\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> record_test_table<span class=\"token punctuation\">(</span>\n\tcol1 <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    col2 <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    col3 <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    col4 <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">CHARSET</span> <span class=\"token operator\">=</span> ASCII ROW_FORMAT<span class=\"token operator\">=</span>CPMPACT<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> record_test_table<span class=\"token punctuation\">(</span>col1<span class=\"token punctuation\">,</span> col2<span class=\"token punctuation\">,</span> col3<span class=\"token punctuation\">,</span> col4<span class=\"token punctuation\">)</span><span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'lisi'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'wangwu'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'songhk'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token string\">'tong'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'chen'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"732COMPACT_2185\"></a>7.3.2、COMPACT行格式</h4>\n<p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9c13208c0ddd43c782952aba13010d70.png\"/></p>\n<h5><a id=\"7321_2191\"></a>7.3.2.1、变长字段长度列表</h5>\n<p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p>\n<blockquote>\n<p>注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p>\n</blockquote>\n<p>以record_test_table表中的第一条记录举例：因为record_test_table表的col1、col2、col2列都是VARCHAR(8)类型的，所以这三个列的值的长度都需要保存在记录开头处，注意record_test_table表中的各个列都使用的是ascii字符集（每个字符只需要1个字节来进行编码）。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\34e7c3f09c0a457ca760ff969c815a17.png\"/></p>\n<p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开知识方便理解）：06 04 08</p>\n<p>把这个节点串组成的变长字段长度列表填入上边的示意图中的效果就是：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\41b4ed7bc8e14d718705b7db760eee0c.png\"/></p>\n<h5><a id=\"7322NULL_2207\"></a>7.3.2.2、NULL值列表</h5>\n<p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。</p>\n<p><strong>为什么定义NULL值列表？</strong></p>\n<p>之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p>\n<ol><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ol>\n<blockquote>\n<p>注意：同样顺序也是反过来存放的</p>\n</blockquote>\n<p>例如:字段a、b、c，其中a是主键，在某一行中存储的数依次是a=1、b=null、c=2。那么Compact行格式中的NULL值列表中存储:01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</p>\n<p>record_test_table的两条记录的NULL值列表就如下:</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e445456191264d4a918314ca1a890d69.png\"/></p>\n<h5><a id=\"73235_2226\"></a>7.3.2.3、记录头信息（5字节）</h5>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2f625400ad3c4faa85c9a72058f49a95.png\"/></p>\n<p>这些记录头信息中各个属性如下：</p>\n<table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> page_demo <span class=\"token keyword\">VALUES</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span><span class=\"token string\">'song'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span><span class=\"token string\">'tong'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">300</span><span class=\"token punctuation\">,</span><span class=\"token string\">'zhan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"list\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\acafda96b56446618b8162926f2ff4c0.png\"/></p>\n<ul><li><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。 \n  <ul><li>值为0：代表记录并没有被删除</li><li>值为1：代表记录被删除掉了</li></ul> </li></ul>\n<pre><code class=\"prism language-markdown\"># 被删除的记录为什么还在页中存储呢？ \n- 你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要`重新排列，导致性能消耗`。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。\n</code></pre>\n<ul><li><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</li><li><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录： \n  <ul><li>0：表示普通记录</li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录</li><li>3：表示最大记录</li></ul> </li><li><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</li></ul>\n<pre><code class=\"prism language-markdown\"># 怎么不见heap_no值为0和1的记录呢 ？\n- MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为`伪记录`或者`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前\n</code></pre>\n<ul><li><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</li></ul>\n<p>比如:第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。</p>\n<p>注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是<br/> Supremum记录（也就是最大记录）。下图用箭头代替偏移量表示next_record。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\451a35dcdbe246e1826216b9bd9ef7bc.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cf2be1b7ede241c68000e4e3f7376e2f.png\"/></p>\n<p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p>\n<ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1.</li><li>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了</li><li>第1条记录的next_record指向了第3条记录</li><li>最大记录的n_owned值从5变成了4.</li></ul>\n<p>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d89715a071fb4979844ceaa718aa058b.png\"/></p>\n<h5><a id=\"7324_2295\"></a>7.3.2.4、记录的真实数据</h5>\n<table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table>\n<p>实际上这几个列的真正名称是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。</p>\n<ul><li>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</li></ul>\n<h4><a id=\"733DynamicCompressed_2307\"></a>7.3.3、Dynamic和Compressed行格式</h4>\n<h5><a id=\"_2309\"></a>行溢出</h5>\n<p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p>\n<pre><code class=\"prism language-markdown\">- 很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗?如果我们使用ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。\n\nCREATE TABLE varchar_size_demo(\n\tc VARCHAR(65535)\n)CHARSET=ascii ROW_FORMAT=Compact;\n\n- 结果如下:\nERROR 1118(42000):Row size too large.The maximum row size for the used tabletype, not counting BLOBs, is 65535. This includes storage overhead, check the manual.You have to change some columns tp TEXT or BLOBs\n\n报错信息表达的意思是:MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。\n\n这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。\n\n如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用2个字节，NULL值标识需要1个字节。\nCREATE TABLE varchar_size_demo(\n\tc VARCHAR(655352)\n)CHARSET=ascii ROW_FORMAT=Compact;\n如果有not null属性，那么久不需要NULL值标识，也就是可以多存储一个字节，即65533个字节\nCREATE TABLE varchar_size_demo(\n\tc VARCHAR(65533)\n)CHARSET=ascii ROW_FORMAT=Compact;\n</code></pre>\n<p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p>\n<p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b13411faaead4fb58e21202b69b27304.png\"/></p>\n<p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p>\n<ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul>\n<p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8b67d37287694adc9c625b9322bd6ee4.png\"/></p>\n<h4><a id=\"734Redundant_2352\"></a>7.3.4、Redundant行格式</h4>\n<p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式,MySQL 5.0支持Redundant是为了兼容之前版本的页格式。</p>\n<p>现在我们把表record_test_table的行格式修改为Redundant:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> record_test_table ROW_FORMAT<span class=\"token operator\">=</span>Redundant<span class=\"token punctuation\">;</span>\nQuery OK<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token keyword\">rows</span> affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.05</span> sec<span class=\"token punctuation\">)</span>\nRecords: <span class=\"token number\">0</span> Duplicates: o <span class=\"token keyword\">Warnings</span>: <span class=\"token number\">0</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\10e7c2819f7f4ecf93b7c2791ad61076.png\"/></p>\n<p>从上图可以看到，不同于Compact行记录格式，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。</p>\n<p>注意Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同:</p>\n<ul><li>少了“变长”两个字:Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。</li><li>多了“偏移”两个字:这意味着计算列值长度的方式不像Compact行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</li></ul>\n<p>举例:比如第一条记录的字段长度偏移列表就是:</p>\n<p>2B 25 1F 1B13 0C 06</p>\n<p>因为它是逆序排放的，所以按照列的顺序排列就是:</p>\n<p>06 0C 1317 1A24 25</p>\n<p>按照两个相邻数值的差值来计算各个列值的长度的意思就是:</p>\n<ul><li>第一列(row_id)的长度就是Ox06个字节，也就是6个字节。</li><li>第二列(transaction_id)的长度就是(OxOC- 0x06)个字节，也就是6个字节。</li><li>第三列(roll_pointer)的长度就是(Ox13 - oxOC)个字节，也就是7个字节。</li><li>第四列(col1)的长度就是(Ox1B- Ox13)个字节，也就是8个字节。</li><li>第五列(col2)的长度就是(Ox1F - Ox1B)个字节，也就是4个字节。</li><li>第六列(col3)的长度就是(Ox25 - Ox1F)个字节，也就是6个字节。</li><li>第七列(col4)的长度就是(Ox2B - Ox25)个字节，也就是6个字节。</li></ul>\n<p>不同于Compact行格式，Redundant行格式中的记录头信息固定占用6个字节(48位)，每位的含义见下表。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c3344a9ac3fe4415bb192de64c4e1742.png\"/></p>\n<p>与Compact行格式的记录头信息对比来看，有两处不同:</p>\n<ul><li>Redundant行格式多了n_field和1byte_offs_flag这两个属性。</li><li>Redundant行格式没有record_type这个属性。</li></ul>\n<p>其中，n_fields:代表一行中列的数量，占用10位，这也很好地解释了为什么MySQL一个行支持最多的列为1023。另一个值为1byte_offs_flags，该值定义了偏移列表占用1个字节还是2个字节。当它的值为1时，表明使用1个字节存储。当它的值为0时，表明使用2个字节存储。</p>\n<h3><a id=\"74_2406\"></a>7.4、区、段和碎片区</h3>\n<h4><a id=\"741_2408\"></a>7.4.1、为什么要有区？</h4>\n<p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p>\n<p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，<code>功大于过</code>！</p>\n<h4><a id=\"742_2414\"></a>7.4.2、为什么要有段？</h4>\n<p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p>\n<p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p>\n<p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p>\n<p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>\n<h4><a id=\"743_2424\"></a>7.4.3、为什么要有碎片区？</h4>\n<p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以 默认情况下一个只存在几条记录的小表也需要2M的存储空间么？ 以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p>\n<p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p>\n<p>所以此后为某个段分配存储空间的策略是这样的：</p>\n<ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul>\n<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>已经<code>一些完整的区</code>的集合。</p>\n<h4><a id=\"744_2437\"></a>7.4.4、区的分类</h4>\n<p>区大体上可以分为4种类型：</p>\n<ul><li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li></ul>\n<p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p>\n<h3><a id=\"75_2450\"></a>7.5、表空间</h3>\n<p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>\n<p>表空间是一个 <code>逻辑容器</code> ，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为 <code>系统表空间（System tablespace）</code> 、<code>独立表空间（File-per-table tablespace）</code>、<code>撤销表空间（Undo Tablespace）</code> 和 <code>临时表空间（Temporary TableSpace）</code>等。</p>\n<h4><a id=\"751_2456\"></a>7.5.1、独立表空间</h4>\n<p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即：单表）可以在不同的数据库之间进行 <code>迁移</code>。</p>\n<p>空间可以回收(DROP TABLE操作可自动回收表空间;其他情况，表空间不能自己回收)。如果对于统计分析或是日志表，删除大量数据后可以通过: alter table TableName engine=innodb;回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>\n<p><strong>独立表空间结构</strong></p>\n<p>独立表空间由段、区、页组成。前面已经讲解过了。</p>\n<p><strong>真实表空间对应的文件大小</strong></p>\n<p>我们到数据目录里看，会发现一个新建的表对应的.ibd文件只占用了96K，才6个页面大小(MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些.ibd文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 查看InnoDB的表空间类型</span>\n<span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_file_per_table'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>你能看到 innodb_file_per_table=ON，这就意味着每张表都会单独保存为一个 .ibd 文件。</p>\n<h4><a id=\"752_2477\"></a>7.5.2、系统表空间</h4>\n<p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面,这部分是独立表空间中没有的。</p>\n<p><strong>InnoDB数据字典</strong></p>\n<p>每当我们向一个表中插入一条记录的时候，MySQL校验过程如下:</p>\n<p>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说:</p>\n<pre><code class=\"prism language-markdown\">- 某个表属于哪个表空间，表里边有多少列\n- 表对应的每一个列的类型是什么\n- 该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面\n- 该表有哪些外键,外键对应哪个表的哪些列\n- 某个表空间对应文什系统上文件路径是什么\n</code></pre>\n<p>上述这些数据并不是我们使用INSERT语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为 <code>元数据</code>，InnoDB存储引擎特意定义了一系列的 <code>内部系统表（Internal System table）</code>来记录这些元数据：</p>\n<table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIRTUAL</td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr></tbody></table>\n<p>这些系统表也被称为数据字典，它们都是以B+树的形式保存在系统表空间的某些页面中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS这四个表尤其重要，称之为基本系统表(basic system tables)</p>\n<p>注意：用户是不能直接访问InnoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库information_schema中提供了一些以innodb_sys开头的表:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">USE</span> information_schema<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">TABLES</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'innodb_sys%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"_2520\"></a>八、索引的创建与设计原则</h2>\n<h3><a id=\"81_2522\"></a>8.1、索引的声明与使用</h3>\n<h4><a id=\"811_2524\"></a>8.1.1、索引的分类</h4>\n<p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>\n<ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li></ul>\n<ol><li> <p>普通索引</p> <p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p> </li><li> <p>唯一性索引</p> <p>使用 <code>UNIQUE参数</code> 可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p> </li><li> <p>主键索引</p> <p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，一张表里最多只有一个主键索引。why?这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p> </li><li> <p>单列索引</p> <p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p> </li><li> <p>多列(组合、联合)索引</p> <p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name.gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p> </li><li> <p>全文索引</p> <p>全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p> <p>使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p> <p>全文索引典型的有两种类型:自然语言的全文索引和布尔全文索引。</p>\n<ul><li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li></ul> <p>MySQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。在5.7.6版本，MySQL内置了ngram全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MysQL版本、存储引擎和数据类型是否支持全文索引。</p> <p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr、 ElasticSearch等专门的搜索引擎所替代。</p> </li><li> <p>空间索引</p> <p>使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p> </li></ol>\n<p>小结:不同的存储引擎支持的索引类型也不一样</p>\n<ul><li>lnnoDB:支持 B-tree、Full-text 等索引，不支持Hash索引;</li><li>MylSAM:支持B-tree、Full-text等索引，不支持Hash索引;</li><li>Memory :支持B-tree、Hash等索引，不支持Full-text索引;</li><li>NDB :支持Hash 索引，不支持B-tree、Full-text等索引;</li><li>Archive :不支持B-tree、Hash、Full-text等索引;</li></ul>\n<h4><a id=\"812_2578\"></a>8.1.2、创建索引</h4>\n<p>MySQL支持多种方法在单个或多个列上创建索引:在创建表的定义语句CREATE TABLE中指定索引列，使用ALTER TABLE语句在存在的表上创建索引，或者使用CREATE INDEX语句在已存在的表上添加索引。</p>\n<h5><a id=\"1__2582\"></a>1. 创建表的时候创建索引</h5>\n<p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束,而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引（隐式创建）。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 举例:</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> dept<span class=\"token punctuation\">(</span>\n    dept_id <span class=\"token keyword\">INT</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n    dept_name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> emp<span class=\"token punctuation\">(</span>\n    emp_id <span class=\"token keyword\">INT</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n    emp_name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span><span class=\"token punctuation\">,</span>\n    dept_id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">CONSTRAINT</span> emp_dept_id_fk <span class=\"token keyword\">FOREIGN</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">(</span>dept_id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">REFERENCES</span> dept<span class=\"token punctuation\">(</span> dept_id<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>但是，如果显式创建表时创建索引的话，基本语法格式如下:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> table_name <span class=\"token punctuation\">[</span>col_name data_type<span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">[</span><span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">|</span> FULLTEXT <span class=\"token operator\">|</span> SPATIAL<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">INDEX</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>index_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>col_name <span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">ASC</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<ul><li> <p><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</p> </li><li> <p><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</p> </li><li> <p><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</p> </li><li> <p><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</p> </li><li> <p><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p> </li><li> <p><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</p>\n<ol><li>创建普通索引</li></ol> </li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> book<span class=\"token punctuation\">(</span> \n    book_id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> \n    book_name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    authors <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    info <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">comment</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    year_publication <span class=\"token keyword\">YEAR</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">INDEX</span><span class=\"token punctuation\">(</span>year_publication<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#查看索引</span>\n<span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> book<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">INDEX</span> <span class=\"token keyword\">FROM</span> book<span class=\"token punctuation\">;</span> \n</code></pre>\n<pre><code>2.   创建唯一索引 \n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test1<span class=\"token punctuation\">(</span> \n    id <span class=\"token keyword\">INT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    name <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">INDEX</span> uk_idx_id<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"3\"><li>主键索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token punctuation\">(</span> \n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span> \n    student_no <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    student_name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 删除主键索引</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">drop</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"4\"><li>创建单列索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test2<span class=\"token punctuation\">(</span> \n    id <span class=\"token keyword\">INT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    name <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">INDEX</span> single_idx_name<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"5\"><li>创建组合索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test3<span class=\"token punctuation\">(</span> \n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    name <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    age <span class=\"token keyword\">INT</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    info <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">INDEX</span> multi_idx<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"6\"><li>创建全文索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>papers<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span> \n    id<span class=\"token identifier\"><span class=\"token punctuation\">`</span> int(10) unsigned NOT NULL AUTO_INCREMENT, \n    <span class=\"token punctuation\">`</span></span>title<span class=\"token identifier\"><span class=\"token punctuation\">`</span> varchar(200) DEFAULT NULL, \n    <span class=\"token punctuation\">`</span></span>content<span class=\"token identifier\"><span class=\"token punctuation\">`</span> text, \n    PRIMARY KEY (<span class=\"token punctuation\">`</span></span>id<span class=\"token identifier\"><span class=\"token punctuation\">`</span>), \n    FULLTEXT KEY <span class=\"token punctuation\">`</span></span>title<span class=\"token identifier\"><span class=\"token punctuation\">`</span> (<span class=\"token punctuation\">`</span></span>title<span class=\"token identifier\"><span class=\"token punctuation\">`</span>,<span class=\"token punctuation\">`</span></span>content<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span>MyISAM <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#全文索引用match+against方式查询：</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> papers <span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">MATCH</span><span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">,</span>content<span class=\"token punctuation\">)</span> AGAINST <span class=\"token punctuation\">(</span><span class=\"token string\">'查询字符串'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"7\"><li>创建空间索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test5<span class=\"token punctuation\">(</span> \n    geo <span class=\"token keyword\">GEOMETRY</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span> \n    SPATIAL <span class=\"token keyword\">INDEX</span> spa_idx_geo<span class=\"token punctuation\">(</span>geo<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span>MyISAM<span class=\"token punctuation\">;</span>\n</code></pre>\n<h5><a id=\"2__2709\"></a>2. 在已经存在的表上创建索引</h5>\n<ol><li>使用ALTER TABLE语句创建索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> table_name \n<span class=\"token keyword\">ADD</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">|</span> FULLTEXT <span class=\"token operator\">|</span> SPATIAL<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">INDEX</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>index_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>col_name<span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">ASC</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<ol start=\"2\"><li>使用CREATE INDEX创建索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">|</span> FULLTEXT <span class=\"token operator\">|</span> SPATIAL<span class=\"token punctuation\">]</span> <span class=\"token keyword\">INDEX</span> index_name \n<span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">(</span>col_name<span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">ASC</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<h4><a id=\"8_13_2725\"></a>8. 1.3、删除索引</h4>\n<ol><li>使用ALTER TABLE删除索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> table_name <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> index_name<span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>使用DROP INDEX语句删除索引</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> table_name<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>提示：</p>\n<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>\n<h3><a id=\"82MySQL80_2743\"></a>8.2、MySQL8.0索引新特性</h3>\n<h4><a id=\"821_2745\"></a>8.2.1、支持降序索引</h4>\n<p>降序索引以降序存储键值。虽然在语法上，从MysQL 4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的，直到MysQL 8.x版本才开始真正支持降序索引(仅限于InnoDB存储引擎）。</p>\n<p>MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p>\n<p>举例:分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> ts1<span class=\"token punctuation\">(</span>a <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>b <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">index</span> idx_a_b<span class=\"token punctuation\">(</span>a <span class=\"token keyword\">asc</span><span class=\"token punctuation\">,</span>b <span class=\"token keyword\">desc</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在MySQL 5.7版本中查看数据ts1的结构，如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\92c4dc9a735a4166a8dba0fbd1fec53e.png\"/></p>\n<p>从结果中可以看出，索引仍然是默认的升序。</p>\n<p>在MySQL8.0版本中查看数据ts1的结构，如下：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c5a54f7d38f748d398c2dcdac68dc549.png\"/></p>\n<p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p>\n<p>分别在MySQL 5.7版本和MySQL 8.o版本的数据表ts1中插入8oo条随机数据，执行语句如下:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">DELIMITER</span> <span class=\"token comment\">//</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> ts_insert<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n\t<span class=\"token keyword\">DECLARE</span> i <span class=\"token keyword\">INT</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">WHILE</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">880</span>\n\t<span class=\"token keyword\">DO</span>\n\t\t<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> ts1 <span class=\"token keyword\">select</span> rand<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">80080</span><span class=\"token punctuation\">,</span> rand <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">80000</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">END</span> <span class=\"token keyword\">WHILE</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">commit</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span> <span class=\"token comment\">//</span>\n<span class=\"token keyword\">DELIMITER</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#调用</span>\n<span class=\"token keyword\">CALL</span> ts_insert<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在MySQL5.7版本中查看数据表ts1的执行计划，结果如下：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> ts1 <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> a<span class=\"token punctuation\">,</span>b <span class=\"token keyword\">DESC</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。</p>\n<blockquote>\n<p>提示</p>\n<p>Using filesort是MysQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。</p>\n</blockquote>\n<p>在MysQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Usingfilesort。</p>\n<blockquote>\n<p>注意</p>\n<p>降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为ORDER BY a DESC, b DESC，MYSQL5.7自执行计划要明显好于MySQL 8.0.</p>\n</blockquote>\n<p>将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。</p>\n<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> ts1 <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> a <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">,</span> b <span class=\"token keyword\">DESC</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在MySQL 8.0版本中查看数据表ts1的执行计划。</p>\n<p>从结果可以看出，修改后MySQL 5.7.的执行计划要明显好于MySQL 8.0。</p>\n<h4><a id=\"822_2819\"></a>8.2.2、隐藏索引</h4>\n<p>在MysQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>\n<p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p>\n<p>同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引</p>\n<blockquote>\n<p>注意:</p>\n<p>主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p>\n</blockquote>\n<p>索引默认是可见的，在使用CREATE TABLE，CREATE INDEX或者ALTER TABLE等语句时可以通过VISIBLE或者INVISIBLE关键词设置索引的可见性。</p>\n<ol><li>创建表时直接创建</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> tablename<span class=\"token punctuation\">(</span> \n    propname1 type1<span class=\"token punctuation\">[</span>CONSTRAINT1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n    propname2 type2<span class=\"token punctuation\">[</span>CONSTRAINT2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n    ……\n    propnamen typen<span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">INDEX</span> <span class=\"token punctuation\">[</span>indexname<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>propname1 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> INVISIBLE\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>在已经存在的表上创建</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> indexname \n<span class=\"token keyword\">ON</span> tablename<span class=\"token punctuation\">(</span>propname<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> INVISIBLE<span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"3\"><li>通过ALTER TABLE语句创建</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> tablename \n<span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> indexname <span class=\"token punctuation\">(</span>propname <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> INVISIBLE<span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"4\"><li>切换索引可见状态</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> tablename <span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">INDEX</span> index_name INVISIBLE<span class=\"token punctuation\">;</span> <span class=\"token comment\">#切换成隐藏索引 </span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> tablename <span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">INDEX</span> index_name VISIBLE<span class=\"token punctuation\">;</span>   <span class=\"token comment\">#切换成非隐藏索引</span>\n</code></pre>\n<p>注意</p>\n<p>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>\n<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>\n<ol start=\"5\"><li>使隐藏索引对查询优化器可见</li></ol>\n<p>在MysQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关(use_invisible_indexes)来打开某个设置，使隐藏索引对查询优化器可见。如果use_invisible_indexes 设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。</p>\n<p>(1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">select</span> @<span class=\"token variable\">@optimizer_switch</span> \\G\n</code></pre>\n<p>在输出的结果信息中找到如下属性配置。</p>\n<pre><code class=\"prism language-sql\">use_invisible_indexes<span class=\"token operator\">=</span><span class=\"token keyword\">off</span>\n</code></pre>\n<p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p>\n<p>(2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令:</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> <span class=\"token keyword\">session</span> optimizer_switch<span class=\"token operator\">=</span><span class=\"token string\">\"use_invisible_indexes=on\"</span><span class=\"token punctuation\">;</span>\nQuery oK<span class=\"token punctuation\">,</span><span class=\"token number\">0</span> <span class=\"token keyword\">rows</span> affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.80</span> sec<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>SQL语句执行成功，再次查看查询优化器的开关设置。</p>\n<h3><a id=\"83_2899\"></a>8.3、索引的设计原则</h3>\n<p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>\n<h4><a id=\"831_2903\"></a>8.3.1、哪些情况适合创建索引</h4>\n<ol><li><strong>字段的数值有唯一性的限制</strong></li></ol>\n<p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p>\n<blockquote>\n<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>\n<p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>\n</blockquote>\n<ol start=\"2\"><li><strong>频繁作为 WHERE 查询条件的字段</strong></li></ol>\n<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>\n<ol start=\"3\"><li><strong>经常 GROUP BY 和 ORDER BY的列</strong></li></ol>\n<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p>\n<ol start=\"4\"><li><strong>UPDATE、DELETE、的 WHERE条件列</strong></li></ol>\n<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。 如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</p>\n<ol start=\"5\"><li><strong>DISTINCT字段需要创建索引</strong></li></ol>\n<p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>\n<ol start=\"6\"><li><strong>多表 JOIN、连接操作时，创建索引注意事项</strong></li></ol>\n<p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p>\n<p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>\n<p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。</p>\n<ol start=\"7\"><li><strong>使用列的类型小的创建索引</strong></li></ol>\n<p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p>\n<p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用MEDIUMINT就不要使用INT。这是因为：</p>\n<ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul>\n<p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p>\n<ol start=\"8\"><li><strong>使用字符串前缀创建索引</strong></li></ol>\n<p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:</p>\n<ul><li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul>\n<p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p>\n<p>区分度计算公式：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">distinct</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">(</span>列名<span class=\"token punctuation\">,</span> 索引长度<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>索引列前缀对排序的影响：使用索引列前缀的方式 <code>无法支持使用索引排序</code>，只能使用文件排序</p>\n<blockquote>\n<p>拓展：Alibaba《Java开发手册》</p>\n<p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>\n<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>\n</blockquote>\n<ol start=\"9\"><li><strong>区分度高(散列性高)的列适合作为索引</strong></li></ol>\n<p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说， 在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。 这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p>\n<p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p>\n<p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p>\n<ol start=\"10\"><li> <p><strong>使用最频繁的列放到联合索引的左侧</strong></p> </li><li> <p><strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p> </li></ol>\n<h4><a id=\"832_2983\"></a>8.3.2、限制索引的数目</h4>\n<p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p>\n<ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li></ul>\n<h4><a id=\"833_2991\"></a>8.3.3、哪些情况不适合创建索引</h4>\n<pre><code>1.   在where中使用不到的字段，不要设置索引 \n2.   数据量小的表最好不要使用索引 \n3.   有大量重复数据的列上不要建立索引 \n4.   避免对经常更新的表创建过多的索引 \n     - 第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。\n     - 第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时虽然提高了查询速度，同时却会降低更新表的速度。\n5.   不建议用无序的值作为索引 \n     - 例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。\n\n6.   删除不再使用或者很少使用的索引 \n     - 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引多更新操作的影响。 \n7.   不要定义冗余或重复的索引 \n</code></pre>\n<h2><a id=\"_3006\"></a>九、性能分析工具的使用</h2>\n<h3><a id=\"91_3008\"></a>9.1、数据库服务器的优化步骤</h3>\n<p>整个流程划分成了 观察（Show status）和 行动（Action）两部分。字母S的部分代表观察（会使用相应的分析工具），字母A代表的部分是行动（对应分析可以采取的行动）。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d96f086e8d7d4af0961f9193598215cd.png\"/></p>\n<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到问题，再采取相应的行动。</p>\n<pre><code class=\"prism language-markdown\"># 调优流程图详解：\n\n1. 首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，如双十一，促销活动等。这样的话，可以通过 A1 加缓存这一步骤解决，或者更改缓存失效策略。\n\n2. 如果缓存策略没有解决，或者不是周期性波动的原因，就需要进一步分析查询延迟和卡顿的原因。进入开启慢查询 S2 步骤，通过慢查询可用快速定位执行慢的SQL语句。我们可以通过设置 long_query_time 参数定义“慢”的阈值（阈值即边界值），如果SQL执行时间超过了阈值，则认为是慢查询。收集上来这些慢查询的SQL语句之后，我们就可以通过分析工具对慢查询日志进行分析。\n\n3. 在S3这一步骤中，我们就知道了执行慢的sQL，这样就可以针对性地用EXPLAIN查看对应SQL语句的执行计划，或者使用show profile查看sQL中每一个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。\n\n4. 如果是SQL等待时间长，就进入 A2 步骤。进行调优服务器的参数，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入 A3 步骤。可以从三个方面进行优化调整：\n\t- 索引设计优化。比如联合索引就比多个单个索引的查询效率要快一些。\n\t- Join表是否过多。Join表的数据最好不要超过三张，表的数据越多，嵌套循环就越多，查询时间也就越长。\n\t- 数据表设计优化。虽然一般设计数据表都遵循三范式，但是我们可以适当的增加数据冗余度，以空间换取时间提高数据的查询效率。\n\n5. 如果 A2 和 A3 都不能解决问题，就要考虑数据库自身的SQL查询性能是否已经达到了瓶颈，如果确认没有达到性能瓶颈，就需要重新检查也就是重复上述步骤。如果已经达到了性能瓶颈，进入 A4 阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表，比如垂直分库，垂直分表和水平分表等。\n\n以上就是数据库调优的流程思路。如果我们发现执行sQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的sQL，这三种分析工具你可以理解是sQL调优的三个步骤:慢查询、EXPLAIN和SHoWPROFILING。\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\22c0a46f254340e086e9fbe61f336953.png\"/></p>\n<h3><a id=\"92_3037\"></a>9.2、查看系统性能参数</h3>\n<p>在MySQL中，可以使用SHOW STATUS语句查询一些MySQL数据库服务器的 性能参数、执行频率。</p>\n<p>SHOW STATUS语句语法如下：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">GLOBAL</span><span class=\"token operator\">|</span><span class=\"token keyword\">SESSION</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'参数'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>一些常用的性能参数如下:</p>\n<ul><li>Connections：连接MySQL服务器的次数。.</li><li>Uptime：MySQL服务器的上线时间。</li><li>Slow_queries：慢查询的次数。</li><li>lnnodb_rows_read：select查询返回的行数</li><li>lnnodb_rows_inserted：执行INSERT操作插入的行数</li><li>Innodb_rows_updated：执行UPDATE操作更新的行数</li><li>lnnodb_rows_deleted：执行DELETE操作删除的行数</li><li>com_select：查询操作的次数。</li><li>Com_insert：插入操作的次数。对于批量插入的INSERT操作，只累加一次。</li><li>Com_update：更新操作的次数。</li><li>Com_delete：删除操作的次数。</li></ul>\n<h3><a id=\"93SQLlast_query_cost_3061\"></a>9.3、统计SQL的查询成本：last_query_cost</h3>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'last_query_cost'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>\n<blockquote>\n<p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>\n<ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol>\n<p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>\n</blockquote>\n<h3><a id=\"94SQL_3076\"></a>9.4、定位执行慢的SQL：慢查询日志</h3>\n<p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p>\n<p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p>\n<h4><a id=\"941_3082\"></a>9.4.1、开启慢查询日志参数</h4>\n<ol><li>开启slow_query_log</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> slow_query_log<span class=\"token operator\">=</span><span class=\"token string\">'ON'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>%slow_query_log%<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>修改long_query_time阈值</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%long_query_time%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 </span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> long_query_time <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> <span class=\"token keyword\">global</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%long_query_time%'</span><span class=\"token punctuation\">;</span> \n\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> long_query_time<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%long_query_time%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"942_3111\"></a>9.4.2、查看慢查询数目</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%Slow_queries%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>补充说明:</p>\n<p>除了上述变量，控制慢查询日志的还有一个系统变量: min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_time的值，那么，这个查询就被记录到慢查询日志中;反之，则不被记录到慢查询日志中。</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'min%'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-------------------------+-------+</span>\n<span class=\"token operator\">|</span> Variable_namel          <span class=\"token operator\">|</span> <span class=\"token keyword\">Value</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-------------------------+-------+</span>\n<span class=\"token operator\">|</span> min_examined_row_limit  <span class=\"token operator\">|</span> <span class=\"token number\">0</span>     <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-------------------------+-------+</span>\n<span class=\"token number\">1</span> <span class=\"token keyword\">row</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">set</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span> warning <span class=\"token punctuation\">(</span> <span class=\"token number\">0.00</span> sec<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>这个值默认是0。与long_query_time=10合在一起，表示只要查询的执行时间超过10秒，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“ my.ini\"文件，来修改查询时长，或者通过SET指令，用SQL语句修改“min_examined_row_limit”的值。</p>\n</blockquote>\n<h4><a id=\"943mysqldumpslow_3133\"></a>9.4.3、慢查询日志分析工具：mysqldumpslow</h4>\n<p>在生产环境中，如果要手工分析日志，查找、分析sQL，显然是个体力活，MysQL提供了日志分析工具mysqldumpslow 。</p>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\"># 查看mysqldumpslow的帮助信息</span>\nmysqldumpslow --help\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3f75abc1fe3a4729bbf08b09e7288cb1.png\"/></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#得到返回记录集最多的10个SQL </span>\nmysqldumpslow -s r -t <span class=\"token number\">10</span> /var/lib/mysql/atguigu-slow.log \n<span class=\"token comment\">#得到访问次数最多的10个SQL </span>\nmysqldumpslow -s c -t <span class=\"token number\">10</span> /var/lib/mysql/atguigu-slow.log\n<span class=\"token comment\">#得到按照时间排序的前10条里面含有左连接的查询语句 </span>\nmysqldumpslow -s t -t <span class=\"token number\">10</span> -g <span class=\"token string\">\"left join\"</span> /var/lib/mysql/atguigu-slow.log \n<span class=\"token comment\">#另外建议在使用这些命令时结合 | 和more 使用，否则有可能出现爆屏情况 </span>\nmysqldumpslow -s r -t <span class=\"token number\">10</span> /var/lib/mysql/atguigu-slow.log <span class=\"token operator\">|</span> <span class=\"token function\">more</span>\n</code></pre>\n<h4><a id=\"944_3155\"></a>9.4.4、关闭慢查询日志</h4>\n<p>方式1：永久性方式</p>\n<pre><code class=\"prism language-ini\">[mysqld] \nslow_query_log=OFF\n#或\n[mysqld] \n#slow_query_log=ON\n</code></pre>\n<p>方式2：临时性方式</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> slow_query_log<span class=\"token operator\">=</span><span class=\"token keyword\">off</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>重启mysql服务，执行如下语句查询慢日志功能</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%slow%'</span> <span class=\"token punctuation\">;</span>     <span class=\"token comment\">#查询慢查询日志所在目录</span>\n<span class=\"token keyword\">SHOw</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%long_query_time%'</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">#查询超时时长</span>\n</code></pre>\n<h4><a id=\"945_3180\"></a>9.4.5、删除慢查询日志</h4>\n<p>使用SHOW语句显示慢查询日志信息，具体sQL语句如下。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHow</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'slow_query_log%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\666cefed4beb4f14851d9cdf72e1044b.png\"/></p>\n<p>从执行结果可以看出，慢查询日志的目录默认为MysQL的数据目录，在该目录下手动删除慢查询日志文件即可。</p>\n<p>使用命令mysqladmin flush-logs 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>\n<pre><code class=\"prism language-sql\">mysqladmin <span class=\"token operator\">-</span>uroot <span class=\"token operator\">-</span>p flush<span class=\"token operator\">-</span>logs slow\n</code></pre>\n<blockquote>\n<p>提示:</p>\n<p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>\n</blockquote>\n<h3><a id=\"95SQLSHOW_PROFILE_3202\"></a>9.5、查看SQL执行成本：SHOW PROFILE</h3>\n<p>逻辑架构章节 已经使用过。</p>\n<p>Show Profile是MysQL提供的可以用来分析当前会话中SQL都做了什么、执行的资源消耗情况的工具，可用于sql调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'profiling'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">#开启</span>\n<span class=\"token keyword\">set</span> profiling <span class=\"token operator\">=</span> <span class=\"token string\">'ON'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#查看</span>\n<span class=\"token keyword\">SHOW</span> PROFILE <span class=\"token punctuation\">[</span><span class=\"token keyword\">type</span> <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">,</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">[</span> <span class=\"token keyword\">FOR</span> QUERY n <span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">[</span><span class=\"token keyword\">LIMIT</span> row_count <span class=\"token punctuation\">[</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token keyword\">offset</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">type</span> : {\n\t<span class=\"token keyword\">ALL</span> <span class=\"token comment\">-- 显示所有参数的开销信息</span>\n\tBLOCK IO <span class=\"token comment\">-- 显示IO的相关开销</span>\n\tCONTEXT SWITCHES <span class=\"token comment\">-- 上下文切换相关开销</span>\n\tCPU <span class=\"token comment\">-- 显示CPU相关开销信息</span>\n\tIPC <span class=\"token comment\">-- 显示发送和接收相关开销信息</span>\n\tMEMORY <span class=\"token comment\">-- 显示内存相关开销信息</span>\n\tPAGE FAULTS <span class=\"token comment\">-- 显示页面错误相关开销信息</span>\n\tSOURCE <span class=\"token comment\">-- 显示和Source_function, Source_file,Source_line相关的开销信息</span>\n\tSWAPS <span class=\"token comment\">-- 显示交换次数相关的开销信息</span>\n}\n\n<span class=\"token keyword\">show</span> profiles<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">show</span> profile cpu<span class=\"token punctuation\">,</span>block io <span class=\"token keyword\">for</span> query <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>日常开发需注意的结论:</p>\n<ul><li>converting HEAP to MyISAM︰查询结果太大，内存不够，数据往磁盘上搬了。</li><li>creating tmp table:创建临时表。先拷贝数据到临时表，用完后再删除临时表。</li><li>Copying to tmp table on disk:把内存中临时表复制到磁盘上，警惕!</li><li>locked 。</li></ul>\n<p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p>\n<p>注意：不过 SHOW PROFILE命令将被弃用，我们可以从information_schema 中的profiling数据表进行查看。</p>\n<h3><a id=\"96EXPLAIN_3245\"></a>9.6、分析查询语句：EXPLAIN</h3>\n<p>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE,工具做针对性的分析查询语句。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。</p>\n<p>MysQL中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。</p>\n<p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>\n<p>MySQL 5.6.3以前只能<code>EXPLAIN SELECT</code>；MYSQL 5.6.3以后就可以 <code>EXPLAIN SELECT，UPDATE，DELETE</code></p>\n<p>在5.7以前的版本中，想要显示<code>partitions</code>需要使用<code>explain partitions</code>命令；想要显示 filtered 需要使用<code>explain extended</code>命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。</p>\n<h4><a id=\"961_3259\"></a>9.6.1、基本语法</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> select_options \n<span class=\"token comment\">#或者</span>\n<span class=\"token keyword\">DESCRIBE</span> <span class=\"token keyword\">SELECT</span> select_options\n</code></pre>\n<p>EXPLAIN 语句输出的各个列的作用如下：</p>\n<table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table>\n<h4><a id=\"962EXPLAIN_3284\"></a>9.6.2、EXPLAIN各列作用</h4>\n<ol><li> <p>table</p> <p>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法 ，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p> </li><li> <p>id</p>\n<ul><li> <p>id如果相同，可以认为是一组，从上往下顺序执行</p> </li><li> <p>在所有组中，id值越大，优先级越高，越先执行</p> </li><li> <p>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</p> </li></ul> </li><li> <p>select_type</p> <p>一条大的查询语句里边可以包含若干个SELECT关键字，每个SELECT天键字代表着一个小的查询语句，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。</p> <p>MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为select.type的属性，意思是我们只要知道了某个小查询的select_type 属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，我们看一下select_type都能取哪些值，请看官方文档:</p>\n<table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>Simple SELECT (not using UNION or subqueries)</td></tr><tr><td>PRIMARY</td><td>Outermost SELECT</td></tr><tr><td>UNION</td><td>Second or later SELECT statement in a UNION</td></tr><tr><td>UNION RESULT</td><td>Result of a UNION</td></tr><tr><td>SUBQUERY</td><td>First SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td>DEPENDENT UNION</td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>DERIVED</td><td>Derived table</td></tr><tr><td>MATERIALIZED</td><td>Materialized subquery</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>Asubquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table></li><li> <p>partitions</p> <p>代表分区表中的命中情况，非分区表，该项为NULL。一般情况下我们的查询语句的执行计划的partitions列的值都是NULL。</p> </li><li> <p>type（重点）</p> <p>执行计划的一条记录就代表着MysQL对某个表的执行查询时的访问方法，又称“访问类型”，其中的type列就表:了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref，表明MySQL即将使用ref访(方法来执行对s1表的查询。</p> <p>完整的访问方法如下: system，const,eq.ref，ref，fulltext,ref_or_null,index_merge,unique_subquery , index_subquery , range , index，ALL。</p> <p>结果值从最好到最坏依次是： <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong></p> <p>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是const级别。（阿里巴巴开发手册要求）</p> </li><li> <p>possible_keys和key</p> <p>在EXPLAIN语句输出的执行计划中, possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。</p> </li><li> <p>key_len（重点）</p> <p>key_len的长度计算公式：</p> </li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>变长字段且允许<span class=\"token boolean\">NULL</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span>： utf8<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>gbk<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>latin1<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">(</span>变长字段<span class=\"token punctuation\">)</span> \n\n<span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>变长字段且不允许<span class=\"token boolean\">NULL</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span>：utf8<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>gbk<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>latin1<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">(</span>变长字段<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>固定字段且允许<span class=\"token boolean\">NULL</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span>：utf8<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>gbk<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>latin1<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">NULL</span><span class=\"token punctuation\">)</span> \n\n<span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>固定字段且不允许<span class=\"token boolean\">NULL</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span>：utf8<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>gbk<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>latin1<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<ol start=\"8\"><li> <p>ref</p> <p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p> <p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const、eq_ref、ref、ref_of_null、unique_subquery、index_subquery其中之一时，ref 列展示的就是与索引列作等值匹配的结构是什么，比如只是一个常数或者是某个列。</p> </li><li> <p>rows（重点）</p> <p>预估的需要读取的记录条数。。。值越小越好</p> </li><li> <p>filtered</p> <p>某个表经过搜索条件过滤后剩余记录条数的百分比</p> <p>对个单表查询来说，这个filtered列的值没有什么意义，我们更关注连接查询</p> </li><li> <p>Extra</p> <p>Extra列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>\n<ul><li>No tables used ——当查询语句没有 ‘from’ 子句时将会提示该额外信息</li><li>Impossible WHERE ——查询语句的 where 子句永远为 false 时将会提示该额外信息</li><li>Using where ——当使用全表扫描来执行对给某个表的查询，并且该语句的 where 子句中有针对该表的搜索条件时，会提示该额外信息；当使用索引访问来执行对某个表的查询，并且该语句的 where 子句中有除了该索引包含的列之外的其他搜索条件时，也会提示该额外信息</li><li>No matching min/max row ——当查询列表处有 MIN 或 MAX 聚合函数，但是并没有符合 WHERE 子句中的搜索条件的记录时</li><li>Using index ——当查询列表以及搜索条件中只包含某个索引的列，也就是在可以使用覆盖索引的情况下，将提示该信息。比方说下边这个查询中只需要用到 idx_key1 而不需要回表操作。</li><li>Using index condition ——有些搜索条件中虽然出现了索引列，但却不能使用到索引。称为索引条件下推。</li><li>Using join buffer ——在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫 ‘join buffer’ 的内存块来加快查询速度，也就是我们所讲的 ‘基于块的嵌套循环算法’</li><li>Not exists ——当我们使用左（外）连接时，如果 ‘WHERE’ 子句中包含要求被驱动表的某个列等于 ‘NULL’ 值的搜索条件，而且那个列又是不允许存储 ‘NULL’ 值的，将提示该额外信息。</li><li>Using intersect（…） ——说明准备使用 Intersect 索引合并的方式执行查询，括号中的 ‘…’ 表示需要进行索引合并的索引名称；Using union（…） ——说明准备使用 Union 索引合并的方式执行查询；Using sort_union（…），说明准备使用 Sort-Union 索引合并的方式执行查询。</li><li>Zero limit ——当 limit 子句的参数为 0 时，表示压根儿不打算从表中读取任何记录，将提示该额外信息</li><li>Using filesort ——很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序。如果某个查询需要文件排序的方式执行查询，将提示该信息</li><li>Using temporary ——在许多查询执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 ‘DISTINCT’，‘GROUP BY’， 'UNION’等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，将提示该信息。</li></ul> </li></ol>\n<p><strong>小结：</strong></p>\n<ul><li>EXPLAIN不考虑各种cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定文函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul>\n<h3><a id=\"97EXPLAIN_3391\"></a>9.7、EXPLAIN的进一步使用</h3>\n<h4><a id=\"971EXPLAIN_3393\"></a>9.7.1、EXPLAIN四种输出格式</h4>\n<p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p>\n<ol><li> <p>传统格式</p> </li><li> <p>JSON格式</p> </li></ol>\n<p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p>\n<ol start=\"3\"><li>TREE格式</li></ol>\n<p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p>\n<ol start=\"4\"><li>可视化输出</li></ol>\n<p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p>\n<h4><a id=\"972SHOW_WARNINGS_3411\"></a>9.7.2、SHOW WARNINGS的使用</h4>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> s1<span class=\"token punctuation\">.</span>key1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">.</span>key1 <span class=\"token keyword\">FROM</span> s1 <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> s2 <span class=\"token keyword\">ON</span> s1<span class=\"token punctuation\">.</span>key1 <span class=\"token operator\">=</span> s2<span class=\"token punctuation\">.</span>key1 <span class=\"token keyword\">WHERE</span> s2<span class=\"token punctuation\">.</span>common_field <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 查看优化后的执行语句</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">WARNINGS</span>\\G\n</code></pre>\n<h3><a id=\"98trace_3419\"></a>9.8、分析优化器执行计划：trace</h3>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 开启</span>\n<span class=\"token keyword\">SET</span> optimizer_trace<span class=\"token operator\">=</span><span class=\"token string\">\"enabled=on\"</span><span class=\"token punctuation\">,</span>end_markers_in_json<span class=\"token operator\">=</span><span class=\"token keyword\">on</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\"># 设置大小</span>\n<span class=\"token keyword\">set</span> optimizer_trace_max_mem_size<span class=\"token operator\">=</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 使用</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> student <span class=\"token keyword\">where</span> id <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> information_schema<span class=\"token punctuation\">.</span>optimizer_trace\\G\n</code></pre>\n<h3><a id=\"99MySQLsys_schema_3431\"></a>9.9、MySQL监控分析视图-sys schema</h3>\n<p>7.1 Sys schema视图使用场景</p>\n<p>索引情况</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#1. 查询冗余索引 </span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>schema_redundant_indexes<span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#2. 查询未使用过的索引 </span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>schema_unused_indexes<span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#3. 查询索引的使用情况 </span>\n<span class=\"token keyword\">select</span> index_name<span class=\"token punctuation\">,</span>rows_selected<span class=\"token punctuation\">,</span>rows_inserted<span class=\"token punctuation\">,</span>rows_updated<span class=\"token punctuation\">,</span>rows_deleted <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>schema_index_statistics <span class=\"token keyword\">where</span> table_schema<span class=\"token operator\">=</span><span class=\"token string\">'dbname'</span> <span class=\"token punctuation\">;</span>\n</code></pre>\n<p>表相关</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 1. 查询表的访问量 </span>\n<span class=\"token keyword\">select</span> table_schema<span class=\"token punctuation\">,</span>table_name<span class=\"token punctuation\">,</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>io_read_requests<span class=\"token operator\">+</span>io_write_requests<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> io <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>schema_table_statistics <span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> table_schema<span class=\"token punctuation\">,</span>table_name <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> io <span class=\"token keyword\">desc</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\"># 2. 查询占用bufferpool较多的表 </span>\n<span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>allocated<span class=\"token punctuation\">,</span><span class=\"token keyword\">data</span>\n<span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>innodb_buffer_stats_by_table <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> allocated <span class=\"token keyword\">limit</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\"># 3. 查看表的全表扫描情况 </span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>statements_with_full_table_scans <span class=\"token keyword\">where</span> db<span class=\"token operator\">=</span><span class=\"token string\">'dbname'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>语句相关</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#1. 监控SQL执行的频率 </span>\n<span class=\"token keyword\">select</span> db<span class=\"token punctuation\">,</span>exec_count<span class=\"token punctuation\">,</span>query <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>statement_analysis <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> exec_count <span class=\"token keyword\">desc</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#2. 监控使用了排序的SQL </span>\n<span class=\"token keyword\">select</span> db<span class=\"token punctuation\">,</span>exec_count<span class=\"token punctuation\">,</span>first_seen<span class=\"token punctuation\">,</span>last_seen<span class=\"token punctuation\">,</span>query\n<span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>statements_with_sorting <span class=\"token keyword\">limit</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#3. 监控使用了临时表或者磁盘临时表的SQL </span>\n<span class=\"token keyword\">select</span> db<span class=\"token punctuation\">,</span>exec_count<span class=\"token punctuation\">,</span>tmp_tables<span class=\"token punctuation\">,</span>tmp_disk_tables<span class=\"token punctuation\">,</span>query\n<span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>statement_analysis <span class=\"token keyword\">where</span> tmp_tables<span class=\"token operator\">&gt;</span><span class=\"token number\">0</span> <span class=\"token operator\">or</span> tmp_disk_tables <span class=\"token operator\">&gt;</span><span class=\"token number\">0</span> <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> <span class=\"token punctuation\">(</span>tmp_tables<span class=\"token operator\">+</span>tmp_disk_tables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">desc</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>IO相关</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#1. 查看消耗磁盘IO的文件 </span>\n<span class=\"token keyword\">select</span> <span class=\"token keyword\">file</span><span class=\"token punctuation\">,</span>avg_read<span class=\"token punctuation\">,</span>avg_write<span class=\"token punctuation\">,</span>avg_read<span class=\"token operator\">+</span>avg_write <span class=\"token keyword\">as</span> avg_io\n<span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>io_global_by_file_by_bytes <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> avg_read <span class=\"token keyword\">limit</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Innodb、相关</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#1. 行锁阻塞情况 </span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> sys<span class=\"token punctuation\">.</span>innodb_lock_waits<span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"10__3488\"></a>第10章 索引优化与查询优化</h2>\n<h3><a id=\"1____3490\"></a>1. 索引失效案例</h3>\n<p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>\n<ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul>\n<p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p>\n<p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，**SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p>\n<h4><a id=\"11_3501\"></a>1.1、全值匹配我最爱</h4>\n<h4><a id=\"12_3503\"></a>1.2、最佳左前缀法则</h4>\n<p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>\n<p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引， 过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。 如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p>\n<h4><a id=\"13_3509\"></a>1.3、主键插入顺序</h4>\n<p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p>\n<h4><a id=\"14_3513\"></a>1.4、计算、函数、类型转换(自动或手动)导致索引失效</h4>\n<h4><a id=\"15_3515\"></a>1.5、类型转换导致索引失效</h4>\n<h4><a id=\"16_3517\"></a>1.6、范围条件右边的列索引失效</h4>\n<blockquote>\n<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p>\n</blockquote>\n<h4><a id=\"17__3521\"></a>1.7、不等于(!= 或者&lt;&gt;)索引失效</h4>\n<h4><a id=\"18_is_nullis_not_null_3523\"></a>1.8 is null可以使用索引，is not null无法使用索引</h4>\n<blockquote>\n<p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)</p>\n<p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p>\n</blockquote>\n<h4><a id=\"19_like_3529\"></a>1.9 like以通配符%开头索引失效</h4>\n<blockquote>\n<p>拓展：Alibaba《Java开发手册》</p>\n<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>\n</blockquote>\n<h4><a id=\"110_OR_3535\"></a>1.10 OR、前后存在非索引的列，索引失效</h4>\n<p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，**OR前后的两个条件中的列都是索引时，查询中才使用索引。</p>\n<h4><a id=\"111utf8mb4_3539\"></a>1.11、数据库和表的字符集统一使用utf8mb4**</h4>\n<p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p>\n<h3><a id=\"2____3543\"></a>2. 关联查询优化</h3>\n<blockquote>\n<p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p>\n<p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p>\n<p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p>\n</blockquote>\n<h4><a id=\"21_Index_NestedLoop_Join_3551\"></a>2.1 Index Nested-Loop Join（索引嵌套循环连接）</h4>\n<p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cr395amv-1661608724710)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png)]</p>\n<h4><a id=\"22_Block_NestedLoop_Join_3557\"></a>2.2 Block Nested-Loop Join（块嵌套循环连接）</h4>\n<p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p>\n<p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FCIhBdvX-1661608724711)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png)]</p>\n<h4><a id=\"23_Hash_Join_3565\"></a>2.3 Hash Join</h4>\n<p>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join**</p>\n<ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。 \n  <ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul> </li></ul>\n<h3><a id=\"3____3575\"></a>3. 子查询优化</h3>\n<p>子查询是 **MySQL、的一项重要的功能，可以帮助我们通过一个 **SQL、语句实现比较复杂的查询。但是，子查询的执行效率不高。 原因：</p>\n<p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>\n<p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p>\n<p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>\n<p>在MySQL中，可以使用连接（JOIN）查询来替代子查询。 连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p>\n<blockquote>\n<p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>\n</blockquote>\n<h3><a id=\"4____3589\"></a>4. 排序优化</h3>\n<ol><li> <p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p> </li><li> <p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p> </li><li> <p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p> </li></ol>\n<h3><a id=\"5_GROUP_BY_3597\"></a>5. GROUP BY优化</h3>\n<ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul>\n<h3><a id=\"6____3606\"></a>6. 优化分页查询</h3>\n<p>优化思路一</p>\n<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student t<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> id <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">2000000</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> a\n<span class=\"token keyword\">WHERE</span> t<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>优化思路二</p>\n<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">&gt;</span> <span class=\"token number\">2000000</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"7____3625\"></a>7. 优先考虑覆盖索引</h3>\n<h4><a id=\"71_3627\"></a>7.1、什么是覆盖索引？</h4>\n<p>理解方式一 ：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。 一个索引包含了满足查询结果的数据就叫做覆盖索引。</p>\n<p>理解方式二 ：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>\n<p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p>\n<h4><a id=\"72_3635\"></a>7.2、覆盖索引的利弊</h4>\n<p>好处：</p>\n<ol><li> <p>避免Innodb表进行索引的二次查询（回表）</p> </li><li> <p>可以把随机IO变成顺序IO加快查询效率</p> </li></ol>\n<p>弊端：</p>\n<p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p>\n<h3><a id=\"8____3647\"></a>8. 索引条件下推</h3>\n<h4><a id=\"81_3649\"></a>8.1、使用前后的扫描过程</h4>\n<p>在不使用ICP索引扫描的过程：</p>\n<p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层</p>\n<p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p>\n<p>使用ICP扫描的过程：</p>\n<p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p>\n<p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p>\n<h3><a id=\"9____3663\"></a>9. 其它查询优化策略</h3>\n<h4><a id=\"91_EXISTS__IN_3665\"></a>9.1 EXISTS、和 **IN、的区分</h4>\n<p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p>\n<h4><a id=\"92_COUNTCOUNT_3669\"></a>9.2 COUNT(*)与COUNT(具体字段)效率</h4>\n<p>环节1： <code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p>\n<p>环节2： 如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p>\n<p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p>\n<p>环节3： 在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p>\n<p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p>\n<h4><a id=\"93SELECT_3681\"></a>9.3、关于SELECT(*)</h4>\n<p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p>\n<p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将\"*\"按序转换成所有列名，这会大大的耗费资源和时间。</p>\n<p>② 无法使用<code>覆盖索引</code></p>\n<h4><a id=\"94_LIMIT_1_3689\"></a>9.4 LIMIT 1、对优化的影响</h4>\n<p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>\n<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p>\n<h4><a id=\"95COMMIT_3695\"></a>9.5、多使用COMMIT**</h4>\n<p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p>\n<p>COMMIT 所释放的资源：</p>\n<ul><li> <p>回滚段上用于恢复数据的信息</p> </li><li> <p>被程序语句获得的锁</p> </li><li> <p>redo / undo log buffer 中的空间</p> </li><li> <p>管理上述 3 种资源中的内部花费</p> </li></ul>\n<h2><a id=\"_3709\"></a></h2>\n<h2><a id=\"11__3711\"></a>第11章 数据库的设计规范</h2>\n<h3><a id=\"1_____3713\"></a>1. 范 式</h3>\n<h4><a id=\"11_3715\"></a>1.1、范式简介</h4>\n<p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。 可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>\n<h4><a id=\"12_3719\"></a>1.2、范式都包括哪些</h4>\n<p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是： 第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式） 。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kRGwPnEO-1661608724713)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png)]</p>\n<h4><a id=\"13_3725\"></a>1.3、键和相关属性的概念</h4>\n<p>这里有两个表：</p>\n<p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p>\n<p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p>\n<ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul>\n<h4><a id=\"141st_NF_3739\"></a>1.4、第一范式(1st NF)</h4>\n<p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p>\n<h4><a id=\"152nd_NF_3743\"></a>1.5、第二范式(2nd NF)</h4>\n<p>第二范式要求，在满足第一范式的基础上，还要 满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。 如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p>\n<h4><a id=\"163rd_NF_3747\"></a>1.6、第三范式(3rd NF)</h4>\n<p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说， 要求数据表中的所有非主键字段不能依赖于其他非主键字段。 （即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在\"A–&gt;B–&gt;C\"的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p>\n<h4><a id=\"17__3751\"></a>1.7 小结</h4>\n<p>关于数据表的设计，有三个范式要遵循。</p>\n<p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p>\n<p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p>\n<p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p>\n<p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p>\n<p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p>\n<p>范式的优点： 数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p>\n<p>范式的缺点： 范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p>\n<p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p>\n<h3><a id=\"2____3771\"></a>2. 反范式化</h3>\n<h4><a id=\"21_3773\"></a>2.1、概述</h4>\n<p>规范化 **vs、性能</p>\n<ol><li> <p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p> </li><li> <p>在数据规范化的同时 , 要综合考虑数据库的性能</p> </li><li> <p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p> </li><li> <p>通过在给定的表中插入计算列，以方便查询</p> </li></ol>\n<h4><a id=\"22_3785\"></a>2.2、反范式的新问题</h4>\n<ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul>\n<h4><a id=\"23_3792\"></a>2.3、反范式的适用场景</h4>\n<p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p>\n<ol><li>增加冗余字段的建议</li></ol>\n<p>1）这个冗余字段<code>不需要经常进行修改</code></p>\n<p>2）这个冗余字段<code>查询的时候不可或缺</code></p>\n<ol start=\"2\"><li>历史快照、历史数据的需要</li></ol>\n<p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>\n<p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>\n<h3><a id=\"3_BCNF_3808\"></a>3. BCNF(巴斯范式)</h3>\n<p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF， 它在 3NF、的基础上消除了主属性对候选键的部分依赖或者传递依赖关系 。</p>\n<p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p>\n<h3><a id=\"4_ER_3814\"></a>4. ER模型</h3>\n<p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。 在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</p>\n<h4><a id=\"41_ER__3818\"></a>4.1 ER 模型包括那些要素？</h4>\n<p>**ER、模型中有三个要素，分别是实体、属性和关系 。</p>\n<p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p>\n<p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p>\n<p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p>\n<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看， 可以独立存在的是实体，不可再分的是属性 。也就是说，属性不能包含其他属性。</p>\n<h4><a id=\"42_3830\"></a>4.2、关系的类型</h4>\n<p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>\n<p><code>一对一</code>：指实体之间的关系是一一对应的</p>\n<p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p>\n<p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p>\n<h3><a id=\"5____3840\"></a>5. 数据表的设计原则</h3>\n<p>数据表设计的一般原则：“三少一多”</p>\n<ol><li> <p>数据表的个数越少越好</p> </li><li> <p>数据表中的字段个数越少越好</p> </li><li> <p>数据表中联合主键的字段个数越少越好</p> </li><li> <p>使用主键和外键越多越好</p> </li></ol>\n<blockquote>\n<p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p>\n</blockquote>\n<h3><a id=\"6____3854\"></a>6. 数据库对象编写建议</h3>\n<h4><a id=\"61_3856\"></a>6.1、关于库</h4>\n<ol><li> <p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p> </li><li> <p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p> </li><li> <p>【强制】库的名称格式：业务系统名称_子系统名。</p> </li><li> <p>【强制】库名禁止使用关键字（如type,order等）。</p> </li><li> <p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET 'utf8'</code>;</p> </li><li> <p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。</p> </li><li> <p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p> </li></ol>\n<h4><a id=\"62_3872\"></a>6.2、关于表、列</h4>\n<ol><li> <p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。</p> </li><li> <p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p> </li><li> <p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item</p> </li><li> <p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。</p> </li><li> <p>【强制】表名、列名禁止使用关键字（如type,order等）。</p> </li><li> <p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。</p> </li><li> <p>【强制】建表必须有comment。</p> </li><li> <p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p> </li><li> <p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。</p> </li><li> <p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p> </li><li> <p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</p> </li><li> <p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p> </li><li> <p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p> </li><li> <p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p> </li><li> <p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p> </li><li> <p>【示范】一个较为规范的建表语句：</p> </li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> user_info <span class=\"token punctuation\">(</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">unsigned</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'自增主键'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户id'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>username<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'真实姓名'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>email<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户邮箱'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>nickname<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'昵称'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>birthday<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">date</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'生日'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>sex<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">tinyint</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'性别'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>short_introduce<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">150</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'一句话介绍自己，最多50个汉字'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_resume<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户提交的简历存放地址'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_register_ip<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户注册时的源ip'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>create_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">timestamp</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CURRENT_TIMESTAMP</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'创建时间'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>update_time<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">timestamp</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CURRENT_TIMESTAMP</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">CURRENT_TIMESTAMP</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'修改时间'</span><span class=\"token punctuation\">,</span> \n    <span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_review_status<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">tinyint</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>uniq_user_id<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_id<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>idx_username<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>username<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>idx_create_time_status<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>create_time<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>user_review_status<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8 <span class=\"token keyword\">COMMENT</span><span class=\"token operator\">=</span><span class=\"token string\">'网站用户基本信息'</span>\n</code></pre>\n<ol start=\"17\"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol>\n<h4><a id=\"63_3930\"></a>6.3、关于索引</h4>\n<ol><li> <p>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值<code>禁止被更新</code>。</p> </li><li> <p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。</p> </li><li> <p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p> </li><li> <p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</p> </li><li> <p>【建议】单个表上的索引个数<code>不能超过6个</code>。</p> </li><li> <p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p> </li><li> <p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p> </li><li> <p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p> </li></ol>\n<h4><a id=\"64_SQL_3948\"></a>6.4 SQL编写</h4>\n<ol><li> <p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</p> </li><li> <p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p> </li><li> <p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p> </li><li> <p>【建议】INSERT INTO…VALUES(XX),(XX),(XX)… 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p> </li><li> <p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p> </li><li> <p>【建议】线上环境，多表 JOIN 不要超过5个表。</p> </li><li> <p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p> </li><li> <p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p> </li><li> <p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p> </li><li> <p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</p> </li><li> <p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p> </li><li> <p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p> </li></ol>\n<h2><a id=\"12__3974\"></a>第12章 数据库其它调优策略</h2>\n<h3><a id=\"1____3976\"></a>1. 数据库调优的措施</h3>\n<h4><a id=\"11_3978\"></a>1.1、调优的目标</h4>\n<ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul>\n<h4><a id=\"12_3984\"></a>1.2、如何定位调优问题</h4>\n<ul><li>用户的反馈（主要）</li><li>日志分析（主要）</li><li>服务器资源使用监控</li><li>数据库内部状况监控</li><li>其它</li></ul>\n<h4><a id=\"13_3992\"></a>1.3、调优的维度和步骤</h4>\n<p>第1步：选择适合的 <strong>DBMS</strong></p>\n<p>第2步：优化表设计</p>\n<p>第3步：优化逻辑查询</p>\n<p>第4步：优化物理查询</p>\n<p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p>\n<p>第5步：使用 **Redis、或 **Memcached、作为缓存</p>\n<p>第6步：库级优化</p>\n<p>1、读写分离</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2xhOe6Lt-1661608724714)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031025279.png)]</p>\n<p>2、数据分片</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gZlOArON-1661608724714)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031026743.png)]</p>\n<h3><a id=\"2___MySQL_4016\"></a>2. 优化MySQL服务器</h3>\n<h4><a id=\"21_4018\"></a>2.1、优化服务器硬件</h4>\n<p>服务器的硬件性能直接决定着MySQL数据库的性能。 硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。</p>\n<p>（1）<code>配置较大的内存</code></p>\n<p>（2）<code>配置高速磁盘系统</code></p>\n<p>（3）<code>合理分布磁盘I/O</code></p>\n<p>（4）<code>配置多处理器</code></p>\n<h4><a id=\"22MySQL_4030\"></a>2.2、优化MySQL的参数</h4>\n<ul><li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li><li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li><li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。 \n  <ul><li>当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。</li><li>当query_cache_type=2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul> </li><li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</li><li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参数的值。默认为64K，可以设置为4M。</li><li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。 \n  <ul><li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li><li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul> </li><li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li><li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。</li><li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li></ul>\n<h3><a id=\"3____4053\"></a>3. 优化数据库结构</h3>\n<h4><a id=\"31_4055\"></a>3.1、拆分表：冷热数据分离</h4>\n<h4><a id=\"32_4057\"></a>3.2、增加中间表</h4>\n<h4><a id=\"33_4059\"></a>3.3、增加冗余字段</h4>\n<h4><a id=\"34_4061\"></a>3.4、优化数据类型</h4>\n<p>情况1：对整数类型数据进行优化。</p>\n<p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p>\n<p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p>\n<p>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型 。</p>\n<p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p>\n<p>情况3：避免使用TEXT、BLOB数据类型</p>\n<p>情况4：避免使用ENUM类型</p>\n<p>情况5：使用TIMESTAMP存储时间</p>\n<p>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</p>\n<p>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优 。</p>\n<h4><a id=\"35_4083\"></a>3.5、优化插入记录的速度</h4>\n<ol><li>MyISAM引擎的表：</li></ol>\n<p>① 禁用索引</p>\n<p>② 禁用唯一性检查</p>\n<p>③ 使用批量插入</p>\n<p>④ 使用LOAD DATA INFILE 批量导入</p>\n<ol start=\"2\"><li>InnoDB引擎的表：</li></ol>\n<p>① 禁用唯一性检查</p>\n<p>② 禁用外键检查</p>\n<p>③ 禁止自动提交</p>\n<h4><a id=\"36_4103\"></a>3.6、使用非空约束</h4>\n<p>在设计字段的时候，如果业务允许，建议尽量使用非空约束</p>\n<h4><a id=\"37_4107\"></a>3.7、分析表、检查表与优化表</h4>\n<ol><li>分析表</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ANALYZE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">LOCAL</span> <span class=\"token operator\">|</span> NO_WRITE_TO_BINLOG<span class=\"token punctuation\">]</span> <span class=\"token keyword\">TABLE</span> tbl_name<span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span>tbl_name<span class=\"token punctuation\">]</span>…\n</code></pre>\n<p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p>\n<p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p>\n<p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。 该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</p>\n<ol start=\"2\"><li>检查表</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CHECK</span> <span class=\"token keyword\">TABLE</span> tbl_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> tbl_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">option</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">option</span> <span class=\"token operator\">=</span> {<!-- --><span class=\"token keyword\">QUICK</span> <span class=\"token operator\">|</span> FAST <span class=\"token operator\">|</span> MEDIUM <span class=\"token operator\">|</span> <span class=\"token keyword\">EXTENDED</span> <span class=\"token operator\">|</span> CHANGED}\n</code></pre>\n<p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p>\n<ol start=\"3\"><li>优化表</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">OPTIMIZE</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">LOCAL</span> <span class=\"token operator\">|</span> NO_WRITE_TO_BINLOG<span class=\"token punctuation\">]</span> <span class=\"token keyword\">TABLE</span> tbl_name <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> tbl_name<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre>\n<p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。</p>\n<p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p>\n<h2><a id=\"13__4141\"></a>第13章 事务基础知识</h2>\n<h3><a id=\"1____4143\"></a>1. 数据库事务概述</h3>\n<h4><a id=\"11_4145\"></a>1.1、基本概念</h4>\n<p>事务： 一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>\n<p>事务处理的原则： 保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚(<code>rollback</code>)到最初状态。</p>\n<h4><a id=\"12ACID_4151\"></a>1.2、事务的ACID特性</h4>\n<ul><li>原子性（atomicity）：</li></ul>\n<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>\n<ul><li>一致性（consistency）：</li></ul>\n<p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p>\n<ul><li>隔离型（isolation）：</li></ul>\n<p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>\n<ul><li>持久性（durability）：</li></ul>\n<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n<p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code>。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>\n<h4><a id=\"13_4171\"></a>1.3、事务的状态</h4>\n<ul><li>活动的（active）</li></ul>\n<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p>\n<ul><li>部分提交的（partially committed）</li></ul>\n<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p>\n<ul><li>失败的（failed）</li></ul>\n<p>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p>\n<ul><li>中止的（aborted）</li></ul>\n<p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p>\n<ul><li>提交的（committed）</li></ul>\n<p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ghOSx4cS-1661608724715)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031104063.png)]</p>\n<h3><a id=\"2____4195\"></a>2. 如何使用事务</h3>\n<h4><a id=\"21_4197\"></a>2.1、显式事务</h4>\n<p>步骤1： <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">sql</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#或者 </span>\n<span class=\"token keyword\">sql</span><span class=\"token operator\">&gt;</span> <span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>：</p>\n<p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>\n<p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>\n<p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p>\n<p>步骤2： 一系列事务中的操作（主要是DML，不含DDL）</p>\n<p>步骤3： 提交事务 或 中止事务（即回滚事务）</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 回滚事务。即撤销正在进行的所有没有提交的修改 </span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">ROLLBACK</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\"># 将事务回滚到某个保存点。 </span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">ROLLBACK</span> <span class=\"token keyword\">TO</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">SAVEPOINT</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>其中关于SAVEPOINT相关操作有：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事物中可以存在多个保存点。</span>\n<span class=\"token keyword\">SAVEPOINT</span> 保存点名称<span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 删除某个保存点</span>\n<span class=\"token keyword\">RELEASE</span> <span class=\"token keyword\">SAVEPOINT</span> 保存点名称<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"22_4244\"></a>2.2、隐式事务</h4>\n<ul><li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></li></ul>\n<h4><a id=\"23_4249\"></a>2.3、隐式提交数据的情况</h4>\n<ul><li> <p>数据定义语言（Data definition language，缩写为：DDL）</p> </li><li> <p>隐式使用或修改mysql数据库中的表</p> </li><li> <p>事务控制或关于锁定的语句</p>\n<ul><li>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上一个事务。</li><li>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</li><li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</li></ul> </li></ul>\n<h3><a id=\"3____4259\"></a>3. 事务隔离级别</h3>\n<h4><a id=\"31_4261\"></a>3.1、数据并发问题</h4>\n<ol><li>脏写（ <code>Dirty Write</code> ）</li></ol>\n<p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code></p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ssTpltbB-1661608724716)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124086.png)]</p>\n<ol start=\"2\"><li>脏读（ <code>Dirty Read</code> ）</li></ol>\n<p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段。之后若 Session B<code>回滚</code>，Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6BR1bIhV-1661608724717)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124136.png)]</p>\n<ol start=\"3\"><li>不可重复读（ <code>Non-Repeatable Read</code> ）</li></ol>\n<p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code>同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1v6cvYWu-1661608724718)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124331.png)]</p>\n<ol start=\"4\"><li>幻读（ <code>Phantom</code> ）</li></ol>\n<p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RPLkJgD4-1661608724719)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031125847.png)]</p>\n<p>注意1：</p>\n<p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code>，幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p>\n<p>注意2：</p>\n<p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p>\n<h4><a id=\"32_SQL_4295\"></a>3.2 SQL中的四种隔离级别</h4>\n<p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p>\n<ul><li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</li><li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kJOsKCAa-1661608724719)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031127542.png)]</p>\n<h4><a id=\"33_4306\"></a>3.3、如何设置事务的隔离级别</h4>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">GLOBAL</span><span class=\"token operator\">|</span><span class=\"token keyword\">SESSION</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">TRANSACTION</span> <span class=\"token keyword\">ISOLATION</span> <span class=\"token keyword\">LEVEL</span> 隔离级别<span class=\"token punctuation\">;</span> \n<span class=\"token comment\">#其中，隔离级别格式： </span>\n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">READ</span> <span class=\"token keyword\">UNCOMMITTED</span> \n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">READ</span> <span class=\"token keyword\">COMMITTED</span> \n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">REPEATABLE</span> <span class=\"token keyword\">READ</span> \n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SERIALIZABLE</span>\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">GLOBAL</span><span class=\"token operator\">|</span><span class=\"token keyword\">SESSION</span><span class=\"token punctuation\">]</span> TRANSACTION_ISOLATION <span class=\"token operator\">=</span> <span class=\"token string\">'隔离级别'</span> \n<span class=\"token comment\">#其中，隔离级别格式： </span>\n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">READ</span><span class=\"token operator\">-</span><span class=\"token keyword\">UNCOMMITTED</span> \n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">READ</span><span class=\"token operator\">-</span><span class=\"token keyword\">COMMITTED</span> \n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">REPEATABLE</span><span class=\"token operator\">-</span><span class=\"token keyword\">READ</span> \n<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SERIALIZABLE</span>\n</code></pre>\n<h2><a id=\"_4328\"></a></h2>\n<h2><a id=\"14_MySQL_4332\"></a>第14章 MySQL事务日志</h2>\n<p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>\n<ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。 \n  <ul><li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul> </li></ul>\n<h3><a id=\"1_redo_4341\"></a>1. redo日志</h3>\n<h4><a id=\"11REDO_4343\"></a>1.1、为什么需要REDO日志</h4>\n<p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>\n<p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>\n<p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p>\n<p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p>\n<h4><a id=\"12_REDO_4353\"></a>1.2 REDO日志的好处、特点</h4>\n<ol><li>好处</li></ol>\n<ul><li> <p>**redo日志降低了刷盘频率</p> </li><li> <p>**redo日志占用的空间非常小</p>\n<ol start=\"2\"><li>特点</li></ol> </li><li> <p>**redo日志是顺序写入磁盘的</p> </li><li> <p>事务执行过程中，redo log不断记录</p> </li></ul>\n<h4><a id=\"13_redo_4365\"></a>1.3 redo的组成</h4>\n<p>Redo log可以简单分为以下两个部分：</p>\n<ul><li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li></ul>\n<p>参数设置：innodb_log_buffer_size：</p>\n<p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。</p>\n<ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul>\n<h4><a id=\"14_redo_4377\"></a>1.4 redo的整体流程</h4>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1HHd9LE0-1661608724720)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031147714.png)]</p>\n<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</p>\n<p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</p>\n<p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</p>\n<p>第4步：定期将内存中修改的数据刷新到磁盘中</p>\n<blockquote>\n<p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>\n</blockquote>\n<h4><a id=\"15_redo_log_4391\"></a>1.5 redo log的刷盘策略</h4>\n<p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>\n<p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>\n<ul><li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>）</li><li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul>\n<h4><a id=\"16_4401\"></a>1.6、不同刷盘策略演示</h4>\n<ol><li>流程图</li></ol>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r3SjIoEI-1661608724721)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152952.png)]</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9xvRVwqT-1661608724722)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152607.png)]</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Xpef2H9c-1661608724723)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031153931.png)]</p>\n<h4><a id=\"17redo_log_buffer_4411\"></a>1.7、写入redo log buffer过程</h4>\n<ol><li>补充概念：Mini-Transaction**</li></ol>\n<p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7AGV22jA-1661608724723)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040912119.png)]</p>\n<ol start=\"2\"><li>redo、日志写入log buffer**</li></ol>\n<p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wi35RHky-1661608724723)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040915708.png)]</p>\n<h4><a id=\"18_redo_log_file_4425\"></a>1.8 redo log file**</h4>\n<ol><li>相关参数设置</li></ol>\n<ul><li> <p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p> </li><li> <p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。</p> </li><li> <p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。</p> </li><li> <p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p>\n<ol start=\"2\"><li>日志文件组</li></ol> </li></ul>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DYCx1R7M-1661608724724)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040920532.png)]</p>\n<ol start=\"3\"><li>checkpoint**</li></ol>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9FJvP4Se-1661608724725)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040921715.png)]</p>\n<p>如果 write pos 追上 checkpoint ，表示 日志文件组 满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>\n<h3><a id=\"2_Undo_4445\"></a>2. Undo日志</h3>\n<p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p>\n<h4><a id=\"21Undo_4449\"></a>2.1、如何理解Undo日志</h4>\n<p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>\n<ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul>\n<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p>\n<h4><a id=\"22_Undo_4458\"></a>2.2 Undo日志的作用</h4>\n<ul><li>作用1：回滚数据</li><li>作用2：MVCC（详情看第16章）</li></ul>\n<h4><a id=\"23_undo_4463\"></a>2.3 undo的存储结构</h4>\n<ol><li>回滚段与undo页</li></ol>\n<p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p>\n<ol start=\"2\"><li> <p>回滚段与事务</p> </li><li> <p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p> </li><li> <p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p> </li><li> <p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p> </li><li> <p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p> </li><li> <p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>\n<ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul> </li><li> <p>回滚段中的数据分类</p> </li><li> <p>未提交的回滚数据(uncommitted undo information)</p> </li><li> <p>已经提交但未过期的回滚数据(committed undo information)</p> </li><li> <p>事务已经提交并过期的数据(expired undo information)</p> </li></ol>\n<h4><a id=\"24_undo_4491\"></a>2.4 undo的类型</h4>\n<p>在InnoDB存储引擎中，undo log分为：</p>\n<ul><li>insert undo log</li><li>update undo log</li></ul>\n<h4><a id=\"25_undo_log_4498\"></a>2.5 undo log的生命周期</h4>\n<ol><li>简要生成过程</li></ol>\n<p>只有Buffer Pool的流程：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vy1iYKbj-1661608724726)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040937761.png)]</p>\n<p>有了Redo Log和Undo Log之后：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qKGPNJh9-1661608724727)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040938657.png)]</p>\n<ol start=\"2\"><li>详细生成过程</li></ol>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZnBpMAYj-1661608724728)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040939231.png)]</p>\n<p>当我们执行INSERT时：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">begin</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"tom\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6fZKTSrw-1661608724728)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040940543.png)]</p>\n<p>当我们执行UPDATE时：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r2I5BGlz-1661608724729)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941624.png)]</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">UPDATE</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">SET</span> id<span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2erF7dCz-1661608724729)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941449.png)]</p>\n<ol start=\"3\"><li>undo log是如何回滚的</li></ol>\n<p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>\n<ol><li> <p>通过undo no=3的日志把id=2的数据删除</p> </li><li> <p>通过undo no=2的日志把id=1的数据的deletemark还原成0</p> </li><li> <p>通过undo no=1的日志把id=1的数据的name还原成Tom</p> </li><li> <p>通过undo no=0的日志把id=1的数据删除</p> </li><li> <p>undo log的删除</p> </li></ol>\n<ul><li>针对于insert undo log</li></ul>\n<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>\n<ul><li>针对于update undo log</li></ul>\n<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>\n<h4><a id=\"26_4555\"></a>2.6、小结</h4>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6ltyofEH-1661608724729)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040944948.png)]</p>\n<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>\n<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>\n<h2><a id=\"15__4565\"></a>第15章 锁</h2>\n<h3><a id=\"1____4567\"></a>1. 概述</h3>\n<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p>\n<h3><a id=\"2_MySQL_4571\"></a>2. MySQL并发事务访问相同记录</h3>\n<h4><a id=\"21_4573\"></a>2.1、读-读情况</h4>\n<p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>\n<h4><a id=\"22_4577\"></a>2.2、写-写情况</h4>\n<p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p>\n<p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p>\n<h4><a id=\"23_4583\"></a>2.3、读-写或写-读情况</h4>\n<p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p>\n<h4><a id=\"24_4587\"></a>2.4、并发问题的解决方案</h4>\n<p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p>\n<ul><li>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</li></ul>\n<p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建）。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p>\n<blockquote>\n<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>\n<ul><li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</li><li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作 </code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul>\n</blockquote>\n<ul><li> <p>方案二：读、写操作都采用<code>加锁</code>的方式。</p> </li><li> <p>小结对比发现：</p>\n<ul><li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<code>性能更高</code>。</li><li>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>，影响性能。</li></ul> </li></ul>\n<p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。</p>\n<h3><a id=\"3____4608\"></a>3. 锁的不同角度分类</h3>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SzzcUVwl-1661608724730)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204050933339.png)]</p>\n<h4><a id=\"31_4612\"></a>3.1、从数据操作的类型划分：读锁、写锁</h4>\n<ul><li><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul>\n<p>需要注意的是对于 **InnoDB、引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>\n<ol><li>锁定读</li></ol>\n<p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p>\n<ul><li>对读取的记录加<code>S锁</code>：</li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">LOCK</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SHARE</span> <span class=\"token keyword\">MODE</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 或</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SHARE</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">#(8.0新增语法)</span>\n</code></pre>\n<ul><li>对读取的记录加<code>X锁</code>：</li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>**MySQL8.0新特性：</p>\n<p>在5.7及之前的版本，SELECT … FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT … FOR UPDATE, SELECT … FOR SHARE 添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p>\n<ul><li> <p>NOWAIT：如果查询的行已经加锁，会立即报错返回</p> </li><li> <p>SKIP LOCKED：如果查询的行已经加锁，只返回结果中不包含被锁定的行</p>\n<ol start=\"2\"><li>写操作</li></ol> </li><li> <p><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。</p> </li><li> <p><code>UPDATE</code>：在对一条记录做UPDATE操作时分为三种情况：</p>\n<ul><li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原纪录的位置进行修改操作。</li><li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>情况3：修改该记录的键值，则相当于在原纪录上做<code>DELECT</code>操作之后再来一次<code>INSERT</code>操作。</li></ul> </li><li> <p><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p> </li></ul>\n<h4><a id=\"32_4653\"></a>3.2、从数据操作的粒度划分：表级锁、页级锁、行锁</h4>\n<ol><li>表锁（Table Lock）</li></ol>\n<p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>，并且表锁是<code>开销最少</code>的策略。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p>\n<p>① 表级别的S锁、X锁</p>\n<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p>\n<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，<code>手动</code>获取InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p>\n<ul><li> <p><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。</p> </li><li> <p><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</p> </li></ul>\n<p>总结：MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p>\n<p>② 意向锁 （intention lock）</p>\n<p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而 意向锁 就是其中的一种<code>表锁</code>。</p>\n<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p>\n<p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p>\n<p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p>\n<p>意向锁分为两种：</p>\n<ul><li>意向共享锁 （intention shared lock, IS）：事务有意向对表中的某些行加 共享锁 （S锁）</li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 </span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">column</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">LOCK</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SHARE</span> <span class=\"token keyword\">MODE</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>意向排他锁 （intention exclusive lock, IX）：事务有意向对表中的某些行加 排他锁 （X锁）</li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 </span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">column</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">UPDATE</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p>\n<ol><li>意向锁要解决的问题</li></ol>\n<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级级别的空间示意里面是否已经上过锁。</p>\n<p>在数据表的场景中， 如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了 ，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。</p>\n<ul><li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code></li><li>如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上<code>添加意向排他锁</code></li></ul>\n<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p>\n<p>③ 自增锁（AUTO-INC锁）</p>\n<ol><li>“Simple inserts” （简单插入）</li></ol>\n<p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。</p>\n<ol start=\"2\"><li>“Bulk inserts” （批量插入）</li></ol>\n<p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p>\n<ol start=\"3\"><li>“Mixed-mode inserts” （混合模式插入）</li></ol>\n<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p>\n<p>对于上面数据插入的案例，MySQL采用了<code>自增锁</code>的方式来实现，**AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁 ，在执行插入语句时就在表级别加一个AUTO-INT锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。 一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞 ，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高， 当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争 ，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p>\n<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>\n<p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p>\n<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p>\n<p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p>\n<p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p>\n<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>\n<p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>\n<p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p>\n<p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p>\n<p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可拓展的锁定模式，但是当使用基于语句的复制或恢复方案时， 从二进制日志重播SQL语句时，这是不安全的。</p>\n<p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号）， 为任何给定语句插入的行生成的值可能不是连续的。</p>\n<p>④ 元数据锁（MDL锁）</p>\n<p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>\n<p>因此， 当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>\n<ol start=\"2\"><li>InnoDB中的行锁</li></ol>\n<p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制， 行级锁只在存储引擎层实现。</p>\n<p>优点： 锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code></p>\n<p>缺点： 对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况</p>\n<p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p>\n<p>① 记录锁（Record Locks）</p>\n<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。</p>\n<p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p>\n<ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul>\n<p>② 间隙锁（Gap Locks）</p>\n<p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。</p>\n<p>**gap锁的提出仅仅是为了防止插入幻影记录而提出的 。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p>\n<p>③ 临键锁（Next-Key Locks）</p>\n<p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。Next-Key Locks是在存储引擎<code>innodb</code>、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">begin</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> student <span class=\"token keyword\">where</span> id <span class=\"token operator\">&lt;=</span><span class=\"token number\">8</span> <span class=\"token operator\">and</span> id <span class=\"token operator\">&gt;</span> <span class=\"token number\">3</span> <span class=\"token keyword\">for</span> <span class=\"token keyword\">update</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>④ 插入意向锁（Insert Intention Locks）</p>\n<p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是**InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构 ，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p>\n<p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。</p>\n<p>事实上 插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>\n<ol start=\"3\"><li>页锁</li></ol>\n<p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。 页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</p>\n<p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>\n<h4><a id=\"33_4802\"></a>3.3、从对待锁的态度划分:乐观锁、悲观锁</h4>\n<p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p>\n<ol><li>悲观锁（Pessimistic Locking）</li></ol>\n<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（ 共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 ）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<p>注意：**select … for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</p>\n<ol start=\"2\"><li>乐观锁（Optimistic Locking）</li></ol>\n<p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是 不采用数据库自身的锁机制，而是通过程序来实现 。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。 乐观锁适用于多读的应用类型，这样可以提高吞吐量 。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p>\n<ol><li>乐观锁的版本号机制</li></ol>\n<p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>\n<ol start=\"2\"><li>乐观锁的时间戳机制</li></ol>\n<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>\n<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p>\n<ol start=\"3\"><li>两种锁的适用场景</li></ol>\n<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>\n<ol><li> <p><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p> </li><li> <p><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p> </li></ol>\n<h4><a id=\"34_4834\"></a>3.4、按加锁的方式划分：显式锁、隐式锁</h4>\n<ol><li>隐式锁</li></ol>\n<ul><li> <p>情景一： 对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p> </li><li> <p>情景二： 对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p> </li></ul>\n<p>即：一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p>\n<ol start=\"2\"><li>显式锁</li></ol>\n<p>通过特定的语句进行加锁，我们一般称之为显示加锁。</p>\n<h4><a id=\"35_4848\"></a>3.5、其它锁之：全局锁</h4>\n<p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p>\n<p>全局锁的命令：</p>\n<pre><code class=\"prism language-sql\">Flush <span class=\"token keyword\">tables</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">read</span> <span class=\"token keyword\">lock</span>\n</code></pre>\n<h4><a id=\"36_4858\"></a>3.6、其它锁之：死锁</h4>\n<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>\n<ol><li>如何处理死锁</li></ol>\n<p>方式1： 等待，直到超时（innodb_lock_wait_timeout=50s）</p>\n<p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。</p>\n<p>方式2： 使用死锁检测进行死锁处理</p>\n<p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。</p>\n<h3><a id=\"4____4872\"></a>4. 锁的内存结构</h3>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-COchqSka-1661608724731)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051514736.png)]</p>\n<p>结构解析：</p>\n<p><code>1. 锁所在的事务信息</code>：</p>\n<p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。</p>\n<p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>\n<p><code>2. 索引信息</code>：</p>\n<p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>\n<p><code>3. 表锁／行锁信息</code>：</p>\n<p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p>\n<ul><li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁：记载了三个重要的信息： \n  <ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul> </li></ul>\n<blockquote>\n<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>\n</blockquote>\n<p><code>4. type_mode</code>：</p>\n<p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EF1HEX9D-1661608724731)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051518659.png)]</p>\n<ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下： \n  <ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。</li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。</li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。</li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。</li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul> </li></ul>\n<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>\n<ul><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用： \n  <ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul> </li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在 <code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型： \n  <ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。</li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。</li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul> </li><li><code>is_waiting</code>属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中： \n  <ul><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul> </li></ul>\n<p><code>5. 其他信息</code>：</p>\n<p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>\n<p><code>6. 一堆比特位</code>：</p>\n<p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个 heap_no 属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射到页内的一条记录。</p>\n<h3><a id=\"5____4934\"></a>5. 锁监控</h3>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_row_lock%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul>\n<p>其他监控方法：</p>\n<p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。</p>\n<p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>\n<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>\n<p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p>\n<h2><a id=\"16__4958\"></a>第16章 多版本并发控制</h2>\n<h3><a id=\"1___MVCC_4960\"></a>1. 什么是MVCC**</h3>\n<p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>\n<h3><a id=\"2____4964\"></a>2. 快照读与当前读</h3>\n<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>\n<h4><a id=\"21_4968\"></a>2.1、快照读</h4>\n<p>快照读又叫一致性读，读取的是快照数据。 不加锁的简单的 **SELECT、都属于快照读 ，即不加锁的非阻塞读。</p>\n<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p>\n<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>\n<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>\n<h4><a id=\"22_4978\"></a>2.2、当前读</h4>\n<p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p>\n<h3><a id=\"3____4982\"></a>3. 复习</h3>\n<h4><a id=\"31_4984\"></a>3.1、再谈隔离级别</h4>\n<p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q8DXskeO-1661608724732)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536648.png)]</p>\n<p>另图：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e6x0cuWY-1661608724732)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536125.png)]</p>\n<h4><a id=\"32Undo_Log_4994\"></a>3.2、隐藏字段、Undo Log版本链</h4>\n<p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>\n<ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给trx_id 隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul>\n<h3><a id=\"4_MVCCReadView_5001\"></a>4. MVCC实现原理之ReadView**</h3>\n<p>MVCC 的实现依赖于： 隐藏字段、Undo Log、Read View**。</p>\n<h4><a id=\"41ReadView_5005\"></a>4.1、什么是ReadView**</h4>\n<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，启动了但还没提交）。</p>\n<h4><a id=\"42_5009\"></a>4.2、设计思路</h4>\n<p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>\n<p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>\n<p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>\n<p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p>\n<ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li></ol>\n<blockquote>\n<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>\n</blockquote>\n<ol start=\"2\"><li> <p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。</p> </li><li> <p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。</p> </li><li> <p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p> </li></ol>\n<blockquote>\n<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>\n</blockquote>\n<h4><a id=\"43_ReadView_5031\"></a>4.3 ReadView的规则</h4>\n<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>\n<ul><li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。 \n  <ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul> </li></ul>\n<h4><a id=\"44_MVCC_5042\"></a>4.4 MVCC整体操作流程</h4>\n<p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>\n<ol><li> <p>首先获取事务自己的版本号，也就是事务 ID；</p> </li><li> <p>获取 ReadView；</p> </li><li> <p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p> </li><li> <p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p> </li><li> <p>最后返回符合规则的数据。</p> </li></ol>\n<p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p>\n<p>如表所示：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sLf75PE9-1661608724732)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051549618.png)]</p>\n<blockquote>\n<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p>\n</blockquote>\n<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yEK0sIzr-1661608724733)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051550072.png)]</p>\n<h3><a id=\"5____5068\"></a>5. 举例说明</h3>\n<h4><a id=\"51_READ_COMMITTED_5070\"></a>5.1 READ COMMITTED隔离级别下</h4>\n<p><strong>READ COMMITTED、：每次读取数据前都生成一个ReadView</strong>。</p>\n<h4><a id=\"52_REPEATABLE_READ_5074\"></a>5.2 REPEATABLE READ隔离级别下</h4>\n<p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p>\n<h4><a id=\"53_5078\"></a>5.3、如何解决幻读</h4>\n<p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JRo14W5B-1661608724733)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051556631.png)]</p>\n<p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p>\n<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> student <span class=\"token keyword\">where</span> id <span class=\"token operator\">&gt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p>\n<p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>\n<p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p>\n<p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> student<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'李四'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> student<span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'王五'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HPOAtAJK-1661608724734)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559345.png)]</p>\n<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>\n<p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>\n<p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>\n<p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ngfCVL9b-1661608724734)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559867.png)]</p>\n<p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>\n<h3><a id=\"6____5121\"></a>6. 总结</h3>\n<p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p>\n<p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p>\n<ul><li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView</li><li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul>\n<h2><a id=\"17__5132\"></a>第17章 其它数据库日志</h2>\n<h3><a id=\"1_MySQL_5134\"></a>1. MySQL支持的日志</h3>\n<h4><a id=\"11_5136\"></a>1.1、日志类型</h4>\n<p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p>\n<ul><li> <p>慢查询日志： 记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p> </li><li> <p>通用查询日志： 记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p> </li><li> <p>错误日志： 记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p> </li><li> <p>二进制日志： 记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p> </li><li> <p>中继日志： 用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p> </li><li> <p>数据定义语句日志： 记录数据定义语句执行的元数据操作。</p> </li></ul>\n<p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p>\n<h4><a id=\"12_5154\"></a>1.2、日志的弊端</h4>\n<ul><li> <p>日志功能会<code>降低MySQL数据库的性能</code>。</p> </li><li> <p>日志会<code>占用大量的磁盘空间</code>。</p> </li></ul>\n<h3><a id=\"2___general_query_log_5160\"></a>2. 通用查询日志(general query log)</h3>\n<p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时， 查看通用查询日志，还原操作时的具体场景 ，可以帮助我们准确定位问题。</p>\n<h4><a id=\"21_5164\"></a>2.1、查看当前状态</h4>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%general%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"22_5170\"></a>2.2、启动日志</h4>\n<p>方式1：永久性方式</p>\n<pre><code class=\"prism language-ini\">[mysqld] \ngeneral_log=ON \ngeneral_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名\n</code></pre>\n<p>方式2：临时性方式</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> general_log<span class=\"token operator\">=</span><span class=\"token keyword\">on</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># 开启通用查询日志</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> general_log_file<span class=\"token operator\">=</span>’path<span class=\"token operator\">/</span>filename’<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 设置日志文件保存位置</span>\n<span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> general_log<span class=\"token operator\">=</span><span class=\"token keyword\">off</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># 关闭通用查询日志</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'general_log%'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># 查看设置后情况</span>\n</code></pre>\n<h4><a id=\"23_5189\"></a>2.3、停止日志</h4>\n<p>方式1：永久性方式</p>\n<pre><code class=\"prism language-ini\">[mysqld] \ngeneral_log=OFF\n</code></pre>\n<p>方式2：临时性方式</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> general_log<span class=\"token operator\">=</span><span class=\"token keyword\">off</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'general_log%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"3error_log_5205\"></a>3.错误日志(error log)</h3>\n<h4><a id=\"31_5207\"></a>3.1、启动日志</h4>\n<p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p>\n<pre><code class=\"prism language-ini\">[mysqld] \nlog-error=[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名\n</code></pre>\n<h4><a id=\"32_5216\"></a>3.2、查看日志</h4>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'log_err%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"33_5222\"></a>3.3、删除\\刷新日志</h4>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">install</span> -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log\nmysqladmin -uroot -p flush-logs\n</code></pre>\n<h3><a id=\"4___bin_log_5229\"></a>4. 二进制日志(bin log)</h3>\n<h4><a id=\"41_5231\"></a>4.1、查看默认情况</h4>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%log_bin%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"42_5237\"></a>4.2、日志参数设置</h4>\n<p>方式1：永久性方式</p>\n<pre><code class=\"prism language-ini\">[mysqld] \n#启用二进制日志 \nlog-bin=atguigu-bin \nbinlog_expire_logs_seconds=600 max_binlog_size=100M\n</code></pre>\n<p>设置带文件夹的bin-log日志存放目录</p>\n<pre><code class=\"prism language-ini\">[mysqld] \nlog-bin=\"/var/lib/mysql/binlog/atguigu-bin\"\n</code></pre>\n<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">chown</span> -R -v mysql:mysql binlog\n</code></pre>\n<p>方式2：临时性方式</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># global 级别 </span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> sql_log_bin<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \nERROR <span class=\"token number\">1228</span> <span class=\"token punctuation\">(</span>HY000<span class=\"token punctuation\">)</span>: Variable <span class=\"token string\">'sql_log_bin'</span> <span class=\"token operator\">is</span> a <span class=\"token keyword\">SESSION</span> variable <span class=\"token operator\">and</span> can<span class=\"token punctuation\">`</span>t be used <span class=\"token keyword\">with</span> <span class=\"token keyword\">SET</span> <span class=\"token keyword\">GLOBAL</span> \n\n<span class=\"token comment\"># session级别 </span>\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">SET</span> sql_log_bin<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \nQuery OK<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token keyword\">rows</span> affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span> 秒<span class=\"token punctuation\">)</span>\n</code></pre>\n<h4><a id=\"43_5273\"></a>4.3、查看日志</h4>\n<pre><code class=\"prism language-sql\">mysqlbinlog <span class=\"token operator\">-</span>v <span class=\"token string\">\"/var/lib/mysql/binlog/atguigu-bin.000002\"</span>\n<span class=\"token comment\"># 不显示binlog格式的语句</span>\nmysqlbinlog <span class=\"token operator\">-</span>v <span class=\"token comment\">--base64-output=DECODE-ROWS \"/var/lib/mysql/binlog/atguigu-bin.000002\"</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\"># 可查看参数帮助 </span>\nmysqlbinlog <span class=\"token comment\">--no-defaults --help </span>\n\n<span class=\"token comment\"># 查看最后100行 </span>\nmysqlbinlog <span class=\"token comment\">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100 </span>\n\n<span class=\"token comment\"># 根据position查找 </span>\nmysqlbinlog <span class=\"token comment\">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A20 '4939002'</span>\n</code></pre>\n<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> binlog events <span class=\"token punctuation\">[</span><span class=\"token operator\">IN</span> <span class=\"token string\">'log_name'</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">FROM</span> pos<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">LIMIT</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">offset</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">]</span> row_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li><code>IN 'log_name'</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）</li><li><code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>：偏移量(不指定就是0)</li><li><code>row_count</code>:查询总条数（不指定就是所有行）</li></ul>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> binlog events <span class=\"token operator\">in</span> <span class=\"token string\">'atguigu-bin.000002'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"44_5307\"></a>4.4、使用日志恢复数据</h4>\n<p>mysqlbinlog恢复数据的语法如下：</p>\n<pre><code class=\"prism language-shell\">mysqlbinlog <span class=\"token punctuation\">[</span>option<span class=\"token punctuation\">]</span> filename<span class=\"token operator\">|</span>mysql –uuser -ppass<span class=\"token punctuation\">;</span>\n</code></pre>\n<ul><li><code>filename</code>：是日志文件名。</li><li><code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 --start-position、-- stop-position。 \n  <ul><li><code>--start-date 和 --stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position和--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</li></ul> </li></ul>\n<blockquote>\n<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p>\n</blockquote>\n<h4><a id=\"45_5322\"></a>4.5、删除二进制日志</h4>\n<ol><li>PURGE MASTER LOGS：删除指定日志文件</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">PURGE</span> {MASTER <span class=\"token operator\">|</span> <span class=\"token keyword\">BINARY</span>} LOGS <span class=\"token keyword\">TO</span> ‘指定日志文件名’ \n<span class=\"token keyword\">PURGE</span> {MASTER <span class=\"token operator\">|</span> <span class=\"token keyword\">BINARY</span>} LOGS BEFORE ‘指定日期’\n</code></pre>\n<h3><a id=\"5___binlog_5331\"></a>5. 再谈二进制日志(binlog)</h3>\n<h4><a id=\"51_5333\"></a>5.1、写入机制</h4>\n<p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-V7hQZpvJ-1661608724735)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051630535.png)]</p>\n<p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是 <code>0</code>。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z5O1q7L9-1661608724735)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051631346.png)]</p>\n<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同**redo log、刷盘流程 一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eHbPR7I0-1661608724736)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051632526.png)]</p>\n<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>\n<h4><a id=\"52_binlogredolog_5349\"></a>5.2 binlog与redolog对比</h4>\n<ul><li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。 \n  <ul><li>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性</li></ul> </li></ul>\n<h4><a id=\"53_5357\"></a>5.3、两阶段提交</h4>\n<p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p>\n<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用 两阶段提交 方案。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OESavHVq-1661608724736)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051637390.png)]</p>\n<p>使用 两阶段提交 后，写入binlog时发生异常也不会有影响</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-h7PqS0DH-1661608724737)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639192.png)]</p>\n<p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1SdwvqW9-1661608724737)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639403.png)]</p>\n<p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>\n<h3><a id=\"6___relay_log_5375\"></a>6. 中继日志(relay log)</h3>\n<h4><a id=\"61_5377\"></a>6.1、介绍</h4>\n<p>中继日志只在主从服务器架构的从服务器上存在 。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p>\n<h4><a id=\"62_5381\"></a>6.2、恢复的典型错误</h4>\n<p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p>\n<p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>\n<h2><a id=\"18__5391\"></a>第18章 主从复制</h2>\n<h3><a id=\"1____5393\"></a>1. 主从复制概述</h3>\n<h4><a id=\"11_5395\"></a>1.1、如何提升数据库并发能力</h4>\n<p>一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p>\n<p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p>\n<h4><a id=\"12_5401\"></a>1.2、主从复制的作用</h4>\n<p>第1个作用：读写分离。</p>\n<p>第2个作用就是数据备份。</p>\n<p>第3个作用是具有高可用性。</p>\n<h3><a id=\"2____5409\"></a>2. 主从复制的原理</h3>\n<h4><a id=\"21_5411\"></a>2.1、原理剖析</h4>\n<p>三个线程</p>\n<p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ozg3BtR9-1661608724737)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051646097.png)]</p>\n<p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p>\n<p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p>\n<p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7WFjYIcV-1661608724738)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051647759.png)]</p>\n<p>复制三步骤</p>\n<p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p>\n<p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p>\n<p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p>\n<p>复制的问题</p>\n<p>复制的最大问题：<code>延时</code></p>\n<h4><a id=\"22_5439\"></a>2.2、复制的基本原则</h4>\n<ul><li> <p>每个<code>Slave</code>只有一个<code>Master</code></p> </li><li> <p>每个<code>Slave</code>只能有一个唯一的服务器ID</p> </li><li> <p>每个<code>Master</code>可以有多个<code>Slave</code></p> </li></ul>\n<h3><a id=\"3____5447\"></a>3. 同步数据一致性问题</h3>\n<p>主从同步的要求：</p>\n<ul><li> <p>读库和写库的数据一致(最终一致)；</p> </li><li> <p>写数据必须写到写库；</p> </li><li> <p>读数据必须到读库(不一定)；</p> </li></ul>\n<h4><a id=\"31_5457\"></a>3.1、理解主从延迟问题</h4>\n<p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p>\n<h4><a id=\"32_5461\"></a>3.2、主从延迟问题原因</h4>\n<p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p>\n<p>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。 造成原因：</p>\n<p>1、从库的机器性能比主库要差</p>\n<p>2、从库的压力大</p>\n<p>3、大事务的执行</p>\n<h4><a id=\"33_5473\"></a>3.3、如何减少主从延迟</h4>\n<p>若想要减少主从延迟的时间，可以采取下面的办法：</p>\n<ol><li> <p>降低多线程大事务并发的概率，优化业务逻辑</p> </li><li> <p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p> </li><li> <p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p> </li><li> <p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p> </li><li> <p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p> </li></ol>\n<h4><a id=\"34_5487\"></a>3.4、如何解决一致性问题</h4>\n<p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p>\n<p>方法 1：异步复制</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NWHx1OJB-1661608724738)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051654133.png)]</p>\n<p>方法 2：半同步复制</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TKqEyo1p-1661608724739)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051655175.png)]</p>\n<p>方法 3：组复制</p>\n<p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-A8sNgGU4-1661608724739)(https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051656560.png)]</p>\n<h2><a id=\"_5505\"></a></h2>\n<h2><a id=\"19__5509\"></a>第19章 数据库备份与恢复</h2>\n<h3><a id=\"1____5511\"></a>1. 物理备份与逻辑备份</h3>\n<p>物理备份 ：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p>\n<p>逻辑备份 ：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>\n<h3><a id=\"2_mysqldump_5517\"></a>2. mysqldump实现逻辑备份</h3>\n<h4><a id=\"21_5519\"></a>2.1、备份一个数据库</h4>\n<pre><code class=\"prism language-shell\">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称<span class=\"token punctuation\">[</span>tbname, <span class=\"token punctuation\">[</span>tbname<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span> 备份文件名 称.sql\n</code></pre>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p atguigu<span class=\"token operator\">&gt;</span>atguigu.sql <span class=\"token comment\">#备份文件存储在当前目录下</span>\nmysqldump -uroot -p atguigudb1 <span class=\"token operator\">&gt;</span> /var/lib/mysql/atguigu.sql\n</code></pre>\n<h4><a id=\"22_5530\"></a>2.2、备份全部数据库</h4>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -pxxxxxx --all-databases <span class=\"token operator\">&gt;</span> all_database.sql \nmysqldump -uroot -pxxxxxx -A <span class=\"token operator\">&gt;</span> all_database.sql\n</code></pre>\n<h4><a id=\"23_5537\"></a>2.3、备份部分数据库</h4>\n<pre><code class=\"prism language-shell\">mysqldump –u user –h <span class=\"token function\">host</span> –p --databases <span class=\"token punctuation\">[</span>数据库的名称1 <span class=\"token punctuation\">[</span>数据库的名称2<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> 备份文件名 称.sql\n</code></pre>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p --databases atguigu atguigu12 <span class=\"token operator\">&gt;</span>two_database.sql\nmysqldump -uroot -p -B atguigu atguigu12 <span class=\"token operator\">&gt;</span> two_database.sql\n</code></pre>\n<h4><a id=\"24_5548\"></a>2.4、备份部分表</h4>\n<pre><code class=\"prism language-shell\">mysqldump –u user –h <span class=\"token function\">host</span> –p 数据库的名称 <span class=\"token punctuation\">[</span>表名1 <span class=\"token punctuation\">[</span>表名2<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> 备份文件名称.sql\n</code></pre>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p atguigu book<span class=\"token operator\">&gt;</span> book.sql\n<span class=\"token comment\">#备份多张表 </span>\nmysqldump -uroot -p atguigu book account <span class=\"token operator\">&gt;</span> 2_tables_bak.sql\n</code></pre>\n<h4><a id=\"25_5560\"></a>2.5、备份单表的部分数据</h4>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p atguigu student --where<span class=\"token operator\">=</span><span class=\"token string\">\"id &lt; 10 \"</span> <span class=\"token operator\">&gt;</span> student_part_id10_low_bak.sql\n</code></pre>\n<h4><a id=\"26_5566\"></a>2.6、排除某些表的备份</h4>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p atguigu --ignore-table<span class=\"token operator\">=</span>atguigu.student <span class=\"token operator\">&gt;</span> no_stu_bak.sql\n</code></pre>\n<h4><a id=\"27_5572\"></a>2.7、只备份结构或只备份数据</h4>\n<ul><li>只备份结构</li></ul>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p atguigu --no-data <span class=\"token operator\">&gt;</span> atguigu_no_data_bak.sql\n</code></pre>\n<ul><li>只备份数据</li></ul>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p atguigu --no-create-info <span class=\"token operator\">&gt;</span> atguigu_no_create_info_bak.sql\n</code></pre>\n<h4><a id=\"28_5586\"></a>2.8、备份中包含存储过程、函数、事件</h4>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p -R -E --databases atguigu <span class=\"token operator\">&gt;</span> fun_atguigu_bak.sql\n</code></pre>\n<h3><a id=\"3_mysql_5592\"></a>3. mysql命令恢复数据</h3>\n<pre><code class=\"prism language-shell\">mysql –u root –p <span class=\"token punctuation\">[</span>dbname<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> backup.sql\n</code></pre>\n<h4><a id=\"31_5598\"></a>3.1、单库备份中恢复单库</h4>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\">#备份文件中包含了创建数据库的语句</span>\nmysql -uroot -p <span class=\"token operator\">&lt;</span> atguigu.sql\n<span class=\"token comment\">#备份文件中不包含了创建数据库的语句</span>\nmysql -uroot -p atguigu<span class=\"token operator\"><span class=\"token file-descriptor important\">4</span>&lt;</span> atguigu.sql\n</code></pre>\n<h4><a id=\"32_5607\"></a>3.2、全量备份恢复</h4>\n<pre><code class=\"prism language-shell\">mysql –u root –p <span class=\"token operator\">&lt;</span> all.sql\n</code></pre>\n<h4><a id=\"33_5613\"></a>3.3、从全量备份中恢复单库</h4>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">sed</span> -n <span class=\"token string\">'/^-- Current Database: `atguigu`/,/^-- Current Database: `/p'</span> all_database.sql <span class=\"token operator\">&gt;</span> atguigu.sql \n<span class=\"token comment\">#分离完成后我们再导入atguigu.sql即可恢复单个库</span>\n</code></pre>\n<h4><a id=\"34_5620\"></a>3.4、从单库备份中恢复单表</h4>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">cat</span> atguigu.sql <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -e <span class=\"token string\">'/./{H;$!d;}'</span> -e <span class=\"token string\">'x;/CREATE TABLE `class`/!d;q'</span> <span class=\"token operator\">&gt;</span> class_structure.sql \n<span class=\"token function\">cat</span> atguigu.sql <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> --ignore-case <span class=\"token string\">'insert into `class`'</span> <span class=\"token operator\">&gt;</span> class_data.sql \n<span class=\"token comment\">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 </span>\n\nuse atguigu<span class=\"token punctuation\">;</span> \nmysql<span class=\"token operator\">&gt;</span> <span class=\"token builtin class-name\">source</span> class_structure.sql<span class=\"token punctuation\">;</span> \nQuery OK, <span class=\"token number\">0</span> rows affected, <span class=\"token number\">1</span> warning <span class=\"token punctuation\">(</span><span class=\"token number\">0.00</span> sec<span class=\"token punctuation\">)</span> \n\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token builtin class-name\">source</span> class_data.sql<span class=\"token punctuation\">;</span> \nQuery OK, <span class=\"token number\">1</span> row affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span> sec<span class=\"token punctuation\">)</span>\n</code></pre>\n<h3><a id=\"4____5635\"></a>4. 表的导出与导入</h3>\n<h4><a id=\"41_5637\"></a>4.1、表的导出</h4>\n<ol><li>使用SELECT…INTO OUTFILE导出文本文件</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%secure%'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> account <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">OUTFILE</span> <span class=\"token string\">\"/var/lib/mysql-files/account.txt\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>使用mysqldump命令导出文本文件</li></ol>\n<pre><code class=\"prism language-shell\">mysqldump -uroot -p -T <span class=\"token string\">\"/var/lib/mysql-files/\"</span> atguigu account\n<span class=\"token comment\"># 或</span>\nmysqldump -uroot -p -T <span class=\"token string\">\"/var/lib/mysql-files/\"</span> atguigu account --fields-terminated- <span class=\"token assign-left variable\">by</span><span class=\"token operator\">=</span><span class=\"token string\">','</span> --fields-optionally-enclosed-by<span class=\"token operator\">=</span><span class=\"token string\">'\\\"'</span>\n</code></pre>\n<ol start=\"3\"><li>使用mysql命令导出文本文件</li></ol>\n<pre><code class=\"prism language-shell\">mysql -uroot -p --execute<span class=\"token operator\">=</span><span class=\"token string\">\"SELECT * FROM account;\"</span> atguigu<span class=\"token operator\">&gt;</span> <span class=\"token string\">\"/var/lib/mysql-files/account.txt\"</span>\n</code></pre>\n<h4><a id=\"42_5660\"></a>4.2、表的导入</h4>\n<ol><li>使用LOAD DATA INFILE方式导入文本文件</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">LOAD</span> <span class=\"token keyword\">DATA</span> <span class=\"token keyword\">INFILE</span> <span class=\"token string\">'/var/lib/mysql-files/account_0.txt'</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">TABLE</span> atguigu<span class=\"token punctuation\">.</span>account<span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 或</span>\n<span class=\"token keyword\">LOAD</span> <span class=\"token keyword\">DATA</span> <span class=\"token keyword\">INFILE</span> <span class=\"token string\">'/var/lib/mysql-files/account_1.txt'</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">TABLE</span> atguigu<span class=\"token punctuation\">.</span>account <span class=\"token keyword\">FIELDS</span> <span class=\"token keyword\">TERMINATED</span> <span class=\"token keyword\">BY</span> <span class=\"token string\">','</span> <span class=\"token keyword\">ENCLOSED</span> <span class=\"token keyword\">BY</span> <span class=\"token string\">'\\\"'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>使用mysqlimport方式导入文本文件</li></ol>\n<pre><code class=\"prism language-shell\">mysqlimport -uroot -p atguigu <span class=\"token string\">'/var/lib/mysql-files/account.txt'</span> --fields-terminated- <span class=\"token assign-left variable\">by</span><span class=\"token operator\">=</span><span class=\"token string\">','</span> --fields-optionally-enclosed-by<span class=\"token operator\">=</span><span class=\"token string\">'\\\"'</span>\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 1, "php": 0, "time": "2022-08-27 22:45:55", "summary": "文章目录高级一下的安装与使用安装前说明的版安装登录下修改配置字符集的相关操作、各级别的字符集、请求到响应过程中字符集的变化二的数据目录三用户与权限管理四、逻辑架构、逻辑架构剖析、服务器处理客户端请求、"}