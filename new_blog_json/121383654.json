{"blogid": "121383654", "writerAge": "码龄1年", "writerBlogNum": "137", "writerCollect": "10855", "writerComment": "4382", "writerFan": "41378", "writerGrade": "7级", "writerIntegral": "11238", "writerName": "安然无虞", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121383654.jpg", "writerRankTotal": "987", "writerRankWeekly": "914", "writerThumb": "5633", "writerVisitNum": "429004", "blog_read_count": "16349", "blog_time": "已于 2022-01-27 23:24:38 修改", "blog_title": "【两万字精编】蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（下）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>欢迎回到：<span style=\"color:#956fe7;\">遇见蓝桥遇见你，不负代码不负卿！</span></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0\">【补充】：常用头文件及库函数</a></p>\n<p id=\"1.%23include%3Cstdio.h%3E-toc\" style=\"margin-left:40px;\"><a href=\"#1.%23include%3Cstdio.h%3E\">1.#include</a></p>\n<p id=\"sscanf()%20%E5%92%8C%20sprintf()-toc\" style=\"margin-left:80px;\"><a href=\"#sscanf%28%29%20%E5%92%8C%20sprintf%28%29\">sscanf() 和 sprintf()</a></p>\n<p id=\"2.%23include%3Cstdlib.h%3E-toc\" style=\"margin-left:40px;\"><a href=\"#2.%23include%3Cstdlib.h%3E\">2.#include</a></p>\n<p id=\"3.%23include%3Ctime.h%3E-toc\" style=\"margin-left:40px;\"><a href=\"#3.%23include%3Ctime.h%3E\">3.#include</a></p>\n<p id=\"4.%23include%3Cmath.h%3E-toc\" style=\"margin-left:40px;\"><a href=\"#4.%23include%3Cmath.h%3E\">4.#include</a></p>\n<p id=\"(1).fabs(double%20x)-toc\" style=\"margin-left:80px;\"><a href=\"#%281%29.fabs%28double%20x%29\">(1).fabs(double x)</a></p>\n<p id=\"(2).pow(double%20r%2C%20double%20p)-toc\" style=\"margin-left:80px;\"><a href=\"#%282%29.pow%28double%20r%2C%20double%20p%29\">(2).pow(double r, double p)</a></p>\n<p id=\"(3).sqrt(double%20x)-toc\" style=\"margin-left:80px;\"><a href=\"#%283%29.sqrt%28double%20x%29\">(3).sqrt(double x)</a></p>\n<p id=\"5.%23include%3Cstring.h%3E-toc\" style=\"margin-left:40px;\"><a href=\"#5.%23include%3Cstring.h%3E\">5.#include</a></p>\n<p id=\"(1).strlen()-toc\" style=\"margin-left:80px;\"><a href=\"#%281%29.strlen%28%29\">(1).strlen()</a></p>\n<p id=\"(2).strcmp()-toc\" style=\"margin-left:80px;\"><a href=\"#%282%29.strcmp%28%29\">(2).strcmp()</a></p>\n<p id=\"(3).strcpy()-toc\" style=\"margin-left:80px;\"><a href=\"#%283%29.strcpy%28%29\">(3).strcpy()</a></p>\n<p id=\"(4).strcat()-toc\" style=\"margin-left:80px;\"><a href=\"#%284%29.strcat%28%29\">(4).strcat()</a></p>\n<p id=\"6.%23include%3Cvector%3E%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#6.%23include%3Cvector%3E%C2%A0\">6.#include </a></p>\n<p id=\"7.%23include%3Cqueue%3E-toc\" style=\"margin-left:40px;\"><a href=\"#7.%23include%3Cqueue%3E\">7.#include</a></p>\n<p id=\"8.%23include%3Cstack%3E-toc\" style=\"margin-left:40px;\"><a href=\"#8.%23include%3Cstack%3E\">8.#include</a></p>\n<p id=\"9.%23include%3Calgorithm%3E-toc\" style=\"margin-left:40px;\"><a href=\"#9.%23include%3Calgorithm%3E\">9.#include</a></p>\n<p id=\"%E4%B8%80%E3%80%81string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3\">一、string的常见用法详解</a></p>\n<p id=\"1.string%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#1.string%E7%9A%84%E5%AE%9A%E4%B9%89\">1.string的定义</a></p>\n<p id=\"2.string%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:40px;\"><a href=\"#2.string%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE\">2.string中内容的访问</a></p>\n<p id=\"(1).%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:80px;\"><a href=\"#%281%29.%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE\">(1).通过下标访问</a></p>\n<p id=\"(3).%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:80px;\"><a href=\"#%283%29.%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE\">(3).通过迭代器访问</a></p>\n<p id=\"3.string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#3.string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90\">3.string常用函数实例解析</a></p>\n<p id=\"(1).operator%2B%3D-toc\" style=\"margin-left:80px;\"><a href=\"#%281%29.operator%2B%3D\">(1).operator+=</a></p>\n<p id=\"(2).compare%20operator-toc\" style=\"margin-left:80px;\"><a href=\"#%282%29.compare%20operator\">(2).compare operator</a></p>\n<p id=\"(3).length()%20%2F%20size()-toc\" style=\"margin-left:80px;\"><a href=\"#%283%29.length%28%29%20%2F%20size%28%29\">(3).length() / size()</a></p>\n<p id=\"(4).insert()-toc\" style=\"margin-left:80px;\"><a href=\"#%284%29.insert%28%29\">(4).insert()</a></p>\n<p id=\"(5).erase()-toc\" style=\"margin-left:80px;\"><a href=\"#%285%29.erase%28%29\">(5).erase()</a></p>\n<p id=\"(6).clear()-toc\" style=\"margin-left:80px;\"><a href=\"#%286%29.clear%28%29\">(6).clear()</a></p>\n<p id=\"(7).substr()-toc\" style=\"margin-left:80px;\"><a href=\"#%287%29.substr%28%29\">(7).substr()</a></p>\n<p id=\"(8).string%3A%3Anpos-toc\" style=\"margin-left:80px;\"><a href=\"#%288%29.string%3A%3Anpos\">(8).string::npos</a></p>\n<p id=\"(9).find()-toc\" style=\"margin-left:80px;\"><a href=\"#%289%29.find%28%29\">(9).find()</a></p>\n<p id=\"(10).replace()-toc\" style=\"margin-left:80px;\"><a href=\"#%2810%29.replace%28%29\">(10).replace()</a></p>\n<p id=\"%E4%BA%8C%E3%80%81queue%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81queue%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3\">二、queue的常见用法详解</a></p>\n<p id=\"1.queue%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#1.queue%E7%9A%84%E5%AE%9A%E4%B9%89\">1.queue的定义</a></p>\n<p id=\"2.queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:40px;\"><a href=\"#2.queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE\">2.queue容器内元素的访问</a></p>\n<p id=\"3.queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#3.queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90\">3.queue常用函数实例解析</a></p>\n<p id=\"(1).push()-toc\" style=\"margin-left:80px;\"><a href=\"#%281%29.push%28%29\">(1).push()</a></p>\n<p id=\"(2).front()%2C%20back()-toc\" style=\"margin-left:80px;\"><a href=\"#%282%29.front%28%29%2C%20back%28%29\">(2).front(), back()</a></p>\n<p id=\"(3).pop()-toc\" style=\"margin-left:80px;\"><a href=\"#%283%29.pop%28%29\">(3).pop()</a></p>\n<p id=\"(4).empty()-toc\" style=\"margin-left:80px;\"><a href=\"#%284%29.empty%28%29\">(4).empty()</a></p>\n<p id=\"(5).size()-toc\" style=\"margin-left:80px;\"><a href=\"#%285%29.size%28%29\">(5).size()</a></p>\n<p id=\"%E4%B8%89%E3%80%81stack%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81stack%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3\">三、stack的常见用法详解</a></p>\n<p id=\"1.stack%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#1.stack%E7%9A%84%E5%AE%9A%E4%B9%89\">1.stack的定义</a></p>\n<p id=\"2.stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:40px;\"><a href=\"#2.stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE\">2.stack容器内元素的访问</a></p>\n<p id=\"3.stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#3.stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90\">3.stack常用函数实例解析</a></p>\n<p id=\"(1).push()-toc\" style=\"margin-left:80px;\"><a href=\"#%281%29.push%28%29\">(1).push()</a></p>\n<p id=\"(2).top()-toc\" style=\"margin-left:80px;\"><a href=\"#%282%29.top%28%29\">(2).top()</a></p>\n<p id=\"(3).pop()-toc\" style=\"margin-left:80px;\"><a href=\"#%283%29.pop%28%29\">(3).pop()</a></p>\n<p id=\"(4).empty()-toc\" style=\"margin-left:80px;\"><a href=\"#%284%29.empty%28%29\">(4).empty()</a></p>\n<p id=\"(5).size()-toc\" style=\"margin-left:80px;\"><a href=\"#%285%29.size%28%29\">(5).size()</a></p>\n<p id=\"%E5%9B%9B%E3%80%81algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0\">四、algorithm头文件下的常用函数</a></p>\n<p id=\"1.max()%E3%80%81min()%E5%92%8Cabs()-toc\" style=\"margin-left:40px;\"><a href=\"#1.max%28%29%E3%80%81min%28%29%E5%92%8Cabs%28%29\">1.max()、min()和abs()</a></p>\n<p id=\"(2).swap()-toc\" style=\"margin-left:40px;\"><a href=\"#%282%29.swap%28%29\">2.swap()</a></p>\n<p id=\"(3).reverse()-toc\" style=\"margin-left:40px;\"><a href=\"#%283%29.reverse%28%29\">3.reverse()</a></p>\n<p id=\"(4).next_permutation()-toc\" style=\"margin-left:40px;\"><a href=\"#%284%29.next_permutation%28%29\">4.next_permutation()</a></p>\n<p id=\"(5).fill()-toc\" style=\"margin-left:40px;\"><a href=\"#%285%29.fill%28%29\">5.fill()</a></p>\n<p id=\"(6).sort()-toc\" style=\"margin-left:40px;\"><a href=\"#%286%29.sort%28%29\">6.sort()</a></p>\n<p id=\"%3C1%3E.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%3C1%3E.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F\">&lt;1&gt;.基本数据类型数组的排序</a></p>\n<p id=\"%3C2%3E.%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%3C2%3E.%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F\">&lt;2&gt;.结构体数组的排序</a></p>\n<p id=\"%3C3%3E.%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%3C3%3E.%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F\">&lt;3&gt;.容器的排序</a></p>\n<p id=\"(7).lower_bound()%E5%92%8Cupper_bound()-toc\" style=\"margin-left:40px;\"><a href=\"#%287%29.lower_bound%28%29%E5%92%8Cupper_bound%28%29\">7.lower_bound()和upper_bound()</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E8%93%9D%E6%A1%A5%E7%BB%93%E8%AF%AD%EF%BC%9A%E9%81%87%E8%A7%81%E8%93%9D%E6%A1%A5%E9%81%87%E8%A7%81%E4%BD%A0%EF%BC%8C%E4%B8%8D%E8%B4%9F%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%B4%9F%E5%8D%BF%EF%BC%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E8%93%9D%E6%A1%A5%E7%BB%93%E8%AF%AD%EF%BC%9A%E9%81%87%E8%A7%81%E8%93%9D%E6%A1%A5%E9%81%87%E8%A7%81%E4%BD%A0%EF%BC%8C%E4%B8%8D%E8%B4%9F%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%B4%9F%E5%8D%BF%EF%BC%81\">五、蓝桥结语：遇见蓝桥遇见你，不负代码不负卿！</a></p>\n<hr id=\"hr-toc\"/>\n<p>【前言】</p>\n<blockquote>\n<p>这篇是上次文章的后续哦，铁汁们可以先回顾一下上篇的内容。</p>\n</blockquote>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_57544072/article/details/121311117\" title=\"蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（上）（万字博文，建议抱走）_安然无虞的博客-CSDN博客\">蓝桥杯算法竞赛系列第0章——蓝桥必考点及标准模板库STL（上）（万字博文，建议抱走）_安然无虞的博客-CSDN博客</a></p>\n<blockquote>\n<p>上次有好几位铁汁建议我多换点图片，表示看腻了，也有不少热心小友私发给了我一些，但是由于格式大小的问题，能用的不多，不过在这里还是要特别感谢一下哈，抱拳啦。</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"385\" src=\"..\\..\\static\\image\\73bdeb6aeb25481ba27bc19e9565746b.jpg\" width=\"570\"/></p>\n<h1 id=\"%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0\">【补充】：常用头文件及库函数</h1>\n<blockquote>\n<ul><li>#include&lt;stdio.h&gt;</li><li>#include&lt;iostream&gt;</li><li>#include&lt;stdlib.h&gt;</li><li>#include&lt;time.h&gt;</li><li>#include&lt;math.h&gt;</li><li>#include&lt;string.h&gt;</li><li>#include&lt;vector&gt;</li><li>#include&lt;string&gt;</li><li>#include&lt;queue&gt;</li><li>#include&lt;stack&gt;</li><li>#include&lt;algorithm&gt;</li></ul>\n</blockquote>\n<h2 id=\"1.%23include%3Cstdio.h%3E\">1.#include&lt;stdio.h&gt;</h2>\n<blockquote>\n<ul><li>scanf()</li><li>printf()</li><li>getchar()</li><li>putchar()</li><li>gets()</li><li>puts()</li><li>sscanf()</li><li>sprintf()</li></ul>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">标准输入输出头文件，当然除了scanf() 和 printf() 很重要外，sscanf() 和 sprintf()也是非常重要的，</span>对于这两个库函数，老师从未讲过，但是看题解时经常出现，它们是用来处理字符串的利器。待会再谈它们，<span style=\"color:#956fe7;\">先讲一下scanf() 的弊端，对于scanf() 函数，不能读入空格，遇到空格就结束了</span>，所以处理起字符串就很不方便。所以这里还有两个库函数用来处理字符串：gets() 和 puts() ,<span style=\"color:#956fe7;\"> gets() 用来输入一行字符串，识别'\\n' 结束，遇到空格不会结束哦，puts() 用来输出一行字符串，并且紧跟一个换行,</span>对于putchar()和getchar() 用得不多，有兴趣可自行了解哦。</p>\n</blockquote>\n<h3 id=\"sscanf()%20%E5%92%8C%20sprintf()\">sscanf() 和 sprintf()</h3>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">sscanf() 与 sprintf() 是处理字符串问题的利器，我们很有必要学会它们(sscanf() 从单词上可理解为 string + scanf , sprintf 则可理解为 string + printf, 均在stdio.h 头文件下) 。</span>先来回顾一下scanf() 和 printf(), 如果想要从屏幕上输入int 型变量n 并将int 型变量 n 输出到屏幕上，则可以写成下面这样：</p>\n</blockquote>\n<pre><code class=\"language-cpp\">scanf(\"%d\", &amp;n);\nprintf(\"%d\", n);</code></pre>\n<p>事实上，上面的写法其实可以表示成下面的样子，其中screen 表示屏幕：</p>\n<pre><code class=\"language-cpp\">scanf(screen, \"%d\", &amp;n);\nprintf(screen, \"%d\", n);</code></pre>\n<p>可以发现，scanf() 的输入其实是把screen 的内容以\"%d\" 的格式传输到n 中（即从左至右），而printf() 的输出则是把n 以“%d” 的格式传输到screen 上（即从右至左）</p>\n<p>sscanf() 和 sprintf() 与上面的格式是相同的，只不过把screen 换成了字符数组（假设定义了一个char 数组 str[100]）,如下所示：</p>\n<pre><code class=\"language-cpp\">sscanf(str, \"%d\", &amp;n);\nsprintf(str, \"%d\", n);</code></pre>\n<p><span style=\"color:#956fe7;\">上面的sscanf() 写法的作用是把字符数组str 中的内容以\"%d\" 的格式写到n 中（还是从左至右）</span></p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n\nint main()\n{\n\tint n = 0;\n\tchar str[100] = \"123\";\n\tsscanf(str, \"%d\", &amp;n);\n\n\tprintf(\"%d\\n\", n);//输出123\n\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#956fe7;\">而sprintf() 写法的作用是把n 以\"%d\" 的格式写到str 字符数组中（还是从右至左）</span></p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n\nint main()\n{\n\tint n = 233;\n\tchar str[100];\n\tsprintf(str, \"%d\", n);\n\tprintf(\"%s\\n\", str);//输出233\n\treturn 0;\n}</code></pre>\n<p>上面只是一些简单的应用，事实上，可以像使用scanf() 和 printf() 那样进行复杂的格式的输入和输出。例如下面的代码使用sscanf() 将字符数组str 中的内容按\"%d:%lf,%s\"的格式写到int 型变量n、double 型变量db、char型数组str2中</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n\nint main()\n{\n\tint n;\n\tdouble db;\n\tchar str[100] = \"2048:3.14,hello\", str2[100];\n\tsscanf(str, \"%d:%lf,%s\", &amp;n, &amp;db, str2);\n\tprintf(\"n = %d, db = %lf, str2 = %s\\n\", n, db, str2);\n\treturn 0;\n}</code></pre>\n<p>类似的，下面的代码使用sprintf() 将int 型变量n 、double 型变量db、char 型数组str2 按\"%d:%lf,%s\" 的格式写到字符数组str 中</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n\nint main()\n{\n\tint n = 12;\n\tdouble db = 3.1415;\n\tchar str[100], str2[100] = \"good\";\n\tsprintf(str, \"%d:%.2lf,%s\", n, db, str2);\n\tprintf(\"str = %s\\n\", str);\n\treturn 0;\n}</code></pre>\n<h2 id=\"2.%23include%3Cstdlib.h%3E\">2.#include&lt;stdlib.h&gt;</h2>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">主要用于生成随机数以及动态内存开辟，常用的库函数有srand((unsigned int) time(NULL)),rand() 和动态内存开辟用的malloc(),用new会更简单一些</span></p>\n</blockquote>\n<h2 id=\"3.%23include%3Ctime.h%3E\">3.#include&lt;time.h&gt;</h2>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">上面生成随机数的时候，常用time()函数用于生成时间戳，作为随机数种子</span></p>\n</blockquote>\n<h2 id=\"4.%23include%3Cmath.h%3E\">4.#include&lt;math.h&gt;</h2>\n<blockquote>\n<ul><li>fabs()</li><li>sqrt()</li><li>pow()</li><li>floor()</li><li>ceil()</li><li>round()</li></ul>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">用数学函数可以节省大量的时间，所以一定要记住，对于很常用的其实也就是fabs()、sqrt()和pow()</span></p>\n</blockquote>\n<h3 id=\"(1).fabs(double%20x)\">(1).fabs(double x)</h3>\n<blockquote>\n<p><span style=\"color:#956fe7;\">该函数用于对double 型变量取绝对值。</span></p>\n</blockquote>\n<h3 id=\"(2).pow(double%20r%2C%20double%20p)\">(2).pow(double r, double p)</h3>\n<blockquote>\n<p><span style=\"color:#956fe7;\">该函数用于返回 r ^ p ，要求r 和 p 都是double类型的</span></p>\n</blockquote>\n<h3 id=\"(3).sqrt(double%20x)\">(3).sqrt(double x)</h3>\n<blockquote>\n<p><span style=\"color:#956fe7;\">该函数用于返回double型变量的算数平方根</span></p>\n<p>在这里就只简单介绍这三个最常用的。</p>\n</blockquote>\n<h2 id=\"5.%23include%3Cstring.h%3E\">5.#include&lt;string.h&gt;</h2>\n<blockquote>\n<ul><li>strlen()</li><li>strcmp()</li><li>strcpy()</li><li>strcat()</li></ul>\n</blockquote>\n<h3 id=\"(1).strlen()\">(1).strlen()</h3>\n<blockquote>\n<p><span style=\"color:#956fe7;\">strlen()函数可以得到字符数组中第一个\\0之前的字符的个数</span></p>\n</blockquote>\n<h3 id=\"(2).strcmp()\">(2).strcmp()</h3>\n<blockquote>\n<p>strcmp()函数返回两个字符串大小的比较结果，比较原则是按字典序，所谓字典序就是字符串在字典中的顺序，因此如果有两个字符数组str 1 和 str 2, 且满足str 1[0...k - 1] == str 2[0...k - 1]、str1[k] &lt; str2[k], 那么就说str 1的字典序小于str2。例如\"a\" 的字典序小于\"b\"、\"aaaa\" 的字典序小于\"aab\"</p>\n</blockquote>\n<blockquote>\n<p>strcmp()函数的返回值：</p>\n<ul><li><span style=\"color:#4da8ee;\">如果字符数组1 &lt; 字符数组2，则返回一个负整数（不一定是-1，由编译器决定）</span></li><li><span style=\"color:#4da8ee;\">如果字符数组1 == 字符数组2，则返回0</span></li><li><span style=\"color:#4da8ee;\">如果字符数组1 &gt; 字符数组2，则返回一个正整数（不一定是1，由编译器决定）</span></li></ul>\n</blockquote>\n<h3 id=\"(3).strcpy()\">(3).strcpy()</h3>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">strcpy()函数可以把一个字符串复制给另一个字符串</span>，格式如下：</p>\n</blockquote>\n<pre><code class=\"language-cpp\">strcpy(字符数组1，字符数组2);</code></pre>\n<blockquote>\n<p><span style=\"color:#956fe7;\">注意哦，是把字符数组2复制给字符数组1，</span>这里的“复制” 包括了结束标志\\0 ，<span style=\"color:#fe2c24;\">而且需要特别注意的是字符数组1一定是足够大的！ </span></p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nint main()\n{\n\tchar str1[50] = \"Thank\";\n\tchar str2[50] = \"you for your smile.\";\n\tstrcpy(str1, str2);\n\tputs(str1);//输出you for your smile.\n\t//printf(\"%s\\n\", str1);\n\treturn 0;\n\n}</code></pre>\n<h3 id=\"(4).strcat()\">(4).strcat()</h3>\n<blockquote>\n<p><span style=\"color:#956fe7;\">strcat()可以把一个字符串拼接到另一个字符串的后面</span></p>\n</blockquote>\n<pre><code class=\"language-cpp\">strcat(字符数组1， 字符数组2)；</code></pre>\n<blockquote>\n<p><span style=\"color:#956fe7;\">注意哦，是把字符数组2拼接到字符数组1的后面 </span></p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nint main()\n{\n\tchar str1[50] = \"Thank\";\n\tchar str2[50] = \"you for your smile.\";\n\tstrcat(str1, str2);\n\tputs(str1);//输出 Thankyou for your smile.\n\t//printf(\"%s\\n\", str1);\n\treturn 0;\n\treturn 0;\n}</code></pre>\n<h2 id=\"6.%23include%3Cvector%3E%C2%A0\">6.#include&lt;vector&gt; </h2>\n<blockquote>\n<p>常用函数：</p>\n<ul><li>push_back()</li><li>pop_back()</li><li>size()</li><li>clear()</li></ul>\n</blockquote>\n<h2 id=\"7.%23include%3Cqueue%3E\">7.#include&lt;queue&gt;</h2>\n<blockquote>\n<p>常用函数</p>\n<ul><li>push()</li><li>pop()</li><li>front()</li><li>back()</li><li>empty()</li><li>size()</li></ul>\n</blockquote>\n<h2 id=\"8.%23include%3Cstack%3E\">8.#include&lt;stack&gt;</h2>\n<blockquote>\n<p>常用函数：</p>\n<ul><li>push()</li><li>pop()</li><li>top()</li><li>empty()</li><li>size()</li></ul>\n</blockquote>\n<h2 id=\"9.%23include%3Calgorithm%3E\">9.#include&lt;algorithm&gt;</h2>\n<blockquote>\n<p>常用函数：</p>\n<ul><li>max()</li><li>min()</li><li>swap()</li><li>fill()</li><li>sort()</li></ul>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"271\" src=\"..\\..\\static\\image\\d8d2f2b077a0454998a6d38c7ad65f17.png\" width=\"178\"/></p>\n<blockquote>\n<p>下面在介绍一些常见的容器： </p>\n</blockquote>\n<h1 id=\"%E4%B8%80%E3%80%81string%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3\">一、string的常见用法详解</h1>\n<blockquote>\n<p>在C语言中，一般使用字符数组char str[ ] 来存放字符串，但是使用字符数组有时会显得操作麻烦，而且容易因经验不足产生错误，得不偿失。为了使编程者可以更方便的对字符串进行操作，C++在STL中加入了string类型，对字符串常用的需求功能进行了封装，使得操作起来更方便，且不易出错。</p>\n</blockquote>\n<blockquote>\n<p>如果要使用string，需要添加string头文件，即#include&lt;string&gt;（注意string.h 和 string 是不一样的头文件）。除此之外，还需要在头文件下面加上一句：\"using namespace std;\", 这样就可以在代码中使用string了。下面来看string的一些常见用法。</p>\n</blockquote>\n<h2 id=\"1.string%E7%9A%84%E5%AE%9A%E4%B9%89\">1.string的定义</h2>\n<p>定义string的方式跟基本数据类型相同，只需要在string后面跟上变量名即可：</p>\n<pre><code class=\"language-cpp\">string str;</code></pre>\n<p>如果要初始化，可以直接给string类型的变量进行赋值：</p>\n<pre><code class=\"language-cpp\">string str = \"abcd\"</code></pre>\n<h2 id=\"2.string%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE\">2.string中内容的访问</h2>\n<h3 id=\"(1).%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE\">(1).通过下标访问</h3>\n<p>一般来说，可以直接像字符数组那样去访问string：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcd\";\n\tfor (int i = 0; i &lt; str.length(); i++)\n\t{\n\t\tprintf(\"%c \", str[i]);//输出a b c d\n\t}\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#4da8ee;\">注意哦，如果要读入和输出整个字符串，则只能用cin 和  cout:</span></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;//cin和cout在iostream头文件中，而不是stdio.h\n#include&lt;string&gt;\n\nusing namespace std;\nint main()\n{\n\tstring str;\n\tcin &gt;&gt; str;\n\tcout &lt;&lt; str;\n\n\treturn 0;\n}</code></pre>\n<p>上面的代码对任意的字符串输入，都会输出同样的字符串。</p>\n<p>那么，真的没有办法用printf来输出string吗？其实是有的，即用c_str()将string类型转换为字符数组进行输出，示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcd\";\n\tprintf(\"%s\\n\", str.c_str());//将string型str使用c_str()变成字符数组\n\treturn 0;\n}</code></pre>\n<h3 id=\"(3).%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE\">(3).通过迭代器访问</h3>\n<p>一般仅通过（1）即可满足访问的要求，但是有些函数比如insert()与erase()则要求以迭代器为参数，因此还是需要学习一下string迭代器的用法。</p>\n<p>由于string不像其他STL容器那样需要参数，因此可以直接入下定义：</p>\n<pre><code class=\"language-cpp\">string::iterator it;</code></pre>\n<p>这样就得到了迭代器it, 并且可以通过*it 来访问string里的每一位：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcd\";\n\tfor (string::iterator it = str.begin(); it != str.end(); it++)\n\t{\n\t\tprintf(\"%c \", *it);//输出a b c d\n\t}\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>最后指出，string和vector一样，支持直接对迭代器进行加减某个数字，如str.begin() + 3的写法是可行的</p>\n</blockquote>\n<h2 id=\"3.string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90\">3.string常用函数实例解析</h2>\n<blockquote>\n<ul><li>operator+=</li><li>compare operator</li><li>length() / size()</li><li>insert()</li><li>erase()</li><li>clear()</li><li>substr()</li><li>string::nops</li><li>find()</li><li>replace()</li></ul>\n</blockquote>\n<h3 id=\"(1).operator%2B%3D\">(1).operator+=</h3>\n<blockquote>\n<p>这是string的加法，可以将两个string<span style=\"color:#956fe7;\">直接拼接</span>起来</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str1 = \"abc\", str2 = \"xyz\", str3;\n\tstr3 = str1 + str2;//将str1和str2拼接，赋值给str3\n\tstr1 = str1 + str2;//将str2直接拼接到str1上\n\n\tcout &lt;&lt; str1 &lt;&lt; endl;//输出abcxyz\n\tcout &lt;&lt; str3 &lt;&lt; endl;//输出abcxyz\n\n\treturn 0;\n}</code></pre>\n<h3 id=\"(2).compare%20operator\">(2).compare operator（比较操作符）</h3>\n<blockquote>\n<p>两个string类型可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是字典序。</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str1 = \"aa\", str2 = \"aaa\", str3 = \"abc\", str4 = \"xyz\";\n\tif (str1 &lt; str2)//如果str1字典序小于str2，输出ok1\n\t{\n\t\tprintf(\"ok1\\n\");//输出ok1\n\t}\n\n\tif (str1 != str3)//如果str1和str3字典序不等，输出ok2\n\t{\n\t\tprintf(\"ok2\\n\");//输出ok2\n\t}\n\n\tif (str4 &gt;= str3)//如果str4字典序大于等于str3，输出ok3\n\t{\n\t\tprintf(\"ok3\\n\");//输出ok3\n\t}\n\treturn 0;\n}</code></pre>\n<h3 id=\"(3).length()%20%2F%20size()\">(3).length() / size()</h3>\n<blockquote>\n<p>length()返回string的长度，即存放的字符数。时间复杂度为O(1)。size()与length()基本相同</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">string str = \"abcdef\";\nprintf(\"%d %d\\n\", str.length(), str.size());//输出6 6</code></pre>\n<h3 id=\"(4).insert()\">(4).insert()</h3>\n<blockquote>\n<p>string的insert()函数有很多种写法，这里给出几种常用的写法。时间复杂度为O(N)</p>\n</blockquote>\n<blockquote>\n<p>1.insert(pos, string), 在pos号位置插入一个字符串string</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">string str = \"abcxyz\", str2 = \"opq\";\nstr.insert(3, str2);//往str[3]处插入opq，将括号里的str2直接写成\"opq\"也是可以的\ncout&lt;&lt;str&lt;&lt;endl;//输出abcopqxyz</code></pre>\n<blockquote>\n<p>2.insert(it, it2, it3), it 为原字符串的欲插入位置，it2 和 it3 为待插字符串的首尾迭代器，用来表示串[it2, it3)将被插在it 的位置上</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcxyz\", str2 = \"opq\";//str为原字符串，str2为待插字符串\n\t//在str的3号位（即c和x之间）插入str2\n\tstr.insert(str.begin() + 3, str2.begin(), str2.end());\n\tcout &lt;&lt; str &lt;&lt; endl;//输出abcopqxyz\n\treturn 0;\n}</code></pre>\n<h3 id=\"(5).erase()\">(5).erase()</h3>\n<blockquote>\n<p>erase()有两种用法：删除单个元素、删除一个区间内的所有元素。时间复杂度均为O(N)</p>\n</blockquote>\n<blockquote>\n<p>1.删除单个元素：str.erase(it) 用于删除单个元素，it为需要删除的元素的迭代器</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n\nusing namespace std;\nint main()\n{\n\tstring str = \"abcdefg\";\n\tstr.erase(str.begin() + 4);//删除4号位（即e）\n\tcout &lt;&lt; str &lt;&lt; endl;//输出abcdfg\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>2.删除一个区间内的所有元素：有两种方法：</p>\n</blockquote>\n<ul><li>str.erase(first, last), 其中first为需要删除的区间的起始迭代器，而last为需要删除的区间的末尾迭代器的下一个地址，即为删除[first, last)</li></ul>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcdefg\";\n\t//删除在[str.begin() + 2, str.end() - 1)内的元素，即cdef\n\tstr.erase(str.begin() + 2, str.end() - 1);\n\tcout &lt;&lt; str &lt;&lt; endl;//输出abg\n\treturn 0;\n}</code></pre>\n<ul><li>str.erase(pos, length), 其中pos为需要开始删除的起始位置，length为删除的字符个数。</li></ul>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcdefg\";\n\tstr.erase(3, 2);//删除de\n\tcout &lt;&lt; str &lt;&lt; endl;//输出abcfg\n\treturn 0;\n}</code></pre>\n<h3 id=\"(6).clear()\">(6).clear()</h3>\n<blockquote>\n<p>clear()可以清空string中的数据，时间复杂度一般为O(1)</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcd\";\n\tstr.clear();//清空字符串\n\tcout &lt;&lt; str.length() &lt;&lt; endl;//输出0\n\treturn 0;\n}</code></pre>\n<h3 id=\"(7).substr()\">(7).substr()</h3>\n<blockquote>\n<p>substr(pos, len) 返回从pos号位开始、长度为len的子串，时间复杂度为O(len)</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"Thank you for your smile.\";\n\tcout &lt;&lt; str.substr(0, 5) &lt;&lt; endl;//输出Thank\n\tcout &lt;&lt; str.substr(14, 4) &lt;&lt; endl;//输出your\n\tcout &lt;&lt; str.substr(19, 5) &lt;&lt; endl;//输出smile\n\treturn 0;\n}</code></pre>\n<h3 id=\"(8).string%3A%3Anpos\">(8).string::npos</h3>\n<blockquote>\n<p>string::npos是一个常数，其本身的值为-1 ，但由于是unsigned int 类型，因此实际上也可以认为是unsigned int 类型的最大值，可认为是4,294,967,295。string::npos 用以作为 find 函数失配时的返回值。</p>\n</blockquote>\n<h3 id=\"(9).find()\">(9).find()</h3>\n<blockquote>\n<p>str.find(str2) 当str2 是str 的子串时，返回其在str 中第一次出现的位置，如果str2 不是str 的子串，那么返回string::npos</p>\n<p>str.find(str2, pos), 从str 的pos 号位开始匹配str2，返回值与上相同。时间复杂度为O(M*N)，M和N 分别是str2 和str的长度</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"Thank you for your smile\";\n\tstring str2 = \"you\";\n\tstring str3 = \"me\";\n\tif (str.find(str2) != string::npos)\n\t{\n\t\tcout &lt;&lt; str.find(str2) &lt;&lt; endl;//输出6\n\t}\n\tif (str.find(str2, 7) != string::npos)\n\t{\n\t\tcout &lt;&lt; str.find(str2, 7) &lt;&lt; endl;//输出14\n\t}\n\tif (str.find(str3) != string::npos)\n\t{\n\t\tcout &lt;&lt; str.find(str3) &lt;&lt; endl;\n\t}\n\telse\n\t{\n\t\tcout &lt;&lt; \"I know there is no position for me.\" &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>\n<h3 id=\"(10).replace()\">(10).replace()</h3>\n<blockquote>\n<p>str.replace(pos,len,str2) 把str 从pos 号位开始、长度为len 的子串替换为上str2</p>\n<p>str.replace(it1,it2,str2) 把str 的迭代器[it1, it2)范围的子串替换为str2</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"Maybe you will turn around.\";\n\tstring str2 = \"will not\";\n\tstring str3 = \"surely\";\n\tcout &lt;&lt; str.replace(10, 4, str2) &lt;&lt; endl;\n\tcout &lt;&lt; str.replace(str.begin(), str.begin() + 5, str3) &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E4%BA%8C%E3%80%81queue%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3\">二、queue的常见用法详解</h1>\n<blockquote>\n<p>queue翻译为队列，在STL中主要则是实现一个<span style=\"color:#956fe7;\">先进先出</span>的容器，<span style=\"color:#956fe7;\">当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue代替，以提高程序的准确性。</span></p>\n</blockquote>\n<h2 id=\"1.queue%E7%9A%84%E5%AE%9A%E4%B9%89\">1.queue的定义</h2>\n<p>要使用queue， 需要先添加头文件#include&lt;queue&gt;, 并在头文件下面加上\"using namespace std;\" ，然后就可以使用了。</p>\n<p>其定义的写法和其他STL容器相同，typename 可以是任意基本数据类型和容器：</p>\n<pre><code class=\"language-cpp\">queue&lt;typename&gt; name;</code></pre>\n<h2 id=\"2.queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE\">2.queue容器内元素的访问</h2>\n<p>由于队列（queue）本身就是一种先进先出的限制性数据结构，因此在STL中只能通过front() 来访问队首元素，或是通过back() 来访问队尾元素。</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;queue&gt;\n\nusing namespace std;\n\nint main()\n{\n\tqueue&lt;int&gt; q;\n\tfor (int i = 1; i &lt;= 5; i++)\n\t{\n\t\tq.push(i);//push(i)用以将i压入队列，因此依次入队1 2 3 4 5 \n\t}\n\tprintf(\"%d %d\\n\", q.front(), q.back());//输出结果为1 5\n\treturn 0;\n}</code></pre>\n<h2 id=\"3.queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90\">3.queue常用函数实例解析</h2>\n<blockquote>\n<ul><li>push()</li><li>front()</li><li>back()</li><li>pop()</li><li>empty()</li><li>size()</li></ul>\n</blockquote>\n<h3 id=\"(1).push()\">(1).push()</h3>\n<blockquote>\n<p>push(x) 将x 进行入队，时间复杂度为O(1)</p>\n</blockquote>\n<h3 id=\"(2).front()%2C%20back()\">(2).front(), back()</h3>\n<blockquote>\n<p>front(), back()可以分别获得队首元素和队尾元素，时间复杂度为O(1)</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#956fe7;\">注意哦，使用front() 和 pop() 函数之前，必须用empty() 判断队列是否为空，否则可能会因为队列空导致错误</span></p>\n</blockquote>\n<h3 id=\"(3).pop()\">(3).pop()</h3>\n<blockquote>\n<p>pop()令队首元素出队，时间复杂度为O(1)</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;queue&gt;\n\nusing namespace std;\n\nint main()\n{\n\tqueue&lt;int&gt; q;\n\tfor (int i = 1; i &lt;= 5; i++)\n\t{\n\t\tq.push(i);\n\t}\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tq.pop();//出队列元素3次，依次出队1 2 3\n\t}\n\tprintf(\"%d\\n\", q.front());//输出4\n\treturn 0;\n}</code></pre>\n<h3 id=\"(4).empty()\">(4).empty()</h3>\n<blockquote>\n<p>empty()检测queue是否为空，返回true则为空，返回false则非空，时间复杂度为O(1)</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;queue&gt;\n\nusing namespace std;\n\nint main()\n{\n\tqueue&lt;int&gt; q;\n\tif (q.empty() == true)//一开始队列里没有元素，所以是空\n\t{\n\t\tprintf(\"Empty\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"Not Empty\\n\");\n\t}\n\tq.push(1);\n\tif (q.empty() == true)\n\t{\n\t\tprintf(\"Empty\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"Not Empty\\n\");\n\t}\n\treturn 0;\n}</code></pre>\n<h3 id=\"(5).size()\">(5).size()</h3>\n<blockquote>\n<p>size()返回queue内元素的个数，时间复杂度为O(1)</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;queue&gt;\n\nusing namespace std;\n\nint main()\n{\n\tqueue&lt;int&gt; q;\n\tfor (int i = 1; i &lt;= 5; i++)\n\t{\n\t\tq.push(i);\n\t}\n\tprintf(\"%d\\n\", q.size());//输出5\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>【延伸】：STL容器中还有两种容器跟队列有关，分别是双端队列(deque) 和优先队列(priority_queue) ，前者是首尾皆可插入和删除的队列，后者是使用堆实现的默许将当前队列最大元素置于队首的容器，这里暂时先不介绍，后期如果需要再进行补充。</p>\n</blockquote>\n<h1 id=\"%E4%B8%89%E3%80%81stack%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3\">三、stack的常见用法详解</h1>\n<blockquote>\n<p>stack 翻译为栈，是STL中实现的一个先进后出的容器，stack 用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。</p>\n</blockquote>\n<h2 id=\"1.stack%E7%9A%84%E5%AE%9A%E4%B9%89\">1.stack的定义</h2>\n<p>要使用stack，应先添加头文件#include&lt;stack&gt;, 并在头文件下面加上\" using namespace std;\"，然后就可以使用了。</p>\n<p>其定义的写法和其他STL容器相同，typename可以是任意基本数据类型或容器：</p>\n<pre><code class=\"language-cpp\">stack&lt;typename&gt; name;</code></pre>\n<h2 id=\"2.stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE\">2.stack容器内元素的访问</h2>\n<p>由于栈(stack) 本身就是一种先进后出的数据结构，<span style=\"color:#956fe7;\">在STL的stack 中只能通过top() 来访问栈顶元素</span></p>\n<p><span style=\"color:#0d0016;\">示例如下：</span></p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstack&lt;int&gt; st;\n\tfor (int i = 1; i &lt;= 5; i++)\n\t{\n\t\tst.push(i);//依次入栈1 2 3 4 5\n\t}\n\tprintf(\"%d\\n\", st.top());//输出5\n\treturn 0;\n}</code></pre>\n<h2 id=\"3.stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90\">3.stack常用函数实例解析</h2>\n<blockquote>\n<ul><li>push()</li><li>top()</li><li>pop()</li><li>empty()</li><li>size()</li></ul>\n</blockquote>\n<h3>(1).push()</h3>\n<blockquote>\n<p>push(x) 将x 入栈，时间复杂度为O(1)，</p>\n</blockquote>\n<h3 id=\"(2).top()\">(2).top()</h3>\n<blockquote>\n<p>top()获得栈顶元素，时间复杂度为O(1)</p>\n</blockquote>\n<h3>(3).pop()</h3>\n<blockquote>\n<p>pop()用以弹出栈顶元素，时间复杂度为O(1)</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstack&lt;int&gt; st;\n\tfor (int i = 1; i &lt;= 5; i++)\n\t{\n\t\tst.push(i);\n\t}\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tst.pop();\n\t}\n\tprintf(\"%d\\n\", st.top());//输出2\n\treturn 0;\n}</code></pre>\n<h3>(4).empty()</h3>\n<blockquote>\n<p>empty()可以检测stack 内是否为空，返回true 为空，返回false 为非空，时间复杂度为O(1)</p>\n</blockquote>\n<h3>(5).size()</h3>\n<blockquote>\n<p>size()返回stack 内元素的个数，时间复杂度为O(1)</p>\n</blockquote>\n<h1 id=\"%E5%9B%9B%E3%80%81algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0\">四、algorithm头文件下的常用函数</h1>\n<blockquote>\n<p>使用algorithm 头文件，需要在头文件下面加上一行\"using namespace std;\"，才能正常使用</p>\n</blockquote>\n<blockquote>\n<ul><li>max()、min()、abs()</li><li>swap()</li><li>reverse()</li><li>next_permutation()</li><li>fill()</li><li>sort()</li><li>lower_bound() 和 upper_bound()</li></ul>\n</blockquote>\n<h2 id=\"1.max()%E3%80%81min()%E5%92%8Cabs()\">1.max()、min()和abs()</h2>\n<blockquote>\n<p>max(x,y)和min(x,y) 分别返回x, y中的最大值和最小值，且参数必须是两个，可以是浮点数，如果想返回三个数x,y,z的最大值，可以使用max(x, max(y, z)) 的写法；abs(x) 返回x的绝对值。注意：此时的x 必须是整数，浮点数的绝对值请用math 头文件下的fabs</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint x = -1;\n\tint y = -2;\n\tprintf(\"%d %d\\n\", max(x, y), min(x, y));//输出-1 -2\n\tprintf(\"%d %d\\n\", abs(x), abs(y));//输出1 2\n\treturn 0;\n}</code></pre>\n<h2 id=\"(2).swap()\">2.swap()</h2>\n<blockquote>\n<p>swap(x, y) 用来交换x 和 y 的值</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint x = 10;\n\tint y = 20;\n\tswap(x, y);\n\tprintf(\"%d %d\\n\", x, y);//输出20 10\n\treturn 0;\n}</code></pre>\n<h2 id=\"(3).reverse()\">3.reverse()</h2>\n<blockquote>\n<p>reverse(it, it2) 可以将数组指针在[it, it2) 之间的元素或容器的迭代器在[it, it2) 范围内的元素进行反转</p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint arr[10] = { 10,11,12,13,14,15 };\n\treverse(arr, arr + 4);//将arr[0]~arr[3]反转\n\tfor (int i = 0; i &lt; 6; i++)\n\t{\n\t\tprintf(\"%d \", arr[i]);//输出13,12,11,10,14,15\n\t}\n\n\treturn 0;\n}</code></pre>\n<p>如果要是对容器中的元素（例如string 字符串）进行反转，结果也是一样</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str = \"abcdefghi\";\n\treverse(str.begin() + 2, str.begin() + 6);//对str[0]~str[5]反转\n\tfor (int i = 0; i &lt; str.length(); i++)\n\t{\n\t\tprintf(\"%c\", str[i]);//输出abfedcghi\n\t}\n\treturn 0;\n}</code></pre>\n<h2 id=\"(4).next_permutation()\">4.next_permutation()</h2>\n<blockquote>\n<p>next_permutation() 给出一个序列在全排列中得下一个序列</p>\n</blockquote>\n<p>例如，当n == 3 时的全排列为：</p>\n<blockquote>\n<p>123</p>\n<p>132</p>\n<p>213</p>\n<p>231</p>\n<p>312</p>\n<p>321</p>\n</blockquote>\n<p>这样231的下一个序列就是312</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint a[10] = { 1,2,3 };\n\t//a[0]~a[2]之间的序列需要求解next_permutation\n\tdo\n\t{\n\t\tprintf(\"%d%d%d\\n\", a[0], a[1], a[2]);\n\t} while (next_permutation(a, a + 3));\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>在上述的代码中，使用循环是因为next_permutation在已经到达全排列的最后一个时会返回false, 这样会方便退出循环。而使用do...while语句而不使用while语句是因为序列1 2 3本身也需要输出，如果使用while会直接跳到下一个序列再输出，这样的话结果会少一个123</p>\n</blockquote>\n<blockquote>\n<p>注意：next_permutation(start, end) 是左闭右开的！</p>\n</blockquote>\n<h2 id=\"(5).fill()\">5.fill()</h2>\n<blockquote>\n<p>fill()可以把数组或容器中的某一段区间赋为某个相同的值。<span style=\"color:#4da8ee;\">和memset 不同，这里的赋值可以是数组类型对应范围中的任意值</span></p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint a[5] = { 1,2,3,4,5 };\n\tfill(a, a + 5, 133);//将a[0]~a[4]均赋值为133\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);//输出133 133 133 133 133\n\t}\n\treturn 0;\n}</code></pre>\n<h2 id=\"(6).sort()\">6.sort()</h2>\n<blockquote>\n<p><span style=\"color:#4da8ee;\">顾名思义，sort()就是用来排序的函数，它根据具体情形使用不同的排序方法，效率较高。一般来说，不推荐使用C语言中的qsort函数，原因是qsort 用起来比较繁琐，涉及很多指针的操作。</span></p>\n</blockquote>\n<ul><li>如何使用sort排序？</li></ul>\n<p>sort函数的使用必须加上头文件\"#include&lt;algorithm&gt;\" 和 \"using namespace std;\"，其使用的方式如下：</p>\n<blockquote>\n<p>sort(首元素地址（必填），尾元素地址的下一个地址（必填），比较函数（非必填）);</p>\n</blockquote>\n<p><span style=\"color:#4da8ee;\">可以看到，sort的参数有三个，其中前两个是必填的，而比较函数则可以根据需要填写，如果不写比较函数，则默认对前面给出的区间进行递增排序。</span></p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint a[6] = { 9,4,2,5,6,-1 };\n\t//将a[0]~a[3]进行从小到大排序\n\tsort(a, a + 4);\n\tfor (int i = 0; i &lt; 6; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);//输出2 4 5 9 6 -1\n\t}\n\tputchar('\\n');\n\t//将a[0]~a[5]进行从小到大排序\n\tsort(a, a + 6);\n\tfor (int i = 0; i &lt; 6; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);//输出-1 2 4 5 6 9\n\t}\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>【敲黑板】：特别需要注意理解的是尾元素地址的下一个地址！</p>\n</blockquote>\n<p>对double数组进行排序：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tdouble a[] = { 1.4,-2.1,9 };\n\tsort(a, a + 3);\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tprintf(\"%.1lf \", a[i]);\n\t}\n\treturn 0;\n}</code></pre>\n<p>对char型数组进行排序（默认是字典序）</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tchar c[] = { 'T', 'W','A', 'K' };\n\tsort(c, c + 4);\n\tfor (int i = 0; i &lt; 4; i++)\n\t{\n\t\tprintf(\"%c\", c[i]);//输出AKTW\n\t}\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>我们需要知道的是，如果对序列进行排序，那么序列中的元素一定要有可比性，因此需要制定排序规则来建立这种可比性。特别是像结构体，本身并没有大小关系，需要认为制定比较的规则。sort 的第三个可选参数就是cmp函数，用来实现这个规则。</p>\n</blockquote>\n<ul><li>如何实现比较函数cmp</li></ul>\n<p>下面介绍对基本数据类型、结构体类型、STL容器进行自定义规则排序时cmp的写法。</p>\n<h3 id=\"%3C1%3E.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F\">&lt;1&gt;.基本数据类型数组的排序</h3>\n<p>若比较函数不填，则默认按照从小到大的顺序排序。</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint a[] = { 3,1,4,2 };\n\tsort(a, a + 4);\n\tfor (int i = 0; i &lt; 4; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);//输出1 2 3 4\n\t}\n\treturn 0;\n}</code></pre>\n<p>如果想要从大到小来排序，则要使用比较函数cmp 来“告诉”sort 何时要交换元素（让元素的大小比较关系反过来）</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nbool cmp(int a, int b)\n{\n\treturn a &gt; b;//可以理解为当a&gt;b时把a放在b前面\n}\n\nint main()\n{\n\tint a[] = { 3,1,4,2 };\n\tsort(a, a + 4, cmp);\n\tfor (int i = 0; i &lt; 4; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);//输出4 3 2 1\n\t}\n\n\treturn 0;\n}</code></pre>\n<p>这样就可以让数值较大的元素放在前面，也就达到了从大到小排序的要求。</p>\n<p>同样的，对double型数组从大到小排序的代码如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nbool cmp(double a, double b)\n{\n\treturn a &gt; b;//同样是a&gt;b\n}\n\nint main()\n{\n\tdouble a[] = { 1.4,-2.1,9 };\n\tsort(a, a + 3, cmp);\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tprintf(\"%.1lf \", a[i]);//输出9.0 1.4 -2.1\n\t}\n\treturn 0;\n}</code></pre>\n<p>对char型数组从大到小排序如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nbool cmp(char a, char b)\n{\n\treturn a &gt; b;//可以理解为当a&gt;b时把a放在b之前\n}\n\nint main()\n{\n\tchar c[] = { 'T','W','A','K' };\n\tsort(c, c + 4, cmp);\n\tfor (int i = 0; i &lt; 4; i++)\n\t{\n\t\tprintf(\"%c\", c[i]);//输出WTKA\n\t}\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>【记忆方法】：</p>\n<p>如果要把数据从小到大排列，那么就用'&lt;', 因为\"a&lt;b\" 就是左小右大；如果要把数据从大到小排列，那么就用'&gt;', 因为\"a&gt;b\" 就是左大右小。而当不确定或者忘记的时候，不妨两种都试一下，就会知道该用哪种了。</p>\n</blockquote>\n<h3 id=\"%3C2%3E.%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F\">&lt;2&gt;.结构体数组的排序</h3>\n<p>现在定义了如下结构体：</p>\n<pre><code class=\"language-cpp\">struct node{\n    int x, y;\n}ssd[10];</code></pre>\n<p>如果想将ssd数组按照 x 从大到小排序（即进行一级排序），那么可以这样写cmp函数：</p>\n<pre><code class=\"language-cpp\">bool cmp(node a, node b){\n    return a.x &gt; b.x;\n}</code></pre>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nstruct node\n{\n\tint x;\n\tint y;\n}ssd[10];\n\nbool cmp(node a, node b)\n{\n\treturn a.x &gt; b.x;//按x值从大到小对结构体数组进行排序\n}\n\nint main()\n{\n\tssd[0].x = 2;\n\tssd[0].y = 2;\n\tssd[1].x = 1;\n\tssd[1].y = 3;\n\tssd[2].x = 3;\n\tssd[2].y = 1;\n\tsort(ssd, ssd + 3, cmp);\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tprintf(\"%d %d\\n\", ssd[i].x, ssd[i].y);\n\t}\n\treturn 0;\n}</code></pre>\n<p>而如果想先按x 从大到小排序，但当x相等的情况下，按照y的大小从小到大来排序（即进行二级排序），那么cmp的写法是：</p>\n<pre><code class=\"language-cpp\">bool cmp(node a, node b)\n{\n    if(a.x != b.x)\n    {\n        return a.x &gt; b.x;\n    }\n    else\n    {\n        return a.y &lt; b.y;\n    }\n}</code></pre>\n<p>这里的cmp函数首先判断结构体内的x 元素是否相等，如果不相等则直接按照x 的大小来排序，否则，按照y 的大小来排序。</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nstruct node\n{\n\tint x;\n\tint y;\n}ssd[10];\n\nbool cmp(node a, node b)\n{\n\tif (a.x != b.x)\n\t{\n\t\treturn a.x &gt; b.x;//x 不等时按x 从大到小排序\n\t}\n\telse\n\t{\n\t\treturn a.y &lt; b.y;//x 相等时按y 从小到大排序\n\t}\n}\nint main()\n{\n\tssd[0].x = 2;\n\tssd[0].y = 2;\n\tssd[1].x = 1;\n\tssd[1].y = 3;\n\tssd[2].x = 3;\n\tssd[2].y = 1;\n\tsort(ssd, ssd + 3, cmp);//排序\n\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tprintf(\"%d %d\\n\", ssd[i].x, ssd[i].y);\n\t}\n\treturn 0;\n}</code></pre>\n<h3 id=\"%3C3%3E.%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F\">&lt;3&gt;.容器的排序</h3>\n<blockquote>\n<p>在STL标准容器中，只有vector、string、deque是可以使用sort的。这是因为像set、map这种容器是用红黑树实现的（了解即可），元素本身有序，故不允许使用sort排序</p>\n</blockquote>\n<p>vector示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nbool cmp(int a, int b)//因为vector中的元素为int型，因此仍然是int的比较\n{\n\treturn a &gt; b;\n}\n\n\nint main()\n{\n\tvector&lt;int&gt; vi;\n\tvi.push_back(3);\n\tvi.push_back(1);\n\tvi.push_back(2);\n\tsort(vi.begin(), vi.end(), cmp);\n\tfor (vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++)\n\t{\n\t\tprintf(\"%d \", *it);//输出3 2 1\n\t}\n\treturn 0;\n}</code></pre>\n<p>再来看string 的排序，示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tstring str[3] = { \"bbbb\", \"cc\", \"aaa\" };\n\tsort(str, str + 3);//将string数组按字典树从小到大输出\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tcout &lt;&lt; str[i] &lt;&lt; endl;\n\t}\n\n\treturn 0;\n}</code></pre>\n<p>如果上面这个例子中，需要按照字符串长度从小到大排序，那么可以这样写：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nbool cmp(string str1, string str2)\n{\n\treturn str1.length() &lt; str2.length();//按照string 的长度从小到大排序\n}\n\nint main()\n{\n\tstring str[3] = { \"bbbb\", \"cc\", \"aaa\" };\n\tsort(str, str + 3, cmp);\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\tcout &lt;&lt; str[i] &lt;&lt; endl;\n\t}\n\n\treturn 0;\n}</code></pre>\n<h2 id=\"(7).lower_bound()%E5%92%8Cupper_bound()\">7.lower_bound()和upper_bound()</h2>\n<blockquote>\n<p>lower_bound() 和 upper_bound() 需要用在一个有序数组或容器中</p>\n<p><span style=\"color:#4da8ee;\">lower_bound(first, last, val) 用来寻找在数组或容器的[first, last) 范围内</span><span style=\"color:#956fe7;\">第一个值大于等于val元素的位置</span><span style=\"color:#4da8ee;\">，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</span></p>\n<p><span style=\"color:#4da8ee;\">upper_bound(first, last, val) 用来寻找在数组或容器的[first, last) 范围内</span><span style=\"color:#956fe7;\">第一个值大于val 的元素的位置</span><span style=\"color:#4da8ee;\">，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</span></p>\n<p>显然，如果数组或容器中没有需要寻找的元素，则lower_bound() 和 upper_bound() 均返回可以插入该元素的位置的指针或迭代器（即假设存在该元素时，该元素应当在的位置）。</p>\n</blockquote>\n<p>示例如下： </p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint a[10] = { 1,2,2,3,3,3,5,5,5,5 };\n\t//寻找-1\n\tint* lowerPos = lower_bound(a, a + 10, -1);\n\tint* upperPos = upper_bound(a, a + 10, -1);\n\tprintf(\"%d %d\\n\", lowerPos - a, upperPos - a);//输出0 0\n\n\t//寻找1\n\tlowerPos = lower_bound(a, a + 10, 1);\n\tupperPos = upper_bound(a, a + 10, 1);\n\tprintf(\"%d %d\\n\", lowerPos - a, upperPos - a);//输出0 1\n\n\t//寻找3\n\tlowerPos = lower_bound(a, a + 10, 3);\n\tupperPos = upper_bound(a, a + 10, 3);\n\tprintf(\"%d %d\\n\", lowerPos - a, upperPos - a);//输出3 6\n\n\t//寻找4\n\tlowerPos = lower_bound(a, a + 10, 4);\n\tupperPos = upper_bound(a, a + 10, 4);\n\tprintf(\"%d %d\\n\", lowerPos - a, upperPos - a);//输出6 6\n\n\t//寻找6\n\tlowerPos = lower_bound(a, a + 10, 6);\n\tupperPos = upper_bound(a, a + 10, 6);\n\tprintf(\"%d %d\\n\", lowerPos - a, upperPos - a);//输出10 10\n\treturn 0;\n}</code></pre>\n<p>显然，如果只想获得欲查元素的下标，就可以不使用临时指针，而直接令返回值减去数组首地址即可。</p>\n<blockquote>\n<p>【敲黑板】：<span style=\"color:#956fe7;\">这里补充一条知识点，指针 - 指针  = 两指针之间的元素个数</span></p>\n</blockquote>\n<p>示例如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n\tint a[10] = { 1,2,2,3,3,3,5,5,5,5 };\n\t//寻找3\n\tprintf(\"%d %d\\n\", lower_bound(a, a + 10, 3) - a, upper_bound(a, a + 10, 3) - a);//输出3 6\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E4%BA%94%E3%80%81%E8%93%9D%E6%A1%A5%E7%BB%93%E8%AF%AD%EF%BC%9A%E9%81%87%E8%A7%81%E8%93%9D%E6%A1%A5%E9%81%87%E8%A7%81%E4%BD%A0%EF%BC%8C%E4%B8%8D%E8%B4%9F%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%B4%9F%E5%8D%BF%EF%BC%81\">五、蓝桥结语：遇见蓝桥遇见你，不负代码不负卿！</h1>\n<blockquote>\n<p><span style=\"color:#956fe7;\">希望能给大家带来帮助，码字不易，如果可以动动小手来个三连那就更好啦，hh，咱们下次再见。</span></p>\n</blockquote>\n<p style=\"text-align:center;\">·<img alt=\"\" src=\"..\\..\\static\\image\\988bfe8178ce495fb96e26877aaf14e1.jpg\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-01-27 23:24:38", "summary": "欢迎回到：遇见蓝桥遇见你，不负代码不负卿！目录补充：常用头文件及库函数和一、的常见用法详解的定义中内容的访问通过下标访问通过迭代器访问常用函数实例解析"}