{"blogid": "126242703", "writerAge": "码龄7年", "writerBlogNum": "51", "writerCollect": "128", "writerComment": "37", "writerFan": "68", "writerGrade": "4级", "writerIntegral": "1074", "writerName": "fl2011sx", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126242703.jpg", "writerRankTotal": "18955", "writerRankWeekly": "2173", "writerThumb": "87", "writerVisitNum": "57942", "blog_read_count": "1016", "blog_time": "已于 2022-08-23 13:13:15 修改", "blog_title": "C++的缺陷和思考（一）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"_0\"></a>前言</h1>\n<p>我从大学时期就开始研究，并稳定扎根在C++方向上，作为一名专职的C++程序员，在这些年的开发经历中，对C++语言的一些“缺陷”有了一些思考总结。与此同时，新兴的编程语言越来越受欢迎，而C++本身为了克服自己的一些缺陷，也在发生着一些改变。<br/> 本文主要有3个目的：</p>\n<ol><li>总结一些C++晦涩难懂的语法现象，解释其背后原因，作为防踩坑之用</li><li>和一些其他的编程语言进行比较，列举它们的优劣</li><li>发表一些我自己作为C++程序员的看法和感受</li></ol>\n<p><strong>需要说明的是，本文并不是在批判C++，或是说其他语言就比C++好。</strong> C++仍然是我个人认为最值得学习的语言，优秀的C++程序员转去用其他编程语言后一样会很优秀，但反过来并不一定成立。<br/> 文中的“缺陷”更多的是想让大家去注意这个点，了解它的底层原因，避免踩坑，并不建议大家一刀切地杜绝使用这些语法。<br/> 另外由于笔者并没有精通各种编程语言，仅仅能在利索能力范围内跟一些其他语言进行比较，还请见谅。</p>\n<h1><a id=\"C_11\"></a>继承自C的缺陷</h1>\n<p>C++有一个很大的历史包袱，就是C语言。C语言诞生时间很早，并且它是为了编写OS而诞生的，语法更加底层。有人说，C并不是针对程序员友好的语言，而是针对编译期友好的语言。这种缺陷放到C++当中更加明显。<br/> 下面章节重点介绍由C语言“继承”来的一些缺陷。</p>\n<h2><a id=\"_14\"></a>数组</h2>\n<p>数组本身其实没有什么问题，这种语法也非常常用，主要是表示连续一组相同的数据构成的集合。但数组类型在待遇上却和其他类型（比如说结构体）非常不一样。</p>\n<h4><a id=\"_16\"></a>数组的复制</h4>\n<p>我们知道，结构体类型是可以很轻松的复制的，比如说：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">St</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> m1<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">double</span> m2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  St st1<span class=\"token punctuation\">;</span>\n  St st2 <span class=\"token operator\">=</span> st1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n  St st3<span class=\"token punctuation\">;</span>\n  st1 <span class=\"token operator\">=</span> st3<span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但数组却并不可以，比如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> arr1<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> arr2<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR</span>\n</code></pre>\n<p>明明这里arr2和arr1同为<code>int[5]</code>类型，但是并不支持复制。照理说，数组应当比结构体更加适合复制场景，因为需求是很明确的，就是元素按位复制。</p>\n<h4><a id=\"_37\"></a>数组类型传参</h4>\n<p>由于数组不可以复制，导致了数组同样不支持传参，因此我们只能采用“首地址+长度”的方式来传递数组：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>而为了方便程序员进行这种方式的传参，C又做了额外的2件事：</p>\n<ol><li>提供一种隐式类型转换，支持将数组类型转换为首元素指针类型（比如说这里arr是<code>int[5]</code>类型，传参时自动转换为<code>int *</code>类型）</li><li>函数参数的语法糖，如果在函数参数写数组类型，那么会自动转换成元素指针类型，比如说下面这几种写法都完全等价：</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>所以这里非常容易误导人的就在这个语法糖中，<strong>无论中括号里写多少，或者不写，这个值都是会被忽略的</strong>，要想知道数组的边界，你就必须要通过额外的参数来传递。<br/> 但通过参数传递这是一种软约束，你无法保证调用者传的就是数组元素个数，这里的危害详见后面“指针偏移”的章节。</p>\n<h4><a id=\"_58\"></a>分析和思考</h4>\n<p>之所以C的数组会出现这种奇怪现象，我猜测，作者考虑的是数组的实际使用场景，是经常会进行切段截取的，也就是说，一个数组类型并不总是完全整体使用，我们可能更多时候用的是其中的一段。举个简单的例子，如果数组是整体复制、传递的话，做数组排序递归的时候会不会很尴尬？首先，排序函数的参数难以书写，因为要指定数组个数，我们总不能针对于1,2,3,4,5,6,…元素个数的数组都分别写一个排序函数吧？其次，如果取子数组就会复制出一个新数组的话，也就不能对原数组进行排序了。<br/> 所以综合考虑，干脆这里就不支持复制，强迫程序员使用指针+长度这种方式来操作数组，反而更加符合数组的实际使用场景。<br/> 当然了，在C++中有了引用语法，我们还是可以把数组类型进行传递的，比如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 必须传int[5]类型</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> arr1<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> arr2<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n  <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但绝大多数的场景似乎都不会这样去用。<br/> 一些新兴语言（比如说Go）就注意到了这一点，因此将其进行了区分。在Go语言中，区分了“数组”和“切片”的概念，数组就是长度固定的，整体来传递；而切片则类似于首地址+长度的方式传递（只不过没有单独用参数，而是用len函数来获取）</p>\n<pre><code class=\"prism language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面例子里，f1就必须传递长度是5的数组类型，而f2则可以传递任意长度的切片类型。<br/> 而C++其实也注意到了这一点，但由于兼容问题，它只能通过STL提供容器的方式来解决，<code>std::array</code>就是定长数组，而<code>std::vector</code>就是变长数组，跟上述Go语言中的数组和切片的概念是基本类似的。这也是C++中更加推荐使用vector而不是C风格数组的原因。</p>\n<h2><a id=\"_82\"></a>类型说明符</h2>\n<h3><a id=\"_83\"></a>类型不是从左向右说明</h3>\n<p>C/C++中的类型说明符其实设计得很不合理，除了最简单的变量定义：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个int类型的变量a</span>\n</code></pre>\n<p>上面这个还是很清晰明了的，但稍微复杂一点的，就比较奇怪了：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个int[5]类型的变量arr</span>\n</code></pre>\n<p>arr明明是<code>int[5]</code>类型，但是这里的int和[5]却并没有写到一起，如果这个还不算很容易造成迷惑的话，那来看看下面的：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a1<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义了一个数组</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>a2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义了一个指针</span>\n</code></pre>\n<p>a1是<code>int *[5]</code>类型，表示a1是个数组，有5个元素，每个元素都是指针类型的。<br/> a2是<code>int (*)[5]</code>类型，是一个指针，指针指向了一个<code>int[5]</code>类型的数组。<br/> 这里离谱的就在这个<code>int (*)[5]</code>类型上，也就是说，“指向<code>int[5]</code>类型的指针”并不是<code>int[5]*</code>，而是<code>int (*)[5]</code>，类型说明符是从里往外描述的，而不是从左往右。</p>\n<h3><a id=\"_100\"></a>类型说明符同时承担了动作语义</h3>\n<p>这里的另一个问题就是，C/C++并没有把“定义变量”和“变量的类型”这两件事分开，而是用类型说明符来同时承担了。也就是说，“定义一个int类型变量”这件事中，int这一个关键字不仅表示“int类型”，还表示了“定义变量”这个意义。这件事放在定义变量这件事上可能还不算明显，但放到定义函数上就不一样了：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>上面这个例子中，int和()共同表示了“定义函数”这个意义。也就是说，看到int这个关键字，并不一定是表示定义变量，还有可能是定义函数，定义函数时int表示了函数的返回值的类型。<br/> 正是由于C/C++中，类型说明符具有多重含义，才造成一些复杂语法简直让人崩溃，比如说定义高阶函数：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 输入一个函数，输出这个函数的导函数</span>\n<span class=\"token keyword\">double</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">DC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>DC是一个函数，它有一个参数，是<code>double (*)(double)</code>类型的函数指针，它的返回值是一个<code>double (*)(double)</code>类型的函数指针。但从直观性上来说，上面的写法完全毫无可读性，如果没有那一行注释，相信大家很难看得出这个语法到底是在做什么。<br/> C++引入了返回值右置的语法，从一定程度上可以解决这个问题：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> <span class=\"token function\">DC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">auto</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>但用auto作为占位符仍然还是有些突兀和晦涩的。</p>\n<h3><a id=\"_118\"></a>将类型符和动作语义分离的语言</h3>\n<p>我们来看一看其他语言是如何弥补这个缺陷的，最简单的做法就是把“类型”和“动作”这两件事分开，用不同的关键字来表示。<br/> Go语言：</p>\n<pre><code class=\"prism language-go\"><span class=\"token comment\">// 定义变量</span>\n<span class=\"token keyword\">var</span> a1 <span class=\"token builtin\">int</span>\n<span class=\"token keyword\">var</span> a2 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span>\n<span class=\"token keyword\">var</span> a3 <span class=\"token operator\">*</span><span class=\"token builtin\">int</span>\n<span class=\"token keyword\">var</span> a4 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token builtin\">int</span> <span class=\"token comment\">// 元素为指针的数组</span>\n<span class=\"token keyword\">var</span> a5 <span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token comment\">// 数组的指针</span>\n<span class=\"token comment\">// 定义函数</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 高阶函数</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">DC</span><span class=\"token punctuation\">(</span>f <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">float64</span><span class=\"token punctuation\">)</span><span class=\"token builtin\">float64</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">float64</span><span class=\"token punctuation\">)</span><span class=\"token builtin\">float64</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Swift语言：</p>\n<pre><code class=\"prism language-swift\"><span class=\"token comment\">// 定义变量</span>\n<span class=\"token keyword\">var</span> a1<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span>\n<span class=\"token keyword\">var</span> a2<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">Int</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// 定义函数</span>\n<span class=\"token keyword\">func</span> <span class=\"token function-definition function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function-definition function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token class-name\">Int</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 高阶函数</span>\n<span class=\"token keyword\">func</span> <span class=\"token function-definition function\">DC</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Double</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Double</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-&gt;</span><span class=\"token class-name\">Double</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Double</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Double</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-&gt;</span><span class=\"token class-name\">Double</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>JavaScript语言：</p>\n<pre><code class=\"prism language-js\"><span class=\"token comment\">// 定义变量</span>\n<span class=\"token keyword\">var</span> a1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">var</span> a2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// 定义函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 高阶函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token constant\">DC</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">f</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"_172\"></a>指针偏移</h2>\n<p>指针的偏移运算让指针操作有了较大的自由度，但同时也会引入越界问题</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p1 <span class=\"token operator\">=</span> arr <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> \n<span class=\"token operator\">*</span>p1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token comment\">// 越界</span>\n\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 越界</span>\n</code></pre>\n<p>换句话说，指针的偏移是完全随意的，静态检测永远不会去判断当前指针的位置是否合法。<br/> 这个与之前章节提到的数组传参的问题结合起来，会更加容易发生并且更加不容易发现：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 可能导致越界</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为参数中的值和数组的实际长度并没有要求强一致。</p>\n<h4><a id=\"_194\"></a>其他语言的指针</h4>\n<p>在其他语言中，有的语言（例如java、C#）直接取消了指针的相关语法，但由此就必须引入“值类型”和“引用类型”的概念。<br/> 例如在java中，存在“实”和“名”的概念：</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token class-name\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr2 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// “名”的复制，浅复制</span>\n  <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr3 <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 用库方法进行深复制</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>本质上来说，这个“名”就是栈空间上的一个指针，而“实”则是堆空间中的实际数据。如果取消指针概念的话，就要强行区分哪些类型是“值类型”，会完全复制，哪些是“引用类型”，只会浅复制。<br/> C#中的结构体和类的概念恰好如此，结构体是值类型，整体复制，而类是引用类型，要用库函数来复制。<br/> 而还有一些语言保留了指针的概念（例如Go、Swift），但仅仅用于明确指向和引用的含义，并不提供指针偏移运算，来防止出现越界问题。例如go中：</p>\n<pre><code class=\"prism language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">var</span> a <span class=\"token builtin\">int</span>\n  <span class=\"token keyword\">var</span> p <span class=\"token operator\">*</span><span class=\"token builtin\">int</span>\n  p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a <span class=\"token comment\">// OK</span>\n  r1 <span class=\"token operator\">:=</span> <span class=\"token operator\">*</span>p <span class=\"token comment\">// 直接解指针是OK的</span>\n  r2 <span class=\"token operator\">:=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// ERR，指针不可以偏移</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>swift中虽然仍然支持指针，但非常弱化了它的概念，从语法本身就能看出，不到迫不得已并不推荐使用：</p>\n<pre><code class=\"prism language-swift\"><span class=\"token keyword\">func</span> <span class=\"token function-definition function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token omit keyword\">_</span> ptr<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UnsafeMutablePointer</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Int</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  ptr<span class=\"token punctuation\">.</span>pointee <span class=\"token operator\">+=</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 给指针所指向的值加1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function-definition function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">var</span> a<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n  <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>OC中的指针更加特殊和“奇葩”，首先，OC完全保留了C中的指针用法，而额外扩展的“类”类型则不允许出现在栈中，也就是说，所有对象都强制放在堆中，栈上只保留指针对其引用。虽然OC中的指针仍然是C指针，但由于操作对象的“奇葩”语法，倒是并不需要太担心指针偏移的问题</p>\n<pre><code class=\"prism language-objc\"><span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  NSObject <span class=\"token operator\">*</span>obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSObject alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 例如调用obj的description方法</span>\n  NSString <span class=\"token operator\">*</span>desc <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>obj description<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 指针仍可偏移，但几乎不会有人这样来写：</span>\n  <span class=\"token punctuation\">[</span>obj<span class=\"token operator\">+</span><span class=\"token number\">1</span> description<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 也会越界</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"_237\"></a>隐式类型转换</h2>\n<p>隐式类型转换在一些场景下会让程序更加简洁，降低代码编写难度。比如说下面这些场景：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">double</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// int-&gt;double</span>\n<span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// double-&gt;int</span>\n<span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token char\">'5'</span> <span class=\"token operator\">-</span> <span class=\"token char\">'0'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// char-&gt;int</span>\n</code></pre>\n<p>但是有的时候隐式类型转化却会引发很奇怪的问题，比如说：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">ARR_SIZE</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></span></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  size_t size <span class=\"token operator\">=</span> <span class=\"token function\">ARR_SIZE</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  size_t size <span class=\"token operator\">=</span> <span class=\"token function\">ARR_SIZE</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// WRONG</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>结合之前所说，函数参数中的数组其实是数组首元素指针的语法糖，所以f2中的arr其实是<code>int *</code>类型，这时候再对其进行sizeof运算，结果是指针的大小，而并非数组的大小。如果程序员不能意识到这里发生了<code>int [N]</code>-&gt;<code>int *</code>的隐式类型转换，那么就可能出错。<br/> 还有一些隐式类型转换也很离谱，比如说：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">&gt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 可能原本想写a / 2，把/写成了&gt;</span>\n</code></pre>\n<p>这里发生的隐式转换是bool-&gt;int，同样可能不符合预期。关于布尔类型详见后面章节。<br/> C中的这些隐式转换可能影响并不算大，但拓展到C++中就可能有爆炸性的影响，详见后面“隐式构造”和“多态转换”的相关章节。</p>\n<h2><a id=\"_263\"></a>赋值语句的返回值</h2>\n<p>C/C++的赋值语句自带返回值，这一定算得上一大缺陷，在C中赋值语句返回值，在C++中赋值语句返回左值引用。<br/> 这件事造成的最大影响就在<code>=</code>和<code>==</code>这两个符号上，比如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> b <span class=\"token operator\">=</span> a1 <span class=\"token operator\">=</span> a2<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这里原本想写<code>b = a1 == a2</code>，但是错把<code>==</code>写成了<code>=</code>，但编译是可以完全通过的，因为<code>a1 = a2</code>本身返回了a1的引用，再触发一次隐式类型转换，把bool转化为int（这里详见后面非布尔类型的布尔意义章节）。<br/> 更有可能的是写在if表达式中：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>可以看到，<code>a = 1</code>执行后a的值变为1，返回的a的值就是1，所以这里的if变成了恒为真。<br/> C++为了兼容这一特性，又不得不要求自定义类型要定义赋值函数</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  Test <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Test <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 拷贝赋值函数</span>\n  Test <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>Test <span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 移动赋值函数</span>\n  Test <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 其他的赋值函数</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这里赋值函数的返回值强制要求定义为当前类型的左值引用，一来会让人觉得有些无厘头，记不住这里的写法，二来在发生继承关系的时候非常容易忘记处理父类的赋值</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  Base <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Base <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Ch</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  Ch <span class=\"token operator\">&amp;</span>opeartor <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Ch <span class=\"token operator\">&amp;</span>ch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">this</span><span class=\"token operator\">-&gt;</span>Base<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 或者写成 *static_cast&lt;Base *&gt;(this) = ch;</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4><a id=\"_303\"></a>其他语言的赋值语句</h4>\n<p>古老一些的C系扩展语言基本还是保留了赋值语句的返回值（例如java、OC），但一些新兴语言（例如Go、Swift）则是直接取消了赋值语句的返回值，比如说在swift中：</p>\n<pre><code class=\"prism language-swift\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">var</span> b<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span>\n<span class=\"token keyword\">var</span> c<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span>\nc <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ERR</span>\n</code></pre>\n<p><code>b = a</code>会返回<code>Void</code>，所以再赋值给c时会报错</p>\n<h2><a id=\"_312\"></a>非布尔类型的布尔意义</h2>\n<p>在原始C当中，其实并没有“布尔”类型，所有表示是非都是用int来做的。所以，int类型就赋予了布尔意义，0表示false，非0都表示true，由此也诞生了很多“野路子”的编程技巧：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 指针→bool</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// int→bool</span>\n\n<span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">~</span><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// int→bool</span>\n</code></pre>\n<p>所有表示判断逻辑的语法，都可以用非布尔类型的值传入，这样的写法其实是很反人类直觉的，更严重的问题就是与true常量比较的问题</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> judge <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 用了int表示了判断逻辑</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>judge <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 但这里的条件其实是false，因为true会转为1，2 == 1是false</span>\n</code></pre>\n<p>正是由于非布尔类型具有了布尔意义，才会造成一些非常反直觉的事情，比如说：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token boolean\">true</span> <span class=\"token operator\">+</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">!=</span> <span class=\"token boolean\">true</span>\n<span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">false</span>\n</code></pre>\n<h4><a id=\"_334\"></a>其他语言的布尔类型</h4>\n<p>基本上除了C++和一些弱类型脚本语言（比如js）以外，其他语言都取消了非布尔类型的布尔意义，要想转换为布尔值，一定要通过布尔运算才可以，例如在Go中：</p>\n<pre><code class=\"prism language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span> <span class=\"token comment\">// int类型</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token comment\">// ERR，if表达式要求布尔类型</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token comment\">// OK，通过逻辑运算得到布尔类型</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这样其实更符合直觉，也可以一定程度上避免出现写成类似于<code>if (a = 1)</code>出现的问题。C++中正是由于“赋值语句有返回值”和“非布尔类型有布尔意义”同时生效，才会在这里出现问题。</p>\n<h2><a id=\"_346\"></a>解指针类型</h2>\n<p>关于C/C++到底是强类型语言还是弱类型语言，业界一直争论不休。有人认为，变量的类型从定义后就不能改变，并且每个变量都有固定的类型，所以C/C++应该是强类型语言。<br/> 但有人持相反意见，是因为这个类型，仅仅是“表面上”不可变，但其实是可变的，比如说看下面例程：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">reinterpret_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里其实就是把a变成了uint8_t类型</span>\n</code></pre>\n<p>根源就在于，指针的解类型是可以改变的，原本int类型的变量，我们只要把它的首地址保存下来，然后按照另一种类型来解，那么就可以做到“改变a的类型”的目的。<br/> 这也就意味着，指针类型是不安全的，因为你不一定能保证现在解指针的类型和指针指向数据的真实类型是匹配的。<br/> 还有更野一点的操作，比如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">S1</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">short</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">S2</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  S2 s2<span class=\"token punctuation\">;</span>\n  S1 <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">reinterpret_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>S1 <span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  p<span class=\"token operator\">-&gt;</span>a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  p<span class=\"token operator\">-&gt;</span>b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> s2<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 猜猜这里会输出多少？</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里的指针类型问题和前面章节提到的指针偏移问题，综合起来就是说C/C++的指针操作的自由度过高，提升了语言的灵活度，同时也增加了其复杂度。</p>\n<h2><a id=\"_376\"></a>后置自增/自减</h2>\n<p>如果仅仅在C的角度上，后置自增/自减语法并没有带来太多的副作用，有时候在程序中作为一些小技巧反而可以让程序更加精简，比如说：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">AttrCnt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> count<span class=\"token operator\">++</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但这个特性继承到C++后问题就会被放大，比如说下面的例子：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> iter <span class=\"token operator\">=</span> ve<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> iter <span class=\"token operator\">!=</span> ve<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> iter<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这段代码看似特别正常，但仔细想想，iter作为一个对象类型，如果后置<code>++</code>，一定会发生复制。后置<code>++</code>原本的目的就是在表达式的位置先返回原值，表达式执行完后再进行自增。但如果放在类类型来说，就必须要临时保存一份原本的值。例如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Element</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">public</span>：\n  <span class=\"token comment\">// 前置++</span>\n  Element <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  \tele<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  \t<span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> \n  <span class=\"token comment\">// 后置++</span>\n  Element <span class=\"token keyword\">operator</span> <span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 为了最终返回原值，所以必需保存一份快照用于返回</span>\n    Element tmp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    ele<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> tmp<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">int</span> ele<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这也从侧面解释了，为什么前置<code>++</code>要求返回引用，而后置<code>++</code>则是返回非引用，因为这里需要复制一份快照用于返回。<br/> 那么，写在for循环中的后置<code>++</code>就会平白无故发生一次复制，又因为返回值没有接收，再被析构。<br/> C++保留的<code>++</code>和<code>--</code>的语义，也是因为它和<code>+=1</code>或<code>-=1</code>语义并不完全等价。我们可以用顺序迭代器来解释。对于顺序迭代器（比如说链表的迭代器），<code>++</code>表示取下一个节点，<code>--</code>表示取上一个节点。而<code>+n</code>或者<code>-n</code>则表示偏移了，这种语义更适合随机访问（所以说随机迭代器支持<code>+=</code>和<code>-=</code>，但顺序迭代器只支持<code>++</code>和<code>--</code>）。</p>\n<h4><a id=\"_412\"></a>其他语言的自增/自减</h4>\n<p>其他语言的做法基本分两种，一种就是保留自增/自减语法，但不再提供返回值，也就不用区分前置和后置，例如Go：</p>\n<pre><code class=\"prism language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">3</span>\na<span class=\"token operator\">++</span> <span class=\"token comment\">// OK</span>\nb <span class=\"token operator\">:=</span> a<span class=\"token operator\">++</span> <span class=\"token comment\">// ERR，自增语句没有返回值</span>\n</code></pre>\n<p>另一种就是干脆删除自增/自减语法，只提供普通的操作赋值语句，例如Swift：</p>\n<pre><code class=\"prism language-swift\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\na<span class=\"token operator\">++</span> <span class=\"token comment\">// ERR，没有这种语法</span>\na <span class=\"token operator\">+=</span> <span class=\"token number\">1</span> <span class=\"token comment\">// OK，只能用这种方式自增</span>\n</code></pre>\n<h2><a id=\"_425\"></a>类型长度</h2>\n<p>这里说的类型长度指的是相同类型在不同环境下长度不一致的情况，下面总结表格</p>\n<table><thead><tr><th>类型</th><th>32位环境长度</th><th>64位环境长度</th></tr></thead><tbody><tr><td>int/unsigned</td><td>4B</td><td>4B</td></tr><tr><td>long/unsigned long</td><td>4B</td><td>8B</td></tr><tr><td>long long/ unsigned long long</td><td>8B</td><td>8B</td></tr></tbody></table>\n<p>由于这里出现了32位和64位环境下长度不一致的情况，C语言特意提供了stdint.h头文件(C++中在cstddef中引用)，定义了定长类型，例如int64_t在32位环境下其实是long long，而在64位环境下其实是long。</p>\n<p>但这里的问题点在于：</p>\n<h4><a id=\"1__436\"></a>1. 并没有定长格式符</h4>\n<p>例如uint64_t在32位环境下对应的格式符是%llu，但是在64位环境下对应的格式符是%lu。有一种折中的解决办法是自定义一个宏：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span><span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">u64</span> <span class=\"token string\">\"%lu\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">u64</span> <span class=\"token string\">\"%llu\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">uint64_t</span> a<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a=\"</span>u64<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但这样会让字符串字面量从中间断开，非常不直观。</p>\n<h4><a id=\"2__451\"></a>2. 类型不一致。</h4>\n<p>例如在64位环境下，long和long long都是64位长，但编译器会识别为不同类型，在一些类型推导的场景会出现和预期不一致的情况，例如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">func</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int64_t</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int64_t</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> a<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 会匹配通用模板，而匹配不到特例</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上述例子表明，<code>func&lt;int64_t&gt;</code>和<code>func&lt;long long&gt;</code>是不同实例，尽管在64位环境下long和long long真的看不出什么区别，但是编译器就是会识别成不同类型。</p>\n<h2><a id=\"_466\"></a>格式化字符串</h2>\n<p>格式化字符串算是非常经典的C的产物，不仅是C++，非常多的语言都是支持这种格式符的，例如java、Go、python等等。<br/> 但C++中的格式化字符串可以说完全就是C的那一套，根本没有任何扩展。换句话说，除了基本数据类型和0结尾的字符串以外，其他任何类型都没有用于匹配的格式符。<br/> 例如，对于结构体类型、数组、元组类型等等，都没法匹配到格式符：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// 打印Point</span>\n  Point p <span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"(%lf,%lf)\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 无法直接打印p</span>\n  <span class=\"token comment\">// 打印数组</span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d, \"</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 无法直接打印整个数组</span>\n  <span class=\"token punctuation\">}</span> \n  <span class=\"token comment\">// 打印元组</span>\n  std<span class=\"token double-colon punctuation\">::</span>tuple <span class=\"token function\">tu</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"(%d,%lf,%s)\"</span><span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>tu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>tu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token number\">2</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span>tu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 无法直接打印整个元组</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>对于这些组合类型，我们就不得不手动去访问内部成员，或者用循环访问，非常不方便。<br/> 针对于字符串，还会有一个严重的潜在问题，比如：</p>\n<pre><code class=\"prism language-cpp\">std<span class=\"token double-colon punctuation\">::</span>string str <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\nstr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token char\">'\\0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstr<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sprintf</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token string\">\"str=%s\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>由于str中出现了<code>'\\0'</code>，如果用%s格式符来匹配的话，会在0的位置截断，也就是说buf其实只获取到了str中的第一个abc，第二个abc就被丢失了。</p>\n<h4><a id=\"_500\"></a>其他语言中的格式符</h4>\n<p>而一些其他语言则是扩展了格式符功能用于解决上述问题，例如OC引入了%@格式符，用于调用对象的description方法来拼接字符串：</p>\n<pre><code class=\"prism language-objc\"><span class=\"token keyword\">@interface</span> Point2D <span class=\"token punctuation\">:</span> NSObject\n<span class=\"token keyword\">@property</span> <span class=\"token keyword\">double</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token keyword\">double</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>description<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> Point2D\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>description <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"(%lf, %lf)\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Point2D <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>Point2D alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">[</span>p setX<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">[</span>p setY<span class=\"token punctuation\">:</span><span class=\"token number\">2.5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"p=%@\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 会调用p的description方法来获取字符串，用于匹配%@</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>而Go语言引入了更加方便的%v格式符，可以用来匹配任意类型，用它的默认方式打印</p>\n<pre><code class=\"prism language-go\"><span class=\"token keyword\">type</span> Test <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{<!-- --></span>\n\tm1 <span class=\"token builtin\">int</span>\n\tm2 <span class=\"token builtin\">float32</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  a1 <span class=\"token operator\">:=</span> <span class=\"token number\">5</span>\n  a2 <span class=\"token operator\">:=</span> <span class=\"token number\">2.6</span>\n  a3 <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span>\n  a4 <span class=\"token operator\">:=</span> <span class=\"token string\">\"123abc\"</span>\n  a5 <span class=\"token operator\">:=</span> Test<span class=\"token punctuation\">{<!-- --></span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.5</span><span class=\"token punctuation\">}</span>\n\t\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a1=%v, a2=%v, a3=%v, a4=%v, a5=%v\\n\"</span><span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3<span class=\"token punctuation\">,</span> a4<span class=\"token punctuation\">,</span> a5<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Python则是用%s作为万能格式符来使用：</p>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n     a1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n     a2 <span class=\"token operator\">=</span> <span class=\"token number\">2.5</span>\n     a3 <span class=\"token operator\">=</span> <span class=\"token string\">\"abc123\"</span>\n     a4 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n     <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s, %s, %s, %s\"</span><span class=\"token operator\">%</span><span class=\"token punctuation\">(</span>a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3<span class=\"token punctuation\">,</span> a4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#这里没有特殊格式要求时都可以用%s来匹配</span>\n</code></pre>\n<h2><a id=\"_548\"></a>枚举</h2>\n<p>枚举类型原本是用于解决固定范围取值的类型表示，但由于在C语言中被定义为了整型类型的一种语法糖，导致枚举类型的使用上出现了一些问题。</p>\n<h4><a id=\"1__550\"></a>1. 无法前置声明。</h4>\n<p>枚举类型无法先声明后定义，例如下面这段代码会编译报错：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Season</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{<!-- --></span>\n  Season se<span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERR</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">enum</span> <span class=\"token class-name\">Season</span> <span class=\"token punctuation\">{<!-- --></span>\n  Spring<span class=\"token punctuation\">,</span>\n  Summer<span class=\"token punctuation\">,</span>\n  Autumn<span class=\"token punctuation\">,</span>\n  Winter\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>主要是因为enum类型是动态选择基础类型的，比如这里只有4个取值，那么可能会选取int16_t，而如果定义的取值范围比较大，或者中间出现大枚举值的成员，那么可能会选取int32_t或者int64_t。也就是说，枚举类型如果没定义完，编译期是不知道它的长度的，因此就没法前置声明。<br/> C++中允许指定枚举的基础类型，制定后可以前置声明:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Season</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{<!-- --></span>\n  Season se<span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">enum</span> <span class=\"token class-name\">Season</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">{<!-- --></span>\n  Spring<span class=\"token punctuation\">,</span>\n  Summer<span class=\"token punctuation\">,</span>\n  Autumn<span class=\"token punctuation\">,</span>\n  Winter\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>但如果你是在调别人写的库的时候，人家的枚举没有指定基础类型的话，那你也没辙了，就是不能前置声明。</p>\n<h4><a id=\"2__583\"></a>2. 无法确认枚举值的范围。</h4>\n<p>也就是说，我没有办法判断某个值是不是合法的枚举值：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Season</span> <span class=\"token punctuation\">{<!-- --></span>\n  Spring<span class=\"token punctuation\">,</span>\n  Summer<span class=\"token punctuation\">,</span>\n  Autumn<span class=\"token punctuation\">,</span>\n  Winter\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Season s <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Season<span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不会报错</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4><a id=\"3__597\"></a>3. 枚举值可以相同</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n  Ele1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n  Ele2<span class=\"token punctuation\">,</span>\n  Ele3 <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">bool</span> judge <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Ele1 <span class=\"token operator\">==</span> Ele3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4><a id=\"4_C_609\"></a>4. C风格的枚举还存在“成员名称全局有效”和“可以隐式转换为整型”的缺陷</h4>\n<p>但因为C++提供了<code>enum class</code>风格的枚举类型，解决了这两个问题，因此这里不再额外讨论。</p>\n<h2><a id=\"_611\"></a>宏</h2>\n<p>宏这个东西，完全就是针对编译器友好的，编译器非常方便地在宏的指导下，替换源代码中的内容。但这个玩意对程序员（尤其是阅读代码的人）来说是极其不友好的，由于是预处理指令，因此任何的静态检测均无法生效。一个经典的例子就是：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">MUL</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> x <span class=\"token operator\">*</span> y</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token function\">MUL</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 11</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为宏就是简单粗暴地替换而已，并没有任何逻辑判断在里面。<br/> 宏因为它很“好用”，所以非常容易被滥用，下面列举了一些宏滥用的情况供参考：</p>\n<h4><a id=\"1__622\"></a>1. 用宏来定义类成员</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">DEFAULT_MEM</span>     <span class=\"token punctuation\">\\</span>\n<span class=\"token expression\"><span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                 </span><span class=\"token punctuation\">\\</span>\n<span class=\"token expression\"><span class=\"token keyword\">int</span> <span class=\"token function\">GetX</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token keyword\">return</span> x_<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span> </span><span class=\"token punctuation\">\\</span>\n<span class=\"token expression\"><span class=\"token keyword\">private</span><span class=\"token operator\">:</span>                </span><span class=\"token punctuation\">\\</span>\n<span class=\"token expression\"><span class=\"token keyword\">int</span> x_<span class=\"token punctuation\">;</span></span></span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\nDEFAULT_MEM<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这种用法相当于屏蔽了内部实现，对阅读者非常不友好，与此同时加不加DEFAULT_MEM是一种软约束，实际开发时极容易出错。<br/> 再比如这种的：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">SINGLE_INST</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>class_name<span class=\"token punctuation\">)</span>                        </span><span class=\"token punctuation\">\\</span>\n <span class=\"token expression\"><span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                                               </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\"><span class=\"token keyword\">static</span> class_name <span class=\"token operator\">&amp;</span><span class=\"token function\">GetInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>                   </span><span class=\"token punctuation\">\\</span>\n    <span class=\"token expression\"><span class=\"token keyword\">static</span> class_name instance<span class=\"token punctuation\">;</span>                        </span><span class=\"token punctuation\">\\</span>\n    <span class=\"token expression\"><span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>                                   </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\"><span class=\"token punctuation\">}</span>                                                    </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\"><span class=\"token function\">class_name</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> class_name<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span>              </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\">class_name <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> class_name <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span>\n <span class=\"token expression\"><span class=\"token keyword\">private</span><span class=\"token operator\">:</span>                                              </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\"><span class=\"token function\">class_name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span></span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token function\">SINGLE_INST</span><span class=\"token punctuation\">(</span>Test<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这位同学，我理解你是想封装一下单例的实现，但咱是不是可以考虑一下更好的方式？（比如用模板）</p>\n<h4><a id=\"2__655\"></a>2. 用宏来屏蔽参数</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">strcpy_s</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">,</span> dst_buf_size<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">)</span> <span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">)</span></span></span>\n</code></pre>\n<p>这位同学，咱要是真想写一个安全版本的函数，咱就好好去判断dst_buf_size如何？</p>\n<h4><a id=\"3__660\"></a>3. 用宏来拼接函数处理</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">COPY_IF_EXSITS</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">,</span> field<span class=\"token punctuation\">)</span> </span><span class=\"token punctuation\">\\</span>\n<span class=\"token expression\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{<!-- --></span>                                    </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">.</span>has_</span><span class=\"token punctuation\">##</span><span class=\"token expression\"><span class=\"token function\">field</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>              </span><span class=\"token punctuation\">\\</span>\n    <span class=\"token expression\">dst<span class=\"token punctuation\">.</span>set_</span><span class=\"token punctuation\">##</span><span class=\"token expression\"><span class=\"token function\">field</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span><span class=\"token function\">field</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       </span><span class=\"token punctuation\">\\</span>\n  <span class=\"token expression\"><span class=\"token punctuation\">}</span>                                     </span><span class=\"token punctuation\">\\</span>\n<span class=\"token expression\"><span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  Pb1 pb1<span class=\"token punctuation\">;</span>\n  Pb2 pb2<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">COPY_IF_EXSITS</span><span class=\"token punctuation\">(</span>pb2<span class=\"token punctuation\">,</span> pb1<span class=\"token punctuation\">,</span> f1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">COPY_IF_EXSITS</span><span class=\"token punctuation\">(</span>pb2<span class=\"token punctuation\">,</span> pb1<span class=\"token punctuation\">,</span> f2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这种用宏来做函数名的拼接看似方便，但最容易出的问题就是类型不一致，加入<code>pb1</code>和<code>pb2</code>中虽然都有<code>f1</code>这个字段，但类型不一样，那么这样用就可能造成类型转换。试想<code>pb1.f1</code>是<code>uint64_t</code>类型，而<code>pb2.f1</code>是<code>uint32_t</code>类型，这样做是不是有可能造成数据的截断呢？</p>\n<h4><a id=\"4__678\"></a>4. 用宏来改变语法风格</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">IF</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>con<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>con<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">END_IF</span> <span class=\"token expression\"><span class=\"token punctuation\">}</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">ELIF</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>con<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>con<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">ELSE</span> <span class=\"token expression\"><span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">IF</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Process1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">ELIF</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> \n    <span class=\"token function\">Process2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  ELSE\n    <span class=\"token function\">Process3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这位同学你到底是写python写惯了不适应C语法呢，还是说你为了让代码扫描工具扫不出来你的圈复杂度才出此下策的呢~~</p>\n<h1><a id=\"_697\"></a>小结</h1>\n<p>C++的所谓“缺陷”，有很大程度上是C语言造成的，由于C语言的特殊性，使得C++背负着历史包袱，而要提供一些方便的用法，都不太敢通过直接改变语法的方式，因为可能会造成对C、或者老版本C++的不兼容。因此C++采用的方式就是封装成STL中的工具，但这样做的缺点就是用起来会很别扭，不如原生语法那样优雅。</p>\n<p><strong>本文主要介绍的是从C继承来的缺陷，上述关于封装成STL工具后引发的一些问题将会在后续文章将会继续介绍，后续文章也会介绍C++的一些其他缺陷和笔者的思考。</strong></p>\n<p>第二篇已经脱稿，请看<a href=\"https://blog.csdn.net/fl2011sx/article/details/126300435\">C++的缺陷和思考（二）</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 1, "csharp": 1, "python": 1, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-08-23 13:13:15", "summary": "前言我从大学时期就开始研究，并稳定扎根在方向上，作为一名专职的程序员，在这些年的开发经历中，对语言的一些缺陷有了一些思考总结。与此同时，新兴的编程语言越来越受欢迎，而本身为了克服自己的一些缺陷，也在发"}