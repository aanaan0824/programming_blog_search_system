{"blogid": "121381597", "writerAge": "码龄5年", "writerBlogNum": "87", "writerCollect": "253", "writerComment": "41", "writerFan": "362", "writerGrade": "4级", "writerIntegral": "1390", "writerName": "dancebit", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121381597.jpg", "writerRankTotal": "17065", "writerRankWeekly": "22550", "writerThumb": "49", "writerVisitNum": "89958", "blog_read_count": "2230", "blog_time": "于 2021-11-17 18:14:31 发布", "blog_title": "USB HID上位机测试（C#）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95\" title=\"1、基本测试\">1、基本测试</a></p>\n<p id=\"1.1%E3%80%81%E9%80%9A%E8%BF%87Bus%20Hound%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AE%BE%E5%A4%87%E5%88%97%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%E3%80%81%E9%80%9A%E8%BF%87Bus%20Hound%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AE%BE%E5%A4%87%E5%88%97%E8%A1%A8\" title=\"1.1、通过Bus Hound可以看到设备列表\">1.1、通过Bus Hound可以看到设备列表</a></p>\n<p id=\"%C2%A01.2%E3%80%81%C2%A0%E9%80%9A%E8%BF%87API%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E2%80%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01.2%E3%80%81%C2%A0%E9%80%9A%E8%BF%87API%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E2%80%8B\" title=\" 1.2、 通过API获取到设备接口文件列表​\"> 1.2、 通过API获取到设备接口文件列表​</a></p>\n<p id=\"1.3%E3%80%81%E7%94%A8BUS%20Hound%E6%94%B6%E5%8F%91%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%E3%80%81%E7%94%A8BUS%20Hound%E6%94%B6%E5%8F%91%E6%B5%8B%E8%AF%95\" title=\"1.3、用BUS Hound收发测试\">1.3、用BUS Hound收发测试</a></p>\n<p id=\"%C2%A02%E3%80%81C%23%E4%B8%8A%E4%BD%8D%E6%9C%BA-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A02%E3%80%81C%23%E4%B8%8A%E4%BD%8D%E6%9C%BA\" title=\" 2、C#上位机\"> 2、C#上位机</a></p>\n<p id=\"2.1%E3%80%81%E6%89%93%E5%BC%80%E8%AE%BE%E5%A4%87-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%E3%80%81%E6%89%93%E5%BC%80%E8%AE%BE%E5%A4%87\" title=\"2.1、打开设备\">2.1、打开设备</a></p>\n<p id=\"%E6%8A%A5%E5%91%8AReportID-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8A%A5%E5%91%8AReportID\" title=\"报告ReportID\">报告ReportID</a></p>\n<p id=\"2.2%E3%80%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%E3%80%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE\" title=\"2.2、发送数据\">2.2、发送数据</a></p>\n<p id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B3%A8%E6%84%8F%EF%BC%9A\" title=\"注意：\">注意：</a></p>\n<p id=\"%E6%B5%8B%E8%AF%95%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B5%8B%E8%AF%95%EF%BC%9A\" title=\"测试：\">测试：</a></p>\n<p id=\"%C2%A02.3%E3%80%81%E5%BC%82%E6%AD%A5%E6%8E%A5%E6%94%B6-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.3%E3%80%81%E5%BC%82%E6%AD%A5%E6%8E%A5%E6%94%B6\" title=\" 2.3、异步接收\"> 2.3、异步接收</a></p>\n<p id=\"3%E3%80%81%E5%85%B6%E4%BB%96%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:0px;\"><a href=\"#3%E3%80%81%E5%85%B6%E4%BB%96%E6%B5%8B%E8%AF%95\" title=\"3、其他测试\">3、其他测试</a></p>\n<p id=\"3.1%E3%80%81%E4%B8%AD%E6%96%AD%E7%AB%AF%E7%82%B9%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%E3%80%81%E4%B8%AD%E6%96%AD%E7%AB%AF%E7%82%B9%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95\" title=\"3.1、中断端点时间测试\">3.1、中断端点时间测试</a></p>\n<hr id=\"hr-toc\"/>\n<p>下位机这两天已经折腾出一个一二了，在配合上位机完整学习一下，下位机芯片是STM32F103VB</p>\n<h1 id=\"1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95\">1、基本测试</h1>\n<h2 id=\"1.1%E3%80%81%E9%80%9A%E8%BF%87Bus%20Hound%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AE%BE%E5%A4%87%E5%88%97%E8%A1%A8\">1.1、通过Bus Hound可以看到设备列表</h2>\n<p><img alt=\"\" height=\"151\" src=\"..\\..\\static\\image\\5c71e7df3217476d8faee94879638562.png\" width=\"545\"/></p>\n<p><img alt=\"\" height=\"91\" src=\"..\\..\\static\\image\\e427f4c13e624e28b1e2d3499e3173c1.png\" width=\"599\"/></p>\n<h2 id=\"%C2%A01.2%E3%80%81%C2%A0%E9%80%9A%E8%BF%87API%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E2%80%8B\"> 1.2、 通过API获取到设备接口文件列表</h2>\n<p><img alt=\"\" height=\"257\" src=\"..\\..\\static\\image\\252123c541b34329bbbd0eb2e82c9fcf.png\" width=\"563\"/></p>\n<p> 可以看出，每个接口有一个对应的操作对象，三个设备是可以独立操作的。</p>\n<ul><li>\\\\?\\hid#vid_0480&amp;pid_5750&amp;<span style=\"color:#fe2c24;\">mi_00</span>#8&amp;eff1a39&amp;0&amp;0000#{4d1e55b2-f16f-11cf-88cb-001111000030}</li><li>\\\\?\\hid#vid_0480&amp;pid_5750&amp;<span style=\"color:#fe2c24;\">mi_01</span>#8&amp;32d657fb&amp;0&amp;0000#{4d1e55b2-f16f-11cf-88cb-001111000030}\\kbd</li><li> \\\\?\\hid#vid_0480&amp;pid_5750&amp;<span style=\"color:#fe2c24;\">mi_02</span>#8&amp;1b12cbb6&amp;0&amp;0000#{4d1e55b2-f16f-11cf-88cb-001111000030}</li></ul>\n<p>用   mi_(接口编号)  区别,接口编号对应配置描述表里的接口编号，鼠标0，键盘1，自定义HID 2</p>\n<blockquote>\n<p> 此处的复合设备是单独的接口操作的，就会产生对应的操作文件。如果是通过同一个接口，用报告描述符ID来产生的对个设备，将不会出现对个设备文件，操作时需要通过报告描述符ID来寻找设备。</p>\n</blockquote>\n<h2 id=\"1.3%E3%80%81%E7%94%A8BUS%20Hound%E6%94%B6%E5%8F%91%E6%B5%8B%E8%AF%95\">1.3、用BUS Hound收发测试</h2>\n<p>bus hound 不会限制发送长度，下位机端也可以不用报告描述符来描述具体发送数据的意义及格式</p>\n<p> <img alt=\"\" height=\"471\" src=\"..\\..\\static\\image\\330edeec71894e28a94885ba2ec531f0.png\" width=\"644\"/></p>\n<h1 id=\"%C2%A02%E3%80%81C%23%E4%B8%8A%E4%BD%8D%E6%9C%BA\"> 2、C#上位机</h1>\n<p><a class=\"has-card\" href=\"https://download.csdn.net/download/ai5945fei/43657670\" title=\"C# HID上位机\"><span class=\"link-card-box\"><span class=\"link-title\">C# HID上位机</span><span class=\"link-link\"><img alt=\"icon-default.png?t=LA92\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://download.csdn.net/download/ai5945fei/43657670</span></span></a></p>\n<p>参考：</p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/u010875635/article/details/73321066?spm=1035.2023.3001.6557&amp;utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-2~default~OPENSEARCH~default-5.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-2~default~OPENSEARCH~default-5.nonecase\" title=\"【C#】HID API_beatfan的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">【C#】HID API_beatfan的博客-CSDN博客</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"..\\..\\static\\image\\icon-default.png\"/>https://blog.csdn.net/u010875635/article/details/73321066?spm=1035.2023.3001.6557&amp;utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-2~default~OPENSEARCH~default-5.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-2~default~OPENSEARCH~default-5.nonecase</span></span></a>其中做了些修改，感觉原先的有点小问题</p>\n<h2 id=\"2.1%E3%80%81%E6%89%93%E5%BC%80%E8%AE%BE%E5%A4%87\">2.1、打开设备</h2>\n<p>不建议去打开一些未知的设备，确定是谁再去打开，可以通过VID和PID，接口编号三个参数确定我们的目标设备。</p>\n<pre><code class=\"language-cs\">public HID_RETURN OpenDevice(string deviceNme)\n{\n    if (deviceOpened == false)\n    {\n        IntPtr device = CreateFile(deviceNme,\n                                    DESIREDACCESS.GENERIC_READ | DESIREDACCESS.GENERIC_WRITE,\n                                    0,\n                                    0,\n                                    CREATIONDISPOSITION.OPEN_EXISTING,\n                                    FLAGSANDATTRIBUTES.FILE_FLAG_OVERLAPPED,\n                                    0);\n        if (device != INVALID_HANDLE_VALUE)\n        {\n            HIDD_ATTRIBUTES attributes;\n            IntPtr serialBuff = Marshal.AllocHGlobal(512);\n            HidD_GetAttributes(device, out attributes);\n            HidD_GetSerialNumberString(device, serialBuff, 512);\n            string deviceStr = Marshal.PtrToStringAuto(serialBuff);\n            Marshal.FreeHGlobal(serialBuff);\n\n            IntPtr preparseData;\n            HIDP_CAPS caps;\n            HidD_GetPreparsedData(device, out preparseData);\n            HidP_GetCaps(preparseData, out caps);\n            HidD_FreePreparsedData(preparseData);\n            outputReportLength = caps.OutputReportByteLength;\n            inputReportLength = caps.InputReportByteLength;\n\n            hidDevice = new FileStream(new SafeFileHandle(device, false), FileAccess.ReadWrite, inputReportLength, true);\n            deviceOpened = true;\n            BeginAsyncRead();\n\n            hHubDevice = device;\n            return HID_RETURN.SUCCESS;\n        }\n\n        return HID_RETURN.DEVICE_NOT_FIND;\n    }\n    else\n        return HID_RETURN.DEVICE_OPENED;\n}    </code></pre>\n<h3 id=\"%E6%8A%A5%E5%91%8AReportID\">报告ReportID</h3>\n<p>测试发现：</p>\n<ul><li>如果报告描述符有问题，则获取出来的caps对应值就为0，我开始没设置端点OUT的信息，caps.OutputReportByteLength就为0。</li><li>实际的值会默认加上报告描述符描述表ReportID,首字节位置。默认为0，多报告表就对应变化。及caps.OutputReportByteLength = 1字节ReportID + 实际报告表描述的数据长度。</li></ul>\n<pre><code class=\"language-cs\">HIDP_CAPS caps;\nHidP_GetCaps(preparseData, out caps);\noutputReportLength = caps.OutputReportByteLength;\ninputReportLength = caps.InputReportByteLength;</code></pre>\n<h2 id=\"2.2%E3%80%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE\">2.2、发送数据</h2>\n<pre><code class=\"language-cs\">public HID_RETURN Write(report r)\n{\n    if (deviceOpened)\n    {\n        try\n        {\n            byte[] buffer = new byte[outputReportLength];\n            int txlen = r.reportBuff.Length;\n            if (txlen &gt; outputReportLength) txlen = outputReportLength;\n            buffer[0] = r.reportID;\n            Array.Copy(r.reportBuff, 0, buffer, 1, txlen);\n            hidDevice.Write(buffer, 0, buffer.Length);\n            hidDevice.Flush();//立即发送数据\n            return HID_RETURN.SUCCESS;\n        }\n        catch\n        {\n            EventArgs ex = new EventArgs();\n            OnDeviceRemoved(ex);//发出设备移除消息\n            CloseDevice();\n            return HID_RETURN.NO_DEVICE_CONECTED;\n        }\n    }\n    return HID_RETURN.WRITE_FAILD;\n}</code></pre>\n<h3 id=\"%E6%B3%A8%E6%84%8F%EF%BC%9A\">注意：</h3>\n<ul><li>写入数据之后调用 <span style=\"color:#fe2c24;\">hidDevice.Flush</span>,数据才会立即发送，否则就会乱发送。</li><li>发送数据的buffer的长度必须和outputReportLength一致，否则会报错，不知缘由。</li><li>buffer的首字节为ReportID,一个报告下默认为0。（如果有多个时，这个参数就有用了）</li></ul>\n<h3 id=\"%E6%B5%8B%E8%AF%95%EF%BC%9A\">测试：</h3>\n<p>同时勾选两个上这两个</p>\n<p><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\e0f807cab7d94e0d97f2843d3c460c32.png\" width=\"427\"/></p>\n<p><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\33caf5adee654ed497b463aeaf585cb9.png\" width=\"661\"/></p>\n<p> <img alt=\"\" height=\"70\" src=\"..\\..\\static\\image\\d411257fd6804cf992cfcb7e20cc71b4.png\" width=\"226\"/></p>\n<p>会发现106.3 发送8个字节，109是9个字节，加上了ReportID，下位机收到的也是8个字节。</p>\n<h2 id=\"%C2%A02.3%E3%80%81%E5%BC%82%E6%AD%A5%E6%8E%A5%E6%94%B6\"> 2.3、异步接收</h2>\n<pre><code class=\"language-cs\">private void ReadCompleted(IAsyncResult iResult)\n{\n    byte[] readBuff = (byte[])(iResult.AsyncState);\n    try\n    {\n        hidDevice.EndRead(iResult);//读取结束,如果读取错误就会产生一个异常\n        byte[] reportData = new byte[readBuff.Length - 1];\n        for (int i = 1; i &lt; readBuff.Length; i++)\n            reportData[i - 1] = readBuff[i];\n        report e = new report(readBuff[0], reportData);\n        OnDataReceived(e); //发出数据到达消息\n        if (!deviceOpened) return;\n        BeginAsyncRead();//启动下一次读操作\n    }\n    catch  //读写错误,设备已经被移除\n    {\n        //MyConsole.WriteLine(\"设备无法连接，请重新插入设备\");\n        EventArgs ex = new EventArgs();\n        OnDeviceRemoved(ex);//发出设备移除消息\n        CloseDevice();\n    }\n}</code></pre>\n<ul><li>接收到的数据头字节也是ReportID，数据为其后的内容。</li><li>如果上传的数据长度和报告描述表里规定的长度不一致，API也收不到数据，但是BusHound能监控到数据。(肯定是哪里有问题，后续再查)</li></ul>\n<h1 id=\"3%E3%80%81%E5%85%B6%E4%BB%96%E6%B5%8B%E8%AF%95\">3、其他测试</h1>\n<h2 id=\"3.1%E3%80%81%E4%B8%AD%E6%96%AD%E7%AB%AF%E7%82%B9%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95\">3.1、中断端点时间测试</h2>\n<p>连续发送两个包，查看发送时间间隔</p>\n<pre><code class=\"language-cs\">private void button2_Click(object sender, EventArgs e)\n{\n    SendBytes(new byte[] { 0xA5, 0, 1, 0 });\n    SendBytes(new byte[] { 0xA5, 0, 2, 0 });\n}</code></pre>\n<p>OUT端点设置</p>\n<p><img alt=\"\" height=\"187\" src=\"..\\..\\static\\image\\cd6cf55dd3e8459693db064229462f2b.png\" width=\"677\"/></p>\n<p> 结果:</p>\n<p><img alt=\"\" height=\"104\" src=\"..\\..\\static\\image\\131ad9a435d143e7ba45e5a7dffe51eb.png\" width=\"609\"/></p>\n<p>点击了两次，连续发送的两个包之间间隔是31ms,设置的端点中断时间为32ms</p>\n<hr/>\n<p><strong>对比：</strong>改成10ms之后,对应间隔变成8ms左右</p>\n<p><img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\973610e21adc4365992fcbccdffd10e9.png\" width=\"674\"/></p>\n<blockquote>\n<p> 修改之后，需要删除原来的设备重新安装设备这个值才会刷新，或者修改VID,PID也可以。否则PC会记录并使用以前的值。</p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\"> 所以要是需要下发的数据块速接收到，将 bInterval: Polling Interval  改小即可。</span></p>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-11-17 18:14:31", "summary": "目录、基本测试、基本测试、通过可以看到设备列表、通过可以看到设备列表、通过获取到设备接口文件列表、通过获取到设备接口文件列表、用收发测试、用收发测试、上位机、上位机、打开设备、打开设备报告报告、发送数"}