{"blogid": "126336991", "writerAge": "码龄3年", "writerBlogNum": "92", "writerCollect": "81", "writerComment": "15", "writerFan": "169", "writerGrade": "4级", "writerIntegral": "994", "writerName": "干饭小白", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126336991.jpg", "writerRankTotal": "19440", "writerRankWeekly": "2525", "writerThumb": "65", "writerVisitNum": "44659", "blog_read_count": "2072", "blog_time": "于 2022-08-16 19:14:59 发布", "blog_title": "C++项目实战-信号", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"main-toc\"><strong>目录</strong></h1>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5\">信号的概念</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%85%B1%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%85%B1%E6%80%A7\">信号的共性</a></p>\n<p id=\"%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%AE%E7%9A%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%AE%E7%9A%84\">使用信号的目的</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6\">信号的机制</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%89%B9%E8%B4%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%89%B9%E8%B4%A8\">信号的特质</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81\">信号的状态</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\">信号的处理方式</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E9%9B%86-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E9%9B%86\">信号集</a></p>\n<p id=\"%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86\">未决信号集和阻塞信号集</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7%C2%A0\">信号的编号 </a></p>\n<p id=\"%E4%BF%A1%E5%8F%B74%E8%A6%81%E7%B4%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B74%E8%A6%81%E7%B4%A0\">信号4要素</a></p>\n<p id=\"Linux%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E8%AF%B4%E6%98%8E(1-31)-toc\" style=\"margin-left:40px;\"><a href=\"#Linux%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E8%AF%B4%E6%98%8E%281-31%29\">Linux常规信号说明(1-31)</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F\">信号的产生</a></p>\n<p id=\"%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\">终端按键产生信号</a></p>\n<p id=\"%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\">硬件异常产生信号</a></p>\n<p id=\"kill%E5%87%BD%E6%95%B0%2F%E5%91%BD%E4%BB%A4%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7-toc\" style=\"margin-left:80px;\"><a href=\"#kill%E5%87%BD%E6%95%B0%2F%E5%91%BD%E4%BB%A4%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\">kill函数/命令产生信号</a></p>\n<p id=\"%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\">软件条件产生信号</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\">信号集操作函数</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E9%9B%86%E8%AE%BE%E5%AE%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E9%9B%86%E8%AE%BE%E5%AE%9A\">信号集设定</a></p>\n<p id=\"sigprocmask%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#sigprocmask%E5%87%BD%E6%95%B0\">sigprocmask函数</a></p>\n<p id=\"sigpending%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#sigpending%E5%87%BD%E6%95%B0\">sigpending函数</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89\">信号捕捉</a></p>\n<p id=\"%C2%A0signal%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0signal%E5%87%BD%E6%95%B0\"> signal函数</a></p>\n<p id=\"sigaction%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#sigaction%E5%87%BD%E6%95%B0\">sigaction函数</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7\">信号捕捉特性</a></p>\n<p id=\"%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B\">信号捕捉函数案例</a></p>\n<p id=\"%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E8%BF%87%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E8%BF%87%E7%A8%8B\">内核实现信号捕捉过程</a></p>\n<p id=\"%C2%A0%E6%97%B6%E6%80%81%E7%AB%9E%E4%BA%89-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%97%B6%E6%80%81%E7%AB%9E%E4%BA%89\"> 时态竞争</a></p>\n<p id=\"%C2%A0%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A\"> 时序问题分析：</a></p>\n<p id=\"%E8%A7%A3%E5%86%B3%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%A7%A3%E5%86%B3%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98\">解决时序问题</a></p>\n<p id=\"%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\">时序问题总结</a></p>\n<p id=\"%E5%8F%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8F%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%C2%A0\">可不可重入函数 </a></p>\n<p id=\"SIGCHLD%E4%BF%A1%E5%8F%B7%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#SIGCHLD%E4%BF%A1%E5%8F%B7%C2%A0\">SIGCHLD信号 </a></p>\n<p id=\"%C2%A0%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82\"> 信号传参</a></p>\n<p id=\"%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">中断系统调用</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5\">信号的概念</h2>\n<blockquote>\n<p>信号在我们的生活中随处可见，如古代烽火戏诸侯中的烽火，跑步时的使用的信号枪发出的信号。</p>\n<p>所以说，信号是信息的载体，不能够携带大量的信息</p>\n<h3 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%85%B1%E6%80%A7\">信号的共性</h3>\n<p>简单，不能够携带大量的信息，满足某个特定条件，优先级高</p>\n<h3 id=\"%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%9B%AE%E7%9A%84\">使用信号的目的</h3>\n<p>1.让进程知道已经发生了一个特定的事情</p>\n<p>2.强迫进程执行它自己代码中的信号处理程序(中断机制)</p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6\">信号的机制</h2>\n<blockquote>\n<p>A给B发送信号。B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，立即去处理信号(信号的优先级高)。与硬件中断类似，但信号是软件层实现的中断，又成为“软中断”。</p>\n<p></p>\n<h3 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%89%B9%E8%B4%A8\">信号的特质</h3>\n<p>由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>\n<p><span style=\"color:#fe2c24;\"><strong>每一进程收到的所有信号，都是由内核负责发送的，内核处理(请记住这句话)</strong></span></p>\n<p></p>\n<p><strong>引发内核为进程产生信号的各类事件：</strong></p>\n<p><strong>1.对于前台进程，用户可以输入特殊的终端字符来给它发送信号</strong></p>\n<p><strong>ctrl+c  ctrl+z  ctrl+\\</strong></p>\n<p><strong>2.硬件发送异常</strong></p>\n<p><strong>非法访问内存(段错误)  除0  内存对齐出错(总线错误)</strong></p>\n<p><strong>3.系统状态变化</strong></p>\n<p><strong>4.运行kill</strong></p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81\">信号的状态</h2>\n<blockquote>\n<p><strong>产生信号</strong></p>\n<p><strong>        按键产生</strong></p>\n<p><strong>        系统调用</strong></p>\n<p><strong>        软件条件产生</strong></p>\n<p><strong>        硬件异常产生</strong></p>\n<p><strong>        命令产生</strong></p>\n<p><strong>未决</strong></p>\n<p><strong>        产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态</strong></p>\n<p><strong>递答</strong></p>\n<p><strong>        递送并且到达进程</strong></p>\n<p></p>\n<h3 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\"><strong>信号的处理方式</strong></h3>\n<p><strong>        1.执行默认动作</strong></p>\n<p><strong>        2.忽略(丢弃)</strong></p>\n<p><strong>        3.捕捉(调用用户处理函数)</strong></p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E9%9B%86\">信号集</h2>\n<blockquote>\n<p>Linux内核的进程控制块PCB是一个结构体，task_struct除了包含进程id,状态，工作目录，用户id,组id,文件描述表，还包含了信号相关的信息，主要指<span style=\"color:#fe2c24;\">阻塞信号集和未决信号集</span></p>\n</blockquote>\n<blockquote>\n<p>1.许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t</p>\n<p><img alt=\"\" height=\"107\" src=\"..\\..\\static\\image\\eb00395a5e314c7fb45e3b62b7ee6cd1.png\" width=\"412\"/></p>\n<p></p>\n<p>2.在PCB中有两个非常重要的信号集。一个称为\"阻塞信号集\"，另一个称为\"未决信号集\"。这两个信号集都是内核使用<span style=\"color:#fe2c24;\">位图</span>机制实现的。但操作系统不允许我们直接对这两个信号集进行位操作(我们都知道用户是不能够直接去操作内核空间里的内容的)。<span style=\"color:#fe2c24;\">需自定义另一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改</span></p>\n<p>3.信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间</p>\n<p>4.信号的\"阻塞\"是一种开关状态，<span style=\"color:#fe2c24;\">指的是阻止信号被处理</span>，但不是阻止信号产生</p>\n<p>5.信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感操作</p>\n</blockquote>\n<h2 id=\"%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86\">未决信号集和阻塞信号集</h2>\n<blockquote>\n<p><img alt=\"\" height=\"583\" src=\"..\\..\\static\\image\\8b4d1c52b0044fec969d2ea3df6ab50e.png\" width=\"994\"/><strong>阻塞信号集(信号屏蔽字)</strong></p>\n<p>        将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，在收到该信号，该信号的处理将被推迟(解除屏蔽后)。说个通俗点的，阻塞信号集可以暂时影响未决信号集，未决信号集上面有讲到是一个状态，它是处于产生到递达之间的状态(递达包括了送达并且处理)。在未决信号集中标识了<span style=\"color:#fe2c24;\">暂时不处理</span>，那么就是忽略。处理信号不是有三种方式嘛</p>\n<p><strong>未决信号集</strong></p>\n<p><strong>       </strong> 1.信号的产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应的位置转回0。这一时刻往往非常短暂</p>\n<p>        2.信号产生后由某些原因(主要是阻塞)不能到达。这类信号的集合称之为未决信号集。在解除屏蔽之前一直处于未决定状态</p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7%C2%A0\">信号的编号 </h2>\n<blockquote>\n<p>查看信号：kill -l</p>\n<p><img alt=\"\" height=\"277\" src=\"..\\..\\static\\image\\f33d162e5f6b424c824080c404c00be6.png\" width=\"816\"/></p>\n<p>说明：</p>\n<p>        不存在0号信号。</p>\n<p>        1-31：常规信号(普通信号、标准信号)</p>\n<p>        32-64: 实时信号(驱动编程于硬件有关) </p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B74%E8%A6%81%E7%B4%A0\">信号4要素</h2>\n<blockquote>\n<p>每个信号有4个必备的要素：</p>\n<p><strong>编号   名称   事件   默认处理动作</strong></p>\n<p>通过 man 7 signal查看</p>\n<p>      名称               编号      默认处理动作  事件  </p>\n<p><img alt=\"\" height=\"518\" src=\"..\\..\\static\\image\\252284568ad74147b42d7072cde88c32.png\" width=\"768\"/></p>\n<p>在标准信号中，有一些信号有三个“value”。这是因为不同的操作系统定义了不同的系统信号。我们只研究Linux(中间的值)，为了避免歧义，直接使用名称即可</p>\n<p></p>\n<p><strong>默认处理动作</strong></p>\n<p><strong>Term:终止进程</strong></p>\n<p><strong>Core:终止进程</strong>，<strong>生成Core文件</strong>(查验进程死亡原因，用于gdb调试)   ulimit -a/ulimit -c 1024</p>\n<p><img alt=\"\" height=\"276\" src=\"..\\..\\static\\image\\a4d290913cb8459ebc43e5c7789e1fd0.png\" width=\"431\"/></p>\n<p><strong>Ing:忽略信号</strong></p>\n<p><strong>Stop:暂停信号</strong></p>\n<p><strong>Cont:继续运行进程</strong></p>\n<p></p>\n<p><strong>特别说明:</strong></p>\n<p><img alt=\"\" height=\"47\" src=\"..\\..\\static\\image\\a27a92bd407b47249daa60a1a930f69e.png\" width=\"709\"/></p>\n<p><strong><span style=\"background-color:#a5a5a5;\"> 9)SIGKILL和19)SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞</span></strong></p>\n<p><span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#a5a5a5;\">只要产生信号发送的事件发送，信号一定会产生并且递送，但是由于阻塞信号集的原因，该信号不一定会被递达，信号的产生和处理都是内核做到事情。信号的处理方式是信号递达之后的处理方式</span></strong></span></p>\n<p>core文件的查看<br/> core文件需要使用gdb来查看。<br/> gdb ./a.out<br/> core-file core.xxxx</p>\n</blockquote>\n<h2 id=\"Linux%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E8%AF%B4%E6%98%8E(1-31)\">Linux常规信号说明(1-31)</h2>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\">1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">2) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</span></p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">3) SIGQUIT：当用户按下&lt;ctrl+\\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</span></p>\n<p style=\"margin-left:0;text-align:justify;\">4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</p>\n<p style=\"margin-left:0;text-align:justify;\">5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</p>\n<p style=\"margin-left:0;text-align:justify;\">6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。</p>\n<p style=\"margin-left:0;text-align:justify;\">7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>\n<p style=\"margin-left:0;text-align:justify;\">8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</span></p>\n<p style=\"margin-left:0;text-align:justify;\">10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</span></p>\n<p style=\"margin-left:0;text-align:justify;\">12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</span></p>\n<p style=\"margin-left:0;text-align:justify;\">14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</span></p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</span></p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#a2e043;\">19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</span></p>\n<p style=\"margin-left:0;text-align:justify;\">20) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</p>\n<p style=\"margin-left:0;text-align:justify;\">24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</p>\n<p style=\"margin-left:0;text-align:justify;\">29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</p>\n<p style=\"margin-left:0;text-align:justify;\">30) SIGPWR：关机。默认动作为终止进程。</p>\n<p style=\"margin-left:0;text-align:justify;\">31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</p>\n<p style=\"margin-left:0;text-align:justify;\">34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F\">信号的产生</h2>\n<blockquote>\n<h3 id=\"%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\"><strong>终端按键产生信号</strong></h3>\n<p><span style=\"color:#956fe7;\"><strong>        ctrl+c   ==&gt;   2)SIGINT   用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>        ctrl+z   ==&gt;   20) SIGTSTP  停止终端交互进程的运行。默认动作为暂停进程。</strong></span></p>\n<p><span style=\"color:#956fe7;\"><strong>        ctrl+\\    ==&gt;   3) SIGQUIT    用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</strong></span></p>\n<h3 id=\"%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\"><strong>硬件异常产生信号</strong></h3>\n<p><span style=\"color:#956fe7;\"><strong>        除0操作              ==&gt;</strong>8) SIGFPE 在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。<strong>默认动作为终止进程并产生core文件</strong>。</span></p>\n<p><span style=\"color:#956fe7;\"><strong>        非法访问内存    ==&gt;</strong>20) SIGTSTP：停止终端交互进程的运行。<strong>默认动作为暂停进程</strong>。</span></p>\n<p><span style=\"color:#956fe7;\"><strong>        总线错误            ==&gt;</strong>7) SIGBUS：非法访问内存地址，包括内存对齐出错，<strong>默认动作为终止进程并产生core文件。</strong></span></p>\n<h3 id=\"kill%E5%87%BD%E6%95%B0%2F%E5%91%BD%E4%BB%A4%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\"><strong>kill函数/命令产生信号</strong></h3>\n<p><strong>        kill命令产生信号：</strong>kill -信号名称或编号  进程id   (eg:kill -9(SIGKILL)  12201)</p>\n<p><strong>        kill函数：</strong>给指定进程发送信号(不一定是杀死,根据发送什么信号决定)</p>\n<p><strong>        int kill(pid_t  pid,int sig);</strong></p>\n<p><strong>        成功：</strong>0  </p>\n<p><strong>        失败：</strong>-1(id非法  信号非法  权限问题)</p>\n<p>       <strong> 参数：</strong></p>\n<p><strong>    </strong>    sig:使用宏名，不要使用编号(避免歧义)</p>\n<p>        pid:</p>\n<p>                &gt;0  ==&gt;  发送给指定的进程</p>\n<p>                =0  ==&gt;  发送信号给与调用kill函数进程属于同一进程组的所有进程</p>\n<p>                &lt;0  ==&gt;  取|pid|发送给对应的进程组</p>\n<p>                -1   ==&gt;  发送给进程有权限发送的所有进程</p>\n<p><strong>一些概念说明：</strong></p>\n<p><strong>         进程组：</strong></p>\n<p><strong>                </strong>每一个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每一个进程都有一个进程组长，默认进程组ID与进程组长ID相同。</p>\n<p><strong>         权限保护：</strong></p>\n<p><strong>        </strong>        超级用户可以向任意用户发送信号，而普通用户不能向系统用户发送信号。同样普通用户无法向其他普通用户发送信号。<span style=\"color:#fe2c24;\">只能向自己创建的进程发送信号</span></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n\nusing namespace std;\n\nint main(void)\n{\n\n    pid_t pid;\n    int i;\n    int tmppid;\n    //abort();\n    //raise(SIGSTOP);\n\n    for(i=0;i&lt;5;++i)\n    {\n        pid = fork();\n        if(pid == 0)\n        {\n            break;\n        }\n        if(i == 2)\n        {\n            tmppid = pid;\n        }\n    }\n\n    if(i &lt; 5)\n    {\n        cout&lt;&lt;getpid()&lt;&lt;\"  其父:\"&lt;&lt;getppid()&lt;&lt;endl;\n        sleep(2);\n    }\n    else if(i == 5)\n    {\n       sleep(1);\n       kill(tmppid,SIGKILL);\n       while(1)\n       {}\n    }\n\n\n    return 0;\n}</code></pre>\n<h3 id=\"%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7\"><strong>软件条件产生信号</strong></h3>\n<p><strong>        alarm函数</strong></p>\n<p><strong>        说明：</strong>设置定时器(闹钟)。在指定多少秒后，内核会给当前进程发送14)SIGALRM信号，进程收到该信号，默认动作终止进程。无论进程处于某种状态都会记时</p>\n<p><strong>        原型：</strong></p>\n<p><strong>       </strong> unsigned int alarm(unsigned int seconds);</p>\n<p>        返回0或剩余的秒数</p>\n<p><strong>取消定时器：alarm(0)</strong></p>\n<p><strong>查看当前进程执行的秒数：time 可执行程序</strong></p>\n<p><strong>实际执行时间=系统时间+用户时间+等待时间(绝大多数时间都是在等待中度过)</strong></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:650px;\"><tbody><tr><td> <p>程序运行的瓶颈在于IO,优化程序，首先优化IO</p> <p>例如：</p> <p>        往屏幕上打印，很浪费时间。我们可以重定向往文件中输出</p> </td></tr></tbody></table>\n<p><strong>分别向文件和终端打印，观察1s可以计算多少个数：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nusing namespace std;\n\nint main(void)\n{\n\n    int i=0;\n    alarm(1);   //定时1秒,14)SIGALRM  终止进程\n   \n    while(1)\n    {\n        ++i;\n        //cout&lt;&lt;i&lt;&lt;endl;\n        printf(\"%d\\n\",i);   //printf比cout更快一点点\n    }\n\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"201\" src=\"..\\..\\static\\image\\bba8daeaac3b49ad91d0627d8edb86c5.png\" width=\"271\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n\nusing namespace std;\n\nint main(void)\n{\n\n    int i=0;\n    int fd = open(\"./a.txt\",O_RDWR|O_CREAT,0777);\n    dup2(fd,STDOUT_FILENO);\n    alarm(1);   //定时1秒,14)SIGALRM  终止进程\n   \n    while(1)\n    {\n        ++i;\n        //cout&lt;&lt;i&lt;&lt;endl;\n        printf(\"%d\\n\",i);   //printf比cout更快一点点\n    }\n\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"160\" src=\"..\\..\\static\\image\\680f0b3652374df9ad0291d21099261a.png\" width=\"427\"/></p>\n<p> 大概71倍</p>\n<p></p>\n<p><strong>setitimer函数</strong></p>\n<p><strong>说明：</strong>设置定时器(闹钟)。可替代alarm函数，精度微妙us,可实现周期定时</p>\n<p><strong>原型：</strong>int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value);</p>\n<p><strong>成功返回 0 失败-1，并设置error</strong></p>\n<p><strong>参数：</strong></p>\n<p>        which:指定定时方式</p>\n<p>        1.自然定时：ITIMER_REAL  --&gt;  14)SIGARM</p>\n<p>        2.虚拟空间计时(用户空间):ITIMER_VIRTUAL  --&gt; 26)SIGVTALRM   占用cpu的时间</p>\n<p>        3.运行时间(用户+内存):ITIMER_PROT --&gt; 27)SIGPROF   cpu+系统调用</p>\n<p>        old_value</p>\n<p>        上一次定时的时间</p>\n<p><img alt=\"\" height=\"195\" src=\"..\\..\\static\\image\\54ec76ab7b794a7fa75c7d0dc00930a3.png\" width=\"690\"/><strong>it_interval:两次触发定时器的间隔时间</strong></p>\n<p><strong>it_value:定时器定时的时间</strong></p>\n<p><strong>如果都为0，表示清0</strong></p>\n<p>案例1：</p>\n<p>        使用setitemer函数实现alarm，重复计算1s      </p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/time.h&gt;\n\nusing namespace std;\n\nvoid myalarm(unsigned long sec)\n{\n    itimerval it,oldit;\n\n    it.it_interval.tv_sec = 0;\n    it.it_interval.tv_usec = 0;\n    it.it_value.tv_sec = 1;\n    it.it_value.tv_usec = 0;\n    int ret = setitimer(ITIMER_REAL,&amp;it,&amp;oldit);\n    if(ret == -1)\n    {\n        perror(\"setitimer err\");\n        exit(-1);\n    }\n\n    return;\n}\n\nint main(void)\n{   \n\n    int i;\n    myalarm(1);\n    \n    while(1)\n    {\n        printf(\"%d\\n\",i);\n        ++i;\n    }\n\n    return 0;\n}</code></pre>\n<p>案例2： </p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;signal.h&gt;\n\nvoid func(int signo)\n{\n\n    printf(\"wo shi da sha bi\\n\");\n    //raise(SIGKILL);\n}\n\nint main(void)\n{\n\n    signal(SIGALRM,func);   //信号捕捉,当SIGALRM递达，则执行func\n\n    itimerval it,oldit;\n    it.it_interval.tv_sec = 2;\n    it.it_interval.tv_usec = 0;\n    it.it_value.tv_sec = 1;\n    it.it_value.tv_usec = 0;\n\n    if(setitimer(ITIMER_REAL,&amp;it,&amp;oldit) == -1)\n    {\n        perror(\"setitimer err\");\n        exit(-1);\n    }\n\n    while (1)\n    {\n        /* code */\n    }\n    \n\n    return 0;\n}\n</code></pre>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\">信号集操作函数</h2>\n<blockquote>\n<p>        内核通过读取未决信号集来判断信号是否应该被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。以达到屏蔽指定信号的目的。</p>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"589\" src=\"..\\..\\static\\image\\437430304c2e42f38aadfd5f3b2ba5a3.png\" width=\"1124\"/></h3>\n<p></p>\n<h3 id=\"%E4%BF%A1%E5%8F%B7%E9%9B%86%E8%AE%BE%E5%AE%9A\">信号集设定</h3>\n<p>sigset_t set;                  //unsigned long   (8字节 64bit)</p>\n<p>int sigemptyset(sigset_t * set);                                //将某个信号集清0</p>\n<p>int sigfillset(sigset_t *set);                                        //将某个信号集置1</p>\n<p>int sigaddset(sigset_t *set,int signum);                    //将某个信号加入信号集</p>\n<p>int sigdelset(sigset_t *set,int signum);                      //将某个信号清除信号集</p>\n<p>int sigismember(const sigset_t *set,int signum);       //判断某个信号是否在信号集中</p>\n<h3 id=\"sigprocmask%E5%87%BD%E6%95%B0\"><strong>sigprocmask函数</strong></h3>\n<p>        int sigprocmask(int how,const sigset_t *set,sigset_t *oldset);</p>\n<p>        成功：0  失败：-1，设置error</p>\n<p>        参数：</p>\n<p>              how:假设当前信号屏蔽字为 mask</p>\n<p>                1.SIG_BLOCK：mask = mask | set</p>\n<p>                2.SIG_UNBLOCK: mask = mask | ~set</p>\n<p>                3.SIG_SETMASK: mask = set</p>\n<h3 id=\"sigpending%E5%87%BD%E6%95%B0\">sigpending函数</h3>\n<p>        读取当前进程的未决信号集</p>\n<p>        int sigpending(sigset_t *set);</p>\n<p>        成功：0   失败：-1,设置error</p>\n<p>  </p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid printset(sigset_t *ped)\n{\n    for(int i=1;i&lt;32;++i)\n    {\n        if(sigismember(ped,i) == 1)\n        {\n            putchar('1');\n        }\n        else\n        {\n            putchar('0');\n        }\n    }\n}\n\nint main(void)\n{\n    sigset_t set,ped;\n    sigemptyset(&amp;set);\n\n    sigaddset(&amp;set,SIGINT);\n    sigaddset(&amp;set,SIGQUIT);\n\n    sigfillset(&amp;set);\n    sigprocmask(SIG_BLOCK,&amp;set,NULL);\n\n    while(1)\n    {\n        sigpending(&amp;ped);\n        printset(&amp;ped);\n        sleep(1);\n    }\n\n    return 0;\n}</code></pre>\n<p>  </p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89\">信号捕捉</h2>\n<blockquote>\n<h3 id=\"%C2%A0signal%E5%87%BD%E6%95%B0\"> signal函数</h3>\n<p>注册一个信号捕捉函数</p>\n<p>        typedef void(*sighandler_t)(int);</p>\n<p>        sighandler_t signal(int signum,.sighandler handler);</p>\n<p>handler:</p>\n<p>        SIG_IGN   忽略此信号</p>\n<p>        SIG_DFL   使用信号默认的行为</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n\nusing namespace std;\n\ntypedef void (*sighandler_t)(int);\n\nvoid catchsignal(int signo)\n{\n    cout&lt;&lt;\"aaa\"&lt;&lt;endl;\n}\n\nint main(void)\n{\n\n\n    sighandler_t headler;\n    headler = signal(SIGINT,catchsignal);\n    if(headler == SIG_ERR)\n    {\n        perror(\"dignal err\");\n        exit(-1);\n    }\n\n    while (1)\n    {\n        /* code */\n    }\n    \n\n    return 0;\n}</code></pre>\n<h3 id=\"sigaction%E5%87%BD%E6%95%B0\">sigaction函数</h3>\n<p>       <strong> int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact);</strong></p>\n<p>        成功：0    失败：-1，并设置error</p>\n<p>        act:新的处理方式</p>\n<p>        oldact:传出参数，旧的处理方式</p>\n<p>        <img alt=\"\" height=\"173\" src=\"..\\..\\static\\image\\6c6ad7026a3d4d179768e4d7d1e74a82.png\" width=\"604\"/></p>\n<p>         重要的参数：</p>\n<p>         sa_handler:指定信号捕捉后的处理函数名。(也可以指定SIG_IGN   SIG_DFL)</p>\n<p>         sa_mask:<span style=\"color:#fe2c24;\">调用信号处理函数时</span>，所要屏蔽的信号集合(阻塞信号集)</p>\n<p>         sa_flags:通常设置为0，表示默认属性(对正在处理的信息设置屏蔽)</p>\n<p></p>\n<h3 id=\"%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7\">信号捕捉特性</h3>\n<p>         1.进程正常运行时，默认在PCB中有一个阻塞信号集和未决信号集。对于阻塞信号集，它决定自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到信号以后，要调用该函数。而该函数有可能执行时间很长，在这期间所需要屏蔽的信号由sa_mask来决定。当信号处理完后，又恢复为PCB中的阻塞信号集决定</p>\n<p>        2.xxx信号捕捉函数执行期间，xxx信号自动被屏蔽</p>\n<p>        3.阻塞的常规信号不支持排队，<span style=\"color:#fe2c24;\">产生多次只记录一次</span></p>\n</blockquote>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B\">信号捕捉函数案例</h2>\n<blockquote>\n<p>1.自定义一个信号捕捉函数</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\nusing namespace std;\n\nvoid headler(int signo)\n{\n    cout&lt;&lt;\"我是你大爷...\"&lt;&lt;endl;\n    sleep(2);\n\n    return;\n}\n\nint main(void)\n{\n\n    struct sigaction act;\n    act.sa_handler = headler;\n    act.sa_flags = 0;\n    sigemptyset(&amp;act.sa_mask);\n    sigaddset(&amp;act.sa_mask,SIGQUIT);\n    int ret = sigaction(SIGINT,&amp;act,NULL);\n    if(ret == -1)\n    {\n        perror(\"sigaction err\");\n        exit(-1);\n    }\n\n    while(1)\n    {\n\n    }\n\n\n    return 0;\n}</code></pre>\n<p>2.验证在信号处理函数执行期间,该信号多次递送,那么只在处理函数支行技术和，处理一次</p>\n<pre><code class=\"language-cs\">#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\nusing namespace std;\n\nvoid headler(int signo)\n{\n    cout&lt;&lt;\"我是你大爷...\"&lt;&lt;endl;\n    sleep(2);\n    cout&lt;&lt;\"-----end-------\"&lt;&lt;endl;\n    return;\n}\n\nint main(void)\n{\n\n    struct sigaction act,old;\n    act.sa_handler = headler;\n    act.sa_flags = 0;\n    sigemptyset(&amp;act.sa_mask);\n    sigaction(SIGINT,&amp;act,&amp;old);\n    \n\n    while(1)\n    {\n\n    }\n\n    sigaction(SIGINT,&amp;old,NULL);\n    \n\n    return 0;\n}</code></pre>\n<p>3.验证sa_mask的屏蔽作用</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\nusing namespace std;\n\nvoid headler(int signo)\n{\n    cout&lt;&lt;\"我是你大爷...\"&lt;&lt;endl;\n    sleep(2);\n\n    return;\n}\n\nint main(void)\n{\n\n    struct sigaction act;\n    act.sa_handler = headler;\n    act.sa_flags = 0;\n    sigemptyset(&amp;act.sa_mask);\n    sigaddset(&amp;act.sa_mask,SIGQUIT);\n    int ret = sigaction(SIGINT,&amp;act,NULL);\n    if(ret == -1)\n    {\n        perror(\"sigaction err\");\n        exit(-1);\n    }\n\n    while(1)\n    {\n\n    }\n\n\n    return 0;\n}</code></pre>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E8%BF%87%E7%A8%8B\">内核实现信号捕捉过程</h2>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">信号的产生和处理都是由内核进行的</span></p>\n<p><span style=\"color:#fe2c24;\">频繁的在用户态和内核态进行切换是很浪费时间的</span></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"615\" src=\"..\\..\\static\\image\\062251a1da0948be99181aadbcd9d58e.png\" width=\"642\"/></p>\n</blockquote>\n<h2 id=\"%C2%A0%E6%97%B6%E6%80%81%E7%AB%9E%E4%BA%89\"> 时态竞争</h2>\n<blockquote>\n<p>        当前进程在执行期间，由于竞争的原因，导致程序执行的时序在先后两次的执行中有不同的结果</p>\n<p>        比如A准备睡觉，定了一个闹钟(定时器)，在10s后叫醒他。</p>\n<p>        由于时序可能会有两种情况:</p>\n<p>        正常:10s后A被闹钟叫醒</p>\n<p>        异常:A在5s时被B叫醒，并且A跟着B一起去打牌，打了20s,那么在打牌的期间，</p>\n<p>                闹钟正常响起，但是并没有叫醒A</p>\n<p>        </p>\n<h3 id=\"%C2%A0%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A\"> 时序问题分析：</h3>\n<p>        假设我们想要通过pause和alarm实现sleep：</p>\n<p>        1.注册SIGALARM信号处理函数(sigaction...)</p>\n<p>        2.调用alarm(1)函数设定闹钟为1秒</p>\n<p>        3.函数调用结束，开始计时倒数。正在这时，进程失去CPU(时间片轮转，进程调度算法决定)，该进程处于就绪状态，等待CPU</p>\n<p>        4.但是此时时自然计时，倒数依旧在进行着，如果此时倒数结束，alarm发送信号，信号将递达,但是此时进程处于挂起状态，每一办法通过信号捕捉函数进行处理，所有处于未决状态。</p>\n<p>        5.当进程再次获得CPU，SIGALARM信号递达，执行处理函数函数</p>\n<p>        6.信号处理函数结束，回到主控制程序，执行pause(),进程将会被挂起，等待alarm唤醒，可以再没有人来唤醒他了</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid myheadler(int signo)\n{\n    cout&lt;&lt;\"aa\"&lt;&lt;endl;\n}\n\nint main(void)\n{\n    \n    signal(SIGALARM,myheadler);\n    alarm(1);\n    pause();\n\n    \n    while(1);\n\n    return 0;\n}</code></pre>\n<h3 id=\"%E8%A7%A3%E5%86%B3%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98\">解决时序问题</h3>\n<p>        可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽字”与“挂起等待信号”这个两个操作间隙失去CPU。除非将这两个步骤合成原子操作。sigsuspend可以实现。</p>\n<p>       int sigsuspend(const sigset_t *mask)   挂起等待信号</p>\n<p>       sigsuspend函数调用期间，进程信号屏蔽字由参数mask决定</p>\n<p>       可将某个信号从临时信号屏蔽集种删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，信号屏蔽字恢复原来的值。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid myheadler(int signo)\n{\n    cout&lt;&lt;\"aa\"&lt;&lt;endl;\n}\n\nint main(void)\n{\n    \n    signal(SIGALARM,myheadler);\n    sigset_t mask;\n    sigfillset(&amp;mask);\n    sigdelset(&amp;mask,SIGALARM);\n    alarm(1);\n    sigsuspend(&amp;mask);\n\n\n    \n    while(1);\n\n    return 0;\n}</code></pre>\n<h3 id=\"%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\">时序问题总结</h3>\n<p><span style=\"color:#fe2c24;\">        竞态条件，跟系统负载有很紧密的关系，体现除信号的不可靠性。系统负载越严重，信号不可靠性越强。不可靠由其实现原理所致。信号是通过软件方式实现，每次系统调用结束后或中断处理结束后，需通过扫描PCB中的未决信号集来判断是否应处理某个信号。当系统负载过重时，会出现混乱</span></p>\n</blockquote>\n<h2 id=\"%E5%8F%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%C2%A0\">可不可重入函数 </h2>\n<blockquote>\n<p> 一个函数在被调用执行期间(尚未调用结束)，由于某时序又被重复调用，称之为\"重入\"。</p>\n<p> 1.定义可重入函数，函数内不能包含全局变量集static变量，不能使用malloc、free</p>\n<p> 2.信号捕捉函数应设计为可重入函数</p>\n<p> 3.不可重入的原理：<span style=\"background-color:#ff9900;\">使用静态数据结构    调用了malloc和new (不是栈结构)</span>  是标准I/O</p>\n</blockquote>\n<h2 id=\"SIGCHLD%E4%BF%A1%E5%8F%B7%C2%A0\">SIGCHLD信号 </h2>\n<blockquote>\n<p>        当子进程停止或者结束时，会向父进程发送SIGCHLD信号，该信号默认处理动作是忽略，所有产生僵尸进程。</p>\n<p>        我们之前的程序是，在父进程中调用 wait或者waitpid来回收子进程，此时父进程要么阻塞等待，要么非阻塞而采用轮询的方式。那么将会导致父进程不能做其他工作，只能等着回收子进程。</p>\n<p>        我们可以利用SIGCHLD信号来捕捉，当有SIGCHLD信号产生时，父进程执行信号捕捉函数。</p>\n<p>        我们先来看一段程序：</p>\n<p>        </p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;wait.h&gt;\nusing namespace std;\n\nvoid sigchldHeadler(int signo)\n{\n    pid_t pid;\n    int status;\n    while((pid=waitpid(-1,&amp;status,WNOHANG))&gt;0)\n    {\n        printf(\"回收成功:%d   ok\\n\",pid);\n        if(WIFEXITED(status))\n        {\n            printf(\"退出状态:%d\\n\",WEXITSTATUS(status));\n        }\n        if(WIFSIGNALED(status))\n        {\n            printf(\"退出状态(信号):%d\\n\",WTERMSIG(status));\n        }\n    }\n}\n\nint main(void)\n{\n\n    //创建10个子进程\n    int i;\n    for(i=0;i&lt;10;i++)\n    {\n        pid_t pid = fork();\n        if(pid == 0)\n        {\n            break;\n        }\n    }\n\n    if(i &lt; 10)\n    {\n        printf(\"I am child:%d\\n\",getpid());\n        sleep(1);\n    }\n    else if(i == 10)\n    {      \n        struct sigaction act;\n        act.sa_handler = sigchldHeadler;\n        act.sa_flags = 0;\n        sigemptyset(&amp;act.sa_mask);\n        sigaction(SIGCHLD,&amp;act,NULL);\n\n        while(1)\n        {\n            printf(\"I am parent:%d\\n\",getpid());   \n            sleep(1);\n        }\n    }\n    \n\n    return 0;\n}</code></pre>\n<p>我们来思考几个问题：</p>\n<p>当父进程在执行信号捕捉函数时，又有子进程死亡。或者有多个子进程死亡。我们知道信号集是位图机制，是不支持排队的。</p>\n<p><img alt=\"\" height=\"114\" src=\"..\\..\\static\\image\\9188208e9a6f4833b154584d1af02bfb.png\" width=\"376\"/></p>\n<p>当父进程的信号捕捉函数还没有注册，就已经有子进程结束了。导致僵尸进程...</p>\n<p><img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\1c01f2449838496eb86914f0d86cfade.png\" width=\"357\"/></p>\n<p>或者在fork之前将SIGCHLD信号设置屏蔽</p>\n<p><img alt=\"\" height=\"126\" src=\"..\\..\\static\\image\\5b88207aa11f4c2fafca1924b73bf284.png\" width=\"380\"/></p>\n<p></p>\n<p>完整：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;wait.h&gt;\nusing namespace std;\n\nvoid sigchldHeadler(int signo)\n{\n    pid_t pid;\n    int status;\n    while((pid=waitpid(-1,&amp;status,WNOHANG))&gt;0)\n    {\n        printf(\"回收成功:%d   ok\\n\",pid);\n        if(WIFEXITED(status))\n        {\n            printf(\"退出状态:%d\\n\",WEXITSTATUS(status));\n        }\n        if(WIFSIGNALED(status))\n        {\n            printf(\"退出状态(信号):%d\\n\",WTERMSIG(status));\n        }\n    }\n}\n\nint main(void)\n{\n\n    //设置阻塞\n    sigset_t set;\n    sigemptyset(&amp;set);\n    sigdelset(&amp;set,SIGCHLD);\n    sigprocmask(SIG_BLOCK,&amp;set,NULL);\n    //创建10个子进程\n    int i;\n    for(i=0;i&lt;10;i++)\n    {\n        pid_t pid = fork();\n        if(pid == 0)\n        {\n            break;\n        }\n    }\n\n    if(i &lt; 10)\n    {\n        printf(\"I am child:%d\\n\",getpid());\n        //sleep(1);\n    }\n    else if(i == 10)\n    {      \n        struct sigaction act;\n        act.sa_handler = sigchldHeadler;\n        act.sa_flags = 0;\n        sigemptyset(&amp;act.sa_mask);\n        sigaction(SIGCHLD,&amp;act,NULL);\n\n        while(1)\n        {\n            printf(\"I am parent:%d\\n\",getpid());   \n            sleep(1);\n        }\n    }\n    \n\n    return 0;\n}</code></pre>\n</blockquote>\n<h2 id=\"%C2%A0%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82\"> 信号传参</h2>\n<blockquote>\n<p>前面讲到信号是不能携带大量数据的，一般通过 kill 来发送信号</p>\n<p>但是信号可以携带数据，可以携带少量。</p>\n<p>通过sigqueue函数，可在向指定进程发送信号的同时携带参数</p>\n<p>int sigqueue(pid_t pid,int sig,const union sigval value);</p>\n<p>成功返回0，失败-1，设置error</p>\n<p><strong>注意事项：</strong></p>\n<p><strong>        向指定进程发送指定信号的同时携带数据。不能够传地址，不能进程之间虚拟地址空间各自独立，当前进程地址传递给另一进程没有实际意义</strong></p>\n<p></p>\n<p><strong>捕捉函数：</strong></p>\n<p>        </p>\n<p>  <strong> int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact);</strong></p>\n<p>        成功：0    失败：-1，并设置error</p>\n<p>        act:新的处理方式</p>\n<p>        oldact:传出参数，旧的处理方式</p>\n<p>        <img alt=\"\" height=\"173\" src=\"..\\..\\static\\image\\6c6ad7026a3d4d179768e4d7d1e74a82.png\" width=\"604\"/></p>\n<p>        </p>\n<p>        <strong>不使用sa_handler，而使用sa_sigaction。sa_flags必须指定为SA_SIGINFO</strong></p>\n<p>        </p>\n</blockquote>\n<h2 id=\"%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">中断系统调用</h2>\n<blockquote>\n<p>系统调用分为两类：</p>\n<p>慢速系统调用：可能导致进程永远阻塞，如果在阻塞期收到一个信号，该系统调用就会被断开，不再继续执行，也可以设定系统调用重启(read、write、pause、wait...)</p>\n<p>其他系统调用：getpid，getpid、fork</p>\n<p>sa_flags可以设置为 SA_RESTART</p>\n</blockquote>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-16 19:14:59", "summary": "目录信号的概念信号的共性使用信号的目的信号的机制信号的特质信号的状态信号的处理方式信号集未决信号集和阻塞信号集信号的编号信号要素常规信号说明信号的产生终端按键产生信号硬件异常产生信号函数命令产生信号软"}