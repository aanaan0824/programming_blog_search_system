{"blogid": "125425715", "writerAge": "码龄2年", "writerBlogNum": "10", "writerCollect": "307", "writerComment": "7", "writerFan": "2799", "writerGrade": "2级", "writerIntegral": "143", "writerName": "心如天然薄荷清凉", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125425715.jpg", "writerRankTotal": "82760", "writerRankWeekly": "918", "writerThumb": "36", "writerVisitNum": "17608", "blog_read_count": "17150", "blog_time": "已于 2022-08-11 15:43:57 修改", "blog_title": "2022最全最新前端面试题（附加解答）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 id=\"JS\">JS</h2>\n<p><strong>1、说一下innerHTML 与 innerText的作用与区别？</strong></p>\n<ol><li>作用：都可以获取或者设置元素的内容</li><li>区别：innerHTML可以解析内容中的html标签</li><li>innerText不能解析内容中的html标签</li></ol>\n<p id=\"u7d402570\"><strong>2、JavaScript 由以下三部分组成：</strong></p>\n<ol><li>ECMAScript（语法部分）：JavaScript 语言基础</li><li>DOM（文档对象模型）：规定了访问 HTML 和 XML 的方法</li><li>BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li></ol>\n<p id=\"u5d673571\"><strong>3、介绍 JS 有哪些内置对象？</strong></p>\n<ol><li id=\"u8452961a\">数据封装类对象：Object、Array、Boolean、Number、String</li><li id=\"u395018ce\">其他对象：Function、Arguments、Math、Date、RegExp、Error</li><li id=\"u9ec33247\">ES6 新增对象：Symbol、Map、Set、Promises、Proxy、Reflect</li></ol>\n<p id=\"u29903a4a\"><strong>4、JS 的基本数据类型和引用数据类型</strong></p>\n<ol><li>基本(原始)数据类型: number、string、boolean、undefined, null, symbol</li><li>引用数据类型: Object、Function、Array</li></ol>\n<p id=\"u2fca7613\"><strong>5、说几条写 JavaScript 书写的基本规范？</strong></p>\n<ol><li id=\"ua21e17b5\">代码一定要正确缩进，建议使用\"二个或者四个空格\"缩进</li><li id=\"u1f1b409c\">语句结束使用分号;</li><li id=\"uaaabaf7a\">规范定义 JSON 对象，补全双引号</li><li id=\"u92d26c12\">用{}和[]声明对象和数组</li><li id=\"ua0221bc2\">变量和函数在使用前进行声明</li><li id=\"u6f35b9e4\">以大写字母开头命名构造函数，全大写命名常量</li><li id=\"u52420b18\">代码段使用花括号{}包裹</li><li id=\"u0d277ce0\">还有要书写正确的标识标签</li></ol>\n<p id=\"u0030ceab\"><strong>6、什么是标识符？</strong></p>\n<ul><li>在JS中，可以自定义命名的东西都属性标识符；</li><li>比如变量名，函数名，参数名都是标识符</li></ul>\n<p id=\"u25990350\"><strong>7、DOM 元素e的 e.getAttribute(propName)和 e.propName 有什么区别和联系</strong></p>\n<ol><li>e.getAttribute：获取的是标签上属性</li><li>可以通过e.setAttribute(propName, propValue)设置标签上属性</li><li>e.propName：获取的是元素对象上属性</li></ol>\n<p id=\"u03f20dcc\"><strong>8、offsetWidth/offsetHeight,clientWidth/clientHeight,scrollWidth/scrollHeight 的区别?</strong></p>\n<ol><li>offsetWidth/offsetHeight 返回值包含 content + padding + border + 包含滚动条，效果与 e.getBoundingClientRect()相同</li><li>clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条</li><li>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸</li></ol>\n<p id=\"u227c3a30\"><strong>9、检测浏览器版本版本有哪些方式？</strong></p>\n<ol><li>根据 navigator.userAgent // UA.toLowerCase().indexOf('chrome')</li></ol>\n<p id=\"u312f4b4a\"><strong>10、说一下元素节点、文本节点、属性节点的nodeType、nodeName、nodeValue分别是什么</strong></p>\n<ol><li>nodeType(节点类型)  nodeName(节点名称)  nodeValue(节点的值)</li><li>元素节点：      1                元素标签名          null(没有值)</li><li>属性节点：      2                属性名              属性值</li><li>文本节点：      3                text                节点内容</li></ol>\n<p id=\"u679bd260\"><strong>11、</strong><code><strong>==</strong></code><strong>和</strong><code><strong>===</strong></code><strong>的区别</strong></p>\n<ol><li>双等号判断时，只需要值相等</li><li>三等号判断时，需要值与类型都相等</li></ol>\n<p><strong>12、函数声明与函数表达式的区别？</strong></p>\n<ol><li>数声明就是直接通过function进行声明函数，例如：function show(){}可以在声明函数之前调用0函</li></ol>\n<p><strong>13、数组方法pop() push() unshift() shift()</strong></p>\n<ol><li>pop()尾部删除</li><li>push()尾部添加</li><li>unshift()头部添加</li><li>shift()头部删除</li></ol>\n<p></p>\n<p><strong>14、ajax请求的时候get 和post方式的区别</strong></p>\n<p>（1）get请求</p>\n<p>参数要跟在url后面<br/> 安全性不高<br/> 传输数据比较小，但速度快<br/> 一般用于获取，删除</p>\n<p id=\"u55023a57\"></p>\n<p>（2）post请求</p>\n<p id=\"u93b99a2e\">参数会放在请求体中，<br/> 安全性相对高些<br/> 传输数据大，但相对速度慢些<br/> post一般用于修改或者添加</p>\n<p></p>\n<p><strong>15、解释什么是Json:</strong></p>\n<ol><li>json是一种轻量级的数据交换格式，一般用于数据传递</li><li>里边只允许出现双引号</li><li>JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null), 数组，对象</li></ol>\n<p></p>\n<p></p>\n<p><strong>16、dom事件委托什么原理，有什么优缺点</strong><br/> 事件委托原理: 事件冒泡机制（把子元素的事件行为 委托给 父级元素执行优点）</p>\n<p id=\"u05835c6c\">优点:<br/> 1. 可以大量节省内存占用，减少事件注册<br/> 2. 可以实现当新增子对象时，无需再对其进行事件绑定</p>\n<p id=\"u985a6487\">缺点:<br/> 如果把所有事件都用事件代理，可能会出现事件误判</p>\n<p></p>\n<p><strong>17、Javascript的事件流模型都有什么?</strong></p>\n<ol><li>“事件冒泡”：事件逐级向上传播</li><li>“事件捕捉”：事件逐级向下传播，一直到最具体的</li><li>“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</li></ol>\n<p><strong>18、split() join() 的区别</strong></p>\n<ol><li>split()：以指定的字符分割字符串返回一个数组,字符串方法</li><li>join(): 以指定的字符连接数组中元素返回一个字符串,数组方法</li></ol>\n<p></p>\n<p><strong>19、如何阻止事件冒泡</strong></p>\n<ol><li>ev.stopPropagation();</li></ol>\n<p><strong>20、如何阻止默认事件</strong></p>\n<ul><li>答案：return false 或者 ev.prevent Default();</li></ul>\n<p></p>\n<p><strong>21、JavaScript中如何检测一个变量是一个 String 类型?</strong></p>\n<ol><li>typeof 变量</li><li>变量.constructor === String</li><li>Object.prototype.toString.call(变量)    // 推荐使用</li></ol>\n<p id=\"uf553033f\"><strong>22、javascript 的 typeof 返回哪些数据类型（至少六个）检测类型如下：</strong></p>\n<ol><li>string、   number、  boolean  、undefined 、object  、function   、symbol（ES6之后新增的类型）</li></ol>\n<p></p>\n<p><strong>23、如何判断变量为NaN</strong></p>\n<ul><li>通过isNaN()判断</li><li>isNaN(NaN)     // 返回true</li><li>isNaN(1000)    // 返回false</li><li>isNaN('小明')  // 返回true（判断前会转换成number类型）</li><li>isNaN('101')   // 返回false</li></ul>\n<p id=\"ucc1d9c81\"></p>\n<p><strong>24、什么是JS变量提升 与 块级作用域</strong></p>\n<ul><li><strong>变量提升</strong>：就是会把变量定义提升到当前作用域的最上面</li><li><strong>块级作用域</strong>：JS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ES6中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。在外边不能调用块作用域里边定义的变量</li></ul>\n<p></p>\n<p id=\"u6f45e27c\"><strong>25、null / undefined 的区别</strong></p>\n<ul><li><strong>null值：</strong>属于null类型,代表“空值\"，代表一个空对象指针；使用typeof运算得到 “object\"，所以你可以认为它是一个特殊的对象值。</li><li><strong>undefined值：</strong>属于undefined类型，当一个声明的变量未初始化赋值时，得到的就是undefined。使用typeof运算得到“undefined\"，</li></ul>\n<p></p>\n<p id=\"u2df04099\"><strong>26、foo = foo || bar，这行代码是什么意思？为什么要这样写？</strong></p>\n<ul><li>如果foo转为false, 则返回bar；否则直接返回foo</li><li>逻辑或：如果第一个值为true，直接返回第一个值；否则直接返回第二个值</li><li>逻辑与：如果第一个值为false，直接返回第一个值；否则返回第二个值、</li></ul>\n<p id=\"u2c4be52b\"></p>\n<p id=\"u371b3c13\"><strong>27、target 和 currentTarget 区别</strong></p>\n<ul><li>都是事件对象上的属性</li><li>event.target：返回触发事件的元素</li><li>event.currentTarget：返回绑定事件的元素(相当于事件中this)</li></ul>\n<p id=\"u00135335\"></p>\n<p id=\"u11b6241e\"><strong>28、prototype 和 proto 的关系是什么</strong></p>\n<ul><li><strong>prototype</strong>: 所有函数都会有一个prototype属性, 它就是函数的原型对象</li><li><strong>proto</strong>: 所有实例对象上都会有一个<strong>proto</strong>属性, 它等同于函数的原型对象</li></ul>\n<blockquote>\n<p>(补充说明)<br/> 原型链：因为所有实例对象都原型对象，原型对象也个对象，<br/> 所以它也自己原型对象(这样形成原型链)</p>\n</blockquote>\n<p><br/> 答案：</p>\n<ul><li>所有的对象都拥有<strong>proto</strong>属性，它指向对象构造函数的 prototype 属性</li><li>所有的函数都同时拥有<strong>proto</strong>和 prototype 属性</li><li>函数的<strong>proto</strong>指向自己的函数实现 函数的 protytpe 是一个对象(原型)</li><li>所以函数的 prototype 也有<strong>proto</strong>属性 指向 Object.prototype</li><li>Object.prototype.<strong>proto</strong>指向 null</li></ul>\n<p id=\"u7a09b523\"></p>\n<p id=\"u30e4a7cf\"><strong>29、请说一下你常用的数组方法(至少七个)</strong><br/> 答案：</p>\n<ul><li><strong>1）Array.push()</strong>：此方法是在数组的后面添加新加元素，此方法改变了数组的长度：</li><li><strong>2）Array.pop()</strong>：此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：</li><li><strong>3） Array.shift()</strong>：此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：</li><li><strong>4） Array.unshift()</strong>：此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：</li><li><strong>5）Array.isArray()</strong>：判断一个对象是不是数组，返回的是布尔值</li><li><strong>6）</strong> <strong>Array.concat()</strong>：此方法是一个可以将多个数组拼接成一个数组：</li><li><strong>7）Array.toString()</strong> ： 把数组作为字符串返回</li><li><strong>8） Array.join()  </strong>     ：以指定字符拼接成字符串，然后返回</li></ul>\n<ul><li><strong>9） Array.splice：</strong>(开始位置， 删除的个数，元素)</li><li><strong>10）Array.map()</strong>：此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组</li><li><strong>11）Array.forEach()</strong>：此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和 map 方法区分</li><li><strong>12）Array.filter()</strong>：此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回</li><li><strong>13）Array.every()</strong>：此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回 true，否则为 false：</li><li><strong>14）Array.some()</strong>：此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回 true，若所有元素都不满足判断条件，则返回 false：</li><li><strong>15）Array.reduce()</strong>：此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：</li></ul>\n<blockquote>\n<p id=\"ude1cce01\"><strong>与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作</strong></p>\n</blockquote>\n<p id=\"u8519b63b\"></p>\n<p id=\"uaa2e0ed8\"><strong>30、请说一下你常用的字符串方法（至少七个）</strong></p>\n<ul><li id=\"u7eb5f060\"><strong>trim(): </strong>去首尾空格</li><li id=\"u73c0c092\"><strong>split(sep，limit)：</strong>将字符串分割为字符数组，limit 为从头开始执行分割的最大数量</li><li id=\"u3dfe9646\"><strong>indexOf(str):</strong>返回 str 在父串中第一次出现的位置，若没有则返回-1</li><li id=\"uebdab103\"><strong>lastIndexOf(str):</strong>返回 str 在父串中最后一次出现的位置，若没有则返回-1</li><li id=\"u864ba1f1\"><strong>substr(start，length)：</strong>从字符索引 start 的位置开始，返回长度为 length 的子串</li><li id=\"u4853e857\"><strong>substring(from,to)：</strong>返回字符索引在 from 和 to（不含）之间的子串</li><li id=\"u62b1e45f\"><strong>slice(start,end)：</strong>返回字符索引在 start 和 end（不含）之间的子串</li><li id=\"u8b09110c\"><strong>toLowerCase()：</strong>将字符串转换为小写</li><li id=\"ue1d16bae\"><strong>toUpperCase()：</strong>将字符串转换为大写</li><li id=\"uab9a5dde\"><strong>replace(str1,str2):</strong>str1 也可以为正则表达式，用 str2 替换 str1</li><li id=\"u15bd6f6a\"><strong>concat(str1,str2,...):</strong>连接多个字符串，返回连接后的字符串的副本</li><li id=\"u407ae713\"><strong>match(regex):</strong>搜索字符串，并返回正则表达式的所有匹配</li><li id=\"ufcf1475e\"><strong>charAt(index):</strong>返回指定索引处的字符串</li><li id=\"ubef9b732\"><strong>charCodeAt(index):</strong>返回指定索引处的字符的 Unicode 的值</li><li id=\"ucc687dfe\"><strong>fromCharCode():</strong>将 Unicode 值转换成实际的字符串</li><li id=\"uac143cdb\"><strong>search(regex):</strong>基于正则表达式搜索字符串，并返回第一个匹配的位置</li><li id=\"uf183a8e6\"><strong>valueOf()：</strong>返回原始字符串值</li></ul>\n<p id=\"u06c07a8f\"></p>\n<p id=\"u2594185f\"><strong>31、原型和原型链</strong></p>\n<ul><li><strong>原型：</strong>portoType这个属性就是函数的原型</li><li><strong>原型链：</strong>1.所有对象都有原型，而原型本身就是对象，所以原型也有自己的原型对象，就形成原型链</li><li>如果对象本身没有属性，则就会去原型链上去找</li><li>Object原型对象的原型值为null</li></ul>\n<p></p>\n<p></p>\n<p id=\"u75272b74\"><strong>32、new操作符具体做了什么？</strong></p>\n<ol><li id=\"u6a2175aa\">在内存创建一个新对象</li><li id=\"u16f8db39\">把构造函数中this指向新建的对象</li><li id=\"ue359560f\">会在新对象上添加一个__proto__属性,指向函数的原型对象prototype</li><li id=\"udcde04e3\">判断函数返回值,如果值是引用类型就直接返回值；否则返回this(创建的新对象)</li></ol>\n<p id=\"u5a53ec02\"></p>\n<p id=\"ufed74e51\"><strong>33、说下什么是IIFE函数</strong></p>\n<ul><li id=\"u98a83264\">IIFE(立即调用函数表达式)是一个在定义时就会立即执行的函数。</li></ul>\n<p id=\"u822c9f0e\"></p>\n<p id=\"u5ee6c53e\"><strong>34、浅拷贝与深拷贝有何区别？如何实现？</strong></p>\n<ul><li id=\"u2a1daf01\"><strong>浅拷贝：</strong>拷贝的是原对象的内存地址</li><li id=\"u8165d645\"><strong>深拷贝：</strong>在内存中把原对象复制一份</li><li id=\"u3d753fbf\"><strong>浅拷贝的实现方式有：</strong></li></ul>\n<p>        （1）直接变量赋值</p>\n<p>        （2）Object.assign()；但目标对象只有一层的时候，是深拷贝；</p>\n<p id=\"u031e8e12\">        （3）扩展运算符(...)；目标对象只有一层的时候，是深拷贝；</p>\n<p></p>\n<blockquote>\n<p id=\"uc3a37341\">深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。</p>\n</blockquote>\n<ul><li id=\"u0e25bdd7\"><strong>深拷贝的实现方式有：</strong></li></ul>\n<p id=\"uae8962cb\">        （1）结合使用JSON.parse()和JSON.stringify()方法。</p>\n<p id=\"u24b12ec3\">        （2）手写遍历递归赋值；</p>\n<p id=\"uc4e7dd3a\"></p>\n<p id=\"u39713ea7\"><strong>35、字符串截取方法substr、 substring、 slice三者的区别</strong></p>\n<ul><li id=\"uf40b71a0\">substr(n,m)：截取的是字符串中索引为n开始的，并且截取m位</li><li id=\"u16c9a6a4\">substring(n,m)：从索引为n的位置开始截取，截取到索引为m的位置但是不包含索引为m这一项</li><li id=\"u0bc047fb\">slice(n,m)：和substring一样，但是他可以支持负数索引</li></ul>\n<p id=\"uf0960aaa\"></p>\n<p id=\"u8802740b\"><strong>36、函数柯里化</strong></p>\n<p id=\"ubace3b22\"><strong>        概念</strong>：把一个接收多个参数的函数变成接收单一参数 并且返回能够接收新参数的函数；比如：</p>\n<pre><code>add(1)(2)(3)(4) = 10;\n\nfunction add(num){\n\n    var sum=num;\n\n    var fn=function(v){\n\n        sum+=v;\n\n        return fn\n\n    };\n\n    fn.toString=function(){\n\n        return sum\n\n    };\n\n    return fn\n\n}\n\nconsole.log(add(1)(2)(3)(4)) // 10</code></pre>\n<p id=\"u8245db18\"></p>\n<p id=\"ue731df40\"></p>\n<p id=\"u0ecca6b0\"><strong>37、判断Array类型的几种方式0</strong></p>\n<pre><code>1、[ ] instanceof Array\n\n2、[ ].constructor === Array\n\n3、Object.prototype.toString.call([]) === '[object Array]'\n\n4、Array.isArray([])</code></pre>\n<p id=\"uc1c359b3\"></p>\n<p id=\"u65270e00\"><strong>38.this指向的各种情况都有什么？</strong></p>\n<ol><li id=\"u7f2b8d61\">全局作用域中的函数：非严格模式下其内部this指向window</li><li id=\"ua699aeb5\">对象内部的函数：其内部this指向对象本身：</li><li id=\"ue5c54c9f\">构造函数：其内部this指向生成的实例：</li><li id=\"u677f102f\">由apply、call、bind改造的函数：其this指向第一个参数：</li><li id=\"uee7bb870\">箭头函数：箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。(函数定义时的this，而不是调用时this)</li></ol>\n<p id=\"u772858fc\"></p>\n<p id=\"u34fcaacb\"><strong>39.什么是AJAX？如何实现？</strong></p>\n<ul><li id=\"u28d6e6e7\">ajax是一种能够实现网页局部刷新的技术，可以使网页异步刷新。</li><li id=\"u9400f886\">ajax的实现主要包括四个步骤：</li></ul>\n<p id=\"uf7183b5d\">        （1）创建核心对象XMLhttpRequest；</p>\n<p id=\"ub61fdb65\">        （2）利用open方法打开与服务器的连接；</p>\n<p id=\"u72c6c5f1\">        （3）利用send方法发送请求；（\"POST\"请求时，还需额外设置请求头）</p>\n<p id=\"ub03f0790\">        （4）监听服务器响应，接收返回值。</p>\n<p id=\"udb772d98\"></p>\n<p id=\"u05d15508\"><strong>40.什么是高阶函数？</strong></p>\n<ul><li id=\"u46affbbf\">高阶函数是对其他函数进行操作的函数;</li><li id=\"u33137819\">高阶函数就是一个接收函数作为参数或将函数作为输出返回的函数。</li></ul>\n<ol><li id=\"u455a63dc\">例如，Array.prototype.map，Array.prototype.filter 和Array.prototype.reduce 是语言中内置的一些高阶函数。</li></ol>\n<p></p>\n<p></p>\n<p id=\"u5571535f\"><strong>41、描述浏览器的渲染过程？，DOM树和渲染树的区别？</strong></p>\n<ul><li>浏览器的渲染过程：</li></ul>\n<ol><li id=\"ubdb8c15e\">解析 HTML 构建 DOM(DOM树)，并行请求 css/image/js</li><li id=\"u204e74f2\">CSS 文件下载完成，开始构建 CSSOM(CSS树)</li><li id=\"uac714035\">CSSOM 构建结束后 和 DOM 一起生成 Render Tree(渲染树)</li><li id=\"u6762c0c1\">布局(Layout)：计算出每个节点在屏幕中的位置</li><li id=\"u1647c751\">显示(Painting)：通过显卡把页面画到屏幕上</li></ol>\n<ul><li id=\"ub57b9054\">DOM 树 和 渲染树 的区别：</li></ul>\n<ol><li id=\"ufdc05ac6\">DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素</li><li id=\"u235374b5\">渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性</li></ol>\n<p id=\"u8245803b\"></p>\n<p id=\"u7d2752da\"><strong>42、Javascript 如何实现继承？</strong></p>\n<ul><li>实例继承：将子构造函数的 prototype 指向父构造函数的一个实例</li><li>原型继承：将子构造函数的 prototype 指向父构造函数的 prototype</li><li>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li><li>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</li><li>ES6 语法 extends：class ColorPoint extends Point {}</li></ul>\n<p id=\"u38e38745\"></p>\n<p id=\"u31b36606\"><strong>43、Javascript 作用域链?</strong></p>\n<ul><li id=\"ud86526b9\">如果当前作用域没有找到属性或方法，会向上层作用域查找，<br/> 直至全局函数，这种形式就是作用域链</li></ul>\n<p id=\"ubac8120a\"></p>\n<p id=\"u16738d71\"><strong>44、eval是做什么的？</strong><br/> eval 的功能是把对应的字符串解析成 JS 代码并运行</p>\n<ul><li id=\"uc2fbf9c5\">应该避免使用 eval，不安全，非常耗性能（先解析成 js 语句，再执行）</li><li id=\"u07f92348\">由 JSON 字符串转换为 JSON 对象的时候可以用 eval('('+ str +')');</li></ul>\n<p id=\"ud3fc8c9a\"></p>\n<p id=\"uc74b0ed6\"><strong>45、js延迟加载的方式有哪些？</strong><br/> 动态创建 DOM 方式（用得最多）、defer 和 async标签属性</p>\n<p id=\"u0a1f4542\"></p>\n<p id=\"u579a0bf6\"><strong>46、defer 和 async区别 </strong></p>\n<ul><li>defer 并行加载 js 文件，会按照页面上 script 标签的顺序执行</li><li>async 并行加载 js 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行</li></ul>\n<p id=\"u2e615de5\"></p>\n<p id=\"u29e48329\"><strong>47、同步和异步的区别?</strong></p>\n<ul><li id=\"uec699b71\">同步: 下面代码会等待上面 同步代码执行完毕</li><li id=\"uc2318dc6\">异步: 下面代码不会等待上面异步代码执行完毕</li><li id=\"u640dc371\">同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，<br/> 新内容出现，用户看到新内容,进行下一步操作</li><li id=\"u4bfe2e4f\">异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。<br/> 等请求完，页面不刷新，新内容也会出现，用户看到新内容</li></ul>\n<p id=\"ua53301a0\"></p>\n<p id=\"u958c47c1\"><strong>48、documen.write 和 innerHTML 的区别</strong></p>\n<ul><li id=\"uc973deaa\">document.write 只能重绘整个页面</li><li id=\"u00a79cc7\">innerHTML 可以重绘页面的某一部分</li></ul>\n<p id=\"u01c24ff2\"></p>\n<p id=\"u17c5ea02\"><strong>49、说说你对闭包的理解</strong><br/> 闭包有三个特性：</p>\n<ul><li id=\"u916372e9\">函数嵌套函数</li><li id=\"u72f67f28\">函数内部可以引用外部的参数和变量</li><li id=\"u5f8b8ec6\">参数和变量不会被垃圾回收机制回收,会永远留驻在内存中</li></ul>\n<blockquote>\n<p id=\"u43618b2e\">使用闭包主要是为了设计私有的方法和变量。<br/> 优点：是可以避免全局变量的污染，</p>\n<p id=\"uc6dce8da\">缺点：是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>\n</blockquote>\n<p id=\"ufa20cc94\"></p>\n<p id=\"u45d4abe0\"><strong>50、 把 </strong><code><strong>&lt;script&gt;</strong></code><strong> 放在 </strong><code><strong>&lt;/body&gt;</strong></code><strong> 之前和之后有什么区别？</strong></p>\n<ul><li>浏览器会如何解析它们？</li><li>按照HTML标准，在结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签都是解析错</li><li>虽然不符合 HTML 标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li><li>浏览器的容错机制会忽略<code>&lt;script&gt;</code>之前的，视作<code>&lt;script&gt;</code>仍在 body 体内。</li></ul>\n<p id=\"u36ff635c\"></p>\n<p id=\"uf6d288b1\"><strong>51、 为什么 JS 是单线程,  而不是多线程 [常考]</strong></p>\n<ul><li id=\"ue83e5a42\">单线程是指 JavaScript 在执行的时候，有且只有一个主线程来处理所有的任务。</li><li id=\"u5096f0ec\">目的是为了实现与浏览器交互。</li><li id=\"u0ea6831a\">我们设想一下，如果 JavaScript 是多线程的，现在我们在浏览器中同时操作一个<br/> DOM，一个线程要求浏览器在这个 DOM 中添加节点，<br/> 而另一个线程却要求浏览器删掉这个 DOM 节点，<br/> 那这个时候浏览器就会很郁闷，他不知道应该以哪个线程为准。<br/> 所以为了避免此类现象的发生，降低复杂度，JavaScript<br/> 选择只用一个主线程来执行代码，以此来保证程序执行的一致性。</li></ul>\n<p></p>\n<p></p>\n<p id=\"u31571684\"><strong>52、请说出以下结果输出什么？为什么？</strong><br/>  </p>\n<pre><code>for(var i = 0; i &lt; 5; i++) {\n    setTimeout(function(){\n        console.log(i)\n    }, 0)\n}</code></pre>\n<blockquote>\n<p id=\"u31571684\">答案：5个5<br/> 解释：异步代码需要等同步代码先执行，所以当异步定时器执行时，<br/> 同步的for循环已经循环完毕</p>\n</blockquote>\n<p id=\"u489f09be\"></p>\n<p id=\"ub67bac94\"><strong>53、请说出以下flag的结果？为什么？</strong></p>\n<pre><code>function show(){}\n\nfunction getName() { return '牛夫人' }\n\nvar flag = show() || getName()</code></pre>\n<blockquote>\n<p id=\"ub67bac94\">答案：flag值为'牛夫人'<br/> 解释：1.函数都会有一个默认的返回值undefined<br/> 2.逻辑或如果第一个值成立就直接返回第一个值，否则直接返回第二个值</p>\n</blockquote>\n<p id=\"uad93338c\"></p>\n<p id=\"ue9b98127\"><strong>54、请解释一下什么是重排与重绘？</strong></p>\n<ul><li><strong>重排：</strong>当改变dom结构的时候，就会从dom树开始从新渲染页面，这过程叫重排比如添加或者删除可见的DOM元素、元素尺寸改变、元素内容改变、浏览器窗口尺寸改变等等</li><li id=\"ue186436b\"><strong>重绘：</strong>当改变样式（不改变几何结构）的时候，它会从render树开始重新开始渲染页面，这过程叫重绘，比如改变颜色，透明等</li></ul>\n<p id=\"u55bc3510\"><strong>55、怎么减少重排与重绘？</strong></p>\n<ul><li id=\"u41c7582f\">尽量避免操作DOM元素</li><li id=\"u615dcd15\">避免多次修改dom结构或者css,集中处理，只引发一次重绘或者重排</li></ul>\n<p id=\"ub9c57105\"></p>\n<p id=\"ude42bf08\"><strong>56、请解释一下什么是防抖与节流</strong></p>\n<ul><li><strong>防抖（debounce）</strong></li></ul>\n<ol><li>总结：就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</li></ol>\n<ul><li id=\"u5216fba1\"><strong>节流（throttle）</strong></li></ul>\n<ol><li id=\"u65f219c9\">总结：就是每次触发事件的隔间至少要大于等于n秒，不会重置计时</li></ol>\n<p id=\"u85fe9856\"></p>\n<p id=\"u5e75294f\"><strong>57、说一下call、apply、bind三者的作用 与 区别</strong></p>\n<ul><li><strong>作用：</strong>三者的作用都是可以改变函数的this指向(function对象自带的方法)</li><li><strong>区别：</strong>1.call、apply会直接调用原函数，bind不会直接调用函数，而会拷贝一份返回一个新函数</li><li>call、bind传参时一个个传入，而apply是把所有参数放到一个数组中传入</li></ul>\n<p id=\"u7025022d\"></p>\n<p id=\"u3803bb74\"><strong>58、JS严格模式的使用与作用</strong><br/><strong>答案：</strong>在代码前面使用\"use strict\"就可以开启严格模式;</p>\n<p id=\"u5c0988ad\"><strong>作用：</strong></p>\n<ul><li id=\"u8f469cc1\">消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li id=\"u521c0058\">消除代码运行的一些不安全之处，保证代码运行的安全；</li><li id=\"ue3087772\">提高编译器效率，增加运行速度；</li><li id=\"u98b0c65d\">为未来新版本的 Javascript 做好铺垫。</li></ul>\n<p id=\"ueefdd62e\"></p>\n<p id=\"u3ce75e37\"><strong>59、举例JS严格模式的特点</strong></p>\n<ul><li id=\"ueeac5c96\">变量必须要通过修饰符进行声明</li><li id=\"ufc8d1801\">函数的参数不能有同名属性，否则报错</li><li id=\"u45c05f0d\">禁止 this 指向全局对象</li><li id=\"u779fb753\">增加了保留字（比如 protected 、 static 和 interface ）</li><li id=\"uccb3caac\">不能删除变量 delete prop</li></ul>\n<p id=\"ub8a00bdd\"></p>\n<p id=\"uc7a612f0\"><strong>60、执行下面代码打印什么？为什么？</strong><br/>  </p>\n<pre><code>var a = {};\nvar b = {key: 'b'};\nvar c = {key: 'c'};\nvar d = [3,5,6];\na[b] = 123;\na[c] = 345;\na[d] = 333;\nconsole.log(a[b]);  \nconsole.log(a[c]);  \nconsole.log(a[d]);  </code></pre>\n<blockquote>\n<p id=\"uc7a612f0\">console.log(a[b]);  // 打印：345<br/> console.log(a[c]);  // 打印：345<br/> console.log(a[d]);  // 打印：333<br/> 为什么：对象转化字符串会变成一个'[object Object]'</p>\n</blockquote>\n<p id=\"uffb29b13\"></p>\n<p><strong>61、JS中的Array.prototype.splice()和Array.prototype.slice()方法作用与区别</strong></p>\n<ul><li>两都的作用都是截取数组中元素，返回一个新数组</li></ul>\n<ol><li>splice(): 第一个参数为下标，第二个参数为截取个数，并且会影响原数组</li><li>slice()：第一个参数为起始下标，第二个参数为结束下标，不会影响原数组</li></ol>\n<p></p>\n<p id=\"ucb5c8397\"><strong>63、下方js执行后的打印值为？</strong></p>\n<pre><code>function demo() {\n    this.length = 10;\n    var fn = function() {\n        console.log(this.length);     // 输出多少？\n    }\n    arr = [fn, 'hello layui'];\n    fn.length = 100;\n    arr0;\n}\n\nwindow.demo()</code></pre>\n<blockquote>\n<p id=\"ued8cca45\"> console.log(this.length)------打印结果为2</p>\n</blockquote>\n<p id=\"u8a65a5c7\"><strong>64、事件绑定的三种方式</strong></p>\n<ol><li>在标签上直接设置事件  onclik=\"a()\"</li><li id=\"ube93c84b\">dom.onclick = function(){}</li><li id=\"u98313163\">addEventListener('click',function(){},true)</li></ol>\n<p id=\"u1403cb07\"></p>\n<p id=\"u8463af4f\"></p>\n<p id=\"u18e5b18e\"><strong>65、事件绑定和普通事件有什么区别？</strong></p>\n<ul><li>普通事件会覆盖掉，只执行后者方法</li></ul>\n<ol><li>dom.onclick = function(){}</li></ol>\n<p id=\"uc4112f04\"></p>\n<ul><li>事件绑定不会覆盖掉，会依次执行</li></ul>\n<ol><li id=\"u1e686857\">addEventListener('click',function(){},true)</li></ol>\n<p id=\"u926ee860\"></p>\n<p id=\"u26fb82b3\"><strong>66、渐进增强与优雅降级</strong></p>\n<ul><li><strong>渐进增强：</strong>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。</li><li id=\"u46689a7e\"><strong>优雅降级：</strong>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul>\n<p id=\"ufc28a74d\"></p>\n<p id=\"u07495c99\"><strong>67、浏览器对象有哪些</strong></p>\n<ul><li>navigator：含有正在使用的Navigator的名称、版本属性，</li><li>window：最高等级的对象，拥有整个窗口的属性;</li><li>document：包含基于文档内容的属性</li><li>location：含有基于当前的URL的属性。</li><li>history：包含客户机先前已经请求过的URL。</li></ul>\n<p id=\"udeb0a0ff\"></p>\n<p id=\"u56f3cccf\"><strong>68、列举3种强制类型转换(显示类型转换)   和   2种隐式类型转换</strong></p>\n<ul><li>强制类型转换</li></ul>\n<ol><li>Number('1235')</li><li>parseInt('1235')</li><li>parseFloat('1235')</li></ol>\n<ul><li>隐式类型转换</li></ul>\n<ol><li>'10' - 0</li><li id=\"u359f9dc8\">'10' * 0</li></ol>\n<p id=\"u05f1672b\"></p>\n<p id=\"ub044409f\"><strong>69、for in 和 for of</strong><br/> 答案：<br/>  (1)、for in</p>\n<ul><li id=\"u74be11de\">1.一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性</li><li id=\"u9dfdf23e\">2.不建议使用 for in 遍历数组，因为输出的顺序是不固定的。</li><li id=\"uccf1c4a8\">3.如果迭代的对象的变量值是 null 或者 undefined,<br/> for in 不执行循环体，建议在使用 for in 循环之前，<br/> 先检查该对象的值是不是 null 或者 undefined</li></ul>\n<p id=\"u5d2180d1\"></p>\n<p id=\"ub923759c\">(2)、for of</p>\n<ul><li id=\"u9363858d\">for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）<br/> 上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</li></ul>\n<p></p>\n<p></p>\n<p id=\"u50d84158\"><strong>70、回答以下代码，alert的值分别是多少？</strong></p>\n<pre><code>&lt;script&gt;\n    var a = 100;\n\n    function test(){\n      alert(a); //输出为100\n      a = 10;   \n      alert(a); //输出为10 \n    }\n    test();\n\n    alert(a);   //输出为10\n&lt;/script&gt;</code></pre>\n<blockquote>\n<p id=\"u912d99ee\">通过var(let、const)定义声明变量，如果var则就仅仅只给变量赋值</p>\n</blockquote>\n<p id=\"uc9049623\"></p>\n<p id=\"u5fe4066b\"><strong>71、form中的input可以设置为readonly和disabled，请问2者有什么区别？</strong></p>\n<ul><li id=\"u27cd1fb0\">readonly不可编辑，但可以选择和复制；值可以传递到后台</li><li id=\"u05bf3320\">disabled不能编辑，不能复制，不能选择；值不可以传递到后台</li></ul>\n<p id=\"ua7419f6b\"></p>\n<p id=\"u63f0ef72\"><strong>72、怎么降维数组 [[1,2],[3,4]] --&gt; [1, 2, 3, 4] </strong></p>\n<ol><li id=\"uf7c0df4c\">使用递归循环，把所有元素放到一个新数组</li><li id=\"u7273029d\">Array.prototype.concat.apply([],[[1,2],[3,4]]);</li></ol>\n<p id=\"u334306c1\"></p>\n<p id=\"ueebd0703\"><strong>73、请说出三种减低页面加载时间的方法</strong></p>\n<ul><li id=\"ud16aa765\">压缩css、js文件</li><li id=\"u3ad84a13\">合并js、css文件，减少http请求(精灵图)</li><li id=\"u63e97861\">外部js、css文件放在最底下</li><li id=\"u6ef2aa66\">减少dom操作，尽可能用变量替代不必要的dom操作</li></ul>\n<p id=\"uad5902d2\"></p>\n<p id=\"uc19f8d36\"><strong>74、基本数据类型和引用数据类型有什么区别？</strong></p>\n<p id=\"u2250bb74\">（1）<strong>变量直接赋值时：</strong></p>\n<p id=\"udffc46f6\">        基本数据类型赋值的是数据的副本，原数据的更改不会影响传入后的数据。</p>\n<p id=\"u9119ad90\">        引用数据类型赋值的是数据的引用地址，原数据的更改会影响传入后的数据。</p>\n<p id=\"ub8973176\">（2）<strong>两者在内存中的存储位置：</strong></p>\n<p id=\"u87ea57ab\">        基本数据类型存储在栈中。</p>\n<p id=\"ua48de40c\">        引用数据类型在栈中存储了指针，该指针指向的数据实体存储在堆中。</p>\n<p id=\"u0b042bdd\"></p>\n<p id=\"ud4f1dce0\"><strong>75、如何改变this指针的指向？</strong></p>\n<p id=\"u9a520907\">可以使用apply、call、bind方法改变this指向(并不会改变函数的作用域)。比较如下：</p>\n<p id=\"u288e368a\">（1）三者第一个参数都是this要指向的对象，也就是想指定的上下文，上下文就是指调用函数的那个对象(没有就指向全局window)；</p>\n<p id=\"uc2adec2d\">（2）apply第二个参数都是数组，call和bind接收多个参数并用逗号隔开；</p>\n<p id=\"uc3e7c5f2\">（3）apply和call只对原函数做改动，bind会返回新的函数(要生效还得再调用一次)。</p>\n<p id=\"u923d38b3\"></p>\n<p id=\"u653dda32\"><strong>76、document load事件 和 document ready事件 的区别</strong></p>\n<p id=\"u54dc3acc\">页面加载完成有两种事件</p>\n<p id=\"u69cf18a4\">1）load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数</p>\n<blockquote>\n<p id=\"u78488dfb\">问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响</p>\n</blockquote>\n<p id=\"ub5332d20\">2）$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行</p>\n<blockquote>\n<p id=\"u4fb24092\">在原生的jS中不包括ready()这个方法，只有load方法就是onload事件</p>\n</blockquote>\n<p id=\"u5d1aca14\"></p>\n<p id=\"u3be824fa\"><strong>77、JS中有哪些不同类型的弹出框可用</strong></p>\n<ul><li id=\"u7304fc58\">在JS中有三种类型的弹出框可用，分别是：</li></ul>\n<ol><li id=\"ue1a02de3\">Alert</li><li id=\"ufe3a7a54\">Confirm</li><li id=\"ue3074a41\">Prompt</li></ol>\n<p></p>\n<p id=\"u4278e86d\"><strong>78、线程与进程的区别</strong></p>\n<ul><li id=\"uefb2cf81\">一个程序至少有一个进程, 一个进程至少有一个线程。</li><li id=\"u3fcb1f8d\">线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li id=\"uc5365c17\">另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li id=\"u3f412340\">线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，</li><li id=\"u2e7784f6\">由应用程序提供多个线程执行控制。</li><li id=\"ub203d798\">从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul>\n<p id=\"ue1b81e18\"></p>\n<p id=\"ua25581d7\"><strong>79、什么是回调</strong></p>\n<ul><li id=\"u1f0422b0\">回调函数是作为参数或选项传递给某个方法的普通JS函数。</li><li id=\"ue894bafa\">它是一个函数，在另一个函数完成调用后执行，因此称为回调。</li></ul>\n<p id=\"u80f079da\"></p>\n<p id=\"u252fcf6d\"><strong>80、如何使用 JS 删除 cookie</strong></p>\n<ul><li id=\"u928c7d71\">如果要删除cookie以便后续尝试读取cookie，则只需将过期日期设置为过去的时间。</li><li id=\"u0b7441ed\">咱们应该定义cookie路径以确保删除正确的cookie。</li><li id=\"uf763274c\">如果未指定路径，某些浏览器将不允许咱们删除cookie</li></ul>\n<p id=\"u8236fe85\"></p>\n<p id=\"ucdc8dff0\"><strong>81、2+5+'3'的结果是什么</strong></p>\n<blockquote>\n<p id=\"ue0f720df\">答案：'73'</p>\n<p id=\"u9f416374\">由于2和5是整数，它们将以数字形式相加。因为3是一个字符串，它将与 7 拼接，结果是73。</p>\n</blockquote>\n<p id=\"u3be650e6\"></p>\n<p id=\"u32c8121c\"><strong>82、如何在JS中清空数组</strong></p>\n<pre><code>\n1、arrayList = []\n\n\n2、arrayList.length = 0;\n\n\n3、arrayList.splice(0, arrayList.length);\n\n\n4、 while(arrayList.length){\n\n        arrayList.pop();\n\n    }</code></pre>\n<p id=\"u36e6693c\"></p>\n<p id=\"u1dc96bab\"><strong>83、innerHTML 和 innerText 的共同点与区别</strong></p>\n<ul><li id=\"u247c1912\"><strong>共同点：</strong>获取或者设置元素的内容</li><li id=\"u78bdc515\"><strong>区别：</strong></li></ul>\n<ol><li>innerHTML可以解析内容中html标签</li><li id=\"u6e6b7ade\">innerText不可以解析内容中html标签</li></ol>\n<p id=\"ue423bcb6\"></p>\n<p id=\"u04d87dab\"><strong>84、请选择结果为真的表达式：（C）</strong></p>\n<p id=\"u49fcb776\">A.null instanceof Object</p>\n<p id=\"u3f919c32\">B.null === undefined</p>\n<p id=\"u53359590\">C.null == undefined+</p>\n<p id=\"ud0970c24\">D.NaN == NaN</p>\n<p id=\"uc80eb38e\"></p>\n<p></p>\n<p></p>\n<p id=\"u69e5af15\"><strong>86、原生JS中如何从一个页面 跳转 到另一个页面</strong></p>\n<ul><li id=\"ue9b628d5\">跳转到其它页面（会产生历史记录）</li></ul>\n<p id=\"ued509b9f\">        location.href = '路径'</p>\n<p id=\"uc0c53d2f\"></p>\n<ul><li id=\"ud36a253e\">跳转且替换页面（不会产生历史记录）</li></ul>\n<p id=\"ua4a607e3\">        location.replace('路径')</p>\n<p id=\"u063df302\"></p>\n<p id=\"u46c7db54\"><strong>87、在JS中编码与解码URL</strong></p>\n<ul><li id=\"uccdd6959\">.encodeURI() 可以对字符串编码</li><li id=\"u90623f12\">.decodeURI() 可以对字符串解码</li></ul>\n<p id=\"u6c8d73ed\"></p>\n<p id=\"u9e198e6e\"><strong>88、callee 与 call 与 caller的区别:</strong></p>\n<ul><li id=\"ua248ff8a\">callee是arguments上面的属性，表示当前正在执行的函数</li><li id=\"uda63a795\">call改变函数调用时里边this的指向</li><li id=\"u80bba693\">caller是函数上的一个属性,它指向当前函数外一层函数，没有外一层函数，则为null</li></ul>\n<p id=\"ud4139977\"></p>\n<p id=\"u3b13f78c\"><strong>89、什么是jsonp</strong></p>\n<ul><li id=\"u29a377db\">jsonp是一种解决跨域请求问题的技术</li><li id=\"u4d5fe751\">不足点：它只能是get请求</li></ul>\n<h1 id=\"TxCI2\"></h1>\n<p id=\"u8585faa5\"><strong>90、[1, 2, 3].map(Math.pow)的结果是什么?</strong></p>\n<p id=\"u8c50b457\">请说出代码的运行结果，为什么？</p>\n<p id=\"u17259416\"></p>\n<blockquote>\n<p>结果时 129</p>\n<p id=\"u4a2fbfd4\">map()会根据提供提供的函数对指定序列(列表)做映射。</p>\n<p id=\"u8c09a6a6\">pow()方法返回 x的y次方的值。<br/><br/> map(function(当前元素的值value,下标index));</p>\n</blockquote>\n<p></p>\n<p id=\"u4f3cc2a8\"><strong>91、toString() 与 valueOf()的区别</strong></p>\n<ol><li id=\"u757fa49e\">toString() 方法返回一个表示该对象的字符串。</li><li id=\"u2d2c49ab\">valueOf() 方法返回指定对象的原始值, 如果对象没有原始值，则valueOf将返回对象本身</li></ol>\n<p></p>\n<p id=\"u2608e30e\"><strong>92、怎么自定义一个dom事件，并且编程式触发它？</strong></p>\n<ul><li>通过new Event('事件名')创建一个事件对象</li><li>给指定元素绑定事件</li><li>document.dispatchEvent(事件对象)来触发事件</li></ul>\n<p>示例</p>\n<pre><code>const ev = new Event('abc');\n\ndocument.addEventListener('abc', function (e) {\n\n    console.log('abc事件触发了。。。。。。')\n\n})\n\ndocument.dispatchEvent(ev)</code></pre>\n<h2></h2>\n<h2></h2>\n<p id=\"u096f8b96\"><strong>93、continue 与 break的区别</strong></p>\n<ul><li>continue：跳过本次循环，直接进入下一次循环</li><li>break：直接终止循环</li></ul>\n<p id=\"ufbe1e986\"></p>\n<p id=\"uc0a18978\"><strong>94、简述一下你对 HTML 语义化标签的理解？</strong></p>\n<blockquote>\n<p>① 用正确的标签做正确的事情。<br/> ② html语义化让页面的 内容结构化，结构更清晰，<br/> 便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，<br/> 并且是容易阅读的;<br/> ③ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于SEO;<br/> ④ 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>\n</blockquote>\n<p id=\"u24d30977\"></p>\n<p id=\"u25bd8e6b\"><strong>95、图片img标签title与alt属性的区别</strong></p>\n<ul><li>title属性：光标移入要显示图片文字</li><li>alt属性：当图片加载失败时要显示的文字</li></ul>\n<p id=\"ud9cfcb43\"></p>\n<p id=\"u3115f2fb\"><strong>96、HTML5 的 form 如何关闭自动完成功能？</strong></p>\n<blockquote>\n<p>答案：将不想要自动完成的<code>form</code>或<code>input</code>设置为<code>autocomplete=off</code></p>\n</blockquote>\n<p id=\"u6ed2ef3a\"><strong>97、简述一下 src 与 href 的区别。</strong></p>\n<blockquote>\n<p>答案：src 用于引用资源，替换当前元素；<br/> href 用于在当前文档和引用资源之间确立联系。</p>\n</blockquote>\n<pre><code>解析：\n●  href \nhref 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，\n是在当前元素和引用资源之间建立联系，在加载它的时候，\n不会停止对当前文档的处理，\n浏览器会继续往下走\n\n若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，\n就会并行下载资源并且不会停止对当前文档的处理。\n这也是为什么建议使link方式加载 CSS，而不是使用 @import  方式。  \n●  src \nsrc 表示引用资源，替换当前元素，用在 img，script，iframe 上，\nsrc 是页面内容不可缺少的一部分。\n\n当浏览器解析到 src ，会暂停其他资源的下载和处理\n（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，\n图片和框架等也如此，类似于将所指向资源应用到当前内容。\n这也是为什么建议把 js 脚本放在底部而不是头部的原因。 </code></pre>\n<p id=\"u23066dac\"><strong>98、对 WEB 标准以及 W3C 的理解与认识</strong></p>\n<blockquote>\n<ol><li>标签闭合、标签小写、不乱嵌套</li><li>使用外链css 和 js脚本、结构行为表现的分离、文件下载与页面速度更快</li><li>W3C标准使网站容易维护、有利于搜索引擎查找</li></ol>\n</blockquote>\n<p></p>\n<p id=\"u0347407c\"><strong>99、Label的作用是什么？是怎么用的？</strong></p>\n<blockquote>\n<p>答案：label 标签来定义表单控制间的关系,**当用户选择该标签时，<br/> 浏览器会自动将焦点转到和标签相关的表单控件上**。</p>\n<p id=\"uab302f6e\">两种用法：一种是 id 绑定，一种是嵌套;</p>\n</blockquote>\n<pre><code>示例：  \n&lt;label for=\"pwd\"&gt;用户名：&lt;/label&gt;\n\n&lt;input id=\"pwd\" type=\"checkbox\"&gt;</code></pre>\n<p></p>\n<p><strong>100、每个 HTML 文件头里都有个很重要的东西，Doctype，知道这是干什么的么？</strong></p>\n<blockquote>\n<p>&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前。</p>\n</blockquote>\n<ul><li>告知浏览器文档使用哪种 HTML 或 XHTML 规范。</li><li>告诉浏览器按照何种规范解析页（如果你的页面没有 DOCTYPE 的声明，那么 compatMode 默认就是 BackCompat,浏览器按照自己的方式解析渲染页面）</li></ul>\n<blockquote>\n<p>解析：<br/> doctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。<br/> 浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 doctype 来区分这两种模式，doctype 在 html<br/> 中的作用就是触发浏览器的标准模式，如果 html 中省略了 doctype，浏览器就会进入到 Quirks 模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而 html 标准和 dom 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 html 开头使用 doctype。</p>\n</blockquote>\n<blockquote>\n<ul><li>自己总结一下：</li></ul>\n<ol><li>doctype是一种标准通用标记语言的文档类型声明;</li><li>doctype在 html中的作用就是触发浏览器的标准模式,否则为怪异模式;</li><li>不同浏览器在怪异模式下会有一些不同的表现，不建议使用怪异模式;</li><li>doctype一定需要写html上面才会生效;</li></ol>\n</blockquote>\n<p></p>\n<p>-----------------------------------------------------------6月27--------------------------------------------------------------</p>\n<p></p>\n<p id=\"u9c79e692\"><strong>101、为什么最好把 CSS 的</strong><code><strong>&lt;link&gt;</strong></code><strong>标签放在</strong><code><strong>&lt;head&gt;&lt;/head&gt;</strong></code><strong>之间？</strong><br/><strong>为什么最好把 JS 的</strong><code><strong>&lt;script&gt;</strong></code><strong>标签恰好放在</strong><code><strong>&lt;/body&gt;</strong></code><strong>之前，有例外情况吗？</strong></p>\n<ul><li id=\"u6a96cc68\">CSS 的<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>:</li></ul>\n<ol><li id=\"uc56975e9\">内容规范</li><li id=\"ude41b05a\">让页面逐步呈现,提高用户体验感</li><li id=\"u299975e2\">防止呈现给用户空白的页面或没有样式的内容</li></ol>\n<ul><li id=\"u76236117\">JS 的<code>&lt;script&gt;</code>标签恰好放在<code>&lt;/body&gt;</code>之前 :</li></ul>\n<ol><li id=\"u1c3d1cb9\">规范;</li><li id=\"u49dba603\">把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户;</li></ol>\n<blockquote>\n<p>解析：<br/> 1).把&lt;link&gt;放在&lt;head&gt;中:<br/> 把&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间是规范要求的内容。<br/> 此外，这种做法可以让页面逐步呈现，提高了用户体验。<br/> 将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）<br/> 不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，<br/> 重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。</p>\n<p>2).把&lt;script&gt;标签恰好放在&lt;/body&gt;之前:<br/> 脚本在下载和执行期间会阻止 HTML 解析。<br/> 把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。<br/> 例外情况是当你的脚本里包含document.write()时。但是现在，<br/> document.write()不推荐使用。同时，将&lt;script&gt;标签放在底部，<br/> 意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。<br/> 也许，对此比较好的做法是，&lt;script&gt;使用defer属性，放在&lt;head&gt;中。</p>\n</blockquote>\n<p id=\"ua88ca27d\"><strong>102、title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</strong></p>\n<ul><li>title：表示文档窗口标题</li><li>h1：内容标题</li><li>b：粗体</li><li id=\"u31013a2f\">strong：粗体（strong会表示强调）(语义化)</li><li>i：斜体</li><li id=\"u594627e3\">em：斜体（em会表示强调，强调比strong弱）(语义化)</li></ul>\n<p></p>\n<p id=\"udb5b962a\"><strong>103、CSS 隐藏元素的几种方法（至少说出三种）</strong></p>\n<ul><li id=\"u19159885\">Opacity: 0 ----设置透明度来隐藏元素</li><li id=\"u8209c485\">visibility:hidden; --- 隐藏对应的元素并且挤占该元素原来的空间。</li><li id=\"uc049a04c\">display:none; ----隐藏对应的元素但不挤占该元素原来的空间。</li><li id=\"u62e02a0d\">position:absolute; top:-9999px; ---让该元素脱离文档流移出视觉区域.</li></ul>\n<p></p>\n<p id=\"u1cb4d2bc\"><strong>104、页面导入样式时，使用 link 和 </strong><a href=\"/import\"><strong>@import </strong></a><strong> 有什么区别？</strong><br/> 答案：</p>\n<p id=\"u09a9c7e3\"><strong>相同点 :</strong> link 和 <a href=\"/import\">@import </a> 都是用于引入外部css样式文件</p>\n<p id=\"u3471bf55\">区别:</p>\n<ul><li id=\"u9a25fb9c\">link:</li></ul>\n<ol><li id=\"u67c3d62e\">html标签</li><li id=\"u48a88722\">与页面一起加载</li><li id=\"u7368877d\">权重比@import大</li><li id=\"ucfc370c2\">由于是html标签,不存在浏览器兼容性问题</li></ol>\n<p id=\"u8bdadd85\"></p>\n<ul><li id=\"u5a50663d\">@import:</li></ul>\n<ol><li id=\"u1c2b1363\">css语法</li><li id=\"ud97b5e48\">需要等页面加载完成后才会加载引用的 CSS</li><li id=\"u3fa734f6\">@import 只有在 ie5 以上才可以被识别</li><li id=\"u7289e72c\">权重比link小</li></ol>\n<p id=\"uc84328ca\"></p>\n<p id=\"u3115b67c\"><strong>105、rgba()和 opacity 的透明效果有什么不同？</strong><br/> 答案：</p>\n<ul><li><strong>相同点 : </strong>rgba()和 opacity 都能实现透明效果，</li><li><strong>不同点 :</strong> 但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）</li></ul>\n<p></p>\n<p id=\"u099b3ffd\"><strong>106、display:none 与 visibility:hidden 的区别是什么？</strong></p>\n<p id=\"ud07a0db1\">答案：<br/><strong>display : </strong> 隐藏对应的元素但不挤占该元素原来的空间。<br/><strong>visibility:  </strong>隐藏对应的元素并且挤占该元素原来的空间。</p>\n<blockquote>\n<p>即是，使用 CSS display:none 属性后，HTML 元素（对象）的宽度、高度等各种属性值都将“丢失”;<br/> 而使用 visibility:hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），<br/> 而它所占据的空间位置仍然存在。</p>\n</blockquote>\n<p id=\"uc974dda6\"><strong>107、哪些 css 属性可以继承？</strong><br/> 答案：</p>\n<ul><li>可继承：text-align、font、color、line-height、letter-spacing、word-spacing、text-indent</li><li>不可继承 ：border padding margin width height ;</li></ul>\n<p id=\"ue455d2ff\"></p>\n<p id=\"u89899e60\"><strong>108、精灵图和 base64 如何选择？</strong></p>\n<p id=\"u6afb023b\"><strong>精灵图:</strong></p>\n<ul><li id=\"u53bcbfaa\">优点:</li></ul>\n<ol><li id=\"u05b83aa3\">将多个图像加载请求合并为一个请求;</li></ol>\n<p id=\"ud4c67c7d\"></p>\n<ul><li id=\"u89d45d0b\">弊端:</li></ul>\n<ol><li id=\"u9ac66e24\">难以维护和更新;</li><li id=\"u3735ca54\">增加内存消耗;</li></ol>\n<p id=\"u7c9491ef\"></p>\n<p id=\"uc66ea72f\"><strong>base64</strong>:</p>\n<ul><li id=\"uf8fceae8\">优点:</li></ul>\n<ol><li id=\"u55f53ea1\">将多个图像加载请求合并为一个CSS文件请求;</li><li id=\"uafcc5445\">轻松更新生成文件;</li></ol>\n<p id=\"u80d026c8\"></p>\n<ul><li id=\"u0d59ee33\">弊端:</li></ul>\n<ol><li id=\"u4596fcf8\">base64编码比原始二进制表示大约大25%;</li><li id=\"u139b1f67\">IE6或IE7不支持;</li></ol>\n<p></p>\n<p id=\"u98f65a63\"><strong>109、请说一下你用过的浏览器存储，并说出它们的区别?</strong></p>\n<ul><li id=\"uead3fd90\">sessionStorage</li><li id=\"u73034978\">localStorage</li><li id=\"u45482077\">cookie</li></ul>\n<p id=\"u2bf966dc\"></p>\n<blockquote>\n<p id=\"u40cb7eae\">相同点 : 三者都是在浏览器本地存放数据;</p>\n</blockquote>\n<ul><li id=\"ud6e5a0e3\">区别 :</li></ul>\n<ol><li id=\"ua00555e3\">sessionStorage：数据只存在于会话期间</li><li id=\"u6c9955cb\">localStorage：数据永久存储</li><li id=\"u2347b848\">cookie：数据默认会话结束时过期，但可以设置过期时间，在请求服务端，浏览器会默认把cookie数据发送给服务器，cookie能存放的数据相对较小</li></ol>\n<p></p>\n<p id=\"u2c9afd60\"><strong>110、请说一个pushState与replaceState两个方法的作用与区别</strong></p>\n<blockquote>\n<p id=\"uecded6c2\">作用 : 都是改变路由(路径)的，路径改变时不会请求服务器（除非你f5刷新）</p>\n</blockquote>\n<ul><li id=\"u9bb14ecc\">区别：</li></ul>\n<ol><li id=\"u4814c852\">pushState：不会替换掉之前的历史路径</li><li id=\"ucf82b13c\">replaceState：会替换掉之前的历史路径</li></ol>\n<p>------------------------------------------------------------6.28---------------------------------------------------------------</p>\n<p></p>\n<p id=\"ud309e495\"><strong>111、请解析一下数组map、filter, reduce三个方法的作用</strong></p>\n<ul><li id=\"u04e7f90e\">map()方法：把回调函数中返回的值，作为一个新数组返回</li><li id=\"udd9e8b84\">filter()方法：返回符合回调函数中条件的元素，形成一个新数组</li><li id=\"u284ee642\">reduce()方法：对数组中元素进行从左到右的累计，并返回最终结果</li></ul>\n<p id=\"u446668eb\"></p>\n<p id=\"ue40c99af\"><strong>112、怎么样删除一个对象的属性</strong></p>\n<ul><li id=\"udc201b4d\">delete 对象.属性名</li></ul>\n<p id=\"ucbb2ed5a\"></p>\n<p id=\"ub100e114\"><strong>113、请说一下深拷贝与浅拷贝的区别</strong></p>\n<ul><li id=\"u42c04e1a\">浅拷贝：只把对象的内存地址，赋值给新变量</li><li id=\"u8cacbb4b\">深拷贝：而是整个对象在堆空间中，复制一份，返回一个新地址给变量</li></ul>\n<p></p>\n<p id=\"u00fee3c7\"><strong>114、如何对一个数组进行去重？</strong></p>\n<pre><code>方式一：\nvar arr01 = [2,3,4,2,2,2,3];\nvar arr02 = [];\nfor(var i = 0; i &lt; arr01.length; i++){\n  if( arr02.indexOf(arr01[i]) === -1 ){\n    arr02.push(  arr01[i]  )\n  }\n}\n\n\n方式二(set去重)：\nvar arr01 = [2,5,2,2,5,7];\nvar set = new Set(arr01)</code></pre>\n<p></p>\n<p id=\"u458757f0\"><strong>115、如果对一个数组进行排序，不能少于2种?</strong></p>\n<pre><code>方法一：\nvar arr = [4,7,2,10,5,9]\nfor(var i = 0; i &lt; arr.length - 1; i++){\n  for(var j = 0; j &lt; arr.length - 1 - i; j++){\n    if(arr[j] &gt; arr[j+1]){\n      var tem = arr[j]\n      arr[j] = arr[j+1]\n      arr[j+1] = tem\n    }\n  }\n}\n\n\n方式二：\narr.sort(function(n1, n2){\n  return n1 - n2\n})</code></pre>\n<p id=\"u86cc1806\"><strong>116、在JS中如何把一个伪数组 转换成一个 真正的数组？</strong></p>\n<pre><code>方式一:\nArray.from(伪数组)\n\n方式二:\nvar arr = [];\nfor(var i = 0; i &lt; 伪数组.length; i++){\n  arr.push(伪数组元素)\n}</code></pre>\n<p></p>\n<p id=\"ub582bce9\"><strong>117、请说一下CSS样式的优先级问题</strong></p>\n<ol><li id=\"u8571f8b2\">ID选择器 id&gt; 类选择器 class&gt; 标签选择器</li><li id=\"u1a94bdc5\">行类样式 &gt; 内部样式 与 外部样式； 后声明的样式 &gt; 先声明的样式</li></ol>\n<p id=\"ud6360251\"></p>\n<p id=\"u8cc4a563\"><strong>118、如果实现一个超链接下载功能</strong></p>\n<ul><li id=\"ub84e158f\">添加download属性</li></ul>\n<p id=\"u71017eb1\"></p>\n<p id=\"u572f0ae4\"><strong>119、一次完整的HTTP事务是怎样的一个过程？</strong></p>\n<ol><li id=\"u4074a186\">域名解析</li><li id=\"uef69c069\">发起TCP的3次握手</li><li id=\"u00bd3795\">建立TCP链接后发起http请求</li><li id=\"u07751958\">服务器端响应http请求，浏览器得到html代码</li><li id=\"u3fe20213\">浏览器解析html代码，并请求html代码中的资源</li><li id=\"ud6a6e63f\">浏览器对页面进行渲染呈现给用户</li></ol>\n<p id=\"u81a042f6\"></p>\n<p id=\"uf1c8f5a8\"><strong>120、怎么把一个对象存储到浏览器本地中</strong></p>\n<p id=\"u5fd979b6\">答案 : 利用sessionStorage或者localStorage把对象存到浏览器中;</p>\n<blockquote>\n<p id=\"ud87c2ec4\">( 但是在存储之前需要把对象变成JSON格式的字符串，获取数据时再解析</p>\n<p id=\"u733da8a2\">利用JSON.stringify()与JSON.parse()两个方法)</p>\n</blockquote>\n<p id=\"u2140f1ad\"><strong>121、json和jsonp的区别?</strong></p>\n<ul><li id=\"u084d1081\">json是一种数据格式，一般用于数据交互;</li><li id=\"u484f4b7c\">jsonp是一种解决跨域请求技术，只能是get请求;</li></ul>\n<p></p>\n<p id=\"u29af84b9\"><strong>122、jsonp的实现原理</strong></p>\n<ul><li>利用script请求并且执行服务端响应的代码；</li><li>执行代码调用页面中的函数，且把代码中数据传入</li></ul>\n<p id=\"ucd20a399\"></p>\n<p id=\"ub5666132\"><strong>123、jsonp是否为ajax请求，为什么？</strong></p>\n<ul><li>不是正真ajax请求</li><li>jsonp是通过script标签发的请求，并没有XMLHttpRequest对象</li></ul>\n<p id=\"u2058ac67\"><strong>124、字符串翻转</strong></p>\n<blockquote>\n<p>'abcde' -&gt; 'edcba'<br/> console.log(str1.split('').reverse().join('')) </p>\n<p>//切割数组  reverse()(反转数组中元素的位置)  切位字符串  </p>\n</blockquote>\n<p id=\"u983205eb\"><strong>125、for循环 与 forEach循环的区别?</strong></p>\n<ol><li>for循环中可以使用break、continue不用使用return 因为它有循环体，且不是函数;</li><li>forEach循环不能使用break、continue，可以return，因为它执行的是函数;</li></ol>\n<p id=\"ub5f469af\"><strong>126、通过 new 的方式创建对象和通过字面量创建有什么区别？</strong></p>\n<ol><li id=\"u43985940\">字面量创建对象，不会调用 Object 构造函数, 简洁且性能更好;</li><li id=\"ue4799b8b\">new Object() 方式创建对象本质上是方法调用，涉及到在 proto<br/> 链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，<br/> 方法调用结束后，还要释放该堆栈，性能不如字面量的方式</li></ol>\n<p id=\"uf0390cb3\"></p>\n<p id=\"uec588981\"><strong>127、javascript的同源策略（跨域问题）</strong></p>\n<ul><li><strong>跨域是什么：</strong>实际上就是一个网站不能执行其他网站上的网址，是由浏览器同源策略造成的，是浏览器对js施加的安全限制，所谓同源，实际上是指域名，协议，端口都相同，也就是说当，域名或者协议，或者端口不同的时候，就是跨域</li></ul>\n<p id=\"ua97d49b4\"></p>\n<p id=\"udf7cc4c6\"><strong>128、常见的浏览器内核有哪些？</strong></p>\n<ul><li>Trident 内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称 MSHTML]</li><li>Gecko   内核：Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey 等</li><li>Presto  内核：Opera7 及以上。 [Opera 内核原为：Presto，现为：Blink;]</li><li>Webkit  内核：Safari,Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]</li></ul>\n<p id=\"u8665120e\"></p>\n<p id=\"u14574625\"><strong>129、如何实现浏览器内多个标签页之间的数据通信?</strong></p>\n<ul><li>调用 localstorge、cookies 等本地存储方式；</li></ul>\n<blockquote>\n<p id=\"u516d8f67\">注意：sessionstorge不可以哦（它只在本窗口使用）</p>\n</blockquote>\n<p id=\"u39af4e0c\"><strong>130、javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？</strong></p>\n<blockquote>\n<p>use strict 是一种 ECMAscript5 添加的（严格）运行模式,</p>\n</blockquote>\n<p></p>\n<ul><li><strong>区别 ：</strong>这种模式使得 Javascript 在更严格的条件下运行,使 JS 编码更加规范化的模式,消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</li></ul>\n<p></p>\n<p></p>\n<p>-------------------------------------------------------------6.29--------------------------------------------------------------</p>\n<p></p>\n<p></p>\n<p><strong>131、行内元素和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？</strong></p>\n<ul><li id=\"u7ae5be72\">块级元素(block)特性</li></ul>\n<ol><li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;</li><li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</li></ol>\n<ul><li id=\"u7346fb32\">内联元素(inline)特性：</li></ul>\n<ol><li>和相邻的内联元素在同一行;</li><li>宽度(width)、高度(height)不能设置</li><li>可以设置padding，但是上下的padding会上下相邻的元素重叠</li><li>可以设置左右的margin,但是不能设置上下的margin</li></ol>\n<p></p>\n<p><strong>132、那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？</strong></p>\n<p></p>\n<blockquote>\n<p>答案：<code>&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。</code></p>\n</blockquote>\n<p></p>\n<p id=\"udfdd5f0b\"><strong>133、px 和 em 的区别。</strong></p>\n<blockquote>\n<p>px 和 em 都是长度单位</p>\n</blockquote>\n<p><strong>区别：</strong></p>\n<ul><li>px 的值是固定的，指定是多少就是多少，计算比较容易。</li><li id=\"uebff6005\">em 得值不是固定的，并且 em 会继承父级元素的字体大小。</li></ul>\n<blockquote>\n<p id=\"u78f8941a\">浏览器的默认字体高都是 16px。所以未经调整的浏览器都符合: 1em=16px。那么 12px=0.75em, 10px=0.625em。</p>\n</blockquote>\n<p></p>\n<p id=\"uca503da3\"><strong>134、Sass、LESS 是什么？大家为什么要使用他们？</strong></p>\n<ul><li id=\"ud9dd3ea4\">他们是 CSS 预处理器。</li><li id=\"u57d20da4\">他们是 CSS 上的一种抽象层。</li><li id=\"u9dcab779\">他们是一种特殊的语法/语言编译成 CSS。</li></ul>\n<blockquote>\n<p id=\"u87a914ad\">例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。</p>\n</blockquote>\n<p id=\"uc3d09c1a\"></p>\n<ul><li><strong>为什么要使用它们？</strong></li></ul>\n<ol><li>结构清晰，便于扩展。</li><li> 可以轻松实现多重继承与混合</li><li>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li><li> 还提供了一些比较方便的函数，语句等等</li><li id=\"u449f0e0a\">可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。</li></ol>\n<p></p>\n<p></p>\n<p id=\"u4eb69c37\"><strong>135、为什么要初始化CSS样式（CSSReset）</strong><br/> 答案：</p>\n<ul><li id=\"uc8ed8286\">因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，<br/> 如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</li><li id=\"u300be420\">去掉标签的默认样式如：margin,padding，其他浏览器默认解析字体大小，字体设置。</li></ul>\n<p></p>\n<p id=\"u22a90f54\"><strong>136、什么是重写，什么是重载？</strong></p>\n<ul><li id=\"uacadaef3\">重写：子类覆盖掉从父类继承过来的方法</li><li id=\"u8719009c\">重载：有多个同名的方法，但是参数列表不一样</li></ul>\n<blockquote>\n<p id=\"uddbd5eab\">重写就是子类覆盖掉父类的方法</p>\n<p id=\"u2c5c48ce\">重载就是在一个类里面，方法名字相同，而参数不同。</p>\n<p id=\"udc29acaf\">返回类型可以相同也可以不同。</p>\n</blockquote>\n<p><strong>137、一句代码随机打乱数组元素顺序</strong></p>\n<pre><code>let arr = [1,1,2,3,4,6,9,1]\narr.sort( function(n1, n2){ return Math.random() - 0.5 } )</code></pre>\n<p></p>\n<p id=\"uffcb8d99\"><strong>138、什么是web worker，为什么我们需要他们web worker？</strong></p>\n<ul><li id=\"uab4508bc\">什么是web worker :</li></ul>\n<ol><li id=\"u27fbaabf\">web worker是一种开启线程方式;</li></ol>\n<ul><li id=\"uaaadc0a4\">使用Web workers的原因：</li></ul>\n<ol><li id=\"u827d98b4\">通过使用Web Worker， 我们可以在浏览器后台运行Javascript， 而不占用浏览器自身线程（Web work实现多线程）。</li><li id=\"u3fd55d8d\">Web Worker可以提高应用的总体性能，并且提升用户体验。</li></ol>\n<blockquote>\n<p>可以在主线程的下面通过web worker开启一个子线程<br/> 子线程的执行不会阻塞主线程执行<br/> 当我们需要去代码一些高运算的代码时，为了不阻塞主线程，<br/> 这个时则就可以开启一个子线程去做这个事件</p>\n</blockquote>\n<p></p>\n<p id=\"u8b14f62d\"><strong>139、JS中如何将页面重定向到另一个页面？</strong></p>\n<ol><li id=\"u900c904d\">location.replace()</li><li id=\"u9f6fa797\">location.href = 'url'</li></ol>\n<p id=\"ub677e88c\"></p>\n<p id=\"udc421a2e\"><strong>140、解释一下回调函数</strong></p>\n<p id=\"udd29da06\">当我们把一个函数(A)作为一个实参传入给函数(B)时，则这个时候函数A就是一个回调函数</p>\n<p></p>\n<blockquote>\n<p>---------------------------------------------------------6.30-----------------------------------------------------------</p>\n</blockquote>\n<p id=\"uc039a1d5\"><strong>141、jQuery对象与js对象互相转换</strong></p>\n<ul><li id=\"u14d5777b\">jquery对象转成js对象（通过下标转换）</li></ul>\n<p id=\"uf88211b8\">        $(\"div\")[0]</p>\n<p id=\"ud370fff3\"></p>\n<ul><li id=\"ud327477c\">js对象转成jquery对象（只需要对象用$包起来）</li></ul>\n<p id=\"uf5059597\">        $(js对象)</p>\n<p id=\"u0ca45612\"></p>\n<p id=\"u9dac2e6f\"><strong>142、script的位置是否会影响首屏显示时间？</strong></p>\n<p id=\"u5a2a98f4\">在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。</p>\n<p id=\"ufe910424\">因此，script 的位置不影响首屏显示的开始时间。</p>\n<p id=\"ufaba6e37\"></p>\n<p id=\"u2f04342b\">浏览器解析 HTML 是自上而下的线性过程，</p>\n<p id=\"u8f485b1f\">script 作为 HTML 的一部分同样遵循这个原则</p>\n<p id=\"u54c9ed9e\">因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，</p>\n<p></p>\n<p></p>\n<p id=\"u0975e286\"><strong>143、JavaScript 对象生命周期的理解？</strong></p>\n<blockquote>\n<p id=\"ufe6e69b4\">一个东西从创建开始 到 销毁结束这个期间，就叫做生命周期</p>\n</blockquote>\n<p id=\"u3144d333\"></p>\n<p id=\"u6f16703f\"><strong>144、请描述一下var、const、let三者的区别</strong></p>\n<ul><li id=\"u8abc6cca\">var可以变量提升，const、let不会</li><li id=\"uad4d37ae\">var没有块级作用域，const、let存在块级作用域</li><li id=\"ued85b751\">var可以重复定义变量，const、let不能重复定义</li><li id=\"u8d55390f\">var定义的变量会作为window对象的属性，let与const定义的变量不会</li><li id=\"u91faf5d7\">const需要有初始值，并且值不能修改（定义的是常量）</li></ul>\n<p id=\"udd6179e6\"><strong>145、var let 在 for 循环中的区别</strong></p>\n<ul><li id=\"u3a0a94bd\">var不存在块级作用域，所以在for循环时，每次循环var定义变量i的值，都会被后一次循环覆盖;</li><li id=\"u33241d87\">let存在块级作用域，每一次循环都是一个独立的域，let定义变量i的值，就不会被后一次循环覆盖</li></ul>\n<p></p>\n<p id=\"ue335d7b5\"><strong>146、forEach、for in、for of三者区别</strong></p>\n<ol><li>forEach更多的用来遍历数组</li><li>for in 一般常用来遍历对象或json</li><li>for of数组对象都可以遍历，for of不能直接的去遍历对象，因为对象不是一个可迭代数据，遍历对象通过Object.keys()获取到对象的属性名，然后再遍历</li></ol>\n<blockquote>\n<p id=\"u34b15201\">for in循环出的是key，for of循环出的是value（for of循环时没有下标）</p>\n</blockquote>\n<p></p>\n<p id=\"u8461895a\"><strong>147、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</strong></p>\n<ul><li>创建Promise时，传入的回调函数的执行，是同步的</li><li>promise对象上 then函数中的回调执行，是异步的</li></ul>\n<p id=\"u473e9031\"></p>\n<p id=\"u119c5782\"><strong>148、使用箭头函数应注意什么？</strong></p>\n<ol><li>箭头函数的this指向父级函数的this，如果没有父级则指向window</li><li>不能够使用arguments对象</li><li>不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li></ol>\n<p></p>\n<p id=\"u2fcf3eda\"><strong>149、解构赋值过程  及其原理</strong><br/> 答案：</p>\n<ul><li id=\"u794e081e\">解构赋值：其实就是分解出一个对象的解构，分成两个步骤：</li></ul>\n<p id=\"u7983c675\"></p>\n<ul><li id=\"ud548d117\">解构赋值过程:</li></ul>\n<ol><li id=\"u1e05237b\">变量的声明</li><li id=\"ud5fd3784\">变量的赋值</li></ol>\n<blockquote>\n<p id=\"u65e6bee0\">原理：<br/> ES6 变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，<br/> 左边的变量就会被赋予匹配的右边的值，<br/> 如果匹配不成功变量的值就等于 undefined</p>\n</blockquote>\n<p><strong>150、es5和es6的区别，说一下你所知道的es6</strong></p>\n<blockquote>\n<p>ECMAScript5，即ES5，是ECMAScript的第五次修订，于2009年完成标准化ECMAScript6，<br/> 即ES6，是ECMAScript的第六次修订，于2015年完成，也称ES2015ES6是继ES5之后的一次改进，<br/> 相对于ES5更加简洁，提高了开发效率ES6新增的一些特性：</p>\n</blockquote>\n<ol><li>let声明变量和const声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明</li><li>箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()=&gt;来进行定义</li><li>字符串模板字符串是增强版的字符串，用反引号标识，可以当作普通字符串使用，也可以用来定义多行字符串</li><li>解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值</li><li>for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串</li><li>import、export模块化导入导出ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用</li><li>Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数</li><li>展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量</li><li id=\"u1ae8d4ec\">class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念</li><li>async、await使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成</li><li>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大</li><li>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</li><li id=\"u115aaad7\">Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</li></ol>\n<p></p>\n<p>---------------------------------------------------------------7.4--------------------------------------------------------------</p>\n<p><strong>151、理解 async/await 以及对 Generator 的优势</strong></p>\n<blockquote>\n<p><strong>async/await的介绍：</strong><br/> async await 是用来解决异步的，async函数是Generator函数的语法糖<br/> 使用关键字async来表示，在函数内部使用 await 来表示异步<br/> async函数返回一个 Promise 对象，可以使用then方法添加回调函数<br/> 当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，<br/> 再接着执行函数体内后面的语句</p>\n</blockquote>\n<blockquote>\n<p id=\"u259ece6b\"><strong>async较Generator的优势：</strong><br/> （1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，<br/> 调用方式跟普通函数的调用一样<br/> （2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　<br/> （3）返回值是 Promise。async 函数返回的是 Promise 对象，<br/> 比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用</p>\n</blockquote>\n<p id=\"ud2b58f13\"></p>\n<p id=\"ub08b93c9\"><strong>152、promise有哪几种状态，什么时候会进入catch（或者then函数的第二个回调）？</strong></p>\n<ul><li><strong>三个状态：</strong></li></ul>\n<ol><li>pending（初始化）、fulfilled（履行|成功）、reject（拒绝|失败）</li></ol>\n<p id=\"u4d482ecd\"></p>\n<ul><li><strong>两个过程：</strong></li></ul>\n<ol><li>padding -&gt; fulfilled、</li><li>padding -&gt; rejected</li><li id=\"u42379f1b\">当pending为rejectd时，会进入catch</li></ol>\n<p id=\"ub3a0c08e\"></p>\n<ol><li>初始化，状态：pending</li><li>当调用resolve(成功)，状态：pengding=&gt;fulfilled</li><li id=\"u9de4657e\">当调用reject(失败)，状态：pending=&gt;rejected</li></ol>\n<p></p>\n<p id=\"u52590221\"><strong>153、什么时候不使用箭头函数? 说出三个或更多的例子</strong></p>\n<ol><li id=\"ua61cd77a\">使用函数作为构造函数时(箭头函数没有构造函数)</li><li id=\"ua81eeab0\">要在函数中使用 this/arguments 时，由于箭头函数本身不具有<br/> this/arguments，因此它们取决于外部上下文</li><li id=\"ud4846556\">当想要函数被提升时(箭头函数是匿名的)</li><li id=\"ub476aded\">当我们希望函数中的this指向调用这个函数的对象时，也不用箭头函数，<br/> 因为咱们无法保证 this 即对象本身。</li></ol>\n<p id=\"u1ea1433b\"><strong>154、什么是Async/Await?</strong></p>\n<ul><li id=\"u12ff8fc5\">async/await是写异步代码的新方式，以前的方法有回调函数和Promise。</li><li id=\"u9849ad25\">async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</li><li id=\"u8ec8c256\">async/await与Promise一样，是非阻塞(异步)的。</li></ul>\n<p></p>\n<p id=\"ub4c59cf2\"><strong>155、jquery的ajax 和 axios区别</strong></p>\n<ul><li id=\"ud46e0d26\">两者其实并没有太大的区别，在写法上大致相同。</li><li id=\"u2736c6a2\">其实axios是通过 promise 实现对 ajax 技术的一种封装。</li><li id=\"ufce57199\">就像jQuery对原生ajax封装一样。</li></ul>\n<blockquote>\n<p id=\"u8714ba62\">也就是说，jQuery 将请求技术进行了封装 变成了 ajax ,</p>\n<p id=\"uad1f2ab1\">而 通过 promise 把 ajax 进行封装就成了 axios。</p>\n</blockquote>\n<p id=\"uf54c584c\"></p>\n<p id=\"u0c0c4bd9\"><strong>156、箭头函数与普通函数区别？</strong></p>\n<ol><li id=\"u6b689bbb\">写法不一样</li><li id=\"u0e5029ca\">普通函数存在提升的现象</li><li id=\"u9d4c8c1e\">箭头函数不能作为构造函数使用</li><li id=\"u8a282eff\">两者this的指向不同</li><li id=\"u3f24375e\">箭头函数本身没有arguments对象</li><li id=\"u0194a0c7\">箭头函数没有new.target</li></ol>\n<p></p>\n<p id=\"ud0f4a04a\"><strong>157、ECMAScript 6 怎么写 class ，为何会出现 class？</strong></p>\n<p id=\"u231fca9e\"><strong>写法: </strong>直接用class来定义</p>\n<p id=\"u8c4a47b8\">ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，</p>\n<p id=\"u2707abd2\">新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</p>\n<p></p>\n<p></p>\n<p id=\"u55f0dfa3\"><strong>158、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</strong></p>\n<ul><li id=\"u564b5bff\">promise构造函数中回调函数是同步执行的，</li><li id=\"uc9ce028e\">then方法中回调函数是异步执行的</li></ul>\n<p></p>\n<p></p>\n<p id=\"uee5e8ea2\"><strong>159、setTimeout、Promise、Async/Await 的区别</strong></p>\n<ul><li id=\"u7d53aa49\"><strong>宏任务：</strong>全局执行、setTimeout，定时器等等</li><li id=\"u2d6e5b5e\"><strong>微任务：</strong>Promise等</li></ul>\n<ol><li id=\"udb1f5631\">setTimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行;</li><li id=\"u295cd2a8\">Promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行;</li><li id=\"u02d31fa8\">async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式;</li><li id=\"u0a815005\">async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行;</li></ol>\n<p></p>\n<p id=\"u0c0c4bd9\"></p>\n<p id=\"u238d2131\"><strong>160、说出至少5个ES6的新特性，并简述它们的作用。（简答题）</strong></p>\n<ol><li id=\"u487c65f4\">let关键字，用于声明只在块级作用域起作用的变量。</li><li id=\"u2ba78206\">const关键字，用于声明一个常量。</li><li id=\"u63bf83a9\"> 结构赋值，一种新的变量赋值方式。常用于交换变量值，提取函数返回值，设置默认值。</li><li id=\"u28c48d2f\"> Symbol数据类型，定义一个独一无二的值。</li><li id=\"u94051738\"> Proxy代理，用于编写处理函数，来拦截目标对象的操作。</li><li id=\"u6a93ed05\"> for...of遍历，可遍历具有iterator 接口的数据结构。</li><li id=\"u4f7ba9f2\"> Set结构，存储不重复的成员值的集合。</li><li id=\"u83a84d91\"> Map结构，键名可以是任何类型的键值对集合。</li><li id=\"u3c8cfd0a\"> Promise对象，更合理、规范地处理异步操作。</li><li id=\"u58ec09cd\"> Class类定义类和更简便地实现类的继承。</li></ol>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"Vue\">Vue</h2>\n<p id=\"u37a75669\"><strong>1、说一下Jquery与Vue的区别</strong></p>\n<p id=\"u07f5e80a\"><strong>(1)、工作原理</strong></p>\n<ol><li id=\"ub5f5c524\">Vue做到了数据和视图完全分离开，它首先把值和js对象进行绑定，然后修改js对象的值，Vue框架就会自动把dom的值就行更新。对数据进行操作不再需要引用相应的dom对象，他们通过Vue对象实现数据和视图的相互绑定。</li><li id=\"u0fa6467b\">jQuery则是要先使用选择器（$）来选取dom对象，然后对dom对象进行操作（如赋值、取值、事件绑定等）。</li></ol>\n<p id=\"u594cafda\"><strong>(2)、侧重</strong></p>\n<ol><li id=\"u41698f0c\">vue侧重数据绑定，可以应用于复杂数据操作的后台页面。如：表单填写页面</li><li id=\"u7c10ae4c\">jquery侧重样式操作，动画效果等；可以应用于一些html5的动画页面，一些需要js来操作页面样式的页面中。</li></ol>\n<p></p>\n<p id=\"u052fb9ee\"><strong>2、说一下v-model的作用</strong><br/> v-model：</p>\n<p id=\"u0c125ad0\">双向绑定，用于表单元素绑定数据，数据的改变会响应到页面；<br/> 页面表单元素value的改变，同样也会响应到数据</p>\n<p></p>\n<p id=\"u3e649345\"><strong>3、说一下v-on是什么，有什么用？</strong><br/> v-on：绑定事件</p>\n<p id=\"ufa2cd027\"></p>\n<p id=\"ufc0a8f16\"><strong>4、说一下v-bind是什么，有什么用？</strong><br/> v-bind：绑定属性</p>\n<p id=\"ud8d8a134\"></p>\n<p id=\"u309c335c\"><strong>5、说一下Vue中的computed是什么，有什么用？</strong><br/> computed：属性计算</p>\n<p id=\"uc33637a0\">1、依赖其它数据计算生成一个新的数据属性；<br/> 2、当里边依赖的其它数据发生改变，就会重新计算，<br/> 3、当第一次使用计算的新属性时，会初始计算一次，<br/> 并且把值缓存，后面的每次调用都使用缓存值；除非改变了依赖的属性数据</p>\n<p></p>\n<p id=\"u8a72f378\"><strong>6、v-pre的作用</strong></p>\n<p id=\"u147d3364\">可以让元素及元素的子元素不编译解析，这样可以加快vue的解析速度</p>\n<p id=\"u28d6f77d\"></p>\n<p id=\"u9dfcff54\"><strong>7、v-cloak可以解决什么问题</strong></p>\n<p id=\"u43897a52\">v-cloak指令解决vue屏幕闪屏</p>\n<blockquote>\n<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>\n</blockquote>\n<p id=\"u92da529f\"><strong>8、v-once</strong></p>\n<p id=\"ub01707b2\">只渲染元素和组件一次。</p>\n<p id=\"u5a666db9\"></p>\n<p id=\"u948e1eb2\"><strong>9、v-html与v-text区别</strong></p>\n<p id=\"uc8c3ce17\">答案：</p>\n<p id=\"ucd6118c7\">v-html :　可以转义标签和渲染数据</p>\n<p id=\"u5bf7a45b\">v-text：不能转义标签只能渲染数据</p>\n<blockquote>\n<p>v-text展示效果：  &lt;strong&gt;Hello&lt;/strong&gt; Vue!<br/> v-html展示效果： Hello Vue!</p>\n</blockquote>\n<p></p>\n<p id=\"uddb1ed42\"><strong>10、watch是什么，有什么用</strong></p>\n<p id=\"u1b94bda9\">属性监听　</p>\n<blockquote>\n<p id=\"u1befeade\">　作用：当需要一个数据改变,然后去做一些逻辑处理,则可以来使用属性监听</p>\n</blockquote>\n<p id=\"u37feac1c\"></p>\n<p id=\"ub46ebc1d\"><strong>11、$el属性是什么， 有什么用</strong></p>\n<p id=\"u3423df6f\">Vue 实例使用的根 DOM 元素。</p>\n<p id=\"ubfd18c73\">容器</p>\n<p id=\"udc69e89c\"></p>\n<p id=\"ub2e2ca31\"><strong>12、$refs属性是什么，有什么用</strong></p>\n<p id=\"ud1a65ca6\">$refs属性是什么：文档说明该属性是一个对象类型，而且是只读的</p>\n<blockquote>\n<p id=\"ue1c00ac5\">作用：　通过$refs获取的ref属性标识的元素对象</p>\n</blockquote>\n<p></p>\n<p id=\"u6679cc2f\"><strong>13、v-model中有哪些修饰符，分别作用是什么</strong></p>\n<ul><li id=\"ue4580b90\">.lazy - 取代 input 监听 change 事件</li><li id=\"u9c08222f\">.number - 输入字符串转为有效的数字</li><li id=\"u3b241457\">.trim - 输入首尾空格过滤</li></ul>\n<p></p>\n<p id=\"u88eeb5a5\"><strong>14、举例说明vue事件绑定中有哪些修饰符，分别作用是什么</strong></p>\n<ol><li id=\"u238faf26\">stop - 调用 event.stopPropagation()。</li><li id=\"u2b109b27\">prevent - 调用 event.preventDefault()。</li><li id=\"uff6666bd\">capture - 添加事件侦听器时使用 capture 模式。</li><li id=\"ufffdfe93\">self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li id=\"u7d2d5979\">{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li><li id=\"uf657391c\">.native - 监听组件根元素的原生事件。</li><li id=\"u729405d1\">once - 只触发一次回调。</li><li id=\"u8501eb9a\">left - (2.2.0) 只当点击鼠标左键时触发。</li><li id=\"u4c1795eb\">right - (2.2.0) 只当点击鼠标右键时触发。</li><li id=\"ud07a4160\">middle - (2.2.0) 只当点击鼠标中键时触发。</li><li id=\"ub3c8e5da\">passive - (2.3.0) 以 { passive: true } 模式添加侦听器</li></ol>\n<p></p>\n<p id=\"ua0032ad3\"><strong>16、说明你知道的vue生命周期钩子</strong></p>\n<ul><li>页面初始化渲染阶段（只执行一次）</li></ul>\n<ol><li id=\"u9b6df5c4\">beforeCreate</li><li id=\"u1fcab6fa\">created</li><li id=\"u41871105\">beforeMount</li><li id=\"u060b528d\">mounted</li></ol>\n<ul><li id=\"ub484ae3f\">数据更新渲染阶段（多次）数据更新时执行</li></ul>\n<ol><li id=\"u132d443e\">beforeUpdate</li><li id=\"ubf7c8a68\">updated</li></ol>\n<ul><li id=\"u1e0b4ae9\">vue销毁阶段（一次），销毁时执行</li></ul>\n<ol><li id=\"uaffb8840\">beforeDestroy</li><li id=\"uf8d14bb1\">destroyed</li></ol>\n<p></p>\n<p id=\"udfae96a1\"><strong>17、描述一下vue在生命周期的beforeMount阶段时，页面是怎么样的</strong></p>\n<blockquote>\n<p id=\"u7c1494a9\">beforeMount执行时,数据和虚拟DOM树已经都加载完成,但是这时数据没有渲染</p>\n</blockquote>\n<p id=\"u8b857c51\"></p>\n<p id=\"u4f24118e\"><strong>18、描述一下vue在生命周期的mounted阶段时，页面是怎么样的</strong></p>\n<blockquote>\n<p id=\"ue308e98f\">mounted执行时,数据和虚拟DOM树已经都加载完成,也渲染完成</p>\n</blockquote>\n<p></p>\n<p id=\"u01819c9e\"><strong>19、props属性有什么用？</strong></p>\n<blockquote>\n<p id=\"u43363398\">可以用作: 子组件接收父组件传入的数据(接收传入的数据)</p>\n</blockquote>\n<p id=\"u9a04f377\"></p>\n<p id=\"u783f50ec\"><strong>20、$emit()函数有什么用？</strong></p>\n<blockquote>\n<p id=\"u4e8e807f\">$emit('事件名',this.需要传给父组件的数据)</p>\n<p id=\"udd555408\">触发调用自定义事件</p>\n</blockquote>\n<p id=\"u30329f9c\"></p>\n<p id=\"u21fbaf99\"><strong>21、template标签有什么特点？</strong></p>\n<blockquote>\n<p id=\"ua4028f97\">一个字符串模板作为 Vue 实例的标识使用。模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p>\n</blockquote>\n<p id=\"uc43ae9ac\"></p>\n<p id=\"u5d0aa7ad\"><strong>22、keep-alive标签有什么特点？</strong></p>\n<blockquote>\n<p id=\"uc471f75b\">会缓存当前的component,等下一次切换的时候,就直接使用缓存就行了</p>\n</blockquote>\n<p id=\"ud7bbab9b\"></p>\n<p id=\"u72e7c271\"><strong>23、$on()函数有什么用？</strong></p>\n<blockquote>\n<p id=\"ua684ebb1\">监听当前实例上的自定义事件。事件可以由 vm.$emit 触发</p>\n</blockquote>\n<p></p>\n<p id=\"u9bd324f2\"><strong>24、说一下vm.$off()的作用</strong></p>\n<blockquote>\n<p id=\"u6246c20f\">移除自定义事件监听器。</p>\n</blockquote>\n<p id=\"uf4b204d8\"></p>\n<p id=\"u0871593a\"><strong>25、说一下vm.$once()的作用</strong></p>\n<blockquote>\n<p id=\"ua0616c3e\">监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p>\n</blockquote>\n<p id=\"u38e9b54c\"></p>\n<p id=\"ud37981f4\"><strong>26、说一下vm.$mount()的作用</strong></p>\n<blockquote>\n<p id=\"u0605ea1a\">手动地挂载一个未挂载的实例</p>\n</blockquote>\n<p id=\"u78ad063b\"></p>\n<p id=\"udfce6fde\"><strong>27、说一下vm.$refs的作用</strong></p>\n<blockquote>\n<p id=\"u8d6ef05e\">一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例。</p>\n</blockquote>\n<p id=\"u68ea032d\"></p>\n<p id=\"u19d1964b\"><strong>28、说一下v-slot的作用</strong></p>\n<blockquote>\n<p id=\"u5b9525bb\">提供具名插槽或需要接收 prop 的插槽。</p>\n</blockquote>\n<p></p>\n<p id=\"u99ede954\"><strong>29、说一下Vue生命周期四个初始化阶段方法</strong></p>\n<ol><li id=\"u10bfd260\">beforeCreate() { }, 创建vue之前执行（数据和虚拟DOM树 还没有加载完成）</li><li id=\"u03496644\">created() { }, 创建vue之前执行（数据已经加载好，虚拟DOM树没有加载完成）</li><li id=\"uf3d9de41\">beforeMount() { }, 页面渲染之前执行（数据和虚拟DOM树都已经加载好，但数据这时并没有填充）</li><li id=\"u21866cda\">mounted() { }, 页面渲染之后（数据已经填充完成）</li></ol>\n<p></p>\n<blockquote>\n<h3>8月8日</h3>\n</blockquote>\n<p></p>\n<p id=\"ue6aba096\"><strong>30、说一下你对组件的理解</strong></p>\n<ol><li id=\"u97bdcc94\">对页面某一个区域进行封装，这个区域可以很小，也可以就是整个页面</li><li id=\"u43c7b821\">组件本身就是一个Vue实例对象</li><li id=\"u3aaf9613\">组件必须有且只有一个根元素</li></ol>\n<blockquote>\n<p>1、就是一个可复用的vue实例，可以作用组件对页面进行封装，可以把页面的某一个区域封装成一个组件，然后复用<br/> 封装的区域可以就是一个标签，也可以是整个页面<br/> 2、组件就是一个可复用的vue实例，则vue中有的东西，组件中都可以使用（比如属性计算，监听，生命周期）<br/> 但是组件没有el这个选项，并且data是一个函数<br/> 3、组件必需要有一个根元素标签（不能有两个）</p>\n</blockquote>\n<p></p>\n<p></p>\n<p id=\"u2ec2af2c\"><strong>31. Vue 的实例生命周期</strong></p>\n<p id=\"u5ae4faac\">整个什么周期包含8个函数</p>\n<ul><li id=\"u824859c8\">页面初始化渲染阶段（只执行一次），在页面初始化渲染时，就会自动执行</li></ul>\n<ol><li id=\"u4bc33505\">beforeCreate() { }, -------创建vue之前执行（数据和虚拟DOM树 还没有加载完成）</li><li id=\"u1ba6bc91\">created() { }, ---------创建vue之前执行（数据已经加载好，虚拟DOM树没有加载完成）</li><li id=\"u926794a4\">beforeMount() { }, -----页面渲染之前执行（数据和虚拟DOM树都已经加载好，但数据这时并没有填充）</li><li id=\"u88484b58\">mounted() { }, -------页面渲染之后（数据已经填充完成）</li></ol>\n<ul><li id=\"u4beb047f\">数据更新渲染阶段（多次）数据更新时执行</li></ul>\n<ol><li id=\"ub5dd8382\">beforeUpdate() { }, ----数据更新之前执行（这个时候数据更新了，但页面还没有更新）</li><li id=\"u78fc856b\">updated() { }, ------数据更新之后执行（这个时候数据更新了，页面也更新了）</li></ol>\n<ul><li id=\"ubb10c767\">vue销毁阶段（一次），销毁时执行</li></ul>\n<ol><li id=\"ucc5e4c44\">beforeDestroy() { }, ----销毁之前会触发，</li><li id=\"u324f8def\">destroyed() { }, ------销毁之后会触发，</li></ol>\n<p></p>\n<p id=\"u8c2dbcdc\"><strong>32. Vue 的双向数据绑定的原理</strong></p>\n<p id=\"u0c89cf8d\">1.通过v-model可以实现双向绑定</p>\n<p id=\"ucbb7acd2\">2.采用数据劫持结合发布者-订阅者模式的方式</p>\n<p id=\"u22f9fa18\">3.通过Object.defineProperty()来劫持各个的set（）设置，get（）获取</p>\n<p id=\"u0bca1080\">4.触发相应的监听回调来渲染视图</p>\n<p id=\"u217b1ee1\"></p>\n<p id=\"u0bea8490\">Vue3.0 将用原生 Proxy 替换 Object.defineProperty</p>\n<p></p>\n<p id=\"ud957aaeb\"><strong>33. 为什么要替换 Object.defineProperty？</strong></p>\n<p id=\"u54d1e0cf\">Object.defineProperty只能遍历对象属性进行劫持</p>\n<p id=\"uf0bd76d0\">Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p>\n<blockquote>\n<p>在 Vue 中，Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。<br/> Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</p>\n</blockquote>\n<p></p>\n<p id=\"u902639ed\"><strong>34. 什么是 Proxy？</strong></p>\n<p id=\"u1b06f2ef\">Proxy：代理，是ES6新增的功能，可以理解为代理器（即由它代理某些操作）。</p>\n<p id=\"u63d840ae\">Proxy ：对象用于定义或修改某些操作的自定义行为，可以在外界对目标对象进行访问前，对外界的访问进行改写。</p>\n<blockquote>\n<p>Proxy 是 ES6 中新增的一个特性JavaScript中用来表示由它来’代理’某些操作<br/> Proxy 是 ES6 中新增的一个特性，翻译过来意思是\"代理\"，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n<p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p>\n</blockquote>\n<p id=\"u563b6161\"><strong>35. 为什么避免 v-if 和 v-for 用在一起</strong></p>\n<p id=\"u5cde8dde\">当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中，带来性能方面的浪费。</p>\n<blockquote>\n<p>我们可以把 v-if 移动到父级（容器）元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。<br/> 或者在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环</p>\n</blockquote>\n<p></p>\n<p id=\"u818c976b\"><strong>36. 组件的设计原则</strong></p>\n<p id=\"uc6b23ec8\">(1)页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块)</p>\n<p id=\"u114428f7\">(2)每个组件对应一个\"工程\"目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中)</p>\n<p id=\"ue3966d2d\">(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑)</p>\n<p id=\"u02377a51\">(3)页面不过是组件的容器，组件可以嵌套自由组合成完整的页面</p>\n<blockquote>\n<p>第一: 容错处理, 这个要做好, 极端场景要考虑到,<br/> 第二: 缺省值(默认值)要有, 一般把应用较多的设为缺省值<br/> 第三: 颗粒化, 把组件拆分出来.<br/> 第四: 一切皆可配置, 如有必要, 组件里面使用中文标点符号, 还是英文的标点符号, 都要考虑到<br/> 第五: 场景化, 如一个dialog弹出, 还需要根据不同的状态封装成success, waring, 等<br/> 第六: 有详细的文档/注释和变更历史, 能查到来龙去脉, 新版本加了什么功能是因为什么<br/> 第七: 组件名称, 参数prop, emit, 名称设计要通俗易懂, 最好能做到代码即注释这种程度<br/> 第八: 可拓展性, 前期可能不需要这个功能, 但是后期可能会用上, 要预留什么, 要注意什么, 心里要有数<br/> 第九: 规范化,我这个input组件, 叫on-change, 我另外一个select组件叫change,<br/> 第十: 分阶段: 不是什么都要一期开发完成看具体业务, 如果一个select, 我只是个简单的select功能</p>\n</blockquote>\n<p></p>\n<p id=\"u8806aade\"><strong>37. vue slot是做什么的?</strong></p>\n<blockquote>\n<p id=\"ucb785ef6\">可以插入的槽口，比如插座的插孔。</p>\n</blockquote>\n<p></p>\n<p id=\"u12ffbd8e\"><strong>38. 对于 Vue 是一套渐进式框架的理解</strong></p>\n<ol><li id=\"u5efdda78\">主张最少，也就是弱主张，他是在vue核心库（视图模板引擎）的基础上，去逐步添加所需要功能（如，组件系统、路由、状态机等）</li><li id=\"u93320085\">vue“渐进式”：是指先使用vue核心库，在vue核心库的基础上，根据自己需要再去逐渐增加功能。</li><li id=\"u42599a53\">Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。</li><li id=\"u7ce46e7b\">在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。</li><li id=\"u0661f24f\">更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。</li><li id=\"ub722ab06\">所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。</li></ol>\n<blockquote>\n<p>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。</p>\n<p>1、使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用；<br/> 2、也可以整个用它全家桶开发，当 Angular 用；<br/> 3、还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO(Object–Oriented )面向对象和设计模式的那套理念。<br/> 也可以函数式，都可以。</p>\n<p>它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。</p>\n<p>你不必一开始就用 Vue 所有的全家桶，根据场景，官方提供了方便的框架供你使用。</p>\n<p>场景联想<br/> 场景 1：<br/> 维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。</p>\n<p>场景 2：<br/> 得到 boss 认可， 后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化</p>\n<p>场景 3:<br/> 越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！</p>\n<p>场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。</p>\n</blockquote>\n<p></p>\n<p id=\"ud0471fe4\"><strong>39. vue.js 的两个核心是什么？</strong></p>\n<blockquote>\n<p id=\"u83a42742\">答案：数据驱动和组件化思想</p>\n</blockquote>\n<p></p>\n<blockquote>\n<h3 id=\"main-toc\"><strong>8月9日</strong></h3>\n</blockquote>\n<p></p>\n<p><strong>40. 请问 v-if 和 v-show 有什么区别</strong></p>\n<p id=\"u56150947\">v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏</p>\n<p id=\"u451c035f\">v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果(删除)</p>\n<p></p>\n<p><strong>42. vue 常用的修饰符</strong></p>\n<ul><li id=\"u4922da35\">stop  阻止点击事件冒泡。等同于JavaScript中的event.stopPropagation()</li><li id=\"u297306d2\">prevent   防止执行预设的行为 同于JavaScript的event.preventDefault()</li><li id=\"u5127c39c\">trim   自动过滤用户输入的首尾空格</li><li id=\"u6c1d2e79\">number 将输出字符串转为Number类型</li><li id=\"u5a2c73db\">enter 回车键</li></ul>\n<p></p>\n<p><strong>43. v-on 可以监听多个方法吗？</strong></p>\n<p id=\"ufcc293df\">答案：肯定可以的。</p>\n<p id=\"u4087481b\">解析：</p>\n<pre><code>&lt;input\n  type=\"text\"\n  :value=\"name\"\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n  @blur=\"onBlur\"\n/&gt;</code></pre>\n<p></p>\n<p><strong>44. vue 中 key 值的作用</strong></p>\n<blockquote>\n<p id=\"u32424730\">需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点<br/> 所以一句话，key 的作用主要是为了高效的更新虚拟 DOM</p>\n</blockquote>\n<p id=\"u7a47b64d\"></p>\n<p><strong>45. vue-cli 工程升级 vue 版本</strong></p>\n<blockquote>\n<p id=\"ub447afe3\">在项目目录里运行 npm upgrade vue vue-template-compiler，不出意外的话，可以正常运行和 build。如果有任何问题，删除 node_modules 文件夹然后重新运行 npm i 即可。</p>\n<p id=\"u95493366\">（简单的说就是升级 vue 和 vue-template-compiler 两个插件）</p>\n</blockquote>\n<p></p>\n<p id=\"ue4b99a76\"><strong>46、vue 与 jquery的区别？</strong><br/> jQuery直接操作DOM元素<br/> Vue使用了MVVM原则，是通过Vue对象将数据 和 View 完全分离；通过数据来响应渲染页面;<br/> 而不需要直接操作DOM元素</p>\n<p id=\"u5a8a7c8f\"></p>\n<p id=\"uca30a6a8\"><strong>47、watch 和 computed 区别</strong></p>\n<p id=\"u2ce0ea24\"><strong>watch:</strong></p>\n<ol><li id=\"udf6c997a\">监听动作（只监听原本的属性）</li><li id=\"ued01ca49\">没缓存，只要数据变化就执行</li><li id=\"uda297d32\">可以执行异步操作</li><li id=\"u348016af\">常用于一个数据影响多个数据</li></ol>\n<p id=\"u21fef057\"><strong>computed:</strong></p>\n<ol><li id=\"u54c00587\">计算属性（会生成新的属性）</li><li id=\"uea4083ef\">有缓存，只在属性变化的时候才去计算。</li><li id=\"u90bac1de\">不能执行异步操作</li><li id=\"u13600f0c\">常用于多个数据影响一个数据</li></ol>\n<p></p>\n<p id=\"ue485f776\"><strong>48、讲一下 Vue 的生命周期？</strong><br/> 整个什么周期包含8个函数</p>\n<p id=\"u7401a58f\">1<span style=\"color:#0d0016;\">.页面初始化渲染阶段（只执行一次），在页面初始化渲染时，就会自动执行</span></p>\n<ul><li id=\"ud635e65b\">beforeCreate() { }, 创建vue之前执行（数据和虚拟DOM树 还没有加载完成）</li><li id=\"u4b972637\">created() { }, 创建vue之前执行（数据已经加载好，虚拟DOM树没有加载完成）</li><li id=\"ua01c2270\">beforeMount() { }, 页面渲染之前执行（数据和虚拟DOM树都已经加载好，但数据这时并没有填充）</li><li id=\"ub504e9e6\">mounted() { }, 页面渲染之后（数据已经填充完成）</li></ul>\n<p id=\"udcf24dda\"></p>\n<p id=\"u9018b653\"></p>\n<p id=\"u1134590f\"><span style=\"color:#0d0016;\">2.数据更新渲染阶段（多次）数据更新时执行</span></p>\n<ul><li id=\"u6e89d327\">beforeUpdate() { }, 数据更新之前执行（这个时候数据更新了，但页面还没有更新）</li><li id=\"u55d78c01\">updated() { }, 数据更新之后执行（这个时候数据更新了，页面也更新了）</li></ul>\n<p id=\"ud477c191\"></p>\n<p id=\"u951f9dae\"><span style=\"color:#0d0016;\">3.vue销毁阶段（一次），销毁时执行</span></p>\n<ul><li id=\"u17ae4547\">beforeDestroy() { }, 销毁之前会触发，</li><li id=\"ufe707649\">destroyed() { }, 销毁之后会触发，</li></ul>\n<p id=\"u1d2fe3ff\"></p>\n<p id=\"u254339f5\">使用情况：mounted、created方法比较常用；</p>\n<p id=\"u7f1001df\">因为经常需要在这两个方法中发送ajax请求，请求页面初始化数据</p>\n<p></p>\n<p></p>\n<p id=\"ua52c8055\"><strong>49、Vue 的父组件和子组件生命周期钩子执行顺序是什么</strong></p>\n<ol><li id=\"u9c188753\">加载渲染过程<br/><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li><li id=\"u521561f5\">子组件更新过程<br/><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></li><li id=\"ubb1ef49e\">父组件更新过程<br/><code>父beforeUpdate-&gt;父updated</code></li><li id=\"u8e8b720c\">销毁过程<br/><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code><br/> 总结：从外到内，再从内到外</li></ol>\n<p></p>\n<p id=\"uac540d88\"><strong>50、Vue 中父组件如何监听子组件的生命周期？</strong></p>\n<blockquote>\n<ol><li id=\"u57d80455\">可以通过自定义事件等，在子组件的生命周期钩子中，调用$emit触发父组件中的方法</li><li id=\"u8adf3ace\">通过@ hook在父组件中监听子组件的生命钩子，如果子组件是一个第三方组件，这很有用、</li></ol>\n</blockquote>\n<p></p>\n<blockquote>\n<h3><strong>8月10日</strong></h3>\n</blockquote>\n<p></p>\n<p id=\"u7e49be0e\"><strong>51、组件间通讯方式</strong></p>\n<blockquote>\n<p id=\"u118677dc\">1、props / $emit</p>\n<p id=\"u892ee28b\">（1）父组件向子组件传值（props将数据自上而下传递）</p>\n<p id=\"ud7721ebf\">（2）子组件向父组件传递数据（$emit和v-on来向上传递信息）</p>\n</blockquote>\n<blockquote>\n<p id=\"u4d6d649d\">2、eventBus事件总线（$emit / $on）</p>\n<p id=\"u784cb4f7\">通过EventBus进行信息的发布与订阅</p>\n</blockquote>\n<blockquote>\n<p id=\"u2373141a\">3、vuex:</p>\n<p id=\"uc7193504\">是全局数据管理库，可以通过vuex管理全局的数据流</p>\n</blockquote>\n<blockquote>\n<p id=\"ucfa4e07e\">4、ref / $refs</p>\n<p id=\"u7e4d2fbe\">ref：这个属性用在子组件上，它的用用就指向了子组件的实例，可以通过实例来访问组件的数据和方法</p>\n</blockquote>\n<blockquote>\n<p id=\"u84617666\">5、依赖注入（provide / inject）</p>\n<p id=\"u75575763\">provide 和 inject 是vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。</p>\n<ul><li id=\"u0a2030f5\">provide 钩子用来发送数据或方法。</li><li id=\"uf6ed879c\">inject钩子用来接收数据或方法</li></ul>\n</blockquote>\n<blockquote>\n<p id=\"u5a266e21\">6、$parent / $children</p>\n<ul><li id=\"u0c4d5f0d\">使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）。</li><li id=\"u0abc9c54\">使用 $children 可以让组件访问子组件的实例，但是， $children 并不能保证顺序，并且访问的数据也不是响应式的。</li></ul>\n</blockquote>\n<blockquote>\n<p id=\"u533e7796\">7、$attrs / $listeners</p>\n<p id=\"uc35a2963\">实现组件之间的跨代通信。</p>\n</blockquote>\n<p></p>\n<p id=\"ue9a3d725\"><strong>52、v-cloak指令的作用</strong></p>\n<blockquote>\n<ul><li id=\"u2b82b796\">用于 防止闪屏，防止页面出现{<!-- -->{ }}</li></ul>\n</blockquote>\n<p></p>\n<p id=\"uf1f057a8\"><strong>53、能讲下 v-if 和 v-for 的优先级吗</strong></p>\n<blockquote>\n<p>v-for优先于v-if执行</p>\n</blockquote>\n<pre><code>const arr = [1,2,3,4,5,6,7,8,9]\n\n&lt;li v-for=\"item in [1,2,3,4,5,6,7,8,9]\" v-if=\"\"&gt;</code></pre>\n<p></p>\n<p id=\"uf67d918b\"><strong>54、</strong><code><strong>v-for</strong></code><strong> 你使用过程中，有遇到什么问题或者关注点吗？</strong></p>\n<ul><li id=\"u2f23838c\"> 避免将 `v-if` 和 `v-for` 放在同一个元素上，因为 `v-for` 优先级比 `v-if` 更高。</li></ul>\n<blockquote>\n<p id=\"uea25a497\">例如：要渲染 todo 列表中未完成的任务，给 li 标签同时写上 v-for 和 v-if 后会导致每次重新渲染都得遍历整个列表。优化方案是把需要遍历的 todoList 更换为在计算属性上遍历过滤。（Vue文档有详细说明）</p>\n</blockquote>\n<ul><li id=\"u71aae472\">给 `v-for` 设置键绑定键值 `key`</li></ul>\n<p></p>\n<p><strong>55、在列表组件中添加 key 属性的作用？</strong></p>\n<ul><li>key的主要作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。这样可以更高效的更新虚拟 DOM。</li><li>另外如果给列表组件设置了过渡效果，不添加key属性会导致过渡效果无法触发。因为不添加key会导致vue无法区分它们，导致只会替换节点内部属性而不会触发过渡效果。</li></ul>\n<p></p>\n<p id=\"u56c84a23\"><strong>56、数据响应式（双向绑定）怎么做到的？</strong></p>\n<blockquote>\n<p>原理：Vue 采用 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者</strong> 模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter 以及 getter，在数据变动时发布消息给订阅者，触发相应的监听回调，更新视图。</p>\n</blockquote>\n<p><br/> 追问1：那如果我要监听一个对象属性的删除或添加呢？splice受 defineProperty 限制，Vue 无法检测对象属性的删除和添加。<br/> 所以我们可以利用 Vue 提供的 <code>Vue.set</code> 来解决此问题。</p>\n<blockquote>\n<ol><li id=\"ua997187d\">避免将 <code>v-if</code> 和 <code>v-for</code> 放在同一个元素上，因为 <code>v-for</code> 优先级比 <code>v-if</code> 更高。<br/> 例如：要渲染 todo 列表中未完成的任务，给 li 标签同时写上 v-for 和 v-if 后会导致每次重新渲染都得遍历整个列表。优化方案是把需要遍历的 todoList 更换为在计算属性上遍历过滤。（Vue文档有详细说明）</li><li id=\"ue01d313c\">给 <code>v-for</code> 设置键绑定键值 <code>key</code>。理由见下。</li><li id=\"u0764774c\">第一步：需要 Observe 对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li id=\"u47029227\">第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新数据。</li><li id=\"u99a21cca\">第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情有： \n   <ol><li>在自身实例化时往属性订阅器（dep）里面添加自己</li><li id=\"ufeac7378\">Watcher对象自身必须有一个 update() 方法，用于更新视图</li><li id=\"uf0e46777\">待属性变动 <code>dep.notice()</code> 通知时，能调用Watcher对象的 <code>update()</code> 方法，<br/> 并触发 Compile 中绑定的回调。</li></ol></li><li id=\"uebe9952e\">第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，<br/> 通过 Observer 数据劫持 来监听自己的 model 数据变化，<br/> 通过 Compile 来解析编译模板指令，<br/> 最终利用 Watcher 搭起 Observer 和 Compile 之间的桥梁，<br/> 达到数据变化 -&gt; 视图更新；<br/> 视图交互变化（input） -&gt; 数据 model 变更的双向绑定效果。</li></ol>\n</blockquote>\n<p>这图是模拟双向绑定的过程：</p>\n<p><img alt=\"\" height=\"522\" src=\"..\\..\\static\\image\\d609ad0159974e7eb2756ec4db9534d5.png\" width=\"1039\"/></p>\n<p></p>\n<p id=\"udeb15a5f\"><strong>57、Vuex 用过吗？简单介绍一下？</strong><br/> 状态管理模式 + 库</p>\n<blockquote>\n<p>相当于共享仓库，方便任何组件直接获取和修改。</p>\n</blockquote>\n<ul><li id=\"uf3c32b43\">state - 数据【存项目共享状态，是响应式的，store的数据改变，所有依赖此状态的组件会更新】 \n  <ul><li id=\"u9980b0a6\">$store.state.count</li></ul></li><li id=\"u37ea434d\">mutations - 方法【同步函数，只建议在这个地方修改数据】 \n  <ul><li id=\"ufbc9a3b1\">inc(state, 参数唯一) {}</li><li id=\"ue424f037\">$store.commit('inc', 2)</li></ul></li><li id=\"uea148949\">actions -【异步操作】【提交的是mutations，不直接修改状态】 \n  <ul><li id=\"ud9c04213\">increment(context, num) {context.commit()}</li><li id=\"u108ee36f\">this.$store.dispatch('',arg)</li></ul></li><li id=\"u4aea02d6\">getters - 包装数据 【store的计算属性，可缓存】 \n  <ul><li id=\"u448533d3\">show: function(state) {}</li><li id=\"u7e88121d\">this.$store.getters.show</li><li id=\"uf2d65c81\">传参，返回函数：show(state) {return function(参数) {return ...}}【不会缓存数据】</li></ul></li></ul>\n<p></p>\n<p id=\"u70e32419\"><strong>58、使用 Vuex 管理数据，与直接在 全局 window 下定义变量相比，有什么区别或者说优势？</strong></p>\n<blockquote>\n<ul><li id=\"ub53f0cf5\"><strong>vuex、</strong></li></ul>\n<ol><li id=\"u5ea01373\">vuex由统一的方法修改数据（ store 数据需要到mutation 层）</li><li id=\"u3d6051f1\">Vuex数据更新 具有响应式</li><li id=\"u0198cd54\">层次划分明确，便于管理</li></ol>\n</blockquote>\n<blockquote>\n<ul><li id=\"u16e662eb\"><strong>window、</strong></li></ul>\n<ol><li id=\"u275c9937\">window全局作用域下定义的数据是静态的，数据不具有响应式</li><li id=\"ud044fcd9\">全局变量多了会造成命名污染</li></ol>\n</blockquote>\n<p id=\"u8d23d2a8\"><strong>59、Vuex 是通过什么方式提供响应式数据的？</strong></p>\n<blockquote>\n<p>在 Store 构造函数中通过 new Vue({}) 实现的。<br/> 利用 Vue 来监听 state 下的数据变化，<br/> 给状态(数据)添加 getter、setter可以监听数据改变。</p>\n</blockquote>\n<p id=\"ub974f38f\"></p>\n<p id=\"ue342667b\"><strong>60、Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</strong><br/> 总结：</p>\n<blockquote>\n<p>在vuex底层会有一个committing变量，初始值false；当通过mutation方法修改数据时<br/> 把committing变量变成true；如果是直接改变的变量则不改变committing变量</p>\n</blockquote>\n<blockquote>\n<h3>8月11日</h3>\n</blockquote>\n<p id=\"ub6bf0b77\"><strong>61、Vuex 原理</strong></p>\n<blockquote>\n<p>vuex 仅仅是作为 vue 的一个插件而存在<br/> vuex 只能使用在 vue 上，很大的程度是因为其高度依赖检测系统以及其插件系统，<br/> 它的实现方式完完全全的使用了vue 自身的响应式设计，依赖监听、依赖收集;<br/> 都属于vue对对象 Property set get 方法的代理劫持。<br/> vuex中的 store 本质就是相当于一个没有 template 的隐藏着的 vue 组件。</p>\n</blockquote>\n<p id=\"u632ce711\"><strong>62、VueRouter 是什么？你平常是怎么用的？</strong></p>\n<ul><li id=\"u3768cd35\">是什么：Vue-Router 是 Vue 官方的路由管理器</li><li id=\"u18aed219\">作用：为了页面跳转</li><li id=\"u08bd349c\">原理：可以给每一个组件分配路由路径，<br/> 则就可以使用rotuer-link或者编程式导航来根据分配的路由路径，<br/> 实现组件之间的跳转；</li></ul>\n<p id=\"u7b90f562\">监听锚点值改变，渲染指定页面</p>\n<p></p>\n<p id=\"u5ad8c7cc\"><strong>63、vue.js 的两个核心是什么？</strong></p>\n<blockquote>\n<p>答案：数据驱动 和 组件化思想</p>\n</blockquote>\n<p id=\"u9ce721c6\"><strong>64、请问 v-if 和 v-show 有什么区别</strong></p>\n<p id=\"u2edca0c5\">相同点：</p>\n<blockquote>\n<p id=\"u810370b8\">v-if和v-show都可以动态控制dom元素隐藏</p>\n</blockquote>\n<p id=\"u9d4102b3\">不同点：</p>\n<blockquote>\n<p id=\"ud502cb73\">v-if显示隐藏是将dom元素整个添加或删除<br/> v-show隐藏则是为该元素添加css--display：none；dom元素还在</p>\n</blockquote>\n<p></p>\n<p id=\"ud025ab0f\"><strong>65、什么时候使用v-if, 什么时候使用v-show? 为什么？</strong><br/> 切换次数比较多时使用v-show：</p>\n<blockquote>\n<p id=\"uec62ea56\">因为切换次数多时，如果使用v-show可以减少DOM元素的插入或者删除，从而提高操作性能</p>\n</blockquote>\n<p id=\"u01243d61\">切换次数比较少时使用v-if：</p>\n<blockquote>\n<p id=\"u9aa39267\">因为v-if隐藏元素不会把元素添加到DOM树中，DOM树会少加载节点，</p>\n<p id=\"u302d5873\">所以DOM树首次加载会有所提高速度（有利于首屏加载速度）</p>\n</blockquote>\n<p id=\"u40900324\"><strong>66、vue 常用的修饰符</strong></p>\n<blockquote>\n<p>stop      阻止点击事件冒泡。等同于JavaScript中的event.stopPropagation()<br/> prevent   防止执行预设的行为 同于JavaScript的event.preventDefault()<br/> trim      自动过滤用户输入的首尾空格<br/> number  将输出字符串转为Number类型<br/> enter    回车键</p>\n</blockquote>\n<p id=\"u1fa620c2\"><strong>67、vue 中 key 值的作用</strong></p>\n<blockquote>\n<p>答案：key 的作用主要是为了高效的更新虚拟 DOM，有唯一标识正确识别节点</p>\n</blockquote>\n<pre><code>需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，\n找到正确的位置区插入新的节点，所以一句话，key 的作用主要是为了高效的更新虚拟 DOM；\n\n因为vue更新节点时，为了提高性能，所以会比较新旧DOM树，如果新节点与旧节点的元素比较结果\n为同一个元素，则不更新，还是使用原来的旧节点，否则才显示新节点；\n而判断两个节点是否为同一个元素节点，就是通过标签名与key来判断的</code></pre>\n<p></p>\n<p id=\"u127d3a8e\"><strong>68、什么是 Vue.nextTick()？</strong><br/> 定义：在下次 DOM 更新循环结束之后执行延迟回调。（在一个异步任务完成之后执行）</p>\n<blockquote>\n<p id=\"u278cc7df\">白话：等你dom加载完毕以后再去调用nextTick()里面的数据内容它是Vue的核心方法之一；<br/> 理解：nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：<br/> 当数据更新了，在 dom 中渲染后，自动执行该函数中回调函数，<br/> Vue.nextTick(function(){ 这里在DOM更新后执行 })</p>\n</blockquote>\n<p></p>\n<p id=\"u0ea8d5df\"><strong>69、Vue 组件中 data 为什么必须是函数</strong></p>\n<p id=\"ud99e83ce\">答 : 防止组件重用的时候导致数据相互影响;<br/> 因为data会挂在组件的原型上；所有实例共有<br/> 如果不是函数，则两个实例都引用同一个对象，当其中一个实例属性改变时，另一个实例属性也随之改变</p>\n<blockquote>\n<p>只有当两个实例拥有自己的作用域时(比如函数)，才不会互相干扰 ！！！！！这句是重点！！！！！</p>\n</blockquote>\n<p id=\"u0830183b\"></p>\n<p id=\"uce01ac0d\"><strong>70、vue 中子组件调用父组件的方法</strong></p>\n<ul><li id=\"ue653c064\">第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</li><li id=\"u8444835c\">第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</li><li id=\"u5135c0c4\">第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul>\n<p></p>\n<blockquote>\n<p></p>\n</blockquote>\n<p></p>\n<h2 id=\"jQuery\">jQuery</h2>\n<p id=\"u6de6a9e3\"><strong>1、jQuery库中的$()是什么？</strong></p>\n<ol><li id=\"u2d68514b\">$() 函数是 jQuery() 函数的别称，</li><li id=\"uc4f3c304\">$()函数用于将任何对象包裹成 jQuery对象，可以调用jquery上的方法;接着被允许调用定义在jQuery对象上的多个不同方法。甚至可以将一个选择器字符串传入$()函数，它会返回一个包含所有匹配的DOM元素数组的jQuery对象。这个问题我已经见过好几次被提及，尽管它非常基础，它经常被用来区分一个开发人员是否了解jQuery。</li></ol>\n<p></p>\n<p id=\"u7afd5c64\"><strong>2、网页上有5个div元素，如何使用 jQuery来选择它们？</strong></p>\n<ol><li id=\"u81fe1db0\">jQuery支持不同类型的选择器，例如ID选择器、class选择器、标签选择器。</li><li id=\"u57e6d0e2\">鉴于这个问题没提到ID和class，可以用标签选择器来选择所有的div 元素。</li><li id=\"u9b67d178\">jQuery代码：$(\"div\")，这样会返回一个包含所有5个div标签的jQuery 对象。</li></ol>\n<p></p>\n<p id=\"uc57d835d\"><strong>3、$(this) 和 this 关键字在 jQuery 中有何不同？</strong></p>\n<ol><li id=\"u51579667\">这对于很多java零基础学jQuery的初学者来说是一个棘手的问题，其实是个简单的问题。$(this) 返回一个jQuery对象，你可以对它调用多个 jQuery方法，比如用text()获取文本，用val()获取值等等。而this代表当前元素，它是JavaScript关键词中的一个，表示上下文中的当前DOM元素。你不能对它调用 jQuery方法，直到它被 $() 函数包裹，例如 $(this)。</li></ol>\n<p><strong>4、使用CDN加载 jQuery库的主要优势是什么？</strong></p>\n<ol><li>更快的下载速度;</li><li>可以节省带宽（服务器缓存）;</li><li>从同一个CDN下载类相同的jQuery版本,它不会重复去下载一次</li></ol>\n<blockquote>\n<p id=\"ueb74b470\">除了报错节省服务器带宽以及更快的下载速度这许多的好处之外, 最重要的是，</p>\n<p id=\"u1a6d468b\">如果浏览器已经从同一个CDN下载类相同的jQuery版本,</p>\n<p id=\"ud0681192\">那么它就不会再去下载它一次，</p>\n<p id=\"u12bdbbae\">因此今时今日，许多公共的网站都将jQuery用于用户交互和动画,</p>\n<p id=\"u72aeec26\">如果浏览器已经有了下载好的jQuery库，网站就能有非常好的展示机会。</p>\n</blockquote>\n<p></p>\n<p id=\"u17a611fa\"><strong>5、jQuery中的方法链是什么？使用方法链有什么好处？</strong></p>\n<blockquote>\n<p id=\"u8694699a\">方法链 : 是对一个方法返回的结果调用另一个方法 ,一个方法接一个方法;</p>\n</blockquote>\n<ul><li id=\"u6298aefb\">好处:</li></ul>\n<ol><li id=\"ubc479b98\">使得代码简洁明了，</li><li id=\"u38f8bd25\">同时由于只对DOM进行了一轮查找，性能方面更加出色。</li></ol>\n<p id=\"u996e5359\"></p>\n<p id=\"uab3458bf\"><strong>6、jQuery如何将一个HTML元素添加到DOM树中的？</strong></p>\n<p id=\"u27114230\">答案: appendTo()或者append();</p>\n<ul><li id=\"u36405da2\">可以用 jQuery方法appendTo()或者append()将一个HTML元素添加到DOM树中。</li><li id=\"ub93a4ad6\">这是jQuery提供的众多操控DOM的方法中的一个。</li><li id=\"u1ee48e07\">可以通过appendTo()方法在指定的DOM元素末尾添加一个现存的元素或者一个新的HTML元素。</li></ul>\n<p id=\"ub5171037\"></p>\n<p id=\"u8509f29d\"><strong>7、说出jQuery中常见的几种函数以及他们的含义是什么?</strong></p>\n<p id=\"u475e587f\">（1）get() 取得所有匹配的DOM元素集合；</p>\n<p id=\"uadfb562d\">（2）get(index) 取得其中一个匹配的元素.index表示取得第几个匹配的元素；</p>\n<p id=\"uc72e21fe\">（3）append(content) 向每个匹配的元素内部追加内容；</p>\n<p id=\"u636c972b\">（4）after(content) 在每个匹配的元素之后插入内容；</p>\n<p id=\"u69cd68b8\">（5）html()/html(var) 取得或设置匹配元素的html内容；</p>\n<p id=\"u4a983466\">（6）find(expr) 搜索所有与指定表达式匹配的元素；</p>\n<p id=\"u49864bff\">（7）bind(type,[data],fn) 为每个匹配元素的特定事件绑定事件处理函数；</p>\n<p id=\"u308f37e0\">（8）empty() 删除匹配的元素集合中所有的子节点；</p>\n<p id=\"u4c1f2229\">（9）hover(over,out) 一个模仿悬停事件(鼠标移动到一个对象上面及移出这个对象)的方法；</p>\n<p id=\"u4ee96139\">（10）attr(name) 取得第一个匹配元素的属性值。</p>\n<p id=\"u96262b8d\">  (11) hide() 隐藏</p>\n<p id=\"u88bbe775\">  (12) show() 显示</p>\n<p id=\"u0cf21499\"></p>\n<p id=\"u4e74fc70\"><strong>8、jQuery能做什么</strong></p>\n<ol><li id=\"u1cd1a77b\">获取页面的元素；</li><li id=\"u36f46e9e\">修改页面的外观；</li><li id=\"ubd160b6d\">改变页面大的内容；</li><li id=\"u59f30f82\">响应用户的页面操作；</li><li id=\"uac4f2eec\">为页面添加动态效果；无需刷新页面，即可以从服务器获取信息；</li><li id=\"ubf15c41d\">简化常见的javascript任务。</li></ol>\n<p id=\"u010691f7\"></p>\n<p id=\"uf435baf2\"><strong>9、jquery中的选择器和CSS中的选择器有区别吗？</strong></p>\n<ol><li id=\"uf1eb2289\">jQuery选择器支持CSS里的选择器，</li><li id=\"u183558cd\">jQuery选择器可用来添加样式和添加相应的行为，</li><li id=\"u26b1b2b9\">CSS中的选择器是只能添加相应的样式。</li></ol>\n<p id=\"ub2d71cb6\"></p>\n<p id=\"u7d882141\"><strong>10、jQuery的特点都有什么？</strong></p>\n<p id=\"u25d7e134\">jQuery的核心特性可以总结为：</p>\n<ol><li id=\"ued373616\">具有独特的链式语法和短小清晰的多功能接口；</li><li id=\"uade599a2\">具有高效灵活的CSS选择器，并且可对CSS选择器进行扩展；</li><li id=\"u8f18f08c\">拥有便捷的插件扩展机制和丰富的插件。</li><li id=\"u9b4b4585\">jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。</li></ol>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<blockquote>\n<h1 id=\"%E5%90%8E%E9%9D%A2%E4%BC%9A%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0\">后面会持续更新</h1>\n</blockquote>\n</div>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-08-11 15:43:57", "summary": "、说一下与的作用与区别？作用：都可以获取或者设置元素的内容区别：可以解析内容中的标签不能解析内容中的标签、由以下三部分组成：语法部分：语言基础文档对象模型：规定了访问和的方法浏览器对象模型：提供了浏览"}