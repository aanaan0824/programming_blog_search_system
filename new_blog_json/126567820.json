{"blogid": "126567820", "writerAge": "码龄1年", "writerBlogNum": "135", "writerCollect": "338", "writerComment": "35", "writerFan": "2731", "writerGrade": "4级", "writerIntegral": "1508", "writerName": "ArimaMisaki", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126567820.jpg", "writerRankTotal": "12029", "writerRankWeekly": "2061", "writerThumb": "114", "writerVisitNum": "113308", "blog_read_count": "501", "blog_time": "于 2022-08-28 11:22:48 发布", "blog_title": "一幅长文细学Vue（五）——组件高级（上）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"5__0\"></a>5 组件高级（上）</h1>\n<blockquote>\n<p><strong>摘要</strong></p>\n<p>​ 在本文中，我们会详细讨论watch侦听器的基本使用，并且了解vue中常用的生命周期函数、实现组件之间的数据共享，最后学习如何在vue3.x项目中全局配置axios。</p>\n<p><strong>声明</strong>：为了文章的清爽性，在文章内部的代码演示中只会附上部分演示代码，main.js文件的代码通常不贴出，如果感兴趣可以前往代码仓库获取</p>\n<p><strong>作者</strong>：来自ArimaMisaki创作</p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#5__0\">5 组件高级（上）</a></li><li><ul><li><a href=\"#51_watch_11\">5.1 watch侦听器</a></li><li><ul><li><a href=\"#511_watch_13\">5.1.1 watch侦听器概述</a></li><li><a href=\"#512_watch_23\">5.1.2 watch的使用场景</a></li><li><a href=\"#513__80\">5.1.3 侦听器选项</a></li><li><a href=\"#514__98\">5.1.4 监听对象单个属性的变化</a></li><li><a href=\"#515__104\">5.1.5 计算属性和侦听器</a></li></ul>\n</li><li><a href=\"#52__110\">5.2 生命周期</a></li><li><ul><li><a href=\"#521__112\">5.2.1 组件运行的过程</a></li><li><a href=\"#522__120\">5.2.2 如何监听组件的不同时刻</a></li><li><a href=\"#523__182\">5.2.3 如何监听组件的更新</a></li><li><a href=\"#524__188\">5.2.4 组件生命周期函数</a></li></ul>\n</li><li><a href=\"#53__196\">5.3 数据共享</a></li><li><ul><li><a href=\"#531__198\">5.3.1 组件之间的关系</a></li><li><a href=\"#532__208\">5.3.2 父子组件</a></li><li><a href=\"#533__218\">5.3.3 兄弟组件</a></li><li><a href=\"#534_Prop_236\">5.3.4 Prop逐级透传问题</a></li><li><a href=\"#535__246\">5.3.5 后代组件</a></li><li><a href=\"#536_Provide_256\">5.3.6 基于Provide向下共享响应式的数据</a></li><li><a href=\"#537_vuex_260\">5.3.7 vuex</a></li></ul>\n</li><li><a href=\"#54_axios_266\">5.4 全局配置axios</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h2><a id=\"51_watch_11\"></a>5.1 watch侦听器</h2>\n<h3><a id=\"511_watch_13\"></a>5.1.1 watch侦听器概述</h3>\n<p><strong>说明</strong>：watch侦听器允许开发者监视数据的<code>变化</code>，从而针对数据的变化做特定的操作。例如，监视用户名的变化并发起请求，判断用户名是否可用。</p>\n<p><strong>本质</strong>：监听器的本质也是一个函数，它允许接收两个参数，即<code>新数据</code>和<code>老数据</code>。</p>\n<p><strong>使用</strong>：在选项式API中，我们可以使用watch选项来定义所需的侦听器。</p>\n<br/>\n<h3><a id=\"512_watch_23\"></a>5.1.2 watch的使用场景</h3>\n<p><strong>场景</strong>：检测用户名是否可用</p>\n<p><strong>说明</strong>：监听username值的变化，并使用axios发起Ajax请求，检测当前输入的用户名是否可用。要完成这个场景，需先安装axios包。</p>\n<pre><code class=\"prism language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;h3&gt;watch 侦听器的用法&lt;/h3&gt;\n        &lt;input type=\"text\" class=\"form-control\" v-model.trim=\"username\"&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport axios from 'axios'\n\nexport default {\n    name: 'MyWatch',\n    data() {\n        return {\n            username: 'admin',\n        }\n    },\n    watch: {\n        async username(newVal, oldVal) {\n            console.log(newVal, oldVal);\n            const { data: res } = axios.get('https://www.escook.cn/api/finduser' + newVal)\n            console.log(res);\n        }\n    }\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code class=\"prism language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;App根组件&lt;/h1&gt;\n        &lt;hr&gt;\n        &lt;my-watch&gt;&lt;/my-watch&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport MyWatch from \"./MyWatch.vue\"\nexport default {\n    name: 'MyWatch',\n    components: {\n        MyWatch\n    },\n}\n&lt;/script&gt;\n</code></pre>\n<br/>\n<h3><a id=\"513__80\"></a>5.1.3 侦听器选项</h3>\n<p><strong>immediate选项</strong>：watch是懒执行的。默认情况下，组件在初次加载完毕后不会调用watch侦听器，仅当数据源发生改变时，侦听器才会触发。如果想让watch侦听器立即被调用，需要使用<code>immediate选项</code>。需要额外注意的是，当我们第一次使用侦听器时，旧值为undefined。</p>\n<p><strong>deep选项</strong>：如果我们侦听的源是<code>对象</code>或<code>数组</code>，在不使用选项的情况下我们无法使用侦听器来侦听它们的变化。使用<code>deep选项</code>可以强制深度遍历源，以便源在进行变更的时候触发回调。</p>\n<pre><code class=\"prism language-vue\">info: {\n            async handler(newVal) {\n                const { data: res } = await axios.get('https://www.escook.cn/api/finduser' + newVal.username)\n                console.log(res);\n            },\n            deep:true\n        }\n</code></pre>\n<br/>\n<h3><a id=\"514__98\"></a>5.1.4 监听对象单个属性的变化</h3>\n<p><strong>说明</strong>：使用<code>deep选项</code>会遍历数组或对象中的所有属性，如果想要监听单个属性，我们可以采用<code>.</code>的形式指定获取数组或对象的单个属性作为监听源。不过需要注意的是，由于使用了<code>.</code>的缘故，作为键的一方需要加上<code>单引号</code>或<code>双引号</code>。</p>\n<br/>\n<h3><a id=\"515__104\"></a>5.1.5 计算属性和侦听器</h3>\n<p><strong>说明</strong>：有很多人会搞混计算属性和侦听器。实际上，计算属性侧重于监听多个值得变化，并最终计算返回一个新值，而侦听器侧重于监听单个数据源的变化，最终执行特定的业务处理，不需要有任何返回值。</p>\n<br/>\n<h2><a id=\"52__110\"></a>5.2 生命周期</h2>\n<h3><a id=\"521__112\"></a>5.2.1 组件运行的过程</h3>\n<p><strong>组件的生命周期</strong>：组件的生命周期指的是组件从创建到湮灭的整个过程，该术语强调的是这个时间段。</p>\n<p><img alt=\"image-20220828082013374\" src=\"..\\..\\static\\image\\943e34e6541d9b3ccd85324637fe0dba.png\"/></p>\n<br/>\n<h3><a id=\"522__120\"></a>5.2.2 如何监听组件的不同时刻</h3>\n<p><strong>说明</strong>：Vue框架为组件内置了不同时刻的生命周期函数，生命周期函数会伴随着组件的运行而自动调用。另外，生命周期函数常被称为<code>生命周期钩子</code>。</p>\n<ul><li>当组件在内存中被创建完毕之后，会自动调用created函数</li><li>当组件被成功的渲染到页面上之后，会自动调用mounted函数</li><li>当组件被销毁完毕之后，会自动调用unmounted函数。</li></ul>\n<pre><code class=\"prism language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3&gt;LifeCycle 组件&lt;/h3&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    name:'LifeCycle',\n    // 组件在内存中被创建完毕了\n    created(){\n        console.log(`created:组件在内存中被创建完毕了`);\n    },\n    // 组件第一次被渲染到页面上\n    mounted(){\n        console.log(`mounted:组件第一次被渲染到了页面上`);\n    },\n    // 组件被销毁完毕了\n    unmounted(){\n        console.log(`unmounted:组件被销毁完毕了`);\n    }\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code class=\"prism language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;App根组件&lt;/h1&gt;\n        &lt;hr&gt;\n        &lt;button @click=\"flag = !flag\"&gt;toggle&lt;/button&gt;\n        &lt;life-cycle v-if=\"flag\"&gt;&lt;/life-cycle&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport LifeCycle from \"./life-cycle.vue\"\nexport default {\n    name: 'MyApp',\n    data(){\n        return{\n            flag:true\n        }\n    },\n    components: {\n        LifeCycle\n    }\n}\n&lt;/script&gt;\n</code></pre>\n<br/>\n<h3><a id=\"523__182\"></a>5.2.3 如何监听组件的更新</h3>\n<p><strong>说明</strong>：一旦组件中的data数据源发生变化，vue会自动重新渲染组件的DOM结构，从而保证View视图展示的数据和Model数据源保持一致。当组件被重新渲染完毕后，会自动调用updated生命周期函数。</p>\n<br/>\n<h3><a id=\"524__188\"></a>5.2.4 组件生命周期函数</h3>\n<p><strong>说明</strong>：在之前学习的四个周期函数之前加上before，即可出现另外四个生命周期函数。</p>\n<p><img alt=\"image-20220828091256028\" src=\"..\\..\\static\\image\\cbb7911d793fb46ed3834c798d06c2fa.png\"/></p>\n<br/>\n<h2><a id=\"53__196\"></a>5.3 数据共享</h2>\n<h3><a id=\"531__198\"></a>5.3.1 组件之间的关系</h3>\n<p><strong>说明</strong>：在项目开发中，组件之间的关系分为如下三种：</p>\n<ul><li>父子关系</li><li>兄弟关系</li><li>后代关系</li></ul>\n<br/>\n<h3><a id=\"532__208\"></a>5.3.2 父子组件</h3>\n<p><strong>父组件向子组件共享数据</strong>：父组件使用v-bind指令来向子组件共享数据，子组件需要使用props选项来接收数据。</p>\n<p><strong>子组件向父组件共享数据</strong>：子组件可以通过自定义事件的方式向父组件共享数据。</p>\n<p><strong>父子组件之间数据双向同步</strong>：通过v-model指令来维护组件内外数据的双向同步。</p>\n<br/>\n<h3><a id=\"533__218\"></a>5.3.3 兄弟组件</h3>\n<p><strong>说明</strong>：兄弟组件之间实现数据共享的方案是EventBus。可以借助于第三方的包mitt来创建eventBus对象，从而实现兄弟组件之间的数据共享。</p>\n<p><strong>示意图</strong>：</p>\n<p><img alt=\"image-20220828093406039\" src=\"..\\..\\static\\image\\b4248521b59c5e47f24fec07546be23c.png\"/></p>\n<p><strong>安装mitt依赖包</strong>：<code>npm install mitt</code></p>\n<p><strong>使用步骤</strong>：</p>\n<ol><li>新建一个EventBus.js文件，在里面创建mitt实例，并默认导出</li><li>在数据接收方的created生命周期钩子中调用<code>mitt实例对象.on('事件名称',要接收的数据)</code>自定义一个事件，通过事件处理函数的形参来接收数据。</li><li>在数据发送方，调用<code>bus.emit('事件名称',要发送的数据)</code>方法触发自定义事件。</li></ol>\n<br/>\n<h3><a id=\"534_Prop_236\"></a>5.3.4 Prop逐级透传问题</h3>\n<p><strong>说明</strong>：通常情况下，当我们需要从父组件向子组件传递数据时，会使用 <code>props</code>。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：</p>\n<p><img alt=\"image-20220828100344487\" src=\"..\\..\\static\\image\\9ee95ab839420e4f1a7fb26fbb381d2f.png\"/></p>\n<p>如上图在传递的过程中，可能Footer组件根本不关心这些props，但为了DeepChild的使用，它必须接收并且继续往下传递，如果组件的链路非常长，可能会影响到这条路上更多的组件，这一问题被称为prop逐级透传，我们希望避免这种情况。</p>\n<br/>\n<h3><a id=\"535__246\"></a>5.3.5 后代组件</h3>\n<p><strong>说明</strong>：如果仅仅只是父子关系，那么使用props和v-bind或许是一种不错的策略，但如果要接收数据的组件离发送数据的组件很远(链路很长)，使用props就会导致逐级透传问题，这时候我们可以使用<code>provide</code>和<code>inject</code>来解决这一问题。</p>\n<p><strong>provide选项</strong>：provide是一个函数，和data一样返回一个共享的数据对象。对于provide对象上的每一个属性，后代组件都会用其key为注入名查找期望注入的值，属性的值就是要提供的数据。</p>\n<p><strong>inject选项</strong>：inject是一个数组，用于接收provide提供的共享数据，根据provide返回的对象中属性的键进行查找。</p>\n<br/>\n<h3><a id=\"536_Provide_256\"></a>5.3.6 基于Provide向下共享响应式的数据</h3>\n<br/>\n<h3><a id=\"537_vuex_260\"></a>5.3.7 vuex</h3>\n<p><strong>说明</strong>：vuex是终极的组件之间的共享方案。在企业级的vue项目开发中，vuex可以让组件之间的数据共享变得高效、清晰、且易于维护。</p>\n<br/>\n<h2><a id=\"54_axios_266\"></a>5.4 全局配置axios</h2>\n<p><strong>引入</strong>：在实际项目中，几乎每个组件都会使用axios发起数据请求，此时会遇到两个问题：</p>\n<ul><li>每个组件中都需要导入axios</li><li>每次发请求都需要填写完整的请求路径</li></ul>\n<p><strong>说明</strong>：想要全局配置axios可以在main.js入口文件中，通过app.config.globalProperties全局挂载axios。</p>\n<p><strong>格式</strong>：app.config.globalProperties.$http</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-28 11:22:48", "summary": "组件高级上摘要在本文中，我们会详细讨论侦听器的基本使用，并且了解中常用的生命周期函数、实现组件之间的数据共享，最后学习如何在项目中全局配置。声明：为了文章的清爽性，在文章内部的代码演示中只会附上部分演"}