{"blogid": "122112440", "writerAge": "码龄3年", "writerBlogNum": "17", "writerCollect": "205", "writerComment": "12", "writerFan": "11", "writerGrade": "2级", "writerIntegral": "249", "writerName": "zyy_demon", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122112440.jpg", "writerRankTotal": "142557", "writerRankWeekly": "695346", "writerThumb": "61", "writerVisitNum": "37411", "blog_read_count": "28641", "blog_time": "于 2021-12-23 18:48:58 发布", "blog_title": "索引失效的情况及解决(超详细)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>大家都知道，一条查询语句走了索引和没走索引的查询效率是非常大的，在我们建好了表，建好了索引后，但是一些不好的sql会导致我们的索引失效，下面介绍一下索引失效的几种情况</p>\n<p>数据准备 </p>\n<p>新建一张学生表，并添加id为主键索引，name为普通索引，(name,age)为组合索引</p>\n<pre><code class=\"language-sql\">CREATE TABLE `student` (\n  `id` int NOT NULL COMMENT 'id',\n  `name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '姓名',\n  `age` int DEFAULT NULL COMMENT '年龄',\n  `birthday` datetime DEFAULT NULL COMMENT '生日',\n  PRIMARY KEY (`id`),\n  KEY `idx_name` (`name`) USING BTREE,\n  KEY `idx_name_age` (`name`,`age`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;</code></pre>\n<p>插入数据</p>\n<pre><code class=\"language-sql\">INSERT INTO `student` VALUES (1, '张三', 18, '2021-12-23 17:12:44');\nINSERT INTO `student` VALUES (2, '李四', 20, '2021-12-22 17:12:48');</code></pre>\n<h2>1.查询条件中有or,即使有部分条件带索引也会失效</h2>\n<p>例：</p>\n<pre><code class=\"language-sql\">explain SELECT * FROM `student` where id =1 </code></pre>\n<p><img alt=\"\" height=\"90\" src=\"..\\..\\static\\image\\72dda8a93ef54422af1e40810584bdef.png\" width=\"940\"/></p>\n<p> 此时命中主键索引，当查询语句带有or后</p>\n<p></p>\n<pre><code>explain SELECT * FROM `student` where id =1 or birthday = \"2021-12-23\"</code></pre>\n<p><img alt=\"\" height=\"54\" src=\"..\\..\\static\\image\\f647ac923839488da4efbf315a95f25e.png\" width=\"934\"/></p>\n<p> 发现此时type=ALL,全表扫描，未命中索引</p>\n<p><span style=\"color:#fe2c24;\">总结：查询条件中带有or,除非所有的查询条件都建有索引，否则索引失效</span></p>\n<h2><span style=\"color:#0d0016;\">2.like查询是以%开头</span></h2>\n<p><span style=\"color:#0d0016;\">例</span></p>\n<pre><code class=\"language-sql\">explain select * from student where name = \"张三\"</code></pre>\n<p><img alt=\"\" height=\"84\" src=\"..\\..\\static\\image\\5d28d27d0e3d4d1aa9c687a4989e4a8d.png\" width=\"981\"/></p>\n<p>非模糊查询，此时命中name索引，当使用模糊查询后</p>\n<pre><code class=\"language-sql\">explain select * from student where name like \"%三\"\n</code></pre>\n<p> <img alt=\"\" height=\"69\" src=\"..\\..\\static\\image\\931a945acf8d4d1b9d1f7d0baaf8064f.png\" width=\"967\"/></p>\n<p> 发现此时type=ALL，全表扫描，未命中索引</p>\n<h2>3.如果列类型是字符串，那在查询条件中需要将数据用引号引用起来，否则不走索引</h2>\n<p>例</p>\n<pre><code class=\"language-sql\">explain select * from student where name = \"张三\"</code></pre>\n<p><img alt=\"\" height=\"76\" src=\"..\\..\\static\\image\\2ae030b19acc434aafbe994f4398f747.png\" width=\"927\"/>此时命中name索引，当数据未携带引号后</p>\n<pre><code class=\"language-sql\">explain select * from student where name = 2222</code></pre>\n<p><img alt=\"\" height=\"72\" src=\"..\\..\\static\\image\\ec5d27efdefb4ecb9e06b337e5ea141e.png\" width=\"964\"/> 此时未命中name索引，全表扫描</p>\n<p><span style=\"color:#fe2c24;\">总结：字符串的索引字段在查询是数据需要用引号引用</span></p>\n<h2><span style=\"color:#0d0016;\">4.索引列上参与计算会导致索引失效</span></h2>\n<p><span style=\"color:#0d0016;\">例</span></p>\n<pre><code class=\"language-sql\">explain select * from student where id-1 = 1</code></pre>\n<p><img alt=\"\" height=\"76\" src=\"..\\..\\static\\image\\fa8d161364d546a89c6c221c551122e8.png\" width=\"958\"/>查询条件为id，但是并没有命中主键索引，因为在索引列上参与了计算 </p>\n<p>正例</p>\n<pre><code class=\"language-sql\">select * from student where id = 2</code></pre>\n<p><span style=\"color:#fe2c24;\"> 总结：将参与计算的数值先算好，再查询</span></p>\n<h2>5.违背最左匹配原则</h2>\n<p>例</p>\n<pre><code class=\"language-sql\">explain select * from student where age =18</code></pre>\n<p><img alt=\"\" height=\"73\" src=\"..\\..\\static\\image\\7dd96ac9ec6240b1a1e7139f2db60160.png\" width=\"923\"/>age的索引是和建立再(name,age)组合索引的基础上，当查询条件中没有第一个组合索引的字段(name)会导致索引失效</p>\n<p>正例</p>\n<pre><code class=\"language-sql\">explain select * from student where age =18 and name =\"张三\"</code></pre>\n<p><img alt=\"\" height=\"75\" src=\"..\\..\\static\\image\\8484a4a47095410b8d653baef0e12287.png\" width=\"913\"/></p>\n<p> 此时才会命中name和(name,age)这个索引</p>\n<h2>6.如果mysql估计全表扫描要比使用索引要快，会不适用索引</h2>\n<h2>7.other</h2>\n<blockquote>\n<p>1) 没有查询条件，或者查询条件没有建立索引 </p>\n<p>2) 在查询条件上没有使用引导列 </p>\n<p>3) 查询的数量是大表的大部分，应该是30％以上。 </p>\n<p>4) 索引本身失效</p>\n<p>5) 查询条件使用函数在索引列上，或者 对索引列进行运算， 运算包括(+，-，*，/，! 等) 错误的例子：select * from test where id-1=9; 正确的例子：select * from test where id=10; </p>\n<p>6) 对小表查询 </p>\n<p>7) 提示不使用索引</p>\n<p>8) 统计数据不真实 </p>\n<p>9) CBO计算走索引花费过大的情况。其实也包含了上面的情况，这里指的是表占有的block要比索引小。 </p>\n<p>10)隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效. 错误的例子：select * from test where tu_mdn=13333333333; 正确的例子：select * from test where tu_mdn='13333333333'; </p>\n<p>12) 1,&lt;&gt; 2,单独的&gt;,&lt;,(有时会用到，有时不会) </p>\n<p>13,like \"%_\" 百分号在前. </p>\n<p>4,表没分析. </p>\n<p>15,单独引用复合索引里非第一位置的索引列. </p>\n<p>16,字符型字段为数字时在where条件里不添加引号. </p>\n<p>17,对索引列进行运算.需要建立函数索引. </p>\n<p>18,not in ,not exist. </p>\n<p>19,当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。 </p>\n<p>20,B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走 </p>\n<p>21,联合索引 is not null 只要在建立的索引列（不分先后）都会走, in null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时,其他建立索引的列可以是is null（但必须在所有列 都满足is null的时候）,或者=一个值； 当建立索引的第一位置是=一个值时,其他索引列可以是任何情况（包括is null =一个值）,以上两种情况索引都会走。其他情况不会走。</p>\n</blockquote>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2021-12-23 18:48:58", "summary": "大家都知道，一条查询语句走了索引和没走索引的查询效率是非常大的，在我们建好了表，建好了索引后，但是一些不好的会导致我们的索引失效，下面介绍一下索引失效的几种情况数据准备新建一张学生表，并添加为主键索引"}