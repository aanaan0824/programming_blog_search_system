{"blogid": "126635311", "writerAge": "码龄2年", "writerBlogNum": "306", "writerCollect": "844", "writerComment": "197", "writerFan": "29065", "writerGrade": "5级", "writerIntegral": "4405", "writerName": "RT-Thread物联网操作系统", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126635311.jpg", "writerRankTotal": "3721", "writerRankWeekly": "9284", "writerThumb": "249", "writerVisitNum": "237741", "blog_read_count": "148", "blog_time": "于 2022-08-31 18:33:05 发布", "blog_title": "Arduino库可以直接在RT-Thread上运行啦！", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div id=\"js_content\">\n<p style=\"text-align:center;\"><img alt=\"ea8c396043e538f2f6728ae537d04c0c.png\" src=\"..\\..\\static\\image\\ea8c396043e538f2f6728ae537d04c0c.png\"/></p>\n<h2>1 简介</h2>\n<p>RTduino为RT-Thread的Arduino生态兼容层，是RT-Thread社区的下属子社区，旨在兼容Arduino社区生态（如上千种分门别类的Arduino库，以及Arduino社区优秀的开源项目），来丰富RT-Thread社区软件包生态，并降低RT-Thread操作系统以及与RT-Thread适配的芯片的学习门槛。可以让用户通过Arduino的函数和编程方法，轻松地将RT-Thread以及特定的芯片使用起来。用户也可以直接使用Arduino社区的库（例如I2C传感器驱动库、算法库等）直接用在RT-Thread工程中，极大地补充了RT-Thread社区生态。该项目由RT-Thread社区核心开发和维护者满鉴霆发起。</p>\n<p>本软件包可以运行在RT-Thread Studio IDE和Keil编译环境下，因为Arduino的库都是基于GCC环境开发的，因此<strong>强烈推荐</strong>使用RT-Thread Studio IDE运行。</p>\n<h3>1.1 已经支持Arduino生态兼容层的RT-Thread BSP</h3>\n<table><thead><tr><th width=\"65\">BSP名称</th><th width=\"370\">备注</th></tr></thead><tbody><tr><td width=\"77\">STM32L475潘多拉</td><td width=\"358\">引脚异构布局，但外设丰富</td></tr><tr><td width=\"89\">STM32F072 Nucleo</td><td width=\"358\">标准Arduino UNO引脚布局</td></tr><tr><td width=\"101\">STM32F401 Nucleo</td><td width=\"358\">标准Arduino UNO引脚布局</td></tr><tr><td width=\"113\">STM32F469 Discovery</td><td width=\"358\">标准Arduino UNO引脚布局</td></tr><tr><td width=\"125\">STM32F103 BluePill</td><td width=\"358\">引脚异构布局</td></tr><tr><td width=\"137\">ES32F3696</td><td width=\"358\">引脚异构布局</td></tr></tbody></table>\n<blockquote>\n<p>注：RTduino也可以无需适配特定BSP，直接运行在任意RT-Thread BSP上，请参考第5章-RTduino精简模式。</p>\n</blockquote>\n<h2>2 如何使用本兼容层</h2>\n<p>本软件包需要对特定的BSP进行适配之后才可以使用，适配方法很简单请参考。本节以STM32L475潘多拉开发板和RT-Studio开发环境为例，来讲解如何使用本兼容层。</p>\n<h3>2.1 参考资料</h3>\n<ul><li><p>2022年RT-Thread全球开发者大会报告视频</p></li></ul>\n<h3>2.2 工程的创建和导入</h3>\n<p>请到RT-Thread Github官方仓库，下载最新的源码。对于部分用户下载Github源码慢的问题，可以百度或者到B站搜索“Github加速”等关键字来解决，此处不再赘述。</p>\n<p style=\"text-align:center;\"><img alt=\"fd01513eb1dce58d21d9ebe455c47a21.png\" src=\"..\\..\\static\\image\\fd01513eb1dce58d21d9ebe455c47a21.png\"/></p>\n<p>下载好之后请解压，打开RT-Studio IDE，选择文件(File) -&gt; 导入(Import)，并选择RT-Thread BSP Project into Workspace，也就是将BSP工程导入到Studio的选项。</p>\n<p><br/></p>\n<p style=\"text-align:center;\"><img alt=\"6166a4d0c00c295431ed9bcba47c6bf3.png\" src=\"..\\..\\static\\image\\6166a4d0c00c295431ed9bcba47c6bf3.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"b652a5e513501c9510df074eda138745.png\" src=\"..\\..\\static\\image\\b652a5e513501c9510df074eda138745.png\"/></p>\n<p>路径选择，你刚刚下载解压好的RT-Thread源码，以STM32L475潘多拉板为例：<code>rt-thread\\bsp\\stm32\\stm32l475-atk-pandora</code>。工程名字随便起一个就好，比如<code>STM32</code>：</p>\n<p style=\"text-align:center;\"><img alt=\"40c74340e12d2635d408aaf9d1db6a29.png\" src=\"..\\..\\static\\image\\40c74340e12d2635d408aaf9d1db6a29.png\"/></p>\n<p>点击完成(Finish)，稍等片刻即可完成工程导入。</p>\n<p>导入成功之后，双击RT-Thread Settings，进入到RT-Thread工程配置界面，点击&lt;&lt;按钮，进入到详细配置页面：</p>\n<p style=\"text-align:center;\"><img alt=\"c0b5885c94838ec08fdf01e00045f32e.png\" src=\"..\\..\\static\\image\\c0b5885c94838ec08fdf01e00045f32e.png\"/></p>\n<figcaption></figcaption>\n<p style=\"text-align:center;\"><img alt=\"370d7591f13ee2170a16821687368260.png\" src=\"..\\..\\static\\image\\370d7591f13ee2170a16821687368260.png\"/></p>\n<br/>\n<figcaption></figcaption>\n<p>点击Hardware，选择Support Arduino，只需要点一下即可，其他依赖项会自动处理。然后点击小锤子按钮进行编译，RT-Thread Studio会自动保存你当前的配置并下载RTduino软件包以及依赖项软件包，并将这些软件包加入到工程中，最后自动编译整个工程。</p>\n<p>总的来讲，你只需要选择Support Arduino，并点一下小锤子按钮，就坐等编译成功即可。</p>\n<p style=\"text-align:center;\"><img alt=\"1b0ed7f5f943be83ca5be83bc7926706.png\" src=\"..\\..\\static\\image\\1b0ed7f5f943be83ca5be83bc7926706.png\"/></p>\n<p>至此，RTduino软件包安装完成，此BSP工程已经具备了兼容Arduino生态的能力。</p>\n<h3>2.3 RTduino文件夹目录结构</h3>\n<p><strong>RTduino软件包包含有两个主要的文件夹：core和libraries。</strong></p>\n<ul><li><p>core文件夹主要是提供Arduino内置的所有的API函数，例如analogWrite、analogRead函数等等，这些函数可以在Arduino官方找到详细的介绍。</p></li><li><p>libraries文件夹是Arduino库所在文件夹。其中：</p></li><li><p>buildin文件夹下存放着Arduino内置的一些库，例如Servo舵机驱动库，Wire I2C驱动库等等；</p></li><li><p>user文件夹是用户文件夹，这是对用户来说很重要的一个文件夹，里边默认是空的，用户可以把下载好的Arduino库拖入到此文件夹中来，在下个章节会细说这个操作。</p></li></ul>\n<h3>2.4 Arduino经典的setup和loop函数在哪里？</h3>\n<p>对于Arduino，最经典的莫过于setup和loop函数。这两个函数位于BSP目录下的applications文件夹内arduino_main.cpp文件中。以潘多拉板为例，这两个函数位于：</p>\n<p><code>bsp/stm32/stm32l475-atk-pandora/applications/arduino_main.cpp</code>文件中，在开启RTduino软件包后，你可以直接在工程的Applications组中找到它。</p>\n<h3>2.5 点一个LED灯吧！</h3>\n<pre class=\"has\"><code class=\"language-go\">1#include &lt;Arduino.h&gt;\n 2\n 3void setup(void)\n 4{\n 5    // put your setup code here, to run once:\n 6    pinMode(LED_BUILTIN, OUTPUT);\n 7}\n 8\n 9void loop(void)\n10{\n11    // put your main code here, to run repeatedly:\n12    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n13    Serial.println(\"Hello Arduino!\");\n14    delay(100);\n15}</code></pre>\n<p>可以看到，板载的LED灯已经开始闪烁，串口开始输出了。</p>\n<blockquote>\n<p>注意：</p>\n<p>由于RT-Thread的main.c文件内，也会默认闪烁一个LED灯，如果板子上只有一个LED灯的话，两个线程会发生干涉。但是你会发现这个LED的闪烁速度明显变快了。因为main.c那边的闪烁周期是1000ms，上面这个例程是200ms。</p>\n<p>如果你用潘多拉板，main.c闪烁的是红灯，RTduino兼容层的Arduino程序默认闪烁的是绿色的灯，二者不会发生干扰。</p>\n</blockquote>\n<h3>2.6 具体Arduino引脚分布信息</h3>\n<p>由于每个BSP的板子设计、以及芯片型号等，引脚分布是有区别的，因此需要到指定BSP的<code>applications/arduino</code>文件夹下的README.md文件查看详细信息。例如：</p>\n<p>STM32L475潘多拉板的Arduino引脚布局的详细说明 | STM32F072 Nucleo板的Arduino引脚布局的详细说明</p>\n<h2>3 Arduino库的导入和使用</h2>\n<h3>3.1 术语说明</h3>\n<p>软件包：英文为 software package，是指RT-Thread社区所属维护的第三方扩展，是RT-Thread原生生态一部分。</p>\n<p>库：英文为library，是指Arduino社区所属维护的第三方扩展，是Arduino原生生态一部分。</p>\n<blockquote>\n<p>库和软件包其实是一个意思，只不过两个社区叫法不一样。</p>\n</blockquote>\n<h3>3.2 RTduino兼容层对Arduino库的兼容情况</h3>\n<p>目前RTduino兼容层可以实现对Arduino纯软件类（例如算法类、数据处理类等）、串口相关、I2C传感器相关的库做到100%兼容。</p>\n<p>支持的详细情况和计划，请查看：</p>\n<p>https://github.com/RTduino/RTduino/discussions/26</p>\n<h3>3.3 导入一个Arduino库到RT-Thread工程（以潘多拉板为例）</h3>\n<p>首先，你需要到Arduino官方的软件包分类中心去查找你想要的库，或者直接在Github上搜索你想要的库，一般都是C++类型的。比如，我想要一个驱动AHT10温湿度传感器的库，可以在此处下载。此处以潘多拉板为例，因为潘多拉板板载了AHT10传感器。</p>\n<p>下载好之后，直接将zip压缩包拖进RTduino文件夹下的<code>libraries\\user</code>这个目录下即可。选择当前工程右键选择Sync Sconscript to project也就是让RT-Studio重新扫描并组织一遍工程目录，在扫描的过程中，RT-Studio会自动将zip压缩包解压，并按照Arduino IDE的文件添加逻辑（也就是忽略examples文件夹，并将其他文件夹的.c文件和.h路径添加到工程），将Arduino库添加到RT-Thread工程中来。</p>\n<p>然后再点一下小锤子按钮来重新编译一下工程。</p>\n<p style=\"text-align:center;\"><img alt=\"df276fcb92e11d420e83a632ea91d805.png\" src=\"..\\..\\static\\image\\df276fcb92e11d420e83a632ea91d805.png\"/></p>\n<p>工程编译通过之后，你可以将这个AHT10 Arduino库的例程（位于该库文件夹下的examples文件夹）直接复制到arduino_main.cpp文件下运行，你可以看到，串口会输出当前的温湿度，Arduino的例程是直接可以在RT-Thread上运行起来的。</p>\n<h3>3.4 RTduino内置库</h3>\n<p>在RTduino中内置了两类库，方便用户直接使用。</p>\n<p>一类是在Arduino中原生内建(buildin)的库，存放于 <code>libraries/buildin</code> 文件夹内。具体如下表所示：</p>\n<img alt=\"1c6829f9785ad4ee5dab4b679b86ec23.png\" src=\"..\\..\\static\\image\\1c6829f9785ad4ee5dab4b679b86ec23.png\"/>\n<h2>4 如何给某个BSP适配RTduino</h2>\n<h3>4.1 创建文件夹和文件</h3>\n<p>需要在某个BSP的applications文件夹下创建如下文件、文件夹：</p>\n<p>参考示例BSP：STM32F072 Nucleo板applications文件夹 | STM32L475 潘多拉板applications文件夹</p>\n<h4>4.1.1 arduino_main.cpp文件</h4>\n<p>该文件是Arduino的编程入口，提供setup和loop函数。在loop函数默认以200ms为周期，闪烁Arduino内建LED灯（LED_BUILTIN）。如果该BSP默认支持SPI功能且为UNO引脚布局，由于SPI和LED_BUILTIN可能存在冲突(D13)，可以在loop函数内以 <code>Serial.println(\"Hello Arduino\\n\");</code> 代替频闪LED（例如STM32F401 Nucleo板）。</p>\n<h4>4.1.2 arduino_pinout文件夹</h4>\n<p>需要在applications文件夹下创建arduino_pinout文件夹，这个文件夹主要包含 <code>arduino_pinout.c</code> 和 <code>arduino_pinout.h</code> 两个关键的文件，这两个文件是对接的关键。用户只需要做好这两个文件，即可完成与RTduino的对接。</p>\n<p>同时，这个文件夹内也需要SConscript脚本文件，以及提供Arduino引脚布局的README说明文档。请参照上面的示例BSP来完成对这两个文件的编写。</p>\n<h4>4.1.3 arduino_pinout.c 文件的编写</h4>\n<p><code>arduino_pinout.c</code> 内需要完成一个IO编号和功能的映射表。由于Arduino的习惯是采用1-13 (D0-D13) 以及 A0-A5的引脚编号，而正规的MCU的引脚编号一般都是PA1之类，因此需要将MCU真正的引脚编号与Arduino引脚编号映射起来。</p>\n<p>以下段代码来举例讲解：</p>\n<pre class=\"has\"><code class=\"language-go\">1/*\n 2    {Arduino Pin, RT-Thread Pin [, Device Name(PWM or ADC), Channel]}\n 3    [] means optional\n 4    Digital pins must NOT give the device name and channel.\n 5    Analog pins MUST give the device name and channel(ADC, PWM or DAC).\n 6    Arduino Pin must keep in sequence.\n 7*/\n 8/* 按照先数字引脚后模拟引脚的顺序从0开始，一定要按序排列 */\n 9/* 可以按照板卡实际IO情况，灵活调整功能，不一定非得按照Arduino UNO的引脚功能布局，但是建议按此布局设计 */\n10const pin_map_t pin_map_table[]=\n11{\n12    {D0}, /* RX */\n13    {D1}, /* TX */\n14    {D2, GET_PIN(A,10)},\n15    {D3, GET_PIN(B,3), \"pwm2\", 2}, /* PWM */\n16    {D4, GET_PIN(B,5)},\n17    {D5, GET_PIN(B,4), \"pwm3\", 1}, /* PWM */\n18    {D6, GET_PIN(B,10), \"pwm2\", 3}, /* PWM */\n19    {D7, GET_PIN(A,8)},\n20    {D8, GET_PIN(A,9)},\n21    {D9, GET_PIN(C,7), \"pwm3\", 2}, /* PWM */\n22    {D10, GET_PIN(B,6), \"pwm16\", 1}, /* PWM */\n23    {D11, GET_PIN(A,7), \"pwm17\", 1}, /* PWM */\n24    {D12, GET_PIN(A,6)},\n25    {D13, GET_PIN(A,5)},\n26    {D14}, /* I2C1-SDA */\n27    {D15}, /* I2C1-SCL */\n28    {D16, GET_PIN(C,13)}, /* user button */\n29    {A0, GET_PIN(A,0), \"adc1\", 0}, /* ADC */\n30    {A1, GET_PIN(A,1), \"adc1\", 1}, /* ADC */\n31    {A2, GET_PIN(A,4), \"adc1\", 4}, /* ADC */\n32    {A3, GET_PIN(B,0), \"adc1\", 8}, /* ADC */\n33    {A4, GET_PIN(C,1), \"adc1\", 11}, /* ADC */\n34    {A5, GET_PIN(C,0), \"adc1\", 10}, /* ADC */\n35}</code></pre>\n<p>如上截取展示了IO编号和功能映射表，每一行用花括号包裹（实际是一个结构体）来建议一个IO的映射关系：</p>\n<pre class=\"has\"><code class=\"language-go\">1{Arduino引脚编号, RT-Thread引脚编号(通过GET_PIN宏获取), 复用功能的设备名(PWM、ADC或DAC), 该复用功能设备的通道号}</code></pre>\n<p>其中，Arduino引脚编号，即是第一个参数，是必填的，D0 - Dx 或者是 A0 - Ax。注意一定要按先数字引脚后模拟引脚照顺序来填写。</p>\n<p>RT-Thread引脚编号，即第二个参数，rt_pin_write中引脚编号填什么，这里就填什么，一般使用 <code>GET_PIN</code> 宏来获取。注意：D0、D1以及I2C、SPI IO需要将此参数略过。</p>\n<p>后两个参数是复用功能IO才需要填写的，普通引脚只需要略过即可。</p>\n<h4>4.1.4 arduino_pinout.h 文件的编写</h4>\n<p>参考示例BSP：STM32L475 潘多拉板applications文件夹</p>\n<p>该文件主要负责定义各种宏，包括：</p>\n<p>D0、A0等引脚的数字宏，该宏一定要按照先数字引脚后模拟引脚的顺序进行排号。</p>\n<p><strong>定义默认开启的一些硬件功能，如下表所示：</strong></p>\n<pre class=\"has\"><code class=\"language-go\">1/* pins alias. Must keep in sequence */\n 2/* 按照先数字引脚后模拟引脚的顺序从0开始，一定要按序排列 */\n 3/* 可以按照板卡实际IO情况，灵活调整功能，不一定非得按照Arduino UNO的引脚功能布局，但是建议按此布局设计 */\n 4#define D0   (0)\n 5#define D1   (1)\n 6#define D2   (2)\n 7#define D3   (3)\n 8#define D4   (4)\n 9#define D5   (5)\n10#define D6   (6)\n11#define D7   (7)\n12#define D8   (8)\n13#define D9   (9)\n14#define D10  (10)\n15#define D11  (11)\n16#define D12  (12)\n17#define D13  (13)\n18#define D14  (14)\n19#define D15  (15)\n20#define D16  (16)\n21#define D17  (17)\n22#define D18  (18)\n23#define D19  (19)\n24#define D20  (20)\n25#define D21  (21)\n26#define D22  (22)\n27#define D23  (23)\n28#define D24  (24)\n29#define D25  (25)\n30#define D26  (26)\n31#define D27  (27)\n32#define D28  (28)\n33#define D29  (29)\n34#define D30  (30)\n35#define D31  (31)\n36#define D32  (32)\n37#define A0   (33)\n38#define A1   (34)\n39#define A2   (35)\n40#define A3   (36)\n41#define DAC0 (37)\n42\n43#define F_CPU  80000000L /* CPU: 80MHz，定义CPU的主频 */\n44#define LED_BUILTIN  D22 /* Default Built-in LED，定义Arduino内置LED的引脚编号 */\n45\n46/* 定义I2C设备名称，在使用Wire库时会直接调用。可选，如果没有I2C功能，不需要定义该宏 */\n47#define RTDUINO_DEFAULT_IIC_BUS_NAME            \"i2c4\"\n48\n49/* 定义SPI设备名称，在使用SPI库时会直接调用。可选，如果没有SPI功能，不需要定义该宏 */\n50#define RTDUINO_DEFAULT_SPI_BUS_NAME            \"spi2\"\n51\n52/* \n53   定义高精度定时器设备名称，该宏主要是提供us时基信号使用。\n54   所有Cortex-M核MCU均不需要定义此宏，RTduino会自动调用systick来计算us级时间戳。\n55   非Cortex-M核的MCU需要提供一个硬件定时器来提供us级时间戳。\n56 */\n57#define RTDUINO_DEFAULT_HWTIMER_DEVICE_NAME     \"timer7\"\n58\n59/* 如果有串口2、串口3可以定义串口2、3的设备名称，若没有可直接不定义此宏 */\n60#define RTDUINO_SERIAL2_DEVICE_NAME             \"uart2\"</code></pre>\n<h3>4.2 修改Kconfig文件</h3>\n<p>Kconfig文件位于BSP的board文件夹下：</p>\n<p>参考示例BSP：</p>\n<p>STM32F072 Nucleo板Kconfig | STM32L475 潘多拉板Kconfig</p>\n<pre class=\"has\"><code class=\"language-go\">1menu \"Onboard Peripheral Drivers\"\n 2    config BSP_USING_STLINK_TO_USART\n 3        bool \"Enable STLINK TO USART (uart2)\"\n 4        select BSP_USING_UART\n 5        select BSP_USING_UART2\n 6        default y\n 7\n 8    #增加 BSP_USING_ARDUINO 配置选项\n 9    config BSP_USING_ARDUINO\n10        bool \"Support Arduino\"\n11        select PKG_USING_RTDUINO\n12        select BSP_USING_STLINK_TO_USART\n13        select BSP_USING_GPIO\n14        select BSP_USING_ADC\n15        select BSP_USING_ADC1\n16        select BSP_USING_PWM\n17        select BSP_USING_PWM2\n18        select BSP_USING_PWM2_CH2\n19        select BSP_USING_PWM2_CH3\n20        select BSP_USING_PWM3\n21        select BSP_USING_PWM3_CH1\n22        select BSP_USING_PWM3_CH2\n23        select BSP_USING_PWM16\n24        select BSP_USING_PWM16_CH1\n25        select BSP_USING_PWM17\n26        select BSP_USING_PWM17_CH1\n27        select BSP_USING_I2C\n28        select BSP_USING_I2C1\n29        imply RTDUINO_USING_SERVO\n30        imply RTDUINO_USING_WIRE\n31        imply RTDUINO_USING_ADAFRUIT\n32        default n\n33\n34endmenu</code></pre>\n<p>需要在<code>Onboard Peripheral Drivers</code>栏下增加 <code>BSP_USING_ARDUINO</code> 配置选项，并依赖相应的PWM、ADC、UART、I2C以及SPI等设备框架，满足一键化开启RTduino的能力。</p>\n<h3>4.3 编写Arduino引脚布局(pinout)的README说明文档</h3>\n<p>示例：STM32F072 Nucleo的Arduino引脚布局说明文档 | STM32L475潘多拉的Arduino引脚布局说明文档</p>\n<p>该文档需位于<code>applications/arduino_pinout/README.md</code>，主要介绍该BSP下的Arduino引脚编号和引脚功能，以及注意事项等。</p>\n<h2>5 RTduino精简模式（快速使用，无需适配特定BSP）</h2>\n<h3>5.1 不使用setup-loop编程模型</h3>\n<p><code>setup()</code> 和 <code>loop()</code> 函数是Arduino编程中非常经典的函数，当你在Arduino IDE中新建一个文件时，默认就提供了这两个函数。这两个函数RTduino是完全支持的（参见第4章），但是一些较为复杂或庞大的业务逻辑如果放在setup-loop函数中就会受到一些束缚。因此，可以在Env或者RT-Thread Studio的RT-Thread Settings中取消setup-loop编程模型：</p>\n<pre class=\"has\"><code class=\"language-go\">1RT-Thread online packages  ---&gt;\n2    system packages  ---&gt;\n3         [*] RTduino: Arduino Ecological Compatibility Layer  ---&gt;\n4              [*]   Don't use setup-loop structure  ---&gt;</code></pre>\n<p>选择此选项后，用户可以直接在 <code>core/arduino_thread.c</code> 中的 <code>arduino_entry</code> 线程函数中直接编程，或者在任意.cpp文件中调用Arduino API（不局限于Arduino线程，只要是.cpp文件下调用即可）。</p>\n<h3>5.2 如何不用定义引脚映射表，更方便的使用RTduino？</h3>\n<p>通过上文，我们可以看到，RTduino软件包并不是直接可以用的，需要RT-Thread BSP方面提供一些配套的支持，如引脚映射表（arduino_pinout）等。但是，如果用户不想使用Arduino引脚（IO）相关的API（如analogRead等），只想借助RTduino软件包，来直接兼容运行I2C芯片驱动库、纯软件算法库等和IO无关的函数和库，如何快速的使用起来呢？</p>\n<p>用户可以直接在Env或者RT-Thread Studio的RT-Thread Settings中选择精简模式 (Enable tiny mode)。在选择精简模式后，用户就无需定义引脚映射表，直接就可以使用Arduino库中的非IO相关的函数和库了。开启精简模式后，会自动开启 5.1 章节所介绍的不使用setup-loop编程模型选项，用户可以在任意.cpp文件下使用Arduino API。</p>\n<pre class=\"has\"><code class=\"language-go\">1RT-Thread online packages  ---&gt;\n2    system packages  ---&gt;\n3         [*] RTduino: Arduino Ecological Compatibility Layer  ---&gt;\n4              -*-   Don't use setup-loop structure\n5              [*]   Enable tiny mode  ---&gt;</code></pre>\n<h3>5.3 常规模式（参见第4章）vs 精简模式（参见第5章）</h3>\n<p>下表列举了在两种不同模式下，RTduino对Arduino API的兼容情况：</p>\n<p style=\"text-align:center;\"><img alt=\"4a146e09ca5c6c8caed9d990fec49ec8.png\" src=\"..\\..\\static\\image\\4a146e09ca5c6c8caed9d990fec49ec8.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"65efad6a58c638a6c5ea724e45c7e066.png\" src=\"..\\..\\static\\image\\65efad6a58c638a6c5ea724e45c7e066.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"e738c1d34dd9ac33ea1a8891cff200fb.png\" src=\"..\\..\\static\\image\\e738c1d34dd9ac33ea1a8891cff200fb.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"483e152130b04a8a12a9f95640e742f4.png\" src=\"..\\..\\static\\image\\483e152130b04a8a12a9f95640e742f4.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"b967bf225f979bb64ecebc3a7d850ab4.png\" src=\"..\\..\\static\\image\\b967bf225f979bb64ecebc3a7d850ab4.png\"/></p>\n<blockquote>\n<p>注：SPI库目前还在施工中，暂不开放使用。</p>\n</blockquote>\n<h2>6 需要注意的事项</h2>\n<h3>6.1 包含Arduino.h头文件</h3>\n<p>调用到Arduino相关函数和宏的源文件，请包含Arduino.h头文件，否则可能会报错：</p>\n<p style=\"text-align:center;\"><img alt=\"42485e8ae0dd2480528cb7b6aa70fae5.png\" src=\"..\\..\\static\\image\\42485e8ae0dd2480528cb7b6aa70fae5.png\"/></p>\n<figcaption>\n<br/>\n</figcaption>\n<figcaption></figcaption>\n<p style=\"text-align:center;\"><img alt=\"1dbd86bcb518b0d78bb6e809757cb6e2.png\" src=\"..\\..\\static\\image\\1dbd86bcb518b0d78bb6e809757cb6e2.png\"/></p>\n<h3>6.2 Keil AC5</h3>\n<p>如果使用Keil AC5环境，需要勾选GNU extension。AC6不需要。</p>\n<h3>6.3 启用PWM不能调用pinMode函数，否则PWM会失效，ADC、DAC同理</h3>\n<pre class=\"has\"><code class=\"language-go\">1void setup() {\n 2  //Declaring LED pin as output\n 3  //pinMode(led_pin, OUTPUT); //不能设置为OUTPUT，否则PWM会失效\n 4}\n 5void loop() {\n 6  //Fading the LED\n 7  for(int i=0; i&lt;255; i++){\n 8    analogWrite(led_pin, i);\n 9    delay(5);\n10  }\n11  for(int i=255; i&gt;0; i--){\n12    analogWrite(led_pin, i);\n13    delay(5);\n14  }\n15}</code></pre>\n<p>因为底层已经将对应的PWM、ADC或DAC的IO设置为模拟输入或者复用推挽，调用pinMode之后把IO模式改成了纯输入输出，原有的PWM、ADC或DAC功能将无法使用。该问题无要修正，只需要知道调用analogRead和analogWrite的时候不需要设置pinMode即可。一旦调用pinMode，该引脚将丧失analogWrite或者analogRead功能，后续只能当做普通IO使用。</p>\n<p><strong>Arduino </strong><strong>官方文档</strong><strong>也是这么建议的：</strong></p>\n<pre class=\"has\"><code class=\"language-go\">1You do not need to call pinMode() to set the pin as an output before calling analogWrite().\n2The analogWrite function has nothing to do with the analog pins or the analogRead function.</code></pre>\n<p>用户如果对PWM、ADC或DAC引脚使用pinMode函数，在终端也会给出警告：</p>\n<p style=\"text-align:center;\"><img alt=\"38d43f44b6f6e331a4c3608cb7032061.png\" src=\"..\\..\\static\\image\\38d43f44b6f6e331a4c3608cb7032061.png\"/></p>\n<p>当然，如果用户已经知道这样做的后果，但是故意需要将PWM、ADC或DAC引脚通过pinMode函数转为普通IO也是完全可以的。</p>\n<h3>6.4 Serial.begin</h3>\n<p>在很多Arduino例程中，都喜欢使用如下语句来初始化串口：</p>\n<pre class=\"has\"><code class=\"language-go\">1  Serial.begin(9600);</code></pre>\n<p>这句话将串口默认初始化成波特率为9600. 但是在RT-Thread中，串口的初始化实际是有RT-Thread驱动框架负责的，并且默认波特率为115200. 因此如果调用<code>Serial.begin(9600)</code> 函数后，串口的波特率将会从默认的115200调整为9600。如果你的终端或者串口助手还保持在115200的波特率，那么接收数据将出现乱码。</p>\n<p><strong>因此建议：</strong></p>\n<p><strong></strong> 使用<code>Serial.begin()</code>代替<code>Serial.begin(9600)</code>。<code>Serial.begin()</code>无参数方法是RTduino的扩充方法，其表示跟随使用RT-Thread串口配置，不重新配置串口。</p>\n<h2>7 贡献与维护</h2>\n<h3>7.1 项目仓库地址</h3>\n<p style=\"text-align:left;\">https://github.com/RTduino/RTduino</p>\n<p style=\"text-align:left;\">https://gitee.com/rtduino/RTduino</p>\n<h3>如果喜欢请Star，这是对本开源项目最大的鼓励，谢谢；如果想要贡献PR，请fork</h3>\n<h3>7.2 感谢以下小伙伴对本仓库的贡献</h3>\n<p style=\"text-align:center;\"><img alt=\"708509c73db1b633f7ab6f5550a69bb6.png\" src=\"..\\..\\static\\image\\708509c73db1b633f7ab6f5550a69bb6.png\"/></p>\n<p style=\"text-align:center;\">查看全部名单请上GitHub</p>\n<p>END</p>\n<p style=\"text-align:center;\"><img alt=\"676b2d72d47393590064d67ec99ef226.jpeg\" src=\"..\\..\\static\\image\\676b2d72d47393590064d67ec99ef226.jpeg\"/></p>\n<p style=\"text-align:justify;\"><img alt=\"a72a2ea51d27ba8e3a6e6475fea423cf.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/a72a2ea51d27ba8e3a6e6475fea423cf.gif\"/><br/></p>\n<p style=\"text-align:right;\">爱我就给我点在看<strong><img alt=\"6435e3ad0a1b799982ecaa86c544483b.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/6435e3ad0a1b799982ecaa86c544483b.gif\"/></strong></p>\n<p style=\"text-align:left;\"><strong><img alt=\"8509761f35e5b42cffd8beeac76af264.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/8509761f35e5b42cffd8beeac76af264.gif\"/>点击 </strong><strong>“</strong><strong>阅读原文</strong><strong>”进入本项目</strong></p>\n</div>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-31 18:33:05", "summary": "简介为的生态兼容层，是社区的下属子社区，旨在兼容社区生态如上千种分门别类的库，以及社区优秀的开源项目，来丰富社区软件包生态，并降低操作系统以及与适配的芯片的学习门槛。可以让用户通过的函数和编程方法，轻"}