{"blogid": "124500224", "writerAge": "码龄3年", "writerBlogNum": "142", "writerCollect": "6895", "writerComment": "6780", "writerFan": "61500", "writerGrade": "7级", "writerIntegral": "14075", "writerName": "几何心凉", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124500224.jpg", "writerRankTotal": "681", "writerRankWeekly": "189", "writerThumb": "6461", "writerVisitNum": "329191", "blog_read_count": "3729", "blog_time": "已于 2022-06-07 09:21:11 修改", "blog_title": "一文带你了解React框架", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>前言</strong></p>\n<p>由于 React的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。</p>\n<p>这个项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次UI ，就能同时运行在服务器、浏览器和手机。<br/> React主要用于构建UI。你可以在React里传递多种类型的参数，如声明代码，帮助你渲染出UI、也可以是静态的HTML DOM元素、也可以传递动态变量、甚至是可交互的应用组件。</p>\n<p>React具备以下优势：<br/> 1.声明式设计：React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据变动时 React 能高效更新并渲染合适的组件<br/> 2.组件化: 构建管理自身状态的封装组件，然后对其组合以构成复杂的 UI。<br/> 3.高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。<br/> 4.灵活：无论你现在使用什么技术栈，在无需重写现有代码的前提下，通过引入 React 来开发新功能。</p>\n<p>让我们来一起学习吧！</p>\n<h1><a id=\"1_React_14\"></a>1. React入门</h1>\n<h2><a id=\"11_React_15\"></a>1.1. React的基本认识</h2>\n<pre><code>1). Facebook开源的一个js库\n2). 一个用来动态构建用户界面的js库\n3). React的特点\n\tDeclarative(声明式编码)\n\tComponent-Based(组件化编码)\n\tLearn Once, Write Anywhere(支持客户端与服务器渲染)\n\t高效\n\t单向数据流\n4). React高效的原因\n\t虚拟(virtual)DOM, 不总是直接操作DOM(批量更新, 减少更新的次数) \n\t高效的DOM Diff算法, 最小化页面重绘(减小页面更新的区域)\n</code></pre>\n<h2><a id=\"12_React_28\"></a>1.2. React的基本使用</h2>\n<pre><code>1). 导入相关js库文件(react.js, react-dom.js, babel.min.js)\n2). 编码:\n\t&lt;div id=\"container\"&gt;&lt;/div&gt;\n\t&lt;script type=\"text/babel\"&gt;\n\t\tvar aa = 123#  #\n\t\tvar bb = 'test'\n\t\tReactDOM.render(&lt;h1 id={bb}&gt;{aa}&lt;/h1&gt;, containerDOM)\n\t&lt;/script&gt;\n</code></pre>\n<h2><a id=\"13_JSX_38\"></a>1.3. JSX的理解和使用</h2>\n<pre><code>1). 理解\n\t* 全称: JavaScript XML\n\t* react定义的一种类似于XML的JS扩展语法: XML+JS\n\t* 作用: 用来创建react虚拟DOM(元素)对象\n2). 编码相关\n\t* js中直接可以套标签, 但标签要套js需要放在{}中\n\t* 在解析显示js数组时, 会自动遍历显示\n\t* 把数据的数组转换为标签的数组: \n\t\tvar liArr = dataArr.map(function(item, index){\n\t\t\treturn &lt;li key={index}&gt;{item}&lt;/li&gt;\n\t\t})\n3). 注意:\n    * 标签必须有结束\n    * 标签的class属性必须改为className属性\n    * 标签的style属性值必须为: {<!-- -->{color:'red', width:12}}\n\t\t* 必须只有一个根标签\n</code></pre>\n<h2><a id=\"14__58\"></a>1.4. 几个重要概念理解</h2>\n<h3><a id=\"1__59\"></a>1). 模块与组件</h3>\n<pre><code>1. 模块:\n  \t理解: 向外提供特定功能的js程序, 一般就是一个js文件\n  \t为什么: js代码更多更复杂\n  \t作用: 复用js, 简化js的编写, 提高js运行效率\n2. 组件: \n\t理解: 用来实现特定界面功能效果的代码集合(html/css/js/img)\n  \t为什么: 一个界面的功能太复杂了\n  \t作用: 复用编码, 简化项目界面编码, 提高运行效率\n</code></pre>\n<h3><a id=\"2__68\"></a>2). 模块化与组件化</h3>\n<pre><code>1. 模块化:\n\t当应用的js都以模块来编写的, 这个应用就是一个模块化的应用\n2. 组件化:\n\t当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用\n</code></pre>\n<h1><a id=\"2_react_75\"></a>2. react组件化开发</h1>\n<h2><a id=\"21__76\"></a>2.1. 基本理解和使用</h2>\n<pre><code>1). 自定义的标签: 组件类(函数)/标签\n2). 创建组件类\n\t//方式1: 无状态函数(简单组件, 推荐使用)\n\tfunction MyComponent1(props) {\n\t\treturn &lt;h1&gt;自定义组件标题11111&lt;/h1&gt;\n\t}\n\t//方式2: ES6类语法(复杂组件, 推荐使用)\n\tclass MyComponent3 extends React.Component {\n\t\trender () {\n\t\t  return &lt;h1&gt;自定义组件标题33333&lt;/h1&gt;\n\t\t}\n\t}\n3). 渲染组件标签\n\tReactDOM.render(&lt;MyComp /&gt;,  cotainerEle)\n4). ReactDOM.render()渲染组件标签的基本流程\n\tReact内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象\n\t将虚拟DOM并解析为真实DOM\n\t插入到指定的页面元素内部\n</code></pre>\n<h2><a id=\"22_3_state_96\"></a>2.2. 组件的3大属性: state</h2>\n<pre><code>1. 组件被称为\"状态机\", 页面的显示是根据组件的state属性的数据来显示\n2. 初始化指定:\n    constructor() {\n      super()\n      this.state = {\n        stateName1 : stateValue1,\n        stateName2 : stateValue2\n      }\n    }\n3. 读取显示: \n    this.state.stateName1\n4. 更新状态--&gt;更新界面 : \n    this.setState({stateName1 : newValue})\n</code></pre>\n<h2><a id=\"22_3_props_111\"></a>2.2. 组件的3大属性: props</h2>\n<pre><code>所有组件标签的属性的集合对象\n给标签指定属性, 保存外部数据(可能是一个function)\n在组件内部读取属性: this.props.propertyName\n作用: 从目标组件外部向组件内部传递数据\n对props中的属性值进行类型限制和必要性限制\n\tPerson.propTypes = {\n\t\tname: React.PropTypes.string.isRequired,\n\t\tage: React.PropTypes.number.isRequired\n\t}\n扩展属性: 将对象的所有属性通过props传递\n    &lt;Person {...person}/&gt;\n</code></pre>\n<h2><a id=\"22_3_refs_124\"></a>2.2. 组件的3大属性: refs</h2>\n<pre><code>组件内包含ref属性的标签元素的集合对象\n给操作目标标签指定ref属性, 打一个标识\n在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)\n作用: 找到组件内部的真实dom元素对象, 进而操作它\n</code></pre>\n<h2><a id=\"23__130\"></a>2.3. 组件中的事件处理</h2>\n<pre><code>1. 给标签添加属性: onXxx={this.eventHandler}\n2. 在组件中添加事件处理方法\n    eventHandler = (event) =&gt; {\n                \n    }\n3. 使自定义方法中的this为组件对象\n  \t在constructor()中bind(this)\n  \t使用箭头函数定义方法\n4. 事件监听\n\t绑定事件监听\n\t\t事件名\n\t\t回调函数\n\t触发事件\n\t\t用户对对应的界面做对应的操作\n\t\t编码\n</code></pre>\n<h2><a id=\"24__147\"></a>2.4. 组件的组合使用</h2>\n<pre><code>1)拆分组件: 拆分界面,抽取组件\n2)实现静态组件: 使用组件实现静态页面效果\n3)实现动态组件\n\t①　动态显示初始化数据\n\t②　交互功能(从绑定事件监听开始)\n</code></pre>\n<h2><a id=\"25__154\"></a>2.5. 组件收集表单数据</h2>\n<pre><code>受控组件: 输入过程中自动收集数据\n非受控组件: 提交时手动读取数据\n</code></pre>\n<h2><a id=\"26__158\"></a>2.6. 组件的生命周期</h2>\n<pre><code>1. 组件的三个生命周期状态:\n\tMount：插入真实 DOM\n\tUpdate：被重新渲染\n\tUnmount：被移出真实 DOM\n2. 生命周期流程:\n\t* 第一次初始化显示: ReactDOM.render(&lt;Xxx/&gt;, containDom)\n\t\tconstructor()\n\t\tcomponentWillMount() : 将要插入回调\n\t\trender() : 用于插入虚拟DOM回调\n\t\tcomponentDidMount() : 已经插入回调\n\t* 每次更新state: this.setState({})\n\t    componentWillReceiveProps(): 接收父组件新的属性\n\t    componentWillUpdate() : 将要更新回调\n\t    render() : 更新(重新渲染)\n\t    componentDidUpdate() : 已经更新回调\n\t* 删除组件: ReactDOM.unmountComponentAtNode(div): 移除组件\n\t\tcomponentWillUnmount() : 组件将要被移除回调\n3. 常用的方法\n\trender(): 必须重写, 返回一个自定义的虚拟DOM\n  \tconstructor(): 初始化状态(state={}), 绑定this(可以箭头函数代替)\n  \tcomponentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\b68fe149b6b44beaa52e1fea88d7101f.png\"/></p>\n<h2><a id=\"27_DOMDOM_diff_184\"></a>2.7. 虚拟DOM与DOM diff算法</h2>\n<h3><a id=\"1_DOM_185\"></a>1). 虚拟DOM是什么?</h3>\n<pre><code>一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)\n虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应\n如果只是更新虚拟DOM, 页面是不会重绘的\n</code></pre>\n<h3><a id=\"2_Virtual_DOM__189\"></a>2). Virtual DOM 算法的基本步骤</h3>\n<pre><code>用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中\n当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\n把差异应用到真实DOM树上，视图就更新了\n</code></pre>\n<h3><a id=\"3__193\"></a>3). 进一步理解</h3>\n<p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。<br/> 可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ed5b6a4013ef4797afbe0d2cdf964a6a.png\"/></p>\n<h2><a id=\"28__200\"></a>2.8. 命令式编程与声明式编程</h2>\n<pre><code>声明式编程\n\t只关注做什么, 而不关注怎么做(流程),  类似于填空题\n命令式编程\n\t要关注做什么和怎么做(流程), 类似于问答题\n\nvar arr = [1, 3, 5, 7]\n// 需求: 得到一个新的数组, 数组中每个元素都比arr中对应的元素大10: [11, 13, 15, 17]\n// 命令式编程\nvar arr2 = []\nfor(var i =0;i&lt;arr.length;i++) {\n\tarr2.push(arr[i]+10)\n}\nconsole.log(arr2)\n// 声明式编程\nvar arr3 = arr.map(function(item){\n\treturn item +10\n})\n// 声明式编程是建立命令式编程的基础上\n\n// 数组中常见声明式方法\n\tmap() / forEach() / find() / findIndex()\n</code></pre>\n<h1><a id=\"_224\"></a>面试法宝</h1>\n<p>很多伙伴找到我询问面试题，问我针对于前端有没有比较体系化的面试题总结，今天就给大家推荐这款面试法宝<br/> 点击链接直达</p>\n<p><a href=\"https://www.nowcoder.com/link/jihexinliang260\">https://www.nowcoder.com/link/jihexinliang260</a></p>\n<p>就是我们的牛客网，各大互联网大厂面试真题。从基础到入阶乃至原理刨析类面试题 应有尽有，赶快来装备自己吧！助你面试稳操胜券，solo全场面试官<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\23fe349fab3f4700b5c5219ad4364d0e.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d6d742deab5a4c758caa22349c2e8e76.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7906bedde5c64b1e86b45dc3e6fb9334.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8f1f9263a7fd4536adc1ca919f19e3fc.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9df5dd71012c492db0e62157aa9b779f.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a4f2d2880f5f42658c27079ac9b95c2e.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "JavaScript", "cpp": 0, "csharp": 0, "python": 0, "javascript": 1, "java": 0, "sql": 0, "php": 0, "time": "2022-06-07 09:21:11", "summary": "前言由于的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来开发的主流工具。这个项目本身也越滚越大，从最早的引擎变成了一整套前后端通吃的"}