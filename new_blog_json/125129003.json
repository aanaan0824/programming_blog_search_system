{"blogid": "125129003", "writerAge": "码龄9年", "writerBlogNum": "5", "writerCollect": "13", "writerComment": "18", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "150", "writerName": "u010816417", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125129003.jpg", "writerRankTotal": "98137", "writerRankWeekly": "339319", "writerThumb": "3", "writerVisitNum": "11254", "blog_read_count": "1041", "blog_time": "已于 2022-06-05 10:53:09 修改", "blog_title": "c/c++ windows ble 蓝牙", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>前言：</h2>\n<p>在使用c/c++ 通过winrt 操作ble蓝牙之前，本身采用了qt的ble蓝牙库去操作，但是最后发现qt的ble只能使用在msvc+qt中使用，其他的使用的时候就会在扫描的时候没有反应，最终又只能在比较了解ble的同事帮助之下去研究 微软的使用c/c++ 通过winrt 操作ble蓝牙，另外如果不用通过广播过滤设备可以使用第三方库<a class=\"link-info\" href=\"http://www.wch.cn/downloads/WCHBleLib_MultiOS_ZIP.html\" title=\" WCHBleLib_MultiOS\"> WCHBleLib_MultiOS</a> 或者是<a class=\"link-info\" href=\"https://github.com/adabru/BleWinrtDll\" title=\"BleWinrtDll\">BleWinrtDll</a> ，如果想多深入了解的话也可以参考微软写的demo <a class=\"link-info\" href=\"https://github.com/microsoft/Windows-universal-samples/tree/main/Samples/BluetoothLE\" title=\"BluetoothLE\">BluetoothLE</a>，关于微软操作ble接口说明文档地址是<a class=\"link-info\" href=\"https://docs.microsoft.com/en-us/uwp/api/windows.devices.bluetooth.advertisement.bluetoothleadvertisement?view=winrt-22000\" title=\"bluetoothleadvertisement\">bluetoothleadvertisement</a></p>\n<h2>注意事项：</h2>\n<p>1.使用该方式的时候c++的版本要设置为 c++17</p>\n<p>2.引用的头文件为：</p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;mutex&gt; \n#include &lt;winrt/Windows.Foundation.h&gt;\n#include &lt;winrt/Windows.Foundation.Collections.h&gt; \n#include &lt;winrt/Windows.Devices.Bluetooth.h&gt;\n#include &lt;winrt/Windows.Devices.Enumeration.h&gt;\n#include &lt;winrt/Windows.Devices.Bluetooth.Advertisement.h&gt;\n#include &lt;winrt/Windows.Devices.Bluetooth.GenericAttributeProfile.h&gt;\n#include &lt;winrt/Windows.Storage.Streams.h&gt;\n#include &lt;winrt/Windows.Foundation.Collections.h&gt;\n#include &lt;winrt/Windows.Devices.Radios.h&gt;\n#include &lt;winrt/Windows.Web.Syndication.h&gt;\n#include &lt;windows.devices.bluetooth.h&gt;\n#include &lt;windows.foundation.h&gt;\n#include&lt;coroutine&gt;\nusing namespace winrt;\nusing namespace Windows::Devices::Bluetooth;\nusing namespace Windows::Devices::Bluetooth::Advertisement;\nusing namespace Windows::Devices::Bluetooth::GenericAttributeProfile;\nusing namespace winrt::Windows::Devices::Radios;\nusing namespace Windows::Foundation;\n#pragma comment(lib, \"windowsapp\")\n#pragma comment(lib, \"WindowsApp.lib\")\nusing namespace std;</code></pre>\n<p></p>\n<h2>1.获取电脑是否支持ble蓝牙和蓝牙是否打开</h2>\n<pre><code class=\"language-cpp\">bool BLEIsLowEnergySupported() {\n\n    auto getadapter_op = Windows::Devices::Bluetooth::BluetoothAdapter::GetDefaultAsync();\n    auto adapter = getadapter_op.get();\n    auto  supported = adapter.IsLowEnergySupported(); // 获取windows电脑是否支持ble\n    if (supported == false) return false;\n    auto async = adapter.GetRadioAsync(); //获取本地蓝牙信息\n    auto radio = async.get();\n    auto t = radio.State(); // 获取电脑蓝牙状态 0未知，1打开，2关闭，3硬件关闭或禁用\n    if (t != winrt::Windows::Devices::Radios::RadioState::On) {\n        return false;\n    }\n    return  true;\n}</code></pre>\n<h2>LPWSTRT 与char 互转</h2>\n<pre><code class=\"language-cpp\">LPWSTR ConvertCharToLPWSTR(char* szString, WCHAR* addrchar)\n{\n    int dwLen = strlen(szString) + 1;\n    int nwLen = MultiByteToWideChar(CP_ACP, 0, szString, dwLen, NULL, 0);//算出合适的长度\n    MultiByteToWideChar(CP_ACP, 0, szString, dwLen, addrchar, nwLen);\n    return addrchar;\n}\n\n\nunsigned char* ConvertLPWSTRToChar(LPCTSTR widestr, unsigned char* addrchar)\n{\n    int num = WideCharToMultiByte(CP_OEMCP, NULL, widestr, -1, NULL, 0, NULL, FALSE);\n    WideCharToMultiByte(CP_OEMCP, NULL, widestr, -1, (char*)addrchar, num, NULL, FALSE);\n    return addrchar;\n}</code></pre>\n<p><br/>  </p>\n<h2>2.扫描ble蓝牙</h2>\n<pre><code class=\"language-cpp\">void Scanblebackfun(BluetoothLEAdvertisementWatcher w, BluetoothLEAdvertisementReceivedEventArgs e) // 扫描到的ble蓝牙设备通过此回调方式返回{\n    if (e.AdvertisementType() == BluetoothLEAdvertisementType::ConnectableUndirected)\n    {\n        uint64_t address = e.BluetoothAddress(); //获取蓝牙地址，建议不用转字符串太麻烦\n        auto Rssi = e.RawSignalStrengthInDBm(); //获取蓝牙信号强度\n\n\n        //保存有效地址\n        BluetoothLEDevice dev = BluetoothLEDevice::FromBluetoothAddressAsync(address).get();\n        int cid = 0;\n        auto id = dev.BluetoothDeviceId(); //获取蓝牙唯一id\n        auto name = dev.Name(); //获取蓝牙名称\n\n        char ID[50] = {0};\n        char Name[50] = {0};\n        ConvertLPWSTRToChar(id.Id().c_str(), (unsigned char*)ID);\n\t\tConvertLPWSTRToChar(name.c_str(), (unsigned char*)Name);\n\n        auto advertisement = e.Advertisement();  //获取蓝牙广播\n\n        auto serviceUuids = advertisement.ServiceUuids(); //获取广播的服务器的uuid\n        auto view = serviceUuids.GetView();\n        bool Isfindguid = false;\n        for (size_t i = 0; i &lt; view.Size(); i++)\n        {\n            auto guid = view.GetAt(i);\n            if (guid.Data1 == 0xf801 ) { //获取自己需要的广播\n\n                Isfindguid = true;\n            }\n        }\n\n        dev.Close();\n\n        if (Isfindguid == false) return;\n}\n\nvoid ScanBLEDevice(int timeout) {\n    BluetoothLEAdvertisementWatcher m_btWatcher;\n    m_btWatcher.ScanningMode(BluetoothLEScanningMode::Passive); //扫描所有此时没有连接的蓝牙\n    m_btWatcher.Received(Scanblebackfun); // 注册扫描到的蓝牙回调\n    Pens.clear();\n    m_btWatcher.Start(); //开始扫描\n    Sleep(timeout);\n    m_btWatcher.Stop();//结束扫描\n}</code></pre>\n<h2>3.连接蓝牙获取服务和特征</h2>\n<pre><code class=\"language-cpp\">void Characteristic_ValueChanged(GattCharacteristic const&amp; characteristic, GattValueChangedEventArgs args){//订阅回传的数据\n\n\n}\nBLEHandle ConnectBLEDevice(char * id) {\n    WCHAR ID[255] = { 0 };\n    ConvertCharToLPWSTR(id, ID);\n    hstring hst(ID);\n    auto device =  BluetoothLEDevice::FromIdAsync(hst).get();\n    auto result =  device.GetGattServicesAsync(BluetoothCacheMode::Uncached).get();//连接蓝牙服务\n    auto services = result.Services();\n\n    for (size_t i = 0; i &lt; services.Size(); i++)\n    {\n        auto service = services.GetAt(i);\n        auto uuid = service.Uuid(); //获取服务uuid\n        auto charact = service.GetCharacteristicsAsync().get();\n        auto characts = charact.Characteristics();\n        for (size_t j = 0; j &lt; characts.Size(); j++)\n        {\n            auto charact = characts.GetAt(j);\n            auto uuid = charact.Uuid(); //获取子服务的uuid\n            auto GAttpro = charact.CharacteristicProperties(); //获取每个子服务特征值\n            if (GAttpro == GattCharacteristicProperties::Notify) {                 charact.WriteClientCharacteristicConfigurationDescriptorAsync(GattClientCharacteristicConfigurationDescriptorValue::Notify);//注册订阅\n                charact.ValueChanged(auto_revoke, &amp;Characteristic_ValueChanged); //设置订阅数据回传的回调\n            }\n\n            if (GAttpro == GattCharacteristicProperties::Write) {\n                //写入数据\n                unsigned char* buff = \"123456\";\n                unsigned int lenght = 6;\n                winrt::Windows::Storage::Streams::DataWriter writer;\n                writer.WriteBytes(array_view&lt;uint8_t const&gt;(buff, buff + lenght));\n                winrt::Windows::Storage::Streams::IBuffer buffer = writer.DetachBuffer();\n                charact.WriteValueAsync(buffer);\n            }\n\n            if (GAttpro == GattCharacteristicProperties::Read) {\n                \n            }\n\n\n            if (GAttpro == (GattCharacteristicProperties::Write | GattCharacteristicProperties::WriteWithoutResponse)) {\n               \n            }\n\n            if (GAttpro == (GattCharacteristicProperties::Notify | GattCharacteristicProperties::Write)) {\n             \n            }\n\n            if (GAttpro == (GattCharacteristicProperties::Notify | GattCharacteristicProperties::Read)) {\n                \n            }\n\n            if (GAttpro == (GattCharacteristicProperties::Write | GattCharacteristicProperties::Read)) {\n                \n            }\n            return;\n        }\n    }\n\n}</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-06-05 10:53:09", "summary": "前言：在使用通过操作蓝牙之前，本身采用了的蓝牙库去操作，但是最后发现的只能使用在中使用，其他的使用的时候就会在扫描的时候没有反应，最终又只能在比较了解的同事帮助之下去研究微软的使用通过操作蓝牙，另外如"}