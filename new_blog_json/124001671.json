{"blogid": "124001671", "writerAge": "码龄8年", "writerBlogNum": "184", "writerCollect": "168", "writerComment": "51", "writerFan": "2793", "writerGrade": "5级", "writerIntegral": "3755", "writerName": "龚礼鹏", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124001671.jpg", "writerRankTotal": "5220", "writerRankWeekly": "3053", "writerThumb": "56", "writerVisitNum": "235512", "blog_read_count": "6478", "blog_time": "已于 2022-04-18 16:50:41 修改", "blog_title": "Kotlin相关面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFkotlin%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%80.%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFkotlin%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F\">一.请简述下什么是kotlin？它有什么特性？</a></p>\n<p id=\"%E4%BA%8C.Kotlin%20%E4%B8%AD%E6%B3%A8%E8%A7%A3%20%40JvmOverloads%20%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C.Kotlin%20%E4%B8%AD%E6%B3%A8%E8%A7%A3%20%40JvmOverloads%20%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\">二.Kotlin 中注解 @JvmOverloads 的作用？</a></p>\n<p id=\"%E4%B8%89.Kotlin%E4%B8%AD%E7%9A%84MutableList%E4%B8%8EList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%89.Kotlin%E4%B8%AD%E7%9A%84MutableList%E4%B8%8EList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">三.Kotlin中的MutableList与List有什么区别？</a></p>\n<p id=\"%E5%9B%9B.kotlin%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%9B.kotlin%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\">四.kotlin实现单例的几种方式？</a></p>\n<p id=\"%E4%BA%94.%20kotlin%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97data%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%94.%20kotlin%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97data%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F\">五. kotlin中关键字data的理解？相对于普通的类有哪些特点？</a></p>\n<p id=\"%E5%85%AD.%E4%BB%80%E4%B9%88%E6%98%AF%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%85%AD.%E4%BB%80%E4%B9%88%E6%98%AF%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">六.什么是委托属性？简单说一下应用场景？</a></p>\n<p id=\"%E4%B8%83.kotlin%E4%B8%ADwith%E3%80%81run%E3%80%81apply%E3%80%81let%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%83.kotlin%E4%B8%ADwith%E3%80%81run%E3%80%81apply%E3%80%81let%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F\">七.kotlin中with、run、apply、let函数的区别？一般用于什么场景？</a></p>\n<p id=\"%E5%85%AB.kotlin%E4%B8%ADUnit%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%92%8CJava%E4%B8%ADvoid%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%85%AB.kotlin%E4%B8%ADUnit%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%92%8CJava%E4%B8%ADvoid%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">八.kotlin中Unit的应用以及和Java中void的区别？</a></p>\n<p id=\"%E4%B9%9D.Kotlin%20%E4%B8%AD%20infix%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B9%9D.Kotlin%20%E4%B8%AD%20infix%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">九.Kotlin 中 infix 关键字的原理和使用场景？</a></p>\n<p id=\"%E5%8D%81.%C2%A0Kotlin%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%9B%B8%E6%AF%94%E4%BA%8E%20Java%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81.%C2%A0Kotlin%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%9B%B8%E6%AF%94%E4%BA%8E%20Java%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">十. Kotlin中的可见性修饰符有哪些？相比于 Java 有什么区别？</a></p>\n<p id=\"%E5%8D%81%E4%B8%80.%E4%BD%A0%E8%A7%89%E5%BE%97Kotlin%E4%B8%8EJava%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%B8%80.%E4%BD%A0%E8%A7%89%E5%BE%97Kotlin%E4%B8%8EJava%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F\">十一.你觉得Kotlin与Java混合开发时需要注意哪些问题？</a></p>\n<p id=\"%E5%8D%81%E4%BA%8C.%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E4%BD%95%E4%B8%BA%E8%A7%A3%E6%9E%84%EF%BC%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%BA%8C.%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E4%BD%95%E4%B8%BA%E8%A7%A3%E6%9E%84%EF%BC%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F\">十二.在Kotlin中，何为解构？该如何使用？</a></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"%E5%8D%81%E4%B8%89.%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%B8%89.%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\">十三.在Kotlin中，什么是内联函数？有什么作用？</a></p>\n<p id=\"%E5%8D%81%E5%9B%9B.%E8%B0%88%E8%B0%88kotlin%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E5%9B%9B.%E8%B0%88%E8%B0%88kotlin%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F\">十四.谈谈kotlin中的构造方法？有哪些注意事项？</a></p>\n<p id=\"%E5%8D%81%E4%BA%94.%E8%B0%88%E8%B0%88Kotlin%E4%B8%AD%E7%9A%84Sequence%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%BA%94.%E8%B0%88%E8%B0%88Kotlin%E4%B8%AD%E7%9A%84Sequence%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88%EF%BC%9F\">十五.谈谈Kotlin中的Sequence，为什么它处理集合操作更加高效？</a></p>\n<p id=\"%E5%8D%81%E5%85%AD.%E8%AF%B7%E8%B0%88%E8%B0%88Kotlin%E4%B8%AD%E7%9A%84Coroutines%EF%BC%8C%E5%AE%83%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E5%85%AD.%E8%AF%B7%E8%B0%88%E8%B0%88Kotlin%E4%B8%AD%E7%9A%84Coroutines%EF%BC%8C%E5%AE%83%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F\">十六.请谈谈Kotlin中的Coroutines，它与线程有什么区别？有哪些优点？</a></p>\n<p id=\"%E5%8D%81%E4%B8%83.Kotlin%E4%B8%AD%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%A4%84%E7%90%86%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%B8%83.Kotlin%E4%B8%AD%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%A4%84%E7%90%86%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%9F\">十七.Kotlin中该如何安全地处理可空类型？</a></p>\n<p id=\"%E5%8D%81%E5%85%AB.Kotlin%E4%B8%AD%E7%9A%84%3F.%E7%84%B6%E5%90%8E%E5%90%8E%E9%9D%A2%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E5%85%AB.Kotlin%E4%B8%AD%E7%9A%84%3F.%E7%84%B6%E5%90%8E%E5%90%8E%E9%9D%A2%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">十八.Kotlin中的?.然后后面调用方法如果为空的情况下是什么？</a></p>\n<p id=\"%E5%8D%81%E5%85%AB.%E8%AF%B4%E8%AF%B4%20Kotlin%E4%B8%AD%20%E7%9A%84%20Any%20%E4%B8%8EJava%E4%B8%AD%E7%9A%84%20Object%20%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E5%85%AB.%E8%AF%B4%E8%AF%B4%20Kotlin%E4%B8%AD%20%E7%9A%84%20Any%20%E4%B8%8EJava%E4%B8%AD%E7%9A%84%20Object%20%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F\">十九.说说 Kotlin中 的 Any 与Java中的 Object 有何异同？</a></p>\n<p id=\"%E5%8D%81%E4%B9%9D.Kotlin%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%B9%9D.Kotlin%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\">二十.Kotlin中的数据类型有隐式转换吗？为什么？</a></p>\n<p id=\"%E4%BA%8C%E5%8D%81%E4%B8%80.Kotlin%20%E4%B8%AD%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E5%8D%81%E4%B8%80.Kotlin%20%E4%B8%AD%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\">二十一.Kotlin 中集合遍历有哪几种方式？</a></p>\n<p id=\"%E4%BA%8C%E5%8D%81%E4%BA%8C.%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%8F%E7%A8%8B%E6%AF%94%E7%BA%BF%E7%A8%8B%E8%A6%81%E8%BD%BB%E9%87%8F%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E5%8D%81%E4%BA%8C.%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%8F%E7%A8%8B%E6%AF%94%E7%BA%BF%E7%A8%8B%E8%A6%81%E8%BD%BB%E9%87%8F%EF%BC%9F\">二十二.为什么协程比线程要轻量？</a></p>\n<p id=\"%E4%BA%8C%E5%8D%81%E4%B8%89.%E5%8D%8F%E7%A8%8BFlow%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E5%8D%81%E4%B8%89.%E5%8D%8F%E7%A8%8BFlow%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">二十三.协程Flow是什么，有哪些应用场景？</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p>参考：<a href=\"https://developer.android.google.cn/kotlin/first\" title=\"Android 的 Kotlin 优先方法  |  Android 开发者  |  Android Developers\">Android 的 Kotlin 优先方法  |  Android 开发者  |  Android Developers</a></p>\n<p><a href=\"https://blog.csdn.net/gongjdde/category_10998720.html?spm=1001.2014.3001.5482\" title=\"https://blog.csdn.net/gongjdde/category_10998720.html?spm=1001.2014.3001.5482\">https://blog.csdn.net/gongjdde/category_10998720.html?spm=1001.2014.3001.5482</a></p>\n<p></p>\n<h2 id=\"%E4%B8%80.%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFkotlin%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F\">一.请简述下什么是kotlin？它有什么特性？</h2>\n<p>kotlin是一门编程语言，<strong>和java一样都是编译成class文件，然后被虚拟机加载。</strong>kotlin是先在android官方优先采用的语言，相比Java，它有以下优势：</p>\n<ul><li><strong>富有表现力且简洁</strong>：您可以使用更少的代码实现更多的功能。表达自己的想法，少编写样板代码。在使用 Kotlin 的专业开发者中，有 67% 的人反映其工作效率有所提高。比如：MVVM中model层<strong>data数据类</strong>相对java实现数据类自动重写了get，set，equals，hashCode，toString、componentN、copy等方法，<strong>单例类</strong>可以直接使用object实现java饿汉单例模式，还有<strong>其他扩展函数、高阶函数、类型转换</strong>等等</li><li><strong>更安全的代码</strong>：Kotlin 有许多语言功能，可帮助您避免<strong> null 指针异常</strong>等常见编程错误。包含 Kotlin 代码的 Android 应用发生崩溃的可能性降低了 20%。例如：可以通过<strong>?</strong>进行判空，不为空的才能继续往下走；还有<strong>密封类</strong>防止出现其他分支的错误；还有对于<strong>类默认不可继承，方法默认不可重写(相当于java中final)</strong>，如果需要继承或者重写都需要加<strong>open关键字</strong>，字段建议使用<strong>val</strong>，不可变。</li><li><strong>可互操作</strong>：您可以在 <strong>Kotlin 代码中调用 Java 代码，或者在 Java 代码中调用 Kotlin 代码。</strong>Kotlin 可完全与 Java 编程语言互操作，因此您可以根据需要在项目中添加任意数量的 Kotlin 代码。</li><li><strong>结构化并发</strong>：Kotlin 协程让异步代码像阻塞代码一样易于使用。<strong>协程</strong>可大幅简化后台任务管理，例如网络调用、本地数据访问等任务的管理。</li></ul>\n<p></p>\n<h2 id=\"%E4%BA%8C.Kotlin%20%E4%B8%AD%E6%B3%A8%E8%A7%A3%20%40JvmOverloads%20%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\">二.Kotlin 中注解 @JvmOverloads 的作用？</h2>\n<p>在<code>Kotlin</code>中<code>@JvmOverloads</code>注解的作用就是：在有<strong>默认参数值的方法中使用<code>@JvmOverloads</code>注解</strong>，则<code>Kotlin</code>就会暴露<strong>多个重载方法</strong>。如果没有加注解@JvmOverloads则只有一个方法，kotlin调用的话如果没有传入的参数用的是默认值。</p>\n<pre><code>@JvmOverloads fun f(a: String, b: Int=0, c:String=\"abc\"){\n}\n// 相当于Java三个方法 不加这个注解就只能当作第三个方法这唯一一种方法\nvoid f(String a)\nvoid f(String a, int b)\n// 加不加注解，都会生成这个方法\nvoid f(String a, int b, String c)</code></pre>\n<p></p>\n<h2 id=\"%E4%B8%89.Kotlin%E4%B8%AD%E7%9A%84MutableList%E4%B8%8EList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">三.Kotlin中的MutableList与List有什么区别？</h2>\n<p><strong>List</strong>：有序接口，只能<strong>读取</strong>，不能更改元素；<br/><strong>MutableList</strong>：有序接口，可以读写与<strong>更改、删除、增加元素。</strong></p>\n<p>源码分析<strong>MutableList</strong>就相当于Java中的<strong>ArrayList</strong>，<strong>List</strong>是kotlin自己<strong>重写的EmptyList</strong>，EmptyList中没有<strong>提供add方法remove方法等修改元素操作的方法。</strong></p>\n<pre><code>internal object EmptyList : List, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n    \n    override fun equals(other: Any?): Boolean = other is List&lt;*&gt; &amp;&amp; other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n    \n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection&lt;Nothing&gt;): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list             doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator&lt;Nothing&gt; = EmptyIterator\n    override fun listIterator(): ListIterator&lt;Nothing&gt; = EmptyIterator\n    override fun listIterator(index: Int): ListIterator&lt;Nothing&gt; {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List&lt;Nothing&gt; {\n        if (fromIndex == 0 &amp;&amp; toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}</code></pre>\n<p></p>\n<h2 id=\"%E5%9B%9B.kotlin%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\">四.kotlin实现单例的几种方式？</h2>\n<p><strong>饿汉式</strong></p>\n<pre><code>object Singleton</code></pre>\n<p><strong>线程安全的懒汉式</strong></p>\n<pre><code>class Singleton private constructor() {\n\n    companion object {\n        private var instance: Singleton? = null\n            get() {\n                if (field == null) field = Singleton()\n                return field\n            }\n\n        @Synchronized\n        fun instance(): Singleton {\n            return instance!!\n        }\n    }\n}</code></pre>\n<p><strong>双重校验锁式</strong></p>\n<pre><code>/**\n * 双重校验锁式\n * Lazy是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托\n * 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果,后续调用 get() 只是返回记录的结果\n * Lazy默认的线程模式就是 LazyThreadSafetyMode.SYNCHRONIZED 内部默认双重校验锁\n * # Lazy内部实现\n * ```\n * public fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =\n *      when (mode) {\n *        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)\n *        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)\n *        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)\n *      }\n * ```\n * ### Lazy接口\n * ```\n * public interface Lazy&lt;out T&gt; {\n *     //当前实例化对象，一旦实例化后，该对象不会再改变\n *     public val value: T\n *     //返回true表示，已经延迟实例化过了，false 表示，没有被实例化，\n *     //一旦方法返回true，该方法会一直返回true,且不会再继续实例化\n *     public fun isInitialized(): Boolean\n * }\n * ```\n * ### SynchronizedLazyImpl\n * ```\n * private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable {\n *     private var initializer: (() -&gt; T)? = initializer\n *     @Volatile private var _value: Any? = UNINITIALIZED_VALUE\n *     // final field is required to enable safe publication of constructed instance\n *     private val lock = lock ?: this\n *\n *     override val value: T\n *         get() {\n *             val _v1 = _value\n *             //判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑\n *             if (_v1 !== UNINITIALIZED_VALUE) {\n *                 @Suppress(\"UNCHECKED_CAST\")\n *                 return _v1 as T\n *             }\n *\n *             return synchronized(lock) {\n *                 val _v2 = _value\n *                 if (_v2 !== UNINITIALIZED_VALUE) {\n *                     @Suppress(\"UNCHECKED_CAST\") (_v2 as T)\n *                 }\n *                 else {\n *                     //调用高级函数获取其返回值\n *                     val typedValue = initializer!!()\n *                     //将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值\n *                     _value = typedValue\n *                     initializer = null\n *                     typedValue\n *                 }\n *             }\n *         }\n *         //省略部分代码\n * }\n * ```\n */\nclass Singleton private constructor() {\n    companion object {\n        val instance by lazy { Singleton() }\n    }\n}</code></pre>\n<p><strong>静态内部类式</strong></p>\n<pre><code>class Singleton private constructor() {\n    companion object {\n        val instance = SingletonHolder.holder\n    }\n\n    private object SingletonHolder {\n        val holder = Singleton()\n    }\n}</code></pre>\n<p><strong>枚举式</strong></p>\n<pre><code>enum class Singleton {\n    INSTANCE;\n}</code></pre>\n<p>参考：<a href=\"https://www.jianshu.com/p/5797b3d0ebd0\" title=\"Kotlin下的5种单例模式 - 简书\">Kotlin下的5种单例模式 - 简书</a></p>\n<p></p>\n<h2 id=\"%E4%BA%94.%20kotlin%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97data%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F\">五. kotlin中关键字data的理解？相对于普通的类有哪些特点？</h2>\n<p>数据类，相当于MVVM模式下的model类，相对java自动重写了equals()/hashCode()方法、get()方法、set()方法(如果是可写入的)、toString()方法、componentN()方法、copy()方法，注意get/set方法是kotlin中的类都会为属性自动生成的方法，和数据类没关系。</p>\n<p>equals/hashCode：equals方法重写使对象的内容一致则返回true，hashCode方法重写使对象的内容一致则hashCode值也一致。</p>\n<p>注意：在kotlin中有 == 和 ===，==比较的对象内容，===比较的是对象的引用地址</p>\n<p>toString：重写此方法为类和属性值的内容，如：\"User(name=John, age=42)\"</p>\n<p>componentN：编译器为数据类(data class)自动声明componentN()函数,可直接用解构声明，如下：</p>\n<pre><code>\tvar girl1: Girl = Girl(\"嫚嫚\", 29, 160, \"廊坊\")\n\tvar (a,b,c,d) = girl1\n\tprintln(\"$a,$b,$c,$d\")\n</code></pre>\n<blockquote>\n<p><strong>在kotlin中所谓的解构就是将一个类对象中的参数拆开来，成为一个一个单独的变量，从而来使用这些单独的变量进行操作。</strong></p>\n</blockquote>\n<p>copy： 复制对象使用，当要复制一个对象，只改变一些属性，但其余不变，copy()就是为此而生</p>\n<p></p>\n<h2 id=\"%E5%85%AD.%E4%BB%80%E4%B9%88%E6%98%AF%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">六.什么是委托属性？简单说一下应用场景？</h2>\n<p> <strong>属性委托的核心思想是将一个属性（字段）的具体实现委托给另一个类去完成。</strong></p>\n<p>应用场景：懒加载技术，通过 by lazy进行懒加载</p>\n<p>参考：<a href=\"https://blog.csdn.net/gongjdde/article/details/105685998\" title=\"kotlin 泛型和委托_龚礼鹏的博客-CSDN博客\">kotlin 泛型和委托_龚礼鹏的博客-CSDN博客</a></p>\n<p></p>\n<h2 id=\"%E4%B8%83.kotlin%E4%B8%ADwith%E3%80%81run%E3%80%81apply%E3%80%81let%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F\">七.kotlin中with、run、apply、let函数的区别？一般用于什么场景？</h2>\n<p>基本介绍：</p>\n<ul><li>with：不是T的扩展函数，需要传入对象进去，不能判空，<strong>最后一行是返回值。</strong></li><li>run：是T的扩展函数，<strong>内部使用this，最后一行是返回值。</strong></li><li>apply：是T的扩展函数，<strong>内部使用this，最后一行返回的是自身。</strong></li><li>let：是T的扩展函数，<strong>内部使用it</strong>，当然可以自定义名称(通过修改lambda表达式参数)，<strong>最后一行是返回值。</strong></li><li>also：是T的扩展函数，<strong>和let一样内部使用it，最后一行是返回自身。</strong></li></ul>\n<p>使用场景：</p>\n<ul><li>用于初始化对象或更改对象属性，可使用apply</li><li>如果将数据指派给接收对象的属性之前验证对象，可使用also</li><li>如果将对象进行空检查并访问或修改其属性，可使用let</li><li>如果想要计算某个值，或者限制多个本地变量的范围，则使用run</li></ul>\n<p></p>\n<h2 id=\"%E5%85%AB.kotlin%E4%B8%ADUnit%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%92%8CJava%E4%B8%ADvoid%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">八.kotlin中Unit的应用以及和Java中void的区别？</h2>\n<ol><li>在java中，必须指定返回类型，即void不能省略，但是在kotlin中，如果返回为unit，可以省略。</li><li>java中void为一个关键字，但是在kotlin中unit是一个类</li></ol>\n<p></p>\n<h2 id=\"%E4%B9%9D.Kotlin%20%E4%B8%AD%20infix%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">九.Kotlin 中 infix 关键字的原理和使用场景？</h2>\n<p>infix可以自定义操作符，比如1 to 2 这种的, 1 add 2,让程序更加语义化</p>\n<p></p>\n<h2 id=\"%E5%8D%81.%C2%A0Kotlin%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%9B%B8%E6%AF%94%E4%BA%8E%20Java%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">十. Kotlin中的可见性修饰符有哪些？相比于 Java 有什么区别？</h2>\n<p>kotlin存在四种可见性修饰符，默认是public。 private、protected、internal、public<br/> 1.private、public是和java中的一样的，protected java中同一个包可见，kotlin中不可见。<br/> 2.不同的是java中默认是<strong>default</strong>修饰符（<strong>包可见</strong>），而kotlin存在<strong>internal</strong>修饰符（<strong>模块内部</strong>可见）。</p>\n<p>3.kotlin可以直接在文件顶级声明方法、变量等。其中protected不能用来修饰在文件顶级声明的类、方法、变量等。<br/> 构造方法默认是public修饰，可以使用可见性修饰符修饰constructor关键字来改变构造方法的可见性。</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td>修饰符</td><td>java</td><td>kotlin</td></tr><tr><td>public</td><td>所有类可见</td><td>所有类可见(默认)</td></tr><tr><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr><td>protected</td><td>当前类，子类，同一包路径下的类可见</td><td>当前类，子类可见</td></tr><tr><td>default</td><td>同一包路径下的类可见(默认)</td><td>无</td></tr><tr><td>internal</td><td>无</td><td>同一模块下的类可见</td></tr></tbody></table>\n<p></p>\n<h2 id=\"%E5%8D%81%E4%B8%80.%E4%BD%A0%E8%A7%89%E5%BE%97Kotlin%E4%B8%8EJava%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F\">十一.你觉得Kotlin与Java混合开发时需要注意哪些问题？</h2>\n<p>kotlin调用java的时候，<strong>如果java返回值可能为null 那就必须加上<a href=\"https://github.com/nullable\" title=\"@nullable\">@nullable</a>@nullable否则kotlin无法识别</strong>，也就不会强制你做非空处理，一旦java返回了null 那么必定会出现null指针异常，加上<a href=\"https://github.com/nullable\" title=\"@nullable\">@nullable</a>注解@nullable之后kotlin就能识别到java方法可能会返回null，编译器就能会知道，并且强制你做非null处理，这也就是kotlin的空安全</p>\n<p></p>\n<h2 id=\"%E5%8D%81%E4%BA%8C.%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E4%BD%95%E4%B8%BA%E8%A7%A3%E6%9E%84%EF%BC%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F\">十二.在Kotlin中，何为解构？该如何使用？</h2>\n<p>在kotlin中所谓的解构就是将<strong>一个类对象中的参数</strong>拆开来，成为一个一个<strong>单独的变量</strong>，从而来使用这些单独的变量进行操作。</p>\n<p>使用方式：</p>\n<p>1.常规使用方式：</p>\n<pre><code>val (name, age) = person\nprintln(name)\nprintln(age)</code></pre>\n<p>2.还可以在<strong>for</strong>需要中获取<strong>Map的key、value值</strong></p>\n<pre><code>for ((key, value) in map) {\n   // 使用该 key、value 做些事情\n}</code></pre>\n<p>3.如果在解构声明中你<strong>不需要</strong>某个变量，那么可以用<strong>下划线取代其名称</strong>：</p>\n<pre><code>val (_, status) = getResult()</code></pre>\n<p> 4.在 <strong>lambda </strong>表达式中解构</p>\n<pre><code>map.mapValues { entry -&gt; \"${entry.value}!\" }\nmap.mapValues { (key, value) -&gt; \"$value!\" }</code></pre>\n<h2></h2>\n<h2 id=\"%E5%8D%81%E4%B8%89.%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\">十三.在Kotlin中，什么是内联函数？有什么作用？</h2>\n<p>关键字 inline 标记函数，该函数就是一个内联函数</p>\n<p>作用是可以在编译kotlin文件时直接将内联函数内联掉，这样就是把内联函数执行过程放在调用此内联函数的位置，避免了java中多调用方法的操作，减少性能消耗。</p>\n<p>参考：<a href=\"https://github.com/Moosphan/Android-Daily-Interview/issues/169\" title=\"2019-10-21：在Kotlin中，什么是内联函数？有什么作用？ · Issue #169 · Moosphan/Android-Daily-Interview · GitHub\">2019-10-21：在Kotlin中，什么是内联函数？有什么作用？ · Issue #169 · Moosphan/Android-Daily-Interview · GitHub</a></p>\n<p><a href=\"https://blog.csdn.net/gongjdde/article/details/105681321\" title=\"kotlin 高阶函数、内联函数_龚礼鹏的博客-CSDN博客\">kotlin 高阶函数、内联函数_龚礼鹏的博客-CSDN博客</a></p>\n<p></p>\n<h2 id=\"%E5%8D%81%E5%9B%9B.%E8%B0%88%E8%B0%88kotlin%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F\">十四.谈谈kotlin中的构造方法？有哪些注意事项？</h2>\n<p>1.概要简述</p>\n<ol><li><code>kotlin</code>中构造函数分为<strong><code>主构造</code></strong>和<strong><code>次级构造</code></strong>两类</li><li>使用关键词<code>constructor</code>标记次级构造函数，部分情况可省略</li><li><strong><code>init</code></strong>关键词用于<strong>初始化代码块</strong>，注意与构造函数的执行顺序，类成员的初始化顺序</li><li>继承，扩展时候的构造函数调用逻辑</li><li>特殊的类如<code>data class</code>、<code>object/componain object</code>、<code>sealed class</code>等构造函数情况与继承问题</li><li>构造函数中的形参声明情况</li></ol>\n<p>2.详细说明</p>\n<ul><li> <p>主/次 构造函数</p>\n<blockquote>\n<ol><li><code>kotlin</code>中任何<code>class</code>（包括<code>object/data class/sealed class</code>）都有一个默认的<strong>无参构造函数</strong></li><li>如果显式的声明了构造函数，默认的无参构造函数就失效了。</li><li>主构造函数写在<code>class</code>声明处，可以有访问权限修饰符<code>private,public</code>等，且可以省略<code>constructor</code>关键字。</li><li>若显式的在<code>class</code>内声明了次级构造函数，就需要委托调用主构造函数。</li><li>若在<code>class</code>内显式的声明处所有构造函数（也就是没有了所谓的默认主构造），这时候可以不用依次调用主构造函数。例如继承<code>View</code>实现自定义控件时，三四个构造函数同时显示声明。</li></ol>\n</blockquote> </li><li> <p><code>init</code>初始化代码块</p>\n<blockquote>\n<p><code>kotlin</code>中若存在主构造函数，其不能有代码块执行，<code>init</code>起到类似作用，在类初始化时侯执行相关的代码块。</p>\n<ol><li><code>init</code>代码块优先于次级构造函数中的代码块执行。</li><li>即使在类的继承体系中，各自的<code>init</code>也是优先于构造函数执行。</li><li>在主构造函数中，形参加有<code>var/val</code>，那么就变成了成员属性的声明。这些属性声明是早于<code>init</code>代码块的。</li></ol>\n</blockquote> </li><li> <p>特殊类</p>\n<blockquote>\n<ol><li> <p><code>object/companion object</code>是对象示例，作为单例类或者伴生对象，没有构造函数。</p> </li><li> <p><code>data class</code>要求必须有一个含有至少一个成员属性的主构造函数，其余方面和普通类相同。</p> </li><li> <p><code>sealed class</code>只是声明类似抽象类一般，可以有主构造函数，含参无参以及次级构造等。</p> </li></ol>\n</blockquote> </li></ul>\n<h2 id=\"%E5%8D%81%E4%BA%94.%E8%B0%88%E8%B0%88Kotlin%E4%B8%AD%E7%9A%84Sequence%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88%EF%BC%9F\">十五.谈谈Kotlin中的Sequence，为什么它处理集合操作更加高效？</h2>\n<p id=\"%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E4%BD%8E%E6%95%88%E5%9C%A8%E5%93%AA%EF%BC%9F\"><strong>集合操作低效在哪？</strong></p>\n<p>处理集合时性能损耗的最大原因是<strong>循环</strong>。集合元素迭代的次数越少性能越好。</p>\n<p>我们写个例子：</p>\n<pre><code>list\n  .map { it ++ }\n  .filter { it % 2 == 0 }\n  .count { it &lt; 3 } \n</code></pre>\n<p>反编译一下，你会发现：Kotlin编译器会创建<code>三个while循环</code>。</p>\n<p id=\"Sequences%20%E5%87%8F%E5%B0%91%E4%BA%86%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0\"><strong>Sequences 减少了循环次数</strong></p>\n<p><code>Sequences</code>提高性能的秘密在于这三个操作可以<strong>共享同一个迭代器(iterator)</strong>，只需要一次循环即可完成。<code>Sequences</code>允许 map 转换一个元素后，立马将这个元素传递给 filter操作 ，而不是像集合(lists) 那样，等待所有的元素都循环完成了map操作后，用一个新的集合存储起来，然后又遍历循环从新的集合取出元素完成filter操作。</p>\n<p id=\"Sequences%20%E6%98%AF%E6%87%92%E6%83%B0%E7%9A%84\"><strong>Sequences 是懒惰的</strong></p>\n<p>上面的代码示例，<code>map</code>、<code>filter</code>、<code>count</code> 都是属于中间操作，只有等待到一个终端操作，如打印、<code>sum()</code>、<code>average()</code>、<code>first()</code>时才会开始工作，不信？你跑下下面的代码？</p>\n<pre><code>val list = listOf(1, 2, 3, 4, 5, 6)\nval result = list.asSequence()\n        .map{ println(\"--map\"); it * 2 }\n        .filter { println(\"--filter\");it % 3  == 0 }\nprintln(\"go~\")\nprintln(result.average())\n</code></pre>\n<p id=\"%E6%89%A9%E5%B1%95%EF%BC%9AJava8%20%E7%9A%84%20Stream(%E6%B5%81)%20%E6%80%8E%E4%B9%88%E6%A0%B7%E5%91%A2%3F\"><strong>扩展：Java8 的 Stream(流) 怎么样呢?</strong></p>\n<pre><code>list.asSequence()\n    .filter { it &lt; 0}\n    .map { it++ }\n    .average()\n\nlist.stream()\n    .filter { it &lt; 0}\n    .map { it++ }\n    .average()\n</code></pre>\n<p><code>stream</code>的处理效率几乎和<code>Sequences </code><strong>一样高</strong>。它们也都是基于惰性求值的原理并且在最后(终端)处理集合。</p>\n<p></p>\n<h2 id=\"%E5%8D%81%E5%85%AD.%E8%AF%B7%E8%B0%88%E8%B0%88Kotlin%E4%B8%AD%E7%9A%84Coroutines%EF%BC%8C%E5%AE%83%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F\">十六.请谈谈Kotlin中的Coroutines，它与线程有什么区别？有哪些优点？</h2>\n<p><strong>协程：协程就像非常轻量级的线程</strong>。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p>\n<p>协程与线程有什么区别：</p>\n<ul><li> <p><strong>Kotlin 协程，不是操作系统级别的概念，无需操作系统支持，线程是操作系统级别的概念</strong>，我们开发者通过编程语言(Thread.java)创建的线程，本质还是操作系统内核线程的映射。</p> </li><li> <p>Kotlin 协程，是<strong>用户态的(userlevel)</strong>，内核对协程「无感知」；一般情况下，我们说的线程，都是<strong>内核线程</strong>，线程之间的切换，调度，都由<strong>操作系统负责。</strong></p> </li><li> <p>Kotlin 协程，是<strong>协作式的，由开发者管理</strong>，不需要操作系统进行调度和切换，也没有抢占式的消耗，因此它更加「高效」；线程，是抢占式的，它们之间能共享内存资源。</p> </li><li> <p>Kotlin 协程，<strong>它底层基于状态机实现</strong>，多协程之间共用一个实例，资源开销极小，因此它更加「轻量」；线程会消耗操作系统资源。</p> </li><li> <p>Kotlin 协程，<strong>本质还是运行于线程之上</strong>，它通过协程调度器，可以运行到不同的线程上</p> </li></ul>\n<p>优点：</p>\n<ul><li>轻量和高效：协程可以在一个线程中开启1000个协程，也不会有什么影响。</li><li>简单好用：其实轻量和高效并不是协程的核心竞争力，最主要的还是<strong>简化异步并发任务</strong>，代码中可以已同步的方式替换异步，去除<strong>java中回调地狱问题。</strong></li></ul>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s/nXfweTaOCpm6Bj34rW-wLA\" title=\"一看就会！协程原来是这样啊~\">一看就会！协程原来是这样啊~</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650250701&amp;idx=1&amp;sn=632f892db1a93568db5bc0dff3596c08&amp;chksm=88636ca2bf14e5b4a78720754626f224ec512c56921725905291503dd5f9ec9d0b3ce6b8d0e3&amp;mpshare=1&amp;scene=24&amp;srcid=1118HQj1yxjZl4TUS4ZFXCTp&amp;sharer_sharetime=1605714971766&amp;sharer_shareid=18e44df20c06c4e8ad35a376855d811a#rd\" title=\"GDG上海实录回顾，带你快速上手Kotlin协程\">GDG上海实录回顾，带你快速上手Kotlin协程</a></p>\n<p></p>\n<h2 id=\"%E5%8D%81%E4%B8%83.Kotlin%E4%B8%AD%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%A4%84%E7%90%86%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%9F\">十七.Kotlin中该如何安全地处理可空类型？</h2>\n<p>a?.let{<!-- --></p>\n<p>//此处的内容就是非空的</p>\n<p>}</p>\n<p></p>\n<h2 id=\"%E5%8D%81%E5%85%AB.Kotlin%E4%B8%AD%E7%9A%84%3F.%E7%84%B6%E5%90%8E%E5%90%8E%E9%9D%A2%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">十八.Kotlin中的?.然后后面调用方法如果为空的情况下是什么？</h2>\n<p>如果<strong>为空不会抛出空指针</strong>，而是<strong>调用的方法</strong>会<strong>返回null</strong>；</p>\n<p></p>\n<h2 id=\"%E5%8D%81%E5%85%AB.%E8%AF%B4%E8%AF%B4%20Kotlin%E4%B8%AD%20%E7%9A%84%20Any%20%E4%B8%8EJava%E4%B8%AD%E7%9A%84%20Object%20%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F\">十九.说说 Kotlin中 的 Any 与Java中的 Object 有何异同？</h2>\n<p>同：</p>\n<ul><li>都是顶级父类<br/> 异：</li><li>成员方法不同<br/> Any只声明了toString()、hashCode()和equals()作为成员方法。</li></ul>\n<p>我们<strong>思考下，为什么 Kotlin 设计了一个 Any ？</strong></p>\n<p>当我们需要和 Java 互操作的时候，Kotlin 把 Java 方法参数和返回类型中用到的 Object 类型看作 Any，这个 Any 的设计是 Kotlin 兼容 Java 时的一种权衡设计。</p>\n<p>所有 Java 引用类型在 Kotlin 中都表现为平台类型。当在 Kotlin 中处理平台类型的值的时候，它既可以被当做可空类型来处理，也可以被当做非空类型来操作。</p>\n<p>试想下，如果所有来自 Java 的值都被看成非空，那么就容易写出比较危险的代码。反之，如果 Java 值都强制当做可空，则会导致大量的 null 检查。综合考量，平台类型是一种折中的设计方案。</p>\n<p></p>\n<h2 id=\"%E5%8D%81%E4%B9%9D.Kotlin%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\">二十.Kotlin中的数据类型有隐式转换吗？为什么？</h2>\n<p>kotlin有隐式转换，在计算过程中一般都转换成其中的较大类型，因为防止精度丢失。</p>\n<p>参考：<a href=\"https://zinyan.com/?p=184\" title=\"Kotlin 数据类型转换，隐式转换与显式转换\">Kotlin 数据类型转换，隐式转换与显式转换</a></p>\n<p></p>\n<h2 id=\"%E4%BA%8C%E5%8D%81%E4%B8%80.Kotlin%20%E4%B8%AD%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\">二十一.Kotlin 中集合遍历有哪几种方式？</h2>\n<p>for,foreach,while,do while,递归,还有集合的高阶方法</p>\n<p></p>\n<h2 id=\"%E4%BA%8C%E5%8D%81%E4%BA%8C.%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%8F%E7%A8%8B%E6%AF%94%E7%BA%BF%E7%A8%8B%E8%A6%81%E8%BD%BB%E9%87%8F%EF%BC%9F\">二十二.为什么协程比线程要轻量？</h2>\n<p>一个线程中开启<strong>1000个协程也没什么问题</strong>，但是如果开启1000个线程则性能消耗无法估量。</p>\n<p></p>\n<h2 id=\"%E4%BA%8C%E5%8D%81%E4%B8%89.%E5%8D%8F%E7%A8%8BFlow%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">二十三.协程Flow是什么，有哪些应用场景？</h2>\n<p>协程flow：Kotlin 协程中使用<strong>挂起函数可以实现非阻塞地执行任务并将结果返回回来</strong>，但是只能返回单个计算结果。但是如果希望有<strong>多个计算结果</strong>返回回来，则可以使用 Flow。</p>\n<p>应用场景：多个数据流执行的情况下。</p>\n<p>参考：<a href=\"https://www.cnblogs.com/joy99/p/15805955.html\" title=\"Kotlin 协程三 —— 数据流 Flow - SharpCJ - 博客园\">Kotlin 协程三 —— 数据流 Flow - SharpCJ - 博客园</a></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-18 16:50:41", "summary": "目录一请简述下什么是？它有什么特性？二中注解的作用？三中的与有什么区别？四实现单例的几种方式？五中关键字的理解？相对于普通的类有哪些特点？六什么是委托属性？简单说一下应用场景？七中、、、函数的区别？一"}