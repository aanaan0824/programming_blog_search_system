{"blogid": "126667516", "writerAge": "码龄4年", "writerBlogNum": "93", "writerCollect": "297", "writerComment": "325", "writerFan": "228", "writerGrade": "5级", "writerIntegral": "1722", "writerName": "安河桥畔", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126667516.jpg", "writerRankTotal": "11429", "writerRankWeekly": "291", "writerThumb": "346", "writerVisitNum": "33104", "blog_read_count": "465", "blog_time": "已于 2022-09-05 11:42:03 修改", "blog_title": "C++中的继承（继承基本概念、菱形虚拟继承的对象模型）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-dracula\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>继承</h3>\n<ul><li><a href=\"#_3\">一、继承的概念与定义格式</a></li><li><ul><li><a href=\"#_4\">概念及定义格式</a></li><li><a href=\"#_15\">访问限定符与继承权限</a></li></ul>\n</li><li><a href=\"#_41\">二、赋值兼容规则</a></li><li><a href=\"#_72\">三、继承中的作用域</a></li><li><a href=\"#_116\">四、子类的默认成员函数</a></li><li><ul><li><a href=\"#_117\">构造函数</a></li><li><a href=\"#_129\">拷贝构造函数</a></li><li><a href=\"#_137\">赋值运算符重载</a></li><li><a href=\"#_144\">析构函数</a></li><li><a href=\"#_147\">构造和析构函数调用顺序</a></li></ul>\n</li><li><a href=\"#_151\">五、继承与友元、静态成员</a></li><li><ul><li><a href=\"#_152\">友元关系</a></li><li><a href=\"#_160\">静态成员</a></li></ul>\n</li><li><a href=\"#_194\">六、菱形继承及菱形虚拟继承</a></li><li><ul><li><a href=\"#_195\">菱形继承概念</a></li><li><a href=\"#_211\">存在问题</a></li><li><a href=\"#_215\">虚拟继承的概念</a></li><li><a href=\"#_227\">虚拟继承的模型</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_3\"></a>一、继承的概念与定义格式</h1>\n<h2><a id=\"_4\"></a>概念及定义格式</h2>\n<p>继承机制是面向对象程序设计<u>使代码可以复用</u>的最重要手段，它允许程序员在<u>保留原有类特性的基础上进行扩展</u>，增加功能，这样产生的类，称为派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。<u>继承是类设计层次的复用</u>。<br/> 个人理解：<u>父类实际上是抽取类的共性，将其它类都有的属性和方法进行提取，再定义其它类时只需要继承父类，并写出该类独有的属性即可</u>。</p>\n<p>以Person类为父类，Student类为学生类举例：</p>\n<ul><li>父类<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\977900ebdb804075833c760ffb67b60a.png\"/></li><li>子类<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\91c0b18845d941108d551beb0f907fda.png\"/></li></ul>\n<p>这里Student类继承了Person类，学生中就包含Person类中的name和age两个属性，只需要再写出Student类独有的num属性即可。</p>\n<h2><a id=\"_15\"></a>访问限定符与继承权限</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\aa65dbe14b604d2d9fbad9537c6ae327.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f35d3ebda6c44db998e69a9c75cc2870.png\"/><br/> 一句话总结上面的表格：<u>继承权限决定了子类能继承的父类的最高权限</u>。即public继承不会改变类成员的访问权限；protected继承方式会改变原来访问权限为public的成员；private继承方式会影响原来访问权限为public和protected的成员。</p>\n<p>另外还有几点要注意：</p>\n<ul><li> <p>父类的private成员被子类继承了，但是子类不能访问父类的private成员，通过查看子类的大小可以得知，子类中包含继承自父类的私有成员变量。<br/> 在子类中访问父类私有成员会报错：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\edc7fdf64ef64e309feadf927c216c01.png\"/><br/> 查看子类大小：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ff79684bea0748b2891f775da94f6289.png\"/></p> </li><li> <p>protected成员访问限定符只因为继承体系才出现的，因为protected在继承中才有意义</p> </li><li> <p>实际中一般使用public继承</p> </li><li> <p>使用关键字class默认的继承方式是private，使用struct默认的继承方式是public，一般最好显式给出继承权限。</p> </li></ul>\n<p><strong>ps： class和struct的区别</strong></p>\n<ol><li>定义类的默认访问权限不同，class为私有，struct为公有，兼容C语言</li><li>模板参数列表中可以使用class，不能使用struct</li><li>继承中的默认继承权限不同，class默认private，struct默认public</li></ol>\n<h1><a id=\"_41\"></a>二、赋值兼容规则</h1>\n<p>这里的复制兼容规则是在public继承的前提下：</p>\n<ol><li>可以使用<u>子类对象给父类对象<mark>赋值</mark>赋值</u>，但是不能使用父类对象给子类对象赋值</li><li>可以使用<u>父类<mark>指针</mark>指向子类对象</u>，但不能使用子类指针指向父类对象，如果一定要指向，进行强制类型转换后可以，但是会有<u>指针越界访问</u>的问题。</li><li>可以使用父类的<mark>引用</mark>去引用子类，不能使用子类的引用引用父类，与指针原理相同。</li></ol>\n<p>仍以 Person类和Student类举例：<br/> Person类：</p>\n<pre><code class=\"prism language-cpp\">lass Person\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\tstring _name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _age <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Student类继承Person类：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>分别验证赋值、指针和引用：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\53cf0c836c334cabb4ba9beed1a644f6.png\"/><br/> 原理如图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c2db66935677405d9f6b316d0ebc4aa3.png\"/><br/> 指针和引用原理与上图相同，父类的指针可以指向子类中继承自父类的部分；但是子类的指针如果指向父类，访问_name和_age时不会有问题，<u>访问到_num时就会超出父类对象的范围，越界访问</u>，所以编译器禁止了子类指针指向父类对象。</p>\n<h1><a id=\"_72\"></a>三、继承中的作用域</h1>\n<ol><li>在继承体系中，父类和子类都有<mark>独立的作用域</mark></li><li>如果父类和子类中有同名成员，子类成员会<u>屏蔽对父类同名成员的直接访问，优先访问自己类中的成员</u>，即<u>同名隐藏</u>，也叫<u><mark>重定义</mark></u>。</li><li>对于成员函数，只要<u>函数名相同就构成重定义</u>，与类型无关。</li></ol>\n<p>Person类：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Person name:\"</span> <span class=\"token operator\">&lt;&lt;</span> _name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Person age\"</span> <span class=\"token operator\">&lt;&lt;</span> _age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\tstring _name <span class=\"token operator\">=</span> <span class=\"token string\">\"ZS\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _age <span class=\"token operator\">=</span> <span class=\"token number\">17</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Student类继承Person类：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Student name：\"</span> <span class=\"token operator\">&lt;&lt;</span> _name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Student age：\"</span> <span class=\"token operator\">&lt;&lt;</span> _age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Student num：\"</span> <span class=\"token operator\">&lt;&lt;</span> _num <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\tstring _name <span class=\"token operator\">=</span> <span class=\"token string\">\"LS\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _age <span class=\"token operator\">=</span> <span class=\"token number\">18</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _num <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>验证结果：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0a1fa32d848241d7865d1b758fe06028.png\"/><br/> 当不加作用域限定符时，子类对象会优先访问自己的成员变量和成员函数。<br/> 对程序稍作修改：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\313b47c8d210410680d4877bcf08f15d.png\"/><br/> 这里两个Print函数的参数不同，看起来像“重载”，但是实际上是同名隐藏，子类中对父类的Print函数进行了重定义。</p>\n<h1><a id=\"_116\"></a>四、子类的默认成员函数</h1>\n<h2><a id=\"_117\"></a>构造函数</h2>\n<p>父类 <u>没有显式定义构造函数 </u>或者父类有 <u>全缺省的构造函数 </u>或者 <u>无参的构造函数 </u>，子类可以不定义构造函数。<br/> 即下面三种情况，子类都可以不显式地给出构造函数：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\921306932bb644a9a4985afdaad73fbb.png\"/><br/> 但是如果父类显式定义了构造函数，且不是无参或者全缺省的，子类必须显式定义构造函数，并<u>在初始化列表显式调用父类的构造函数</u>，因为如果不显式定义，编译器会自动调用父类默认拷贝构造函数，而父类没有默认的构造函数，便会报错：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e46f9b36cf204a6d866363fe5c5a9539.png\"/><br/> <strong>正确的写法：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e601f2474db84f0496305b9ac530778f.png\"/><br/> 这里的name是传递给Person类构造函数的实参，即：用name给Student对象中继承的_name赋值。<br/> 构造一个Student类的对象分两步：</p>\n<ol><li>将从父类继承的成员初始化</li><li>将子类新增加的成员初始化</li></ol>\n<h2><a id=\"_129\"></a>拷贝构造函数</h2>\n<p>子类的拷贝构造函数必须<u>在初始化列表中显式调用父类的拷贝构造函数</u>。<br/> 父类没有定义拷贝构造函数，子类可以定义也可以不定义；父类如果定义了拷贝构造函数，子类一般要定义，并且要在初始化列表中调用父类的拷贝构造函数完成从父类继承的成员的拷贝初始化，否则会报错：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e973f15aa6094a0bbaedec5340f7daca.png\"/><br/> <strong>正确写法：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e9961313eeb345edbf737973b22e914f.png\"/><br/> 此处s是传递给拷贝构造函数的参数。</p>\n<h2><a id=\"_137\"></a>赋值运算符重载</h2>\n<p>子类的赋值运算符重载函数必须调用父类的赋值运算符重载完成对父类的赋值。<br/> 父类的赋值运算符重载：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\19212f87df99413884e66cd3c92d33a6.png\"/><br/> 子类：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\17a7f93a27c34e5ca9dd69780843c7f5.png\"/></p>\n<h2><a id=\"_144\"></a>析构函数</h2>\n<p>子类析构函数会在被调用完后自动调用父类的析构函数完成清理父类成员，所以清理顺序是：<u>先清理子类，再清理父类</u>。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\10b4a298ef9d4bf4bc249933a4b4aebc.png\"/></p>\n<h2><a id=\"_147\"></a>构造和析构函数调用顺序</h2>\n<p>构造子类对象时，<u>先调用父类的构造函数，再调用子类的构造函数</u>，清理对象时，<u>先调用子类的析构函数，再调用父类的析构函数</u>。如图：<img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9e881747149e4f46a115c40526fa183d.png\"/><br/> 因为构造子类对象时会在初始化列表中调用父类的构造函数，执行完之后才会执行子类的构造函数的函数体，所以父类的构造会先于子类的构造执行。</p>\n<h1><a id=\"_151\"></a>五、继承与友元、静态成员</h1>\n<h2><a id=\"_152\"></a>友元关系</h2>\n<p><mark>友元关系不能继承</mark><br/> tips：王叔是你父亲的好朋友，但是不一定是你的好朋友，王叔的财产不会 给你继承🙄<br/> 定义一个Display函数，并在Person类中声明为友元类：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bd2f03fd15564b5485235a7100ff5352.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7edd7953e43441508e1216ca89b39222.png\"/><br/> 在Display函数中可以访问Person类的protected成员，但是不能访问其子类Student类成员，友元关系不能继承。</p>\n<h2><a id=\"_160\"></a>静态成员</h2>\n<p>父类中声明了static静态成员，则整个继承体系只有一个这样的成员。无论派生出多少子类，都只有一个static成员实例。<br/> 定义A、B、C三个类：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _count<span class=\"token punctuation\">;</span><span class=\"token comment\">//类中声明为静态成员</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> A<span class=\"token double-colon punctuation\">::</span>_count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//类外定义</span>\n</code></pre>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span> <span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>通过不同对象访问_count：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\233166deebd74df6bdf69c2509b89165.png\"/></p>\n<h1><a id=\"_194\"></a>六、菱形继承及菱形虚拟继承</h1>\n<h2><a id=\"_195\"></a>菱形继承概念</h2>\n<p><strong>单继承</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5025988b748c41efb3c5bc42d5eedd59.png\"/><br/> <strong>多继承</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a1d65c1190cc412ca77a40527a6d3b22.png\"/><br/> <strong>菱形继承</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3ef5970fc3a640bb96c923ac97f860a4.png\"/><br/> 可以看出，菱形继承实际就是单继承和多继承组合的结果，是多继承的一种特殊情况。<br/> 菱形继承实例：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\653471845c1745248f9bad38a5a668ed.png\"/><br/> <code>注：验证环境为VS2022，win32平台</code><br/> 这里C类的大小是20字节，除了其本身成员的4字节，另外16个字节都是从两个父类继承来的。模型如图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\459c5ee441214ca5989eb0a49a97acb3.png\"/></p>\n<h2><a id=\"_211\"></a>存在问题</h2>\n<p>对于上面图中的菱形继承，存在的问题十分明显，那就是<u>数据冗余</u>和<u>二义性</u>问题。即Teacher类和Student类都继承自Person类，那么两个类中都会包含Person类中的成员，Assistant继承这两个类之后，同样的成员便会包含两份，导致数据重复，并且在通过Assistant对象访问Person类中的成员时，会有二义性。<br/> 通过添加作用域限定符可以解决访问二义性的问题，如：as.Teacher::_name类似的语句可以指定通过哪个父类访问Person类的对象，但是无法从根本解决数据冗余的问题，所以便引入了虚拟继承的概念。</p>\n<h2><a id=\"_215\"></a>虚拟继承的概念</h2>\n<p>虚拟继承是指在继承权限前面加上一个virtura关键字</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">B1</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">virtual</span> <span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _b1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>用<u>虚拟继承可以解决菱形继承的二义性和数据冗余的问题</u>。对于上面的菱形继承，在B1和B2继承A时使用虚拟继承即可解决问题。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0afedc73ae7945bfa58cac4be181f570.png\"/></p>\n<h2><a id=\"_227\"></a>虚拟继承的模型</h2>\n<p>对于上面的菱形虚拟继承，研究其模型。<br/> 通过sizeof打印输出获取c对象的大小为24字节：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7c470e7614a54bd880f1f926393579b3.png\"/><br/> 通过下面的语句为c对象中的成员赋值：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tC c<span class=\"token punctuation\">;</span>\n\tc<span class=\"token punctuation\">.</span>_a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\tc<span class=\"token punctuation\">.</span>_b1 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\tc<span class=\"token punctuation\">.</span>_b2 <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\tc<span class=\"token punctuation\">.</span>_c <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>查看其内存分布<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ef83a866abfd422ca553307192cfd73f.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7cb3b7bf3109418b89c200a64f96986a.png\"/><br/> 所以，菱形虚拟继承将最上面的父类中的成员只保存了一份，并用一个偏移量指针指向偏移量表格，偏移量表格中保存的就是最上面的父类中的成员变量相对于当前对象的偏移量。<br/> 最终得到的菱形虚拟继承对象内存模型如图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\135d5249838344bca6507e7ce2935f43.png\"/></p>\n<p>对象模型与偏移量表格：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\99986d67a7424628b196795e537493d8.png\"/></p>\n<p>附录：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c11cf15f8e454b15bc67eb715853832e.jpeg\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 11:42:03", "summary": "继承一、继承的概念与定义格式概念及定义格式访问限定符与继承权限二、赋值兼容规则三、继承中的作用域四、子类的默认成员函数构造函数拷贝构造函数赋值运算符重载析构函数构造和析构函数调用顺序五、继承与友元、静"}