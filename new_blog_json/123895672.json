{"blogid": "123895672", "writerAge": "码龄1年", "writerBlogNum": "126", "writerCollect": "5826", "writerComment": "7325", "writerFan": "16749", "writerGrade": "7级", "writerIntegral": "15009", "writerName": "鹿九丸", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123895672.jpg", "writerRankTotal": "662", "writerRankWeekly": "1186", "writerThumb": "5702", "writerVisitNum": "235484", "blog_read_count": "1883", "blog_time": "于 2022-04-01 13:43:20 发布", "blog_title": "《C陷阱和缺陷》----第七章 可移植性缺陷", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>第七章 可移植性缺陷</h3>\n<ul><li><a href=\"#71__1\">7.1 字符是有符号整数还是无符号整数</a></li><li><a href=\"#72__7\">7.2 逻辑运算符</a></li><li><a href=\"#73_0_13\">7.3 内存位置0</a></li><li><a href=\"#74__17\">7.4 大小写转换</a></li><li><a href=\"#_39\">附录</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"71__1\"></a>7.1 字符是有符号整数还是无符号整数</h1>\n<p>一个常见的错误认知就是：如果c是一个字符变量，使用<code>(unsigned)</code>就可得到与c等价的无符号整数。</p>\n<p>这是会失败的，因为在将字符c转换为无符号整数时，c将首先被转换为int型整数，而此时可能得到非预期的结果。</p>\n<h1><a id=\"72__7\"></a>7.2 逻辑运算符</h1>\n<p><mark>如果我们想进行逻辑右移操作，就把我们想要进行右移的数的类型设为无符号类型，左边就会填充0，如果想进行算术右移，就一般把类型设为有符号类型。（VS2019环境下）</mark></p>\n<p><mark>注意：移位操作时，移位的数目，不应该超过当前数据的类型所占的字节数，比如int型有32个字节，那么移位操作的数目应该为0到31，这在编译器上属于未定义的操作，同时，移位的数目不可以是负数。</mark></p>\n<h1><a id=\"73_0_13\"></a>7.3 内存位置0</h1>\n<p><mark>除了赋值和比较运算外，出于其它任何目的使用<code>NULL</code>都是非法操作。</mark></p>\n<h1><a id=\"74__17\"></a>7.4 大小写转换</h1>\n<p>toupper是函数实现的，如下所示：</p>\n<pre><code>int toupper(int c)\n{\n\tif(c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n\t\treturn c+'A' - 'a';\n\treturn c;\n}\n</code></pre>\n<p>tolower与此类似</p>\n<pre><code>#define _toupper(c) ((c) + 'A' - 'a')\n#define _tolower(c) ((c) + 'a' - 'A')\n</code></pre>\n<p>即使用toupper会对参数进行判定，如果不是小写字母就返回原来的参数，而_toupper则不会对函数进行判定。</p>\n<h1><a id=\"_39\"></a>附录</h1>\n<ol><li> <p>下面有两行代码：</p> <pre><code>printf(s);\nprintf(\"%s\",s);\n</code></pre> <p>两者的含义并不相同。第一个例子将把字符串s中的任何%s字符视为一个格式项的标志，因而其后的字符会被视为格式码。如果除%%之外的任何格式码再字符串s中出现，而后面又没有对应的参数，将会带来麻烦。而第二个例子中将会打印出任何空字符结尾的字符串。</p> <p><mark>结论：如果我们想要这样(printf(s))进行打印，那么我们就必须将s字符串中的%变为%%，否则会出现打印错误。</mark></p> </li><li> <p><mark>如果一个short整数作为作为任何一个函数（也包括printf函数）的参数出现，它会被自动的扩展为一个正常长度的整数，即int型。</mark></p> </li><li> <p><strong>宽度修饰符绝对不会截断一个输出域（即小数点前面的数字），当我们使用宽度修饰符来按列对齐一组数字时，如果一个数值太大而不能被它所在的栏所容纳，那么它就会挤占同一行右侧紧邻数值的位置。</strong></p> </li><li> <p>对于%e、%E和%f格式项，精度修饰符制定了小数点后应该出现的数字位数。除非标志（Flag）另有说明，否则仅当精度大于0时打印的数值中才会实际出现小数点。下面是例子：<img alt=\"image-20220306223404638\" src=\"..\\..\\static\\image\\130078bbf30751ceff350ea9de64d6f7.png\"/></p> </li><li> <p>对于%g和%G格式符，精度修饰符制定了打印数值中的有效数字位数。除非标志另有说明，否则非有效数字的0将被丢掉。如果小数点后不跟数字，则小数点也将被删除。</p> <p><img alt=\"image-20220306224021458\" src=\"..\\..\\static\\image\\6b6bae5e1ee3f70215fb617f16522e3d.png\"/></p> </li><li> <p>对于%格式项，<mark>精度修饰符(即小数点后面的数字)制定了将要从相应的字符串中打印的字符数</mark>。如果该字符串中包含的字符数少于精度修饰符所指定的字符数，输出的字符数就会少于精度修饰符所指定的数目。如果该字符串中包含的字符数多余精度修饰符所指定的字符数，输出的字符数将和精度修饰符所指定的字符数一致，即发生类似截断的情况。</p> <p><img alt=\"image-20220306225432533\" src=\"..\\..\\static\\image\\98ccd7e350362ba433455fcb48cd6d02.png\"/></p> </li><li> <p>标志自读+(放在%后面)的作用是，规定每个待打印的数值在输出时都应该以它的符号(正号或负号)作为第一个字符。因此，==非负数(包括0)==打印出来后，应该在最前面有一个正号。负数前面有一个负号。</p> </li><li> <p>空白字符作为标志字符时，它的含义是：如果某数是一个非负数，就在它的前面插入一个空白字符。如果标志字符+与空白字符同时出现在一个格式项中，最终的效果以标志字符+为准。</p> <p>例如：</p> <p><img alt=\"image-20220307095839128\" src=\"..\\..\\static\\image\\0941b0cbc769e10a069957d8f00b22c1.png\"/></p> <p>当在固定栏内按科学计数法打印数值，格式项% e和%+e要比正常的格式项%e有用的多。因为这时出现在非负数前面的正号(或者空白)保证了所有输出数值的小数点都会对齐。</p> <p>例如：</p> <p><img alt=\"image-20220307100958917\" src=\"..\\..\\static\\image\\6ed401beb2bdd5276b2824e33872f81a.png\"/></p> </li><li> <p>标志字符#的作用是对数值输出的格式进行微调，具体的格式与特定格式项有关。给%o格式项加上标志字符#的效果是：当有必要时增加数值输出的精度（只需让输出的第一个数字为0就已经做到了）。</p> <p>==注意：%#o与0%o并不相同，因为0%o把数值0打印成00，而%#o的打印结果是0。==同理，%#x与%#X要求打印出来的十六进制数值前面分别加上0x或0X。</p> <p>标志字符#对浮点数格式的影响有两方面：</p>\n<ul><li><mark>它要求小数点必须被打印出来，即使小数点后没有数字也是如此</mark></li><li><mark>如果用于%g或%G格式项，打印出的数值尾缀的0将不会被丢掉。</mark></li></ul> <p>例如：<img alt=\"image-20220307102051616\" src=\"..\\..\\static\\image\\288264fff11559b6045048d94ca84953.png\"/></p> </li><li> <p>可变域宽与精度</p> <p>我们如果要通过宏定义的方式来控制打印字符串的长度，比如我们大概率是会像下面这样使用：</p> <pre><code>#define NAMESIZE 14\nprintf(\".......%.NAMESIZE ...\",...,name,...);\n</code></pre> <p>但是这样写一点用处也没有，<mark>因为预处理器的作用范围不能达到字符串的内部。即预处理期间是无法替换字符串内的宏定义。</mark></p> <p>解决方案：</p> <p>我们需要用*替换修饰符宽修饰符或精度修饰符其中之一。在这种情况下，printf函数首先从参数列表中取得将要使用的域宽或精度的实际数值，然后使用该数值来打印任务。因此，上面的例子可以写成这样：</p> <pre><code>printf(\"%*.%*s\\n\",NAMESIZE,NAMESIZE,name);\n</code></pre> <p>上面的这段代码与下面的这段代码是一样的：</p> <pre><code>printf(\"%*.%*s\\n\",14,14,name);\n</code></pre> <p>看下面一个例子：</p> <pre><code>printf(\"%*%\\n\",n);\n</code></pre> <p>上式将在宽度为n个字符的域内以有段对齐的方式打印除一个%负号，换言之，就是先打印n-1个空白字符，后面再跟一个%负号。</p> <p>注意：如果*用于替换域宽修饰符，而与其相对用的参数的值为负数，那么效果相当于把负号作为-标识符来处理。。因此，上例中如果n为负数，输出结果首先是一个%负号，后面再跟-n-1个空格</p> </li><li> <p>有关于上面的总结：</p> <p>下面对几个进行区分：</p> <p>（1）<mark>%m.nd:m代表输出一共占m列，不够m列前面补空格，够m列不作任何处理，n代表这个数一共要有n列，不够前面补0，够n列不做任何处理。</mark></p> <p><mark>注意：m是把包括负号（正号、0x、0）在内一共是m个字符，而n是只算数字是总共n个数字。前者不够补空格，后者不够补0。</mark></p> <p><img alt=\"image-20220307112620666\" src=\"..\\..\\static\\image\\dbac2a0713da7df913e717baa7690df7.png\"/></p> <p><strong>在大多数场合下，我们都可以用%.来代替%0，效果非常接近。</strong></p> <p>下面是例子：</p> <p><img alt=\"image-20220307114910383\" src=\"..\\..\\static\\image\\987767488abc28eedaf8fb839e8d6aa5.png\"/></p> <p>（2）<mark>%m.ns:m代表这个字符串一共输出m列，n代表取这个字符串前n个元素输出到整个m列的右侧，当n&lt;m时，用空格补齐左边的余缺，当n&gt;=m时，不做处理。</mark></p> <p>下面是例子：</p> <p><img alt=\"image-20220307115944317\" src=\"..\\..\\static\\image\\afe35ca53b264a1b5293c4b6b4ce9fae.png\"/></p> <p>（3）<mark>%m.nf:m代表这个数一共要输出m列，包括小数点和小数的位数，n代表小数的个数，当浮点数的小数的位数大于n时，采用四舍五入（1-5舍掉，6-9进位），小于n时，后面补0</mark></p> <p>下面是例子：</p> <p><img alt=\"image-20220307120249656\" src=\"..\\..\\static\\image\\6c509bad779a0d2d50211b6731c13e8a.png\"/></p> </li></ol>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-01 13:43:20", "summary": "第七章可移植性缺陷字符是有符号整数还是无符号整数逻辑运算符内存位置大小写转换附录字符是有符号整数还是无符号整数一个常见的错误认知就是：如果是一个字符变量，使用就可得到与等价的无符号整数。这是会失败的，"}