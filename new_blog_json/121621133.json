{"blogid": "121621133", "writerAge": "码龄11年", "writerBlogNum": "149", "writerCollect": "378", "writerComment": "62", "writerFan": "255", "writerGrade": "5级", "writerIntegral": "2018", "writerName": "斯内科", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_121621133.jpg", "writerRankTotal": "15059", "writerRankWeekly": "31338", "writerThumb": "60", "writerVisitNum": "136508", "blog_read_count": "2950", "blog_time": "于 2021-12-10 19:59:02 发布", "blog_title": "C#Base64简单加密与解密", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2><strong>Base64属于简单加密算法的一种。类似于凯撒密码【</strong>它是一种替换加密的技术<strong>】</strong></h2>\n<p><span style=\"color:#fe2c24;\"><strong>Base64字符串由65个字符组成，</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>大写字母A~Z，</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>小写字母a~z,</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>数字0~9，以及三个特殊字符+、/、=  </strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>【=“等号”用于补充字符，使Base64字符串长度变成4的倍数】</strong></span></p>\n<h2>规则</h2>\n<p>考虑到初始源字符串可能是任何文本编码的【中文GBK，Unicode，ASCII等】，因此Base64字符串加密只处理字节数组【字节数组通过encoding.GetBytes(string src)获得】。</p>\n<p><strong><span style=\"color:#fe2c24;\">Base64编码字符串的长度一定是4的倍数。</span></strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3*8 = 4*6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，因此每个Base64字节的十进制范围为0~63。也就是说，转换后的字符串理论上将要比原来的长1/3。</strong></span></p>\n<p>字节数组的长度应该是3的倍数，如果这个条件不能满足的话，具体的解决办法是这样的：原文剩余的字节根据编码规则继续单独转(1变2，2变3；不够的位数用0补全)，再用=号补满4个字节。这就是为什么有些Base64编码会以一个或两个等号结束的原因，但等号最多只有两个。因为一个原字节至少会变成两个目标字节，所以余数任何情况下都只可能是0，1，2这三个数中的一个。如果余数是0的话，就表示原文字节数正好是3的倍数（最理想的情况）。如果是1的话，转成2个Base64编码字符，为了让Base64编码是4的倍数，就要补2个等号；同理，如果是2的话，就要补1个等号。 </p>\n<h2>6Bit数字【0~63】映射Base64字符表如下</h2>\n<table><tbody><tr><td> <p><strong>索引</strong></p> </td><td> <p><strong>对应字符</strong></p> </td><td> <p><strong>索引</strong></p> </td><td> <p><strong>对应字符</strong></p> </td><td> <p><strong>索引</strong></p> </td><td> <p><strong>对应字符</strong></p> </td><td> <p><strong>索引</strong></p> </td><td> <p><strong>对应字符</strong></p> </td></tr><tr><td> <p>0</p> </td><td> <p><strong>A</strong></p> </td><td> <p>17</p> </td><td> <p><strong>R</strong></p> </td><td> <p>34</p> </td><td> <p><strong>i</strong></p> </td><td> <p>51</p> </td><td> <p><strong>z</strong></p> </td></tr><tr><td> <p>1</p> </td><td> <p><strong>B</strong></p> </td><td> <p>18</p> </td><td> <p><strong>S</strong></p> </td><td> <p>35</p> </td><td> <p><strong>j</strong></p> </td><td> <p>52</p> </td><td> <p><strong>0</strong></p> </td></tr><tr><td> <p>2</p> </td><td> <p><strong>C</strong></p> </td><td> <p>19</p> </td><td> <p><strong>T</strong></p> </td><td> <p>36</p> </td><td> <p><strong>k</strong></p> </td><td> <p>53</p> </td><td> <p><strong>1</strong></p> </td></tr><tr><td> <p>3</p> </td><td> <p><strong>D</strong></p> </td><td> <p>20</p> </td><td> <p><strong>U</strong></p> </td><td> <p>37</p> </td><td> <p><strong>l</strong></p> </td><td> <p>54</p> </td><td> <p><strong>2</strong></p> </td></tr><tr><td> <p>4</p> </td><td> <p><strong>E</strong></p> </td><td> <p>21</p> </td><td> <p><strong>V</strong></p> </td><td> <p>38</p> </td><td> <p><strong>m</strong></p> </td><td> <p>55</p> </td><td> <p><strong>3</strong></p> </td></tr><tr><td> <p>5</p> </td><td> <p><strong>F</strong></p> </td><td> <p>22</p> </td><td> <p><strong>W</strong></p> </td><td> <p>39</p> </td><td> <p><strong>n</strong></p> </td><td> <p>56</p> </td><td> <p><strong>4</strong></p> </td></tr><tr><td> <p>6</p> </td><td> <p><strong>G</strong></p> </td><td> <p>23</p> </td><td> <p><strong>X</strong></p> </td><td> <p>40</p> </td><td> <p><strong>o</strong></p> </td><td> <p>57</p> </td><td> <p><strong>5</strong></p> </td></tr><tr><td> <p>7</p> </td><td> <p><strong>H</strong></p> </td><td> <p>24</p> </td><td> <p><strong>Y</strong></p> </td><td> <p>41</p> </td><td> <p><strong>p</strong></p> </td><td> <p>58</p> </td><td> <p><strong>6</strong></p> </td></tr><tr><td> <p>8</p> </td><td> <p><strong>I</strong></p> </td><td> <p>25</p> </td><td> <p><strong>Z</strong></p> </td><td> <p>42</p> </td><td> <p><strong>q</strong></p> </td><td> <p>59</p> </td><td> <p><strong>7</strong></p> </td></tr><tr><td> <p>9</p> </td><td> <p><strong>J</strong></p> </td><td> <p>26</p> </td><td> <p><strong>a</strong></p> </td><td> <p>43</p> </td><td> <p><strong>r</strong></p> </td><td> <p>60</p> </td><td> <p><strong>8</strong></p> </td></tr><tr><td> <p>10</p> </td><td> <p><strong>K</strong></p> </td><td> <p>27</p> </td><td> <p><strong>b</strong></p> </td><td> <p>44</p> </td><td> <p><strong>s</strong></p> </td><td> <p>61</p> </td><td> <p><strong>9</strong></p> </td></tr><tr><td> <p>11</p> </td><td> <p><strong>L</strong></p> </td><td> <p>28</p> </td><td> <p><strong>c</strong></p> </td><td> <p>45</p> </td><td> <p><strong>t</strong></p> </td><td> <p>62</p> </td><td> <p><strong>+</strong></p> </td></tr><tr><td> <p>12</p> </td><td> <p><strong>M</strong></p> </td><td> <p>29</p> </td><td> <p><strong>d</strong></p> </td><td> <p>46</p> </td><td> <p><strong>u</strong></p> </td><td> <p>63</p> </td><td> <p><strong>/</strong></p> </td></tr><tr><td> <p>13</p> </td><td> <p><strong>N</strong></p> </td><td> <p>30</p> </td><td> <p><strong>e</strong></p> </td><td> <p>47</p> </td><td> <p><strong>v</strong></p> </td><td style=\"vertical-align:top;\"></td><td style=\"vertical-align:top;\"></td></tr><tr><td> <p>14</p> </td><td> <p><strong>O</strong></p> </td><td> <p>31</p> </td><td> <p><strong>f</strong></p> </td><td> <p>48</p> </td><td> <p><strong>w</strong></p> </td><td style=\"vertical-align:top;\"></td><td style=\"vertical-align:top;\"></td></tr><tr><td> <p>15</p> </td><td> <p><strong>P</strong></p> </td><td> <p>32</p> </td><td> <p><strong>g</strong></p> </td><td> <p>49</p> </td><td> <p><strong>x</strong></p> </td><td style=\"vertical-align:top;\"></td><td style=\"vertical-align:top;\"></td></tr><tr><td> <p>16</p> </td><td> <p><strong>Q</strong></p> </td><td> <p>33</p> </td><td> <p><strong>h</strong></p> </td><td> <p>50</p> </td><td> <p><strong>y</strong></p> </td><td style=\"vertical-align:top;\"></td><td style=\"vertical-align:top;\"></td></tr></tbody></table>\n<h2><strong> 测试Base64源程序</strong></h2>\n<p>新建WinForm应用程序Base64EncoderDemo，重命名默认的 Form1为FormBase64Encoder，</p>\n<p>窗体FormBase64Encoder设计如图：</p>\n<p><img alt=\"\" height=\"550\" src=\"..\\..\\static\\image\\72f66dc377a94155a330f6830b797788.png\" width=\"1200\"/></p>\n<h2>FormBase64Encoder.cs主要代码如下</h2>\n<h3>（忽略设计器自动生成的代码）：</h3>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace Base64EncoderDemo\n{\n    public partial class FormBase64Encoder : Form\n    {\n        public FormBase64Encoder()\n        {\n            InitializeComponent();\n            //参考Convert微软源程序\n            //https://referencesource.microsoft.com/#mscorlib/system/convert.cs,fc990bd1275d43d6\n        }\n\n        private void FormBase64Encoder_Load(object sender, EventArgs e)\n        {\n            rtxtMessage.ReadOnly = true;\n            //编码格式\n            cboEncoding.Items.AddRange(new string[] { \"ASCII\", \"Unicode\", \"UTF-8\", \"GBK\" });\n            cboEncoding.SelectedIndex = 0;\n        }\n\n        private void btnClear_Click(object sender, EventArgs e)\n        {\n            rtxtSourceString.Clear();\n            rtxtBase64String.Clear();\n            rtxtMessage.Clear();\n        }\n\n        /// &lt;summary&gt;\n        /// 显示提示消息\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"content\"&gt;&lt;/param&gt;\n        private void DisplayMessage(string content)\n        {\n            if (rtxtMessage.TextLength &gt;= 20480)\n            {\n                rtxtMessage.Clear();\n            }\n            rtxtMessage.AppendText($\"{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")} -&gt; {content}\\n\");\n            rtxtMessage.ScrollToCaret();\n        }\n\n        private void btnConvertBase64_Click(object sender, EventArgs e)\n        {\n            rtxtBase64String.Clear();\n            if (rtxtSourceString.Text.Trim().Length == 0)\n            {\n                rtxtSourceString.Focus();\n                DisplayMessage(\"源字符串不能为空\");\n                return;\n            }\n            try\n            {\n                Encoding encoding = Encoding.GetEncoding(cboEncoding.Text);\n                byte[] buffer = encoding.GetBytes(rtxtSourceString.Text.Trim());\n                rtxtBase64String.Text = Convert.ToBase64String(buffer, Base64FormattingOptions.None);\n                DisplayMessage($\"转换成功，Base64字符串【{rtxtBase64String.Text}】\");\n            }\n            catch (Exception ex)\n            {\n                DisplayMessage($\"转换为Base64时出错：【{ex.Message}】\");\n            }\n        }\n\n        private void btnRestore_Click(object sender, EventArgs e)\n        {\n            rtxtSourceString.Clear();\n            if (rtxtBase64String.Text.Trim().Length == 0)\n            {\n                rtxtBase64String.Focus();\n                DisplayMessage(\"Base64字符串不能为空\");\n                return;\n            }\n            try\n            {\n                Encoding encoding = Encoding.GetEncoding(cboEncoding.Text);\n                byte[] buffer = Convert.FromBase64String(rtxtBase64String.Text);\n                rtxtSourceString.Text = encoding.GetString(buffer);\n                DisplayMessage($\"还原成功，源字符串【{rtxtSourceString.Text}】\");\n            }\n            catch (Exception ex)\n            {\n                DisplayMessage($\"还原字符串时出错：【{ex.Message}】\");\n            }\n        }\n    }\n}\n</code></pre>\n<h2>程序运行如图：</h2>\n<p><img alt=\"\" height=\"518\" src=\"..\\..\\static\\image\\46c4cdb5984a442b8a45f880b8e1a4a4.png\" width=\"1200\"/></p>\n<p> </p>\n<h2>参考微软源代码：<a href=\"https://referencesource.microsoft.com/#mscorlib/system/convert.cs,37f71bcd2a713cd5\" title=\"Reference Source\">Reference Source</a></h2>\n<pre><code>public static unsafe String ToBase64String(byte[] inArray, int offset, int length, Base64FormattingOptions options) {\n            //Do data verfication\n            if (inArray==null) \n                throw new ArgumentNullException(\"inArray\");\n            if (length&lt;0)\n                throw new ArgumentOutOfRangeException(\"length\", Environment.GetResourceString(\"ArgumentOutOfRange_Index\"));\n            if (offset&lt;0)\n                throw new ArgumentOutOfRangeException(\"offset\", Environment.GetResourceString(\"ArgumentOutOfRange_GenericPositive\"));\n            if (options &lt; Base64FormattingOptions.None || options &gt; Base64FormattingOptions.InsertLineBreaks)\n                throw new ArgumentException(Environment.GetResourceString(\"Arg_EnumIllegalVal\", (int)options));\n            Contract.Ensures(Contract.Result&lt;string&gt;() != null);\n            Contract.EndContractBlock();\n \n            int inArrayLength;\n            int stringLength;\n \n            inArrayLength = inArray.Length;\n            if (offset &gt; (inArrayLength - length))\n                throw new ArgumentOutOfRangeException(\"offset\", Environment.GetResourceString(\"ArgumentOutOfRange_OffsetLength\"));\n           \n            if (inArrayLength == 0)\n                return String.Empty;\n \n            bool insertLineBreaks = (options == Base64FormattingOptions.InsertLineBreaks);\n            //Create the new string.  This is the maximally required length.\n            stringLength = ToBase64_CalculateAndValidateOutputLength(length, insertLineBreaks);\n \n            string returnString = string.FastAllocateString(stringLength);\n            fixed (char* outChars = returnString){\n                fixed (byte* inData = inArray) {\n                    int j = ConvertToBase64Array(outChars,inData,offset,length, insertLineBreaks);\n                    BCLDebug.Assert(returnString.Length == j, \"returnString.Length == j\");\n                    return returnString;\n                }\n            }\n        }\n </code></pre>\n<p><strong>Base64处理字节数组逻辑函数</strong></p>\n<pre><code>internal static readonly char[] base64Table = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',\n                                                       'P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d',\n                                                       'e','f','g','h','i','j','k','l','m','n','o','p','q','r','s',\n                                                       't','u','v','w','x','y','z','0','1','2','3','4','5','6','7',\n                                                       '8','9','+','/','=' };        \n \n        private const Int32 base64LineBreakPosition = 76;     </code></pre>\n<pre><code>[System.Security.SecurityCritical]  // auto-generated\n        private static unsafe int ConvertToBase64Array(char* outChars, byte* inData, int offset, int length, bool insertLineBreaks) {\n            int lengthmod3 = length%3;\n            int calcLength = offset + (length - lengthmod3);\n            int j=0;\n            int charcount = 0;\n            //Convert three bytes at a time to base64 notation.  This will consume 4 chars.\n            int i;\n \n            // get a pointer to the base64Table to avoid unnecessary range checking\n            fixed(char* base64 = base64Table) {\n                for (i=offset; i&lt;calcLength; i+=3)\n                {\n                    if (insertLineBreaks) {\n                        if (charcount == base64LineBreakPosition) {\n                            outChars[j++] = '\\r';\n                            outChars[j++] = '\\n';\n                            charcount = 0;\n                        }\n                        charcount += 4;\n                    }\n                    outChars[j] = base64[(inData[i]&amp;0xfc)&gt;&gt;2];\n                    outChars[j+1] = base64[((inData[i]&amp;0x03)&lt;&lt;4) | ((inData[i+1]&amp;0xf0)&gt;&gt;4)];\n                    outChars[j+2] = base64[((inData[i+1]&amp;0x0f)&lt;&lt;2) | ((inData[i+2]&amp;0xc0)&gt;&gt;6)];\n                    outChars[j+3] = base64[(inData[i+2]&amp;0x3f)];\n                    j += 4;\n                }\n \n                //Where we left off before\n                i =  calcLength;\n \n                if (insertLineBreaks &amp;&amp; (lengthmod3 !=0) &amp;&amp; (charcount == base64LineBreakPosition)) {\n                    outChars[j++] = '\\r';\n                    outChars[j++] = '\\n';\n                }\n                    \n                switch(lengthmod3)\n                {\n                case 2: //One character padding needed\n                    outChars[j] = base64[(inData[i]&amp;0xfc)&gt;&gt;2];\n                    outChars[j+1] = base64[((inData[i]&amp;0x03)&lt;&lt;4)|((inData[i+1]&amp;0xf0)&gt;&gt;4)];\n                    outChars[j+2] = base64[(inData[i+1]&amp;0x0f)&lt;&lt;2];\n                    outChars[j+3] = base64[64]; //Pad\n                    j+=4;\n                    break;\n                case 1: // Two character padding needed\n                    outChars[j] = base64[(inData[i]&amp;0xfc)&gt;&gt;2];\n                    outChars[j+1] = base64[(inData[i]&amp;0x03)&lt;&lt;4];\n                    outChars[j+2] = base64[64]; //Pad\n                    outChars[j+3] = base64[64]; //Pad\n                    j+=4;\n                    break;\n                }\n            }\n            \n            return j;\n        }\n \n        private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks) {\n            long outlen = ((long)inputLength) / 3 * 4;          // the base length - we want integer division here. \n            outlen += ((inputLength % 3) != 0) ? 4 : 0;         // at most 4 more chars for the remainder\n \n            if (outlen == 0)\n                return 0;\n \n            if (insertLineBreaks) {\n                long newLines = outlen / base64LineBreakPosition;\n                if ((outlen % base64LineBreakPosition) == 0) {\n                    --newLines;    \n                }\n                outlen += newLines * 2;              // the number of line break chars we'll add, \"\\r\\n\"\n            }\n \n            // If we overflow an int then we cannot allocate enough\n            // memory to output the value so throw\n            if (outlen &gt; int.MaxValue)\n                throw new OutOfMemoryException();\n \n            return (int)outlen;\n        }</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-12-10 19:59:02", "summary": "属于简单加密算法的一种。类似于凯撒密码它是一种替换加密的技术字符串由个字符组成，大写字母，小写字母数字，以及三个特殊字符、、等号用于补充字符，使字符串长度变成的倍数规则考虑到初始源字符串可能是任何文本"}