{"blogid": "123550498", "writerAge": "码龄2年", "writerBlogNum": "37", "writerCollect": "111", "writerComment": "3", "writerFan": "14", "writerGrade": "2级", "writerIntegral": "398", "writerName": "TBDBTUO", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123550498.jpg", "writerRankTotal": "57665", "writerRankWeekly": "492538", "writerThumb": "11", "writerVisitNum": "30331", "blog_read_count": "12355", "blog_time": "已于 2022-05-08 19:08:00 修改", "blog_title": "SQL连接表(内连接、左连接、右连接、交叉连接、全外连接)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>分享一些自己的连表总结</strong></p>\n<h1><a id=\"_1\"></a>什么是连接表？</h1>\n<ul><li> <h3><a id=\"_2\"></a>多表查询原理：将多个表通过笛卡尔积形成一个虚表，再根据查询条件筛选符合条件的数据。</h3> </li><li>在关系数据库中，<strong>数据分布</strong>在多个逻辑表中。 要获得完整有意义的<strong>数据集</strong>，需要使用连接来查询这些表<br/> 中的数据。 SQL Server支持多种 \n  <ul><li><strong>连接</strong>包括 \n    <ul><li>INNER JOIN:内连接,关键字在表中存在至少一个匹配时返回行。</li><li>left join : 左连接，返回左表中所有的记录以及右表中连接字段相等的记录。</li><li>right join : 右连接，返回右表中所有的记录以及左表中连接字段相等的记录。</li><li>inner join : 内连接，又叫等值连接，只返回两个表中连接字段相等的行。</li><li>full join : 外连接，返回两个表中的行：left join + right join。</li><li>cross join : 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</li><li>GROUP BY:全外连接， 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前</li></ul> </li></ul> </li></ul>\n<p><strong>每种连接类型指定SQL Server如何使用一个表中的数据来选择另一个表中的行</strong></p>\n<h2><a id=\"A_SQL_Server_16\"></a>A. SQL Server内连接</h2>\n<ul><li><mark>内连接</mark>是SQL Server中最常用的连接之一。 <strong>内部联接子句</strong>用于查询来自两个或多个相关表的数据。</li><li>SQL Server <strong>INNER JOIN</strong> 子句的语法：<br/> 在此语法中，从 T1 和 T2 表中查询检索数据： \n  <ul><li>首先，在 FROM 子句中指定主表( T1 )</li><li>其次，在 INNER JOIN 子句和连接谓词中指定第二个表( T2 )。 只有连接谓词计算为 TRUE 的行才包<br/> 含在结果集中。</li></ul> </li></ul>\n<blockquote>\n<p>**INNER JOIN **子句将表 T1 的每一行与表 T2 的行进行比较，以查找满足连接谓词的所有行对。 如果连接<br/> 谓词的计算结果为 TRUE ，则匹配<br/> 的 T1 和 T2 行的列值将合并为一个新行并包含在结果集中。</p>\n</blockquote>\n<p>下图说明了两个结果集的内联接的结果：<br/> 使用两个 INNER JOIN 子句来查询三个表中的数据：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8921c676c7ea475d92d72980efa9e183.png\"/></p>\n<blockquote>\n<p>图中左右两边的表是<strong>有关联的</strong>，中间黄色的<strong>交互区</strong>就是他们两个关联表中<strong>关联的数据</strong>。<br/> 使用<strong>INNER JOIN</strong>可以在两个有关联数据的表中把关联的数据查询出来</p>\n</blockquote>\n<p>使用两个 <strong>INNER JOIN</strong> 子句来查询三个表中的数据：<br/> <strong>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span>\n\t<span class=\"token comment\">--在下面吗三张表中需要查询的数据</span>\n\tproduct_name<span class=\"token punctuation\">,</span>\n\tcategory_name<span class=\"token punctuation\">,</span>\n\tbrand_name<span class=\"token punctuation\">,</span> \n\tlist_price\n<span class=\"token keyword\">FROM</span>\n\t数据表<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> p    <span class=\"token comment\">-- p是数据表的引用变量，可以通过p.出数据表格(1)中的列名 </span>\n<span class=\"token comment\">--使用INNER JOIN通过数据表(1)category_id值查询出对应在数据表(2)的关联数据</span>\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> 数据表<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> c <span class=\"token keyword\">ON</span> c数据表<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>category_id <span class=\"token operator\">=</span> p数据表<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>category_id \n<span class=\"token comment\">--使用INNER JOIN通过数据表(1)中brand_id值查询出对应在数据表(3)的关联数据</span>\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> 数据表<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> b <span class=\"token keyword\">ON</span> b数据表<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>brand_id <span class=\"token operator\">=</span> p数据表<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>brand_id \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> \t<span class=\"token comment\">--查询结果升序排序</span>\n\tproduct_name <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"B_SQL_Server_51\"></a>B. SQL Server左连接</h2>\n<ul><li><strong>LEFT JOIN</strong> 子句用于查询来自多个表的数据。它<strong>返回左表中</strong>的所有行和右表中的<strong>匹配行</strong>。<br/> 如果在右表中找不到匹配的行，则使用 <strong>NULL 代替</strong>显示。</li></ul>\n<h4><a id=\"_55\"></a>以下图说明了两个结果集的左连接结果：</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ad5d04c9b7ec430ba153f82a05adf20e.png\"/><br/> 以下说明如何使用 LEFT JOIN 子句来连接两个表 student(学生表) 和 sc(成绩表) ：</p>\n<blockquote>\n<p>下面的小案例左表(学生表)通过某列名在右表(成绩表)中查询出在<strong>相同列名</strong>中的一行数据</p>\n</blockquote>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span>\n\ts<span class=\"token punctuation\">.</span>sno<span class=\"token punctuation\">,</span><span class=\"token comment\">--学生表中的学生学号\t\t</span>\n\tc<span class=\"token punctuation\">.</span>cno<span class=\"token punctuation\">,</span><span class=\"token comment\">--成绩表中的课程号</span>\n\tc<span class=\"token punctuation\">.</span>score<span class=\"token comment\">--成绩表中学生的在此课程中的成绩</span>\n<span class=\"token keyword\">FROM</span> \n\tstudent s \t\t\t\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> sc c <span class=\"token keyword\">ON</span><span class=\"token comment\">--使用LEFT JOIN获取sc(成绩表)</span>\n\tc<span class=\"token punctuation\">.</span>sno<span class=\"token operator\">=</span>s<span class=\"token punctuation\">.</span>sno<span class=\"token punctuation\">;</span> <span class=\"token comment\">--通过student(学生ID)等于成绩表中(学生ID)选择到学生表在成绩表中的数据</span>\n</code></pre>\n<p>以下是上面左连接查询语句的查询结果:*</p>\n<blockquote>\n<p>图中为空的格子是在右表(成绩表)中 没有该学生学号下的考试课程与成绩，所以默认返回了一个<strong>NULL值</strong><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\39358a76898c4a67bef713761437ba95.png\"/></p>\n</blockquote>\n<p>对于 学生表中的每一行，查询将其与 成绩 表中的所有行进行比较。 如果一对行导致连接谓词计算为<br/> TRUE ，则将组合这些行中的列值以形成新行，然后将其包含在结果集中。</p>\n<ul><li>如果左表( T1 )中的行没有与来自 T2 表的任何匹配行，则查询将左表中的行的列值与来自右表的每个列<br/> 值的 NULL 组合。</li></ul>\n<h2><a id=\"C_ONWHERE_79\"></a>C. ON与WHERE子句</h2>\n<h3><a id=\"_on_80\"></a>关键字 on</h3>\n<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。<br/> 在使用 left jion 时，on 和 where 条件的区别如下：</p>\n<ul><li>1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。</li><li>2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li></ul>\n<p>假设有两张表：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\510ba0aab7994891989a80af8eec6e3c.png\"/><br/> 两条SQL语句:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tab1 <span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> tab2 <span class=\"token keyword\">on</span> <span class=\"token punctuation\">(</span>tab1<span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> tab2<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span> tab2<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">'AAA'</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tab1 <span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> tab2 <span class=\"token keyword\">on</span> <span class=\"token punctuation\">(</span>tab1<span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> tab2<span class=\"token punctuation\">.</span>size <span class=\"token operator\">and</span> tab2<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">'AAA'</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\42baabf2ef9e4806bd59b6964a46468c.png\"/><br/> 其实以上结果的关键原因就是<strong>left join、right join、full join</strong>的特殊性，不管 on 上的条件是否为真都会返回 left 或 right 表中的记录，full 则具有 left 和 right 的特性的并集。 <strong>而 inner jion 没这个特殊性</strong>，则条件放在 on 中和 where 中，返回的结果集是<strong>相同的</strong>。</p>\n<h2><a id=\"D_SQL_Server_96\"></a>D. SQL Server右连接</h2>\n<p><strong>RIGHT JOIN</strong> 子句组合来自两个或多个表的数据。</p>\n<ul><li><strong>RIGHT JOIN</strong> 开始从**右表中选择数据并与左表中的行<br/> 匹配。 RIGHT JOIN 返回一个结果集，该结果集包含右表中的所有行，无论是否具有左表中的匹配行。<br/> 如果右表中的行没有来自右表的任何匹配行，则结果集中右表的列将使用 NULL 值。</li></ul>\n<p>以下是 RIGHT JOIN 的语法：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span>\n\tselect_list\n<span class=\"token keyword\">FROM</span>\n\tT1\n<span class=\"token keyword\">RIGHT</span> <span class=\"token keyword\">JOIN</span> T2 <span class=\"token keyword\">ON</span> join_predicate<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">SQL</span>\n</code></pre>\n<p>在此语法中， T1 是左表， T2 是右表。<br/> 请注意， RIGHT JOIN 和 RIGHT OUTER JOIN 是相同的。 OUTER 关键字是可选的。<br/> 下图说明了 RIGHT JOIN 操作<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c1c52c28e54f4835bcc48fc0331f880a.png\"/><br/> 橙色部分表示返回的结果集。<br/> SQL Server RIGHT JOIN示例<br/> 以下语句返回 production.products 表中的产品名称和 sales.order_items 所有 order_id ：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span>\n\tproduct_name<span class=\"token punctuation\">,</span>\n\torder_id \n<span class=\"token keyword\">FROM</span>\n\tsales<span class=\"token punctuation\">.</span>order_items o \n<span class=\"token keyword\">RIGHT</span> <span class=\"token keyword\">JOIN</span> \n\tproduction<span class=\"token punctuation\">.</span>products p <span class=\"token keyword\">ON</span> o<span class=\"token punctuation\">.</span>product_id <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>product_id \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> \n\torder_id<span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"E_SQL_Server__129\"></a>E. SQL Server 交叉连接</h2>\n<p>CROSS JOIN 连接两个或多个不相关的表。<br/> 以下是两个表的SQL Server CROSS JOIN 的语法：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> \n\tselect_list \n<span class=\"token keyword\">FROM</span> \n\tT1 \n \t<span class=\"token keyword\">CROSS</span> <span class=\"token keyword\">JOIN</span> T2<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>CROSS JOIN 将第一个表(T1)中的每一行与第二个表(T2)中的每一行连接起来。 换句话说，交叉连接返回<br/> 两个表中行的<strong>笛卡尔积</strong>。 与INNER JOIN或LEFT JOIN不同，交叉连接不会在连接的表之间建立关系。</p>\n<blockquote>\n<p>假设 T1 表包含三行： 1 , 2 和 3 ， T2 表包含三行： A ， B 和 C 。 CROSS JOIN 从第一个表(T1)获取一行，然后为第二个表(T2)中的每一行创建一个新行。 然后它对第一个<br/> 表(T1)中的下一行执行相同操作，<strong>依此类推</strong>。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\558b5facf7b9452fb572516900e95011.png\"/><br/> 在此图中， CROSS JOIN 总共创建了 9 行。 通常，如果第一个表有 n 行，第二个表有 m 行，则交叉连接<br/> 将产生 n x m 行。</p>\n<h2><a id=\"F_SQL_Server_147\"></a>F. SQL Server自连接</h2>\n<p>自联接用于将表连接到自身(同一个表)。 它对于查询分层数据或比较同一个表中的行很有用。<br/> 自联接使用内连接或左连接子句。 由于使用自联接的查询引用同一个表，因此表别名用于为查询中的表<br/> 分配不同的名称</p>\n<blockquote>\n<p>请注意，如果在不使用<strong>表别名</strong>的情况下在查询中多次引用同一个表，则会出现错误。</p>\n</blockquote>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span>\n\tt1<span class=\"token punctuation\">.</span>sno<span class=\"token punctuation\">,</span>t2<span class=\"token punctuation\">.</span>sno\n<span class=\"token keyword\">FROM</span>\n\tsc t1<span class=\"token punctuation\">,</span>sc t2 \n</code></pre>\n<p>上面查询语句中两次引用表 T 。表别名 t1 和 t2 用于为 T 表分配不同的名称。</p>\n<p>staffs 表存储员工信息，如身份证，名字，姓氏和电子邮件。 它还有一个名为 manager_id 的列，用<br/> 于指定直接管理者。 例如，员工 Mireya 向管理员者 Fabiola 汇报工作，因为 Mireya 的 manager_id<br/> 列中的值是 Fabiola 。 Fabiola 没有经理，因为它的 manager_id 列是一个 NULL 值。<br/> 要获取工作汇报关系，请使用自联接，如以下查询中所示：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span>\n\te<span class=\"token punctuation\">.</span>first_name <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>last_name employee<span class=\"token punctuation\">,</span> \n\tm<span class=\"token punctuation\">.</span>first_name <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> m<span class=\"token punctuation\">.</span>last_name manager \n<span class=\"token keyword\">FROM</span>\n\tsales<span class=\"token punctuation\">.</span>staffs e \n\t<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> sales<span class=\"token punctuation\">.</span>staffs m <span class=\"token keyword\">ON</span> m<span class=\"token punctuation\">.</span>staff_id <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>manager_id \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> \n\tmanager<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在这个例子中，两次引用了 staffs 表：一个是员工的 e ，另一个是管理者的 m 。<br/> 连接谓词使用 e.manager_id 和 m.staff_id 列中的值匹配 employee 和 manager 关系。<br/> 由于 INNER JOIN 效应， employee 列没有 Fabiola Jackson 。 如果用 LEFT JOIN 子句替换 INNER JOIN 子句，将获得在 employee 列中包含 Fabiola Jackson 的<strong>结果集</strong></p>\n<h2><a id=\"G_SQL_Server_178\"></a>G. SQL Server全外链接?</h2>\n<p>FULL OUTER JOIN当左表或右表中存在匹配项时，该命令将返回所有行。<br/> 以下SQL语句选择所有客户和所有订单：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> \n\tCustomers<span class=\"token punctuation\">.</span>CustomerName<span class=\"token punctuation\">,</span> \n\tOrders<span class=\"token punctuation\">.</span>OrderID \n<span class=\"token keyword\">FROM</span> \n\tCustomers \n<span class=\"token keyword\">FULL</span> <span class=\"token keyword\">OUTER</span> <span class=\"token keyword\">JOIN</span> \n\tOrders <span class=\"token keyword\">ON</span> Customers<span class=\"token punctuation\">.</span>CustomerID<span class=\"token operator\">=</span>Orders<span class=\"token punctuation\">.</span>CustomerID \n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> \nCustomers<span class=\"token punctuation\">.</span>CustomerName<span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>注：FULL OUTER JOIN关键字返回左表（Customers）所有行，以及所有来自右表（Orders）的行。如<br/> 果“Customers”中的某些行在“Orders”中没有匹配项，或者在“Orders”中的某些行在“Customers”中没有<br/> 匹配项，则这些行也将被列出。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-05-08 19:08:00", "summary": "分享一些自己的连表总结什么是连接表？多表查询原理：将多个表通过笛卡尔积形成一个虚表，再根据查询条件筛选符合条件的数据。在关系数据库中，数据分布在多个逻辑表中。要获得完整有意义的数据集，需要使用连接来查"}