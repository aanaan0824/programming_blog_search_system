{"blogid": "122155005", "writerAge": "码龄5年", "writerBlogNum": "267", "writerCollect": "6445", "writerComment": "191", "writerFan": "980", "writerGrade": "7级", "writerIntegral": "18249", "writerName": "路途…", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122155005.jpg", "writerRankTotal": "517", "writerRankWeekly": "17556", "writerThumb": "1402", "writerVisitNum": "2390168", "blog_read_count": "1704", "blog_time": "于 2021-12-26 14:16:37 发布", "blog_title": "【C#】线程操作总结", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\44fdfa718cd69806bfdd4f3023848537.png\"/></p>\n<h3><a id=\"1__6\"></a>1. 线程基础</h3>\n<h4><a id=\"1__8\"></a>.1. 生命周期</h4>\n<blockquote>\n<p>在线程的生命周期中，它要经过<code>新建（New）</code>、<code>就绪（Runnable</code>）、<code>行（Running）</code>、<code>阻塞（Blocked）</code>和<code>死亡（Dead）</code>五种状态。当线程start后，它不能一直\"独占\"着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换.</p>\n</blockquote>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\a4bce976dd1b901e7ad03bda7e60752b.png\"/></p>\n<ul><li><strong>新建状态（new）</strong>：指新建了一个线程对象。<strong>Thread t1 =new Thread();这里就新建了一个Thread类的线程对象。</strong></li><li><strong>就绪状态（Runnable）</strong>：当线程对象创建后，该线程对象自身或者其他对象调用了该对象的start()方法。该线程就位于了可运行池中，变的可运行，等待获取cpu的使用权。<strong>因为在同一时间里cpu只能执行某一个线程。</strong></li><li><strong>运行状态（Running）: 当就绪状态的线程获取了cpu的时间片或者说获取了cpu的执行时间</strong>，这时就会调用该线程对象的run()方法，然后就从就绪状态就入了运行状态。</li><li><strong>阻塞状态（Blocked）</strong>：**阻塞状态就是线程因为某种原因暂时放弃了对cpu的使用权，暂时停止运行。**直到线程再次进入就绪状态，才有机会转到运行状态。阻塞状态分为三种情况： \n  <ul><li>等待阻塞：运行状态的线程调用了<code>wait()方法后</code>，该线程会释放它所持有的锁，然后被jvm放入到等待池中，只有<code>等其他线程调用Object类的notify()方法或者norifyAll()方法时，才能进入重新进入到就绪状态</code>。</li><li>同步阻塞：<code>运行的线程在获取对象的同步锁时</code>，若该同步锁被别的线程占用，JVM就会把该线程设置为阻塞状态，一直到线程获取到同步锁，才能转入就绪状态。</li><li>其它阻塞：运行的线程在<code>执行sleep()或者join()方法</code>时，或者发出了<code>I/O请求</code>，JVM就会把该线程设置为阻塞状态，当<code>sleep()状态超时、join()等待等待线程终止或者超时</code>、或者I/O处理完毕时，线程重进转入到就绪状态。在这需要注意的是sleep()方法和wait()不同，sleep不会释放自身所持有的锁。</li></ul> </li><li>**死亡状态（Dead）：**当线程执行完了或者因异常退出了run()的执行，该线程的生命周期就结束了。</li></ul>\n<h4><a id=\"2__23\"></a>.2. 线程优先级</h4>\n<blockquote>\n<ul><li>记住当线程的优先级<code>没有指定时</code>，所有线程都携带<code>普通优先级</code>。</li><li>java优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li><li>记住优先级最高的线程在执行时被给予优先。但是<code>不能保证线程在启动时就进入运行状态</code>。</li><li>与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</li><li>由调度程序决定哪一个线程被执行。</li><li>t.<code>setPriority()</code>用来设定线程的优先级。</li><li>记住<code>在线程开始方法被调用之前，线程的优先级应该被设定</code>。</li><li>你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级。</li></ul>\n</blockquote>\n<h5><a id=\"1_c_demo_34\"></a>.1. c# demo</h5>\n<pre><code class=\"prism language-c#\">class Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Current thread priority: {0}\", Thread.CurrentThread.Priority);\n        Console.WriteLine(\"Running on all cores available\");\n        RunThreads();\n        Thread.Sleep(TimeSpan.FromSeconds(2));\n        Console.WriteLine(\"Running on a single core\");\n        Process.GetCurrentProcess().ProcessorAffinity = new IntPtr(1);\n        RunThreads();\n    }\n\n    static void RunThreads()\n    {\n        var sample = new ThreadSample();\n\n        var threadOne = new Thread(sample.CountNumbers);\n        threadOne.Name = \"ThreadOne\";\n        var threadTwo = new Thread(sample.CountNumbers);\n        threadTwo.Name = \"ThreadTwo\";\n\n        threadOne.Priority = ThreadPriority.Highest;\n        threadTwo.Priority = ThreadPriority.Lowest;\n        threadOne.Start();\n        threadTwo.Start();\n\n        Thread.Sleep(TimeSpan.FromSeconds(2));\n        sample.Stop();\n\n        Console.ReadKey();\n    }\n\n    class ThreadSample\n    {\n        private bool _isStopped = false;\n\n        public void Stop()\n        {\n            _isStopped = true;\n        }\n\n        public void CountNumbers()\n        {\n            long counter = 0;\n\n            while (!_isStopped)\n            {\n                counter++;\n            }\n\n            Console.WriteLine(\"{0} with {1,11} priority \" +\n                        \"has a count = {2,13}\", Thread.CurrentThread.Name,\n                        Thread.CurrentThread.Priority,\n                        counter.ToString(\"N0\"));\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"2__java_demo_97\"></a>.2. java demo</h5>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">//或取优先级</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPriority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//设置优先级</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setPriority</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span>MIN_PRIORITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPriority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setPriority</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span>MAX_PRIORITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPriority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setPriority</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPriority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//不同优先级设置</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CustomThread</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" : \"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CustomThread</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CustomThread</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t1<span class=\"token punctuation\">.</span><span class=\"token function\">setPriority</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span>MIN_PRIORITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t2<span class=\"token punctuation\">.</span><span class=\"token function\">setPriority</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span>MAX_PRIORITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4><a id=\"3__138\"></a>.3. 前台线程&amp;后台线程</h4>\n<blockquote>\n<p><code>应用程序必须运行完所有的前台线程才会完全退出</code>，<code>若前台线程未执行完成</code>，关闭应用程序后，<code>应用程序并没有完全退出</code>，在任务管理器中还存在此进程；而<code>对于后台线程</code>，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时<code>都会自动结束</code>。</p>\n<ul><li>后台线程：<code>后台线程是可以随时被CLR关闭而不引发异常的</code>，也就是说当后台线程被关闭时，资源的回收是立即的，不等待的，也不考虑后台线程是否执行完成，就算是正在执行中也立即被终止。【后台，存在于黑暗之中默默无闻，它的消亡和存在，别人也感受不到】</li><li>前台线程：前台线程是不会被立即关闭的，它的关闭只会发生在自己执行完成时，不受外在因素的影响。假如应用程序退出，造成它的前台线程终止，此时CLR仍然保持活动并运行，使应用程序能继续运行，当它的的前台线程都终止后，整个进程才会被销毁。</li><li><code>应用程序的主线程</code>以及使用<code>Thread构造的线程</code>都默认为<strong>前台线程</strong>, <code>线程池线程</code>也就是使用 <code>ThreadPool.QueueUserWorkItem()</code>和<code>Task工厂创建的线程都默认为后台线程</code></li><li>可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。</li><li>不管是前台线程还是后台线程，<code>如果线程内出现了异常，都会导致进程的终止</code>。</li><li><code>UI 一般使用前台进程</code>，<code>处理计算繁琐的一般放在后台进程</code>，否则会导致UI卡住。</li></ul>\n</blockquote>\n<h5><a id=\"1_c_demo_149\"></a>.1. c# demo</h5>\n<pre><code class=\"prism language-c#\">class Program\n{\n    static void Main(string[] args)\n    {\n        var sampleForeground = new ThreadSample(10);\n        var sampleBackground = new ThreadSample(20);\n\n        var threadOne = new Thread(sampleForeground.CountNumbers);\n        threadOne.Name = \"ForegroundThread\";\n        var threadTwo = new Thread(sampleBackground.CountNumbers);\n        threadTwo.Name = \"BackgroundThread\";\n        threadTwo.IsBackground = true;\n\n        threadOne.Start();\n        threadTwo.Start();\n\n        Console.ReadKey();\n    }\n\n    class ThreadSample\n    {\n        private readonly int _iterations;\n\n        public ThreadSample(int iterations)\n        {\n            _iterations = iterations;\n        }\n        public void CountNumbers()\n        {\n            for (int i = 0; i &lt; _iterations; i++)\n            {\n                Thread.Sleep(TimeSpan.FromSeconds(0.5));\n                Console.WriteLine(\"{0} prints {1}\", Thread.CurrentThread.Name, i);\n            }\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\23339bd9988f1f68ffffddcf331639e0.png\"/></p>\n<h4><a id=\"4_lockMonitor_193\"></a>.4. lock/Monitor</h4>\n<blockquote>\n<p>在多线程代码中，<code>多个线程可能会访问一些公共的资源（变量、方法逻辑等等）</code>，这些公共资源称为临界区（共享区）；临界区的资源是不安全，所以需要<code>通过线程同步对多个访问临界区的线程进行控制</code>.</p>\n<p>lock关键字可以锁住任何object类型及其派生类，但是尽量不要用public 类型的，否则实例将超出代码的控制范围。根据MSDN，常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (“myLock”) 违反此准则：</p>\n<ul><li>如果<code>实例可以被公共访问，将出现 lock (this) 问题</code>。</li><li>如果 <code>MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题</code>。</li><li>由于<code>进程中使用同一字符串的任何其他代码将共享同一个锁</code>，所以出现 lock(“myLock”) 问题。</li><li><strong>最好定义 private 对象 或 private static 对象进行上锁，从而保护所有实例所共有的数据。</strong></li></ul>\n</blockquote>\n<h5><a id=\"1__lock_C_demo_204\"></a>.1. lock C# demo</h5>\n<pre><code class=\"prism language-c#\">namespace LockTest\n{\n    class PrintNum\n    {\n        private object lockObj = new object();\n\n        public void PrintOddNum()\n        {\n            lock (lockObj)\n            {\n                Console.WriteLine(\"Print Odd numbers:\");\n                for (int i = 0; i &lt; 10; i++)\n                {\n                    if(i%2 != 0)\n                        Console.Write(i);\n                    Thread.Sleep(100);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNum printNum = new PrintNum();\n            for (int i = 0; i &lt; 3; i++)\n            {\n                Thread temp = new Thread(new ThreadStart(printNum.PrintOddNum));\n                temp.Start();\n            }\n\n            Console.Read();\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"2__lock_c__246\"></a>.2. lock c# 错误代码</h5>\n<pre><code class=\"prism language-c#\">#因为Main函数和PrintNum类型中都对printNum对象进行了加锁，所以当主线程获得了互斥锁之后，其他子线程都被block住了，没有办法执行PrintOddNum方法了。\nnamespace LockTest\n{\n    class PrintNum\n    {\n        private object lockObj = new object();\n\n        public void PrintOddNum()\n        {\n            lock (this)\n            {\n                Console.WriteLine(\"Print Odd numbers:\");\n                for (int i = 0; i &lt; 10; i++)\n                {\n                    if (i % 2 != 0)\n                        Console.Write(i);\n                    Thread.Sleep(100);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNum printNum = new PrintNum();\n            for (int i = 0; i &lt; 3; i++)\n            {\n                Thread temp = new Thread(new ThreadStart(printNum.PrintOddNum));\n                temp.Start();\n            }\n\n            lock (printNum)\n            {\n                Thread.Sleep(5000);\n                Console.WriteLine(\"Main thread will delay 5 seconds\");\n            }\n\n            Console.Read();\n        }\n    }\n}\n\n</code></pre>\n<h5><a id=\"3__Monitor_296\"></a>.3. Monitor</h5>\n<blockquote>\n<p>lock使用的就是Monitor类型的Enter和Exit方法。很多情况下lock就可以满足需求了，但是当我们需要更进一步的线程同步时，就需要使用Monitor类型了。</p>\n<ul><li>public static void Enter(object obj); \n   <ul><li>在指定对象上获取互斥锁</li></ul> </li><li>public static void Exit(object obj); \n   <ul><li>释放指定对象上的互斥锁</li></ul> </li><li>public static void Pulse(object obj); \n   <ul><li>通知等待队列中的线程锁定对象状态的更改</li></ul> </li><li>public static bool TryEnter(object obj); \n   <ul><li>试图获取指定对象的互斥锁，如果获得了互斥锁就返回true；否则返回false</li><li>TryEnter(Object, Int32)形式，表示在指定的毫秒数内尝试获取指定对象上的互斥锁</li></ul> </li><li>public static bool Wait(object obj); \n   <ul><li>释放对象上的锁并阻止当前线程，直到它重新获取该锁</li></ul> </li></ul>\n</blockquote>\n<ul><li>Wait：当线程调用 Wait 时，它释放对象的锁并进入<strong>等待队列</strong>。对象的<strong>就绪队列</strong>中的下一个线程（如果有）获取锁并拥有对对象的独占使用。所有调用 Wait 的线程都将留在等待队列中，直到它们接收到由锁的所有者发送的 Pulse 或 PulseAll 的信号为止。</li><li>Pulse：只有锁的当前所有者可以使用 Pulse 向等待对象发出信号。如果发送了 Pulse，则只影响位于等待队列最前面的线程。如果发送了 PulseAll，则将影响正等待该对象的所有线程。接收到信号后，一个或多个线程将离开<strong>等待队列而进入就绪队列</strong>。 在调用 Pulse 的线程释放锁后，<strong>就绪队列中的下一个线程（不一定是接收到脉冲的线程）将获得该锁</strong>。</li></ul>\n<p>使用注意事项：</p>\n<ul><li>在使用Enter和Exit方法的时候，建议像lock的IL代码一样，<code>使用try/finally语句块对Enter和Exit进行包装</code>。</li><li>Pulse 、PulseAll 和 Wait 方法必须从同步的代码块内调用。</li><li>在使用Pulse/Wait进行线程同步的时候，一定要牢记，Monitor 类不对指示 Pulse 方法已被调用的状态进行维护。 因此，<strong>如果在没有等待线程时调用 Pulse，则下一个调用 Wait 的线程将阻止，似乎 Pulse 从未被调用过。 如果两个线程正在使用 Pulse 和 Wait 交互，则可能导致死锁</strong>。</li></ul>\n<pre><code class=\"prism language-c#\">namespace MointorTest\n{\n    class Program\n    {\n        private static object monitorObj = new object();\n\n        static void Main(string[] args)\n        {\n            Thread firstThread = new Thread(new ThreadStart(TryEnterTest));\n            firstThread.Name = \"firstThread\";\n            Thread secondThread = new Thread(new ThreadStart(TryEnterTest));\n            secondThread.Name = \"secondThread\";\n            firstThread.Start();\n            secondThread.Start();\n            Console.Read();\n\n        }\n        public static void TryEnterTest()\n        {\n            if (!Monitor.TryEnter(monitorObj, 5000))\n            {\n                Console.WriteLine(\"Thread {0} wait 5 seconds, didn't get the lock\", Thread.CurrentThread.Name);\n                Console.WriteLine(\"Thread {0} completed!\", Thread.CurrentThread.Name);\n                return;\n            }\n            try\n            {\n           Monitor.Enter(monitorObj);\n                Console.WriteLine(\"Thread {0} get the lock and will run 10 seconds\", Thread.CurrentThread.Name);\n                Thread.Sleep(10000);\n                Console.WriteLine(\"Thread {0} completed!\", Thread.CurrentThread.Name);\n            }\n            finally\n            {\n                Monitor.Exit(monitorObj);\n            }\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"4__363\"></a>.4. 互斥队列</h5>\n<pre><code class=\"prism language-c#\">namespace BlockingQueue\n{\n    class BlockingQueue&lt;T&gt;\n    {\n        private object lockObj = new object();\n        public int QueueSize { get; set; }\n        private Queue&lt;T&gt; queue;\n        \n        public BlockingQueue()\n        {\n            this.queue = new Queue&lt;T&gt;(this.QueueSize);\n        }\n\n        public bool EnQueue(T item)\n        {\n            lock (lockObj)\n            {\n                while (this.queue.Count() &gt;= this.QueueSize)\n                {\n                    Monitor.Wait(lockObj);\n                }\n                this.queue.Enqueue(item);\n                Console.WriteLine(\"---&gt; 0000\" + item.ToString());\n                Monitor.PulseAll(lockObj);\n            }\n            return true;\n\n        }\n\n        public bool DeQueue(out T item)\n        {\n            lock (lockObj)\n            {\n                while (this.queue.Count() == 0)\n                {\n                    if (!Monitor.Wait(lockObj, 3000))\n                    {\n                        item = default(T);\n                        return false;\n                    };\n                }\n                item = this.queue.Dequeue();\n                Console.WriteLine(\"     0000\" + item + \" &lt;---\");\n                Monitor.PulseAll(lockObj);\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            BlockingQueue&lt;string&gt; bQueue = new BlockingQueue&lt;string&gt;();\n            bQueue.QueueSize = 3;\n\n            Random ran = new Random();\n\n            //producer\n            new Thread(\n            () =&gt; {\n                for (int i = 0; i &lt; 5; i++)\n                {\n                    Thread.Sleep(ran.Next(1000));\n                    bQueue.EnQueue(i.ToString());\n                    \n                }\n                Console.WriteLine(\"producer quit!\");\n            }).Start();\n\n            //producer\n            new Thread(\n            () =&gt;\n            {\n                for (int i = 5; i &lt; 10; i++)\n                {\n                    Thread.Sleep(ran.Next(1000));\n                    bQueue.EnQueue(i.ToString());\n\n                }\n                Console.WriteLine(\"producer quit!\");\n            }).Start();\n\n            //consumer\n            new Thread(\n            () =&gt;\n            {\n                while (true)\n                {\n                    Thread.Sleep(ran.Next(1000));\n                    string item = string.Empty;\n                    if (!bQueue.DeQueue(out item))\n                    {\n                        break;\n                    };\n                }\n                Console.WriteLine(\"consumer quit!\");\n            }).Start();\n\n            Console.Read();\n        }\n    }\n}\n</code></pre>\n<h3><a id=\"2__471\"></a>2. 线程同步</h3>\n<h4><a id=\"1__473\"></a>.1. 原子操作&amp;上下文切换</h4>\n<blockquote>\n<p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。</p>\n<ul><li>用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li><li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li><li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li></ul>\n</blockquote>\n<blockquote>\n<p>原子操作是指不会被 <a href=\"http://baike.baidu.com/view/1336364.htm\">线程调度</a> 机制打断的操作； 这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。通常所说的原子操作包括对非long和double型的primitive进行赋值，以及返回这两者之外的primitive。</p>\n</blockquote>\n<h4><a id=\"2__483\"></a>.2. 内核模式&amp;用户模式&amp;混合模式</h4>\n<blockquote>\n<p>内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运行在用户空间。它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高级别（内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。在这个级别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即自己的地址空间。</p>\n<ul><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ul>\n</blockquote>\n<h4><a id=\"3_httpszhuanlanzhihucomp34410587_491\"></a>.3. <a href=\"https://zhuanlan.zhihu.com/p/34410587\">同步信号量</a></h4>\n<blockquote>\n<p>信号量（semaphore）是一种用于提供不同进程之间或者一个给定的不同线程间同步手段的原语。信号量多用于进程间的同步与互斥，简单的说一下同步和互斥的意思：</p>\n<ul><li><strong>同步</strong>：处理竞争就是同步，安排进程执行的先后顺序就是同步，每个进程都有一定的个先后执行顺序。</li><li><strong>互斥</strong>：互斥访问不可共享的临界资源，同时会引发两个新的控制问题（互斥可以说是特殊的同步）。</li><li><strong>竞争</strong>：当并发进程竞争使用同一个资源的时候，我们就称为竞争进程。</li></ul>\n<p>共享资源通常分为两类：一类是<code>互斥共享资源</code>，即任一时刻只允许一个进程访问该资源；另一类是<code>同步共享资源</code>，即同一时刻允许多个进程访问该资源；<code>信号量是解决互斥共享资源的同步问题</code>而引入的机制。</p>\n</blockquote>\n<h3><a id=\"3__501\"></a>3. 线程池</h3>\n<h4><a id=\"1_APM_503\"></a>.1. APM</h4>\n<blockquote>\n<p>Add方法中模拟耗时操作（2s）和Main方法中模拟耗时操作（3s）是串行执行的，那么我们有没有一种方法使这两种操作并行执行了？（3s中之内搞定这两个耗时操作）。</p>\n</blockquote>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\1d4362002d463229961c3d828a972a52.png\"/></p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\602107d04315aaa2ef4550af2c47b3ae.png\"/></p>\n<h4><a id=\"2___511\"></a>.2. 线程取消</h4>\n<blockquote>\n<p>如果一个任务能够在正常完成之前被外部代码影响进入终结状态，那么这个任务就是可取消的。直觉上看，每个任务都应该能够被外界的命令所取消。</p>\n<ol><li>用户请求取消。用户通过交互界面显式地发起取消请求，例如取消正在下载的任务。</li><li>有时间限制的操作。特别是在大数据的背景下，某些关键路径的操作不可超过一定时延。超时的情况下宁可返回错误提示用户重试，也不可以继续等待导致吞吐下降甚至级联故障。</li><li>应用程序事件。例如，通过多线程执行 anyOf 逻辑时，有一个子任务取得结果，则可以乃至应该取消其他子任务。</li></ol>\n</blockquote>\n<h4><a id=\"3__519\"></a>.3. 等待&amp;延时</h4>\n<blockquote>\n<p>Sleep 的过程中，进程是不能响应外部操作的，变成了假死状态</p>\n</blockquote>\n<h5><a id=\"1_sleep_523\"></a>.1. sleep</h5>\n<pre><code class=\"prism language-c#\">using System.Threading;  //导入命名空间,类Thread就在此空间中Thread.Sleep(2000); //延时2s\n</code></pre>\n<h5><a id=\"2_DispatcherTimer_529\"></a>.2. DispatcherTimer</h5>\n<pre><code class=\"prism language-c#\">tbkLabel.Text = \"two seconds delay\";var timer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(2) };timer.Start();timer.Tick += (sender, args) =&gt;    {        timer.Stop();        var page = new Page2();        page.Show();    };\n</code></pre>\n<h5><a id=\"3_TaskDelay_535\"></a>.3. Task.Delay</h5>\n<pre><code class=\"prism language-c#\">tbkLabel.Text = \"two seconds delay\";Task.Delay(2000).ContinueWith(_ =&gt;    {      var page = new Page2();     page.Show();   });\n</code></pre>\n<h5><a id=\"4__541\"></a>.4. 异步/等待</h5>\n<pre><code class=\"prism language-c#\">// we need to add the async keyword to the method signaturepublic async void TheEnclosingMethod(){    tbkLabel.Text = \"two seconds delay\";    await Task.Delay(2000);    var page = new Page2();    page.Show();}\n</code></pre>\n<h4><a id=\"4_BackgroundWorker_547\"></a>.4. BackgroundWorker</h4>\n<blockquote>\n<p>BackgroundWorker是.net里用来执行多线程任务的控件，它允许编程者在一个单独的线程上执行一些操作。耗时的操作（如下载和数据库事务）在长时间运行时可能会导致用户界面 (UI) 始终处于停止响应状态。如果您需要能进行响应的用户界面，而且面临与这类操作相关的长时间延迟，则可以使用<strong>BackgroundWorker</strong>类方便地解决问题。</p>\n<p>该控件有三个事件：<code>DoWork</code> 、<code>ProgressChanged</code> 和 <code>RunWorkerCompleted</code>在程序中调用<code>RunWorkerAsync方法</code>则会<code>启动DoWork事件</code>的事件处理，当在事件处理过程中，<code>调用 ReportProgress方法</code>则会<code>启动ProgressChanged事件</code>的事件处理，而当<code>DoWork事件处理完成时</code>，则会触发<code>RunWorkerCompleted事件</code>。</p>\n<ul><li>确保在 DoWork 事件处理程序中<code>不操作任何用户界面对象</code>。而应该<code>通过 ProgressChanged和 RunWorkerCompleted 事件与用户界面进行通信</code>。</li></ul>\n</blockquote>\n<pre><code class=\"prism language-c#\">namespace BwTester{public partial class Form1 : Form{    public Form1()    {        InitializeComponent();    }        BackgroundWorker backgroundWorker;        private void button1_Click(object sender, EventArgs e)    {        backgroundWorker = new BackgroundWorker();        backgroundWorker.WorkerReportsProgress = true;        backgroundWorker.DoWork += new DoWorkEventHandler(backgroundWorker_DoWork);        backgroundWorker.ProgressChanged += new ProgressChangedEventHandler(backgroundWorker_ProgressChanged);        backgroundWorker.RunWorkerAsync();    }    void backgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)    {        progressBar1.Value = e.ProgressPercentage;    }    void backgroundWorker_DoWork(object sender, DoWorkEventArgs e)    {        for (int i = 0; i &lt; 500; i++)        {            backgroundWorker.ReportProgress(i);            Thread.Sleep(100);        }    }}\n</code></pre>\n<h3><a id=\"4__561\"></a>4. 并行任务库</h3>\n<h4><a id=\"1__563\"></a>.1. 任务创建及组合</h4>\n<blockquote>\n<p>线程是创建并发的底层工具，因此具有一定的局限性。</p>\n<ul><li>没有简单的方法可以从联合（Join）线程得到“返回值”。因此必须创建一些共享域。当抛出一个异常时，捕捉和处理异常也是麻烦的。</li><li>线程完成之后，无法再次启动该线程。相反，只能联合（Join）它（在进程阻塞当前线程）。</li></ul>\n</blockquote>\n<blockquote>\n<p>Task 类的表示单个操作不返回一个值，通常以异步方式执行。Task 对象是一个的中心思想 基于任务的异步模式 首次引入.NET Framework 4 中。 因为由执行工作 Task 对象通常以异步方式执行在线程池线程上而不是以同步方式在主应用程序线程，您可以使用 Status 属性，以及 IsCanceled, ，IsCompleted, ，和 IsFaulted 属性，以确定任务的状态。 大多数情况下，lambda 表达式用于指定的任务是执行的工作。</p>\n<ul><li>task.Resut获取结果时会阻塞线程，即如果task没有执行完成，会等待task执行完成获取到Result，然后再执行后边的代码，</li></ul>\n</blockquote>\n<h5><a id=\"1_Task__574\"></a>.1. Task 创建</h5>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    //1.new方式实例化一个Task，需要通过Start方法启动    Task task = new Task(() =&gt;                         {                             Thread.Sleep(100);                             Console.WriteLine($\"hello, task1的线程ID为{Thread.CurrentThread.ManagedThreadId}\");                         });    task.Start();    //2.Task.Factory.StartNew(Action action)创建和启动一个Task    Task task2 = Task.Factory.StartNew(() =&gt;                                       {                                           Thread.Sleep(100);                                           Console.WriteLine($\"hello, task2的线程ID为{ Thread.CurrentThread.ManagedThreadId}\");                                       });    //3.Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task， 后台线程    Task task3 = Task.Run(() =&gt;                          {                              Thread.Sleep(100);                              Console.WriteLine($\"hello, task3的线程ID为{ Thread.CurrentThread.ManagedThreadId}\");                          });    Console.WriteLine(\"执行主线程！\");    Console.ReadKey();}//先打印\"执行主线程\"，然后再打印各个任务，说明了Task不会阻塞主线程。上边的栗子Task都没有返回值，我们也可以创建有返回值的~task，用法和没有返回值的基本一致,\n</code></pre>\n<h5><a id=\"2_Task__580\"></a>.2. Task 同步</h5>\n<pre><code class=\"prism language-c#\"> static void Main(string[] args) {     Task task = new Task(() =&gt;                          {                              Thread.Sleep(100);                              Console.WriteLine(\"执行Task结束!\");                          });     //同步执行，task会阻塞主线程     task.RunSynchronously();     Console.WriteLine(\"执行主线程结束！\");     Console.ReadKey(); }\n</code></pre>\n<h5><a id=\"3_Task__586\"></a>.3. Task 阻塞</h5>\n<ul><li><strong>Wait/WaitAny/WaitAll</strong></li></ul>\n<pre><code class=\"prism language-c#\">  static void Main(string[] args)  {      Task task1 = new Task(() =&gt; {          Thread.Sleep(500);          Console.WriteLine(\"线程1执行完毕！\");      });      task1.Start();      Task task2 = new Task(() =&gt; {          Thread.Sleep(1000);          Console.WriteLine(\"线程2执行完毕！\");      });      task2.Start();      //阻塞主线程。task1,task2都执行完毕再执行主线程      //执行【task1.Wait();task2.Wait();】可以实现相同功能      //调用Wait方法，可以阻塞任务，直至任务完成，效果等同于Thread.Join：      Task.WaitAll(new Task[]{ task1,task2});      Console.WriteLine(\"主线程执行完毕！\");      Console.ReadKey();  }\n</code></pre>\n<ul><li><strong>延续操作</strong></li></ul>\n<blockquote>\n<p>让所有task执行完毕(或者任一task执行完毕)后，<code>开始执行后续操作</code>。WhenAny/WhenAll方法了，这些方法执行完成返回一个task实例。 task.WhenAll(Task[] tasks) 表示所有的task都执行完毕后再去执行后续的操作， task.WhenAny(Task[] tasks) 表示任一task执行完毕后就开始执行后续操作。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    Task task1 = new Task(() =&gt; {        Thread.Sleep(500);        Console.WriteLine(\"线程1执行完毕！\");    });    task1.Start();    Task task2 = new Task(() =&gt; {        Thread.Sleep(1000);        Console.WriteLine(\"线程2执行完毕！\");    });    task2.Start();    //通过TaskFactroy实现    Task.Factory.ContinueWhenAll(new Task[] { task1, task2 }, (t) =&gt;                                 {                                     Thread.Sleep(100);                                     Console.WriteLine(\"执行后续操作\");                                 });    Console.WriteLine(\"主线程执行完毕！\");    Console.ReadKey();}\n</code></pre>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    Task task1 = new Task(() =&gt; {        Thread.Sleep(500);        Console.WriteLine(\"线程1执行完毕！\");    });    task1.Start();    Task task2 = new Task(() =&gt; {        Thread.Sleep(1000);        Console.WriteLine(\"线程2执行完毕！\");    });    task2.Start();    //task1，task2执行完了后执行后续操作    Task.WhenAll(task1, task2).ContinueWith((t) =&gt; {        Thread.Sleep(100);        Console.WriteLine(\"执行后续操作完毕！\");    });    Console.WriteLine(\"主线程执行完毕！\");    Console.ReadKey();}\n</code></pre>\n<h5><a id=\"4_Task__606\"></a>.4. Task 取消</h5>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    bool isStop = false;    int index = 0;    //开启一个线程执行任务    Thread th1 = new Thread(() =&gt;                            {                                while (!isStop)                                {                                    Thread.Sleep(1000);                                    Console.WriteLine($\"第{++index}次执行，线程运行中...\");                                }                            });    th1.Start();    //五秒后取消任务执行    Thread.Sleep(5000);    isStop = true;    Console.ReadKey();}\n</code></pre>\n<ul><li>使用CancellationTokenSource</li></ul>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    CancellationTokenSource source = new CancellationTokenSource();    int index = 0;    //开启一个task执行任务    Task task1 = new Task(() =&gt;                          {                              while (!source.IsCancellationRequested)                              {                                  Thread.Sleep(1000);                                  Console.WriteLine($\"第{++index}次执行，线程运行中...\");                              }                          });    task1.Start();    //五秒后取消任务执行    Thread.Sleep(5000);    //source.Cancel()方法请求取消任务，IsCancellationRequested会变成true    source.Cancel();    Console.ReadKey();}\n</code></pre>\n<pre><code class=\"prism language-c#\"> static void Main(string[] args) {     CancellationTokenSource source = new CancellationTokenSource();     //注册任务取消的事件     source.Token.Register(() =&gt;                           {                               Console.WriteLine(\"任务被取消后执行xx操作！\");                           });     int index = 0;     //开启一个task执行任务     Task task1 = new Task(() =&gt;                           {                               while (!source.IsCancellationRequested)                               {                                   Thread.Sleep(1000);                                   Console.WriteLine($\"第{++index}次执行，线程运行中...\");                               }                           });     task1.Start();     //延时取消，效果等同于Thread.Sleep(5000);source.Cancel();     source.CancelAfter(5000);     Console.ReadKey(); }\n</code></pre>\n<ul><li>跨线程</li></ul>\n<pre><code class=\"prism language-c#\">public partial class Form1 : Form{    public Form1()    {        InitializeComponent();    }    private void mySetValueBtn_Click(object sender, EventArgs e)    {        Task.Run(() =&gt;                 {                     Action&lt;int&gt; setValue = (i) =&gt; { myTxtbox.Text = i.ToString(); };                     for (int i = 0; i &lt; 1000000; i++)                     {                         myTxtbox.Invoke(setValue,i);                     }                 });    }}\n</code></pre>\n<h5><a id=\"5__628\"></a>.5. 返回值</h5>\n<p><code>Task&lt;TResult&gt;</code>允许任务返回一个值。调用<code>Task.Run</code>，传入一个<code>Func&lt;TResult&gt;</code>代理（或者兼容的Lambda表达式），代替Action，就可以获得一个Task：</p>\n<pre><code class=\"prism language-c#\">Task&lt;int&gt; task = Task.Run (() =&gt; { Console.WriteLine (\"Foo\"); return 3; });int result = task.Result;      // Blocks if not already finishedConsole.WriteLine (result);    // 3\n</code></pre>\n<p>下面的例子创建一个任务，它使用LINQ就按前3百万个整数（从2开始）中的素数个数：</p>\n<pre><code class=\"prism language-c#\">Task&lt;int&gt; primeNumberTask = Task.Run(() =&gt;                                     Enumerable.Range(2, 3000000).Count(n =&gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =&gt; n % i &gt; 0)));Console.WriteLine(\"Task running...\");Console.WriteLine(\"The answer is \" + primeNumberTask.Result);\n</code></pre>\n<h5><a id=\"6__642\"></a>.6. 延迟</h5>\n<p><code>Task.Delay</code>是<code>Thread.Sleep</code>的异步版本</p>\n<pre><code class=\"prism language-c#\">Task.Delay(5000).GetAwaiter().OnCompleted(()=&gt;Console.WriteLine(42));\n</code></pre>\n<p>或者</p>\n<pre><code class=\"prism language-c#\">Task.Delay(5000).ContinueWith(ant =&gt; Console.WriteLine(42));\n</code></pre>\n<h4><a id=\"2__656\"></a>2. 线程相关</h4>\n<h5><a id=\"1__658\"></a>1. 创建线程</h5>\n<pre><code class=\"prism language-C#\">static void Main(string[] args){    Thread t = new Thread(PrintNumbers);    t.Start();//线程开始执行    PrintNumbers();    Console.ReadKey();}static void PrintNumbers(){    Console.WriteLine(\"Starting...\");    for (int i = 1; i &lt; 10; i++)    {        Console.WriteLine(i);    }}\n</code></pre>\n<h5><a id=\"2__664\"></a>2. 暂停线程</h5>\n<pre><code class=\"prism language-c#\">class Program{    static void Main(string[] args)    {        Thread t = new Thread(PrintNumbersWithDelay);        t.Start();        PrintNumbers();        Console.ReadKey();    }    static void PrintNumbers()    {        Console.WriteLine(\"Starting...\");        for (int i = 1; i &lt; 10; i++)        {            Console.WriteLine(i);        }    }    static void PrintNumbersWithDelay()    {        Console.WriteLine(\"Starting...\");        for (int i = 1; i &lt; 10; i++)        {            Thread.Sleep(TimeSpan.FromSeconds(2));//暂停2S            Console.WriteLine(i);        }    }}\n</code></pre>\n<h5><a id=\"3__670\"></a>3. 线程等待</h5>\n<pre><code class=\"prism language-c#\">class Program{    static void Main(string[] args)    {        Console.WriteLine(\"Starting program...\");        Thread t = new Thread(PrintNumbersWithDelay);        t.Start();        t.Join();        Console.WriteLine(\"Thread completed\");    }    static void PrintNumbersWithDelay()    {        Console.WriteLine(\"Starting...\");        for (int i = 1; i &lt; 10; i++)        {            Thread.Sleep(TimeSpan.FromSeconds(2));            Console.WriteLine(i);        }    }}\n</code></pre>\n<h5><a id=\"4__676\"></a>4. 终止线程</h5>\n<blockquote>\n<p>并不推荐使用,Abort方法来关闭线程。可优先使用一些其他方法,比如提供一个CancellationToken方法来,取消线程的执行。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">class Program{    static void Main(string[] args)    {        Console.WriteLine(\"Starting program...\");        Thread t = new Thread(PrintNumbersWithDelay);        t.Start();        Thread.Sleep(TimeSpan.FromSeconds(6));        t.Abort();        Console.WriteLine(\"A thread has been aborted\");    }    static void PrintNumbersWithDelay()    {        Console.WriteLine(\"Starting...\");        for (int i = 1; i &lt; 10; i++)        {            Thread.Sleep(TimeSpan.FromSeconds(2));            Console.WriteLine(i);        }    }}\n</code></pre>\n<h5><a id=\"5_684\"></a>5.监控线程状态</h5>\n<pre><code class=\"prism language-c#\">class Program{    static void Main(string[] args)    {        Console.WriteLine(\"Starting program...\");        Thread t = new Thread(PrintNumbersWithStatus);        Thread t2 = new Thread(DoNothing);        Console.WriteLine(t.ThreadState.ToString());        t2.Start();        t.Start();        for (int i = 1; i &lt; 30; i++)        {            Console.WriteLine(t.ThreadState.ToString());        }        Thread.Sleep(TimeSpan.FromSeconds(6));        t.Abort();        Console.WriteLine(\"A thread has been aborted\");        Console.WriteLine(t.ThreadState.ToString());        Console.WriteLine(t2.ThreadState.ToString());        Console.ReadKey();    }    static void DoNothing()    {        Thread.Sleep(TimeSpan.FromSeconds(2));    }    static void PrintNumbersWithStatus()    {        Console.WriteLine(\"Starting...\");        Console.WriteLine(Thread.CurrentThread.ThreadState.ToString());        for (int i = 1; i &lt; 10; i++)        {            Thread.Sleep(TimeSpan.FromSeconds(2));            Console.WriteLine(i);        }    }}\n</code></pre>\n<h5><a id=\"7__690\"></a>7. 线程传参</h5>\n<pre><code class=\"prism language-c#\">class Program{    static void Main(string[] args)    {        var sample = new ThreadSample(10);        var threadOne = new Thread(sample.CountNumbers);        threadOne.Name = \"ThreadOne\";        threadOne.Start();        threadOne.Join();        Console.WriteLine(\"--------------------------\");        var threadTwo = new Thread(Count);        threadTwo.Name = \"ThreadTwo\";        threadTwo.Start(8);        threadTwo.Join();        Console.WriteLine(\"--------------------------\");        var threadThree = new Thread(() =&gt; CountNumbers(12));        threadThree.Name = \"ThreadThree\";        threadThree.Start();        threadThree.Join();        Console.WriteLine(\"--------------------------\");        int i = 10;        var threadFour = new Thread(() =&gt; PrintNumber(i));        i = 20;        var threadFive = new Thread(() =&gt; PrintNumber(i));        threadFour.Start();         threadFive.Start();    }    static void Count(object iterations)    {        CountNumbers((int)iterations);    }    static void CountNumbers(int iterations)    {        for (int i = 1; i &lt;= iterations; i++)        {            Thread.Sleep(TimeSpan.FromSeconds(0.5));            Console.WriteLine(\"{0} prints {1}\", Thread.CurrentThread.Name, i);        }    }    static void PrintNumber(int number)    {        Console.WriteLine(number);    }    class ThreadSample    {        private readonly int _iterations;        public ThreadSample(int iterations)        {            _iterations = iterations;        }        public void CountNumbers()        {            for (int i = 1; i &lt;= _iterations; i++)            {                Thread.Sleep(TimeSpan.FromSeconds(0.5));                Console.WriteLine(\"{0} prints {1}\", Thread.CurrentThread.Name, i);            }        }    }}\n</code></pre>\n<h4><a id=\"2_APMTask_696\"></a>.2. APM-&gt;Task</h4>\n<blockquote>\n<p>APM(Asynchronous Programming Model)是.Net 旧版本中广泛使用的异步编程模型。使用了 APM的异步方法会返回一个 <code>IAsyncResult 对象</code>，这个对象有一个重要的属性 <code>AsyncWaitHandle</code>，他是一个用来等待异步任务执行结束的一个同步信号。 <code>方法名字以 BeginXXX 开头，返回类型为 IAsyncResult，调用结束后需要EndXXX。</code></p>\n</blockquote>\n<pre><code class=\"prism language-c#\">FileStream fs = File.OpenRead(\"d:/1.txt\");byte[] buffer = new byte[16];IAsyncResult aResult = fs.BeginRead(buffer, 0, buffer.Length, null, null);aResult.AsyncWaitHandle.WaitOne();//等待任务执行结束MessageBox.Show(Encoding.UTF8.GetString(buffer));fs.EndRead(aResult);\n</code></pre>\n<pre><code class=\"prism language-c#\">/// &lt;summary&gt;/// 异步计算接口/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public interface ICalculator&lt;T&gt;{    IAsyncResult BeginAdd(T x, T y, AsyncCallback asyncCallback, Object obj);    T EndAdd(IAsyncResult ar);}/// &lt;summary&gt;/// 异步计算接口实现类/// &lt;/summary&gt;public class Calculator : ICalculator&lt;double&gt;{    public IAsyncResult BeginAdd(double x, double y, AsyncCallback asyncCallback, Object obj)    {        return CalculatorAsyncResult&lt;double&gt;.CreateCalculatorAsyncResult(delegate { return Add(x, y); }, asyncCallback, obj);    }    public double EndAdd(IAsyncResult ar)    {        var calculatorAsyncResult = (CalculatorAsyncResult&lt;double&gt;)(ar);        Console.WriteLine(\"EndAdd Wait() start\");        calculatorAsyncResult.Wait();        Console.WriteLine(\"EndAdd Wait() Invoke\");        return calculatorAsyncResult.CalulatorResult;    }    /// &lt;summary&gt;    /// 计算方法    /// &lt;/summary&gt;    /// &lt;param name=\"x\"&gt;&lt;/param&gt;    /// &lt;param name=\"y\"&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    protected double Add(double x, double y)    {        Console.WriteLine(\"Async thread(id={0}) begins.\\n\", Thread.CurrentThread.ManagedThreadId);        Thread.Sleep(3000);        var r = x + y;        Console.WriteLine(\"Async thread(id={0}) ends.\\n\", Thread.CurrentThread.ManagedThreadId);        return r;    }}\n</code></pre>\n<pre><code class=\"prism language-c#\">1 /// &lt;summary&gt; 2         /// 异步 3         /// &lt;/summary&gt; 4         /// &lt;param name=\"sender\"&gt;&lt;/param&gt; 5         /// &lt;param name=\"e\"&gt;&lt;/param&gt; 6         private void button2_Click(object sender, EventArgs e) 7         {11             var url = this.textBox1.Text.Trim();12             var request = HttpWebRequest.Create(url);13             request.BeginGetResponse(AsyncCallbackImpl, request);//BeginGetResponse,发起异步请求14         }15 16         /// &lt;summary&gt;17         /// 回调18         /// &lt;/summary&gt;19         /// &lt;param name=\"ar\"&gt;&lt;/param&gt;20         public void AsyncCallbackImpl(IAsyncResult ar)21         {22             HttpWebRequest request = ar.AsyncState as HttpWebRequest;23             var response = request.EndGetResponse(ar);//EndGetResponse,异步请求完成24             var stream = response.GetResponseStream();25             StringBuilder sb = new StringBuilder();26             sb.AppendLine(\"当前线程Id:\" + Thread.CurrentThread.ManagedThreadId);27             using (StreamReader reader = new StreamReader(stream))28             {29                 var content = reader.ReadLine();30                 sb.AppendLine(content);31                 this.richTextBox1.Text = sb.ToString();32             }33         }34\n</code></pre>\n<h4><a id=\"3_EAP_Task_712\"></a>.3. EAP -&gt;Task</h4>\n<blockquote>\n<p>基于<code>事件的异步模式</code>是.net 2.0提出的，实现了基于事件的异步模式的类<code>将具有一个或者多个以Async为后缀的方法</code>和<code>对应的Completed事件</code>，并且这些类都支持<code>异步方法的取消、进度报告和报告结果</code>。</p>\n<p>EAP模式类似于 Ajax 中的XmlHttpRequest，<code>send 之后并不是处理完成了</code>，而是在 <code>onreadystatechange 事件中再通知处理完成</code>。</p>\n<p>优点是简单，缺点是当实现复杂的业务的时候很麻烦，比如下载 A 成功后再下载 b，如果下载 b成功再下载 c，否则就下载 d。</p>\n<p>当调用基于事件的EAP模式的类的XXXAsync方法时，就开始了一个异步操作，并且基于事件的EAP模式是基于APM模式之上的，而APM又是建立在委托之上的。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">BackgroundWorker worker = new BackgroundWorker();worker.DoWork += Worker_DoWork;worker.RunWorkerCompleted += Worker_RunWorkerCompleted;worker.RunWorkerAsync(null);private static void Worker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e){    Console.WriteLine(\"dowork completed\");}private static void Worker_DoWork(object sender, DoWorkEventArgs e){    Console.WriteLine(\"dowork\");}\n</code></pre>\n<pre><code class=\"prism language-c#\">WebClient wc = new WebClient();wc.DownloadStringCompleted += Wc_DownloadStringCompleted;wc.DownloadStringAsync(new Uri(\"http://www.baidu.com\"));private void Wc_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e){　　MessageBox.Show(e.Result);}\n</code></pre>\n<h4><a id=\"4_TAPTask_730\"></a>.4. TAP-&gt;Task</h4>\n<blockquote>\n<p>.net 4.0为我们带来了Task的异步，我们有以下三种方法创建Task。</p>\n<p>1，Task.Factory.StartNew()，比较常用。</p>\n<p>2，Task t1 = new Task(() =&gt; { Console.WriteLine(“t1 start”); }); t1.Start();</p>\n<p>3，Task.Run()，是.net 4.5中增加的。</p>\n<p>4，Task.FromResult()，如果结果是已计算，就可以使用这种方法来创建任务。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    Console.WriteLine(\"start\");     Task task1= Task.Run(() =&gt;    {        Thread.Sleep(2000);         Console.WriteLine(\"task1\");    });    Task task2=Task.Run(() =&gt;    {        Thread.Sleep(3000);         Console.WriteLine(\"task2\");    });    Task.WaitAll(task1,task2);    Console.WriteLine($\"task1 task2已经执行完成\");    Task task3=Task.Run(() =&gt;    {        Thread.Sleep(5000);         Console.WriteLine(\"task3\");    });    Console.WriteLine(\"end\");     Console.ReadLine();}\n</code></pre>\n<h4><a id=\"5_TaskScheduler_748\"></a>.5. TaskScheduler</h4>\n<h5><a id=\"1_ThreadPoolTaskScheduler_750\"></a>.1. ThreadPoolTaskScheduler</h5>\n<pre><code class=\"prism language-c#\">protected internal override void QueueTask(Task task){    if ((task.Options &amp; TaskCreationOptions.LongRunning) != TaskCreationOptions.None)    {        new Thread(ThreadPoolTaskScheduler.s_longRunningThreadWork)        {            IsBackground = true        }.Start(task);        return;    }    bool forceGlobal = (task.Options &amp; TaskCreationOptions.PreferFairness) &gt; TaskCreationOptions.None;    ThreadPool.UnsafeQueueCustomWorkItem(task, forceGlobal);}\n</code></pre>\n<h5><a id=\"2_SynchronizationContextTaskScheduler_756\"></a>.2. SynchronizationContextTaskScheduler</h5>\n<blockquote>\n<p>这是一个同步上下文的taskscheduler，原理就是把繁重的耗时工作丢给ThreadPool，然后将更新UI的操作丢给 UI线程的队列中</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">private void button1_Click(object sender, EventArgs e){    Task task = Task.Factory.StartNew(() =&gt;                                      {                                          //复杂操作，等待10s                                          Thread.Sleep(10000);                                      }).ContinueWith((t) =&gt;                                                      {                                                          button1.Text = \"hello world\";                                                      }, TaskScheduler.FromCurrentSynchronizationContext());}\n</code></pre>\n<h3><a id=\"5_asyncawait_766\"></a>5. async/await</h3>\n<h4><a id=\"1_asyncawait_768\"></a>.1. async/await使用</h4>\n<blockquote>\n<p>await 后面跟上一个异步操作Task，当程序执行到此行代码时，由于有await的修饰，会等待异步操作Task执行，<code>Task执行完成后才会执行此方法里await这一行后面的代码</code>.</p>\n<ul><li>async用来声明一个异步方法，await是一个上下文关键字（跟代码上下文相关），必须和async配套使用才会生效，await用来声明异步方法中一个可能会产生阻塞的操作（方法）。</li><li>当将方法用async标识时且返回值为void或者Task或者Task，此时该方法会在当前线程中一直同步执行。用async标识方法并不会影响方法运行完成是否是同步或者异步，相反，它能够将方法划分成多块，有可能有些在异步中运行，以至于这些方法是异步完成的，而划分异步和同步方法的边界就是使用await关键字。也就是说如果在方法中未用到await关键字时则该方法就是一整块没有所谓的划分，会在同步中运行，在同步中完成。</li><li>C#编译器一旦遇到以async声明的方法（即异步方法）时会在这个方法中尝试寻找await关键字，如果找到以await关键字声明的方法，就会自动生成一些代码，这些代码负责<strong>启动后台线程，尝试找到空闲的CPU内核运行以await声明的方法（即以异步方式运行）</strong>，完成这一切后调用者线程从异步方法返回。后台线程在运行完以await声明的方法后会结束，此时await关键字生成的代码还负责提取方法的返回结果，所以干活的都是await，async实际上只是提醒编译器\"你看到有async关键字的方法时进去方法内部是不是有个await关键字，有的话就干活\"。</li><li>C#中可以用<code>async</code>标识方法，表示这个方法是异步的。异步方法的返回值必须是<code>void</code>、<code>Task</code>或者<code>Task&lt;T&gt;</code>。</li></ul>\n</blockquote>\n<ul><li>Method 1和Method 2不相互依赖, 并且俩个方法一起执行</li></ul>\n<pre><code class=\"prism language-c#\">class Program{      static void Main(string[] args)    {          Method1();        Method2();        Console.ReadKey();    }      public static async Task Method1()    {          await Task.Run(() =&gt;                       {                             for (int i = 0; i &lt; 100; i++)                           {                                 Console.WriteLine(\" Method 1\");                             }                         });      }      public static void Method2()    {          for (int i = 0; i &lt; 25; i++)        {              Console.WriteLine(\" Method 2\");          }      }  }  \n</code></pre>\n<ul><li>Method 1将总长度作为整数值返回，我们在Method 3中以长度的形式传递一个参数，它来自Method 1，在控制台应用程序的Main方法中，因为不能使用async关键字而不能使用await 关键字</li></ul>\n<pre><code class=\"prism language-c#\">class Program{      static void Main(string[] args)    {          callMethod();        Console.ReadKey();    }      public static async void callMethod()    {          Task&lt;int&gt; task = Method1();        Method2();        int count = await task;        Method3(count);    }      public static async Task&lt;int&gt; Method1()    {          int count = 0;        await Task.Run(() =&gt;                       {                             for (int i = 0; i &lt; 100; i++)                           {                                 Console.WriteLine(\" Method 1\");                                 count += 1;                           }                         });          return count;    }      public static void Method2()    {          for (int i = 0; i &lt; 25; i++)        {              Console.WriteLine(\" Method 2\");          }      }      public static void Method3(int count)    {          Console.WriteLine(\"Total count is \" + count);    }  }  \n</code></pre>\n<ul><li>demo</li></ul>\n<pre><code class=\"prism language-c#\">class Program{      static void Main()    {          Task task = new Task(CallMethod);        task.Start();        task.Wait();        Console.ReadLine();    }      static async void CallMethod()    {          string filePath = \"E:\\\\sampleFile.txt\";          Task&lt;int&gt; task = ReadFile(filePath);        Console.WriteLine(\" Other Work 1\");          Console.WriteLine(\" Other Work 2\");          Console.WriteLine(\" Other Work 3\");          int length = await task;        Console.WriteLine(\" Total length: \" + length);        Console.WriteLine(\" After work 1\");          Console.WriteLine(\" After work 2\");      }      static async Task&lt;int&gt; ReadFile(string file)    {          int length = 0;        Console.WriteLine(\" File reading is stating\");          using (StreamReader reader = new StreamReader(file))        {              // Reads all characters from the current position to the end of the stream asynchronously               // and returns them as one string.               string s = await reader.ReadToEndAsync();            length = s.Length;        }          Console.WriteLine(\" File reading is completed\");          return length;    }  }  \n</code></pre>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\0fb9ebd0f59d71f32d746f078f42d427.png\"/></p>\n<h4><a id=\"2_lambda__797\"></a>.2. lambda 表达式</h4>\n<h4><a id=\"httpsimgblogcsdnimgcnimg_convertaf4af4407d3b0ae5a81e0c3d2dc22e48png_799\"></a><img alt=\"\" src=\"..\\..\\static\\image\\af4af4407d3b0ae5a81e0c3d2dc22e48.png\"/></h4>\n<h3><a id=\"6__801\"></a>6. 并发集合</h3>\n<blockquote>\n<p>线程安全：多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的.</p>\n<p>线程不安全：不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据<br/> 举例：购票系统有1000张票。A线程和B线程同时抢票，有时候会抢到同一张票。这是就是线程不安全。两个线程可能同时抢一个数据。这时候就要用到锁了.</p>\n</blockquote>\n<h4><a id=\"1_ConcurrentQueuehttpsdocsmicrosoftcomzhcndotnetapisystemcollectionsconcurrentconcurrentqueue1viewnet50_808\"></a>.1. <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1?view=net-5.0\">ConcurrentQueue</a></h4>\n<blockquote>\n<p>ConcurrentQueue队列是一个高效的线程安全的队列，是.Net Framework 4.0,System.Collections.Concurrent 命名空间下的一个数据结构.</p>\n</blockquote>\n<h4><a id=\"2_ConcurrentDictionary_812\"></a>.2. ConcurrentDictionary</h4>\n<h4><a id=\"3_ConcurrentStack_814\"></a>.3. ConcurrentStack</h4>\n<h4><a id=\"4_ConcurrentBaghttpswwwcnblogscomtaisenkip7699667html_816\"></a>.4. <a href=\"https://www.cnblogs.com/taisenki/p/7699667.html\">ConcurrentBag</a></h4>\n<blockquote>\n<p>ConcurrentBag是一个专门的并发包裹，在连接池（多线程数据交互）的实现上具有比LinkedBlockingQueue和LinkedTransferQueue更优越的性能。<br/> ConcurrentBag通过拆分 <code>CopyOnWriteArrayList、ThreadLocal和SynchronousQueue</code><br/> 进行并发数据交互。</p>\n<ul><li>CopyOnWriteArrayList：负责存放ConcurrentBag中全部用于出借的资源</li><li>ThreadLocal：用于加速线程本地化资源访问</li><li>SynchronousQueue：用于存在资源等待线程时的第一手资源交接</li><li>ConcurrentBag中全部的资源均只能通过add方法进行添加，只能通过remove方法进行移出。</li></ul>\n</blockquote>\n<h4><a id=\"5_BlockingCollection_827\"></a>.5. BlockingCollection</h4>\n<h3><a id=\"7_PLINQ_829\"></a>7. PLINQ</h3>\n<blockquote>\n<p>任务并行库 (TPL) 是 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading\">System.Threading</a> 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks\">System.Threading.Tasks</a> 空间中的一组公共类型和 API。 TPL 的目的是通过简化将并行和并发添加到应用程序的过程来提高开发人员的工作效率。 Parallel类提供<strong>数据和任务</strong>的并行性；</p>\n</blockquote>\n<h4><a id=\"1__833\"></a>.1. 数据并行</h4>\n<blockquote>\n<p><em>数据并行</em> 指的是对源集合或数组的元素同时（即，并行）执行相同操作的场景。 在数据并行操作中，对源集合进行分区，以便多个线程能够同时在不同的网段上操作。</p>\n</blockquote>\n<h5><a id=\"1__Foreach_837\"></a>.1. Foreach</h5>\n<pre><code class=\"prism language-c#\">// Sequential versionforeach (var item in sourceCollection){    Process(item);}// Parallel equivalentParallel.ForEach(sourceCollection, item =&gt; Process(item));//自定义数组， 可以解决ForEach中参数传递问题List&lt;Kinectenv&gt; kinectenvs = convertFromeEnv(e);_ = Parallel.ForEach(kinectenvs, (pair) =&gt;                     {                         HandleSingSkeleton(pair.kinectId,pair.skeleton,pair.image, rtime);                     });\n</code></pre>\n<h5><a id=\"2_For_843\"></a>.2. For</h5>\n<pre><code class=\"prism language-c#\">namespace ConsoleApp1{    class Program    {        static void Main(string[] args)        {            int[] nums = new int[] { , , , , , , , , , , ,  };            Parallel.For(, nums.Length, (i) =&gt;            {                Console.WriteLine(\"针对数组索引{0}对应的那个元素{1}的一些工作代码……ThreadId={2}\", i, nums[i], Thread.CurrentThread.ManagedThreadId);            });            Console.ReadKey();        }    }}\n</code></pre>\n<h5><a id=\"3__849\"></a>.3. 退出</h5>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    ConcurrentBag&lt;int&gt; bag = new ConcurrentBag&lt;int&gt;();    Parallel.For(, , (i, state) =&gt;                 {                     if (bag.Count == )                     {                         //state.Break();                         state.Stop();                         return;                     }                     bag.Add(i);                 });    Console.WriteLine(\"当前集合有{0}个元素。\", bag.Count);}\n</code></pre>\n<h5><a id=\"4__855\"></a>.4. 异常处理</h5>\n<pre><code class=\"prism language-c#\">private static void ProcessDataInParallel(byte[] data){    // Use ConcurrentQueue to enable safe enqueueing from multiple threads.    var exceptions = new ConcurrentQueue&lt;Exception&gt;();    // Execute the complete loop and capture all exceptions.    Parallel.ForEach(data, d =&gt;                     {                         try                         {                             // Cause a few exceptions, but not too many.                             if (d &lt; 3)                                 throw new ArgumentException($\"Value is {d}. Value must be greater than or equal to 3.\");                             else                                 Console.Write(d + \" \");                         }                         // Store the exception and continue with the loop.                         catch (Exception e)                         {                             exceptions.Enqueue(e);                         }                     });    Console.WriteLine();    // Throw the exceptions here after the loop completes.    if (exceptions.Count &gt; 0) throw new AggregateException(exceptions);}\n</code></pre>\n<h4><a id=\"2__861\"></a>.2. 任务并行</h4>\n<blockquote>\n<p>任务并行库 (TPL) 以“任务”的概念为基础，后者表示异步操作。 在某些方面，任务类似于线程或 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool\">ThreadPool</a> 工作项，但是抽象级别更高。 术语“任务并行”是指一个或多个独立的任务同时运行。</p>\n</blockquote>\n<h5><a id=\"1_Invoke__865\"></a>.1. Invoke 隐式创建</h5>\n<blockquote>\n<p>这个函数的功能和Task有些相似，就是<code>并发执行一系列任务，然后等待所有完成</code>。和Task比起来，省略了Task.WaitAll这一步，自然也缺少了Task的相关管理功能。它有两种形式:</p>\n<ul><li>Parallel.Invoke( params Action[] actions);</li><li>Parallel.Invoke(Action[] actions,TaskManager manager,TaskCreationOptions options);</li></ul>\n</blockquote>\n<pre><code class=\"prism language-c#\">namespace ConsoleApp1{    class Program    {        static void Main(string[] args)        {            var actions = new Action[]            {                () =&gt; ActionTest(\"test 1\"),                () =&gt; ActionTest(\"test 2\"),                () =&gt; ActionTest(\"test 3\"),                () =&gt; ActionTest(\"test 4\")            };             Console.WriteLine(\"Parallel.Invoke 1 Test\");            Parallel.Invoke(actions);             Console.WriteLine(\"结束！\");        }         static void ActionTest(object value)        {            Console.WriteLine(\"&gt;&gt;&gt; thread:{0}, value:{1}\",            Thread.CurrentThread.ManagedThreadId, value);        }    }}\n</code></pre>\n<h5><a id=\"2_Task__876\"></a>.2. Task 显示创建</h5>\n<pre><code class=\"prism language-c#\">using System;using System.Threading;using System.Threading.Tasks;class CustomData{   public long CreationTime;   public int Name;   public int ThreadNum;}public class Example{   public static void Main()   {      Task[] taskArray = new Task[10];      for (int i = 0; i &lt; taskArray.Length; i++) {         taskArray[i] = Task.Factory.StartNew( (Object obj ) =&gt; {                                                  CustomData data = obj as CustomData;                                                  if (data == null)                                                     return;                                                  data.ThreadNum = Thread.CurrentThread.ManagedThreadId;                                               },                                               new CustomData() {Name = i, CreationTime = DateTime.Now.Ticks} );      }      Task.WaitAll(taskArray);      foreach (var task in taskArray) {         var data = task.AsyncState as CustomData;         if (data != null)            Console.WriteLine(\"Task #{0} created at {1}, ran on thread #{2}.\",                              data.Name, data.CreationTime, data.ThreadNum);      }   }}\n</code></pre>\n<h5><a id=\"3__882\"></a>.3. 任务延续</h5>\n<blockquote>\n<p>使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.continuewith\">Task.ContinueWith</a> 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.continuewith\">Task.ContinueWith</a> 方法，可以<code>指定要在先行任务完成时启动的任务</code>。 延续任务的委托已传递了对先行任务的引用，因此它可以检查先行任务的状态，并通过检索 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result\">Task.Result</a> 属性的值<code>将先行任务的输出用作延续任务的输入</code>。</p>\n<p>在下面的示例中，<code>getData</code> 任务通过调用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.startnew#system-threading-tasks-taskfactory-startnew-1%28system-func%28%28-0%29%29%29\">TaskFactory.StartNew(Func)</a> 方法来启动。 当 <code>processData</code> 完成时，<code>getData</code> 任务自动启动，当 <code>displayData</code> 完成时，<code>processData</code> 启动。 <code>getData</code> 产生一个整数数组，通过 <code>processData</code> 任务的 <code>getData</code> 属性，<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result\">Task.Result</a> 任务可访问该数组。 <code>processData</code> 任务处理该数组并返回结果，结果的类型从传递到 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.continuewith#system-threading-tasks-task-1-continuewith-1%28system-func%28%28system-threading-tasks-task%28%28-0%29%29-0%29%29%29\">Task.ContinueWith(Func,TNewResult&gt;)</a> 方法的 Lambda 表达式的返回类型推断而来。 <code>displayData</code> 完成时，<code>processData</code> 任务自动执行，而 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.tuple-3\">Tuple</a> 任务可通过 <code>processData</code> 任务的 <code>displayData</code> 属性访问由 <code>processData</code> lambda 表达式返回的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result\">Task.Result</a> 对象。 <code>displayData</code> 任务采用 <code>processData</code> 任务的结果，继而得出自己的结果，其类型以相似方式推断而来，且可由程序中的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result\">Result</a> 属性使用。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">using System;using System.Threading.Tasks;public class Example{    public static void Main()    {        var getData = Task.Factory.StartNew(() =&gt; {            Random rnd = new Random();            int[] values = new int[100];            for (int ctr = 0; ctr &lt;= values.GetUpperBound(0); ctr++)                values[ctr] = rnd.Next();            return values;        } );        var processData = getData.ContinueWith((x) =&gt; {            int n = x.Result.Length;            long sum = 0;            double mean;            for (int ctr = 0; ctr &lt;= x.Result.GetUpperBound(0); ctr++)                sum += x.Result[ctr];            mean = sum / (double) n;            return Tuple.Create(n, sum, mean);        } );        var displayData = processData.ContinueWith((x) =&gt; {            return String.Format(\"N={0:N0}, Total = {1:N0}, Mean = {2:N2}\",                                 x.Result.Item1, x.Result.Item2,                                 x.Result.Item3);        } );        Console.WriteLine(displayData.Result);    }}// The example displays output similar to the following:// N=100, Total = 110,081,653,682, Mean = 1,100,816,536.82\n</code></pre>\n<pre><code class=\"prism language-c#\">using System;using System.Threading.Tasks;public class Example{    public static void Main()    {        var displayData = Task.Factory.StartNew(() =&gt; {            Random rnd = new Random();            int[] values = new int[100];            for (int ctr = 0; ctr &lt;= values.GetUpperBound(0); ctr++)                values[ctr] = rnd.Next();            return values;        } ).            ContinueWith((x) =&gt; {                int n = x.Result.Length;                long sum = 0;                double mean;                for (int ctr = 0; ctr &lt;= x.Result.GetUpperBound(0); ctr++)                    sum += x.Result[ctr];                mean = sum / (double) n;                return Tuple.Create(n, sum, mean);            } ).            ContinueWith((x) =&gt; {                return String.Format(\"N={0:N0}, Total = {1:N0}, Mean = {2:N2}\",                                     x.Result.Item1, x.Result.Item2,                                     x.Result.Item3);            } );        Console.WriteLine(displayData.Result);    }}// The example displays output similar to the following://    N=100, Total = 110,081,653,682, Mean = 1,100,816,536.82\n</code></pre>\n<h5><a id=\"4__896\"></a>.4. 创建分离的子任务</h5>\n<blockquote>\n<p>父任务不会等待分离子任务完成。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">var outer = Task.Factory.StartNew(() =&gt;{    Console.WriteLine(\"Outer task beginning.\");    var child = Task.Factory.StartNew(() =&gt;    {        Thread.SpinWait(5000000);        Console.WriteLine(\"Detached task completed.\");    });});outer.Wait();Console.WriteLine(\"Outer task completed.\");// The example displays the following output://    Outer task beginning.//    Outer task completed.//    Detached task completed.\n</code></pre>\n<h5><a id=\"5__904\"></a>.5. 创建子任务</h5>\n<blockquote>\n<p>如果任务中运行的用户代码在创建任务时指定了 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#system-threading-tasks-taskcreationoptions-attachedtoparent\">AttachedToParent</a> 选项，新任务就称为父任务的附加子任务。</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">using System;using System.Threading;using System.Threading.Tasks;public class Example{    public static void Main()    {        var parent = Task.Factory.StartNew(() =&gt; {            Console.WriteLine(\"Parent task beginning.\");            for (int ctr = 0; ctr &lt; 10; ctr++) {                int taskNo = ctr;                Task.Factory.StartNew((x) =&gt; {                    Thread.SpinWait(5000000);                    Console.WriteLine(\"Attached child #{0} completed.\",                                      x);                },taskNo, TaskCreationOptions.AttachedToParent);            }        });        parent.Wait();   // 等待子任务的完成        Console.WriteLine(\"Parent task completed.\");    }}\n</code></pre>\n<ul><li>创建多个子任务，并保持关联</li></ul>\n<pre><code class=\"prism language-c#\">static void Main(string[] args){    var parentTask = new Task&lt;int[]&gt;(() =&gt;                                     {                                         //开启多个子任务                                         var results = new int[2];                                         //创建子任务,并将子任务的值赋给results变量,并通过TaskCreationOptions.AttachedToParent,将其关联到父任务,如果不指定,该任务将独立于父任务单独执行                                         //这里有个奇怪的问题,只能使用new Task的方式去创建关联到父任务的子任务,因为Task.Run没有提供这个方法,可以通过扩展方法解决这个问题                                         new Task(() =&gt; results[0] = ChildThreadOne(), TaskCreationOptions.AttachedToParent).Start();                                         new Task(() =&gt; results[1] = ChildThreadTwo(), TaskCreationOptions.AttachedToParent).Start();                                         return results;                                     });    parentTask.Start();    parentTask.ContinueWith(x =&gt;                            {                                Console.WriteLine(\"当父任务执行完毕时,CLR会唤起一个新线程,将父任务的返回值(子任务的返回值)输出,所以这里不会有任何的线程发生阻塞\");                                foreach (var re in parentTask.Result)                                {                                    Console.WriteLine(\"子任务的返回值分别为:{0}\", re);                                }                            });    Console.WriteLine(\"主线程不会阻塞,它会继续执行\");    Console.ReadKey();//必须加这行代码,因为Task时线程池线程,属于后台线程}/// &lt;summary&gt;/// 子任务一/// &lt;/summary&gt;static int ChildThreadOne(){    Thread.Sleep(2000);//模拟长时间计算操作    Console.WriteLine(\"子任务一完成了计算任务,并返回值:{0}\", 6);    return 6;}/// &lt;summary&gt;/// 子任务一/// &lt;/summary&gt;static int ChildThreadTwo(){    Thread.Sleep(2000);//模拟长时间计算操作    Console.WriteLine(\"子任务二完成了计算任务,并返回值:{0}\", 6);    return 6;}\n</code></pre>\n<h5><a id=\"6___918\"></a>.6. 等待任务的完成</h5>\n<pre><code class=\"prism language-c#\">Task[] tasks = new Task[3]{    Task.Factory.StartNew(() =&gt; MethodA()),    Task.Factory.StartNew(() =&gt; MethodB()),    Task.Factory.StartNew(() =&gt; MethodC())};//Block until all tasks complete.Task.WaitAll(tasks);// Continue on this thread...   ?? 这里是指代 主线程不会等待 task线程吗？  是的\n</code></pre>\n<h3><a id=\"8_Rx_924\"></a>8. Rx</h3>\n<blockquote>\n<p>Rx最显著的特性是使用<code>可观察集合(Observable Collection)</code>来达到集成<code>异步(composing asynchronous)</code>和<code>基于事件(event-based)的编程</code>的效果。Rx有一些几个特性。 <code>类似UI中的触发控件</code></p>\n<ul><li><code>组合(Composing)</code>: Reactive Extension的首要目标之一就是将多种异步操作组合起来是的代码更加简单。要做到这一点，数据流必须定义清楚，这样代码就很清晰集中，使得异步操作代码异步处理代码不会充斥整个应用程序。</li><li><code>异步(Asynchronous)</code>: 虽然Rx不仅仅能处理异步操作，但是使用Rx，大大简化了异步操作的实现，并且代码容易理解进而容易维护。</li><li><code>基于事件(Event-based)</code>: Rx简化了传统的异步编程方式</li><li><code>可观察集合(Observable collections)</code>: Obervable Collection是Rx的核心，它是一种集合，集合的元素在第一次访问的时候肯能还没有填充。它对与Rx的重要性类始于enumerable集合对LINQ的重要性。</li></ul>\n</blockquote>\n<pre><code class=\"prism language-c#\">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Reactive.Linq;using System.IO;namespace RxDemo{    class Program    {        static void Main(string[] args)        {            //使用Range方法返回Observable集合            IObservable&lt;Int32&gt; input = Observable.Range(1, 15);            input.Where(i =&gt; i % 2 == 0).Subscribe(x =&gt; Console.Write(\"{0} \", x));            Console.WriteLine();            //使用Array返回Observabale集合            var myArray = new[] { 1, 3, 5, 7, 9 };            IObservable&lt;Int32&gt; varmyObservable = myArray.ToObservable();            varmyObservable.Subscribe(x =&gt; Console.WriteLine(\"Integer:{0}\", x));            Console.WriteLine();            //Take操作符，用来指定获取集合中的前几项            var take = new[] { 1, 2, 3, 4, 5, 4, 3, 2, 1 }.ToObservable();            take.Take(5).Select(x =&gt; x * 10).Subscribe(x =&gt; Console.WriteLine(x));            Console.WriteLine();            //Skip操作符表示跳过集合中的n条记录。            var skip = new[] { 1, 2, 3, 4, 5, 4, 3, 2, 1 }.ToObservable();            skip.Skip(6).Select(x =&gt; x * 10).Subscribe(x =&gt; Console.WriteLine(x));            Console.WriteLine();            //Distinct操作符用来去除集合中的非重复数据。            var distinct = new[] { 1, 2, 3, 4, 5, 4, 3, 2, 1 }.ToObservable();            distinct.Distinct().Select(x =&gt; x * 10).Subscribe(x =&gt; Console.WriteLine(x));            //Rx也需要释放资源            Console.WriteLine();            var ObservableStrings = Observable.Using&lt;char, StreamReader&gt;(                () =&gt; new StreamReader(new FileStream(\"randomtext.txt\", FileMode.Open)),                streamReader =&gt; (streamReader.ReadToEnd().Select(str =&gt; str)).ToObservable()                );            ObservableStrings.Subscribe(Console.Write);            Console.WriteLine();            //在Rx中Zip是将两个Observable对象合并为一个新的Observable对象。            var numberCitys = varmyObservable.Zip(input, (range, array) =&gt; range + \":\" + array);            numberCitys.Subscribe(Console.WriteLine);            Console.ReadKey();        }    }}\n</code></pre>\n<h3><a id=\"9__937\"></a>9. 并行/顺序执行</h3>\n<blockquote>\n<ul><li>**串行：**A和B两个任务运行在一个CPU线程上，在A任务执行完之前不可以执行B。即，在整个程序的运行过程中，仅存在一个运行上下文，即一个调用栈一个堆。程序会按顺序执行每个指令。</li><li>**并发：**并发指<code>多个线程在宏观(相对于较长的时间区间而言)上表现为同时执行</code>，而<code>实际上是轮流穿插着执行</code>，并发的实质是一个物理CPU在若干道程序之间多路复用，其目的是提高有限物理资源的运行效率。 并发与并行串行并不是互斥的概念，如果是在一个CPU线程上启用并发，那么自然就还是串行的，而如果在多个线程上启用并发，那么程序的执行就可以是既并发又并行的。</li><li>**并行：**并行性指<code>两个或两个以上事件或活动在同一时刻发生</code>。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。比如，A和B两个任务可以同时运行在不同的CPU线程上，效率较高，但受限于CPU线程数，如果任务数量超过了CPU线程数，那么每个线程上的任务仍然是顺序执行的。</li></ul>\n</blockquote>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\5a9633fe07a055a1755752ba9857449d.png\"/></p>\n<pre><code class=\"prism language-c#\">public class Main {    //判断是否为质数    private static boolean isPrime(int n) {        if(n &lt; 2) return false;        if(n == 2) return true;        if(n%2==0) return false;        for(int i = 3; i &lt; n; i += 2)            if(n%i == 0) return false;        return true;    }    //串行计算private static void serial() {        long time1 = System.currentTimeMillis(), time2,time3;        long count = 0;        for(int i=1;i&lt;=100000;++i){            if(isPrime(i)) count+=i;        }        time2=System.currentTimeMillis();        System.out.println(\"1-100000之间质数和为\"+count+\" 耗时：\"+(time2- time1) + \"毫秒\");        count = 0;        for(int i=100001;i&lt;=200000;++i){            if(isPrime(i))                count+=i;        }        time3 = System.currentTimeMillis();        System.out.println(\"100001-200000之间质数和为\"+count+\" 耗时：\"+(time3 - time2) + \"毫秒\");        System.out.println(\"总耗时：\"+ (time3 - time1) + \"毫秒\");    }    //主函数    public static void main(String[] args) {        serial();    }}\n</code></pre>\n<pre><code class=\"prism language-c#\">public class Main{    private static boolean isPrime(int n) {        if(n &lt; 2) return false;        if(n == 2) return true;        if(n%2==0) return false;        for(int i = 3; i &lt; n; i += 2)            if(n%i == 0) return false;        return true;    }    public static void main(String[] args) {        serialConcurrency();    }    private static void serialConcurrency() {        long time = System.currentTimeMillis();        //任务切换标识，1代表A任务，2代表B任务        int task = 1;        //计数器        long count1 = 0, count2 = 0;        int i=1,j=100001;        while (true)        {            if(task == 1 &amp;&amp; i++&lt;=100000) {                if(isPrime(i)) count1+=i;                task = 2;            }            else if(task == 2 &amp;&amp; j++&lt;=200000) {                if(isPrime(j)) count2+=j;                task = 1;            }            else{                break;            }        }        System.out.println(\"1-100000之间质数和为\"+count1);        System.out.println(\"100001-200000之间质数和为\"+count2);        System.out.println(\"总耗时：\"+(System.currentTimeMillis() - time) + \"毫秒\");    }}\n</code></pre>\n<pre><code class=\"prism language-c#\">public class Main {    public static boolean isPrime(int n) {        if(n &lt; 2) return false;        if(n == 2) return true;        if(n%2==0) return false;        for(int i = 3; i &lt; n; i += 2)            if(n%i == 0) return false;        return true;    }    public static void main(String[] args) throws InterruptedException {        long time1 = System.currentTimeMillis(),time2;        Task task1 = new Task(1,100000);        Task task2 = new Task(100001,200000);        Thread thread1 = new Thread(task1);        Thread thread2 = new Thread(task2);        thread1.start();        thread2.start();        while (thread1.isAlive() || thread2.isAlive()){            Thread.sleep(1);        }        time2 = System.currentTimeMillis();        System.out.println(\"总耗时：\"+(time2 - time1)+\"毫秒\");    }}class Task implements Runnable{    private int start;    private int end;    Task(int start, int end) {        this.start = start;        this.end = end;    }    public void run() {        long time = System.currentTimeMillis();        long count = 0;        for(int i=start;i&lt;=end;++i){            if(Main.isPrime(i)) count+=i;        }        System.out.println(String.format(\"%d-%d之间质数和为%d，耗时：%d毫秒\",start,end,count,(System.currentTimeMillis()- time)));    }}\n</code></pre>\n<h3><a id=\"10_IO_957\"></a>10. 异步IO</h3>\n<h4><a id=\"1_FileStream_959\"></a>.1. FileStream</h4>\n<h4><a id=\"2_Http_961\"></a>.2. Http</h4>\n<h4><a id=\"3__963\"></a>.3. 数据库</h4>\n<h4><a id=\"Resource_965\"></a>Resource</h4>\n<ul><li>https://cloud.tencent.com/developer/article/1793724</li><li>https://www.cnblogs.com/wyt007/p/9486752.html</li><li>https://www.cnblogs.com/jackson0714/p/5125808.html</li><li>https://www.huaweicloud.com/articles/cfc1249c1ea36c04c429703a9f150d52.html</li><li>https://www.shuzhiduo.com/A/gVdnPZaaJW/</li><li>https://www.jianshu.com/p/deae44fcc6b3</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2021-12-26 14:16:37", "summary": "线程基础生命周期在线程的生命周期中，它要经过新建、就绪、行、阻塞和死亡五种状态。当线程后，它不能一直独占着独自运行，所以需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换新建状态：指新建"}