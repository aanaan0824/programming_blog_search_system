{"blogid": "125821911", "writerAge": "码龄1年", "writerBlogNum": "77", "writerCollect": "684", "writerComment": "1104", "writerFan": "919", "writerGrade": "5级", "writerIntegral": "3683", "writerName": "NO.-LL", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125821911.jpg", "writerRankTotal": "5192", "writerRankWeekly": "191", "writerThumb": "1241", "writerVisitNum": "44461", "blog_read_count": "185", "blog_time": "于 2022-08-13 16:09:24 发布", "blog_title": "初阶C++__STL__string类（使用方法+模拟实现+测试+思路分析）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"STL%E7%AE%80%E4%BB%8B-toc\" style=\"margin-left:0px;\"><a href=\"#STL%E7%AE%80%E4%BB%8B\">STL简介</a></p>\n<p id=\"string%E7%B1%BB%E7%AE%80%E4%BB%8B-toc\" style=\"margin-left:0px;\"><a href=\"#string%E7%B1%BB%E7%AE%80%E4%BB%8B\">string类简介</a></p>\n<p style=\"margin-left:0px;\"></p>\n<p id=\"%E2%85%A1.%C2%A0%C2%A0string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%85%A1.%C2%A0%C2%A0string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\">Ⅰ.  string类的常用接口</a></p>\n<p id=\"1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0\">string库函数中的构造</a></p>\n<p id=\"%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%94%AF%E6%8C%81%E4%BB%8Epos%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96npos%E4%B8%AA%E5%AD%97%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%94%AF%E6%8C%81%E4%BB%8Epos%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96npos%E4%B8%AA%E5%AD%97%E7%AC%A6\">补充：拷贝构造支持从pos开始，初始化npos个字符</a></p>\n<p style=\"margin-left:80px;\"></p>\n<p id=\"0x02%C2%A0%20sting%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:0px;\"><a href=\"#0x02%C2%A0%20sting%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C\">Ⅱ. sting类对象的容量操作</a></p>\n<p id=\"1%E3%80%81size()%E4%B8%8Elength()%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81size%28%29%E4%B8%8Elength%28%29%E7%9A%84%E5%8C%BA%E5%88%AB\">1、size()与length()的区别</a></p>\n<p id=\"2%E3%80%81%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%20capacity()-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%20capacity%28%29\">2、返回空间总大小的 capacity()</a></p>\n<p id=\"3%E3%80%81%E6%B8%85%E7%A9%BA%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E7%9A%84%20clear()-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E6%B8%85%E7%A9%BA%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E7%9A%84%20clear%28%29\">3、清空有效字符的 clear()</a></p>\n<p id=\"4%E3%80%81%C2%A0%20%E8%B0%83%E6%95%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%C2%A0resize()-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%C2%A0%20%E8%B0%83%E6%95%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%C2%A0resize%28%29\">4、  调整字符串大小 resize()</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#5%E3%80%81%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%94%B9%E5%AE%B9%E9%87%8Freserve%28%29\">5、请求更改容量reserve()</a></p>\n<p style=\"margin-left:40px;\"></p>\n<p id=\"0x03%C2%A0%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:0px;\"><a href=\"#0x03%C2%A0%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C\">Ⅲ. string类对象的访问及遍历操作</a></p>\n<p id=\"1%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%9A%84%20operator%5B%5D%20%E5%92%8C%20at()-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%9A%84%20operator%5B%5D%20%E5%92%8C%20at%28%29\">1、访问字符串字符的 operator[] 和 at()</a></p>\n<p id=\"2%E3%80%81%E5%88%9D%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ebegin()%20%5C%20end()%20%5C%20rbegin()%20%5C%20rend()-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%88%9D%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ebegin%28%29%20%5C%20end%28%29%20%5C%20rbegin%28%29%20%5C%20rend%28%29\">2、初识迭代器与begin() \\ end() \\ rbegin() \\ rend()</a></p>\n<p id=\"3%E3%80%81%E8%8C%83%E5%9B%B4for-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E8%8C%83%E5%9B%B4for\">3、范围for</a></p>\n<p style=\"margin-left:40px;\"></p>\n<p id=\"0x04%C2%A0%20string%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:0px;\"><a href=\"#0x04%C2%A0%20string%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C\">Ⅳ.string 类对象的修改操作</a></p>\n<p id=\"1%E3%80%81push_back()%20append()%20operator%2B%3D%E7%9A%84%E7%94%A8%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81push_back%28%29%20append%28%29%20operator%2B%3D%E7%9A%84%E7%94%A8%E6%B3%95\">1、string赋值与拼接push_back() append() operator+=的用法</a></p>\n<p id=\"2%E3%80%81%E8%BF%94%E5%9B%9EC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20c_str-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E8%BF%94%E5%9B%9EC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20c_str\">2、返回C格式字符串的 c_str</a></p>\n<p id=\"3%E3%80%81%E8%BF%BD%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%E7%9A%84%20find()%20%E5%92%8C%E7%94%9F%E6%88%90%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20substr()-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E8%BF%BD%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%E7%9A%84%20find%28%29%20%E5%92%8C%E7%94%9F%E6%88%90%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20substr%28%29\">3、追查字符位置的 find() 和生成子字符串的 substr()</a></p>\n<p id=\"0x06%20%E5%80%92%E7%9D%80%E8%BF%BD%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20rfind()%C2%A0%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#0x06%20%E5%80%92%E7%9D%80%E8%BF%BD%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20rfind%28%29%C2%A0%C2%A0\">反向追查字符串的 rfind()  </a></p>\n<p id=\"4%E3%80%81string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%92%8C%E6%9B%BF%E6%8D%A2%20-%C2%A0replace()%20compare()-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%92%8C%E6%9B%BF%E6%8D%A2%20-%C2%A0replace%28%29%20compare%28%29\">4、string字符串比较和替换 - replace() compare()</a></p>\n<p id=\"5%E3%80%81%C2%A0string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%20-%C2%A0insert()%C2%A0erase()-toc\" style=\"margin-left:40px;\"><a href=\"#5%E3%80%81%C2%A0string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%20-%C2%A0insert%28%29%C2%A0erase%28%29\">5、 string插入和删除 - insert() erase()</a></p>\n<p style=\"margin-left:40px;\"></p>\n<p id=\"%E2%85%A4.string%20%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%85%A4.string%20%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0\">Ⅴ.string 类非成员函数的实现</a></p>\n<p id=\"%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">1.operator 运算符重载</a></p>\n<p id=\"%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96\">2.流插入和流提取</a></p>\n<p id=\"%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">完整代码</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"STL%E7%AE%80%E4%BB%8B\">STL简介</h1>\n<p><br/> STL(standard template libaray-标准模板库)：是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个<strong>包罗数据结构与算法的软件框架</strong></p>\n<p>其中包括六大组件：</p>\n<ul><li>算法</li><li>容器</li><li>迭代器</li><li>空间适配器</li><li>仿函数</li><li>配接器</li></ul>\n<p>而我们这个系列，实现的是各种各样的容器</p>\n<p>网上有句话说：“不懂STL，不要说你会C++”。STL是C++中的优秀作品，有了它的陪伴，许多底层的数据结构以及算法都不需要自己重新造轮子，站在前人的肩膀上，健步如飞的快速开发。<br/><img alt=\"\" height=\"1131\" src=\"..\\..\\static\\image\\eeba47b01885424ea3a98e875c43ecc5.png\" width=\"1200\"/></p>\n<p></p>\n<h1 id=\"string%E7%B1%BB%E7%AE%80%E4%BB%8B\"><a href=\"https://so.csdn.net/so/search?q=string%E7%B1%BB&amp;spm=1001.2101.3001.7020\" title=\"string类\">string类</a>简介</h1>\n<p><strong>string是c++中表示字符串的容器，其底层的字符串表示方式仍然是以’\\0’表示的字符串集合</strong>但是提供了比c语言更多的接口</p>\n<p><strong>在使用string类时，必须包含string头文件以及using namespace std</strong></p>\n<div>\n<div>\n<pre><code class=\"language-cpp\">#include &lt;string&gt;       // 使用string类时，需引入头文件 &lt;string&gt;\nusing namespace std;    // 展开std</code></pre>\n</div>\n</div>\n<p>string是C++风格的字符串，而string本质上是一个类</p>\n<p><strong>string和char * 区别：</strong></p>\n<ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul>\n<blockquote>\n<p>string成员中包含了以下几个成员：</p>\n<ul><li>字符串数组</li><li>字符串的有效字符大小</li><li>字符串容量</li><li>迭代器</li></ul>\n<p>对以上点做出以下解释：</p>\n<p><strong>迭代器</strong>提供了<strong>遍历整个字符串的方式</strong>，虽然string中的遍历没有迭代器会更加方便。但因为<strong>与STL中其它难以遍历的容器统一，所以string中并没有舍弃迭代器。</strong></p>\n<p></p>\n<p><strong>容量</strong>指的是类为我们的字符串数组开辟的空间，而有效字符个数指的是我们已经使用<strong>已经存储了元素的容量</strong>大小。</p>\n<p></p>\n<p>有效字符和容量都<strong>不包括’\\0’</strong></p>\n</blockquote>\n<p>所以，我们模拟实现的字符串类型中，有以下成员：</p>\n<div>\n<div>\n<pre><code class=\"language-cpp\">char* _str;//字符串类型\nsize_t size;//字符串有效字符大小\nsize_t capacity;//字符串容量\n</code></pre>\n</div>\n</div>\n<p><span style=\"color:#fe2c24;\"><strong>size_t 是 unsigned long long，传-1的实际值是2^64-1 </strong></span></p>\n<hr/>\n<p> 官方文本文档：</p>\n<p><a href=\"https://cplusplus.com/reference/string/string/?kw=string\" title=\"string类的文档介绍 - C++ Reference (cplusplus.com)\">string类的文档介绍 - C++ Reference (cplusplus.com)</a></p>\n<p>① string 是表示字符串的字符串类。</p>\n<p>② 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作 string 的常规操作。</p>\n<p>③ string在底层上实际是：basic_string 模板类的别名：</p>\n<div>\n<div>\n<pre><code class=\"language-cpp\">typedef basic_string&lt;char, char_traits, allocator&gt;string;</code></pre>\n</div>\n</div>\n<p>④ 不能操作多字节或者变长字符的序列。<br/>  </p>\n<p class=\"img-center\"><img alt=\"\" height=\"169\" src=\"..\\..\\static\\image\\93ae75814a0a3ff00f156f49cba26cb2.jpeg\" width=\"169\"/></p>\n<p></p>\n<h1 id=\"%E2%85%A1.%C2%A0%C2%A0string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\">Ⅰ.  string类的常用接口</h1>\n<p><img alt=\"\" height=\"377\" src=\"..\\..\\static\\image\\164a7027972546fdb132bcb744a3ea1b.png\" width=\"1200\"/></p>\n<p></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/string/\" title=\"(constructor) 函数名称\">(constructor) 函数名称</a></td><td>功能说明</td></tr><tr><td>string()                           （重点）</td><td>构造空的string类对象，即空字符</td></tr><tr><td>string(const char* s)      （重点）</td><td>用C-string来构造string类对象</td></tr><tr><td>string(size_t n, char c)    </td><td>string类对象中包含n个字符c</td></tr><tr><td>string(const string&amp; s)   （重点）</td><td>拷贝构造函数</td></tr></tbody></table>\n<div>\n<pre><code class=\"language-cpp\">string()                      // 构造空的string类对象，即非空字符串。\nstring(cosnt char* s)         // 用C-string来构造string类对象\nstring(size_t n, char c)      // string类对象中包含n个字符c\nstring(const string&amp;s)        // 拷贝构造函数</code></pre>\n</div>\n<h2 id=\"1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0\">string<a href=\"https://so.csdn.net/so/search?q=%E5%BA%93%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020\" title=\"库函数\">库函数</a>中的构造</h2>\n<p>库函数构造主要有<strong>默认构造</strong>，<strong>含参构造</strong>和<strong>拷贝构造</strong></p>\n<p><strong>默认构造</strong>是构造出一个空字符串</p>\n<div>\n<pre><code class=\"language-cpp\">string s1;\n//构造出一个空字符串\n</code></pre>\n</div>\n<p><strong>含参构造</strong>中我们可以传入c语言中的字符串指针或字符串数组类型</p>\n<div>\n<pre><code class=\"language-cpp\">string s2(\"hello world!\");\n//构造出\"hello world!字符串\"</code></pre>\n</div>\n<div>\n<pre><code class=\"language-cpp\">string(const char* s = \"\")\n\t:_size(strlen(s)), _capacity(strlen(s))\n{\n\t_str = new char[_capacity + 1];\n\tstrcpy(_str, s);\n}\n</code></pre>\n</div>\n<p></p>\n<p>也可以在string中构造n个相同的字符c</p>\n<div>\n<pre><code class=\"language-cpp\">//string(size_t n,char c)\nstring s3(10,'a');\n//第一个参数是个数n，第二个参数是字符c\n//构造出的字符串：aaaaaaaaaa</code></pre>\n</div>\n<div>\n<pre><code class=\"language-cpp\">string(size_t n, char c)\n\t:_size(n), _capacity(n)\n{\n\t_str = new char[_capacity + 1];\n\tmemset(_str, c, _size);\n\t_str[_size] = '\\0';\n}\n</code></pre>\n</div>\n<p></p>\n<p><strong>拷贝构造使用某个其它stirng类的引用</strong></p>\n<div>\n<pre><code class=\"language-cpp\">string s4(s1);//拷贝一份s1到s4中</code></pre>\n</div>\n<p>string 的拷贝构造： </p>\n<div>\n<pre><code class=\"language-cpp\">/* s2(s1) */\nstring(const string&amp; s)\n\t: _str(new char[strlen(s._str) + 1]) {\n\tstrcpy(_str, s._str);\n}</code></pre>\n</div>\n<p>演示：</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\n//string构造\nvoid test01()\n{\n\tstring s1; //创建空字符串，调用无参构造函数\n\tcout &lt;&lt; \"str1 = \" &lt;&lt; s1 &lt;&lt; endl;\n\n\tconst char* str = \"hello world\";\n\tstring s2(str); //把c_string转换成了string\n\n\tcout &lt;&lt; \"str2 = \" &lt;&lt; s2 &lt;&lt; endl;\n\n\tstring s3(s2); //调用拷贝构造函数\n\tcout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl;\n\n\tstring s4(10, 'a');\n\tcout &lt;&lt; \"str3 = \" &lt;&lt; s4 &lt;&lt; endl;\n}\nint main() {\n\ttest01();\n\treturn 0;\n}\n</code></pre>\n</div>\n<p> <img alt=\"\" height=\"93\" src=\"..\\..\\static\\image\\cb435eeea2954a4a8fc98929bfe1d2c0.png\" width=\"233\"/>​</p>\n<h3 id=\"%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%94%AF%E6%8C%81%E4%BB%8Epos%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96npos%E4%B8%AA%E5%AD%97%E7%AC%A6\"><img alt=\"\" src=\"..\\..\\static\\image\\9dfc678a449e48d496d3f24c348344de.png\"/>补充：拷贝构造支持从pos开始，初始化npos个字符</h3>\n<p><img alt=\"\" height=\"25\" src=\"..\\..\\static\\image\\3de82214c947489bb757a30467bc5a85.png\" width=\"920\"/>​</p>\n<p> 我们发现长度 len 缺省值给的是 npos：</p>\n<div>\n<pre><code class=\"language-cpp\">string (\n    const string&amp; str, \n    size_t pos,         // 起始位置\n    size_t len = npos   // 长度（缺省值给的npos）\n    );</code></pre>\n</div>\n<blockquote>\n<p><img alt=\"\" height=\"477\" src=\"..\\..\\static\\image\\39eed0af06c743dc9c5e015f29bf94e2.png\" width=\"1200\"/>​  </p>\n<p>这个 npos 你可以理解为是 string 里的一个静态变量，它是 -1。</p>\n<p>当你没有指定 len 时，因为 npos 是 -1，而又是 size_t 无符号整型，他长度将会是整形的最大值。</p>\n<p>也就是说，如果你不传，它就相当于取整型最大值 2147483647，所以也就相当于取所有字符串了</p>\n<div>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\tstring s1(\"abcdef123456\");\n\tstring s2(s1, 2);       // 从第2个位置开始，初始化npos个长度的字符\n\tcout &lt;&lt; s2 &lt;&lt; endl;\n \n\treturn 0;\n}</code></pre>\n</div>\n<p></p>\n</blockquote>\n<p></p>\n<p></p>\n<h1 id=\"0x02%C2%A0%20sting%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C\">Ⅱ. sting类对象的容量操作</h1>\n<table align=\"left\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/size/\" title=\"size\">size</a>     （重点）</td><td>返回字符串有效字符长度</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/length/\" title=\"length\">length</a></td><td>返回字符串有效字符长度</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/capacity/\" title=\"capacity\">capacity</a></td><td>返回空间总大小</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/empty/\" title=\"empty\">empty</a>  （重点）</td><td>检测字符串是否为空串，是返回true，否则返回 flase</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/clear/\" title=\"clear\">clear</a>    （重点）</td><td> <p>清空有效字符</p> </td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/reserve/\" title=\"reserve\">reserve</a>（重点）</td><td>为字符串预留空间</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/resize/\" title=\"resize\">resize</a>   （重点）</td><td>将有效字符的个数改成n个，多出的空间用字符c填充</td></tr></tbody></table>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"1%E3%80%81size()%E4%B8%8Elength()%E7%9A%84%E5%8C%BA%E5%88%AB\">1、size()与length()的区别</h2>\n<p><img alt=\"\" height=\"628\" src=\"..\\..\\static\\image\\46991d206b264656be9f18c14b1eb315.png\" width=\"608\"/>​</p>\n<p></p>\n<blockquote>\n<p>①  size() 和 length() 的计算不包含 \\0。</p>\n<p>     解释：它不包含最后作为结尾标识符的 \\0，告诉你的是有效的字符长度。</p>\n<p></p>\n<p>②  size() 和 length() 的功能都是返回字符串有效长度，功能上没有区别。</p>\n<p>     解释： 这是一个 \"历史包袱\" 问题。</p>\n</blockquote>\n<p>总结：size()与length()方法<strong>底层实现原理完全相同</strong>，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。</p>\n<p><img alt=\"\" height=\"67\" src=\"https://img-blog.csdnimg.cn/img_convert/e21f43b2ab119380e3d75682f42de7ac.gif\" width=\"67\"/></p>\n<p></p>\n<h2 id=\"2%E3%80%81%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%20capacity()\">2、<strong>返回空间总大小的 capacity()</strong></h2>\n<blockquote>\n<p>返回当前为<a href=\"https://cplusplus.com/string\" title=\"字符串\">字符串</a>分配的存储空间的大小，以<strong>字节</strong>表示。<br/><br/> 此<em>容量</em>不一定等于<a href=\"https://cplusplus.com/string::length\" title=\"字符串长度\">字符串长度</a>。它可以等于或更大，额外的空间允许对象在向<a href=\"https://cplusplus.com/string\" title=\"字符串\">字符串</a>添加新字符时优化其操作。</p>\n<p></p>\n<p>请注意，此<em>容量</em>并不假定字符串<a href=\"https://cplusplus.com/string::length\" title=\"的长度\">的长度</a>有<a href=\"https://cplusplus.com/string\" title=\"限制。\">限制。</a>当此<em>容量</em>耗尽并且需要更多容量时，它由对象自动扩展（重新分配其存储空间）。<a href=\"https://cplusplus.com/string\" title=\"字符串\">字符串</a><a href=\"https://cplusplus.com/string::length\" title=\"长度\">长度</a>的理论限制由成员<a href=\"https://cplusplus.com/string::max_size\" title=\"max_size\">max_size</a>给出。</p>\n</blockquote>\n<p>总结：在算法中没什么用处，因为每个编译器分配空间方式都不同，所以值都有所出入</p>\n<p></p>\n<p></p>\n<h2 id=\"3%E3%80%81%E6%B8%85%E7%A9%BA%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E7%9A%84%20clear()\">3、<strong>清空有效字符的 clear()</strong></h2>\n<p>clear：擦除字符串的内容，<a href=\"https://cplusplus.com/string\" title=\"该字符串\">该字符串</a>将成为<a href=\"https://cplusplus.com/string::empty\" title=\"空字符串\">空字符串</a>（<a href=\"https://cplusplus.com/string::length\" title=\"长度\">长度</a>为 0 个字符）</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nint main()\n{\n\tstring s1(\"abcdef\");\n    cout &lt;&lt; \"清空前: \" &lt;&lt; s1 &lt;&lt; endl;\n\tcout &lt;&lt; s1.size() &lt;&lt; endl;\n \tcout &lt;&lt; s1.capacity() &lt;&lt; endl;\n\ts1.clear();\n\tcout &lt;&lt; \"清空后: \" &lt;&lt; s1 &lt;&lt; endl;\n\tcout &lt;&lt; s1.size() &lt;&lt; endl;\n\tcout &lt;&lt; s1.capacity() &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n</div>\n<p><img alt=\"\" height=\"215\" src=\"..\\..\\static\\image\\56dc5cc8cbf247bf8d4ddf66cc2174f1.png\" width=\"474\"/>​</p>\n<p> 总结：clear()<strong>只是将string中有效字符清空</strong>，<strong>不改变底层空间大小</strong>。</p>\n<p></p>\n<h2 id=\"4%E3%80%81%C2%A0%20%E8%B0%83%E6%95%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%C2%A0resize()\">4、  调整字符串大小 resize()</h2>\n<div>\n<pre><code class=\"language-cpp\">void resize (size_t n);\nvoid resize (size_t n, char c);</code></pre>\n</div>\n<p>将字符串大小调整为 <em>n</em> 个字符<a href=\"https://cplusplus.com/string::length\" title=\"的长度\">的长度</a>。<br/><br/> 如果 <em>n</em> 小于当前<a href=\"https://cplusplus.com/string::length\" title=\"字符串长度\">字符串长度</a>，则当前值将缩短为其前 <em>n</em> 个字符，并删除超出 <em>n</em> 的字符。</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nint main()\n{\n\tstring s1(\"abcdef\");\n    s1.resize(3);\n    cout&lt;&lt;s1&lt;&lt;endl;\n    s1.resize(30,'1');\n\tcout&lt;&lt;s1&lt;&lt;endl;\n\treturn 0;\n}\n</code></pre>\n</div>\n<p><img alt=\"\" height=\"144\" src=\"..\\..\\static\\image\\9ab56fe229f14701b33ef785d55e8d68.png\" width=\"464\"/>​</p>\n<p></p>\n<p>总结： resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：<strong>resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间</strong>。</p>\n<p>注意：resize在改变元素个数时，如果是将元素个数增多，<strong>可能会改变底层容量的大小</strong>，如果是将元素个数减少，底层空间总大小不变。</p>\n<h3 id=\"resize()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\"><br/> resize() 的实现</h3>\n<pre><code class=\"language-cpp\">/* resize */\nvoid resize(size_t new_capacity, char init_ch = '\\0') {\n\t// 如果欲增容量比_size小\n\tif (new_capacity &lt;= _size) {\n\t\t_str[new_capacity] = '\\0';      // 拿斜杠零去截断\n\t\t_size = new_capacity;           // 更新大小\n\t}\n\t// 欲增容量比_size大\n\telse {\n\t\tif (new_capacity &gt; _capacity) { \n\t\t\treserve(new_capacity);\n\t\t}\n\t\t// 起始位置，初始化字符，初始化个数\n\t\tmemset(_str + _size, init_ch, new_capacity - _size);\n\t\t_size = _capacity;\n\t\t_str[_size] = '\\0';\n\t}\n}</code></pre>\n<h2 id=\"5%E3%80%81%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%94%B9%E5%AE%B9%E9%87%8Freserve()\">5、请求更改容量reserve()</h2>\n<div>\n<pre><code class=\"language-cpp\">void reserve (size_t n = 0);</code></pre>\n</div>\n<blockquote>\n<p> 请求将<a href=\"https://cplusplus.com/string::capacity\" title=\"字符串容量\">字符串容量</a>适应计划<a href=\"https://cplusplus.com/string::size\" title=\"的大小\">的大小</a>更改为最多 <em>n</em> 个字符<a href=\"https://cplusplus.com/string::length\" title=\"的长度\">的长度</a>。<br/><br/> 如果 <em>n</em> 大于当前<a href=\"https://cplusplus.com/string::capacity\" title=\"字符串容量\">字符串容量</a>，则该函数会导致容器将其<a href=\"https://cplusplus.com/string::capacity\" title=\"容量\">容量</a>增加到 <em>n</em> 个字符（或更大）。<br/><br/> 在所有其他情况下，它被视为收缩<a href=\"https://cplusplus.com/string::capacity\" title=\"字符串容量\">字符串容量</a>的非约束性请求：容器实现可以自由地进行优化，并使<a href=\"https://cplusplus.com/string\" title=\"字符串\">字符串</a>的<a href=\"https://cplusplus.com/string::capacity\" title=\"容量\">容量</a>大于<em>n</em>。<br/><br/> 此函数对<a href=\"https://cplusplus.com/string::length\" title=\"字符串长度\">字符串长度</a>没有影响，并且无法更改其内容。</p>\n</blockquote>\n<p>与resize（）的对比： </p>\n<p><img alt=\"\" height=\"721\" src=\"..\\..\\static\\image\\43c7ded82e21473eb199d0ce7f8a5208.png\" width=\"759\"/>​</p>\n<p>可见reserve()仅仅改变容量，不改变长度 </p>\n<p></p>\n<p>总结： reserve(size_t res_arg=0)：<strong>为string预留空间，不改变有效元素个数</strong>，当reserve的参数小于string的底层空间总大小时，<strong>reserver不会改变容量大小。</strong></p>\n<h3 id=\"0x00%20reserve()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">reserve() 的实现</h3>\n<pre><code class=\"language-cpp\">/* 增容：reverse */\nvoid reserve(size_t new_capacity) {\n\tif (new_capacity &gt; _capacity) {\n\t\tchar* tmp = new char[new_capacity + 1];  // 开新空间\n\t\tstrcpy(tmp, _str);                       // 搬运\n\t\tdelete[] _str;                           // 释放原空间\n \n\t\t_str = tmp;                              // 没问题，递交给_str\n\t\t_capacity = new_capacity;                // 更新容量\n\t}\n}</code></pre>\n<p></p>\n<h1 id=\"0x03%C2%A0%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C\">Ⅲ. string类对象的访问及遍历操作</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator%5B%5D/\" title=\"operator[]\">operator[]</a></td><td>返回pos位置的字符，const string类对象调用</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/begin/\" title=\"begin\">begin</a> + <a href=\"http://www.cplusplus.com/reference/string/string/end/\" title=\"end\">end</a></td><td>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/rbegin/\" title=\"rbegin\">rbegin</a> + <a href=\"http://www.cplusplus.com/reference/string/string/rend/\" title=\"rend\">rend</a></td><td>rbegin获取一个字符的反向迭代器 + rend获取最后一个字符下一个位置的迭代器</td></tr><tr><td>范围 for</td><td>C++11支持更简洁的范围 for 新遍历方式</td></tr></tbody></table>\n<h2 id=\"1%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%9A%84%20operator%5B%5D%20%E5%92%8C%20at()\">1、访问字符串字符的 operator[] 和 at()</h2>\n<p>如果访问这个字符串的每一个字符，会有： </p>\n<div>\n<pre><code>for (size_t i = 0; i &lt; s1.size(); i++) {\n\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t}</code></pre>\n</div>\n<div>\n<pre><code class=\"language-cpp\">cout &lt;&lt; s1[i] &lt;&lt; \" \";        \ncout &lt;&lt; s1.operator[](i) &lt;&lt; \" \";   // 取字符串第i个位置的字符的引用</code></pre>\n</div>\n<p>string 这里它作为函数调用，这就是 operator[]  ，并且等价于：cout &lt;&lt; s1.operator[](i) &lt;&lt; \" \";</p>\n<p>operator[] 的底层是这样设计的：</p>\n<div>\n<pre><code class=\"language-cpp\">char&amp; operator[] (size_t pos)\n{\n    return _str[pos];\n}</code></pre>\n</div>\n<p> 所以</p>\n<p><img alt=\"\" height=\"441\" src=\"..\\..\\static\\image\\d4a5358e862a4d39b0c7959e38a5520d.png\" width=\"454\"/>​</p>\n<p></p>\n<hr/>\n<h1 id=\"at()%C2%A0\">at() </h1>\n<p>除了 operator[] 还有一个 at() ，at() 也是早期支持的一个接口</p>\n<p>它和 operator[] 用处是一样的，at() 是像函数一样去使用的：</p>\n<div>\n<pre><code class=\"language-cpp\">int main(void)\n{\n\tstring s1(\"hello world\");\n \n\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\ts1.at(i) += 1;\n\t}\n\tcout &lt;&lt; s1 &lt;&lt; endl;\n \n\treturn 0;\n}</code></pre>\n</div>\n<p><strong>at() 和 operator[] 的区别</strong> —— 它们检查越界的方式不一样。</p>\n<p> operator[] 是使用<strong>断言</strong>处理的，断言是一种激进的处理手段。</p>\n<p>而 at() 是比较温柔的处理方式，如果 pos &gt;= size 就 <strong>throw 一个异常对象</strong>出去。</p>\n<p></p>\n<h2 id=\"2%E3%80%81%E5%88%9D%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ebegin()%20%5C%20end()%20%5C%20rbegin()%20%5C%20rend()\">2、初识迭代器与begin() \\ end() \\ rbegin() \\ rend()</h2>\n<p>迭代器是 STL 六大组件之一，是用来访问和修改容器的。 </p>\n<p><img alt=\"\" height=\"683\" src=\"..\\..\\static\\image\\e612b884fbe64cf59b0f95d7f6f3ca1d.png\" width=\"612\"/>​</p>\n<p><img alt=\"\" height=\"64\" src=\"..\\..\\static\\image\\e66800e8e12341829d49cc206637b35d.png\" width=\"281\"/>​</p>\n<p></p>\n<p> 同理：</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nint main(void)\n{\n\tstring s1(\"hello\");\n\t\n    // 迭代器\n\t\n  \tfor (string::reverse_iterator rit=s1.rbegin(); rit!=s1.rend(); ++rit)\n    \tcout &lt;&lt; *rit;\n \n\treturn 0;\n}\n\n</code></pre>\n</div>\n<blockquote>\n<p>输出：olleh</p>\n</blockquote>\n<p></p>\n<p>迭代器遍历的意义：</p>\n<ul><li>对于 string，你得会用迭代器，但是一般我们还是喜欢用 下标 + [] 遍历；</li><li>比如 list、map / set  不支持 下标 + [] 遍历，迭代器就排上用场了，这就是迭代器存在的意义。</li><li>迭代器是通用的遍历方式。</li></ul>\n<p></p>\n<p></p>\n<h2 id=\"3%E3%80%81%E8%8C%83%E5%9B%B4for\">3、范围for</h2>\n<div>\n<span style=\"color:#777777;\"><strong>C++11</strong></span>\n<span style=\"color:#777777;\"><strong>支持更简洁的范围</strong></span>\n<span style=\"color:#777777;\"><strong>for</strong></span>\n<span style=\"color:#777777;\"><strong>的新遍历方式</strong></span>\n</div>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nint main(void)\n{\n\tstring s1(\"hello\");\n\tfor (auto e : s1) {\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\t//遍历\n\t}\n\tcout &lt;&lt; endl;\n\n\tfor (auto e : s1) {    // 无引用修改\n\t\te += 1;\n\t}\n\tcout &lt;&lt; \"无引用 \" &lt;&lt; s1 &lt;&lt; endl;\n\n\tfor (auto&amp; e : s1) {    // 引用修改\n\t\te += 1;\n\t}\n\tcout &lt;&lt; \"引用修改 \" &lt;&lt; s1 &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"170\" src=\"..\\..\\static\\image\\d9293f19bf784231a71f23e6107c867b.png\" width=\"407\"/>​</p>\n<p> 详情可看下方连接的<a href=\"https://blog.csdn.net/qq_61386381/article/details/124952732#t15\" title=\" Ⅴ. auto关键字(C++11)\"> Ⅴ. auto关键字(C++11)</a></p>\n<p> <a href=\"https://blog.csdn.net/qq_61386381/article/details/124952732\" title=\" C++入门基础总结（最详细）\"> C++入门基础总结（最详细）</a></p>\n<p></p>\n<p></p>\n<h1 id=\"0x04%C2%A0%20string%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C\">Ⅳ.string 类对象的修改操作</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/push_back/\" title=\"push_back\">push_back</a></td><td>在字符串后尾插字符c</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/append/\" title=\"append\">append</a></td><td>在字符后追加一个字符串</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator+=/\" title=\"operator+=\">operator+=</a>    （重点）</td><td>在字符串后追加字符串str</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/c_str/\" title=\"c_str\">c_str</a>              （重点）</td><td>返回c格式字符串</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/find/\" title=\"find\">find</a>  +  <a href=\"http://www.cplusplus.com/reference/string/string/npos/\" title=\"npos\">npos</a>  （重点）</td><td>从字符串pos位置开始往后找字符c，返回该字符自字符串中的位置</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/rfind/\" title=\"rfind\">rfind</a></td><td>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/substr/\" title=\"substr\">substr</a></td><td>在str中从pos位置开始，截取n个字符，然后将其返回</td></tr></tbody></table>\n<p></p>\n<h2 id=\"1%E3%80%81push_back()%20append()%20operator%2B%3D%E7%9A%84%E7%94%A8%E6%B3%95\">1、string赋值与拼接push_back() append() operator+=的用法</h2>\n<blockquote>\n<p><strong>push_back</strong>：插入一个字符，但只能插入一个字符</p>\n<p></p>\n<p><strong>append</strong>：可以插入字符串</p>\n<p></p>\n<p> <strong>operator+=</strong>：可以添加字符、字符串、对象</p>\n<p><img alt=\"\" height=\"251\" src=\"..\\..\\static\\image\\bf4d57439263462fbca4db638a295c4e.png\" width=\"1200\"/>​</p>\n<ul><li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li></ul>\n</blockquote>\n<p>演示：</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nstring s=\"C++\";\nstring s1=\"\";\n\nint main()\n{\n\ts1.push_back('I');//只能单字符 \n\tcout&lt;&lt;s1&lt;&lt;endl;\n\t\n\ts1.append(\" Love \");//插入字符串 \n\tcout&lt;&lt;s1&lt;&lt;endl;\n\t\n\ts1+='C';\n \tcout&lt;&lt;s1&lt;&lt;endl;\n \ts1+=\" and \";\n \tcout&lt;&lt;s1&lt;&lt;endl;\n \ts1+=s;\n \tcout&lt;&lt;s1&lt;&lt;endl;\n\t//可以添加字符、字符串、对象 \n \n\treturn 0;\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"196\" src=\"..\\..\\static\\image\\17a59f1517d9422c8a09466268bc8a62.png\" width=\"431\"/>​</p>\n<p></p>\n<h3 id=\"0x01%C2%A0push_back()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">push_back() 的实现</h3>\n<pre><code class=\"language-cpp\">/* 字符串尾插：push_back */\nvoid push_back(char append_ch) {\n\tif (_size == _capacity) {      // 检查是否需要增容\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2); \n\t}\n \n\t_str[_size] = append_ch;       // 插入要追加的字符\n\t_size++;\n\t_str[_size] = '\\0';            // 手动添加'\\0'\n}</code></pre>\n<h3 id=\"0x02%C2%A0append()%20%E7%9A%84%E5%AE%9E%E7%8E%B0\">append() 的实现</h3>\n<pre><code class=\"language-cpp\">/* 字符串追加：append */\nvoid append(const char* append_str) {\n\tsize_t len = strlen(append_str);     // 计算要追加的字符串的长度\n\tif (_size + len &gt; _capacity) {       // 检查是否需要增容\n\t\treserve(_size + len);\n\t}\n \n\tstrcpy(_str + _size, append_str);    // 首字符+大小就是\\0位置\n\t_size += len;                        // 更新大小\n}</code></pre>\n<h3 id=\"0x03%C2%A0operator%2B%3D%C2%A0%E7%9A%84%E5%AE%9E%E7%8E%B0\"> operator+= 的实现</h3>\n<pre><code class=\"language-cpp\">/* operator+= */\nstring&amp; operator+=(char append_ch) {\n\tpush_back(append_ch);    // 复用push_back\n\treturn *this;\n}\nstring&amp; operator+=(const char* append_str) {\n\tappend(append_str);      // 复用append\n\treturn *this;\n}</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"2%E3%80%81%E8%BF%94%E5%9B%9EC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20c_str\">2、返回C格式字符串的 c_str</h2>\n<p>当我们用printf输出string类型时，就必须用c_str</p>\n<p><img alt=\"\" height=\"427\" src=\"..\\..\\static\\image\\2453803e2fdc4c20a11e908157a720ae.png\" width=\"923\"/>​</p>\n<p></p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nint main() {\n\tstring s1(\"hello string\");\n\tcout &lt;&lt; s1 &lt;&lt; endl;  // 调用重载的流插入运算符打印的\n\tprintf(\"%s\\n\",s1.c_str());\n\t//printf(\"%s\\n\",s1);\n\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;  \n\t// 这是调字符串打印的，c_str 是遇到 \\0 结束的，\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"597\" src=\"..\\..\\static\\image\\430c7fc2fe67493b8168dba195a8a24c.png\" width=\"875\"/>​</p>\n<p> 补充：转成字符串才能取地址时</p>\n<div>\n<pre><code class=\"language-cpp\">// 获取file后缀\nvoid Test() {\n\tstring file(\"test.txt\"); \n\tFILE* pf = fopen(file.c_str(), \"w\");  \n}</code></pre>\n</div>\n<p>比如这里需要打开文件，fopen 第一个参数要求是 const char*，</p>\n<p>所以这里怎么能直接放 string 是不行的，这时候可以用 .c_str()  就可以把字符串的地址返回出来。</p>\n<p><img alt=\"\" height=\"72\" src=\"https://img-blog.csdnimg.cn/img_convert/819d6e90db6bbefc4cfd2d8b4852cbf7.gif\" width=\"94\"/></p>\n<p></p>\n<h2 id=\"3%E3%80%81%E8%BF%BD%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%E7%9A%84%20find()%20%E5%92%8C%E7%94%9F%E6%88%90%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20substr()\">3、追查字符位置的 find() 和生成子字符串的 substr()</h2>\n<p></p>\n<p><strong>find</strong>：从字符串 pos 位置开始往后找字符 c ，返回该字符在字符串中的位置。</p>\n<div>\n<pre><code class=\"language-cpp\">size_t find (const char* s, size_t pos = 0) const;</code></pre>\n</div>\n<p>find（'字符'，开始位置）; （不给开始位置默认从0开始）</p>\n<p><strong>substr</strong>：在 str 中从 pos 位置开始，截取 n 个字符，然后返回一个新构造的对象，其值初始化为此对象的子字符串的副本。</p>\n<div>\n<pre><code class=\"language-cpp\">string substr (size_t pos = 0, size_t len = npos) const;</code></pre>\n</div>\n<p> substr（开始位置，截取长度）；（不给截取长度默认缺省值无穷大npos）</p>\n<p>演示：</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nint main() {\n\t//创建字符串记录网址\n\tstring url(\"http://www.cplusplus.com/reference/string/string/find/\");\n \n\t// 取出协议\n\tsize_t pos1 = url.find(':'); //默认从头找\n\tstring protocol = url.substr(0, pos1);\n\tcout &lt;&lt; protocol &lt;&lt; endl; \n \n\t// 取出域名\n\tsize_t pos2 = url.find('/', pos1 + 3);  \n\t\t\t\t// 冒号位置+3开始往后找（w位置） \n\tstring domain = url.substr(pos1 + 3, pos2 - (pos1 + 3));\n\tcout &lt;&lt; domain &lt;&lt; endl;\n \n\t// 取出路径\n\tstring uri = url.substr(pos2 + 1);\n\tcout &lt;&lt; uri &lt;&lt; endl;\n\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\0eef802c227e410cbd97e62f64c94abf.png\" width=\"539\"/>​</p>\n<p></p>\n<h3 id=\"0x06%20%E5%80%92%E7%9D%80%E8%BF%BD%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20rfind()%C2%A0%C2%A0\">反向追查字符串的 rfind()  </h3>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\nvoid test01()\n{\n\t//查找\n\tstring str1 = \"abcdefgde\";\n\n\tint pos = str1.find(\"de\");\n\n\tif (pos == -1)\n\t{\n\t\tcout &lt;&lt; \"未找到\" &lt;&lt; endl;\n\t}\n\telse\n\t{\n\t\tcout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl;\n\t}\n\t\n\tpos = str1.rfind(\"de\");\n\n\tcout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl;\n\n}\n\n\nint main() {\n\ttest01();\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>pos = 3<br/> pos = 7</p>\n</blockquote>\n<p>与find（）同理，只是从右往左找而已</p>\n<p></p>\n<h3 id=\"0x06%C2%A0%E5%AE%9E%E7%8E%B0%20find()\">find() 的实现</h3>\n<p>find：查找字符</p>\n<pre><code class=\"language-cpp\">/* find */\nsize_t find(char aim_ch) {\n\tfor (size_t i = 0; i &lt; _size; i++) {\n\t\tif (aim_ch == _str[i]) { \n\t\t\t// 找到了\n\t\t\treturn i;    // 返回下标\n\t\t}\n\t}\n\t// 找不到\n\treturn npos;\n}</code></pre>\n<p> find：查找字符串</p>\n<pre><code class=\"language-cpp\">size_t find(const char* aim_str, size_t pos = 0) {\n\tconst char* ptr = strstr(_str + pos, aim_str);\n\tif (ptr == nullptr) {\n\t\treturn npos;\n\t}\n\telse {\n\t\treturn ptr - _str;  // 减开头\n\t}\n}</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"4%E3%80%81string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%92%8C%E6%9B%BF%E6%8D%A2%20-%C2%A0replace()%20compare()\">4、string字符串比较和替换 - <code>replace() compare()</code></h2>\n<blockquote>\n<ul><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li></ul>\n<p></p>\n<ul><li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul>\n</blockquote>\n<p><code>replace():</code></p>\n<pre><code class=\"language-cpp\">void test02()\n{\n\t//替换\n\tstring str1 = \"abcdefgde\";\n\tstr1.replace(1, 3, \"1111\");\n\n\tcout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl;\n}\n\nint main() {\n\ttest02();\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>str1 = a1111efgde</p>\n</blockquote>\n<p></p>\n<p><code>compare():</code></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n//字符串比较\nvoid test01()\n{\n\n\tstring s1 = \"hello\";\n\tstring s2 = \"aello\";\n\n\tint ret = s1.compare(s2);\n\n\tif (ret == 0) {\n\t\tcout &lt;&lt; \"s1 等于 s2\" &lt;&lt; endl;\n\t}\n\telse if (ret &gt; 0)\n\t{\n\t\tcout &lt;&lt; \"s1 大于 s2\" &lt;&lt; endl;\n\t}\n\telse\n\t{\n\t\tcout &lt;&lt; \"s1 小于 s2\" &lt;&lt; endl;\n\t}\n\n}\n\nint main() {\n\n\ttest01();\n\n\treturn 0;\n}\n</code></pre>\n<p></p>\n<h2 id=\"5%E3%80%81%C2%A0string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%20-%C2%A0insert()%C2%A0erase()\">5、 string插入和删除 - <code>insert() erase()</code></h2>\n<ul><li><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code> //删除从Pos开始的n个字符</li></ul>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n//字符串插入和删除\nvoid test01()\n{\n\tstring str = \"hello\";\n\tstr.insert(1, \"111\");\n\tcout &lt;&lt; str &lt;&lt; endl;\n\n\tstr.erase(1, 3);  //从1号位置开始3个字符\n\tcout &lt;&lt; str &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest01();\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>h111ello<br/> hello</p>\n</blockquote>\n<p></p>\n<h3 id=\"0x07%C2%A0%E5%AE%9E%E7%8E%B0%20erase()\">erase() 的实现</h3>\n<pre><code class=\"language-cpp\">/* 删除：erase */\nstring&amp; erase(size_t pos, size_t len = npos) {\n\tassert(pos &lt; _size);\n \n\tif (len == pos || pos + len &gt;= _size) {\n\t\t_str[pos] = '\\0';    // 放置\\0截断\n\t\t_size = pos;\n\t}\n\telse {\n\t\tstrcpy(_str + pos, _str + pos + len);\n\t\t_size -= len;\n\t}\n \n\treturn *this;\n}</code></pre>\n<h3 id=\"%C2%A00x04%C2%A0%E5%AE%9E%E7%8E%B0%20insert()\">insert() 的实现</h3>\n<p>insert：字符</p>\n<pre><code class=\"language-cpp\">/* 插入：insert */\nstring&amp; insert(size_t pos, char append_ch) {\n\tassert(pos &lt;= _size);\n \n\t// 检查是否需要增容\n\tif (_size == _capacity) {     \n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t}\n\t\t\t\n\t// 向后挪动数据\n\t//size_t end = _size;\n\t//while (end &gt;= (int)pos) {\n\t//\t_str[end + 1] = _str[end];\n\t//\tend--;\n\t//}\n \n\tsize_t end = _size + 1;\n\twhile (end &gt; pos) {\n\t\t_str[end] = _str[end - 1];\n\t\tend--;\n\t}\n \n\t// 插入\n\t_str[pos] = append_ch;\n\t_size++;\n \n\treturn *this;\n}</code></pre>\n<p>insert：字符串</p>\n<pre><code class=\"language-cpp\">string&amp; insert(size_t pos, const char* append_str) {\n\tassert(pos &lt;= _size);\n\tsize_t len = strlen(append_str);\n \n\t// 检查是否需要增容\n\tif (_size + len &gt; _capacity) {\n\t\treserve(_size + len);\n\t}\n \n\t// 向后挪动数据\n\tsize_t end = _size + len;\n\twhile (end &gt; pos + len - 1) {\n\t\t_str[end] = _str[end - len];\n\t\tend--;\n\t}\n \n\t// 插入\n\tstrncpy(_str + pos, append_str, len);\n\t_size += len;\n \n\treturn *this;\n}</code></pre>\n<p></p>\n<h1 id=\"%E2%85%A4.string%20%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0\">Ⅴ.string 类非成员函数的实现</h1>\n<h2 id=\"%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">1.operator 运算符重载</h2>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\549f01c295774121bdef3a9a3d22a151.png\"/>大型造轮子现场，核心为复用与调用</p>\n<h3 id=\"0x00%20operator%3C\"> operator&lt;</h3>\n<pre><code class=\"language-cpp\">/* s1 &lt; s2*/\nbool operator&lt;(const string&amp; s1, const string&amp; s2) {\n\tsize_t i1 = 0, i2 = 0;\n\twhile (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {\n\t\tif (s1[i1] &lt; s2[i2]) {\n\t\t\treturn true;\n\t\t} \n\t\telse if (s1[i1] &gt; s2[i2]) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\ti1++;\n\t\t\ti2++;\n\t\t}\n\t}\n\treturn i2 &lt; s2.size() ? true : false;\n}</code></pre>\n<p>当然，我们还可以实现的更简单些，直接用 strcmp 偷个懒：</p>\n<pre><code class=\"language-cpp\">/* s1 &lt; s2*/\nbool operator&lt;(const string&amp; s1, const string&amp; s2) {\n\treturn strcmp(s1.c_str(), s2.c_str()) &lt; 0;\n}</code></pre>\n<p></p>\n<h3 id=\"0x01%20operator%3D\"> operator==</h3>\n<pre><code class=\"language-cpp\">/* s1 == s2 */\nbool operator==(const string&amp; s1, const string&amp; s2) {\n\treturn strcmp(s1.c_str(), s2.c_str()) == 0;\n}</code></pre>\n<p></p>\n<p><strong>接下来的操作可以复用 == 和 &lt;</strong></p>\n<p><img alt=\"\" height=\"120\" src=\"..\\..\\static\\image\\94119bebb99d4546831118785f1bb471.png\" width=\"221\"/>高端的程序员，往往只需要最简单的编程方式~~</p>\n<p></p>\n<p> operator&lt;=</p>\n<pre><code class=\"language-cpp\">\t/* s1 &lt;= s2 */\n\tbool operator&lt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn s1 &lt; s2 || s1 == s2;\n\t}</code></pre>\n<p>operator&gt;</p>\n<pre><code class=\"language-cpp\">    /* s1 &gt; s2 */\n\tbool operator&gt;(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt;= s2);\n\t}</code></pre>\n<p>operator&gt;=</p>\n<pre><code class=\"language-cpp\">\t/* s1 &gt;= s2 */\n\tbool operator&gt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt; s2);\n\t}</code></pre>\n<p>operator!=</p>\n<pre><code class=\"language-cpp\">\t/* s1 != s2 */\n\tbool operator!=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 == s2);\n\t}</code></pre>\n<p></p>\n<h2 id=\"%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96\">2.流插入和流提取</h2>\n<h3 id=\"0x01%20%E5%AE%9E%E7%8E%B0%20operator%3C%3C\">operator&lt;&lt; 的实现</h3>\n<pre><code class=\"language-cpp\">// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)\nostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {\n\t//for (auto ch : s) {\n\t//\tout &lt;&lt; ch;\n\t//}\n \n\tfor (size_t i = 0; i &lt; s.size(); i++) {\n\t\tout &lt;&lt; s[i];\n\t}\n \n\treturn out;\n}</code></pre>\n<h3 id=\"0x02%20%E5%AE%9E%E7%8E%B0%20operator%3E%3E\">operator&gt;&gt; 的实现</h3>\n<pre><code class=\"language-cpp\">// cin &gt;&gt;\nistream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {\n\tchar ch = in.get();\n\twhile (ch == '\\n') {\n\t\ts += ch;\n\t\tch = in.get();\n\t}\n \n\treturn in;\n}</code></pre>\n<p></p>\n<p></p>\n<h1 id=\"%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">完整代码</h1>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n \nnamespace chaos\n{\n\tclass string {\n\tpublic:\n\t\t/* 构造函数 */\n\t\tstring(const char* str = \"\")\n\t\t\t: _size(strlen(str))        // 计算出字符串str的大小\n\t\t\t, _capacity(_size) {        // 初始容量等于字符串大小\n \n\t\t\t_str = new char[_capacity + 1];   // 开辟一块 \"容量+1\" 大小的空间 (_capacity存的是有效字符）\n\t\t\tstrcpy(_str, str);                // 将传入的字符串str复制到 _str中\n\t\t}\n \n\t\tvoid Swap(string&amp; tmp) {\n\t\t\tswap(_str, tmp._str);\n\t\t\tswap(_size, tmp._size);\n\t\t\tswap(_capacity, tmp._capacity);\n\t\t}\n \n\t\t/* 拷贝构造函数：s2(s1) \n\t\tstring(const string&amp; src)\n\t\t\t: _size(src._size)                // 拷贝string大小\n\t\t\t, _capacity(src._capacity) {      // 拷贝string容量\n\t\t\t// 拷贝string内容\n\t\t\t_str = new char[src._capacity + 1];        // 开辟一块和src相同容量的空间\n\t\t\tstrcpy(_str, src._str);\t\t\t\t\t   // 将src中的_str内容拷贝到自己的_str中\n\t\t}\n\t\t*/\n\t\tstring(const string&amp; src)\n\t\t\t: _str(nullptr)\n\t\t\t, _size(0)\n\t\t\t, _capacity(0) {\n \n\t\t\tstring tmp(src._str);   // 拷贝构造一个src\n\t\t\tSwap(tmp);              // 现代写法：交换\n\t\t}\n\t\n \n\t\t/* 赋值重载：s1 = s3\n\t\tstring&amp; operator=(const string&amp; src) {\n\t\t\t// 防止自己跟自己赋值\n\t\t\tif (this != &amp;src) {\n\t\t\t\t// 1. 暂时用tmp开辟一块相同的空间\n\t\t\t\tchar* tmp = new char[src._capacity + 1];\n\t\t\t\t// 2. 把src的值复制给tmp\n\t\t\t\tstrcpy(tmp, src._str);\n\t\t\t\t// 3. 释放this原空间\n\t\t\t\tdelete[] _str;\n\t\t\t\t// 4. 没翻车，把tmp交付给_src\n\t\t\t\t_str = tmp;\n\t\t\t\t_size = src._size;\n\t\t\t\t_capacity = src._capacity;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\tstring&amp; operator=(const string&amp; src) {\n\t\t\t// 防止自己跟自己赋值\n\t\t\tif (this != &amp;src) {\n\t\t\t\tstring tmp(src);   // 复用拷贝构造\n\t\t\t\tSwap(tmp);\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\t*/\n\t\tstring&amp; operator=(string src) {\n\t\t\tSwap(src);    // 正好调用拷贝构造，不如让形参充当tmp\n\t\t\treturn *this;\n\t\t}\n \n \n\t\t/* 返回C格式的字符串：c_str */\n\t\tconst char* c_str() const {\n\t\t\treturn _str;\n\t\t}\n \n\t\t/* 求字符串大小：size() */\n\t\tsize_t size() const {\n\t\t\treturn _size;\n\t\t}\n \n\t\t/* operator[] */\n\t\tchar&amp; operator[](size_t pos) {\n\t\t\tassert(pos &lt; _size);\n\t\t\treturn _str[pos];  // 返回字符串对应下标位置的元素\n\t\t}\n\t\tconst char&amp; operator[](size_t pos) const {\n\t\t\tassert(pos &lt; _size);\n\t\t\treturn _str[pos];\n\t\t}\n \n\t\t/* 迭代器 */\n\t\ttypedef char* iterator;\n\t\titerator begin() { \n\t\t\treturn _str;            // 返回第一个字符的位置\n\t\t}\n\t\titerator end() {\n\t\t\treturn _str + _size;    // 返回最后一个字符的位置\n\t\t}\n \n\t\t/* const迭代器 */\n\t\ttypedef const char* const_iterator;\n\t\tconst_iterator begin() const {\n\t\t\treturn _str;\n\t\t}\n\t\tconst_iterator end() const {\n\t\t\treturn _str + _size;\n\t\t}\n \n\t\t/* reserve() */\n\t\tvoid reserve(size_t new_capacity) {\n\t\t\tif (new_capacity &gt; _capacity) {               // 检查是否真的需要扩容\n\t\t\t\tchar* tmp = new char[new_capacity + 1];   // 开空间\n\t\t\t\tstrcpy(tmp, _str);\t\t\t\t\t\t  // 先搬运数据到tmp\n \n\t\t\t\t_str = tmp;\t\t\t\t\t\t\t\t  // 没翻车，递交给_str\n\t\t\t\t_capacity = new_capacity;\t\t\t\t  // 更新容量\n\t\t\t}\n\t\t}\n \n\t\t/* 字符尾插：push_back() */\n\t\tvoid push_back(char append_ch) {\n\t\t\t/*\n\t\t\tif (_size == _capacity) {                         // 检查是否需要扩容\n\t\t\t\treserve(_capacity == 0 ? 4 : _capacity * 2);  // 首次给4，其他情况默认扩2倍\n\t\t\t}\n\t\t\t_str[_size] = append_ch;     // 插入要追加的字符\n\t\t\t_size++;\t\t\t\t\t\t \n\t\t\t_str[_size] = '\\0';\t         // 手动添加'\\0'\n\t\t\t*/\n \n\t\t\tinsert(_size, append_ch);\n\t\t}\n \n\t\t/* 字符串追加：append() */\n\t\tvoid append(const char* append_str) {\n\t\t\t/*\n\t\t\tsize_t len = strlen(append_str);      // 计算出要追加的字符串的长度\n\t\t\tif (_size + len &gt; _capacity) {\t\t  // 检查是否需要扩容\n\t\t\t\treserve(_size + len);\n\t\t\t}\n\t\t\tstrcpy(_str + _size, append_str);      // 首字符+大小，就是'\\0'位置\n\t\t\t_size += len;\t\t\t\t\t\t   // 更新大小\n\t\t\t*/\n\t\t\t\n\t\t\tinsert(_size, append_str);\n\t\t}\n \n\t\t/* operator+= */\n\t\tstring&amp; operator+=(char append_ch) {\n\t\t\tpush_back(append_ch);\n\t\t\treturn *this;\n\t\t}\n\t\tstring&amp; operator+=(const char* append_str) {\n\t\t\tappend(append_str);\n\t\t\treturn *this;\n\t\t}\n \n\t\t/* insert */\n\t\tstring&amp; insert(size_t pos, char append_ch) {\n\t\t\tassert(pos &lt;= _size);\n \n\t\t\tif (_size == _capacity) {\t\t// 检查是否需要扩容\n\t\t\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t\t\t}\n \n\t\t\t// 向后挪动数据\n\t\t\tsize_t end = _size + 1;\n\t\t\twhile (end &gt; pos) {\n\t\t\t\t_str[end] = _str[end - 1];\n\t\t\t\tend--;\n\t\t\t}\n \n\t\t\t// 插入\n\t\t\t_str[pos] = append_ch;\n\t\t\t_size++;\n \n\t\t\treturn *this;\n\t\t}\n\t\tstring&amp; insert(size_t pos, const char* append_str) {\n\t\t\tassert(pos &lt;= _size);\n\t\t\tsize_t len = strlen(append_str);\n \n\t\t\tif (_size + len &gt; _capacity) {    // 检查是否需要增容\n\t\t\t\treserve(_size + len);\n\t\t\t}\n \n\t\t\t// 向后挪动数据\n\t\t\tsize_t end = _size + len;\n\t\t\twhile (end &gt; pos + len - 1) {\n\t\t\t\t_str[end] = _str[end - len];\n\t\t\t\tend--;\n\t\t\t}\n \n\t\t\t// 插入\n\t\t\tstrncpy(_str + pos, append_str, len);\n\t\t\t_size += len;\n \n\t\t\treturn *this;\n\t\t}\n \n\t\t/* resize */\n\t\tvoid resize(size_t new_capacity, char init_ch = '\\0') {\n\t\t\t// 如果欲增容量比_size小\n\t\t\tif (new_capacity &lt;= _size) {\n\t\t\t\t_str[new_capacity] = '\\0';      // 拿斜杠零去截断\n\t\t\t\t_size = new_capacity;           // 更新大小\n\t\t\t}\n\t\t\t// 欲增容量比_size大\n\t\t\telse {\n\t\t\t\tif (new_capacity &gt; _capacity) {\n\t\t\t\t\treserve(new_capacity);\n\t\t\t\t}\n\t\t\t\t// 起始位置，初始化字符，初始化个数\n\t\t\t\tmemset(_str + _size, init_ch, new_capacity - _size);\n\t\t\t\t_size = _capacity;\n\t\t\t\t_str[_size] = '\\0';\n\t\t\t}\n\t\t}\n \n\t\t/* find */\n\t\tsize_t find(char aim_ch) {\n\t\t\tfor (size_t i = 0; i &lt; _size; i++) {\n\t\t\t\tif (aim_ch == _str[i]) {\n\t\t\t\t\t// 找到了\n\t\t\t\t\treturn i;    // 返回下标\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 找不到\n\t\t\treturn npos;\n\t\t}\n\t\tsize_t find(const char* aim_str, size_t pos = 0) {\n\t\t\tconst char* ptr = strstr(_str + pos, aim_str);\n\t\t\tif (ptr == nullptr) {\n\t\t\t\treturn npos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ptr - _str;  // 减开头\n\t\t\t}\n\t\t}\n \n\t\t/* 删除：erase */\n\t\tstring&amp; erase(size_t pos, size_t len = npos) {\n\t\t\tassert(pos &lt; _size);\n \n\t\t\tif (len == pos || pos + len &gt;= _size) {\n\t\t\t\t_str[pos] = '\\0';    // 放置\\0截断\n\t\t\t\t_size = pos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrcpy(_str + pos, _str + pos + len);\n\t\t\t\t_size -= len;\n\t\t\t}\n \n\t\t\treturn *this;\n\t\t}\n \n\t\t/* 析构函数 */\n\t\t~string() {\n\t\t\tif (_str != nullptr) {\n\t\t\t\tdelete[] _str;\n\t\t\t\t_str = nullptr;\n\t\t\t}\n\t\t\t_size = _capacity = 0;\n\t\t}\n \n\tprivate:\n\t\t/* 成员变量 */\n\t\tchar* _str;\n\t\tsize_t _size;\n\t\tsize_t _capacity;\n \n\tpublic:\n\t\tstatic const size_t npos;\n\t};\n \n\t/* 初始化npos */\n\tconst size_t string::npos = -1;   // 无符号整型的-1，即整型最大值\n \n\t/* s1 &lt; s2*/\n\tbool operator&lt;(const string&amp; s1, const string&amp; s2) {\n\t\t/*\n\t\tsize_t i1 = 0, i2 = 0;\n\t\twhile (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {\n\t\t\tif (s1[i1] &lt; s2[i2]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (s1[i1] &gt; s2[i2]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti1++;\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\t\treturn i2 &lt; s2.size() ? true : false;\n\t\t*/\n \n\t\treturn strcmp(s1.c_str(), s2.c_str()) &lt; 0;\n\t}\n \n\t/* s1 == s2 */\n\tbool operator==(const string&amp; s1, const string&amp; s2) {\n\t\treturn strcmp(s1.c_str(), s2.c_str()) == 0;\n\t}\n \n\t/* s1 &lt;= s2 */\n\tbool operator&lt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn s1 &lt; s2 || s1 == s2;\n\t}\n \n\t/* s1 &gt; s2 */\n\tbool operator&gt;(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt;= s2);\n\t}\n \n\t/* s1 &gt;= s2 */\n\tbool operator&gt;=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 &lt; s2);\n\t}\n \n \n\t/* s1 != s2 */\n\tbool operator!=(const string&amp; s1, const string&amp; s2) {\n\t\treturn !(s1 == s2);\n\t}\n \n\t// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)\n\tostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {\n\t\t/*\n\t\tfor (auto ch : s) {\n\t\t\tout &lt;&lt; ch;\n\t\t}\n\t\t*/\n \n\t\tfor (size_t i = 0; i &lt; s.size(); i++) {\n\t\t\tout &lt;&lt; s[i];\n\t\t}\n \n\t\treturn out;\n\t}\n \n\t// cin &gt;&gt;\n\tistream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {\n\t\tchar ch = in.get();\n\t\twhile (ch == '\\n') {\n\t\t\ts += ch;\n\t\t\tch = in.get();\n\t\t}\n \n\t\treturn in;\n\t}\n \n \n \n\t/* 测试用 */\n\tvoid test_string1() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2(s1);\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t\tcout &lt;&lt; s2.c_str() &lt;&lt; endl;\n \n\t\tstring s3(\"pig\");\n\t\tcout &lt;&lt; s3.c_str() &lt;&lt; endl;\n \n\t\ts1 = s3;\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n \n\tvoid test_string2() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2;\n \n\t\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n \n\tvoid test_string3() {\n\t\tstring s1(\"hello world\");\n\t\tstring s2;\n \n\t\ts1[0] = 'F';\n\t\tfor (size_t i = 0; i &lt; s1.size(); i++) {\n\t\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n \n\tvoid test_string4() {\n\t\tstring s1(\"hello world\");\n \n\t\t// 迭代器写\n\t\tstring::iterator it = s1.begin();\n\t\twhile (it != s1.end()) {\n\t\t\t*it += 1;\n\t\t\tit++;\n\t\t}\n \n\t\t// 迭代器读\n\t\tit = s1.begin();   // 重置起点\n\t\twhile (it != s1.end()) {\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\tit++;\n\t\t}\n\t}\n \n\tvoid test_string5() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1.push_back('!');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1.push_back('A');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n \n\tvoid test_string6() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1 += '!';\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1 += \"this is new data\";\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n \n\tvoid test_string7() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1.insert(0, 'X');\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1.insert(0, \"hahahaha\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n\t}\n \n\tvoid test_string8() {\n\t\tstring s1(\"hello world\");\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1.erase(5, 2);   // 从第五个位置开始，删两个字符\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t\ts1.erase(5, 20);  // 从第五个位置开始，删完\n\t\tcout &lt;&lt; s1.c_str() &lt;&lt; endl;\n \n\t}\n}\n </code></pre>\n<p></p>\n<p><img alt=\"\" height=\"97\" src=\"https://img-blog.csdnimg.cn/01efb8988c7f4d2f8c401fd886c2c8d1.gif\" width=\"97\"/>终于写完了！！</p>\n<p> <img alt=\"\" height=\"91\" src=\"..\\..\\static\\image\\216a8fca12da69cd20ab1687ba790286.jpeg\" width=\"98\"/>不是，这还拿不下你？</p>\n<p><a href=\"https://mp.csdn.net/mp_blog/creation/editor/125821363\" title=\"Ⅲ、Ⅳ、Ⅴ、Ⅵ、Ⅶ、Ⅷ、\">Ⅲ、Ⅳ、Ⅴ、Ⅵ、Ⅶ、Ⅷ、</a></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-13 16:09:24", "summary": "目录简介类简介类的常用接口库函数中的构造补充：拷贝构造支持从开始，初始化个字符类对象的容量操作、与的区别、返回空间总大小的、清空有效字符的、调整字符串大小、请求更改容量类对象的访问及遍历操作、访问字符"}