{"blogid": "114285424", "writerAge": "码龄2年", "writerBlogNum": "122", "writerCollect": "2097", "writerComment": "87", "writerFan": "289", "writerGrade": "5级", "writerIntegral": "2135", "writerName": "白巧克力LIN", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_114285424.jpg", "writerRankTotal": "9119", "writerRankWeekly": "9687", "writerThumb": "431", "writerVisitNum": "153552", "blog_read_count": "26721", "blog_time": "于 2021-03-03 16:34:14 发布", "blog_title": "Java继承超详细", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E7%BB%A7%E6%89%BF-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%A7%E6%89%BF\">继承</a></p>\n<p id=\"%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9\">继承的优点</a></p>\n<p id=\"%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95\">重写和隐藏父类方法</a></p>\n<p id=\"%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95\">重写父类中的方法</a></p>\n<p id=\"%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95\">隐藏父类中的方法</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E5%90%8E%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E5%90%8E%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6\">方法重写和隐藏后的修饰符</a></p>\n<p id=\"%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98\">子类访问父类私有成员</a></p>\n<p id=\"%E4%BD%BF%E7%94%A8super%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BD%BF%E7%94%A8super%E5%85%B3%E9%94%AE%E5%AD%97\">使用super关键字</a></p>\n<p id=\"%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%AD%97%E6%AE%B5-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%AD%97%E6%AE%B5\">使用super调用父类中重写的方法、访问父类中被隐藏的字段</a></p>\n<p id=\"%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F%E6%9C%89%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F%E6%9C%89%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">使用super调用父类的无参数构造方法/有参数构造方法</a></p>\n<p id=\"%E6%9C%80%E5%90%8E-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%9C%80%E5%90%8E\">最后</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>继承是面向对象语法的三大特征之一。继承可以降低代码编写的冗余度，提高编程的效率。通过继承，子类获得了父类的成员变量和方法。一个子类如何继承父类的字段和方法，如何修改从父类继承过来的子类的方法呢。今天我们开始学习有关Java继承的知识。</p>\n<h1 id=\"%E7%BB%A7%E6%89%BF\">继承</h1>\n<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>\n<p><span style=\"color:#f33b45;\">继承的作用</span>：通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。</p>\n<p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>\n<pre><code class=\"language-java\">class 父类{\n    ...       //成员变量、成员方法\n}\nclass 子类 extends 父类{\n    ...       //类体\n}</code></pre>\n<p>例如：</p>\n<pre><code class=\"language-java\">class teacher{             //声明一个teacher类为父类\n\tString name;      \t   //定义父类的成员变量name、age   \n\tint age;\n\tvoid show(){           //定义父类成员方法，将成员变量输出\n\t\tSystem.out.println(name); \t  \n\t\tSystem.out.println(age); \n\t}\n}\nclass Student extends teacher {     //声明一个Student类为子类并继承父类\n}\npublic class myfirst {\n\tpublic static void main(String[] args) {\n\tSystem.out.println(\"学生\");\n\tStudent student=new Student();     //声明一个Student类的实例对象student\n\tstudent.name=\"Tom\";                //子类调用父类的成员变量name并赋值\n\tstudent.age=19;                    //子类调用父类的成员变量age并赋值\n\tstudent.show();                    //子类调用父类的成员方法show\n\t}\n}</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"language-java\">学生\nTom\n19</code></pre>\n<p>注意：</p>\n<ul><li>子类不能选择性继承父类；</li><li>Java不支持多重继承，但一个类可以实现多个接口，从而克服单继承的缺点；</li><li>构造方法不会被子类继承，但可以从子类中调用父类的构造方法。</li></ul>\n<h2 id=\"%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9\">继承的优点</h2>\n<ul><li>继承过来的字段和方法，可以像任何其他字段和方法一样被直接使用；</li><li>在子类中可以声明一个与父类中同名的新字段或静态方法，从而“隐藏”父类中的字段或方法；</li><li>可以在子类中声明一个在父类中没有的新字段和方法；</li><li>可以在子类中编写一个父类当中具有相同名的新实例方法，这称为“方法重写”或“方法覆盖”；</li><li>可以在子类中编写一个调用父类构造方法的子类构造方法，既可以隐式地实现，也可以通过使用关键字super来实现。</li></ul>\n<h2 id=\"%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95\">重写和隐藏父类方法</h2>\n<p>子类继承了父类中的所有成员及方法，但在某种情况下，子类中该方法所表示的行为与其父类中该方法所表示的行为不完全相同，例如，在父类语言中定义了说话这个方法，而在子类中说话的方法是不同的：外国人说英文，中国人说中文，这时我们就需要重写或隐藏父类的该方法。</p>\n<h3 id=\"%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95\">重写父类中的方法</h3>\n<p>当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。例如：</p>\n<pre><code class=\"language-java\">class A{\n\tpublic void sayHello() {                      //输出英文欢迎\n\t\tSystem.out.println(\"Hello,Welcome to Java!!!\");\n\t}\n\tpublic void sayBye() {\n\t\tSystem.out.println(\"GoodBye,everyone\");\n\t}\n}\nclass B extends A {           \n    public void sayHello() {                      //输出中文欢迎  \n    \tSystem.out.println(\"大家好，欢迎学习Java！！！\");\n    }\n}\npublic class myfirst {\n\tpublic static void main(String[] args) {\n\tB b=new B();                                //创建子类B的一个实例对象，使用默认构造方法\n\tb.sayHello();                               //调用子类中重写的方法\n\tb.sayBye();                                 //调用父类中的方法\n\t}\n}</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"language-java\">大家好，欢迎学习Java！！！\nGoodBye,everyone</code></pre>\n<p><span style=\"color:#f33b45;\">注意</span>：重写的方法具有与其所重写的方法相同的名称、参数数量、类型和返回值。</p>\n<h3 id=\"%E9%9A%90%E8%97%8F%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95\">隐藏父类中的方法</h3>\n<p>如果一个子类定义了一个静态类方法，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。</p>\n<ul><li>当调用被重写的方法时，调用的版本是子类的方法；</li><li>当调用被隐藏的方法时，调用的版本取决于是从父类中调用还是从子类中调用。</li></ul>\n<pre><code class=\"language-java\">class A{\n\tpublic static void sayHello() {             //静态类方法\n\t\tSystem.out.println(\"大家好，这是A的静态类方法\");\n\t}\n\tpublic void sayHello2() {                   //实例方法\n\t\tSystem.out.println(\"大家好，这是A中的实例方法\");\n\t}\n}\nclass B extends A {    \n    public static void sayHello() {             //静态类方法\n    \tSystem.out.println(\"大家好，这是B的静态类方法\");\n    }\n    public void sayHello2() {                   //实例方法\n    \tSystem.out.println(\"大家好，这是B的实例方法\");\n    }\n}\npublic class myfirst {\n\tpublic static void main(String[] args) {\n\t    B b=new B();                           //创建B类的实例对象b\n\t    A a=b;                                 //隐式对象类型转换\n\t    A.sayHello();                          //调用A类的静态类方法\n\t    a.sayHello();                          //调用a对象的静态类方法\n\t    B.sayHello();                          //调用B类的静态方法\n\t    a.sayHello2();                         //调用a对象的实例方法\n\t    b.sayHello2();                         //调用b对象的的实例方法\n\t    A a2=new A();                          //创建A类的实例对象a2\n\t    a2.sayHello2();                        //调用a2对象的实现方法\n\t}\n}</code></pre>\n<p>运行结果为：</p>\n<pre><code>大家好，这是A的静态类方法\n大家好，这是A的静态类方法\n大家好，这是B的静态类方法\n大家好，这是B的实例方法\n大家好，这是B的实例方法\n大家好，这是A中的实例方法</code></pre>\n<p>可以看出，得到调用的隐藏方法是父类中的方法，而得到调用的重写方法是子类中的方法。</p>\n<h3 id=\"%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%9A%90%E8%97%8F%E5%90%8E%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6\">方法重写和隐藏后的修饰符</h3>\n<p>在子类中被重写的方法，其访问权限允许大于但不允许小于被其重写的方法，例如：父类中一个受保护的实例方法(protected)在子类中可以是公共的(public)的，但不可以是私有的(private)。如果一个方法在父类中是static方法，那么在子类也必须是static方法；如果一个方法在父类中是实例方法，那么在子类中也必须是实例方法。</p>\n<h2 id=\"%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98\">子类访问父类私有成员</h2>\n<p>子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。那么如何在子类中访问到父类中的字段呢，我们可以在父类中提供用来访问其私有字段的public或protected方法，子类使用这些方法来访问相应的字段。例如：</p>\n<pre><code class=\"language-java\">class A{                     //父类A\n\tprivate int value=10;    //声明一个私有变量value并赋值为10\n\tpublic int getvalue() {  //声明一个公有成员方法getvalue，返回value\n\t\treturn value;\n\t}\n}\nclass B extends A{           //A的子类B\n}\npublic class myfirst {    \n\tpublic static void main(String[] args) {\n\t  B b=new B();           //创建子类B的一个实例对象\n\t  System.out.println(\"子类通过父类提供的公共接口访问A中的私有字段value:\"+b.getvalue());\n\t}\n}</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"language-java\">子类通过父类提供的公共接口访问A中的私有字段value:10</code></pre>\n<h2 id=\"%E4%BD%BF%E7%94%A8super%E5%85%B3%E9%94%AE%E5%AD%97\">使用super关键字</h2>\n<h3 id=\"%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%AD%97%E6%AE%B5\">使用super调用父类中重写的方法、访问父类中被隐藏的字段</h3>\n<p>子类重写了父类中的某一个方法，隐藏父类中的字段，假如想在子类中访问到父类中被重写的方法和隐藏父类的字段，可以在子类中通过使用关键字super来调用父类中被重写的方法和访问父类中被隐藏的字段。例如：</p>\n<pre><code class=\"language-java\">package first;\nclass A{\n    public String name=\"张飞\";         //添加成员变量\n\tpublic void say() {                //添加成员方法say\n\t\tSystem.out.println(\"我是父类A成员方法say\");\n\t}\n}\nclass B extends A{\n    public String name=\"关羽\";         //与父类中同名的字段，隐藏父类\n\tpublic void say(){                 //重写方法say\n\t\tsuper.say();                   //使用super关键字调用父类中的方法\n\t\tSystem.out.println(\"我是子类B成员方法say\");\n        System.out.println(\"父类的name名字：\"+super.name); //使用super关键字访问父类中的变量\n\t}\n}\npublic class myfirst {\n\tpublic static void main(String[] args) {\n\t  B b=new B();                     //创建子类的一个实例对象\n\t  b.say();                         //调用子类中重写的方法\n\t  System.out.println(\"子类的name名字：\"+b.name);   //调用子类中的name\n\t}\n}</code></pre>\n<p>运行结果为：</p>\n<pre><code>我是父类A成员方法say\n我是子类B成员方法say\n父类的name名字：张飞\n子类的name名字：关羽</code></pre>\n<h3 id=\"%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F%E6%9C%89%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">使用super调用父类的无参数构造方法/有参数构造方法</h3>\n<p>子类不继承其父类的构造方法。</p>\n<ul><li>当使用无参数的super()时，父类的无参数构造方法就会被调用；</li><li>当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。</li></ul>\n<p>例如：</p>\n<pre><code class=\"language-java\">class SuperClass {              //创建父类SuperClass\n\t  private int n;            //声明一个私有变量n\n\t  SuperClass(){             //父类无参数构造方法\n\t    System.out.println(\"这是父类SuperClass无参数构造方法\");\n\t  }\n\t  SuperClass(int n) {       //父类有参数构造方法\n\t    System.out.println(\"这是父类SuperClass有参数构造方法\");\n\t    this.n = n;\n\t  }\n\t}\n\tclass SubClass extends SuperClass{     // SubClass类继承SuperClass类\n\t  private int n;                       //声明一个私有变量n\n\t  SubClass(){                          // 自动调用父类的无参数构造器\n\t    System.out.println(\"这是子类无参数构造方法\");\n\t  }  \n\t  \n\t  public SubClass(int n){              //子类有参数构造方法\n\t    super(300);                        //调用父类中带有参数的构造器\n\t    System.out.println(\"这是子类有参数构造方法\"+n);\n\t    this.n = n;\n\t  }\n\t}\npublic class myfirst {\n\tpublic static void main(String[] args) {\n\t\t    SubClass sc1 = new SubClass();      //创建子类SubClass实例对象，调用其无参数构造方法\n\t\t    SubClass sc2 = new SubClass(100);   //创建子类SubClass实例对象，调用其有参数构造方法\n\t}\n}\n</code></pre>\n<p>运行结果为：</p>\n<pre><code>这是父类SuperClass无参数构造方法\n这是子类无参数构造方法\n这是父类SuperClass有参数构造方法\n这是子类有参数构造方法100</code></pre>\n<p>注意</p>\n<ul><li>如果要初始化父类中的字段，可以在子类的构造方法中通过关键字super调用父类的构造方法；</li><li>对父类的构造放的调用必须放在子类构造方法的第一行；</li><li>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器；</li><li>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表；</li><li>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</li></ul>\n<h1 id=\"%E6%9C%80%E5%90%8E\">最后</h1>\n<p>好了，有关Java继承的知识讲到这里了，谢谢观看！！！</p>\n<p>我们下篇文章再见！！！</p>\n<p>成功不是将来才有的，而是从决定去做的那一刻起，持续累积而成。</p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2021-03-03 16:34:14", "summary": "目录前言继承继承的优点重写和隐藏父类方法重写父类中的方法隐藏父类中的方法方法重写和隐藏后的修饰符子类访问父类私有成员使用关键字使用调用父类中重写的方法、访问父类中被隐藏的字段使用调用父类的无参数构造方"}