{"blogid": "122991851", "writerAge": "码龄1年", "writerBlogNum": "61", "writerCollect": "1926", "writerComment": "1002", "writerFan": "2334", "writerGrade": "5级", "writerIntegral": "3254", "writerName": "Hero 2021", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122991851.jpg", "writerRankTotal": "6316", "writerRankWeekly": "5324", "writerThumb": "1014", "writerVisitNum": "56314", "blog_read_count": "2309", "blog_time": "于 2022-03-18 19:09:18 发布", "blog_title": "C++类和对象（中）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">类的6个默认成员函数</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">一、构造函数</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">二、析构函数</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">三、拷贝构造函数</a></p>\n<p id=\"%E5%9B%9B.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">四.赋值运算符的重载</a></p>\n<p id=\"4.1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.1运算符重载</a></p>\n<p id=\"4.2%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">4.2赋值运算符的重载</a></p>\n<p id=\"%E4%BA%94%E3%80%81const%E6%88%90%E5%91%98-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81const%E6%88%90%E5%91%98\">五、const成员</a></p>\n<p id=\"5.1%20const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#5.1%20const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">5.1 const修饰类的成员函数</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BB%A5%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BB%A5%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD\">六、取地址以及const取地址操作符重载</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">类的6个默认成员函数</h1>\n<blockquote>\n<div>\n<span style=\"color:#777777;\">  如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情况下，都会自动生成下面6</span>\n<span style=\"color:#777777;\">个默认成员函数</span>\n</div>\n</blockquote>\n<pre><code class=\"language-cpp\">class Date {}; //空类\n</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"392\" src=\"..\\..\\static\\image\\e0dc7a880350474d870a38e42d779c2d.png\" width=\"1098\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong>注意：</strong></span>这是6个特殊的成员函数</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">一、构造函数</h1>\n<p>概念：构造函数虽然名字叫做构造，但是它<span style=\"color:#fe2c24;\"><strong>并不是开空间创造对象，而是初始化对象</strong></span></p>\n<p><span style=\"color:#fe2c24;\">特征</span>如下：</p>\n<blockquote>\n<p>1、函数名和类名相同</p>\n<p>2、无返回值，并不是void</p>\n<p>3、对象实例化的时候自动调用对应的构造函数</p>\n<p>4、构造函数可以构成重载</p>\n</blockquote>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate()//1、无参构造函数\n\t{\n\t\t_year = 2000;\n\t\t_mouth = 2;\n\t\t_day = 5;\n\t}\n\tDate(int year, int mouth,int day)//2、带参构造函数（可以是缺省的参数）\n\t{\n\t\t_year = year;\n\t\t_mouth = mouth;\n\t\t_day = day;\n\t}\n//以上两个函数名字相同，但是参数不同，构成了函数重载\n\nprivate:\n\tint _year;\n\tint _mouth;\n\tint _day;\n};\nint main()\n{\n\tDate d1;//这里就是具体的对象实例化\n\tDate d2(2022,2,12);\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p><strong>5、tips：C++把我们的类型分为了两类</strong></p>\n<p>第一类<strong>内置类型：</strong>int/double/指针类型/内置类型数组等</p>\n<p>第二类<strong>自定义类型：</strong>struct/class定义的类型</p>\n<p><span style=\"color:#fe2c24;\">特殊的处理规则：</span></p>\n<p>①我们不写编译器默认生成的构造函数，对于内置类型不做处理</p>\n<p>②对于自定义类型的成员变量，会去调用它的默认构造函数（就是不用参数就可以调用的成员函数）进行初始化</p>\n<p>③如果没有默认构造函数，编译器就会报错</p>\n<p>默认构造函数有三类（不用参数就可以调用）：全缺省的，无参的，我们不写编译器默认生成的</p>\n</blockquote>\n<p>举例说明：</p>\n<pre><code class=\"language-cpp\">//A类\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcout &lt;&lt; \"调用A()\" &lt;&lt; endl;\n\t\t_a = 0;\n\t}\n\t//如果是下面的带参的函数，就不是默认构造函数，编译器就会报错\n\t/*A(int a)\n\t{\n\t\tcout &lt;&lt; \"调用A()\" &lt;&lt; endl;\n\t\t_a = 0;\n\t}*/\nprivate:\n\tint _a;\n};\n\nclass Date\n{\npublic:\n\t//这里不写\nprivate:\n\tint _year;\n\tint _mouth;\n\tint _day;\n\tA _aa;//这里对于自定义类型，会去调用A类型的默认构造函数\n};\nint main()\n{\n\tDate d1;\n\treturn 0;\n}</code></pre>\n<p>运行结果： </p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"114\" src=\"..\\..\\static\\image\\491ef97c5f134e3f931b4d9335fca8ff.png\" width=\"500\"/></p>\n<p>说明：对于内置类型不做处理，对于自定义类型A里面_aa成员变量，回去调用A类的默认构造函数，如果没有默认构造函数就会报错</p>\n<p>打开监视窗口观察：</p>\n<p><img alt=\"\" height=\"341\" src=\"..\\..\\static\\image\\8c5325c4c2214cf2850367aaf66a85d1.png\" width=\"1096\"/></p>\n<blockquote>\n<p>6、如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义，编译器就不再生成</p>\n</blockquote>\n<p>例如： </p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t//这里我们不手动写，编译器会默认生成构造函数帮我们完成初始化操作\nprivate:\n\tint _year;\n\tint _mouth;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\treturn 0;\n}</code></pre>\n<p>我们此时打开监视窗口，可以观察到初始化给对象的是随机值，这也印证了我们上面的结论：</p>\n<p><img alt=\"\" height=\"355\" src=\"..\\..\\static\\image\\c41f04147ee84152bd3c7f3b84f2b174.png\" width=\"988\"/></p>\n<p>需要注意：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate()//1、无参构造函数\n\t{\n\t\t_year = 2000;\n\t\t_mouth = 2;\n\t\t_day = 5;\n\t}\n\tDate(int year=2000, int mouth=2, int day=5)//2、带参构造函数\n\t{\n\t\t_year = year;\n\t\t_mouth = mouth;\n\t\t_day = day;\n\t}\n\nprivate:\n\tint _year;\n\tint _mouth;\n\tint _day;\n};\nint main()\n{\n\tDate d1;//这里就会报错\n\t//1、语法上无参和全缺省的可以同时存在\n\t//2、但是如果存在无参调用，就会存在歧义（编译器报错）\n\tDate d2(2022, 2, 12);\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">二、析构函数</h1>\n<p>概念：与构造函数功能相反，析构函数不是完成对象的销毁，局部的对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成对象中一些资源的清理工作。</p>\n<p>例如：我们动态内存开辟的一些指针，我们需要对其进行释放，这就叫做资源的清理工作</p>\n<p><span style=\"color:#fe2c24;\">特征</span>：</p>\n<blockquote>\n<p>1、析构函数名个类名相同，且在前加个 ~</p>\n<p>2、无参数，无返回值</p>\n<p>3、一个类有且只有一个析构函数，若没有显式定义，系统会<span style=\"color:#fe2c24;\">自动生成</span>默认的析构函数</p>\n<p>4、对象生命周期结束时，C++编译系统会自动调用析构函数</p>\n</blockquote>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t~Date()\n\t{//Date类没有资源需要清理，所以Date不实现析构函数也是可以的\n\t\tcout &lt;&lt; \"调用 ~Date()\" &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _mouth;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\treturn 0;\n}</code></pre>\n<p>但是我们遇到某些情况下是需要资源清理的：（例如<span style=\"color:#fe2c24;\">malloc的资源是需要处理的</span>）</p>\n<pre><code class=\"language-cpp\">class stack\n{\npublic:\n\tstack(int capacity = 4)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\tif (_a == nullptr)\n\t\t{\n\t\t\tcout &lt;&lt; \"malloc fail\" &lt;&lt; endl;\n\t\t\texit(-1);\n\t\t}\n\t}\n\t~stack()\n\t{\n\t\tfree(_a);\n\t\t_a = nullptr;\n        _top = _capacity = 0;\n\t}\nprivate:\n\tint* _a;\n\tsize_t _top;\n\tsize_t _capacity;\n\t\n};\nint main()\n{\n\tstack s1;\n\tstack s2(10);\n\treturn 0;\n}</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\900a85c2531d4b0393d00fad1a7148e6.png\" width=\"600\"/></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">5、tips：</span></p>\n<p>如果我们不写，默认生成的析构函数和构造函数类似</p>\n<p>①对于内置类型的成员变量，不做处理</p>\n<p>②对于自定义类型的成员变量，会去调用它的析构函数</p>\n</blockquote>\n<p>我们这里举一个题，用两个栈实现队列，其中默认生成的构造和析构函数就会去调用它的构造和析构：</p>\n<pre><code class=\"language-cpp\">class stack\n{\npublic:\n\tstack(int capacity = 4)\n\t{\n\t\t_a = (int*)malloc(sizeof(int) * capacity);\n\t\tif (_a == nullptr)\n\t\t{\n\t\t\tcout &lt;&lt; \"malloc fail\" &lt;&lt; endl;\n\t\t\texit(-1);\n\t\t}\n\t}\n\t~stack()\n\t{\n\t\tfree(_a);\n\t\t_a = nullptr;\n\t\t_top = _capacity = 0;\n\t}\nprivate:\n\tint* _a;\n\tsize_t _top;\n\tsize_t _capacity;\n\t\n};\n\n//两个栈实现一个队列\nclass MyQueue\n{\npublic:\n\t// 默认生成构造函数和析构函数会对自定义类型成员调用他的构造和析构\n\tvoid push(int x)\n\t{}\nprivate:\n\tstack pushST;\n\tstack popST;\n};\nint main()\n{\n\tMyQueue q;\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">三、拷贝构造函数</h1>\n<p>概念：顾名思义，就是拷贝赋值一个和自己一模一样的对象出来。拷贝构造函数<strong>只有单个形参</strong>，改形参是<strong>对本类类型对象的引用（一般常用const修饰）</strong>，<strong>在用已存在的类类型对象创建新对象时，由编译器自动调用。</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nclass Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)// 构造函数\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tDate(const Date&amp; d)// 拷贝构造函数,\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1(2000, 1, 1);\n\tDate d2(d1); // 用已存在的对象d1创建对象d2\n//用一个同类型对象初始化就是拷贝构造，将d1的内容复制给d2\n\n\treturn 0;\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\">特征</span>：</p>\n<blockquote>\n<p>1、拷贝构造函数是<span style=\"color:#fe2c24;\">构造函数的一个重载形式</span></p>\n<p>2、拷贝构造的函数<span style=\"color:#fe2c24;\">参数只有一个</span>，并且<span style=\"color:#fe2c24;\">必须使用引用传参</span>，使用传值的方式会引发无穷递归调用</p>\n</blockquote>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tDate(const Date&amp; d)\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\n\t~Date()\n\t{\n\t\tcout &lt;&lt; \"~Date()\" &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\tDate d2(d1);\n\t//将d1的内容复制给d2\n\t//用同一个类型的对象去初始化，就是拷贝构造\n\treturn 0;\n}</code></pre>\n<p>为什么这里是引用传参？</p>\n<p>date就是d1的别名，避免传值时的拷贝引发无限递归</p>\n<p><img alt=\"\" height=\"542\" src=\"..\\..\\static\\image\\d62c361de51043d4928848e32836b635.png\" width=\"1200\"/></p>\n<p>为什么这里建议加const？</p>\n<p>这里是想复制一个与原对象一样的对象出来，我们是想保持原对象的内容不改变所以让原对象具有const常属性</p>\n<blockquote>\n<p>3、如果没有显式定义，系统生成默认的拷贝构造函数</p>\n<p>默认生成的拷贝构造函数：</p>\n<p>1）内置类型的成员变量：会完成按字节序的拷贝（浅拷贝）</p>\n<p>2）自定义类型的成员变量：会调用它的拷贝构造函数</p>\n</blockquote>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\t//我们这里不写拷贝构造函数，编译器会自动生成\n\t~Date()\n\t{\n\t\tcout &lt;&lt; \"~Date()\" &lt;&lt; endl;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1;\n\tDate d2(d1);\n\t//将d1的内容复制给d2\n\treturn 0;\n}</code></pre>\n<p>打开监视窗口观察两个对象：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\078cb35a9fb549a599cc21624ea01297.png\" width=\"600\"/></p>\n<p>可以发现发生了浅拷贝（值拷贝），拷贝出了一个内容完全相同的d2。</p>\n<p>我们自己这里并没有定义拷贝构造函数，但是编译器自动生成的拷贝构造函数还是完成了对象的拷贝任务。</p>\n<blockquote>\n<p>4、编译器自动生成的拷贝构造函数不能完成深拷贝</p>\n</blockquote>\n<p>有些时候，我们不写，编译器自动生成的拷贝构造函数就足够用了，但是编译器自动生成的拷贝构造函数不能完成深拷贝，<span style=\"color:#fe2c24;\">举个例子，当我们需要拷贝构造一个栈出来时，对于默认生成的拷贝构造函数就不能用</span></p>\n<pre><code class=\"language-cpp\">class Stack\n{\npublic:\n\tStack(int capacity = 4)\n\t{\n\t\t_ps = (int*)malloc(sizeof(int)* capacity);\n\t\t_size = 0;\n\t\t_capacity = capacity;\n\t}\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _ps &lt;&lt; endl;// 打印栈空间地址\n\t}\nprivate:\n\tint* _ps;\n\tint _size;\n\tint _capacity;\n};\nint main()\n{\n\tStack stack1;\n\tstack1.Print();// 打印stack1栈空间的地址\n\tStack stack2(stack1);// 用已存在的对象stack1创建对象stack2\n\tstack2.Print();// 打印s2栈空间的地址\n\treturn 0;\n}\n</code></pre>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\55723f57aafd464eb8a3f6528d18d82e.png\" width=\"600\"/></p>\n<p>解析：如果我们的拷贝构造还是按字节序的浅拷贝，拷贝出来就会将开辟栈1的地址复制给栈2，这样两个指针就会指向堆区的同一块区域，<span style=\"color:#fe2c24;\"><strong>这样的话就用出现两个栈同时操作会相互影响，当stack2析构完后，stack1也对同一块区域析构，这是不允许的，会导致程序崩溃</strong></span>。正确的是，我们自己写栈的拷贝构造，当程序运行结束，stack2栈将先被析构，此时那块栈空间被释放，然后stack1栈也要被析构，再次对那一块空间进行释放。</p>\n<h1 id=\"%E5%9B%9B.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">四.赋值运算符的重载</h1>\n<h2 id=\"4.1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.1运算符重载</h2>\n<p>默认C++是不支持自定义类型对象使用运算符的，为了让他们可以运算（比大小之类的），提出来运算符重载，运算符重载是<strong><span style=\"color:#fe2c24;\">具有特殊函数名</span></strong>的函数，其目的就是让自定义类型可以像内置类型一样可以直接使用运算符进行操作</p>\n<p><span style=\"color:#fe2c24;\">特征</span>：</p>\n<blockquote>\n<p style=\"margin-left:.0001pt;text-align:justify;\">1、具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">2、函数名字为：关键字<strong>operator后面接需要重载的运算符符号</strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">3、函数原型：<strong>返回值类型 operator操作符(参数列表)</strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">4、参数：操作符有几个操作数，它就有几个参数</p>\n</blockquote>\n<p><span style=\"color:#fe2c24;\">注意</span>：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">1）不能通过连接其他符号来创建新的操作符：比如operator@</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">2）重载操作符必须有一个类类型或者枚举类型的操作数</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">3）用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">4）.* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">我们要实现运算符重载，我们首先来举例看看全局的 operator&gt;</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nclass Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n//private:     //这里需要放开成员变量，会破坏程序的封装性\n\tint _year;\n\tint _month;\n\tint _day;\n};\nbool operator&gt;(const Date&amp; d1, const Date&amp; d2)\n{\n\tif (d1._year &gt; d2._year)\n\t\treturn true;\n\telse if (d1._year == d2._year &amp;&amp; d1._month &gt; d2._month)\n\t\treturn true;\n\telse if (d1._year == d2._year &amp;&amp; d1._month == d2._month &amp;&amp; d1._day &gt; d2._day)\n\t\treturn  true;\n\telse\n\t\treturn false;\n}\n\nint main()\n{\n\tDate d1(2022,2,1);\n\tDate d2(d1);\n\tDate d3(2000, 1, 1);\n\t\n\tcout &lt;&lt;(d1 &gt; d3 )&lt;&lt; endl;\n\tcout &lt;&lt; (operator&gt;(d1,d3)) &lt;&lt; endl;\n\t//将d1的内容复制给d2\n\treturn 0;\n}</code></pre>\n<p>这里会发现运算符重载成全局的就需要成员变量公有的，那么就会破坏程序的封装性了。</p>\n<p>其实我们可以将重载写在类里面：</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n//重载成员函数\nclass Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tbool operator&gt;(const Date&amp; d)//成员函数默认有一个隐藏的this指针\n\t{\n\t\tif (_year &gt; d._year)\n\t\t\treturn true;\n\t\telse if (_year == d._year &amp;&amp; _month &gt; d._month)\n\t\t\treturn true;\n\t\telse if (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day)\n\t\t\treturn  true;\n\t\telse\n\t\t\treturn false;\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1(2022, 2, 1);\n\tDate d2(d1);\n\tDate d3(2000, 1, 1);\n\tcout &lt;&lt; (d1&gt;d3) &lt;&lt; endl;//这样写会被编译器转化为下面这行\n\tcout&lt;&lt; d1.operator&gt;(d3)&lt;&lt;endl;\n\treturn 0;\n}</code></pre>\n<p>成员函数就会有一个隐藏的this指针</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"350\" src=\"..\\..\\static\\image\\261975cc7fb34e708da0ae9085e88d9d.png\" width=\"500\"/></p>\n<h2 id=\"4.2%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD\">4.2赋值运算符的重载</h2>\n<p>我们知道：</p>\n<p>一个已经存在的对象去初始化一个马上创建市级的对象——拷贝构造</p>\n<p>两个已经存在的对象，之间进行赋值操作——赋值拷贝</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\tDate&amp; operator=(const Date&amp; d)//成员函数默认有一个隐藏的this指针，加const保持赋值的那个对象不变，具有常属性\n\t{\n\t\tif (this != &amp;d)//预防自己给自己拷贝，没有这个必要\n\t\t{\n\t\t\t_year = d._year;\n\t\t\t_month = d._month;\n\t\t\t_day = d._day;\n\t\t}\n\t\treturn *this;//引用返回，减少值拷贝\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\tDate d1(2022, 2, 1);\n\tDate d2(d1);\n\tDate d3(2000, 1, 1);\n\n\td1 = d3;\n//将d3的内容拷贝给d1，将d1的内容给覆盖了\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#fe2c24;\">赋值运算符主要特点</span>：</p>\n<p><strong>1、参数类型为引用，并且用const修饰</strong></p>\n<p><img alt=\"\" height=\"384\" src=\"..\\..\\static\\image\\f4785c8625884d0daa51b0b2b831b97f.png\" width=\"1200\"/></p>\n<p> 右操作数是已经存在的对象了，我们一般不改变它，所以加个const修饰</p>\n<p><strong>2、使用引用返回，为了减少多次拷贝</strong></p>\n<p>我们若是d2=d1，这样赋值，完全没有必要有返回值，但是若是连续赋值d3=d2=d1，返回给d2的值要拷贝一份，再赋值给d3，这样最后再拷贝一份返回调用，这样形成了多重拷贝，为了避免不必要的拷贝我们使用引用返回</p>\n<p><strong>3、检测是否自己给自己赋值</strong></p>\n<p>若是出现d1=d1这种没有不要的赋值，我们可以避免不必要赋值操作</p>\n<p><strong>4、return *this</strong></p>\n<p>出了作用域*this还存在，*this就是d对象（对象并未销毁），用引用返回减少拷贝</p>\n<p><strong>5、一个类中如果没有显示定义赋值运算符重载，编译器会默认生成一个，会完成按对象的字节序拷贝 </strong></p>\n<p>编译器默认生成赋值重载，根拷贝构造函数做的事情类似</p>\n<p>1）对于内置类型，会完成按字节序的浅拷贝</p>\n<p>2）对于自定义类型，会去调用它自己的运算符重载</p>\n<h1 id=\"%E4%BA%94%E3%80%81const%E6%88%90%E5%91%98\">五、const成员</h1>\n<h2 id=\"5.1%20const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">5.1 const修饰类的成员函数</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改</p>\n<pre><code class=\"language-cpp\">class Date\n{ \npublic :\n void Display ()\n {\n cout&lt;&lt;\"Display ()\" &lt;&lt;endl;\n cout&lt;&lt;\"year:\" &lt;&lt;_year&lt;&lt; endl;\n cout&lt;&lt;\"month:\" &lt;&lt;_month&lt;&lt; endl;\n cout&lt;&lt;\"day:\" &lt;&lt;_day&lt;&lt; endl&lt;&lt;endl ;\n }\n void Display () const\n {\n cout&lt;&lt;\"Display () const\" &lt;&lt;endl;\n cout&lt;&lt;\"year:\" &lt;&lt;_year&lt;&lt; endl;\n cout&lt;&lt;\"month:\" &lt;&lt;_month&lt;&lt; endl;\n cout&lt;&lt;\"day:\" &lt;&lt;_day&lt;&lt; endl&lt;&lt;endl;\n }\nprivate :\n int _year ; // 年\n int _month ; // 月\n int _day ; // 日\n};\nvoid Test ()\n{\n Date d1 ;//普通对象\n d1.Display ();\n \n const Date d2;//const修饰对象\n d2.Display ();\n}</code></pre>\n<p><img alt=\"\" height=\"454\" src=\"..\\..\\static\\image\\bf0c35dae84a45e3924add7fbc0106ae.png\" width=\"929\"/></p>\n<p><span style=\"color:#fe2c24;\">结论</span>：成员函数加const是好的，建议能加的都加上。这样普通对象和const修饰的对象都可以调用，但是如果要修改成员变量的成员函数是不能加const的</p>\n<h1 id=\"%E5%85%AD%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BB%A5%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD\">六、取地址以及const取地址操作符重载</h1>\n<p>这两个默认成员函数一般不用重新定义，编译器默认会生成</p>\n<pre><code class=\"language-cpp\">class Date\n{ \npublic :\n Date* operator&amp;()\n {\n return this ;\n }\n \n const Date* operator&amp;()const\n {\n return this ;\n }\nprivate :\n int _year ; // 年\n int _month ; // 月\n int _day ; // 日\n};</code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\">这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容！</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">谢谢观看！</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-03-18 19:09:18", "summary": "目录类的个默认成员函数一、构造函数二、析构函数三、拷贝构造函数四赋值运算符的重载运算符重载赋值运算符的重载五、成员修饰类的成员函数六、取地址以及取地址操作符重载类的个默认成员函数如果一个类中什么成员都"}