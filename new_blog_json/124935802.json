{"blogid": "124935802", "writerAge": "码龄9年", "writerBlogNum": "31", "writerCollect": "2147", "writerComment": "84", "writerFan": "97", "writerGrade": "4级", "writerIntegral": "1271", "writerName": "倔强的不服", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124935802.jpg", "writerRankTotal": "16845", "writerRankWeekly": "21569", "writerThumb": "428", "writerVisitNum": "155152", "blog_read_count": "4604", "blog_time": "已于 2022-07-04 10:47:46 修改", "blog_title": "史上最全ThreadLocal 详解（二）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>ThreadLocal 内存泄露的原因及处理方式</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81ThreadLocal%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81ThreadLocal%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86\">1、ThreadLocal 使用原理</a></p>\n<p id=\"2%E3%80%81ThreadLocal%20%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0-toc\" style=\"margin-left:0px;\"><a href=\"#2%E3%80%81ThreadLocal%20%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0\">2、ThreadLocal 内存泄露的原因</a></p>\n<p id=\"3%E3%80%81%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%B0%86key%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%BA%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#3%E3%80%81%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%B0%86key%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%BA%E5%BC%95%E7%94%A8\">3、 为什么不将key设置为强引用</a></p>\n<p id=\"3.1%20%E3%80%81key%20%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20%E3%80%81key%20%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8\">3.1 、key 如果是强引用</a></p>\n<p id=\"3.2%E3%80%81key%20%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%E3%80%81key%20%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8\">3.2、key 如果是强引用</a></p>\n<p id=\"3.3%C2%A0%C2%A0%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%20key%20%E8%A6%81%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3.3%C2%A0%C2%A0%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%20key%20%E8%A6%81%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8\">3.3  那么为什么 key 要用弱引用</a></p>\n<p id=\"3.4%20%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8ThreadLocal-toc\" style=\"margin-left:40px;\"><a href=\"#3.4%20%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8ThreadLocal\">3.4 如何正确的使用ThreadLocal</a></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"1%E3%80%81ThreadLocal%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86\"><a href=\"#1%E3%80%81ThreadLocal%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%862%E3%80%81ThreadLocal%20%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A03%E3%80%81ThreadLocal%20%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\">1、ThreadLocal 使用原理 </a></h1>\n<p>       前文我们讲过ThreadLocal的主要用途是实现线程间变量的隔离，表面上他们使用的是同一个ThreadLocal， 但是实际上使用的值value却是自己独有的一份。用一图直接表示threadlocal 的使用方式。<br/><img alt=\"\" src=\"..\\..\\static\\image\\e82f2120a5d34632bad3ca46ad7f1eb8.png\"/></p>\n<p style=\"text-align:center;\">图1</p>\n<p>从图中我们可以当线程使用threadlocal 时，<strong><span style=\"color:#fe2c24;\">是将threadlocal当做当前线程thread的属性ThreadLocalMap 中的一个Entry的key值，实际上存放的变量是Entry的value值，我们实际要使用的值是value值。</span></strong><span style=\"color:#0d0016;\">value值为什么不存在并发问题呢，因为它只有一个线程能访问。threadlocal我们可以当做一个索引看待，可以有多个threadlocal 变量，不同的threadlocal对应于不同的value值，他们之间互不影响。</span>ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</p>\n<p></p>\n<h1 id=\"2%E3%80%81ThreadLocal%20%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span style=\"color:#0d0016;\">2、ThreadLocal 内存泄露的原因</span><br/>  </h1>\n<p> Entry将ThreadLocal作为Key，值作为value保存，它继承自WeakReference，注意构造函数里的第一行代码super(k)，这意味着ThreadLocal对象是一个「弱引用」。可以看图1.</p>\n<pre><code class=\"language-java\">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n    Entry(ThreadLocal&lt;?&gt; k, Object v) {\n        super(k);\n        value = v;\n    }\n}</code></pre>\n<p></p>\n<p>主要两个原因<br/> 1 . 没有手动删除这个 Entry<br/> 2 . CurrentThread 当前线程依然运行</p>\n<p>        第一点很好理解，只要在使用完下 ThreadLocal ，调用其 remove 方法删除对应的 Entry ，就能避免内存泄漏。<br/>         第二点稍微复杂一点，由于ThreadLocalMap 是 Thread 的一个属性，被当前线程所引用，所以ThreadLocalMap的生命周期跟 Thread 一样长。如果threadlocal变量被回收，那么当前线程的threadlocal 变量副本指向的就是key=null, 也即entry(null,value),那这个entry对应的value永远无法访问到。实际私用ThreadLocal场景都是采用线程池，而线程池中的线程都是复用的，这样就可能导致非常多的entry(null,value)出现，从而导致内存泄露。<br/> 综上， ThreadLocal 内存泄漏的根源是：<br/><span style=\"color:#fe2c24;\"><strong>    由于ThreadLocalMap 的生命周期跟 Thread 一样长，对于重复利用的线程来说，如果没有手动删除（remove()方法）对应 key 就会导致entry(null，value)的对象越来越多，从而导致内存泄漏．</strong></span></p>\n<p></p>\n<h1 id=\"3%E3%80%81%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%B0%86key%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%BA%E5%BC%95%E7%94%A8\">3、 为什么不将key设置为强引用</h1>\n<h2 id=\"3.1%20%E3%80%81key%20%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8\">3.1 、key 如果是强引用</h2>\n<p>     那么为什么ThreadLocalMap的key要设计成弱引用呢？其实很简单，如果key设计成强引用且没有手动remove()，那么key会和value一样伴随线程的整个生命周期。</p>\n<p>   1、假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了，但是因为threadLocalMap的Entry强引用了threadLocal(key就是threadLocal), 造成ThreadLocal无法被回收。在没有手动删除Entry以及CurrentThread(当前线程)依然运行的前提下, 始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏也就是说: ThreadLocalMap中的key使用了强引用, 是无法完全避免内存泄漏的。请结合图1看。</p>\n<p></p>\n<h2 id=\"3.3%C2%A0%C2%A0%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%20key%20%E8%A6%81%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8\"><strong>3.3  那么为什么 key 要用弱引用</strong></h2>\n<p>     事实上，在 ThreadLocalMap 中的set/getEntry 方法中，会对 key 为 null（也即是 ThreadLocal 为 null ）进行判断，如果为 null 的话，那么会把 value 置为 null 的．这就意味着使用threadLocal , <strong><span style=\"color:#fe2c24;\">CurrentThread 依然运行的前提下．就算忘记调用 remove 方法，弱引用比强引用可以多一层保障：弱引用的 ThreadLocal 会被回收．对应value在下一次 ThreadLocaI 调用 get()/set()/remove() 中的任一方法的时候会被清除，从而避免内存泄漏．</span></strong></p>\n<p><br/>  </p>\n<h2 id=\"3.4%20%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8ThreadLocal\">3.4 如何正确的使用ThreadLocal</h2>\n<p></p>\n<p> 1、将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露</p>\n<p><br/>  2、每次使用完ThreadLocal，都调用它的remove()方法，清除数据。<br/>  </p>\n<h2></h2>\n<p></p>\n<h2></h2>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-04 10:47:46", "summary": "内存泄露的原因及处理方式目录、使用原理、内存泄露的原因、为什么不将设置为强引用、如果是强引用、如果是强引用那么为什么要用弱引用如何正确的使用、使用原理前文我们讲过的主要用途是实现线程间变量的隔离，表面"}