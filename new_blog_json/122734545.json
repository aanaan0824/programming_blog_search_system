{"blogid": "122734545", "writerAge": "码龄4年", "writerBlogNum": "107", "writerCollect": "127", "writerComment": "12", "writerFan": "57", "writerGrade": "4级", "writerIntegral": "1135", "writerName": "Yfzm_c", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122734545.jpg", "writerRankTotal": "122431", "writerRankWeekly": "283427", "writerThumb": "29", "writerVisitNum": "52257", "blog_read_count": "2484", "blog_time": "于 2022-01-28 22:19:50 发布", "blog_title": "Unity项目优化", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" height=\"106\" src=\"..\\..\\static\\image\\b7284885df484a1dbb146b8e490cb945.png\" width=\"594\"/></p>\n<p> </p>\n<p><img alt=\"\" height=\"257\" src=\"..\\..\\static\\image\\b103f2e689db46ce8baaf901afd3300f.png\" width=\"426\"/></p>\n<p> </p>\n<p></p>\n<p><img alt=\"\" height=\"233\" src=\"..\\..\\static\\image\\ad184a797d954f20870fb059227ebe42.png\" width=\"501\"/></p>\n<p> 特殊文件链接</p>\n<p><a href=\"https://www.xuanyusong.com/archives/3229\" title=\"Unity3D研究院之手游开发中所有特殊的文件夹 | 雨松MOMO程序研究院\">Unity3D研究院之手游开发中所有特殊的文件夹 | 雨松MOMO程序研究院</a></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\1e19a816d7eb410ca56b1ae6e0931f17.png\" width=\"437\"/></p>\n<p>CPU和GPU的分工链接</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/36311174\" title=\"Render - 浅谈 CPU 与 GPU 如何分工？ - 知乎\">Render - 浅谈 CPU 与 GPU 如何分工？ - 知乎</a> </p>\n<p></p>\n<p><img alt=\"\" height=\"155\" src=\"..\\..\\static\\image\\70b497dee8794ba989a2cc1ccaec23e9.png\" width=\"503\"/></p>\n<p> 脚本优化链接</p>\n<p><a href=\"https://blog.csdn.net/penchaoo/article/details/54291529\" title=\"MipMap与LOD是何物？_penchaoo-CSDN博客_mipmaplod偏移怎么调\">MipMap与LOD是何物？_penchaoo-CSDN博客_mipmaplod偏移怎么调</a></p>\n<p></p>\n<p></p>\n<p>知识补充：HZ：赫兹，刷新的频率。</p>\n<p>        比如显卡的赫兹是144，而显示器的帧率是60，那么帧率就会更不上显卡。每两帧渲染cpu的画面在屏幕上只能显示一帧，那么还有一帧的时候显示器就是黑的，只是太快了，看不出来。这时候就需要更好的显示器了。</p>\n<p>        但是一般，我们的手机60Hz就是极限了，再高你的屏幕也看不出来..</p>\n<p>        所以这时候就有垂直同步的概念了：设置一个项，把我们显卡的帧率和显示器的帧率做一个强行的同步（如果HZ不同步的话，画面会有撕裂感的，所以说要开垂直同步）。</p>\n<p></p>\n<p></p>\n<p></p>\n<p>1.Profiler</p>\n<p>在unity的window下面可以打开profiler</p>\n<p>点击运行之后 可以在左边面板选择你要监听的部分（可以看CPU，渲染，物理等等），右边第一个面板可以看到其占用情况的曲线</p>\n<p>下面面板的左边可以看到不同函数，右边使其占用情况。</p>\n<p>（当然了我这个面板选择的是cpu，你也可以选择别的去看看）</p>\n<p><img alt=\"\" height=\"858\" src=\"..\\..\\static\\image\\2583fc7c84844daeb9414de50cc5b7f2.png\" width=\"923\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p>2.Statistics</p>\n<p><img alt=\"\" height=\"286\" src=\"..\\..\\static\\image\\72aaa87af763414ca0918bca586d1c37.png\" width=\"419\"/></p>\n<p> FPS：渲染物体的数量和GPU性能的影响关系，如上图的数据770.0FPS（1.3ms），表示每帧的间隔为1.3ms，770.2帧。</p>\n<p>CPU：占用CPU所用的时间</p>\n<p>GPU：GPU渲染所用的时间</p>\n<p>Batches（批处理）：unity优化的而一种技术，类似于打包。打包的数量。基本上对应于draw call，这个是为了减少draw call的次数。（材质和shader会影响到这个Batches，如果都用同一个材质那么Batches就会变成1）</p>\n<p>Saved by batching：节省的打包的次数。</p>\n<p>Tris：三角形的数量。</p>\n<p>Verts：顶点数（模型的数量）。</p>\n<p>Screen：画面的分辨率。  同一行后面是这个是画面占用的显存的大小。</p>\n<p>SetPass calls：unity中Shader里面调用pass的次数，如果这个越大那么渲染的压力越大</p>\n<p>Shadow casters：影子的计算，比较消耗性能。</p>\n<p>Visible skinned meshes：渲染的皮肤的网格的数量。（有皮肤（蒙皮）的网格）</p>\n<p>Animations：unity中的animations。</p>\n<p>draw call就是CPU调用GPU渲染的次数。</p>\n<p><img alt=\"\" height=\"636\" src=\"..\\..\\static\\image\\6c8bf38cf91540b1913a741038eecc1b.png\" width=\"937\"/></p>\n<p></p>\n<p>如果说drawcall一开始是一个一个调用格子的话，那么Batches批处理就是圈其中几个一起调用</p>\n<p><img alt=\"\" height=\"453\" src=\"..\\..\\static\\image\\864d5094993f4de9ae2d369b7bfa1a79.png\" width=\"630\"/> </p>\n<p>而批处理又有静态批处理（Static），动态批处理等等。有的批处理的要求是要同一种材质。 </p>\n<p></p>\n<p></p>\n<p></p>\n<p><strong>美术资源优化：</strong></p>\n<p>        一、模型</p>\n<p>        1.减少模型中那些没有用的面</p>\n<p>        2.合并模型，合并那些静态的模型和贴图。这样可以减少Draw Call的数量</p>\n<p>        3.LOD：建筑和复杂的物件用LOD模型和远处剔除来减少同屏面数。（比如吃鸡的里面那些树，你远处看看不清，近了才能看清）。</p>\n<p>        可以添加一个LOD Group的组件，但是记住下面Add的模型一定要是该物体的子物体。所以如果你想让他远处变成A，那你就要把A拖进来，变成他的子物体，然后再Add。</p>\n<p>        <img alt=\"\" height=\"524\" src=\"..\\..\\static\\image\\73e7d4dc073e449a9a261fbbfd4b5b28.png\" width=\"574\"/></p>\n<p> </p>\n<p></p>\n<p>        4.模型的重复利用</p>\n<p>        5.地形优化</p>\n<p>        </p>\n<p>        二、材质</p>\n<p>        1.贴图大小</p>\n<p>        2.资源重复利用</p>\n<p>        3.小物件的贴图合并  （单个物品的贴图最好是一张，最多不易超过3张，相同贴图的材质球统一）</p>\n<p>        4.少用透明贴图，因为非常消耗GPU资源</p>\n<p>        5.minimap，跟LOD的效果差不多。节省GPU的消耗，但是会增加存储空间的大小。</p>\n<p>        6.小场景可以使用PBR材质，用了OBR就一定要用实时灯光才有效果。大场景尽量避免使用PBR材质，大场景可以用烘焙光影。</p>\n<p>        7.贴图压缩，对贴图进行PVRT（ios）或者ETC（Android）格式的压缩可以减少大量的内存消耗</p>\n<p></p>\n<p>        三、灯光</p>\n<p>        1、灯光的数量:室外开放式大场景建议只用一盏平行光。室内场景可适当多一点，室内环境可以用reflection probe来加强反射效果。</p>\n<p>        2、场景烘焙:大场景和比较复杂的室内场景要避免实时灯光的使用。利用UNITY的烘焙系统把光影烘焙成贴图来实现光影效果。烘培贴图本身是一个浩大的工程，大场景的烘培可以选择性的去烘焙。UNITY里自动分UV功能不好控制，所以一般在max\\Maya里分好第2套UV，也可以直接在max\\Maya里烘焙好lightmap导入到unity里。</p>\n<p>        3.Unity提供了混合模式灯光，所以我们可以用混合灯光来实现LIGHTMAP与实时灯光结合。既:一个大场景中，大件如建筑、地形占据画面较大的物件烘焙lightmap，小物件繁多，占据画面的面积很小可以不用烘焙，把灯光设置为mixed模式.</p>\n<p></p>\n<p>        四、其他</p>\n<p>        1.摄像机上少用镜头效果，要有选择性的使用。</p>\n<p>        2.特殊的shader慎用</p>\n<p>        </p>\n<p> </p>\n<p>=========================================================================</p>\n<p></p>\n<p><strong>遮挡剔除：</strong></p>\n<p><strong>效果</strong>：可以看到随着摄像机视野的不断往前，被挡住的部分就直接被剔除了。</p>\n<p>对于大场景非常好用。</p>\n<p><img alt=\"\" height=\"853\" src=\"..\\..\\static\\image\\3ed417a0f69543208eba62ac1b511bc5.png\" width=\"1125\"/></p>\n<p> </p>\n<p></p>\n<p><img alt=\"\" height=\"890\" src=\"..\\..\\static\\image\\66e5893cbbba4f24b266348f90402307.png\" width=\"1200\"/></p>\n<p> </p>\n<p></p>\n<p><strong>实现方法：</strong></p>\n<p>        1.选中你要遮挡剔除得物体，然后选择Occludee Static</p>\n<p><img alt=\"\" height=\"265\" src=\"..\\..\\static\\image\\64265c6d46584b4391f59fe89ce562bd.png\" width=\"567\"/></p>\n<p>         </p>\n<p>2.选中挡住剔除物的物体，然后设置为Occluder Static </p>\n<p><img alt=\"\" height=\"313\" src=\"..\\..\\static\\image\\511cbc8a1383412181813b553c716647.png\" width=\"593\"/></p>\n<p></p>\n<p>3.打开window下的Occlusion Culling，然后点击bake烘焙。</p>\n<p>4.选择隐藏模式，不要选Edit模式。（选了Edit模式你就看不见效果了(●'◡'●)</p>\n<p><img alt=\"\" height=\"267\" src=\"..\\..\\static\\image\\d8509106f7324d94981f286bea7d5ffc.png\" width=\"595\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n<p>=========================================================================</p>\n<p></p>\n<p><strong>光照烘焙</strong></p>\n<p>1.把光的Model设置成Baked</p>\n<p><img alt=\"\" height=\"256\" src=\"..\\..\\static\\image\\5e06074710d04aa49f0a5c23b2f5a19e.png\" width=\"589\"/></p>\n<p></p>\n<p>2.选中物体，将其勾选上Lightmap Static</p>\n<p><img alt=\"\" height=\"275\" src=\"..\\..\\static\\image\\629e569a71be4a1bb0255ac3248e017d.png\" width=\"583\"/></p>\n<p> </p>\n<p>3.在Window下的lighting下的settings下面去自动烘焙或者手动烘焙</p>\n<p><img alt=\"\" height=\"403\" src=\"..\\..\\static\\image\\e53b1adafd45454bb1d3e348a221d5f0.png\" width=\"400\"/></p>\n<p> </p>\n<p>4.效果对比</p>\n<p>左边为我们烘焙的静态效果，右边为原来的动态光。</p>\n<p>可以发现左边烘焙出来的效果更加好，但是不能移动物体（或者场景）了，如果移动的话，就会发现光影效果都是贴图，很假（就暴露了哈哈哈哈哈 </p>\n<p><img alt=\"\" height=\"618\" src=\"..\\..\\static\\image\\7bc7cc0994d043c19fe5a3ded9f09831.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>=========================================================================<strong>合并mesh</strong></p>\n<p>效果</p>\n<p>首先可以看到将所有物体合成了同一个物体，然后对应Statistics下面的话</p>\n<p>1.Saved by batching由原先的114变成了0，因为原来由很多物体，然后批处理可以节约很多，但是现在变成了一个物体，所以没有节约的，就是单纯的对这个物体操作。</p>\n<p>2.Shadow casters由原来的39变成了现在的1，因为原来是由很多物体叠加出来的，所以会有很多的shadow阴影，但是现在只有当前一个物体了，合并了，所有只有1。</p>\n<p><img alt=\"\" height=\"774\" src=\"..\\..\\static\\image\\02eea1735b984748923c42ba045dbe47.png\" width=\"1071\"/></p>\n<p></p>\n<p></p>\n<p>实现方法：</p>\n<p>1.首先将所有要合并的对象放在一个对象的子集下面</p>\n<p><img alt=\"\" height=\"374\" src=\"..\\..\\static\\image\\9b135aafd80a4eab910869f15095326a.png\" width=\"278\"/></p>\n<p> </p>\n<p>2.添加Mesh Conbine脚本，并且设置一个皮肤材质M，有个IsHideChild可以看效果。</p>\n<p>Mesh Conbine.cs：</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MeshCombiner : MonoBehaviour {\n    public Material m;\n    public bool isHideChild;\n\tvoid Start () {\n        Combine();\n        HideChild();\n\n    }\n\n\n\n    void Combine()\n    {\n        MeshFilter[] meshs = GetComponentsInChildren&lt;MeshFilter&gt;();\n\n        CombineInstance[] combiners = new CombineInstance[meshs.Length];\n\n        for (int i = 0; i &lt; meshs.Length; i++)\n        {\n            combiners[i].mesh = meshs[i].sharedMesh;\n            combiners[i].transform = meshs[i].transform.localToWorldMatrix;\n\n\n        }\n\n        Mesh target = new Mesh();\n        target.CombineMeshes(combiners);\n\n        //设置材质\n        GetComponent&lt;MeshFilter&gt;().sharedMesh = target;\n        GetComponent&lt;Renderer&gt;().material = m;\n    }\n    /// &lt;summary&gt;\n    /// 隐藏子对象\n    /// &lt;/summary&gt;\n    private void HideChild()\n    {\n        if (isHideChild)\n        {\n            var list = GetComponentsInChildren&lt;Renderer&gt;();\n            foreach (var item in list)\n            {\n                if (GetComponent&lt;Renderer&gt;() != item)\n                {\n                    item.enabled = false;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>3.添加Mesh Filter和MeshRenderer</p>\n<p><img alt=\"\" height=\"345\" src=\"..\\..\\static\\image\\40e7e654cf5440ffa1648055c44e3db9.png\" width=\"564\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n<p>=========================================================================</p>\n<p><strong>对象池</strong></p>\n<p>ObjectPool.cs:</p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class ObjectPool : MonoBehaviour {\n\n    public int poolCount = 30;\n\n    public GameObject objPf;\n\n    private List&lt;GameObject&gt; objList = new List&lt;GameObject&gt;();\n    private void Start()\n    {\n        InitPool();\n    }\n    void InitPool()\n    {\n        for(int i = 0; i &lt; poolCount; i++)\n        {\n            GameObject go = GameObject.Instantiate(objPf);\n            objList.Add(go);\n            go.SetActive(false);\n            go.transform.parent = this.transform;\n        }\n    }\n\n    public GameObject GetObj()\n    {\n        foreach(GameObject go in objList)\n        {\n            if (go.activeInHierarchy == false)\n            {\n                go.SetActive(true);\n                return go;\n            }\n        }\n        return null;\n    }\n\n}\n</code></pre>\n<p></p>\n<p></p>\n<p>=========================================================================</p>\n<p>关于脚本的性能优化：附上链接</p>\n<p><a href=\"https://wuzhiwei.net/unity_script_optimization/\" title=\"Unity性能优化 – 脚本篇 | Tim's Blog\">Unity性能优化 – 脚本篇 | Tim's Blog</a></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-01-28 22:19:50", "summary": "特殊文件链接研究院之手游开发中所有特殊的文件夹雨松程序研究院研究院之手游开发中所有特殊的文件夹雨松程序研究院和的分工链接浅谈与如何分工？知乎浅谈与如何分工？知乎脚本优化链接与是何物？博客偏移怎么调与是"}