{"blogid": "126137912", "writerAge": "码龄2年", "writerBlogNum": "32", "writerCollect": "166", "writerComment": "128", "writerFan": "126", "writerGrade": "3级", "writerIntegral": "727", "writerName": "恒者走天下", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126137912.jpg", "writerRankTotal": "24030", "writerRankWeekly": "2486", "writerThumb": "191", "writerVisitNum": "44982", "blog_read_count": "1080", "blog_time": "已于 2022-08-14 22:14:54 修改", "blog_title": "读《MySQL是怎样运行的》笔记记录", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_5\">前言</a></li><li><a href=\"#1MySQL_9\">第1章：初始MySQL</a></li><li><ul><li><ul><li><a href=\"#_11\">客户端与服务器连接的过程</a></li><li><ul><li><a href=\"#TCPIP_12\">TCP/IP</a></li><li><a href=\"#_18\">命名管道和内存共享</a></li></ul>\n</li><li><a href=\"#_23\">服务器处理客户端请求</a></li><li><ul><li><a href=\"#_30\">连接管理</a></li><li><a href=\"#_33\">解析与优化</a></li><li><ul><li><ul><li><a href=\"#_34\">查询缓存</a></li><li><a href=\"#_39\">语法解析</a></li><li><a href=\"#_42\">查询优化</a></li><li><a href=\"#_45\">存储引擎</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#2MySQL_48\">第2章：MySQL的启动配置</a></li><li><a href=\"#3_51\">第3章：字符集和比较规则</a></li><li><ul><li><ul><li><a href=\"#_52\">字符集简介</a></li><li><a href=\"#_55\">一些重要的字符集</a></li><li><a href=\"#MySQL_61\">MySQL中支持的字符集和比较规则</a></li><li><ul><li><ul><li><ul><li><a href=\"#_70\">字符集的查看</a></li><li><a href=\"#_74\">比较规则的查看</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_89\">字符集和比较规则的应用</a></li><li><ul><li><ul><li><ul><li><a href=\"#_90\">各级别的字符集和比较规则</a></li><li><a href=\"#_145\">客户端和服务器通信过程中使用的字符集</a></li><li><a href=\"#_222\">比较规则的应用</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#4_InnoDB_226\">第4章： InnoDB记录存储结构</a></li><li><ul><li><ul><li><a href=\"#InnoDB_229\">InnoDB页简介</a></li><li><a href=\"#InnoDB_232\">InnoDB行格式</a></li><li><ul><li><ul><li><ul><li><a href=\"#COMPACT__244\">COMPACT 行格式</a></li><li><a href=\"#PEDUNDANT_271\">PEDUNDANT行格式</a></li><li><a href=\"#_284\">溢出列</a></li><li><a href=\"#DYNAMICCOMPRESSED_291\">DYNAMIC行格式和COMPRESSED行格式</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#5InnoDB_295\">第5章：InnoDB数据页结构</a></li><li><ul><li><ul><li><a href=\"#_296\">不同类型页简介</a></li><li><a href=\"#_299\">数据页的结构</a></li><li><a href=\"#_306\">记录在页中的存储</a></li><li><ul><li><ul><li><ul><li><a href=\"#_310\">记录头信息</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#Page_Directory_336\">Page Directory（页目录）</a></li><li><a href=\"#File_Trailer_343\">File Trailer（文件尾部）</a></li></ul>\n</li></ul>\n</li><li><a href=\"#6B_347\">第6章：B+树索引</a></li><li><ul><li><ul><li><a href=\"#_350\">索引</a></li><li><a href=\"#InnoDBB_375\">InnoDB中B+树索引的注意事项</a></li><li><a href=\"#MyISAM_388\">MyISAM中的索引解决方案</a></li><li><a href=\"#MySQL_397\">MySQL中创建和删除索引的语句</a></li></ul>\n</li></ul>\n</li><li><a href=\"#7B_400\">第7章：B+树索引的使用</a></li><li><ul><li><ul><li><a href=\"#_401\">索引的代价</a></li><li><a href=\"#B_410\">应用B+树索引</a></li><li><ul><li><ul><li><ul><li><a href=\"#_411\">扫描区间和边界条件</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_429\">索引用于排序</a></li><li><a href=\"#_454\">索引用于分组</a></li><li><a href=\"#_457\">回表的代价</a></li><li><a href=\"#_461\">更好地创建和使用索引</a></li></ul>\n</li></ul>\n</li><li><a href=\"#8MySQL_484\">第8章：MySQL的数据目录</a></li><li><ul><li><ul><li><a href=\"#_485\">数据库和文件系统的关系</a></li><li><a href=\"#MySQL_488\">MySQL数据目录</a></li><li><ul><li><ul><li><ul><li><a href=\"#MySQL_489\">如何确定MySQL中的数据目录</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_496\">数据目录的结构</a></li><li><ul><li><ul><li><ul><li><a href=\"#_497\">数据库在文件系统中的表示</a></li><li><a href=\"#_500\">表在文件系统中的表示</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#9InnoDB_517\">第9章：InnoDB的表空间</a></li><li><ul><li><ul><li><a href=\"#_520\">独立表空间结构</a></li><li><ul><li><ul><li><ul><li><a href=\"#_521\">区的概念</a></li><li><a href=\"#_531\">段的概念</a></li><li><a href=\"#_541\">区的分类</a></li><li><a href=\"#_560\">段的结构</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_562\">系统表空间</a></li></ul>\n</li></ul>\n</li><li><a href=\"#10_567\">第10章：单表访问方法</a></li><li><ul><li><ul><li><a href=\"#_568\">访问方法的概念</a></li><li><a href=\"#const_570\">const</a></li><li><a href=\"#ref_573\">ref</a></li><li><a href=\"#ref_or_null_577\">ref_or_null</a></li><li><a href=\"#range_580\">range</a></li><li><a href=\"#index_583\">index</a></li><li><a href=\"#all_586\">all</a></li><li><a href=\"#_589\">注意事项</a></li><li><ul><li><ul><li><ul><li><a href=\"#_590\">索引合并</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#11_617\">第11章：连接的原理</a></li><li><ul><li><ul><li><a href=\"#_618\">连接简介</a></li><li><ul><li><ul><li><ul><li><a href=\"#_620\">连接过程简介</a></li><li><a href=\"#_623\">内连接和外连接</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_636\">连接的原理</a></li><li><ul><li><ul><li><ul><li><a href=\"#_637\">嵌套循环连接</a></li><li><a href=\"#_640\">使用索引加快连接速度</a></li><li><a href=\"#_644\">基于块的嵌套循环连接</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#12_647\">第12章：基于成本的优化</a></li><li><ul><li><ul><li><a href=\"#_653\">单表查询的成本</a></li><li><ul><li><ul><li><ul><li><a href=\"#_654\">基于成本的优化步骤</a></li><li><a href=\"#_660\">基于索引统计数据的成本计算</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_665\">连接查询的成本</a></li><li><ul><li><ul><li><ul><li><a href=\"#_666\">条件过滤</a></li><li><a href=\"#_672\">两表连接的成本分析</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#13InnoDB_678\">第13章：InnoDB统计数据是如何收集的</a></li><li><ul><li><ul><li><a href=\"#_679\">统计数据的存储方式</a></li><li><a href=\"#_683\">基于磁盘的永久性统计数据</a></li></ul>\n</li></ul>\n</li><li><a href=\"#14_688\">第14章：基于规则的优化（内含子查询优化二三事）</a></li><li><ul><li><ul><li><a href=\"#_689\">条件化简</a></li><li><ul><li><ul><li><ul><li><a href=\"#_690\">移除不必要的括号</a></li><li><a href=\"#_702\">常量传递</a></li><li><a href=\"#_713\">移除没用的条件</a></li><li><a href=\"#_726\">表达式计算</a></li><li><a href=\"#havingwhere_730\">having子句和where子句的合并</a></li><li><a href=\"#_733\">常量表检测</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_742\">外连接消除</a></li><li><a href=\"#_745\">子查询优化</a></li><li><ul><li><ul><li><ul><li><a href=\"#_746\">子查询语法注意事项</a></li><li><a href=\"#MySQL_750\">子查询在MySQL中是怎么执行的</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#15explain_768\">第15章：explain详解</a></li><li><ul><li><ul><li><a href=\"#_770\">执行计划输出中各个列详解</a></li><li><ul><li><ul><li><ul><li><a href=\"#table_771\">table</a></li><li><a href=\"#id_774\">id</a></li><li><a href=\"#select_type_780\">select_type</a></li><li><a href=\"#type_782\">type</a></li><li><a href=\"#possible_keys_key_785\">possible_keys 和key</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#16optimizer_trace_788\">第16章：optimizer trace的神奇功效</a></li><li><ul><li><ul><li><a href=\"#optimizer__trace_789\">optimizer trace简介</a></li></ul>\n</li></ul>\n</li><li><a href=\"#17InnoDBBuffer_Pool_792\">第17章：InnoDB的Buffer Pool</a></li><li><ul><li><ul><li><a href=\"#InnoDBBuffer_Pool_793\">InnoDB的Buffer Pool</a></li><li><ul><li><ul><li><ul><li><a href=\"#Buffer_Pool_794\">Buffer Pool的概念</a></li><li><a href=\"#Buffer_Pool_797\">Buffer Pool内部组成</a></li><li><a href=\"#free_800\">free链表的管理</a></li><li><a href=\"#_804\">缓冲页的哈希处理</a></li><li><a href=\"#flush_809\">flush链表的管理</a></li><li><a href=\"#LRU_814\">LRU链表的管理</a></li><li><a href=\"#_841\">刷新脏页到磁盘</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#18_846\">第18章：事务简介</a></li><li><ul><li><ul><li><a href=\"#_847\">事务的起源</a></li><li><ul><li><ul><li><ul><li><a href=\"#_848\">原子性</a></li><li><a href=\"#_849\">隔离性</a></li><li><a href=\"#_852\">一致性</a></li><li><a href=\"#_855\">持久性</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_857\">事务的概念</a></li><li><a href=\"#MySQL_861\">MySQL中事务的语法</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_5\"></a>前言</h1>\n<p>深入学习一门技术，亦可以达到面试等级，最好的方法无不是在现有的知识基础上，再去阅读相关书籍，到达更深层的理解。本文内容，便是在以前学习MySQL的基础上，再去读《MySQL是怎样运行的》一书，并通过阅读本书，做的笔记记录。<strong>（注意本文只是针对自己在现有的基础上，对自己内容知识的补充，如果想详细了解内容，建议还是自己看书）</strong></p>\n<h1><a id=\"1MySQL_9\"></a>第1章：初始MySQL</h1>\n<h3><a id=\"_11\"></a>客户端与服务器连接的过程</h3>\n<h4><a id=\"TCPIP_12\"></a>TCP/IP</h4>\n<p>MySQL采用TCP作为服务器和客户端之间的网络通信协议。并且MySQL服务器会默认监听3306端口。如果3306端口被占用或者想自定义监听的端口，在启动服务器程序时，输入如下命令即可<br/> 这样就把监听端口改成了3307</p>\n<pre><code class=\"prism language-bash\">mysqld -P3307\n</code></pre>\n<h4><a id=\"_18\"></a>命名管道和内存共享</h4>\n<p>如果是在Windows电脑下，并且是在自己电脑上联系使用MySQL，那么可以考虑在客户端进程和服务器进程之间使用命名管道或共享内存进行通信。不过需要参数设置。<br/> 对于使用命名管道进行进程通信：需要在启动服务器程序的命令中加上–enable-named-pipe参数，然后在启动客户端程序的命令中加上–pipe或者–protocol=pipe参数。<br/> 对于使用共享内存进行进程通信：需要在启动服务器程序的命令中加上–shared-memory参数。也可以在启动客户端程序的命令中加上–protocol=memory参数来显示指定使用共享内存进行通信。</p>\n<h3><a id=\"_23\"></a>服务器处理客户端请求</h3>\n<p>客户端向服务器发送请求（sql语句）的执行过程：<br/> 以比较复杂的查询请求为例：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\0ecc9e11caea4ba9ad8e40f206c5ec4b.jpeg\"/></p>\n<p>服务器在处理客户端请求时，大概需要部分：连接管理、解析与优化、存储引擎。</p>\n<h4><a id=\"_30\"></a>连接管理</h4>\n<p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理与这个客户端的交互；当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁，<strong>而是把它缓存起来</strong>，在另一个新客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就不用频繁地创建和销毁线程，从而节省开销。</p>\n<h4><a id=\"_33\"></a>解析与优化</h4>\n<h6><a id=\"_34\"></a>查询缓存</h6>\n<p>MySQL服务器程序处理查询请求的过程中会把刚刚处理过的查询请求和结果缓存起来。<strong>如果下一次有同样的请求过来，直接从缓存中查找结果就好了，就不用再去底层的表中查找了</strong>，这个查询缓存可以在不同的客户端之间共享。但如果这两个查询请求有任何字符上的不同（例如，空格、注释、大小写），都会导致缓存不会命中。并且如果查询请求中包含某些系统函数、用户自定义变量和函数、系统表，则这个请求就不会被缓存。<br/> <strong>对于缓存失效问题：</strong> MySQL的缓存系统会检测涉及的每张表，只要该表的结构或者数据被修改，比如对该表使用了insert、update、delete、truncate table、alter table、drop table或者drop database语句，则与该表有关的所有查询缓存都将变为无效并从查询缓存中删除。<br/> <strong>系统性能：</strong> 查询缓存有时可以提升性能，但不得不因维护这块缓存而造成一些开销。比如每次都要去查询缓存中检索，查询请求处理完后需要更新询缓存，需要维护该查询缓存对应的内存区域等。从MySQL 5.7.20开始，不推荐使用查询缓存，在MySQL 8.0直接将其删除。</p>\n<h6><a id=\"_39\"></a>语法解析</h6>\n<p>客户端程序发送过来的请求只是一段文本，所以MySQL服务器程序首先要对这段文本进行分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的一些数据结构上。</p>\n<h6><a id=\"_42\"></a>查询优化</h6>\n<p>MySQL的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等一堆东西。</p>\n<h6><a id=\"_45\"></a>存储引擎</h6>\n<p>MySQL服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中。在物理上如何表示记录，怎么从表中读取数据，以及怎么把数据写入具体的物理存储器上，都是存储引擎负责的事情。</p>\n<h1><a id=\"2MySQL_48\"></a>第2章：MySQL的启动配置</h1>\n<p>这章主要讲述关于MySQL的配置，感觉没什么可以做笔记的，毕竟在配置中哪里遇到问题，就在网上搜哪里就行了啊</p>\n<h1><a id=\"3_51\"></a>第3章：字符集和比较规则</h1>\n<h3><a id=\"_52\"></a>字符集简介</h3>\n<p>计算机存储字符串实际上存储的是二进制，需要建立字符与二进制数据的映射关系。将字符映射成二进制数据的过程叫做<strong>编码</strong>，将二进制数据映射到字符的过程叫做<strong>解码</strong>。</p>\n<h3><a id=\"_55\"></a>一些重要的字符集</h3>\n<p>ASCII字符集：共收录128个字符，使用一个字节来进行编码。<br/> GB2312字符集：收录了汉字等一些字母，同时又兼任ASCII字符集。在编码中，如果该字符在ASCII字符集中，则采用一字节编码，否则采用两字节编码。<br/> GBK字符集：只是对GB2312在收录范围上进行了扩充。<br/> UTF-8字符集：兼任ASCII字符集。采用变长编码方式，编码一个字符时需要<strong>使用1~4字节。</strong></p>\n<h3><a id=\"MySQL_61\"></a>MySQL中支持的字符集和比较规则</h3>\n<p>在MySQL中，字符集表示一个字符所用的最大字节长度<br/> 在MySQL的设计中：<br/> utf8mb3：“阉割”过的UTF-8字符集，使用1~3字节表示字符。<br/> 在MySQL中utf8是utf8mb3的别名，所以在MySQL中提到utf8时，就意味着使用1~3字节来表示一个字符。</p>\n<p>utf8mb4:正宗的UTF-8字符集，使用1~4字节表示字符。<br/> 比如：存储一些emoji表情，使用4字节编码一个字符，就使用utf8mb4。</p>\n<h6><a id=\"_70\"></a>字符集的查看</h6>\n<p>请看下图MySQL中常见的字符集：<br/> Maxlen表示这种字符最多需要几个字节来表示一个字符<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\8b03514e5c594fa3b86ec1878d3fccfa.png\"/></p>\n<h6><a id=\"_74\"></a>比较规则的查看</h6>\n<p>通过命令：</p>\n<pre><code class=\"prism language-bash\">show collation <span class=\"token punctuation\">[</span>like 匹配模式<span class=\"token punctuation\">]</span>\n</code></pre>\n<p>通过命令查看utf8字符集的比较规则<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2f4a4c4c249a49ceb8ab1e573aa92cfc.png\"/><br/> 规则命名的含义：<br/> 1.比较规则的名称以与其关联的字符集的名称开头；比如上面的查询结果，比较规则的名称都是以utf8开头。<br/> 2.后面紧跟着该比较规则所应应用的语言。比如，utf8_polish_ci表示波兰语的比较规则；utf8_general_ci是一种通用的比较规则<br/> 3.名称后缀意味着该比较规则是否区分语言中的重音、大小写等。如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\14802596cc2b489c94d0e15d58acbdda.png\"/><br/> 比如比较规则utf8_general_ci是以ci结尾的，说明不区分大小写。</p>\n<h3><a id=\"_89\"></a>字符集和比较规则的应用</h3>\n<h6><a id=\"_90\"></a>各级别的字符集和比较规则</h6>\n<p>MySQL的4个级别的字符集和比较规则：服务器级别、数据库级别、表级别、列级别<br/> 服务器级别：<br/> 提供了两个系统变量来表示服务器级别的字符集和比较规则。<br/> 如图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9ea19483abeb49b7950b20089760d1d4.png\"/><br/> 通过命令查看：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'character_set_server'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'collation_server'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>数据库级别：<br/> 创建和修改数据库时可以指定数据库的字符集和比较规则：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">database</span> 数据库名\n\t\t<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span> 字符集名称<span class=\"token punctuation\">]</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">collate</span>  比较规则名称<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">alter</span> <span class=\"token keyword\">database</span>  数据库名\n\t\t<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span> 字符集名称<span class=\"token punctuation\">]</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">collate</span> 比较规则名称<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果查看当前数据库使用的字符集和比较规则，可以查看两个系统变量：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d14dbf5c15fd4cef9ce667419fe40b6d.png\"/><br/> 注意不能通过修改这两个变量的值来改变当前数据库的字符集和比较规则。</p>\n<p>表级别：<br/> 同样也可以在创建和修改表的时候指定表的字符集和比较规则。</p>\n<p>列级别：<br/> 对于存储字符串的列，同一个表中不同的列也可以有不同的字符集和比较规则，可以在创建和修改列的时候指定该列的字符集和比较规则。语法如下：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> 表名<span class=\"token punctuation\">(</span>\n\t列名  字符串类型  <span class=\"token punctuation\">[</span><span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span> 字符集名称<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">collate</span> 比较规则名称<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\t其他列…\n\t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">alter</span> <span class=\"token keyword\">table</span> 表名 <span class=\"token keyword\">modify</span> 列名  字符串类型 <span class=\"token punctuation\">[</span><span class=\"token keyword\">character</span> <span class=\"token keyword\">set</span> 字符集名称<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">collate</span> 比较规则名称<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>注意：在修改列的字符集时需要注意 <strong>，如果列中存储的数据不能用修改后的字符集进行表示，则会发送错误</strong> 。比如，列最初使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii就会出错，因为ascii字符集并不能表示汉字字符。</p>\n<p>仅修改字符集或仅修改比较规则：<br/> 由于字符集和比较规则之间相互关联，因此如果只修改字符集，比较规则也会跟着变化；如果只修改比较规则，字符集也会跟着变化。具体规则如下：<br/> <strong>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则；<br/> 只修改比较规则，则字符集将变为修改后的比较规则对应的字符集</strong></p>\n<p>各级别字符集和比较规则小结：<br/> 如果创建或修改列时没有显式指定字符集和比较规则，则该<strong>列默认使用表</strong>的字符集和比较规则；<br/> 如果创建表时没有显式指定字符集和比较规则，则该<strong>表默认使用数据库</strong>的字符集和比较规则；<br/> 如果创建数据库时没有显式指定字符集和比较规则，则该<strong>数据库默认使用服务器</strong>的字符集和比较规则；<br/> 知道了字符集和比较规则，可以清楚的知道存储数据所占用的存储空间的大小。</p>\n<h6><a id=\"_145\"></a>客户端和服务器通信过程中使用的字符集</h6>\n<p>1.编码和解码使用的字符集不一致<br/> 字符串在计算机上体现就是一个字节序列。如果使用不同的字符集去解码这个字节序列，可能会出现乱码。<br/> 比如用utf-8编码，用gbk解码可能会出现乱码的错误。</p>\n<p>2.字符集转换的概念<br/> 比如通过utf-8发来的数据，用utf-8解码，然后用按照gbk编码。把这个字符串从utf-8字符集转换为gbk字符集的过程就叫做字符集的转换。</p>\n<p>3.MySQL中的字符集转换过程<br/> MySQL客户端与服务器进行通信的过程中事先规定好的数据格式称为MySQL通信协议。</p>\n<p>客户端发送请求：<br/> 一般情况下，客户端编码请求字符串使用的字符集与操作系统当前使用的字符集一致。<br/> 在启动客户端程序时，可以通过命令来选择编码格式：</p>\n<pre><code class=\"prism language-sql\">mysql <span class=\"token comment\">--default-character-set=utf8</span>\n</code></pre>\n<p>此时客户端将会以utf-8字符集对请求的字符串进行编码</p>\n<p>服务器接收请求：<br/> 每个客户端与服务器建立连接后，服务器都会为该客户端维护一个单独的<strong>character_set_client变量</strong>（session级别），并且服务器把接收到的字节序看做是使用系统变量character_set_client代表的字符集进行编码的字节序列。<br/> 客户端在编码请求字符串时实际使用的字符集与服务器在收到一个字节序列后认为该字节序列所采用的的编码字符集，是两个独立的字符集。</p>\n<p>服务器处理请求：<br/> 服务器会将请求的字节序列当作采用character_set_client对应的字符集进行编码的字节序列，但在真<strong>正处理请求时</strong>又会将其转换为使用session级别的系统变量character_set_connection对应的字符集进行编码的字节序列。<br/> 这样做的作用：<br/> 看下面的SQL语句</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fb65014dc5ae4eaa9195fd5ca4499b2a.png\"/><br/> 我们从结果中可以看到，这两个字符是相等的（因为我们此时的character_set_connection是utf8，对应的比较规则是utf8_general_ci不区分大小写）</p>\n<p>我们将其比较规则修改一下，再进行比较。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">set</span> collation_connection<span class=\"token operator\">=</span>utf8_bin<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\03699605d92e475f977e5fb3352e600a.png\"/><br/> 这个时候我们再看，这两个字符便不相等了，我们修改的是<strong>character_set_connection</strong>的比较规则，发现它起作用了！<br/> 与character_set_connection配套的还有个系统变量collation_connection这个系统变量表示这些字符串应该应用使用哪种比较规则。<br/> 另一种情况：请求中的字符串和某个列进行比较<br/> 看代码，创建个表</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">temp</span><span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> c <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">)</span><span class=\"token keyword\">engine</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">charset</span><span class=\"token operator\">=</span>gbk<span class=\"token punctuation\">;</span>\n\nmysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> <span class=\"token keyword\">temp</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'我'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>我们创建了如下表，只有一行数据。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d6c3ed3326324a638f5aa4e5a60fee00.png\"/><br/> 接下来，我们要执行一条语句（铺垫一下，此时我们的<strong>character_set_connection</strong>为utf8，比较规则<strong>collation_connection</strong>为utf8_bin，而对应的列，我们在建表时已经规定它的编码方式了，为gbk和gbk_chinses_ci）</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">temp</span> <span class=\"token keyword\">where</span> c <span class=\"token operator\">=</span> <span class=\"token string\">'我'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>服务器在进行字节序列处理的时候，根据的是character_set_connection的字符集进行编码，也就是utf8，比较规则collation_connection为utf8_bin，而此时语句中我的编码便与之对应<br/> 另一方面，表的列中的我，采用的则是gbk编码和gbk_chinses_ci比较规则，那么这种情况下，该如何比较呢？<br/> 我们执行看看结果！<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ec63140d95864fbe88e204683ac590c3.png\"/><br/> 在这种情况下啊，<strong>列的字符集和排列规则的优先级更高</strong>。因此需要将请求中的字符串 ‘我’ 先从gbk字符集转换为utf-8字符集，然后再使用列c的比较规则utf8_general_ci进行比较。</p>\n<p>服务器生成响应：<br/> 服务器将数据发送给客户端的编码格式，依据character_set_results</p>\n<p>看下这三个系统变量的作用<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ff73151b29504e52a6c993ec93249772.png\"/><br/> 这三个都是session级别。每个客户端与服务器建立连接后，服务器都会为这个连接维护这3个变量。<br/> 在服务器收到客户端连接时，服务器会将character_set_client 、character_set_connection和character_set_results这三个系统变量的值初始化为客户端的默认字符集。<br/> 如图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\77a86dda583146b38fe15a9dee6ba682.png\"/></p>\n<h6><a id=\"_222\"></a>比较规则的应用</h6>\n<p>比较规则通常用来比较字符串的大小以及对某些字符串进行排序</p>\n<h1><a id=\"4_InnoDB_226\"></a>第4章： InnoDB记录存储结构</h1>\n<p>MySQL服务器中负责对表中的数据进行读取和写入工作的部分是存储引擎，真实的数据在不同存储引擎中的存放格式一般也是不同的。InnoDB是MySQL默认的存储引擎，也是我们最常用的存储引擎。</p>\n<h3><a id=\"InnoDB_229\"></a>InnoDB页简介</h3>\n<p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，但真正处理数据的过程发送在内存中，所以需要把磁盘中的数据加载到内存中。InnoDB采取的方式是，将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。InnoDB中的页大小一般为<strong>16KB</strong>，就是说一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。（在服务器运行过程中不可以更改页面大小）</p>\n<h3><a id=\"InnoDB_232\"></a>InnoDB行格式</h3>\n<p>以记录为单位向表中插入数据，这些记录在磁盘上的存放形式也被称为行格式或者记录格式。<br/> InnoDB存储引擎一共4种不同类型的行格式：COMPACT 、REDUNDANT、 DYNAMIC、 COMPRESSED<br/> 创建或修改表的语句中指定记录所使用的行格式：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> 表名 <span class=\"token punctuation\">(</span>列的信息<span class=\"token punctuation\">)</span> row_format<span class=\"token operator\">=</span>行格式名称<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">alter</span> <span class=\"token keyword\">table</span> 表名 row_format<span class=\"token operator\">=</span>行格式名称<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>下面来介绍下这四种行格式</p>\n<h6><a id=\"COMPACT__244\"></a>COMPACT 行格式</h6>\n<p>看下行的结构：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3708700030ab488aa5b3e1dbcab15cec.png\"/><br/> 一条完整的记录被分为记录的额外信息和记录的真实数据。</p>\n<p>1.记录的额外信息</p>\n<ul><li>变长字段长度列表：所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表**（逆序存放，并且只存储值为非NULL的列的内容长度，不存储值为NULL的列的内容长度）**<br/> 对于变长字段长度列表中的字节数是用1字节还是用2字节表示，InnoDB的判断规则：<br/> 假设某个字符集中最多需要<strong>W</strong>字节来表示一个字符（比如，utf8字符集中的W是3，ASCII字符集中的W就是1）；对于变长类型把varchar（<strong>M</strong>），这种类型表示能存储最多M个字符**（注意是字符不是字节）<strong>，所以这种类型表示的字符串最多占用的</strong>字节数是M<em>W**。假设该变长字段实际存储的字节数是<strong>L</strong>。那么确定是1字节还是2字节表示的规则是：<br/> **如果M</em>W小于等于255，那么使用1字节来表示真实数据占用的字节数。**<br/> <strong>如果M*W大于255，并且L小于等于127，那么使用1字节来表示。</strong><br/> <strong>如果M*W大于255，并且L大于127，那么使用2字节来表示。</strong></li></ul>\n<p>NULL值列表的优化：<br/> 一条记录某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以COMPACT行格式把一条记录中值为NULL的列同一管理起来。</p>\n<p>2.记录的真实数据<br/> MySQL除了自己定义列数据外，还会为每个记录默认地添加一些列（也称为隐藏列）。<br/> 具体如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\cb271727dacf40e79baba1d70751efa5.png\"/><br/> <strong>InnoDB表的主键生成策略：</strong> 优先使用用户<strong>自定义的主键作为主键</strong>；如果用户没有定义主键，则选取<strong>一个不允许存储NULL值的UNIQUE键</strong>作为主键；如果表中连不允许存储NULL值的UNIQUE键都没有定义，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。<br/> InnoDB会为每条记录都添加trx_id和roll_pointer这两个列，但是row_id是可选的（在没有自定义主键以及不允许存储NULL值的UNIQUE键的情况下才会添加该列）</p>\n<ol start=\"3\"><li>char（M）列的存储格式<br/> 对于**char（M）<strong>类型列，当列采用的是定长编码的字符集时，该列占用的字节数</strong> <strong>被加到变长字段长度列表；<strong>而如果采用变长编码的字符集时（如utf8），该列占用的字节数就会被加到变长字段长度列表</strong>。并且采用变长编码字符集的</strong>char（M）**类型的列要求至少占用M字节（真实数据占不够，就用空格填充），比如类型为char（10）的列（utf8编码），该列存储的数据占用的字节长度范围就是10~30字节，即使是空字符串也会占用10字节。 <strong>（目的是：在将来更新该列时，在新值的字节长度大于旧值的字节长度但不大于10个字节时，可以在该记录处直接更新，而不是在存储空间中再重新分配一个新的记录空间，导致原有的记录空间成为所为的碎片化）</strong></li></ol>\n<h6><a id=\"PEDUNDANT_271\"></a>PEDUNDANT行格式</h6>\n<p>REDUNDANT行格式如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\606317d4b3124898a7b5cbe69dc2c2a1.png\"/></p>\n<p>1.字段长度偏移列表<br/> REDUNDANT行格式会把该记录中<strong>所有的列（包括隐藏列）</strong> 的长度信息都按照<strong>逆序存储</strong>到长度偏移列表中，；并且它是采用两个相邻偏移量的差值来计算各个列值的长度</p>\n<p>2.REDUNDANT行格式中NULL值的处理<br/> 将列对应的偏移量值的第一个比特位作为是否为NULL的依据</p>\n<p>3.CHAR(M)列的存储格式<br/> 对于REDUNDANT行格式，不管该列使用的字符集是啥，只要使用CHAR（M）类型，该列的真实数据占用的存储空间大小就是该字符集表示一个字符最多需要的字节数和M乘积。比如，使用utf8字符集的char（10）类型的列，其真实数据占用的存储空间大小始终为30字节。</p>\n<h6><a id=\"_284\"></a>溢出列</h6>\n<p>在COMPACT和REDUNDANT行格式中，对于占用存储空间非常多的列，在记录的真实数据处只会存储该列的一部分数据，而把剩余的数据分散存储在几个其他的页中，然后在记录的真实数据处用20字节存储指向这些页的地址（这20字节还包括分散在其他页面中的数据所占用的字节数），从而可以找到剩余数据所在的页，如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4981cec194734b159c9399cedb0d0d46.png\"/><br/> 对于COMPACT和REDUNDANT行格式，如果某一列中的数据非常多，则在本记录的真实数据处只会存储该列前768字节的数据以及一个指向其他页的地址，然后把剩下的数据存放到其他页中。如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fd2ef615007c4b5f85e27e8f09a99495.png\"/><br/> 如果一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为溢出列。</p>\n<h6><a id=\"DYNAMICCOMPRESSED_291\"></a>DYNAMIC行格式和COMPRESSED行格式</h6>\n<p>这两个行格式不会在记录的真实数据处存储该溢出列真实数据的前768字节，而是把该列的所有真实数据都存储到溢出页中，只在记录真实数据处存储20字节大小的指向溢出页的地址。如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\709a7af3ddb54e669ca2d8e6c64c7674.png\"/></p>\n<h1><a id=\"5InnoDB_295\"></a>第5章：InnoDB数据页结构</h1>\n<h3><a id=\"_296\"></a>不同类型页简介</h3>\n<p>InnoDB为了不同目的而设计了多种不同的类型的页，比如存放表空间头部信息的页、存放Change Buffer信息页、存放INODE的信息页、存放undo日志信息的页，存放表中记录的那种类型页（索引页 或者成为<strong>数据页</strong>）</p>\n<h3><a id=\"_299\"></a>数据页的结构</h3>\n<p>数据页代表的这块16KB大小的存储空间可以划分为多个部分，如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c2ac86b4a98e4d678683567acc7f0169.png\"/><br/> 可以看下每个部分存储什么内容：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\7bb17d0e3500492c9fe88f1f2ba4beb9.png\"/></p>\n<h3><a id=\"_306\"></a>记录在页中的存储</h3>\n<p>自己存储的记录会按照指定的行格式存储到User Records部分。（一开始生成页的时候，其实并没有User Records部分）。插入流程如下：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\63302f0a381b449cbbf108393db1f25c.png\"/></p>\n<h6><a id=\"_310\"></a>记录头信息</h6>\n<p>我们首先看下记录头主要包含了那些信息<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\be4818f4667241a08593cbc6647b6dc5.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\3ac0f934034947579d8474da5cfa4272.png\"/><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fa16e10240cb4bdfb614ce857785751b.png\"/></p>\n<ul><li> <p>deleted_flag<br/> 这个属性用来标记当前记录是否被删除，占用1比特。<br/> 值为1时表示记录被删除了，但还真实的在磁盘上，只打一个删除标记（不在磁盘移除它们的原因是，如果移除还需要在磁盘上重新排列其他的记录，这会带来性能的消耗），放在一个垃圾链表中。</p> </li><li> <p>min_rec_flag<br/> B+树每层非叶子节点中的最小</p> </li><li> <p>heap_no（在分配之后就不会发生改动了，即使之后删除l堆的某条记录，这条被删除记录的heap_no值也仍然保持不变）<br/> 把一条记录（这条记录的deleted_flag可以为1）在堆（把记录一条一条无间排列的结构）中的相对位置称之为heap_no。在页面前边的记录heap_no相对较小，在页面后边的记录heap_no相对较大，每新申请一条记录的存储空间时，该条记录比物理位置在它前边的那条记录的heap_no值大于1。<br/> 虚拟记录：一条代表页面中的最小记录（Infimum记录），另外一条代表页面中最大记录（Supremum记录），分别占据了heap_no的0和1，说明它们在页面中的相对位置最靠前。<br/> <strong>注意：比较记录的大小就是比较主键的大小</strong><br/> 虽然Infimum记录和Supremum记录没有主键值，但是任何用户记录都比Infimum记录大，任何用户记录都比Supremum记录小</p> </li><li> <p>record_type<br/> 这个属性表示当前记录的类型<br/> 一共4种类型的记录，0表示普通记录，1表示B+树非叶节点的目录项记录，2表示Infimum记录，3表示Supremum记录</p> </li><li> <p>next_record<br/> 表示从当前记录的真实数据到下一条记录的真实数据的距离。<br/> 比如，第1条记录的next_record值为32，意味着从第1条记录的真实数据的地址处向后找32字节便是下一条记录的真实数据。（下一条记录指的并不是插入顺序中的下一条记录，而是按照主键值由小到大的顺序排列的下一条记录）<br/> <strong>各条记录按照主键从小到大的顺序形成一个单向链表。</strong><br/> next_record指针指向记录头信息和真实数据之间的位置的原因？原因是这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据，并且还可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，提高高速缓存的命中率。<br/> 当数据页存在多条被删除的记录时，可以使用这些记录的next_record属性将这些被删除的记录组成一个垃圾链表，以备之后重用这部分存储空间</p> </li></ul>\n<h3><a id=\"Page_Directory_336\"></a>Page Directory（页目录）</h3>\n<p>分组中记录的条数规定：对于Infimum记录所在的分组只能有1条记录，Supremum记录所在的分组拥有的记录条数只能在1~8条之间，剩下的分组中记录的条数范围只能是4 ~8条之间。</p>\n<p>在一个数据页中查找指定主键值的记录时，过程分为两步：<br/> 1.通过二分法确定该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的那条记录。<br/> 2.通过记录的next_record属性遍历该槽所在的组中的各个记录。</p>\n<h3><a id=\"File_Trailer_343\"></a>File Trailer（文件尾部）</h3>\n<p>为了检测一个页是否完整（也就是在刷新时有没有发生只刷新了一部分的尴尬情况），设计了一个File Trailer部分。</p>\n<h1><a id=\"6B_347\"></a>第6章：B+树索引</h1>\n<p>各个数据页可以组成一个双向链表，每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表。每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>\n<h3><a id=\"_350\"></a>索引</h3>\n<p>创建索引时，如果添加元素，对页中记录进行增删改操作，可能会做一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的键值必须大于上一个页用户记录的主键值。（页分裂）<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\bd8dc53d22a24f3bbd707b2471afa65f.png\"/><br/> B+树都不会超过4层</p>\n<p>1.聚簇索引<br/> B+树特点：</p>\n<ul><li>记录主键值的大小进行记录和页的排序<br/> 页（包括叶子节点和内节点）<strong>内</strong>的记录按照主键的大小顺序排成一个单向链表。<br/> 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。<br/> 同一层级的页也排成一个双向链表。</li><li>B+树的叶子节点存储的是完整的用户记录（包括隐藏列）</li></ul>\n<p>聚簇索引只能在搜索条件是主键值时才能发挥作用。</p>\n<ol start=\"2\"><li>二级索引（辅助索引）</li></ol>\n<p>以其他列作为搜索条件<br/> 也创建个B+树，但是该B+树叶子节点存储的并不是完成的用户记录，而是该索引列+主键这两个列的值。<br/> 通过该B+树的叶子节点处定位到<strong>第一条</strong>符合条件的那条用户记录，然后需要根据该记录中的主键信息到聚簇索引中查找到完整的用户记录。<strong>这个通过携带主键信息到聚簇索引中重新定位完整的用户记录的过程成为回表</strong><br/> 然后再返回到这棵B+树的叶子节点处，找到刚才定位到的符合条件的那条用户记录，并沿着记录组成的单向链表向后继续搜索其他也满足的记录，每找到一条就继续回表操作，重复这个操作，直到下一条记录不满足为止。</p>\n<ol start=\"3\"><li>联合索引<br/> 本质也是二级索引，先按其中一个排序，这个相同再按另一个排序。</li></ol>\n<h3><a id=\"InnoDBB_375\"></a>InnoDB中B+树索引的注意事项</h3>\n<p>1.根页面万年不动<br/> 一个B+树索引的根节点自创建之日便不会再移动（也就是页号不再改变）</p>\n<p>2.内节点中目录项记录的唯一性<br/> 对与像二级索引那样，索引不唯一，那在插入数据时，如果出现了重复，那该放入那页时懵了。因此二级索引的内节点的目录项内容由三部分构成：<br/> 索引列的值、 主键值、 页号</p>\n<p>所以上面那个问题，就可以先比较该索引，如果相同，再比较主键值</p>\n<p>3.一个页面至少容纳2条记录<br/> 避免B+树的层级增长得过高</p>\n<h3><a id=\"MyISAM_388\"></a>MyISAM中的索引解决方案</h3>\n<p>MyISAM的索引方案是将索引和数据分开存储的。<br/> 1.将表中的记录按照记录的插入顺序单独存储在一个文件中（称之为数据文件）<br/> 2.把索引信息单独存储到另外一个文件（索引文件）<br/> 叶子节点存储的不是完整的用户记录，而是主键值与行号的组合。二级索引</p>\n<p>MyISAM行格式有定长格式、变长格式、变长记录格式等。<br/> 对于变长格式，MyISAM会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量。由此可见，MyISAM的回表操作是十分快速的，，因为它是拿着地址偏移量直接到文件中取数据。</p>\n<h3><a id=\"MySQL_397\"></a>MySQL中创建和删除索引的语句</h3>\n<p>InnoDB和MyISAM会自动为主键或者带有UNIQUE属性的列建立索引。</p>\n<h1><a id=\"7B_400\"></a>第7章：B+树索引的使用</h1>\n<h3><a id=\"_401\"></a>索引的代价</h3>\n<ul><li> <p>空间上的代价<br/> 每建立一个索引，都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页。</p> </li><li> <p>时间上的代价</p> </li></ul>\n<p>存储引擎需要额外的时间进行<strong>页面分裂、页面回收</strong>等操作，以维护节点和记录的排序。并且在执行查询语句前，首先生成执行计划，在生成执行计划时需要计算使用不同索引执行查询时所需的成本，最后选取成本最低的那个索引执行查询</p>\n<h3><a id=\"B_410\"></a>应用B+树索引</h3>\n<h6><a id=\"_411\"></a>扫描区间和边界条件</h6>\n<p>扫描区间：把待扫描记录的值所在的区间成为扫描区间<br/> 边界条件：形成扫描区间的搜索条件（如 id&gt;20 and id &lt;100）<br/> 单点扫描区间：只包含一个值的扫描区间<br/> 范围扫描区间：包含多个值的扫描区间<br/> 在有多个索引的情况下，在使用某个索引执行查询时，关键的问题就是通过搜索条件找出合适的扫描区间，然后再到对应的B+树中扫描区间中的第一条记录。<br/> <strong>需要注意的是：</strong></p>\n<ul><li>IN操作符的语义与若干等值匹配操作符（=）之间用OR连接起来的语义是一样的，都会产生多个单点扫描区间。</li><li>LIKE操作符比较特殊，只有在匹配完整的字符串或者匹配字符串前缀时才产生合适的扫描区间。</li></ul>\n<p>在执行一个查询语句时，首先需要找出所有可用的索引以及使用它们时对应的扫描区间。</p>\n<ol><li>所有搜索条件都可以生成合适的扫描区间的情况</li><li>有的搜索条件不能生成合适的扫描区间的情况</li><li>从复杂的搜索条件中找出扫描区间</li><li>使用联合索引执行查询时对应的扫描区间<br/> 索引下推进行优化</li></ol>\n<h3><a id=\"_429\"></a>索引用于排序</h3>\n<p>在MySQL中，这种在内存或者磁盘中进行排序的方式统称为文件排序。但是，如果order by子句中使用了索引，就有可能省去在内存或磁盘中的排序的步骤。</p>\n<ol><li>使用联合索引进行排序时的注意事项<br/> order by子句后面的列的顺序也必须按照索引列的顺序给出，否则无法使用B+树索引。<br/> 并且当联合索引的索引列左边连续的列为常量时，也可以使用联合索引对右边的列进行排序，如下面的SQL语句：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">//key_part1 key_part2 key_part3为联合索引</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> key_part1<span class=\"token operator\">=</span><span class=\"token string\">'a'</span> <span class=\"token operator\">and</span> key_part2<span class=\"token operator\">=</span><span class=\"token string\">'b'</span> <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> key_part3 <span class=\"token keyword\">limit</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> \n</code></pre>\n<ol start=\"2\"><li>不可以使用索引进行排序的几种情况<br/> （1）asc desc混用<br/> 对于联合索引，要求各个排序列的排序规则是一致的，要么都是按照asc（升序）规则，要么都是按照desc（降序）规则排序。<br/> 对于降序规则排序的方法：<br/> 在查找当前记录的上一条记录时，找到该记录所在组的第一条记录（一直根据记录的next_record属性找下一条记录，直到某条记录的头信息的n_owned属性值不为0，该记录就是本组中的“带头大哥”。然后再从页目录中找到“带头大哥”记录对应的槽的上一个槽，该槽对应记录的下一条记录就是本组中第一条记录），从第一条记录开始遍历该组中的记录，直到找到当前记录的前一条记录。<br/> 对于order by子句中asc、desc混用的情况，MySQL 8.0引入了一种称为Descending Index的特性</li></ol>\n<p>（2）排序列包含非同一个索引的列<br/> 用来排序的多个列不是同一个索引中的，这种情况不能使用索引进行排序。</p>\n<p>（3）排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续<br/> （4）用来形成扫描区间的索引列与排序列不同<br/> （5）排序列不是以单独列名的形式出现在order by子句中<br/> 要想使用索引进行排序操作，必须保证索引列是以单独列名的形式（而不是修饰过的形式）出现。</p>\n<h3><a id=\"_454\"></a>索引用于分组</h3>\n<p>与使用B+树索引进行排序差不多，分组列的顺序也需要与索引列的顺序一致；也可以只使用索引列中左边连续的列进行分组。</p>\n<h3><a id=\"_457\"></a>回表的代价</h3>\n<p>InnoDB中的数据页会被存放到磁盘中的一个或者多个文件中，页面的页号对应着该页在磁盘文件中的偏移量。<br/> 一般情况下，可以给查询语句指定limit子句来限制查询返回的记录数，这可能会让查询优化器倾向于选择使用二级索引+回表的方式进行查询，原因是回表的记录越少，性能提升越高。</p>\n<h3><a id=\"_461\"></a>更好地创建和使用索引</h3>\n<p>（1）只为用于搜索、排序或分组的列创建索引<br/> 只为出现在where子句中的列、连接子句中的连接列，或者出现在order by或group by子句中的列创建索引<br/> （2）考虑索引中不重复值的个数<br/> 在执行查询时，某个扫描区间中包含的二级索引记录数量越多，就会导致回表操作的<strong>代价越大</strong>。在为某个列创建索引时，需要考虑该列中不重复值的个数占全部记录条数的比例。如果比例太低，则说明该列包含过多重复值，那么在通过二级索引+回表的方式执行查询时，就有可能执行太多次回表操作。<br/> （3）索引列的类型尽量小<br/> 数据类型越小，索引占用的存储空间就越小，在一个数据页就可以存放更多的记录，磁盘I/O带来的性能损耗也就越小（一次页面I/O可以将更多的记录加载到内存中），读写效率也就越高<br/> （4）为列前缀建立索引<br/> 即只将字符串的前几个字符存放到索引中，也就是说在二级索引的记录中只保留字符串的前几个字符。但是，只为列前缀建立索引的方式无法支持使用索引进行排序的需求。<br/> （5）覆盖索引<br/> 把索引中已经包含所有需求读取的列的查询方式（如二级索引中包含了主键）称为覆盖索引。排序操作也优先使用覆盖索引查询。<br/> （6）让索引列以列名的形式在搜索条件中单独出现<br/> 如下SQL语句：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> <span class=\"token keyword\">key</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>不会进行简化，而是会用全表扫描的方式进行</p>\n<p>（6）新插入记录时主键大小对效率的影响<br/> 为了避免性能消耗，在插入主键时，最好让它一次递增<br/> （7）冗余和重复索引</p>\n<h1><a id=\"8MySQL_484\"></a>第8章：MySQL的数据目录</h1>\n<h3><a id=\"_485\"></a>数据库和文件系统的关系</h3>\n<p>InnoDB、MyISAM这样的存储引擎都是把表存储在磁盘上，而操作系统又是使用文件系统来管理磁盘。所以，像InnoDB、MyISAM这样的存储引擎都是把数据存储在文件系统上。</p>\n<h3><a id=\"MySQL_488\"></a>MySQL数据目录</h3>\n<h6><a id=\"MySQL_489\"></a>如何确定MySQL中的数据目录</h6>\n<p>可以通过命令查看：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'datadir'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c148d9a471964585a57486b7a73eddc9.png\"/></p>\n<h3><a id=\"_496\"></a>数据目录的结构</h3>\n<h6><a id=\"_497\"></a>数据库在文件系统中的表示</h6>\n<p>每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹</p>\n<h6><a id=\"_500\"></a>表在文件系统中的表示</h6>\n<p>每个表的信息可以分为两种：</p>\n<ol><li>表结构的定义<br/> 描述表结构的文件 表名.frm</li><li>表中的数据</li></ol>\n<ul><li>InnoDB是如何存储表数据的<br/> 表空间：对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间可以被划分为很多个页，表数据就存放在某个表空间下的某些页中<br/> （1）系统表空间<br/> 在一个MySQL服务器中，系统表空间只有一份。从MySQL 5.5.7到MySQL 5.6.5之间的各个版本中，表中的数据都会被默认存储到这个系统表空间。</li></ul>\n<p>（2）独立表空间<br/> 在使用独立表空间来存储表数据时，会在该表所属的数据库对应的子目录下创建一个表示该独立表空间的文件，其文件名和表名相同，如 表名.ibd</p>\n<ul><li>MyISAM是如何存储表数据的<br/> MyISAM中的索引相当于全部都是二级索引，该存储引擎的数据和索引是分开存放的</li></ul>\n<h1><a id=\"9InnoDB_517\"></a>第9章：InnoDB的表空间</h1>\n<p>表空间中的每一个页都对应着一个页号，可以通过这个页号在表空间中快速定位到指定的页面</p>\n<h3><a id=\"_520\"></a>独立表空间结构</h3>\n<h6><a id=\"_521\"></a>区的概念</h6>\n<p>对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。每256个区被划分成一组。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\d0cb0c4864204e25adfad7899e0c22b4.png\"/></p>\n<p>第一个组最开始的3个页面的类型是固定的：<br/> FSP_HDR:这个类型的页面用来登记整个表空间的一些整体属性以及本组所有的区。<br/> IBUF_BITMAP:这个类型的页面用来存储关于change buffer的一些信息。<br/> INODE：这个类型的页面存储了许多成为INODE Entry的数据结构。<br/> 其余各组最开始的2个页面的类型是固定的。</p>\n<h6><a id=\"_531\"></a>段的概念</h6>\n<p>尽量让页面链表中相邻的页的物理位置也相邻，这样在扫描叶子节点中大量的记录时才可以使用顺序I/O。所以引入区的概念，一个区就是在物理位置上连续的64个页（区里页面的页号都是连续的）。<br/> 在表中的数据量很大时，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位进行分配。<br/> 叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段，存放非叶子节点的区的集合也算是一个段。一个索引会生成两个段：一个叶子节点段和一个非叶子节点段。<br/> <strong>对于“以完整的区为单位分配给某个段时，对于数据量较小的表来说太浪费存储空间”这种情况</strong>，提出了碎片区的概念。<br/> 在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用于不同的目的。碎片区直属于表空间，并不属于任何一个段。</p>\n<ul><li>在刚开始向表中插入数据时，段是从某个碎片区以单个页面为单位来分配存储空间的；</li><li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间（原先占用的碎片区页面并不会被复制到新申请的完整的区中）。</li></ul>\n<h6><a id=\"_541\"></a>区的分类</h6>\n<p>空闲的区、有剩余空闲页面的碎片的区、没有剩余空闲页面的碎片的区、附属于某个段的区<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\4479bc82df0f459d9558476e8db6ccef.png\"/><br/> 处于FREE、FREE_FRAG、以及FULL_FRAG这3种状态的区都是独立的，算是直属于表空间；而处于FSEG状态的区是附属于某个段的。</p>\n<p>为了管理这些区，设计XDES Entry的结构对应区的一些属性。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fb235ac1be6d41f98087d3d841c18c94.png\"/></p>\n<ul><li>Sagment ID（8字节）：每一个段都有一个唯一的编号，用ID表示。前提是该区已经被分配给某个段了</li><li>List Node（12字节）：这个部分可以将若干个XDES Entry结构串连成一个链表。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\61150768500344f1ba43fa623b37cf3d.png\"/></li></ul>\n<p>如果我们想定位表空间内的某一个位置，只需指定页号以及该位置在指定页号中的页内偏移量即可。</p>\n<ol><li> <p>XDES Entry链表<br/> 把FREE、FREE_FRAG、FULL_FRAG状态的区分别建立链表</p> </li><li> <p>链表基节点<br/> 为了找到这些链表，设计了名为List Base Node（链表基节点）：包含了链表的头节点和尾节点、以及包含了多少个节点的信息。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fd1feb65bcda42189e07c498d9fc8cf7.png\"/></p> </li></ol>\n<h6><a id=\"_560\"></a>段的结构</h6>\n<h3><a id=\"_562\"></a>系统表空间</h3>\n<p>MySQL进程只有一个系统表空间，系统表空间中需要记录一些与整个系统相关的信息。<br/> InnoDB数据字典<br/> 存储元数据的表</p>\n<h1><a id=\"10_567\"></a>第10章：单表访问方法</h1>\n<h3><a id=\"_568\"></a>访问方法的概念</h3>\n<p>把MySQL执行查询语句的方式称为访问方法或者访问类型。同一个查询语句可以使用多种不同的访问方法来执行。</p>\n<h3><a id=\"const_570\"></a>const</h3>\n<p>通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const（意识是常数级别的，代价是可以忽略的）。不过这种const只能在与一个常数进行等值比较时才有效。</p>\n<h3><a id=\"ref_573\"></a>ref</h3>\n<p>普通二级索引进行等值比较时，单点扫描称为ref。<br/> 在执行key is NULL只能是ref访问方法，而不能是const方法（因为NULL可能会出现很多条）</p>\n<h3><a id=\"ref_or_null_577\"></a>ref_or_null</h3>\n<p>扫描区间为单点扫描和[NULL,NULL]时称为ref_or_null（注意 值为NULL的记录会被放在索引的最左边）</p>\n<h3><a id=\"range_580\"></a>range</h3>\n<p>对扫描区间为若干个单点扫描区间或者范围扫描区间的访问方法称为range</p>\n<h3><a id=\"index_583\"></a>index</h3>\n<p>把这种扫描全部二级索引记录的访问方法称为index访问方法</p>\n<h3><a id=\"all_586\"></a>all</h3>\n<p>全表扫描</p>\n<h3><a id=\"_589\"></a>注意事项</h3>\n<h6><a id=\"_590\"></a>索引合并</h6>\n<p>把使用多个索引来完成一次查询的执行方法称为index merge（索引合并）<br/> 索引合并的方法有下面3种：</p>\n<ol><li>Intersection索引合并<br/> 如下SQL语句：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">//key1  key3均是二级索引</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> key1<span class=\"token operator\">=</span><span class=\"token string\">'a'</span> <span class=\"token operator\">and</span> key3<span class=\"token operator\">=</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>执行方案：同时使用idx_key1和idx_key3进行单点扫描，然后在找出主键值相同的列，再回表。（交集）<br/> <strong>要求获得的记录都是按照主键值排序的</strong><br/> 如果读取的记录不是按照主键值排序的，则不可以使用Intersection索引，比如下面的SQL查询：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> key1<span class=\"token operator\">&gt;</span><span class=\"token string\">'a'</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">key</span><span class=\"token operator\">=</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol start=\"2\"><li>Union索引合并（并集）<br/> 如下SQL语句：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> key1<span class=\"token operator\">=</span><span class=\"token string\">'a'</span>  <span class=\"token operator\">or</span> key3<span class=\"token operator\">=</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>先分别单点扫描，然后根据主键值进行去重，再根据<strong>去重</strong>后的主键值，执行回表（要求必须是按主键值进行排序的）</p>\n<p>3.Sort-Union索引合并</p>\n<h1><a id=\"11_617\"></a>第11章：连接的原理</h1>\n<h3><a id=\"_618\"></a>连接简介</h3>\n<p>连接就是把各个表中的记录都取出来进行依次匹配，并把匹配后的组合发送给客户端。笛卡尔积</p>\n<h6><a id=\"_620\"></a>连接过程简介</h6>\n<p>首先确定第一个需要查询的表（驱动表）进行单表查询；然后根据获取到的记录，都需要到另一张表中查找匹配记录。（注意：每获得一条驱动表记录，就立即到被驱动表中寻找匹配的记录）</p>\n<h6><a id=\"_623\"></a>内连接和外连接</h6>\n<p>内连接：<br/> 若驱动表中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集。</p>\n<p>外连接：<br/> 即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集。<br/> 为了解决有时需要把匹配失败加入结果集，有时不要把匹配失败加入结果集，所以把过滤条件分为了两种：<br/> （1）where子句中的过滤条件<br/> 不论是内连接还是外连接，凡是不符合where子句中过滤条件的记录<strong>都不会被加入到最后的结果集。</strong><br/> （2）on子句中的过滤条件<br/> 如果无法在被驱动表中找到匹配on子句中过滤条件的记录，那么<strong>该驱动表仍然会被加入到结果集中</strong>，对应的被驱动表记录的各个字段使用NULL值填充。<br/> （注意：on子句是专门为“外连接驱动表中的记录在被驱动表找不到匹配记录时是否应该把该驱动表记录加入结果集中”这个场景提出的）</p>\n<h3><a id=\"_636\"></a>连接的原理</h3>\n<h6><a id=\"_637\"></a>嵌套循环连接</h6>\n<p>驱动表只访问一次，但被驱动表却可能访问多次，且访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录；这种连接执行方式称为嵌套循环连接。</p>\n<h6><a id=\"_640\"></a>使用索引加快连接速度</h6>\n<p>建立索引，减小扫描代价。<br/> 建议做好不要使用*作为查询列表，而是把真正用到的列作为查询列表。</p>\n<h6><a id=\"_644\"></a>基于块的嵌套循环连接</h6>\n<p>为了可以在把驱动表中记录加载到内存时，一次性地与驱动表中的多条记录进行匹配，大大减少重复从磁盘上加载被驱动表的代价。所以设计了Join Buffer（连接缓冲区）的概念</p>\n<h1><a id=\"12_647\"></a>第12章：基于成本的优化</h1>\n<p>MySQL中执行成本是由两个方面组成的</p>\n<ul><li>I/O成本：从磁盘到内存的加载过程损耗的时间称为I/O成本。</li><li>CPU成本：读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称为CPU成本。</li></ul>\n<h3><a id=\"_653\"></a>单表查询的成本</h3>\n<h6><a id=\"_654\"></a>基于成本的优化步骤</h6>\n<p>1.根据搜索条件，找出所有可能使用的索引<br/> 2.计算全表扫描的代价<br/> 3.计算使用不同索引执行查询的代价<br/> 4.对比各种执行方案的代价，找出成本最大的那个方案</p>\n<h6><a id=\"_660\"></a>基于索引统计数据的成本计算</h6>\n<p>把通过直接访问索引对应的B+树来计算某个扫描区间内对应的索引记录条数的方式称为 index dive。</p>\n<p>如果通过IN语句生成的单点扫描区间的数量小于200个，将使用index dive来计算各个单点扫描区间对应的记录条数；如果大于或等于200个，就不能使用index dive了，而是要使用索引统计数据来进行估算。（避免单点扫描个数较多，造成性能损失）</p>\n<h3><a id=\"_665\"></a>连接查询的成本</h3>\n<h6><a id=\"_666\"></a>条件过滤</h6>\n<p>把查询驱动表后得到的记录条数称为驱动表的扇出。（驱动表的扇出值越小，对被驱动表的查询次数也就越小，连接查询的总成本也就越低）<br/> 下面两种情况下计算驱动表扇出值时，需要靠猜测：<br/> （1）如果使用全表扫描的方式执行单表查询，那么计算驱动表扇出值时需要猜测满足全部搜索条件的记录到底有多少条<br/> （2）如果使用索引来执行单表查询，那么计算驱动表扇出值时需要猜测除了满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条。</p>\n<h6><a id=\"_672\"></a>两表连接的成本分析</h6>\n<p>在连接查询中“占大头”的其实是驱动表扇出数*单次访问被驱动表的成本，所以优化的重点就是这两点：<br/> （1）尽量减少驱动表的扇出<br/> （2）访问被驱动表的成本要尽量低<br/> 需要尽量在被驱动表的连接列上建立索引，这样就可以使用ref访问方法来降低被驱动表的访问成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降至更低了。</p>\n<h1><a id=\"13InnoDB_678\"></a>第13章：InnoDB统计数据是如何收集的</h1>\n<h3><a id=\"_679\"></a>统计数据的存储方式</h3>\n<p>永久性地存储统计数据：统计数据在磁盘上。<br/> 非永久性地存储统计数据：统计数据存储在内存上。</p>\n<h3><a id=\"_683\"></a>基于磁盘的永久性统计数据</h3>\n<ol><li>n_rows统计项的收集<br/> 为什么是估值？ 计算方法：按照一定算法从聚簇索引中选取几个叶子节点页面，统计每个页面中包含的记录数量，然后计算一个页面中平均包含的记录数量，并将其乘以全部叶子节点的数量，结果就是该表的n_rows值。</li></ol>\n<h1><a id=\"14_688\"></a>第14章：基于规则的优化（内含子查询优化二三事）</h1>\n<h3><a id=\"_689\"></a>条件化简</h3>\n<h6><a id=\"_690\"></a>移除不必要的括号</h6>\n<p>如下面SQL语句：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">,</span>t3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span> t1<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span>t2<span class=\"token punctuation\">.</span>a <span class=\"token operator\">and</span> t2<span class=\"token punctuation\">.</span>b<span class=\"token operator\">=</span>t3<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>优化器会把语句中不必要的括号移除掉，移除后的效果如下所示：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> t1<span class=\"token punctuation\">,</span>t2<span class=\"token punctuation\">,</span>t3 <span class=\"token keyword\">where</span> t1<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span>t2<span class=\"token punctuation\">.</span>a  <span class=\"token operator\">and</span> t2<span class=\"token punctuation\">.</span>b<span class=\"token operator\">=</span>t3<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span>\n</code></pre>\n<h6><a id=\"_702\"></a>常量传递</h6>\n<p>当使用and操作符将这个表达式和其他涉及列a的表达式连接起来时，可以将其他表达式中a的值替换为常量，比如下面这个表达式：</p>\n<pre><code class=\"prism language-sql\">a<span class=\"token operator\">=</span><span class=\"token number\">5</span> <span class=\"token operator\">and</span> b<span class=\"token operator\">&gt;</span>a\n</code></pre>\n<p>就可以被转换为：</p>\n<pre><code class=\"prism language-sql\">a<span class=\"token operator\">=</span><span class=\"token number\">5</span> <span class=\"token operator\">and</span> b<span class=\"token operator\">&gt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h6><a id=\"_713\"></a>移除没用的条件</h6>\n<p>对于一些明显的永远true或者false的表达式，优化器会移除掉它们。<br/> 如下面的表达式：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token punctuation\">(</span>a<span class=\"token operator\">&lt;</span><span class=\"token number\">1</span> <span class=\"token operator\">and</span> b<span class=\"token operator\">=</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">=</span><span class=\"token number\">6</span> <span class=\"token operator\">or</span> <span class=\"token number\">5</span><span class=\"token operator\">!=</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>很明显，b=b这个表达式永远为true，5！=5这个表达式永远为false，所以简化后成了如下：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token punctuation\">(</span>a<span class=\"token operator\">&lt;</span><span class=\"token number\">1</span> <span class=\"token operator\">and</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">=</span><span class=\"token number\">6</span> <span class=\"token operator\">or</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h6><a id=\"_726\"></a>表达式计算</h6>\n<p>如果表达式只包含常量，它的值会被先计算出来，如 a=5+1，会被简化成a=6；<br/> 在搜索条件中，只有搜索列和常数使用某些运算符连接起来，才可能形成合适的范围区间来减少需要扫描的记录数量。所以，最好让索引列以单独的形式出现在搜索条件表达式中。</p>\n<h6><a id=\"havingwhere_730\"></a>having子句和where子句的合并</h6>\n<p>如果查询语句中没有出现诸如sum、max这样的聚集函数以及group by子句，查询优化器就把having子句和where子句合并起来。</p>\n<h6><a id=\"_733\"></a>常量表检测</h6>\n<p>默认下面这两种类型的查询运行的特别快：</p>\n<ul><li> <p>类型1：查询的表中一条记录都没有，或者只有一条记录。</p> </li><li> <p>类型2：使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。<br/> 默认这两种查询方式花费的时间特别少，把通过这两种方式查询的表称为常量表。<br/> 查询优化器在分析一个查询语句时，首先执行常量表查询，然后把查询中涉及该表的条件全部替换成常数，最后再分析其余表的查询成本。</p> </li></ul>\n<h3><a id=\"_742\"></a>外连接消除</h3>\n<p>在外连接查询中，指定的where子句中包含被驱动表中的列不为NULL值的条件称为空值拒绝。在被驱动表的where子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是优化器可以通过评估表的不同连接顺序的成本，选出成本最低的连接顺序来执行查询。</p>\n<h3><a id=\"_745\"></a>子查询优化</h3>\n<h6><a id=\"_746\"></a>子查询语法注意事项</h6>\n<p>1.子查询必须用小括号括起来<br/> 2.在select子句中的子查询必须是标量子查询</p>\n<h6><a id=\"MySQL_750\"></a>子查询在MySQL中是怎么执行的</h6>\n<ol><li>标量子查询、行子查询的执行方式</li><li>in子查询优化<br/> （1）物化表的提出<br/> 对于不相关的in子查询，比如下面这样：</li></ol>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> s1 <span class=\"token keyword\">where</span> key1 <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> comm_filed <span class=\"token keyword\">from</span> s2 <span class=\"token keyword\">where</span> <span class=\"token keyword\">key</span><span class=\"token operator\">=</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>对于这样，MySQL的处理策略是将子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表中。在将结果集写入临时表时，有两点需要注意（该临时表的列就是子查询结果集中的列；写入临时表的记录会被去重）。把那个存储子查询结果集的临时表称为物化表。物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的物化表有B+树索引）</p>\n<p>（2）物化表转连接<br/> 把子查询的结果集放到临时表中后，相当于两个表直接的操作，内连接。</p>\n<p>（3）将子查询转换为半连接<br/> 如上面的SQL语句；半连接概念。将s1表和s2表进行半连接的意思就是：对于s1表中的某条记录来说，我们只关心在s2表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1表的记录。</p>\n<h1><a id=\"15explain_768\"></a>第15章：explain详解</h1>\n<p>MySQL提供了explain语句，可以查看某个查询语句的具体执行计划</p>\n<h3><a id=\"_770\"></a>执行计划输出中各个列详解</h3>\n<h6><a id=\"table_771\"></a>table</h6>\n<p>explain语句输出的每条记录都对应着某个单表访问方法，该条记录的table列代表该表的表名</p>\n<h6><a id=\"id_774\"></a>id</h6>\n<p>查询语句中每出现一个select关键字，就会为它分配一个唯一的id值。<br/> 在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的；出现在前面的表表示驱动表，出现在后面的表表示被驱动表</p>\n<p>对于union， id会多个NULL，原因：union会把多个查询的结果集合并起来并对结果集中的记录进行去重。（会创建个临时表）</p>\n<h6><a id=\"select_type_780\"></a>select_type</h6>\n<h6><a id=\"type_782\"></a>type</h6>\n<p>type列表明访问该表执行查询的方法是啥。</p>\n<h6><a id=\"possible_keys_key_785\"></a>possible_keys 和key</h6>\n<p>possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些；key列表示实际用到的索引有哪些。</p>\n<h1><a id=\"16optimizer_trace_788\"></a>第16章：optimizer trace的神奇功效</h1>\n<h3><a id=\"optimizer__trace_789\"></a>optimizer trace简介</h3>\n<p>optimizer trace功能可以让用户方便地查看优化器生成执行计划的整个过程</p>\n<h1><a id=\"17InnoDBBuffer_Pool_792\"></a>第17章：InnoDB的Buffer Pool</h1>\n<h3><a id=\"InnoDBBuffer_Pool_793\"></a>InnoDB的Buffer Pool</h3>\n<h6><a id=\"Buffer_Pool_794\"></a>Buffer Pool的概念</h6>\n<p>为了缓存磁盘中的页，在MySQL服务器启动时就向操作系统申请了一片连续的内存-------Buffer Pool（缓冲池）。默认情况下，Buffer Pool只有128MB。</p>\n<h6><a id=\"Buffer_Pool_797\"></a>Buffer Pool内部组成</h6>\n<p>Buffer Pool对应的一片连续的内存被划分为若干个页面，页面大小与InnoDB表空间使用的页面大小一致，默认都是16KB，称为缓冲页。InnoDB为每一个缓冲页都创建了一些控制信息，每个缓冲页对应的控制信息占用的内存大小是相同的。把每个页对应的控制信息占用的一块内存称为一个控制块，控制块与缓冲页是<strong>一 一对应</strong>的。</p>\n<h6><a id=\"free_800\"></a>free链表的管理</h6>\n<p>把所有<strong>空闲</strong>的缓冲页对应的<strong>控制块</strong>作为一个节点放到链表中，这个链表也可以称为free链表（或者说空闲链表）。<br/> 为了管理free链表，为这个链表定义了一个基节点，链表的基节点占用的内存空间并不包含在为Buffer Pool申请的一大片连续内存空间之内，而是一块单独申请的内存空间。</p>\n<h6><a id=\"_804\"></a>缓冲页的哈希处理</h6>\n<p>为了确定该页是否在缓冲区？<br/> 根据表空间号+页号来定位一个页，也就是相当于表空间号+页号是一个key（键），缓冲页控制块 就是对应的value（值）。通过哈希表来确定。<br/> 如果有直接使用该缓冲页就好，如果没有，就从free链表中选一个空闲的缓冲页，然后把磁盘中对应的页加载到该缓冲页的位置。</p>\n<h6><a id=\"flush_809\"></a>flush链表的管理</h6>\n<p>脏页：缓冲页的数据与磁盘页上的不一致。<br/> 每次修改缓冲页后，不立即把修改刷新到磁盘上，而是在未来的某个时间点进行刷新。<br/> 创建一个存储脏页的链表，凡是修改过的缓冲页对应的控制块都会作为一个节点加入到这个链表（flush链表）中。</p>\n<h6><a id=\"LRU_814\"></a>LRU链表的管理</h6>\n<p>（1）缓冲区不够的窘境<br/> free链表没有空闲的缓冲页，需要移除些缓冲页？<br/> 移除使用不频繁的<br/> （2）简单的LRU链表<br/> LRU链表：为了按照最近最少使用的原则去淘汰缓冲页的，所以这个链表可以被称为LRU链表。<br/> 对LRU链表的处理：</p>\n<ul><li>如果该页不在Buffer Pool中，在把该页从磁盘加载到Buffer Pool中的缓冲页时，就把该缓冲页对应的控制块作为节点塞到LRU链表的头部；</li><li>如果该页已经被加载到Buffer Pool中，则直接把该页对应的控制块移动到LRU链表的头部。</li></ul>\n<p>（3）划分区域的LRU链表<br/> 预读：InnoDB执行当前的请求时，可能会在后面读取某些页面，于是就预先把这些页面加载到Buffer Pool中。<br/> 可能降低Buffer Pool命中率的两种情况：<br/> 加载到Buffer Pool中的页不一定被用到； 如果有非常多的使用频率偏低的页被同时加载到Buffer Pool中，则可能会把那些使用频率非常高的页从Buffer Pool中淘汰掉。</p>\n<p>为了解决这两种情况，InnoDB把LRU链表按照<strong>一定比例</strong>分成两截：</p>\n<ul><li>一部分存储使用频率非常高的缓冲页；这一部分链表也称为热数据，或者称为young区域；</li><li>另一部分存储使用频率不是很高的缓冲页；这一部分链表也称为冷数据，或者称为old区域。</li></ul>\n<p>InnoDB针对降低Buffer Pool命中率的情况进行优化：<br/> 针对预读的页面可能不进行后续访问的优化,当初次页面加载到Buffer Pool中，该缓冲页对应的控制块会放大old区域的头部，而不会影响young区域中使用比较频繁的缓冲页。<br/> 针对全表扫描时，短时间内访问大量使用频率非常低的页面的优化，在对某个处于old区域的缓冲页进行第一次访问时，就在它对应的控制块中记录下这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会从old区域移动到young区域的头部，否则将它移动到young区域的头部。</p>\n<p>（4）更进一步优化LRU链表<br/> 只有被访问的缓冲页位于young区域1/4的后面时，才会被移动到LRU链表的头部，这样可以降低调整LRU链表的频率。</p>\n<h6><a id=\"_841\"></a>刷新脏页到磁盘</h6>\n<p>后台有专门的线程负责每隔一段时间就把脏数据刷新到磁盘，这样可以在不影响用户线程处理的正常的请求。刷新方式主要有下面两种：<br/> （1）从LRU链表的冷数据中刷新一部分页面到磁盘。<br/> （2）从flush链表中刷新一部分页面到磁盘</p>\n<h1><a id=\"18_846\"></a>第18章：事务简介</h1>\n<h3><a id=\"_847\"></a>事务的起源</h3>\n<h6><a id=\"_848\"></a>原子性</h6>\n<h6><a id=\"_849\"></a>隔离性</h6>\n<p>保证其他的状态转换不会影响到本次状态转换，这个规则称为隔离性。</p>\n<h6><a id=\"_852\"></a>一致性</h6>\n<p>数据库中的数据全部符合现实世界中的约束，就说这些数据是一致的，或者说符合一致性的。</p>\n<h6><a id=\"_855\"></a>持久性</h6>\n<h3><a id=\"_857\"></a>事务的概念</h3>\n<p>把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为事务。<br/> 事务的状态：活动的、部分提交的、失败的、中止的、提交的。</p>\n<h3><a id=\"MySQL_861\"></a>MySQL中事务的语法</h3>\n<p>如果不显示指定事务的访问模式，那么该事务的访问模式就是读写模式。<br/> 目前只有InnoDB和NDB存储引擎支持事务。</p>\n<p>推荐一个零声学院免费公开课程，个人觉得老师讲得不错，<br/> 分享给大家：[Linux，Nginx，ZeroMQ，MySQL，Redis，<br/> fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，<br/> TCP/IP，协程，DPDK等技术内容，点击立即学习:<a href=\"https://course.0voice.com/v1/course/intro?courseId=5&amp;agentId=0\">服务器课程</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-08-14 22:14:54", "summary": "文章目录前言第章：初始客户端与服务器连接的过程命名管道和内存共享服务器处理客户端请求连接管理解析与优化查询缓存语法解析查询优化存储引擎第章：的启动配置第章：字符集和比较规则字符集简介一些重要的字符集中"}