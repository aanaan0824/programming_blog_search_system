{"blogid": "120583142", "writerAge": "码龄2年", "writerBlogNum": "137", "writerCollect": "11916", "writerComment": "892", "writerFan": "12933", "writerGrade": "6级", "writerIntegral": "6020", "writerName": "-孤单又灿烂的神-", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120583142.jpg", "writerRankTotal": "12612", "writerRankWeekly": "11630", "writerThumb": "3304", "writerVisitNum": "300598", "blog_read_count": "21856", "blog_time": "于 2021-10-02 11:19:19 发布", "blog_title": "❤️万字总结，C语言的这些万年坑你还在踩吗（基础篇）❤️", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" height=\"406\" src=\"..\\..\\static\\image\\20211002111632374.png\" width=\"689\"/></p>\n<p> <strong>目录</strong></p>\n<p id=\"%E4%B8%80%EF%BC%8C%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%EF%BC%8C%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\" title=\"一，写在前面\">一，写在前面</a></p>\n<p id=\"%E4%BA%8C%EF%BC%8C%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%EF%BC%8C%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80\" title=\"二，概念基础\">二，概念基础</a></p>\n<p id=\"1%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#1%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" title=\"1，数据类型\">1，数据类型</a></p>\n<p id=\"2%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F\" title=\"2，数据类型的大小\">2，数据类型的大小</a></p>\n<p id=\"3%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:40px;\"><a href=\"#3%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\" title=\"3，局部变量和全局变量\">3，局部变量和全局变量</a></p>\n<p id=\"4%EF%BC%8C%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc\" style=\"margin-left:40px;\"><a href=\"#4%EF%BC%8C%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\" title=\"4，变量的访问规则及变量的作用域和生命周期\">4，变量的访问规则及变量的作用域和生命周期</a></p>\n<p id=\"5%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:40px;\"><a href=\"#5%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2\" title=\"5，字符串\">5，字符串</a></p>\n<p id=\"%C2%A06%EF%BC%8C%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A06%EF%BC%8C%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6\" title=\" 6，转义字符\"> 6，转义字符</a></p>\n<p id=\"7%EF%BC%8Cstrlen-toc\" style=\"margin-left:40px;\"><a href=\"#7%EF%BC%8Cstrlen\" title=\"7，strlen\">7，strlen</a></p>\n<p id=\"8%EF%BC%8C%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA-toc\" style=\"margin-left:40px;\"><a href=\"#8%EF%BC%8C%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA\" title=\"8，数组创建\">8，数组创建</a></p>\n<p id=\"9%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#9%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97\" title=\"9，关键字\">9，关键字</a></p>\n<p id=\"10%EF%BC%8C%E6%8C%87%E9%92%88-toc\" style=\"margin-left:40px;\"><a href=\"#10%EF%BC%8C%E6%8C%87%E9%92%88\" title=\"10，指针\">10，指针</a></p>\n<p id=\"%E4%B8%89%EF%BC%8C%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%EF%BC%8C%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\" title=\"三，分支语句和循环语句\">三，分支语句和循环语句</a></p>\n<p id=\"1%EF%BC%8Cif%E8%AF%AD%E5%8F%A5-toc\" style=\"margin-left:40px;\"><a href=\"#1%EF%BC%8Cif%E8%AF%AD%E5%8F%A5\" title=\"1，if语句\">1，if语句</a></p>\n<p id=\"2%EF%BC%8Cswitch%E8%AF%AD%E5%8F%A5-toc\" style=\"margin-left:40px;\"><a href=\"#2%EF%BC%8Cswitch%E8%AF%AD%E5%8F%A5\" title=\"2，switch语句\">2，switch语句</a></p>\n<p id=\"3%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5-toc\" style=\"margin-left:40px;\"><a href=\"#3%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\" title=\"3，循环语句\">3，循环语句</a></p>\n<p id=\"%C2%A0%E5%9B%9B%EF%BC%8C%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%9B%9B%EF%BC%8C%E5%87%BD%E6%95%B0\" title=\" 四，函数\"> 四，函数</a></p>\n<p id=\"1%EF%BC%8C%E5%BA%93%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1%EF%BC%8C%E5%BA%93%E5%87%BD%E6%95%B0\" title=\"1，库函数\">1，库函数</a></p>\n<p id=\"2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\" title=\"2，自定义函数\">2，自定义函数</a></p>\n<p id=\"3%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8\" title=\"3，函数的调用\">3，函数的调用</a></p>\n<p id=\"%C2%A04%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A04%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0\" title=\" 4，函数的参数\"> 4，函数的参数</a></p>\n<p id=\"%E4%BA%94%EF%BC%8C%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%EF%BC%8C%E6%95%B0%E7%BB%84\" title=\"五，数组\">五，数组</a></p>\n<p id=\"1%EF%BC%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82-toc\" style=\"margin-left:40px;\"><a href=\"#1%EF%BC%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82\" title=\"1，一维数组的创建和初始化。\">1，一维数组的创建和初始化。</a></p>\n<p id=\"2%EF%BC%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2%EF%BC%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8\" title=\"2，一维数组的使用\">2，一维数组的使用</a></p>\n<p id=\"3%EF%BC%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#3%EF%BC%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96\" title=\"3，二维数组初始化\">3，二维数组初始化</a></p>\n<p id=\"%E5%85%AD%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%AC%A6-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%AC%A6\" title=\"六，操作符\">六，操作符</a></p>\n<p id=\"1%EF%BC%8C%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#1%EF%BC%8C%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6\" title=\"1，算术操作符\">1，算术操作符</a></p>\n<p id=\"2%EF%BC%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#2%EF%BC%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6\" title=\"2，移位操作符\">2，移位操作符</a></p>\n<p id=\"3%EF%BC%8C%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#3%EF%BC%8C%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6\" title=\"3，位操作符\">3，位操作符</a></p>\n<p id=\"4%EF%BC%8C%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#4%EF%BC%8C%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6\" title=\"4，单目操作符\">4，单目操作符</a></p>\n<p id=\"5%EF%BC%8Csizeof%E5%92%8C%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:40px;\"><a href=\"#5%EF%BC%8Csizeof%E5%92%8C%E6%95%B0%E7%BB%84\" title=\"5，sizeof和数组\">5，sizeof和数组</a></p>\n<p id=\"6%EF%BC%8C%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#6%EF%BC%8C%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F\" title=\"6，逗号表达式\">6，逗号表达式</a></p>\n<p id=\"%E4%B8%83%EF%BC%8C%E6%8C%87%E9%92%88-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%EF%BC%8C%E6%8C%87%E9%92%88\" title=\"七，指针\">七，指针</a></p>\n<p id=\"1%EF%BC%8C%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#1%EF%BC%8C%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\" title=\"1，指针是什么？\">1，指针是什么？</a></p>\n<p id=\"2%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8\" title=\"2，指针的解引用\">2，指针的解引用</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E4%B8%80%EF%BC%8C%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\"><span style=\"color:#a2e043;\"><strong>一，写在前面</strong></span></h1>\n<blockquote>\n<p>古人云，温故而知新，学习的过程中，只有不断复习，才能达到孰能手巧的地步，尤其是复习那些自己或者是那些常人的错误，才能提高自己的学习效率。值此国庆佳节，祝福伟大祖国繁荣昌盛，C站的好友们国庆节快乐。如果你认为这篇博客写的还不错的话，<span style=\"color:#fe2c24;\"><strong>求点赞，求收藏，求评论</strong></span>，您的三连是我制作的最大动力！本片主要讲的是基础入门，进阶版很快就会更新，废话不多说，让我们学起来吧。</p>\n</blockquote>\n<h1 id=\"%E4%BA%8C%EF%BC%8C%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80\"><span style=\"color:#a2e043;\"><strong>二，概念基础</strong></span></h1>\n<h2 id=\"1%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span style=\"color:#38d8f0;\"><strong>1，数据类型</strong></span></h2>\n<pre><code>char        //字符数据类型\nshort       //短整型\nint         //整形\nlong        //长整型\nlong long   //更长的整形\nfloat       //单精度浮点数\ndouble      //双精度浮点数</code></pre>\n<blockquote>\n<p>下面哪个不是C语言内置的数据类型：</p>\n<p>A.char</p>\n<p>B.double</p>\n<p>C.struct Stu</p>\n<p>D.short</p>\n</blockquote>\n<blockquote>\n<p>  struct关键字是用户用来自定义的结构体类型，不属于C语言的内置类型。</p>\n<p>  因此：选择C</p>\n</blockquote>\n<h2 id=\"2%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F\"><span style=\"color:#38d8f0;\"><strong>2，数据类型的大小</strong></span></h2>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    printf(\"%d\\n\", sizeof(char));\n    printf(\"%d\\n\", sizeof(short));\n    printf(\"%d\\n\", sizeof(int));\n    printf(\"%d\\n\", sizeof(long));\n    printf(\"%d\\n\", sizeof(long long));\n    printf(\"%d\\n\", sizeof(float));\n    printf(\"%d\\n\", sizeof(double));\n    printf(\"%d\\n\", sizeof(long double));\n    return 0;\n}\n</code></pre>\n<h2 id=\"3%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span style=\"color:#38d8f0;\"><strong>3，局部变量和全局变量</strong></span></h2>\n<blockquote>\n<p>  <strong><span style=\"color:#be191c;\">局部变量</span>：</strong>一般将定义在函数中的变量称为局部变量，其只能在函数内部使用。</p>\n<p>  <strong><span style=\"color:#be191c;\">全局变量</span>：</strong>定义在全局作用域中的变量，即函数外的变量，称之为全局变量，全局变量的生命周期随程序启动而      生，随程序结束而消亡，在任何函数中都可以使用。</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint global = 2019;//全局变量\nint main()\n{\n    int local = 2018;//局部变量\n    int global = 2020;//局部变量\n    printf(\"global = %d\\n\", global);\n    return 0;\n}</code></pre>\n<blockquote>\n<p>局部变量的作用域是：</p>\n<p>A.main函数内部</p>\n<p>B.整个程序</p>\n<p>C.main函数之前</p>\n<p>D.局部变量所在的局部范围</p>\n</blockquote>\n<blockquote>\n<p>注意：全局变量使用起来方便，但为了防止冲突和安全性，尽量避免定义全局变量。</p>\n<p>  A：main函数内部定义的局部变量作用域在main函数中，但是其他函数中的局部变量则不在，因此A选项不对。</p>\n<p>  B：局部变量作用域在函数内部，全局变量是整个程序，因此B选项不对</p>\n<p>  C：main函数之前，是系统做的一些事情，因此也不对</p>\n<p>  D：正确，即在函数体内</p>\n</blockquote>\n<h2 id=\"4%EF%BC%8C%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span style=\"color:#4da8ee;\"><strong>4，变量的访问规则及变量的作用域和生命周期</strong></span></h2>\n<blockquote>\n<p><span style=\"color:#1a439c;\"><strong>作用域</strong></span></p>\n<p>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用 的</p>\n<p>局部变量的作用域是变量所在的局部范围。</p>\n<p>全局变量的作用域是整个工程。</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#1a439c;\"><strong>生命周期</strong></span></p>\n<p>变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</p>\n<p>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。</p>\n<p>全局变量的生命周期是：整个程序的生命周期。</p>\n</blockquote>\n<blockquote>\n<p>下面代码输出的结果是：（ ）</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint num = 10;\nint main()\n{\n    int num = 1;\n    printf(\"num = %d\\n\", num);\n\treturn 0;\t\n}</code></pre>\n<blockquote>\n<p> 根据以上描述可知，对于以上代码：</p>\n<p>  1. 全局作用域中的num和main中的num可以同时存在，不会冲突，因为不是同一个作用域</p>\n<p>  2. 在main函数中访问num时，采用就近原则，因此访问的是main中的num，相当于将全局作用域中的num屏蔽了</p>\n<p> A：错误：因为两个num不在同一个作用域中，可以通过编译</p>\n<p> B：正确，main中访问的是main中的num，而main函数中的num是1，因此打印1</p>\n<p> C：错误，应该访问main函数中的num，而不是全局作用域中的num</p>\n<p> D：错误，凑选择的</p>\n</blockquote>\n<h2 id=\"5%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span style=\"color:#4da8ee;\"><strong>5，字符串</strong></span></h2>\n<pre><code>\"hell0\\n\"\n</code></pre>\n<blockquote>\n<p>这种由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符串。</p>\n</blockquote>\n<blockquote>\n<p>字符串的结束标志是：（ ）</p>\n<p>A.是'0'</p>\n<p>B.是EOF</p>\n<p>C. 是'\\0'</p>\n<p>D.是空格</p>\n</blockquote>\n<blockquote>\n<p>C语言规定：以'\\0'作为有效字符串的结尾标记</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char arr1[] = \"abc\";\n    char arr2[] = { 'a', 'b', 'c' };\n    char arr3[] = { 'a', 'b', 'c', '\\0' };\n    printf(\"%s\\n\", arr1);\n    printf(\"%s\\n\", arr2);\n    printf(\"%s\\n\", arr3);\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"159\" src=\"..\\..\\static\\image\\20211002085654268.png\" width=\"966\"/></p>\n<h2 id=\"%C2%A06%EF%BC%8C%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6\"><span style=\"color:#38d8f0;\"><strong> 6，转义字符</strong></span></h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"width:142px;\">转义字符</td><td style=\"width:356px;\">释义</td></tr><tr><td style=\"width:142px;\">\\?</td><td style=\"width:356px;\">在书写连续多个问号时使用，防止他们被解析成三字母词</td></tr><tr><td style=\"width:142px;\">\\'</td><td style=\"width:356px;\">用于表示字符常量'</td></tr><tr><td style=\"width:142px;\">\\\\</td><td style=\"width:356px;\">用于表示一个反斜杠，防止它被解释为一个转义序列符。</td></tr><tr><td style=\"width:142px;\">\\ddd</td><td style=\"width:356px;\">ddd表示1~3个八进制的数字。 如： \\130 X</td></tr><tr><td style=\"width:142px;\">\\xdd</td><td style=\"width:356px;\">dd表示2个十六进制数字。 如： \\x30 0</td></tr><tr><td style=\"width:142px;\">\\f</td><td style=\"width:356px;\">进纸符</td></tr><tr><td style=\"width:142px;\">\\n</td><td style=\"width:356px;\">换行</td></tr><tr><td style=\"width:142px;\">\\r</td><td style=\"width:356px;\">回车</td></tr><tr><td style=\"width:142px;\">\\t</td><td style=\"width:356px;\">水平制表符</td></tr><tr><td style=\"width:142px;\">\\v</td><td style=\"width:356px;\">垂直制表符</td></tr><tr><td style=\"width:142px;\">\\\"</td><td style=\"width:356px;\">用于表示一个字符串内部的双引号</td></tr></tbody></table>\n<blockquote>\n<p> 下面那个不是转义字符？</p>\n<p>A.'\\n'</p>\n<p>B.'\\060'</p>\n<p>C.'\\q'</p>\n<p>D.'\\b'</p>\n</blockquote>\n<blockquote>\n<p>A：'\\n' 转义字符，代表换行</p>\n<p>B：'\\060' 转义字符，060八进制数据，十进制为48，因此'\\48'表示的就是'0'</p>\n<p>C：'\\q' 什么都不是</p>\n<p>D：'\\b' 转义字符，表示退格</p>\n</blockquote>\n<h2 id=\"7%EF%BC%8Cstrlen\"><strong>7，strlen</strong></h2>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n{\n    char arr[] = {'b', 'i', 't'};\n    printf(\"%d\\n\", strlen(arr));\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>strlen是用来获取字符串的有效长度的，结尾标记'\\0'不包含在内。</p>\n<p>strlen获取的规则非常简单：从前往后一次检测，直到遇到'\\0'是就终止检测。</p>\n<p>而上体中arr是一个字符数组，不是一个有效的字符串，因为后面没有放置'\\0'，因此strlen在求解时，将有效字符检测完之后，还会继续向后检测，直到遇到'\\0'是才终止，因此答案为不确定，就看紧跟在't'之后的第一个'\\0'在什么位置。</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main()\n{\n    printf(\"%d\\n\", strlen(\"c:\\test\\121\"))\n    return 0;\n}</code></pre>\n<blockquote>\n<p>strlen：获取字符串的有效长度，不包括'\\0'</p>\n<p>\"c:\\test\\121\": 在该字符串中，\\t是转移字符，水平制表，跳到下一个tab的位置；而\\121表示一个字符，是讲121看做8进制数组，转换为10进制后的81，作业为ASCII码值的字符，即：字符'Q' ，故上述字符串实际为：\"c:  esty\",只有7个有效字符.</p>\n</blockquote>\n<h2 id=\"8%EF%BC%8C%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA\"><span style=\"color:#38d8f0;\"><strong>8，数组创建</strong></span></h2>\n<blockquote>\n<p>C语言中下面那个数组的创建错误的：（ ）</p>\n</blockquote>\n<pre><code>A.int arr[10] = {0}\n\nB.int n = 10; int arr[n] ={0}\n\nC.int arr[] = {1,2,3,4,5,6,7,8,9,0}\n\nD.char ch[10] = \"hello bit\"</code></pre>\n<blockquote>\n<p>关于数组描述错误的是：</p>\n<p>A.数组是一组相同类型元素的集合</p>\n<p>B.数组的下标是从1开始的</p>\n<p>C.数组的下标是从0开始</p>\n<p>D.数组如果初始化，可以不指定数组的大小</p>\n</blockquote>\n<blockquote>\n<p>数组的下标是从0开始的。</p>\n<p>需要注意的是D：int a[] = {1,2,3},数组可以通过初始化确定大小。</p>\n</blockquote>\n<h2 id=\"9%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97\"><span style=\"color:#38d8f0;\"><strong>9，关键字</strong></span></h2>\n<blockquote>\n<p>关键字<span style=\"color:#9c8ec1;\"> <strong>typedef</strong></span>：typedef 顾名思义是类型定义，这里应该理解为类型重命名。</p>\n</blockquote>\n<blockquote>\n<p>关键字<span style=\"color:#9c8ec1;\"><strong>static</strong></span>：</p>\n<p>1. 修饰局部变量-静态局部变量</p>\n<p>2. 修饰全局变量-静态全局变量</p>\n<p>3. 修饰函数-静态函数</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nvoid test()\n{\n    //static修饰局部变量\n    static int i = 0;\n    i++;\n    printf(\"%d \", i);\n}\nint main()\n{\n int i = 0;\n    for(i=0; i&lt;10; i++)\n   {\n        test();\n   }\n    return 0;\n}</code></pre>\n<blockquote>\n<p>static修饰局部变量改变了变量的生命周期，让静态局部变量出了作用域依然存在，到程序结束， 生命周期才结束。</p>\n</blockquote>\n<pre><code>static int g_val = 2018;\nint main()\n{\n    printf(\"%d\\n\", g_val);\n    return 0;\n}</code></pre>\n<blockquote>\n<p>一个全局变量被static修饰，使得这个全局变量只能在本源文件内使用， 不能在其他源文件内使用。</p>\n</blockquote>\n<pre><code>static int Add(int x, int y)\n{\n    return c+y;\n}\nint main()\n{\n    printf(\"%d\\n\", Add(2, 3));\n    return 0;\n}</code></pre>\n<blockquote>\n<p>一个函数被static修饰，使得这个函数只能在本源文件内使用，不能在其他源文件内使用。</p>\n</blockquote>\n<blockquote>\n<p>关于C语言关键字说法正确的是：( )</p>\n</blockquote>\n<blockquote>\n<p>A.关键字可以自己创建</p>\n<p>B.关键字不能自己创建</p>\n<p>C.关键字可以做变量名</p>\n<p>D.typedef不是关键字</p>\n</blockquote>\n<blockquote>\n<p>关于static说法不正确的是：（ ）</p>\n</blockquote>\n<blockquote>\n<p>A.static可以修饰局部变量</p>\n<p>B.static可以修全局变量</p>\n<p>C.static修饰的变量不能改变</p>\n<p>D.static可以修饰函数</p>\n</blockquote>\n<blockquote>\n<p><strong>  static修饰变量</strong></p>\n<p>   a. 函数中局部变量：</p>\n<p>      声明周期延长：该变量不随函数结束而结束</p>\n<p>      初始化：只在第一次调用该函数时进行初始化</p>\n<p>      记忆性：后序调用时，该变量使用前一次函数调用完成之后保存的值</p>\n<p>      存储位置：不会存储在栈上，放在数据段</p>\n<p>   b. 全局变量</p>\n<p>     改变该变量的链接属性，让该变量具有文件作用域，即只能在当前文件中使用</p>\n<p>   c. 修饰变量时，没有被初始化时会被自动初始化为0</p>\n</blockquote>\n<blockquote>\n<p><strong>static修饰函数</strong></p>\n<p>改变该函数的链接属性，让该函数具有文件作用域，即只能在当前文件中使用</p>\n</blockquote>\n<blockquote>\n<p>const修饰的变量不能改变</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint sum(int a)\n{\n    int c = 0;\n    static int b = 3;\n    c += 1;\n    b += 2;\n    return (a + b + c);\n}\nint main()\n{\n    int i;\n    int a = 2;\n    for (i = 0; i &lt; 5; i++) \n    { \n        printf(\"%d,\", sum(a)); \n    } \n} </code></pre>\n<blockquote>\n<p>本题主要考察static修饰局部变量的特性，static修饰局部变量，该变量不会随函数的结束而消失，并且只在第一次调用时进行初始化，后序调用该函数时，使用的都是上次结束前该变量的值。 </p>\n<p>  第一次循环：a=2 b=5 c=1 a+b+c=8</p>\n<p>  第二次循环：a=2 b=7 c=1 a+b+c=10</p>\n<p>  第二次循环：a=2 b=9 c=1 a+b+c=12</p>\n<p>  第二次循环：a=2 b=11 c=1 a+b+c=14</p>\n<p>  第二次循环：a=2 b=13 c=1 a+b+c=16</p>\n</blockquote>\n<h2 id=\"10%EF%BC%8C%E6%8C%87%E9%92%88\"><span style=\"color:#38d8f0;\"><strong>10，指针</strong></span></h2>\n<blockquote>\n<p><span style=\"color:#be191c;\"><strong>内存</strong></span></p>\n<p>内存是电脑上特别重要的存储器，计算机中所有程序的运行都是在内存中进行的 。 所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节。为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。</p>\n</blockquote>\n<blockquote>\n<p>变量都有地址，取出变量地址如下：</p>\n</blockquote>\n<pre><code>int main()\n{\n int num = 10;\n &amp;num;//取出num的地址\n printf(\"%p\\n\", &amp;num);//打印地址，%p--以地址的形式打印\n return 0;\n}</code></pre>\n<blockquote>\n<p><span style=\"color:#be191c;\"><strong>指针变量的大小</strong></span></p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    printf(\"%d\\n\", sizeof(char *));\n    printf(\"%d\\n\", sizeof(short *));\n    printf(\"%d\\n\", sizeof(int *));\n    printf(\"%d\\n\", sizeof(double *));\n    return 0;\n}</code></pre>\n<blockquote>\n<p> <span style=\"color:#b95514;\"><strong>指针大小在32位平台是4个字节，64位平台是8个字节。</strong></span></p>\n</blockquote>\n<blockquote>\n<p>关于指针说法正确的是：（ ）</p>\n<p>A.sizeof(char*)大小一定是1</p>\n<p>B.指针是个变量，用来存放地址</p>\n<p>C.指针变量的大小都是4个字节</p>\n<p>D.指针不是变量</p>\n</blockquote>\n<blockquote>\n<p>A：错误，指针是一种复合数据类型，指针变量内容是一个地址，因此一个指针可以表示该系统的整个地址集合， 故按照32位编译代码，指针占4个字节，按照64位编译代码，指针占8个字节(注意：不是64位系统一定占8个字  节，关键是要按照64位方式编译)</p>\n<p>B：正确</p>\n<p>C：错误，参考A选项解释</p>\n<p>D：错误，该条描述比较模糊 指针可以认为是一种数据类型，也可以认为是定义出来的指针变量</p>\n</blockquote>\n<h1 id=\"%E4%B8%89%EF%BC%8C%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\"><span style=\"color:#a2e043;\"><strong>三，分支语句和循环语句</strong></span></h1>\n<h2 id=\"1%EF%BC%8Cif%E8%AF%AD%E5%8F%A5\"><span style=\"color:#38d8f0;\"><strong>1，if语句</strong></span></h2>\n<pre><code>语法结构：\nif(表达式)\n    语句;\nif(表达式)\n    语句1;\nelse\n    语句2;\n//多分支    \nif(表达式1)\n    语句1;\nelse if(表达式2)\n    语句2;\nelse\n    语句3;</code></pre>\n<blockquote>\n<p>如果条件成立，要执行多条语句，怎应该使用代码块。</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    if(表达式)\n   {\n        语句列表1；\n   }\n    else\n   {\n        语句列表2；\n   }\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>下面代码执行的结果是：( )</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint i = 0;\n\tfor (i = 0; i&lt;10; i++)\n\t{\n\t\tif (i = 5)\n\t\t\tprintf(\"%d \", i);\n\t}\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>上述代码本来的想法应该是：循环10次，每次循环时如果i==5则打印i的结果。</p>\n<p>但if语句中表达式的==写成了赋值，相当于每次循环尽量都是将i的值设置成了5，5为真，因此每次都会打印5</p>\n<p>i每次修改成5打印后，i的值永远不会等于10，因此造成死循环</p>\n<p>故：死循环的打印5</p>\n</blockquote>\n<h2 id=\"2%EF%BC%8Cswitch%E8%AF%AD%E5%8F%A5\"><span style=\"color:#38d8f0;\"><strong>2，switch语句</strong></span></h2>\n<pre><code>switch(整型表达式)\n{\n    语句项；\n}</code></pre>\n<blockquote>\n<p><span style=\"color:#1c7331;\"><strong> 编程好习惯</strong></span></p>\n</blockquote>\n<blockquote>\n<p>在switch语句中，我们没法直接实现分支，搭配break使用才能实现真正的分支</p>\n<p>在最后一个 case 语句的后面加上一条 break语句。 （之所以这么写是可以避免出现在以前的最 后一个 case 语句后面忘了添加 break语句）。</p>\n<p> 在每个 switch 语句中都放一条default子句是个好习惯，甚至可以在后边再加一个 break 。</p>\n</blockquote>\n<pre><code>int func(int a)\n{\n    int b;\n    switch (a)\n    {\n        case 1: b = 30;\n        case 2: b = 20;\n        case 3: b = 16;\n        default: b = 0;\n    }\n    return b;\n}</code></pre>\n<blockquote>\n<p>则func(1) = （      ）</p>\n<p>switch的每个case之后如果没有加break语句，当前case执行结束后，会继续执行紧跟case中的语句。func(1)可知，在调用func时形参a的值为1，switch(a)&lt;==&gt;switch(1),case 1被命中，因为该switch语句中所有分支下都没有增加break语句，因此会从上往下顺序执行，最后执行default中语句返回。所以答案为0.</p>\n</blockquote>\n<blockquote>\n<p>下面代码的执行结果是什么（ ）</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main() \n{\n\tint x = 3;\n\tint y = 3;\n\tswitch (x % 2) \n{\n\tcase 1:\n\t\tswitch (y)\n\t\t{\n\t\tcase 0:\n\t\t\tprintf(\"first\");\n\t\tcase 1:\n\t\t\tprintf(\"second\");\n\t\t\tbreak;\n\t\tdefault: printf(\"hello\");\n\t\t}\n\tcase 2:\n\t\tprintf(\"third\");\n\t}\n\treturn 0;\n}</code></pre>\n<pre><code>  #include &lt;stdio.h&gt;\n  int main()\n{\n  \tint x = 3;\n  \tint y = 3;\n  \tswitch (x % 2) \n{  // x%2的结果为1，因此执行case1\n  \tcase 1:\n  \t\tswitch (y)   // y是3，因此会执行case3，而case3不存在，那只能执行default\n  \t\t{\n  \t\tcase 0:\n  \t\t\tprintf(\"first\");\n  \t\tcase 1:\n  \t\t\tprintf(\"second\");\n  \t\t\tbreak;\n  \t\tdefault: printf(\"hello\"); // 打印hello，打印完之后，内部switch结束，此时外部case1结束\n  \t\t}             // 因为外部case1之后没有添加break语句，所以继续执行case2\n  \tcase 2:             // 打印third\n  \t\tprintf(\"third\");      // 外部switch结束\n  \t}\n  \treturn 0;\n  }</code></pre>\n<h2 id=\"3%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\"><span style=\"color:#38d8f0;\"><strong>3，循环语句</strong></span></h2>\n<pre><code>if(条件)\n     语句；</code></pre>\n<pre><code>while(表达式)\n 循环语句；</code></pre>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>while语句中的break和continue</strong></span></p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint i = 1;\n\twhile (i &lt;= 10)\n\t{\n\t\tif (i == 5)\n\t\t\tbreak;\n\t\tprintf(\"%d \", i);\n\t\ti = i + 1;\n\t}\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"209\" src=\"..\\..\\static\\image\\20211002095035660.png\" width=\"1069\"/></p>\n<blockquote>\n<p><span style=\"color:#ad720d;\"><strong> break在while循环中的作用：</strong></span></p>\n<p>其实在循环中只要遇到break，就停止后期的所有的循环，直接终止循环。 所以：while中的 break是用于永久终止循环的。</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint i = 1;\n\twhile (i &lt;= 10)\n\t{\n\t\tif (i == 5)\n\t\t\tcontinue;\n\t\tprintf(\"%d \", i);\n\t\ti = i + 1;\n\t}\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"\" height=\"240\" src=\"..\\..\\static\\image\\20211002095149949.png\" width=\"1157\"/></p>\n<blockquote>\n<p><span style=\"color:#ad720d;\"><strong> continue在while循环中的作用就是：</strong></span></p>\n</blockquote>\n<blockquote>\n<p>continue是用于终止本次循环的，也就是本次循环中continue后边的代码不会再执行，而是直接 跳转到while语句的判断部分。进行下一次循环的入口判断。</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint a = 0, b = 0;\n\tfor (a = 1, b = 1; a &lt;= 100; a++)\n\t{\n\t\tif (b &gt;= 20) break;\n\t\tif (b % 3 == 1)\n\t\t{\n\t\t\tb = b + 3;\n\t\t\tcontinue;\n\t\t}\n\t\tb = b-5;\n\t}\n\tprintf(\"%d\\n\", a);\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p> 第一次循环：a = 1，b=1---&gt;b小于20，if不成立，b%3==1%3==1成立，b=b+3, 此时b的值为4</p>\n<p> 第一次循环：a = 2，b=4---&gt;b小于20，if不成立，b%3==4%3==1成立，b=b+3, 此时b的值为7</p>\n<p> 第一次循环：a = 3，b=7---&gt;b小于20，if不成立，b%3==7%3==1成立，b=b+3, 此时b的值为10</p>\n<p> 第一次循环：a = 4，b=10---&gt;b小于20，if不成立，b%3==10%3==1成立，b=b+3, 此时b的值为13</p>\n<p> 第一次循环：a = 5，b=13---&gt;b小于20，if不成立，b%3==13%3==1成立，b=b+3, 此时b的值为16</p>\n<p> 第一次循环：a = 6，b=16---&gt;b小于20，if不成立，b%3==16%3==1成立，b=b+3, 此时b的值为19</p>\n<p> 第一次循环：a = 7，b=19---&gt;b小于20，if不成立，b%3==19%3==1成立，b=b+3, 此时b的值为22</p>\n<p> 第一次循环：a = 8，b=22---&gt;b大于20，if成立，循环break提出</p>\n<p>最后打印a：8</p>\n</blockquote>\n<h1 id=\"%C2%A0%E5%9B%9B%EF%BC%8C%E5%87%BD%E6%95%B0\"><span style=\"color:#a2e043;\"> 四，函数</span></h1>\n<h2 id=\"1%EF%BC%8C%E5%BA%93%E5%87%BD%E6%95%B0\"><span style=\"color:#38d8f0;\"><strong>1，库函数</strong></span></h2>\n<blockquote>\n<p>我们知道在我们学习C语言编程的时候，总是在一个代码编写完成之后迫不及待的想知道结果，想 把这个结果打印到我们的屏幕上看看。这个时候我们会频繁的使用一个功能：将信息按照一定的格 式打印到屏幕上（printf）。</p>\n<p>在编程的过程中我们会频繁的做一些字符串的拷贝（strcpy）。</p>\n<p>在编程是我们也计算，总是会计算n的k次方这样的运算（pow）。</p>\n</blockquote>\n<h2 id=\"2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\"><span style=\"color:#38d8f0;\"><strong>2，自定义函数</strong></span></h2>\n<blockquote>\n<p>函数的组成：</p>\n</blockquote>\n<pre><code>ret_type fun_name(para1, * )\n{\n statement;//语句项\n}\nret_type 返回类型\nfun_name 函数名\npara1    函数参数</code></pre>\n<pre><code>#include &lt;stdio.h&gt;\n//get_max函数的设计\nint get_max(int x, int y)\n{\n return (x&gt;y)?(x):(y);\n}\nint main()\n{\n int num1 = 10;\n int num2 = 20;\n int max = get_max(num1, num2);\n printf(\"max = %d\\n\", max);\n return 0;\n}</code></pre>\n<blockquote>\n<p>关于函数的声明和定义说法正确的是：（ ）</p>\n<p>A.函数的定义必须放在函数的使用之前</p>\n<p>B.函数必须保证先声明后使用</p>\n<p>C.函数定义在使用之后，也可以不声明</p>\n<p>D.函数的声明就是说明函数是怎么实现的</p>\n</blockquote>\n<blockquote>\n<p>A：错误，函数的定义可以放在任意位置，函数的声明必须放在函数的使用之前</p>\n<p>B：正确</p>\n<p>C：错误，函数定义在使用之后，使用之前没有声明时，编译器编译时识别不了该函数</p>\n<p>D：错误，函数的声明只是告诉编译器函数返回值类型、函数名字以及函数所需要的参数，函数定义才是说明函数是怎么  实现的</p>\n</blockquote>\n<h2 id=\"3%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8\"><span style=\"color:#38d8f0;\"><strong>3，函数的调用</strong></span></h2>\n<blockquote>\n<p><span style=\"color:#9c8ec1;\"><strong>传值调用</strong></span></p>\n<p>函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#9c8ec1;\"><strong>传址调用</strong></span></p>\n<p>传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。 这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操 作函数外部的变量。</p>\n</blockquote>\n<blockquote>\n<p>能把函数处理结果的二个数据返回给主调函数，在下面的方法中不正确的是：（ ）</p>\n<p>A.return 这二个数</p>\n<p>B.形参用数组</p>\n<p>C.形参用二个指针</p>\n<p>D.用二个全局变量</p>\n</blockquote>\n<blockquote>\n<p>A：错误，一个函数只能返回一个结果</p>\n<p>B：正确，将形参存在数组中，修改数组中内容，可以通过数组将修改结果带出去</p>\n<p>C：正确，形参如果用指针，最终指向的是外部的实参，在函数中对指向指向内容进行修改，改变的就是外部的实参</p>\n<p>D：正确，全局变量不受函数的结束而结束，在函数中改变全局变量，主调函数中可以看到改变之后的结果</p>\n</blockquote>\n<blockquote>\n<p>关于函数调用说法不正确的是：（ ）</p>\n<p>A.函数可以传值调用，传值调用的时候形参是实参的一份临时拷贝</p>\n<p>B.函数可以传址调用，传址调用的时候，可以通过形参操作实参</p>\n<p>C.函数可以嵌套定义，但是不能嵌套调用</p>\n<p>D.函数可以嵌套调用，但是不能嵌套定义</p>\n</blockquote>\n<blockquote>\n<p> A：正确，形参按照值的方式传递，将来形参就是实参的一份临时拷贝，修改形参不会影响外部的实参</p>\n<p>B：正确，形参按照指针方式传递，将来形参就是实参地址的一份拷贝，形参指向的是实参，修改形参指针指向的内容，  就是在操作实参</p>\n<p>C：错误，C语言中，函数不能嵌套定义</p>\n<p>D：正确，函数可以嵌套调用，即：A()中调用B()，B()中调用A()，但是要控制好，否则就成为无限递归</p>\n</blockquote>\n<blockquote>\n<p>在函数调用时，以下说法正确的是：（ ）</p>\n<p>A.函数调用必须带回返回值</p>\n<p>B.实际参数和形式参数可以同名</p>\n<p>C.函数间的数据传递不可以使用全局变量</p>\n<p>D.主调函数和被调函数总是在同一个文件里</p>\n</blockquote>\n<h2 id=\"%C2%A04%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0\"><span style=\"color:#38d8f0;\"><strong> 4，函数的参数</strong></span></h2>\n<blockquote>\n<p><strong><span style=\"color:#fe2c24;\">实际参数（实参）</span>：</strong></p>\n<p>真实传给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类 型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>形式参数（形参）：</strong></span></p>\n<p>形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配 内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在 函数中有效。</p>\n</blockquote>\n<blockquote>\n<p>关于实参和形参描述错误的是：（ ）</p>\n<p>A.形参是实参的一份临时拷贝</p>\n<p>B.形参是在函数调用的时候才实例化，才开辟内存空间</p>\n<p>C.改变形参就是改变实参</p>\n<p>D.函数调用如果采用传值调用，改变形参不影响实参</p>\n</blockquote>\n<blockquote>\n<p>A：正确，传参时不论是按照值还是指针方式传递，形参拿到的都是实参的一份拷贝</p>\n<p>B：正确，函数没有调用时，新参没有空间</p>\n<p>C：错误，如果是按照值的方式传递，形参和实参各自有各自的空间，改变形参不能改变外部的实参</p>\n<p>D：正确，因为形参和实参是两个不同的变量</p>\n</blockquote>\n<blockquote>\n<p>函数调用exec((vl，v2)，(v3，v4)，v5，v6);中，实参的个数是：（ ）</p>\n<p> exec((vl，v2)，(v3，v4)，v5，v6) 总共有四个参数</p>\n<p> (v1, v2)属于第一个实参，逗号表达式，真实的参数时v2</p>\n<p> (v3，v4)属于第二个实参，逗号表达式，真实的参数是v4</p>\n<p> v5属于第三个实参</p>\n<p> v6属于第四个实参</p>\n</blockquote>\n<h1 id=\"%E4%BA%94%EF%BC%8C%E6%95%B0%E7%BB%84\"><span style=\"color:#a2e043;\"><strong>五，数组</strong></span></h1>\n<h2 id=\"1%EF%BC%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82\"><span style=\"color:#38d8f0;\"><strong>1，一维数组的创建和初始化。</strong></span></h2>\n<pre><code>type_t   arr_name   [const_n];\n//type_t 是指数组的元素类型\n//const_n 是一个常量表达式，用来指定数组的大小</code></pre>\n<blockquote>\n<p>定义了一维 int 型数组 a[10] 后，下面错误的引用是：（ ）</p>\n<p>A.a[0] = 1;</p>\n<p>B.a[0] = 5*2;</p>\n<p>C.a[10] = 2;</p>\n<p>D.a[1] = a[2] * a[0];</p>\n</blockquote>\n<blockquote>\n<p>数组是相同类型的一段连续的空间，下标是从0开始的，比如：int array[N]</p>\n<p>下标的范围为[0,N),其中N位置不能存储有效元素</p>\n<p>A：正确，将0号位置设置为1</p>\n<p>B：正确，将0号位置设置为10</p>\n<p>C：错误，越界</p>\n<p>D：正确，1号位置初始化为a[2]*a[0]之后的结果</p>\n</blockquote>\n<h2 id=\"2%EF%BC%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8\"><span style=\"color:#38d8f0;\"><strong>2，一维数组的使用</strong></span></h2>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int arr[10] = { 0 };//数组的不完全初始化\n       //计算数组的元素个数\n    int sz = sizeof(arr) / sizeof(arr[0]);\n    //对数组内容赋值,数组是使用下标来访问的，下标从0开始。所以：\n    int i = 0;//做下标\n    for (i = 0; i &lt; 10; i++)//这里写10，好不好？\n    {\n        arr[i] = i;\n    }\n    //输出数组的内容\n    for (i = 0; i &lt; 10; ++i)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}</code></pre>\n<p><img alt=\"\" height=\"129\" src=\"..\\..\\static\\image\\20211002101549427.png\" width=\"953\"/></p>\n<blockquote>\n<p>下面代码的结果是：( )</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int arr[] = {1,2,(3,4),5};\n    printf(\"%d\\n\", sizeof(arr));\n    return 0;\n}</code></pre>\n<blockquote>\n<p>对于int arr[] = {1,2,(3,4),5}数组，里面总共有4个元素，(3,4)为逗号表达式，取后者，因此数组中元素分别为：1,2,4,5。而sizeof(arr)求的是整个数组所占空间的大小，即：4*sizeof(int)=4*4=16</p>\n</blockquote>\n<blockquote>\n<p>下面代码的结果是：( )</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char str[] = \"hello bit\";\n    printf(\"%d %d\\n\", sizeof(str), strlen(str));\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>str字符数组使用\"hello bit\"初始化，最终也会将'\\0'放置到数组中，因此数组中总共有10个元素</p>\n<p>sizeof(str)：获取数组的总大小，10个元素，每个元素占1个字节，因此总共是10个字节</p>\n<p>strlen(str): 获取字符串中有效字符的个数，不算'\\0'，因此总共9个有效字符</p>\n<p>故上述printf会分别打印：10  9</p>\n</blockquote>\n<blockquote>\n<p>关于一维数组描述不正确的是：( )</p>\n<p>A.数组的下标是从0开始的</p>\n<p>B.数组在内存中是连续存放的</p>\n<p>C.数组名表示首元素的地址</p>\n<p>D.随着数组下标的由小到大，地址由高到低</p>\n</blockquote>\n<blockquote>\n<p>A：正确，C语言规定，数组的下标是从0开始的</p>\n<p>B：正确，数组的空间是一段连续的内存空间</p>\n<p>C：正确，数组名既可以表示数组的地址，也可以表示数组首元素的地址，两个在数值上是一样的，但是含义不一样。</p>\n<p>  注意：数组名只有在sizeof和&amp;后才代表整个数组，其它都表示首元素的地址</p>\n<p>D：错误，这个要是系统而定，一般都是下标由小到大，地址由低到高</p>\n</blockquote>\n<h2 id=\"3%EF%BC%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span style=\"color:#38d8f0;\"><strong>3，二维数组初始化</strong></span></h2>\n<blockquote>\n<p><strong>二维数组的创建</strong></p>\n</blockquote>\n<pre><code>//数组创建\nint arr[3][4];\nchar arr[3][5];\ndouble arr[2][4];</code></pre>\n<blockquote>\n<p><strong>二维数组的初始化</strong></p>\n</blockquote>\n<pre><code>//数组初始化\nint arr[3][4] = {1,2,3,4};\nint arr[3][4] = {<!-- -->{1,2},{4,5}};\nint arr[][4] = {<!-- -->{2,3},{4,5}};\n</code></pre>\n<blockquote>\n<p>以下能对二维数组a进行正确初始化的语句是：（ ）</p>\n<p>A.int a[2][]={<!-- -->{0,1,2},{3,4,5}};</p>\n<p>B.int a[][3]={<!-- -->{0,1,2},{3,4,5}};</p>\n<p>C.int a[2][4]={<!-- -->{0,1,2},{3,4},{5}};</p>\n<p>D.int a[][3]={<!-- -->{0,,2},{},{3,4,5}};</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#ad720d;\"><strong>对于二维数组int array[M][N], 说明如下：</strong></span></p>\n<p> 1. M和N都必须为常数，</p>\n<p> 2. M代表数组有M行，N代表每行中有N个元素</p>\n<p> 3. 其中M可以省略，省略后必须给出初始化表达式，编译器从初始化结果中推断数组有多少行</p>\n<p> 4. N一定不能省略，因为N省略了就不能确定一行有多少个元素，也不能确定数组有多少行</p>\n<p>A：错误，参数上述说明</p>\n<p>B：正确，参考上述说明</p>\n<p>C：错误，数组有两行，但是初始化给了三行</p>\n<p>D：错误，初始化不允许{0,,2}该种情况存在</p>\n</blockquote>\n<h1 id=\"%E5%85%AD%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span style=\"color:#a2e043;\"><strong>六，操作符</strong></span></h1>\n<h2 id=\"1%EF%BC%8C%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span style=\"color:#38d8f0;\"><strong>1，算术操作符</strong></span></h2>\n<pre><code>+    -   *   /   %</code></pre>\n<blockquote>\n<p>1. 除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。</p>\n<p>2. 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除 法。</p>\n<p>3. % 操作符的两个操作数必须为整数。返回的是整除之后的余数。</p>\n</blockquote>\n<h2 id=\"2%EF%BC%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span style=\"color:#38d8f0;\"><strong>2，移位操作符</strong></span></h2>\n<pre><code>&lt;&lt; 左移操作符\n&gt;&gt; 右移操作符\n</code></pre>\n<blockquote>\n<p><span style=\"color:#1c7331;\"><strong>左移操作符 移位规则：</strong></span></p>\n<p>左边抛弃、右边补0</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#1c7331;\"><strong>右移操作符 移位规则：</strong></span></p>\n<p>1. 逻辑移位 左边用0填充，右边丢弃</p>\n<p>2. 算术移位 左边用原该值的符号位填充，右边丢弃</p>\n</blockquote>\n<h2 id=\"3%EF%BC%8C%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span style=\"color:#38d8f0;\"><strong>3，位操作符</strong></span></h2>\n<pre><code>&amp; //按位与\n| //按位或\n^ //按位异或\n注：他们的操作数必须是整数</code></pre>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n int num1 = 1;\n int num2 = 2;\n num1 &amp; num2;\n num1 | num2;\n num1 ^ num2;\n return 0;\n}</code></pre>\n<h2 id=\"4%EF%BC%8C%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span style=\"color:#38d8f0;\"><strong>4，单目操作符</strong></span></h2>\n<pre><code>!           逻辑反操作\n-           负值\n+           正值\n&amp;           取地址\nsizeof      操作数的类型长度（以字节为单位）\n~           对一个数的二进制按位取反\n--          前置、后置--\n++          前置、后置++\n*           间接访问操作符(解引用操作符)\n(类型)       强制类型转换</code></pre>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>以上四个内容我在之前的博客专门有讲解，欢迎大家考古。</strong></span></p>\n</blockquote>\n<h2 id=\"5%EF%BC%8Csizeof%E5%92%8C%E6%95%B0%E7%BB%84\"><span style=\"color:#38d8f0;\"><strong>5，sizeof和数组</strong></span></h2>\n<pre><code>#include &lt;stdio.h&gt;\n int main()\n {\n int a = 10;\n int x = ++a;\n //先对a进行自增，然后对使用a，也就是表达式的值是a自增之后的值。x为11。\n int y = --a;\n //先对a进行自减，然后对使用a，也就是表达式的值是a自减之后的值。y为10;\n return 0;\n }\n \n //后置++和--\n #include &lt;stdio.h&gt;\n int main()\n {\n int a = 10;\n int x = a++;\n //先对a先使用，再增加，这样x的值是10；之后a变成11；\n int y = a--;\n //先对a先使用，再自减，这样y的值是11；之后a变成10；\n return 0;\n }\n</code></pre>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint a, b, c;\n\ta = 5;\n\tc = ++a;\n\tb = ++c, c++, ++a, a++;\n\tb += a++ + c;\n\tprintf(\"a = %d b = %d c = %d\\n:\", a, b, c);\n\treturn 0;\n}</code></pre>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint a, b, c;\n\ta = 5;\n\tc = ++a;// ++a：加给a+1，结果为6，用加完之后的结果给c赋值，因此：a = 6  c = 6\n\tb = ++c, c++, ++a, a++;\n   // 逗号表达式的优先级，最低，这里先算b=++c, b得到的是++c后的结果，b是7\n   // b=++c 和后边的构成逗号表达式，依次从左向右计算的。\n   // 表达式结束时，c++和，++a,a++会给a+2，给c加1，此时c：8，a：8，b:7\n\tb += a++ + c; // a先和c加，结果为16，在加上b的值7，比的结果为23，最后给a加1，a的值为9\n\tprintf(\"a = %d b = %d c = %d\\n:\", a, b, c); // a:9, b:23, c:8\n\treturn 0;\n}</code></pre>\n<h2 id=\"6%EF%BC%8C%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span style=\"color:#38d8f0;\"><strong>6，逗号表达式</strong></span></h2>\n<pre><code>exp1, exp2, exp3, …expN</code></pre>\n<blockquote>\n<p>逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。整个表达式的结果是最 后一个表达式的结果。</p>\n</blockquote>\n<pre><code>int main()\n{\n\tint a = 1;\n\tint b = 2;\n\tint c = (a &gt; b, a = b + 10, a, b = a + 1);\n\tprintf(\"%d\", c);\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"170\" src=\"..\\..\\static\\image\\20211002103536439.png\" width=\"880\"/></p>\n<h1 id=\"%E4%B8%83%EF%BC%8C%E6%8C%87%E9%92%88\"><span style=\"color:#a2e043;\"><strong>七，指针</strong></span></h1>\n<h2 id=\"1%EF%BC%8C%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span style=\"color:#38d8f0;\"><strong>1，指针是什么？</strong></span></h2>\n<blockquote>\n<p>在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向 （points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以 说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p>\n</blockquote>\n<blockquote>\n<p>指针是个变量，存放内存单元的地址（编号）。</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n int a = 10;//在内存中开辟一块空间\n int *p = &amp;a;//这里我们对变量a，取出它的地址，可以使用&amp;操作符。\n   //将a的地址存放在p变量中，p就是一个之指针变量。\n return 0;\n}</code></pre>\n<blockquote>\n<p>关于指针的概念，错误的是：( )</p>\n<p>A.指针是变量，用来存放地址</p>\n<p>B.指针变量中存的有效地址可以唯一指向内存中的一块区域</p>\n<p>C.野指针也可以正常使用</p>\n<p>D.局部指针变量不初始化就是野指针</p>\n</blockquote>\n<blockquote>\n<p>A：正确，指针变量中存储的是一个地址，指向同类型的一块内存空间</p>\n<p>B：正确，地址是唯一的，一个指针变量中只能存储一个地址，因此可以唯一指向内存中的一块区域</p>\n<p>C：野指针指向的空间时非法的，或者说该指针指向的空间已经不存在了，因此野指针不能使用</p>\n<p>D：局部指针变量没有初始化时里面就是随机值，因此指向那个位置不一定，故将其看成是野指针</p>\n</blockquote>\n<blockquote>\n<p>以下系统中，int类型占几个字节，指针占几个字节，操作系统可以使用的最大内存空间是多大：( )</p>\n<p>A.32位下：4,4,2^32 64位下：8,8,2^64</p>\n<p>B.32位下：4,4,不限制 64位下：4,8,不限制</p>\n<p>C.32位下：4,4,2^32 64位下：4,8,2^64</p>\n<p>D.32位下：4,4,2^32 64位下：4,4,2^64</p>\n</blockquote>\n<blockquote>\n<p>32位系统下：</p>\n<p>int占4个字节，指针表示地址空间个数，总共有2^32个，故占4个字节</p>\n<p>64位系统下：</p>\n<p>int占4个字节，指针表示地址空间个数，总共有2^64个，故占8个字节</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#4da8ee;\"><strong>指针的大小在32位平台是4个字节，在64位平台是8个字节。</strong></span></p>\n</blockquote>\n<h2 id=\"2%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8\"><span style=\"color:#38d8f0;\"><strong>2，指针的解引用</strong></span></h2>\n<pre><code>int main()\n{\n int n = 0x11223344;\n char *pc = (char *)&amp;n;\n int *pi = &amp;n;\n *pc = 0;   //重点在调试的过程中观察内存的变化。\n *pi = 0;   //重点在调试的过程中观察内存的变化。\n return 0;\n}\n</code></pre>\n<p><img alt=\"\" height=\"359\" src=\"..\\..\\static\\image\\20211002104404578.png\" width=\"901\"/></p>\n<blockquote>\n<p>总结： 指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。 比如： <span style=\"color:#511b78;\"><strong>char* 的 指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。</strong></span></p>\n</blockquote>\n<blockquote>\n<p>下面代码的结果是：（ ）</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n  int arr[] = {1,2,3,4,5};\n  short *p = (short*)arr;\n  int i = 0;\n  for(i=0; i&lt;4; i++)\n  {\n    *(p+i) = 0;\n  }\n   \n  for(i=0; i&lt;5; i++)\n  {\n    printf(\"%d \", arr[i]);\n  }\n  return 0;\n}</code></pre>\n<pre><code>arr数组在内存中的存储格式为：\n0x00ECFBF4:  01 00 00 00\n0x00ECFBF8:  02 00 00 00\n0x00ECFBFC:  03 00 00 00\n0x00ECFC00:  04 00 00 00\n0x00ECFC04:  05 00 00 00\n指针p的类型为short*类型的，因此p每次只能所有两个字节，for循环对数组中内容进行修改时，一次访问的是：\narr[0]的低两个字节，arr[0]的高两个字节，arr[1]的低两个字节，arr[1]的高两个字节，故改变之后，数组中内容如下：\n0x00ECFBF4:  00 00 00 00\n0x00ECFBF8:  00 00 00 00\n0x00ECFBFC:  03 00 00 00\n0x00ECFC00:  04 00 00 00\n0x00ECFC04:  05 00 00 00\n故最后打印：0   0   3   4   5</code></pre>\n<blockquote>\n<p>下面代码输出的结果是：（ ）</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\tint a = 0x11223344;\n    char *pc = (char*)&amp;a;\n    *pc = 0;\n    printf(\"%x\\n\", a);\n    return 0;\n}</code></pre>\n<pre><code>答案解析：\n \n假设，a变量的地址为0x64，则a变量在内存中的模型为：\n0x64| 44 |\n0x65| 33 |\n0x66| 22 |\n0x67| 11 |\n \nchar*类型的指针变量pc指向只能指向字符类型的空间，如果是非char类型的空间，必须要将该空间的地址强转为char*类型。\nchar *pc = (char*)&amp;a; pc实际指向的是整形变量a的空间，即pc的内容为0x64，即44，\n*pc=0，即将44位置中内容改为0，修改完成之后，a中内容为：0x11223300</code></pre>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-10-02 11:19:19", "summary": "目录一，写在前面一，写在前面二，概念基础二，概念基础，数据类型，数据类型，数据类型的大小，数据类型的大小，局部变量和全局变量，局部变量和全局变量，变量的访问规则及变量的作用域和生命周期，变量的访问规则"}