{"blogid": "123929467", "writerAge": "码龄2年", "writerBlogNum": "68", "writerCollect": "390", "writerComment": "296", "writerFan": "939", "writerGrade": "4级", "writerIntegral": "1373", "writerName": "五毛变向.", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123929467.jpg", "writerRankTotal": "30434", "writerRankWeekly": "216821", "writerThumb": "312", "writerVisitNum": "58025", "blog_read_count": "1427", "blog_time": "已于 2022-05-02 12:15:25 修改", "blog_title": "C++ 【 入门 】【 第一回 】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%20C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B98)-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%28C%2B%2B98%29\">1. C++关键字(C++98)</a></p>\n<p id=\"%C2%A02.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A02.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"> 2.命名空间</a></p>\n<p id=\"2.1%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99\">2.1作用域规则</a></p>\n<p id=\"2.2%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89\">2.2 命名空间定义</a></p>\n<p id=\"2.3%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2.3%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8\">2.3 命名空间使用</a></p>\n<p id=\"2.3.1%20%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6%20%3A%3A-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.1%20%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6%20%3A%3A\">2.3.1 加作用域限定符 ::</a></p>\n<p id=\"%C2%A02.3.2%20%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%BC%95%E5%85%A5-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A02.3.2%20%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%BC%95%E5%85%A5\"> 2.3.2 使用using关键字将命名空间引入</a></p>\n<p id=\"%C2%A02.3.3%20%E4%BD%BF%E7%94%A8using%20namespace%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A02.3.3%20%E4%BD%BF%E7%94%A8using%20namespace%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5\"> 2.3.3 使用using namespace 命名空间名称引入</a></p>\n<p id=\"%C2%A03.C%2B%2B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A03.C%2B%2B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA\"> 3.C++输入和输出</a></p>\n<p id=\"4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\">4.缺省参数</a></p>\n<p id=\"4.1C%E5%92%8CC%2B%2B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#4.1C%E5%92%8CC%2B%2B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\">4.1C和C++函数的区别</a></p>\n<p id=\"%C2%A04.1%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A04.1%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5\"> 4.1 缺省参数概念</a></p>\n<p id=\"4.2%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5\">4.2 缺省参数概念</a></p>\n<p id=\"4.3%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#4.3%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB\">4.3 缺省参数分类</a></p>\n<p id=\"4.3.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#4.3.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\">4.3.1全缺省参数</a></p>\n<p id=\"4.3.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#4.3.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\">4.3.2半缺省参数</a></p>\n<p id=\"4.3.4%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-toc\" style=\"margin-left:80px;\"><a href=\"#4.3.4%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A\">4.3.4 函数调用约定</a></p>\n<p id=\"5.%C2%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:0px;\"><a href=\"#5.%C2%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">5.  函数重载</a></p>\n<p id=\"5.1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#5.1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5\">5.1函数重载概念</a></p>\n<p id=\"5.2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#5.2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86\">5.2函数重载的原理</a></p>\n<p id=\"5.3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#5.3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">5.3函数重载的底层实现原理</a></p>\n<p id=\"5.3.2%20C%2FC%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#5.3.2%20C%2FC%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\">5.3.2 C/C++编译器的处理方式</a></p>\n<p id=\"5.3.3%20%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0-toc\" style=\"margin-left:80px;\"><a href=\"#5.3.3%20%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0\">5.3.3 名字修饰</a></p>\n<p id=\"5.4%20extern%20%E2%80%9C%20C%20%E2%80%9D-toc\" style=\"margin-left:40px;\"><a href=\"#5.4%20extern%20%E2%80%9C%20C%20%E2%80%9D\">5.4 extern “ C ”</a></p>\n<p id=\"6.%20%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#6.%20%E5%BC%95%E7%94%A8\">6. 引用</a></p>\n<p id=\"6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5\">6.1引用的概念</a></p>\n<p id=\"6.2%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#6.2%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95\">6.2引用的语法</a></p>\n<p id=\"6.3%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#6.3%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7\">6.3引用的特性</a></p>\n<p id=\"6.4%20%E5%B8%B8%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#6.4%20%E5%B8%B8%E5%BC%95%E7%94%A8\">6.4 常引用</a></p>\n<p id=\"6.5%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#6.5%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8\">6.5引用的应用</a></p>\n<p id=\"6.5.1%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#6.5.1%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7\">6.5.1简化代码增加可读性</a></p>\n<p id=\"6.5.2%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#6.5.2%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7\">6.5.2增加代码的安全性</a></p>\n<p id=\"6.5.3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:80px;\"><a href=\"#6.5.3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B\">6.5.3作为函数的返回值类型</a></p>\n<p id=\"6.6%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#6.6%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB\">6.6 引用和指针的区别</a></p>\n<p id=\"6.6.1%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:80px;\"><a href=\"#6.6.1%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB\">6.6.1 底层实现区别</a></p>\n<p id=\"6.6.2%20%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:80px;\"><a href=\"#6.6.2%20%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB\">6.6.2 使用区别</a></p>\n<p id=\"7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\">7. 内联函数</a></p>\n<p id=\"7.1%20%23define%20%E5%AE%8F-toc\" style=\"margin-left:40px;\"><a href=\"#7.1%20%23define%20%E5%AE%8F\">7.1 #define 宏</a></p>\n<p id=\"7.1.1%C2%A0%20%E5%AE%8F%E5%B8%B8%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#7.1.1%C2%A0%20%E5%AE%8F%E5%B8%B8%E9%87%8F\">7.1.1  宏常量</a></p>\n<p id=\"7.1.2%20%E5%AE%9A%E4%B9%89%E5%AE%8F-toc\" style=\"margin-left:80px;\"><a href=\"#7.1.2%20%E5%AE%9A%E4%B9%89%E5%AE%8F\">7.1.2 定义宏</a></p>\n<p id=\"7.1.3%20%E5%AE%8F%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99-toc\" style=\"margin-left:80px;\"><a href=\"#7.1.3%20%E5%AE%8F%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99\">7.1.3 宏的替换规则</a></p>\n<p id=\"7.1.4%20%E5%AE%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc\" style=\"margin-left:80px;\"><a href=\"#7.1.4%20%E5%AE%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">7.1.4 宏的优缺点</a></p>\n<p id=\"7.2%20%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#7.2%20%E6%A6%82%E5%BF%B5\">7.2 概念</a></p>\n<p id=\"%C2%A07.3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A07.3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"> 7.3注意事项</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%20C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B98)\">1. C++关键字(C++98)</h1>\n<p>C++总计63个关键字，C语言32个关键字</p>\n<p>以下是C++98里面的关键字</p>\n<table><tbody><tr><td>asm</td><td>do</td><td>if</td><td>return</td><td>try</td><td>continue</td></tr><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typedef</td><td>for</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typeid</td><td>public</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>typename</td><td>throw</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>union</td><td>wchar_t</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>unsigned</td><td>default</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>using</td><td>friend</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>virtual</td><td>register</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>void</td><td>true</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>volatile</td><td>while</td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td></tr></tbody></table>\n<h1 id=\"%C2%A02.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"> 2.命名空间</h1>\n<h2 id=\"2.1%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99\">2.1作用域规则</h2>\n<p>在C语言中我们知道他的程序中名字的作用域分为两种是 <strong>局部作用域</strong> 和 <strong>全局作用域。</strong></p>\n<p><strong>1.局部变量</strong>：如果一个变量被定义在函数中，那么这个变量的作用域就是一个局部作用域，在函数体外面不能访问这个变量，在别的函数定义同名变量，编译器会给他分配新的内存，他们互补干扰，你在你的地盘，我在我的地盘。</p>\n<p><strong>2.静态局部变量</strong>：想要延长他的生命周期我们可以在前面加一个static关键字把他变成静态局部变量，但是他的作用跟局部变量一样，即只能在定义该变量的函数内使用该变量，只是程序仅分配一次内存，函数返回后，该变量不会消失，该变量还存在只是不能使用他。但是他的生命周期延长到了整个工程。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\0614cf56024146e1982278b12e483cbd.png\"/></p>\n<p><strong> 3.全局变量：</strong>在函数体外定义的变量，且存放在静态存储区中，在定义变量的位置到本源文件结束后都有效，在这个作用域中全局变量，可以为程序内各个函数引用，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。</p>\n<p><strong>4.静态全局变量：</strong>和全局变量一样，不过加了static之后会限制他们的作用域，使他们只能在定义他们的文件内使用，加了static可以将名字限制在一个文件中，防止名字污染。</p>\n<p>滥用全局变量可能还是造成会造成名字污染，我加static也不行。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_17,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\697c06929c5245ef96625546e16efb7d.png\"/></p>\n<p>我们在之前说了C语言从你的文本文件变成可执行文件过程中，会经过预处理，编译，汇编，链接的过程。而在预处理里面会有 头文件的展开，宏替换  ，取消注释  ，条件编译。而qsort是C里面的一个快排函数，我预处理头文件展开了，恰巧有个函数声明，这个函数就叫qsort，即使你加了static关键字修饰，但是还是在本文件内使用，还是会有重定义的问题。</p>\n<p>C语言这时只能去改这个变量的名称了，万一工程很大呢？这时为了解决命名冲突，C++里面就有了命名空间。</p>\n<h2 id=\"2.2%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89\">2.2 命名空间定义</h2>\n<p>定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空间的成员。<br/> 1.普通的命名空间</p>\n<pre><code class=\"language-cpp\">namespace A {\n\tint a = 10;\n\t// 命名空间中的内容，既可以定义变量，也可以定义函数\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n}\n</code></pre>\n<p>2. 命名空间可以嵌套</p>\n<pre><code class=\"language-cpp\">namespace B {\n\tint b = 20;\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n\tnamespace C {\n\t\tint c = 30;\n\t\tint add(int a, int b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n}</code></pre>\n<p>3. 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中<br/>  </p>\n<pre><code class=\"language-cpp\">namespace A {\n\tint aa = 10;\n\tint sub(int a, int b) {\n\t\treturn a - b;\n\t}\n}\nnamespace A {\n\tint a = 10;\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n}</code></pre>\n<p>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。</p>\n<h2 id=\"2.3%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8\">2.3 命名空间使用</h2>\n<p>举个例子这个函数打印的是那个a呢？</p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\nnamespace A {\n\tint a = 10;\n\t// 命名空间中的内容，既可以定义变量，也可以定义函数\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n}\n\nint main() {\n\tint a = 1000;\n\tprintf(\"%d\", a);\n\treturn 0;\n}</code></pre>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\87bcea480f554fc8a56c77c74f05b360.png\"/></p>\n<p>肯定是1000啦，那我怎么访问A这个命名空间里的a呢？ </p>\n<p>命名空间的使用有三种方式：</p>\n<h3 id=\"2.3.1%20%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6%20%3A%3A\"><strong>2.3.1 加作用域限定符 ::</strong></h3>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\nnamespace A {\n\tint a = 10;\n\t// 命名空间中的内容，既可以定义变量，也可以定义函数\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n}\n\nint main() {\n\tint a = 1000;\n\tprintf(\"%d\", A::a);\n\treturn 0;\n}</code></pre>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_18,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\14456e99ec3f446d818475070001c670.png\"/></p>\n<h3 id=\"%C2%A02.3.2%20%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%BC%95%E5%85%A5\"><strong> 2.3.2 使用using关键字将命名空间引入</strong></h3>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\nnamespace A {\n\tint a = 10;\n\t// 命名空间中的内容，既可以定义变量，也可以定义函数\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n}\nusing A::add;\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tprintf(\"%d\", add(a, b));\n\treturn 0;\n}</code></pre>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\f648bbd256ba48f996fdb291bd9191b4.png\"/></p>\n<h3 id=\"%C2%A02.3.3%20%E4%BD%BF%E7%94%A8using%20namespace%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5\"><strong> 2.3.3 使用using namespace 命名空间名称引入</strong></h3>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\nnamespace A {\n\tint c = 10;\n\t// 命名空间中的内容，既可以定义变量，也可以定义函数\n\tint add(int a, int b) {\n\t\treturn a + b;\n\t}\n}\nusing namespace A;\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tprintf(\"%d\\n\",c);\n\tprintf(\"%d\\n\", add(a, b));\n\treturn 0;</code></pre>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\73651b97ffb34ed1bf52c99fe6f14b8b.png\"/></p>\n<h1 id=\"%C2%A03.C%2B%2B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA\"> 3.C++输入和输出</h1>\n<p>不知道你是否和我一样在刚刚开始接触C语言的时候写过以下的代码</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_12,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\fd0ea300c8ef4e40a4e4ed2b9ed0d3a9.png\"/></p>\n<p> 这个问题确实现在看起来让人啼笑皆非，但是刚刚开始学习的时候确实让我很费解，看半天也不知道错误在哪里。但是在C++里面输入和输出是不需要格式控制符的，输入也不需要取地址符了。</p>\n<p>在C++中使用标准输入输出必须包含 &lt;iostream&gt; 头文件 和 std 命名空间</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nint main() {\n\tint a = 0;\n\tstd::cin &gt;&gt; a;\n\tstd::cout &lt;&lt; a &lt;&lt; std::endl;\n}</code></pre>\n<p>不过我们一般不这样用会用using关键字来使用这个命名空间。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n\t//int a = 0;\n\t//std::cin &gt;&gt; a;\n\t//std::cout &lt;&lt; a &lt;&lt; std::endl;\n\n\tint a, b, c;\n\tdouble d;\n\t//可以连着输入\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\t//可以连着输入不同类型的\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n\n\tcout &lt;&lt; a &lt;&lt; endl;\n\t//还可以连着输出不同类型的\n\tcout &lt;&lt; \"hello world!\" &lt;&lt; 100 &lt;&lt; 3.14 &lt;&lt; endl;\n}</code></pre>\n<h1 id=\"4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\">4.缺省参数</h1>\n<h2 id=\"4.1C%E5%92%8CC%2B%2B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\">4.1C和C++函数的区别</h2>\n<p>举个例子，这个代码会报错吗？</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\8d1bd3ac22604e05a7e7c0bc62dbf901.png\"/></p>\n<p> 答案是不会的，但是C++的编译器比C语言编译器更严格，就会报错。</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\94c8412c2877449bab4ebfdeb6703382.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\0e8f240a8af5480c8dd7876231e80c62.png\"/></p>\n<p> 在看这个例子</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\ef909f0610d0459394f89a498b082292.png\"/></p>\n<p> 这个在C语言的的编译器下也是可以通过的但是在C++下就不行，C++编译器对函数的返回值类型检测的更加的严格。<img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\cae187156c30425a98d570d7e96dec9f.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\80eb657f909e434a953535124d151208.png\"/></p>\n<p>还记得在之前写栈的实现的时候我们在初始化时候默认给了栈3个空间，在C语言的时候我们只能在调用这个方法的时候穿一个3作为参数进去，但是在C++里面我们可以这样做。</p>\n<h2 id=\"%C2%A04.1%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5\"> 4.1 缺省参数概念</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\ntypedef struct Stack\n{\n\tint* array;\n\tint size;\n\tint capacity;\n}Stack;\nvoid InitStack(Stack* ps, int initCapacity = 3)\n{\n\tcout &lt;&lt; initCapacity &lt;&lt; endl;\n}\n\nint main()\n{\n\tStack s;\n\tInitStack(&amp;s, 100);\n\tInitStack(&amp;s);\n\treturn 0;\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\66b9de410db84ab7a07ad11a06776782.png\"/></p>\n<p> 这个语法在C++是可以通过的，这个3相当与一个备胎你没有传参数，那我就用你了。</p>\n<h2 id=\"4.2%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5\">4.2 缺省参数概念</h2>\n<p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nvoid Test(int a = 0)\n{\n\tcout &lt;&lt; a &lt;&lt; endl;\n}\nint main()\n{\n\tTest(); // 没有传参时，使用参数的默认值\n\tTest(10); // 传参时，使用指定的实参\n}</code></pre>\n<h2 id=\"4.3%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB\">4.3 缺省参数分类</h2>\n<h3 id=\"4.3.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\">4.3.1全缺省参数</h3>\n<p>所有参数都有默认参数</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nvoid Test(int a = 10, int b = 20, int c = 30)\n{\n\tcout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl;\n}\nint main()\n{\n\tTest(); // 没有传参时，使用参数的默认值\n\tTest(10); // 传参时，使用指定的实参\n}</code></pre>\n<p>那我们在看这段代码</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nvoid Test(int a = 10, int b = 20, int c = 30)\n{\n\tcout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" b = \" &lt;&lt; b &lt;&lt; \" c = \" &lt;&lt; c &lt;&lt; endl;\n}\nint main()\n{\n\tTest(); // 没有传参时，使用参数的默认值\n\tTest(100); // 传参时，使用指定的实参\n\tTest(100, 200);\n\tTest(100, 200, 300);\n}</code></pre>\n<p>这里Test(100);和Test(100, 200, 300);我们都知道第一个替换和全部替换，那为啥Test(100, 200);</p>\n<p>结果是100 200 30 不是 100 200 10呢？</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\7e6ec2ab3f634bb7878dcc86558a74b0.png\"/></p>\n<p> 这里先卖个关子不知道大家知道 __cdecl (下面会说)</p>\n<h3 id=\"4.3.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0\">4.3.2半缺省参数</h3>\n<p>从右往左依次给出默认值</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nvoid Test(int a, int b = 10, int c = 20)\n{\n\tcout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl;\n}\nint main()\n{\n\tTest(10);\n}</code></pre>\n<p><strong>注意</strong></p>\n<p>1. 半缺省参数必须从右往左依次来给出，不能间隔着给（下面会说）</p>\n<p>2. 缺省参数不能在函数声明和定义中同时出现</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\9d7b7774591248c68c46096caaf95a86.png\"/></p>\n<p> 如果声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那<br/> 个缺省值，所以声明和定义不能一起出现。</p>\n<p>3. 缺省值必须是常量或者全局变量</p>\n<h3 id=\"4.3.4%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A\">4.3.4 函数调用约定</h3>\n<p>给定以下代码</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint Test(int a = 10, int b = 20, int c = 30)\n{\n\tcout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" b = \" &lt;&lt; b &lt;&lt; \" c = \" &lt;&lt; c &lt;&lt; endl;\n\treturn a + b + c;\n}\nint main()\n{\n\tint ret =Test(100, 200, 300);\n\tTest(100, 200, 300);\n\n\treturn 0;\n}</code></pre>\n<p>__cdecl 这个其实是函数的调用约定，在msvc中C和C++函数调用约定都是__cdecl。</p>\n<p>__cdecl调用约定又称为 C 调用约定，是 C/C++ 语言缺省的调用约定。参数按照从右至左的方式入栈，函数本身不清理栈，此工作由调用者负责，返回值在eax中。由于由调用者清理栈，所以允许可变参数函数存在</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_17,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\a733bbe9fd2345e785c8b3feee89b9fd.png\"/></p>\n<p> 我们可以清晰的看到 他把把返回值放在eax寄存器里面</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\0f76c35d315141ed91b79c6d9a9acfd8.png\"/></p>\n<p>我们在汇编代码可以清晰到是由右向左依次入栈的 ，所以我们在给默认值的时候，必须是从右向左依次给的，如果不然那函数就不知道把谁压栈。</p>\n<p>函数调用约定有很多在此就不一一赘述</p>\n<h1 id=\"5.%C2%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">5.  函数重载</h1>\n<p>重载？啥是重载呢？就好比是一个次在不同语境下会有不同的含义，比如说 菊花，鸹貔，老司机，这一类的词，我们就说他被重载了。</p>\n<h2 id=\"5.1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5\">5.1函数重载概念</h2>\n<p>函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint Add(int left, int right)\n{\n\treturn left + right;\n}\n\ndouble Add(double left, double right)\n{\n\treturn left + right;\n}\n\ndouble Add(int left, double right)\n{\n\treturn left + right;\n}\n\nint main()\n{\n\tcout &lt;&lt; Add(10, 20) &lt;&lt; endl;\n\tcout &lt;&lt; Add(1.2, 3.4) &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p>调用这Add函数每次根据传入的实参的类型不同，系统找到与之相应的入口参数进行匹配从而实现一个函数多种用途，也就是我们的重载。所以我们根据以上例子就可以得出函数重载的条件：</p>\n<ol><li>必须在同一个作用域下。</li><li>函数名相同。</li><li>参数数据类型不同，个数不同，顺序不同。</li></ol>\n<p>函数返回值不可以作为重载条件！</p>\n<h2 id=\"5.2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86\">5.2函数重载的原理</h2>\n<ol><li>编译器在编译的时候，会对传递的实参类型进行推演，然后根据推演的结果选择合适的函数进行调用，如果是完全参数类型都是匹配的，则直接调用。</li><li>如果不能进行完全匹配，则编译器会进行隐式类型转换，如果转换之后还没有合适的函数进行调用则报错，反之若有合适的函数则进行调用。</li></ol>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\04b893c9a2aa43aebca07d8e4f794562.png\"/></p>\n<p> 这个例子就很好的说明了发生了隐式类型转换，我传了2个参数一个int 一个 double int可以转换为double double 可以转换为int 这个时候编译器就不知道该调谁了，给你报错有两个相似的转换。</p>\n<p>回到刚刚那个问题函数返回值不能作为重载的条件，我隐式类型转换，且匹配成功但是有两个函数返回值是不一样样，翻译器也不知调用谁。</p>\n<h2 id=\"5.3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">5.3函数重载的底层实现原理</h2>\n<p> 为什么C语言不可以实现函数重载而C++可以呢？</p>\n<p>首先我们回顾一下C和C++编译器的处理方式，预处理，编译，汇编，链接。</p>\n<h3 id=\"5.3.2%20C%2FC%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\">5.3.2 C/C++编译器的处理方式</h3>\n<ol><li>预处理 ：头文件展开，宏替换，去注释，条件编译。</li><li>编译 : 将预处理后的源文件转换为汇编语言文件，只编译源文件，不编译头文件，头文件在刚刚预处理阶段已经展开。</li><li>汇编 ： 虽然叫做汇编，但是不是转变为汇编代码，而是将刚刚的汇编语言文件转换为机器码，也就是二进制文件。</li><li>链接 ：将生成的二进制代码与库函数以及其他目标文件，通过链接器链接起来形成可执行文件的过程。</li></ol>\n<p>对于这块不熟悉可看之前的一篇文章</p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/qq_50119037/article/details/123424389?spm=1001.2014.3001.5501\" title=\"C语言 程序的翻译 预处理 编译 汇编 链接 #define详解\">C语言 程序的翻译 预处理 编译 汇编 链接 #define详解</a></p>\n<p>C语言编译器的处理方式</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\2c29e164505e433d84562ff596764b26.png\"/></p>\n<p>这时候光声明没定义，给你报错报的是链接错误就是你这函数没有定义，我编译器找不到他的入口地址，但是你的名字不是add吗前面这个_add 是啥。</p>\n<p>C++编译器处理方法</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\99a8c784e4444967af2b1da8abde1669.png\"/></p>\n<p>我这边也没有定义， 这个？add@@YAHHH@Z  ，？add@@YAHNH@Z  ,？add@@YAHNN@Z  是啥意思呀？</p>\n<p>说明编译器在把函数名修改了！这里我们在谈到名字修饰的问题。</p>\n<h3 id=\"5.3.3%20%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0\">5.3.3 名字修饰</h3>\n<ol><li>编译器需保证每个函数的实体名称唯一，防止名字污染，而为每个函数名进行修饰;</li><li>编译器在链接时，当出现调用函数，就是通过修饰后的实体函数名来进行查找的，不同编译器不同语言的修饰规则不同。</li></ol>\n<p>C语言的修饰规则就是简单在下面加上下划线。</p>\n<p>在MSVC编译器下修饰规则则是这样的</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\8044e3c897df4a89bdac1edccc420c16.png\"/></p>\n<p>我们再在Linux g++ 下面看一下</p>\n<p>Linux是开源的他的方式方法就很好让人读懂没有MSVC这么诡异</p>\n<p>C</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_11,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\68bf683ea4ea4d01b1cf22bf35d88284.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\3950024bf8e04af68c7fa92eb43bb99c.png\"/></p>\n<p>没有做啥修饰就是单纯函数名字 </p>\n<p>C++</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_14,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\54c24d1c33194aaeb727b76bf7fa3ec4.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\1f3a577de5a840b3b29e40e4685a5de3.png\"/></p>\n<p> 对于C++就是_z3指的是函数名字占三个字符，add就是函数名字，后面俩就是参数类型，i就是int，d就是double。 </p>\n<p>我们在回到刚才那个问题 ，为什么有名字修饰，为什么C语言不能进行函数重载？</p>\n<ol><li> .c或者.cpp文件，需要在编译器经过预处理 编译 汇编 链接 生成可执行文件，才能让计算机直接运行，而操作系统会在编译环节堆程序里的函数进程 名字修饰以便识别查找；</li><li>  C语言的所有编译器对进程函数的名字修饰并不涉及参数，只能通过函数名对不同的函数进行区分，故C语言不支持函数重载；</li><li>  C++的编译器对其函数进行的名字修饰会将参数类型包括，故C++支持函数重载</li><li> 链接阶段是通过经过修饰的函数名字找他的入口地址，而修饰规则跟他参数列表的参数类型有关，跟函数返回值没有关系，因此函数返回值不可以作为重载条件。<br/>  </li></ol>\n<h2 id=\"5.4%20extern%20%E2%80%9C%20C%20%E2%80%9D\">5.4 extern “ C ”</h2>\n<p>假设一个情景在一个公司做开发，有人熟悉C语言，有人熟悉C++那怎么办呢？</p>\n<p>在C++中可以使用extern “ C ”修饰一个函数，则是告诉编译器修饰函数按照C语言的风格编译.</p>\n<p>在拿刚刚那个链接错误举例子来看。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nextern \"C\" int add(int left, int right);\n\nint main() {\n\tint ret = add(1, 2);\n\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\17de5d524ae3408ea5f94c89fbd36e8a.png\"/></p>\n<p>明显发现这是浓烈的C语言风格，函数名称前面加了个下划线来进行修饰。 </p>\n<p>其实extern不是这样使用的一般是我们创建库的时候使用的。</p>\n<p>这里演示一下VS2022静态库的创建以及使用。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\0489d7629d3446f1b710169fa8b1c831.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\8c0b9d1339b749a49d945c3b7836a695.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\7daff0bc970d4da19d1c8c82b896d43d.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\778ff95569c546f798b07966670bff99.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\a4379b80a4d14e3b92fbe05d6f310d1a.png\"/></p>\n<p>就可以看见是一个静态库了。</p>\n<p>生成解决方案后就可以在目录中找到了</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\a37753a89a8e47c9b6ce85f4d9293840.png\"/></p>\n<p>找到刚刚 工程那个文件把静态库拷贝进去</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\79bfa92633bd43c5a06aa757a8046780.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\c52df3ffc484405391ae82dfbf3e6676.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\9c4a037241614415b5197d4b9bfabb58.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\9006b350f63341cbb8c5e08cdec836ed.png\"/>我们在把他用起来</p>\n<p></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n//刚刚的静态库文件\n#include\"testlib.h\"\n\n//预处理命令把静态库引进来\n// .\\是当前目录然后\\转义字一下..\\是当前目录的上一级目录\n#pragma comment (lib,\".\\\\..\\\\Debug\\\\lib\\\\testlib.lib\")\n\n\nint main() {\n\tcout &lt;&lt; add(1, 2) &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\c2c061fcf4f44708abb8c3758a227e2f.png\"/></p>\n<p> 我现在是C++写的静态库我C++当然可以用，那我现在创建一个C语言的工程呢?</p>\n<p>我现在在C程序里面调add函数，就发现报错了。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\0e3d0ce5c1764a0d87a4519e284200fe.png\"/></p>\n<p>这时候就该用到extern “ C ”了</p>\n<pre><code class=\"language-cpp\">#pragma once\n\n\n#if __cpluscplus\n\nextern \"C\"\n{\n#endif\n\n\tint add(int left, int right);\n\tint sub(int left, int right);\n\tint mul(int left, int right);\n    int div(int left, int right);\n#if __cpluscplus\n}\n#endif</code></pre>\n<p> 条件编译一下就好了。</p>\n<h1 id=\"6.%20%E5%BC%95%E7%94%A8\">6. 引用</h1>\n<h2 id=\"6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5\">6.1引用的概念</h2>\n<p>引用不是新定义的一个变量，而是给已经存在的变量起了一个别名，编译器不会给他开辟内存空间，他和他的引用变量共用一个内存空间。张三，他也可以被叫做法外狂徒。</p>\n<p>我们来看之前C语言这个例子。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\n//void swap(int a, int b) {\n//\tint temp = a;\n//\ta = b;\n//\tb = temp;\n//}\nvoid swap(int *a, int *b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\nvoid swap(int&amp; a, int&amp; b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tswap(a, b);\n\tcout &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; b &lt;&lt; endl;\n}</code></pre>\n<p>在C++里面新增了引用类型，也可以做到！</p>\n<h2 id=\"6.2%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95\">6.2引用的语法</h2>\n<p>类型&amp; 引用变量名(对象名) = 引用实体<br/>  </p>\n<pre><code class=\"language-cpp\">void Test()\n{\n    int a = 10;\n    int&amp; ra = a;\n    printf(\"%p\\n\", &amp;a);\n    printf(\"%p\\n\", &amp;ra);\n}</code></pre>\n<h2 id=\"6.3%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7\">6.3引用的特性</h2>\n<ol><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦引用一个实体，再不能引用其他实体</li></ol>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\8191d9e56b3c425e94653db200ea44f6.png\"/></p>\n<p> 很明显验证了编译器不会给他开辟内存空间，他和他的引用变量共用一个内存空间。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\c31afb2bf989406eb1ac0e19a168e6fd.png\"/></p>\n<p> 一个变量可以有多个引用，这几个全是一个货，地址都一样，我rrra一改全改了。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\dd5afe202ca846e9b945caa3b0acd3ad.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\90586ec6fa574b8db1af5b31a2637043.png\"/></p>\n<p> 引用一旦引用一个实体，再不能引用其他实体，后面会说。</p>\n<h2 id=\"6.4%20%E5%B8%B8%E5%BC%95%E7%94%A8\">6.4 常引用</h2>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_11,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\7fb4bc389bff44909c7760a7033a57b5.png\"/><img alt=\"88016ff6bb684ef1beded31443dadae6.png\" src=\"..\\..\\static\\image\\88016ff6bb684ef1beded31443dadae6.png\"/></p>\n<p>· 在C语言里面一个变量被const修饰之后他就是一个不可以被修改的变量,而在C++里面一个变量被const修饰之后就是一个常量了，我给个数组把a丢进去也是可行的充分说明这时候a就是一个常量。</p>\n<p>那我现在去给他来个引用，就会发现报错了！</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\9491899b6b284b9aab4ea9ee88c15e96.png\"/></p>\n<p>再来看这个例子</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_10,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\b326d3686ec749dfaecffde83c8e31b5.png\"/></p>\n<p>刚刚说过引用必须引用的是一个实体跟引用实体类型相同，但是我们加const就可以，而且按理说我把a修改了ra应该也变呀，我们来看一下。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\9083916f3fd74121b13f4a945e01f85d.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\20542298c15041da9baf2af1a8ffa904.png\"/></p>\n<p>不仅a和ra没变，而且这个ra不是a的引用，他俩地址都不一样，说明ra就不是a的引用那是谁的引用呢？</p>\n<p>你引用整形的，编译器就是会知道要发生隐式类型转换，编译器把12放在一个临时变量里面，你不知道变量的名字，也不知道他的地址空间，他的地址空间也没有名字，你不可以读也不可以写，说明这个东西具有常性，相当于你引用的是一个常量，那你不加const咋行呢？</p>\n<h2 id=\"6.5%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8\">6.5引用的应用</h2>\n<h3 id=\"6.5.1%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7\">6.5.1简化代码增加可读性</h3>\n<p>还是那个swap的例子</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nvoid swap(int** a, int** b) {\n\tint* temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n//有了引用就可以这样做\nvoid swap(int*&amp; a, int*&amp; b) {\n\tint* temp = a;\n\ta = b;\n\tb = temp;\n}\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tint* pa = &amp;a;\n\tint* pb = &amp;b;\n\tswap(&amp;pa, &amp;pb);\n\tswap(pa, pb);\n}</code></pre>\n<p>这样子代码的可读性增加了，引用其实可以代替一级指针（引用的本质......），可以吧指针简化一部分。</p>\n<h3 id=\"6.5.2%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7\">6.5.2增加代码的安全性</h3>\n<p>不想通过形参改变外部实参可以加一个常引用</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\ntypedef struct Stack\n{\n\tint* array;\n\tint size;\n\tint capacity;\n}Stack;\n\n// 如果引用类型作为函数的形参，尽量传递引用\n// 如果不想通过形参修改外部实参，将引用给成const类型的引用\nint StackSize(const Stack&amp; s)\n{\n\t// s.size = 100;\n\treturn s.size;\n}\n\nint main()\n{\n\tStack s;\n\n\t//....进行一系列压栈操作之后，栈中有5个元素\n\ts.size = 5;\n\tcout &lt;&lt; StackSize(s) &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<h3 id=\"6.5.3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B\">6.5.3作为函数的返回值类型</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n// 3. 作为函数的返回值类型\n//int&amp; Add(int left, int right)\n//{\n//\tint temp = left + right;\n//\tcout &lt;&lt; &amp;temp &lt;&lt; endl;\n//\treturn temp;\n//}\nint temp = 0;\n\nint&amp; Add(int left, int right)\n{\n\ttemp = left + right;\n\tcout &lt;&lt; &amp;temp &lt;&lt; endl;\n\treturn temp;\n}\n\n// 注意：如果以引用方式作为函数的返回值类型，不能返回函数栈上的空间\n// 如果要返回，返回的实体必须要比函数的声明周期长，即函数结束了，返回的实体依然存在\nint main()\n{\n\tint&amp; ret = Add(10, 20);\n\tAdd(20, 30);\n\tAdd(30, 40);\n\treturn 0;\n}</code></pre>\n<p>这个例子来想一下这个ret会是多少呢？</p>\n<p>走着</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\dbd7b7aa521b4ea391e8bda1ddf019ee.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\8de312af4b6545aa88348dd9fbb6c65d.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\2ebe25d73c014421b2157d0e04fbe184.png\"/></p>\n<p> 他这个引用的是啥呀咋就给变了。</p>\n<p>来上汇编！</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\e499e1bafd074f2cb56d62323d65e5e2.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\8c5e06cbc58c4dc1b8cc3ce80d4c639b.png\"/></p>\n<p>他引用的其实是临时变量的地址。</p>\n<p>这里就要根据汇编语言来了解函数的调用过程</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\6839f8bc6c0048c5a180c9ab6f1e4f93.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"..\\..\\static\\image\\00b4d595b3c1476c9ad1c686cf21b7e6.png\"/></p>\n<p>当add函数结束调用后esp 和 ebp也回到原来位置，add函数对应的栈帧已经被系统回收了 ，即add对应的栈帧的空间不能使用了，但是空间还在而且add运行完成之后留下的垃圾数据也在，我的ret引用的是temp那个空间下次调用add就会把原来的垃圾数据覆盖掉，返回后空间还是在的，以此类推，编译的时候就会给你一个警告，你引用的其实是局部变量的地址，你一解引用访问的就是非法的地址！</p>\n<p>注意：如果以引用方式作为函数的返回值类型，不能返回函数栈上的空间。<br/> 如果要返回，返回的实体必须要比函数的声明周期长，即函数结束了，返回的实体依然存在。</p>\n<h2 id=\"6.6%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB\">6.6 引用和指针的区别</h2>\n<h3 id=\"6.6.1%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB\">6.6.1 底层实现区别</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n\tint a = 10;\n\tint* p = &amp;a;\n\t*p = 20;\n\n\tint&amp; ra = a;\n\tra = 30;\n}</code></pre>\n<p><img alt=\"\" height=\"272\" src=\"..\\..\\static\\image\\f94da3e93f194929bf4d40ae8ffde69b.png\" width=\"587\"/></p>\n<p> <img alt=\"\" height=\"221\" src=\"..\\..\\static\\image\\8bdd008257c34babb1388d859cecfdbb.png\" width=\"569\"/></p>\n<p> 这俩好家伙一模一样，那就是说明引用的底层实现就是按照指针的方式实现的，在底层引用就是指针常量(一旦引用一个实体，就不能引用其他实体)</p>\n<p>引用其实是有空间的，在概念层面上说， 引用就是起别名，编译器不会为引用变量开辟新的内存空间，引用的变量和引用的实体用的是同一份空间，但是其实在底层引用是有空间的，他就是指针呀，在底层跟指针没有任何区别。</p>\n<h3 id=\"6.6.2%20%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB\">6.6.2 使用区别</h3>\n<p>1.有NULL指针但是没有NULL引用。</p>\n<p><img alt=\"\" height=\"366\" src=\"..\\..\\static\\image\\759ccc11a8354ef8bf17346658f4253c.png\" width=\"444\"/></p>\n<p>这个NULL就是一个宏呀,是一个常量当然不能放在引用旁边。 </p>\n<p>2.引用一旦引用一个实体就不能在引用其他实体。打码机指针可以任何时间指向同一个类型的实体。</p>\n<p>其实就是好比char * 跟 char * const 的区别</p>\n<p>3.指针初始化没有任何要求，可以随便指，只不过我们一般让他指向NULL，但是对与引用在使用的时候必须初始化。</p>\n<p>4.引用++是给引用后的实体++,而指针++是+上其所指向类型的大小。</p>\n<p>5.有多级指针但是没有多级引用。</p>\n<p>6.在sizeof里面含义不一样，sizeof（引用）结果是的引用类型的大小，sizeof（指针）在64位下是8，32位下是4。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n\tint a = 10;\n\tdouble b = 12.34;\n\n\tdouble* p1 = &amp;b;\n\tint* p2 = &amp;a;\n\n\tint&amp; ra = a;\n\tdouble&amp; rb = b;\n\n\tcout &lt;&lt; sizeof(p1) &lt;&lt; endl;\n\tcout &lt;&lt; sizeof(p2) &lt;&lt; endl;\n\tcout &lt;&lt; sizeof(ra) &lt;&lt; endl;\n\tcout &lt;&lt; sizeof(rb) &lt;&lt; endl;\n\n}</code></pre>\n<p><img alt=\"\" height=\"609\" src=\"..\\..\\static\\image\\db83611a17d84bd29dd40700c4f347dc.png\" width=\"611\"/></p>\n<p> <img alt=\"\" height=\"554\" src=\"..\\..\\static\\image\\7a97f7c2317f48a5a01908c74c2a047c.png\" width=\"586\"/></p>\n<p> 7. 访问实体不同，指针需要解引用，引用编译器自己处理。</p>\n<h1 id=\"7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\">7. 内联函数</h1>\n<h2 id=\"7.1%20%23define%20%E5%AE%8F\">7.1 #define 宏</h2>\n<p>还记得在C语言里面的宏  #define  吗？</p>\n<p>在你的文本文件变成可执行文件编译器处理的时候，第一步就是预处理，预处理会进行，头文件展开，去注释，条件编译，和宏替换，以为是在预处理进行的替换，那他会出一些奇奇怪怪的错误。</p>\n<h3 id=\"7.1.1%C2%A0%20%E5%AE%8F%E5%B8%B8%E9%87%8F\">7.1.1  宏常量</h3>\n<p>那我们一般对于数字进行宏替换的时候要加；吗？</p>\n<pre><code class=\"language-cpp\">#define MAX 1000;\n#define MAX 1000</code></pre>\n<p>在Linux底下看看预处理完的文件</p>\n<p><img alt=\"\" height=\"214\" src=\"..\\..\\static\\image\\e9661a9cc8b24d2ba0ef4894c38d7dbd.png\" width=\"224\"/></p>\n<p>再举个例子在上文 我们刚刚谈到了const 修饰 一个变量在C++跟 C语言不同 </p>\n<p>C语言 const修饰就是原本这个变量变成了一个不可修改的常量。</p>\n<p>C++中const修饰就是原本这个变量变成了一个常量。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \n//在C++中 const修饰的内容已经是一个常量了\n// 在C语言中，const修饰的内容是一个不可以被修改的变量\nint main()\n{\n\tconst int MAX_SIZE = 100;\n\tint array[MAX_SIZE];\n\treturn 0;\n}</code></pre>\n<p>按理说我通过指针已经把a的内容修改了，不是应该是100吗？为啥是10？</p>\n<p>const修饰的内容不仅仅是一个常量，而且还具有宏替换的效果，并且替换发生在编译时。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \n// const修饰的内容不仅仅是一个常量，而且还具有宏替换的效果\n// 并且替换发生在编译时\nint main()\n{\n\tconst int a = 10;\n\n\tint* pa = (int*)&amp;a;  \n\t*pa = 100;\n\n\tcout &lt;&lt; a &lt;&lt; endl; \n\tcout &lt;&lt; *pa &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p> <img alt=\"\" height=\"532\" src=\"..\\..\\static\\image\\d9dbd7308c4d4316adf2304c07dc9d74.png\" width=\"1078\"/></p>\n<h3 id=\"7.1.2%20%E5%AE%9A%E4%B9%89%E5%AE%8F\">7.1.2 定义宏</h3>\n<p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏。<br/> 下面是宏的申明方式：<br/> #define name( parament-list ) stuff其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。<br/> 注意：<br/> 参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分</p>\n<p>比如这个例子</p>\n<h2 id=\"%E2%80%8B\"><img alt=\"\" height=\"175\" src=\"..\\..\\static\\image\\932775c23a164e4585327eb5347a2875.png\" width=\"328\"/></h2>\n<p>我们原本想的是应该是11*11 结果是121 为啥是21呢，那就看看.i 文件看看到底宏替换哪块出问题了 </p>\n<h2><img alt=\"\" height=\"236\" src=\"..\\..\\static\\image\\190670abab6a44b4a9b44f94d29c354e.png\" width=\"851\"/></h2>\n<p>原来是替换之后根据运算符号的先后顺序所以结果是21那么怎样去避免这个问题呢我们在宏定义的时候这样去做 </p>\n<pre><code class=\"language-cpp\">#define sq(x) (x)*(x)</code></pre>\n<h2><img alt=\"\" height=\"200\" src=\"..\\..\\static\\image\\aff92ee3abe549a7abd9137937a96859.png\" width=\"296\"/></h2>\n<p> 不是按理来说应该是110吗咋变成1210了那我们再看看.i文件</p>\n<h2><img alt=\"\" height=\"366\" src=\"..\\..\\static\\image\\1e1a8a652cb64f2e8550c745c08d2fa5.png\" width=\"1200\"/></h2>\n<pre><code class=\"language-cpp\">#define sq(x) ((x)*(x))</code></pre>\n<p>带参宏就会有很多很多的问题在替换中提现到那只能尽可能的加（）来避免操作顺序带来的问题</p>\n<p>尽量不要使用这种带参数的</p>\n<p>但是却省掉了很多函数调用的开销，参数压栈，开辟栈帧等一些列操作，运行效率高，他就是简单的替换！</p>\n<h3 id=\"7.1.3%20%E5%AE%8F%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99\">7.1.3 宏的替换规则</h3>\n<p>        1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。<br/>         2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。<br/>         3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。<br/> 注意：<br/>         1. 宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归。<br/>         2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。</p>\n<h3 id=\"7.1.4%20%E5%AE%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">7.1.4 宏的优缺点</h3>\n<p>优点：<br/>         1.增强代码的复用性。<br/>         2.提高性能。<br/> 缺点：<br/>         1.不方便调试宏。（因为预编译阶段进行了替换）<br/>         2.导致代码可读性差，可维护性差，容易误用。<br/>         3.没有类型安全的检查 。</p>\n<p>但是宏的缺点还是很多的C++为了解决就提出了内联函数。</p>\n<h2 id=\"7.2%20%E6%A6%82%E5%BF%B5\">7.2 概念</h2>\n<p> 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n \ninline int Add(int left, int right)\n{\n\treturn left + right;\n}\n\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint ret = Add(a, b);\n\tcout &lt;&lt; ret &lt;&lt; endl;\n\n\n\treturn 0;\n}</code></pre>\n<p>那他是怎样展开的呢？让我们再来看看汇编代码。</p>\n<p><img alt=\"\" height=\"654\" src=\"..\\..\\static\\image\\b6c204ddb789425fa47a28759d100598.png\" width=\"649\"/></p>\n<p>这一看没有展开呀 我call指令把这个当函数调用了，因为我们是在Debug模式下为了调试，如果展开了就不能调试了，在Debug模式下用户要进行调试。</p>\n<p><img alt=\"\" height=\"610\" src=\"..\\..\\static\\image\\11c4c4cbc55646e58171161108e42c08.png\" width=\"553\"/></p>\n<p> 发现就根本没有调用函数，直接把1Eh也就是30直接给打印了，就不用调用函数，也不需要参数压栈，开辟栈帧，那一系列的操作了。</p>\n<p>那我要看展开没有那就得设置一下编译器。</p>\n<p><img alt=\"\" height=\"895\" src=\"..\\..\\static\\image\\b85f60fcf8824baeb3d6af04e888004d.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"692\" src=\"..\\..\\static\\image\\f9a6e18d3aad46b6be666889537a4378.png\" width=\"1000\"/></p>\n<p><img alt=\"\" height=\"692\" src=\"..\\..\\static\\image\\914f0200d29a4589b5fac7a0dddcab40.png\" width=\"1000\"/></p>\n<p>就可以了 </p>\n<p> <img alt=\"\" height=\"669\" src=\"..\\..\\static\\image\\0e64b1d6ef20467ba14367e44f478614.png\" width=\"820\"/></p>\n<h2 id=\"%C2%A07.3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"> 7.3注意事项</h2>\n<p>        1. inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。</p>\n<p>        2. inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\ninline int Add(int left, int right)\n{\n\tAdd(left,right);\n\treturn left + right;\n}\n\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint ret = Add(a, b);\n\tprintf(\"&amp;d\", ret);\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"664\" src=\"..\\..\\static\\image\\54047a3f89434e2b893d8e6f71471df9.png\" width=\"781\"/><br/>         3. inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。</p>\n<p></p>\n<p><strong>持续更新中...........</strong></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-05-02 12:15:25", "summary": "目录关键字命名空间作用域规则命名空间定义命名空间使用加作用域限定符使用关键字将命名空间引入使用命名空间名称引入输入和输出缺省参数和函数的区别缺省参数概念缺省参数概念缺省参数分类全缺省参数半缺省参数函数"}