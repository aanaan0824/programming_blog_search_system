{"blogid": "124668114", "writerAge": "码龄1年", "writerBlogNum": "10", "writerCollect": "10", "writerComment": "4", "writerFan": "13", "writerGrade": "2级", "writerIntegral": "108", "writerName": "求你了快睡吧", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124668114.jpg", "writerRankTotal": "127867", "writerRankWeekly": "695093", "writerThumb": "4", "writerVisitNum": "8703", "blog_read_count": "1383", "blog_time": "于 2022-05-09 17:23:07 发布", "blog_title": "thinkPHP6+workerman即时通讯小demo", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>上次我们说到js定时异步请求模仿实时通讯。</p>\n<p>本次我们就来讲下另一种即时通讯，workerman+tp6</p>\n<p>环境：tp6(5也可以)，workerman插件，composer，apipost(接口测试软件)</p>\n<p>首先执行以下代码安装workerman</p>\n<pre><code>composer require topthink/think-worker`</code></pre>\n<p>安装好之后</p>\n<p>在项目路径下的cofing 文件下找到 config/worker_server.php</p>\n<pre><code>   'protocol'       =&gt; 'websocket', // 协议 支持 tcp udp unix http websocket text\n    'host'           =&gt; '0.0.0.0', // 监听地址\n    'port'           =&gt; 2346, // 监听端口\n    'socket'         =&gt; '', // 完整监听地址\n    'context'        =&gt; [], // socket 上下文选项\n    'worker_class'   =&gt; 'app\\man\\Worker', // 自定义Workerman服务类名 支持数组定义多个服务</code></pre>\n<p>只需要修改里面对应的参数即可，‘worker_class’可以是多个，需要使用逗号分隔开，也可以写成数组，路径需要写我们的类的绝对路径，不需要带后缀。</p>\n<p>worker类代码如下</p>\n<p><img alt=\"\" height=\"765\" src=\"..\\..\\static\\image\\be35ed1ed046470887d51256421f048d.png\" width=\"1200\"/></p>\n<p> </p>\n<pre><code class=\"language-php\">&lt;?php\nnamespace app\\man;\nuse think\\facade\\Db;\nuse think\\worker\\Server;\nuse Workerman\\Lib\\Timer;\ndefine('HEARTBEAT_TIME', 20);// 心跳间隔\n \nclass Worker extends Server\n{\n\t    protected $socket = 'http://0.0.0.0:2346';   //端口自行修改\n\t \n\t    protected static $heartbeat_time    =   55;  //心跳55,秒\n\t \n\t \n\t    public function onWorkerStart($worker){\n\t        //查看是否有新的充值或提现订单，有就推送给所有用户\n\t        Timer::add(3, function()use($worker){\n\t \n\t            $time_now   =   time();\n\t            $hasNewDepositOrder   =   Db::name('deposit_order')-&gt;where('order_status',0)-&gt;where('is_push',0)-&gt;order('id desc')-&gt;count('id');\n\t            // $system_listener    =   Db::name('system_listener')-&gt;cache(true)-&gt;order('id desc')-&gt;select()-&gt;toArray();\n\t \n\t            if($hasNewDepositOrder){\n\t                $depositOrderInfo   =   Db::name('deposit_order')-&gt;where('order_status',0)-&gt;where('is_push',0)-&gt;order('id desc')-&gt;find();\n\t                // $data   =   ['creatTime'=&gt;$depositOrderInfo['create_time'],'money'=&gt;$depositOrderInfo['pay_amount'],'type'=&gt;'deposit','system_listener'=&gt;$system_listener];\n\t                $data   =   ['creatTime'=&gt;$depositOrderInfo['create_time'],'money'=&gt;$depositOrderInfo['pay_amount'],'type'=&gt;'deposit'];\n\t                \n\t                foreach($worker-&gt;connections as $connection) {\n\t                    if(empty($connection-&gt;lastMessageTime)){\n\t                        $connection-&gt;lastMessageTime =   $time_now;\n\t                    }\n\t \n\t                    if($time_now-$connection-&gt;lastMessageTime &gt; self::$heartbeat_time){\n\t                        $connection-&gt;close();\n\t                    }\n\t                $connection-&gt;send(json_encode($data));\n\t                }\n\t \n\t               Db::name('deposit_order')-&gt;where('id',$depositOrderInfo['id'])-&gt;save(['is_push'=&gt;1]);\n\t            }else{\n\t                foreach($worker-&gt;connections as $connection) {\n\t                    if(empty($connection-&gt;lastMessageTime)){\n\t                        $connection-&gt;lastMessageTime = $time_now;\n\t                        continue;\n\t                    }\n\t \n\t                    if($time_now-$connection-&gt;lastMessageTime &gt; self::$heartbeat_time){      //连接超时\n\t                        $connection-&gt;close();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t}\n\t</code></pre>\n<p>头部引入我们必须的几个类，定义好命名空间</p>\n<p>下面的成员变量配置我们的端口以及心跳时间，函数内就是封装我们的自己的逻辑。</p>\n<p>重新启动wokkerman</p>\n<pre><code>php think worker:server start 开启\n\nphp think worker:server stop  结束\n\nphp think worker:server status  查看状态</code></pre>\n<p>然后随便进入一个页面，这里需要注意的是在tp6中需要引入view类，否则有可能报错找不到</p>\n<blockquote>\n<p>use think\\facade\\View;</p>\n</blockquote>\n<h1 id=\"articleContentId\">Driver [Think] not supported  报错解决</h1>\n<p>将view删除，运行</p>\n<blockquote>\n<p>composer require topthink/think-view</p>\n</blockquote>\n<p>再新建view文件夹，还需要开启777权限，这是博主遇到的真实问题。</p>\n<p>页面建好后，我们页面内写</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\t&lt;head&gt;\n\t\t&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;\n\t\t&lt;title&gt;Title&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;script&gt;\n\t\t\tvar lockReconnect = false; //避免ws重复连接\n\t\t\tvar ws = null; // 判断当前浏览器是否支持WebSocket\n\t\t\tvar wsUrl = \"ws:服务器ip:端口号\";\n\t\t\tcreateWebSocket(wsUrl); //连接ws\n \n\t\t\tfunction createWebSocket(url) {\n\t\t\t\ttry {\n\t\t\t\t\tif ('WebSocket' in window) {\n\t\t\t\t\t\tws = new WebSocket(url);\n\t\t\t\t\t}\n\t\t\t\t\tinitEventHandle();\n\t\t\t\t} catch (e) {\n\t\t\t\t\treconnect(url);\n\t\t\t\t\tconsole.log(e);\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tfunction initEventHandle() {\n\t\t\t\tws.onclose = function() {\n\t\t\t\t\treconnect(wsUrl);\n\t\t\t\t\tconsole.log(\"llws连接关闭!\" + new Date().toLocaleString());\n\t\t\t\t};\n\t\t\t\tws.onerror = function() {\n\t\t\t\t\treconnect(wsUrl);\n\t\t\t\t\tconsole.log(\"llws连接错误!\");\n\t\t\t\t};\n\t\t\t\tws.onopen = function() {\n\t\t\t\t\theartCheck.reset().start(); //心跳检测重置\n\t\t\t\t\tconsole.log(\"llws连接成功!\" + new Date().toLocaleString());\n\t\t\t\t};\n\t\t\t\tws.onmessage = function(event) { //如果获取到消息，心跳检测重置\n\t\t\t\t\theartCheck.reset().start(); //拿到任何消息都说明当前连接是正常的\n\t\t\t\t\t// console.log(event);\n\t\t\t\t\tif (event.data != 'pong') {\n\t\t\t\t\t\tlet data = JSON.parse(event.data);\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t// 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n\t\t\twindow.onbeforeunload = function() {\n\t\t\t\tws.close();\n\t\t\t}\n \n\t\t\tfunction reconnect(url) {\n\t\t\t\tif (lockReconnect) return;\n\t\t\t\tlockReconnect = true;\n\t\t\t\tsetTimeout(function() { //没连接上会一直重连，设置延迟避免请求过多\n\t\t\t\t\tcreateWebSocket(url);\n\t\t\t\t\tlockReconnect = false;\n\t\t\t\t}, 2000);\n\t\t\t}\n \n\t\t\t//心跳检测\n\t\t\tvar heartCheck = {\n\t\t\t\ttimeout: 5000, //5秒发一次心跳\n\t\t\t\ttimeoutObj: null,\n\t\t\t\tserverTimeoutObj: null,\n\t\t\t\treset: function() {\n\t\t\t\t\tclearTimeout(this.timeoutObj);\n\t\t\t\t\tclearTimeout(this.serverTimeoutObj);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tstart: function() {\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tthis.timeoutObj = setTimeout(function() {\n\t\t\t\t\t\t//这里发送一个心跳，后端收到后，返回一个心跳消息，\n\t\t\t\t\t\t//onmessage拿到返回的心跳就说明连接正常\n\t\t\t\t\t\tws.send(\"ping\");\n\t\t\t\t\t\tconsole.log(\"ping!\");\n\t\t\t\t\t\tself.serverTimeoutObj = setTimeout(function() { //如果超过一定时间还没重置，说明后端主动断开了\n\t\t\t\t\t\t\tws\n\t\t\t\t\t\t.close(); //如果onclose会执行reconnect，我们执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次\n\t\t\t\t\t\t}, self.timeout)\n\t\t\t\t\t}, this.timeout)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t&lt;/script&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>因为上面是根据数据库的信息插入来进行判断了 所以我们通过结构去表中增加数据在前台的 onmessage 中就可以打印出来数据展示</p>\n<p>直接通过数据库的新增数据，就可以把对应的信息展示出来 具体逻辑就是worker.php中写的数据库展示逻辑</p>\n<p>然后到根目录启动workerman，看下具体的效果。</p>\n<p></p>\n<blockquote>\n<p>php think worker:server   启动</p>\n<p><img alt=\"\" height=\"275\" src=\"..\\..\\static\\image\\a43eeb480f2d49c9a105ec8baaa45fde.png\" width=\"1004\"/></p>\n<p> </p>\n</blockquote>\n<blockquote>\n<p><img alt=\"\" height=\"339\" src=\"..\\..\\static\\image\\22af125dab384e96bb8914c001efd8d9.png\" width=\"771\"/></p>\n</blockquote>\n<p> 然后看到ok了，再见。</p>\n<p><img alt=\"\" src=\"..\\..\\static\\image\\2f3abf7b212e4b18bf20a6b506165a82.png\"/></p>\n<p> </p>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2022-05-09 17:23:07", "summary": "上次我们说到定时异步请求模仿实时通讯。本次我们就来讲下另一种即时通讯，环境：也可以，插件，，接口测试软件首先执行以下代码安装安装好之后在项目路径下的文件下找到协议支持监听地址监听端口完整监听地址上下文"}