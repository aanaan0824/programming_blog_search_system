{"blogid": "126455954", "writerAge": "码龄1年", "writerBlogNum": "22", "writerCollect": "664", "writerComment": "912", "writerFan": "1421", "writerGrade": "5级", "writerIntegral": "2611", "writerName": "是Lay", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126455954.jpg", "writerRankTotal": "7782", "writerRankWeekly": "106", "writerThumb": "775", "writerVisitNum": "15292", "blog_read_count": "227", "blog_time": "于 2022-08-21 22:22:18 发布", "blog_title": "【Java基础】面向对象进阶(二)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"\" src=\"..\\..\\static\\image\\231bda16a01b4e3aab2f5b30e10c157e.png\"/>​<br/> ​</p>\n<p><strong>个人简介</strong></p>\n<blockquote>\n<p>&gt; 📦个人主页：<a href=\"https://blog.csdn.net/LKS_010620?type=lately\" title=\"是Lay的主页\">是Lay的主页</a><br/> &gt; 🏆学习方向：JAVA后端开发 <br/> &gt; 📣种一棵树最好的时间是十年前，其次是现在！<br/> &gt; ⏰往期文章：<a class=\"link-info\" href=\"https://blog.csdn.net/LKS_010620/article/details/126446245?spm=1001.2014.3001.5501\" title=\"【Java基础】面向对象进阶\">【Java基础】面向对象进阶</a><br/> &gt; 🧡喜欢的话麻烦点点关注喔，你们的支持是我的最大动力。</p>\n</blockquote>\n<p> </p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%20%E5%8C%85-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20%E5%8C%85\">1. 包</a></p>\n<p id=\"2.%20%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\">2. 权限修饰符</a></p>\n<p id=\"3.%20final-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20final\">3. final</a></p>\n<p id=\"4.%20%E5%B8%B8%E9%87%8F%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#4.%20%E5%B8%B8%E9%87%8F%C2%A0\">4. 常量 </a></p>\n<p id=\"5.%20%E6%9E%9A%E4%B8%BE-toc\" style=\"margin-left:40px;\"><a href=\"#5.%20%E6%9E%9A%E4%B8%BE\">5. 枚举</a></p>\n<p id=\"6.%20%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#6.%20%E6%8A%BD%E8%B1%A1%E7%B1%BB\">6. 抽象类</a></p>\n<p id=\"7.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%3A%20%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:40px;\"><a href=\"#7.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%3A%20%E5%A4%9A%E6%80%81\">7. 面向对象三大特征之三: 多态</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<blockquote>\n<p>活动地址：<a href=\"https://marketing.csdn.net/p/bdabfb52c5d56532133df2adc1a728fd\" title=\"CSDN21天学习挑战赛\">CSDN21天学习挑战赛</a></p>\n</blockquote>\n<h2 id=\"1.%20%E5%8C%85\">1. 包</h2>\n<p><strong>  1. 什么是包？</strong></p>\n<p>        1). 包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。</p>\n<p>        2). 建包的语法格式：package 公司域名倒写.技术名称。报名建议全部英文小写，且具备意义</p>\n<p>        3). 建包语句必须在第一行，一般IDEA工具会帮助创建</p>\n<p><strong>  2. 导包</strong></p>\n<p>       1). 相同包下的类可以直接访问，不同包下的类必须导包,才可以使用！导包格式：import 包名.类名;</p>\n<p>        2). 假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问。 </p>\n<h2 id=\"2.%20%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\">2. 权限修饰符</h2>\n<table align=\"left\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><caption>\n  权限修饰符速查表\n </caption><tbody><tr><td>修饰符</td><td>同类</td><td>同包</td><td>子类</td><td>不同包(无关类)</td></tr><tr><td>public</td><td>YES</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>protected</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>默认</td><td>YES</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>private</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table>\n<h2 id=\"3.%20final\">3. final</h2>\n<ol><li>final表示最终</li><li>被final修饰的类是最终类，也称作叶子结点，所以不能被继承</li><li>被final修饰的方法是这个方法的最终实现，不能被重写</li><li>被final修饰的是常量，值不可以被修改，注意常量定义时必须赋值</li></ol>\n<p><strong>final修饰变量的注意</strong></p>\n<p>final修饰的变量是基本类型：那么变量存储的数据值不能发生改变。</p>\n<p>final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。</p>\n<h2 id=\"4.%20%E5%B8%B8%E9%87%8F%C2%A0\">4. 常量 </h2>\n<p><strong>  1. 常量</strong></p>\n<p>        常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。</p>\n<p>        常量名的命名规范：英文单词全部大写，多个单词下划线连接起来。</p>\n<p><strong>  2. 常量做信息配置时的原理, 优势</strong></p>\n<p>        在编译阶段会进行“宏替换”：把使用常量的地方全部替换成真实的字面量。</p>\n<p>        维护系统容易，可读性更好。</p>\n<h2 id=\"5.%20%E6%9E%9A%E4%B8%BE\">5. 枚举</h2>\n<p><strong>  1. 枚举的概述</strong></p>\n<p>        枚举是Java中的一种特殊类型</p>\n<p>        枚举的作用：\"是为了做信息的标志和信息的分类\"。</p>\n<p><strong>  2. 定义枚举类的格式:</strong></p>\n<blockquote>\n<p>        修饰符  enum  枚举名称 {<!-- --></p>\n<p>                第一行都是罗列枚举类实例的名称</p>\n<p>        }</p>\n</blockquote>\n<blockquote>\n<p>                enum  Season {<!-- --></p>\n<p>                        SPRING , SUMMER , AUTUMN , WINTER;</p>\n<p>                }</p>\n</blockquote>\n<p><strong>  3. 枚举的特征:</strong></p>\n<p>        1). 枚举类都是继承了枚举类型：java.lang.Enum</p>\n<p>        2). 枚举都是最终类，不可以被继承。</p>\n<p>        3). 构造器都是私有的，枚举对外不能创建对象。</p>\n<p>        4). 枚举类的第一行默认都是罗列枚举对象的名称的。</p>\n<p>        5). 枚举类相当于是多例模式。</p>\n<h2 id=\"6.%20%E6%8A%BD%E8%B1%A1%E7%B1%BB\">6. 抽象类</h2>\n<p>        在Java中abstract是抽象的意思，可以修饰类、成员方法。</p>\n<p>        abstract修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法。</p>\n<blockquote>\n<p>                修饰符 abstract class 类名{     </p>\n<p>                        修饰符 abstract 返回值类型 方法名称(形参列表)；</p>\n<p>                }</p>\n</blockquote>\n<blockquote>\n<p>                        public abstract class Animal{        </p>\n<p>                                public abstract void run();</p>\n<p>                        }</p>\n</blockquote>\n<p>注意事项</p>\n<p>        抽象方法只有方法签名，不能声明方法体。</p>\n<p>        一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错。</p>\n<p>  1. 抽象的关键字是abstract<br/>   2. 被abstract修饰的方法是抽象方法，抽象方法没有方法体<br/>   3. 如果一个类中出现了一个抽象方法，那么这个类必须被abstract修饰<br/>   4. 关于抽象类的特点：<br/>         1）抽象类中的方法不做限制 ： 全普 / 全抽 / 半普半抽<br/>         2）如果一个类中的方法都是普通方法，还要声明成抽象类，为什么？<br/>         为了不让外界创建本类的对象<br/>         3）抽象类不可以创建对象，所以常用于多态<br/>         4）抽象类中包含构造方法，但是不是为了自己创建对象时使用，而是为了子类的super()<br/>         5）抽象类中也是可以定义成员变量的<br/>   5. 如果一个子类继承了一个抽象父类，有两种解决方案：<br/>         1）作为抽象子类：不实现/实现部分 抽象父类中的抽象方法 ： ”躺平”<br/>         2）作为普通子类：实现抽象父类中的所有的抽象方法 ： “父债子偿”<br/>   6. 面向抽象进行编程：后天重构的结果<br/> 案例:</p>\n<pre><code class=\"language-java\">package com.example.bbb;\n/*本类用于面向抽象编程的推导*/\npublic class DesignTeacher {\n}\n//3.抽取共性,向上形成父类\nabstract class Teacher{\n    String name;\n    int id;\n    public abstract void ready();\n    public abstract void teach();\n}\n\n//1.创建培优CGB老师类\n//业务:主打互联网架构与微服务\nclass CGBTeaher extends Teacher{\n    @Override\n    public void ready(){\n        System.out.println(\"正在备课:互联网架构与微服务\");\n    }\n    @Override\n    public void teach(){\n        System.out.println(\"正在讲课:互联网架构与微服务\");\n    }\n}\n//2.创建高手加薪班老师类\n//主打:基础加强 框架加强 高新技术\nclass ACTTeacher extends Teacher{\n    @Override\n    public void ready(){\n        System.out.println(\"正在备课:基础加强 框架加强 高新技术\");\n    }\n    @Override\n    public void teach(){\n        System.out.println(\"正在讲课:基础加强 框架加强 高新技术\");\n    }\n}\n\n//创建抽象父类的子实现类SCDTeacher\n//这是一个抽象子类,只实现抽象父类中的一个抽象方法\nabstract class SCDTeacher extends Teacher{\n    @Override\n    public void ready() {\n        System.out.println(\"正在研发中...\");\n    }\n}\n</code></pre>\n<p><strong>  7. final和abstract是什么关系？</strong></p>\n<p>        1). 互斥关系</p>\n<p>        2). abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承。</p>\n<p>        3). 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。</p>\n<p><strong>  8. 模板方法模式解决了什么问题？ </strong> </p>\n<p>        1). 提高了代码的复用性  </p>\n<p>        2). 模板方法已经定义了通用结构，模板方法不能确定的部分定义成抽象方法，交给子类实现，因此，使用者只需要关心自己需要实现的功能即可。</p>\n<h2 id=\"7.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%3A%20%E5%A4%9A%E6%80%81\">7. 面向对象三大特征之三: 多态</h2>\n<p>  多态的常见形式</p>\n<blockquote>\n<p>        父类类型 对象名称 = new 子类构造器;</p>\n</blockquote>\n<p>  1. 前提：为了忽略子类型之间的差异，统一看作父类类型，写出更加通用的代码<br/>         比如：把Cat看作Animal,把Dog看作Animal,把Bird看作Animal,如果方法需要设置传入的参数，可以buy(Animal a)<br/>         比如：把算术异常、输入不匹配异常都看作是Exception,统一捕获处理，只写一个解决方案<br/>   2. 概念：在同一时刻，同一个对象，代表的类型不同,拥有多种形态<br/>   3. 多态的要求：继承 + 重写<br/>   4. 多态的口诀1：父类引用指向子类对象：父类型的引用类型变量保存的是子类对象的地址值<br/>   5. 多态的口诀2：编译看左边，运行看右边：<br/>         父类中定义的功能，子类才能使用，否则报错<br/>         多态中，方法的定义看的是父类的，方法的实现看的是子类重写后的功能</p>\n<p><img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\cd35dac8338c4ec0a96b645b580c9e2d.png\" width=\"659\"/></p>\n<p><strong>  6. 多态中资源的使用：</strong><br/>         1）成员变量：使用的是父类的<br/>         2）成员方法：对于方法的定义看的都是父类的，对于方法实现，重写后使用的是子类的<br/>         3）静态资源：静态资源属于类资源，不存在重写的概念，在哪个类中定义的，就属于哪个类<br/><strong>  7. 向上造型与向下造型</strong><br/>         1）这两种都属于多态，只不过是多态的两种不同的表现形式<br/>         2）向上造型【最常用】<br/>         可以把不同的子类型都看作是父类型，比如Parent p = new Child();<br/>         比如：花木兰替父从军，被看作是父类型，并且花木兰在从军的时候，不能使用自己的特有功能，比如化妆<br/>         3）向下造型<br/>         前提：必须得先向上造型，才能向下造型<br/>         子类的引用指向子类的对象，但是这个子类对象之前被看作是父类类型，所以需要强制类型转换<br/>         Parent p = new Child(); 然后：Child c = (Child) p;<br/>         比如：花木兰已经替她爸打完仗了，想回家织布，那么这个时候，一直被看作是父类型的花木兰必须经历“解甲归田”【强制类型转换】这个过程，才能重新被看作成子类类型，使用子类的特有功能<br/>         为什么有向下造型：之前被看作是父类类型的子类对象，想使用子类的特有功能，那就需要向下造型</p>\n<p><strong>  8. 引用数据类型的类型转换，有几种方式？  </strong></p>\n<p>        自动类型转换、强制类型转换。</p>\n<p><strong>  9. 强制类型转换能解决什么问题？ </strong> </p>\n<p>        可以转换成真正的子类类型，从而调用子类独有功能。</p>\n<p><strong>  10. 强制类型转换需要注意什么？ </strong> </p>\n<p>        有继承关系/实现的2个类型就可以进行强制转换，编译无问题。  </p>\n<p>        运行时，如果发现强制转换后的类型不是对象真实类型则报错（ClassCastException）</p>\n<p><strong>  11. 强制类型转换前最好做什么事情，如何进行？  </strong></p>\n<p>        使用instanceof判断当前对象的真实类型，再进行强制转换  </p>\n<p>        对象变量名 instanceof 真实类型</p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-21 22:22:18", "summary": "个人简介个人主页：是的主页是的主页学习方向：后端开发种一棵树最好的时间是十年前，其次是现在！往期文章：基础面向对象进阶基础面向对象进阶喜欢的话麻烦点点关注喔，你们的支持是我的最大动力。目录包权限修饰符"}