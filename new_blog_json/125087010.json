{"blogid": "125087010", "writerAge": "码龄1年", "writerBlogNum": "764", "writerCollect": "1263", "writerComment": "1453", "writerFan": "981", "writerGrade": "7级", "writerIntegral": "9203", "writerName": "90后小伙追梦之路", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125087010.jpg", "writerRankTotal": "1573", "writerRankWeekly": "2105", "writerThumb": "295", "writerVisitNum": "229393", "blog_read_count": "4739", "blog_time": "于 2022-06-01 17:13:03 发布", "blog_title": "什么是Docker容器?(全面了解使用)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2><strong>一:为什么需要Docker容器？</strong></h2>\n<h2><strong>1.引入</strong></h2>\n<h3><strong>1.1麻烦的环境部署</strong></h3>\n<pre><code>1.在软件开发中，最麻烦的事情之一就是环境配置。在正常情况下，如果要保证程序能运行，我们需要设置好操作系统，以及各种库和组件的安装。\n\n2.举例来说，要运行一个Python程序，计算机必须要有 Python 引擎，还需要安装好程序的各种依赖，甚至还要配置特定的环境变量。假设你有两个程序都需要部署在同一个服务器上，一个需要软件是基于Python2.0，一个是Python3.0，那么在部署上就很容易造成混乱。因为不同版本的Python模块可能互不兼容，况且不同开发环境上的库也需要额外的配置。如果要部署很多程序，而开发环境和部署环境各不相同的话，可想而知配置得多么麻烦。\n\n3.为了更好地将软件从一个环境移植到另一个环境上，必须从根源上解决问题，那么如何在移植软件的时候，将一模一样的原始环境迁移过来呢？</code></pre>\n<h3><strong>1.2虚拟机（Virtual Machine）</strong></h3>\n<pre><code>虚拟机是移植环境的一种解决方案。虚拟机本质上也是一个软件，在这个软件中，我们可以运行另一种操作系统。比如我们想要在 MacOS 上运行 Linux 系统，我们就在电脑上安装 Linux 镜像，并使用虚拟机打开此镜像，就能创建出一个镜中镜了。这个方案非常方便，想要新环境，就安装镜像，然后使用虚拟机打开，不想要直接删除。但是这个方案有几个缺点：</code></pre>\n<ol><li>占用资源多：虚拟机需要安装整个操作系统，自然会消耗大量内存和硬盘空间。如我们只需要运行1MB的软件，有时候也不得不安装几个G的环境才能运行。</li><li>运行步骤冗余：虚拟机安装的是完整的系统，每次运行程序都需要按部就班，打开系统、登入用户等等之类麻烦的步骤，很不方便。</li><li>运行速度慢：为了运行特定环境中的软件，虚拟机必须先运行系统，而系统占用的资源往往很多（网络，GUI，IO等等），自然也会影响运行速度。</li></ol>\n<h3><strong>1.3Linux容器（Container）</strong></h3>\n<p>为了解决虚拟机存在的这些缺点，Linux发展出了另一种虚拟化的技术：Linux容器。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，就是在正常进程的外面套用了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层程序的隔离。由于容器是进程级别的，相比虚拟机有更多优势：</p>\n<ol><li>占有资源少：容器只占用需要的资源，不占用那些用不到的资源。相比于虚拟机安装完整的操作系统，容器需要消耗的空间自然就少了很多。</li><li>资源利用率高：虚拟机都是独享资源，电脑需要为每个虚拟环境单独分配资源，不仅仅占用空间大，而且资源的利用率很低。而容器之间可以共享资源，最大化资源的利用率。</li><li>运行速度快：容器里面的应用就是底层系统的一个进程，所以启动容器相当于直接运行本机的一个进程，而不是一个完整并臃肿的操作系统，自然就快很多。</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\168c7455912e33104fde9ccbbc789173.png\"/></p>\n<h2><strong>二:Docker是什么？</strong></h2>\n<h3><strong>1.Docker简介</strong></h3>\n<pre><code>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口，它也是目前最流行的Linux容器解决方案。Docker 将软件代码和其依赖，全打包在一个文件中。运行单个文件，就会生成虚拟容器。在这个虚拟容器中，不管本地的操作系统是如何的不同，此容器都能照常运行。\n\n简而言之，Docker的接口非常简单，可以帮助用户更好地创建和使用容器，让相同的代码在不同的环境上正常运行。</code></pre>\n<h3><strong>2.Docker的用途</strong></h3>\n<h3><strong>Docker目前主要有以下三个用途：</strong></h3>\n<ol><li>提供一次性的环境：本地测试别人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>提供弹性的云服务：因为Docker容器可以随时启动或关闭，所以非常适合动态规划和缩容。</li><li>组建微服务构架：通过多个容器，服务的部署能更加灵活，帮助实现微服务构架。</li><li>不需要虚拟硬件和操作系统，轻量级，占用体积小，启动快</li></ol>\n<h2><strong>3.Docker容器 VS VM</strong></h2>\n<p>Docker容器和传统VM技术，在技术实现上有所不同。下图显示的是VM与Docker容器的逻辑组成：</p>\n<ul><li>VM：使用Hypervisor提供虚拟机的运行平台，管理每个VM中操作系统的运行。每个VM都要有自己的操作系统、应用程序和必要的依赖文件等。</li><li>Docker容器：使用Docker引擎进行调度和隔离，提高了资源利用率，在相同硬件能力下可以运行更多的容器实例；每个容器拥有自己的隔离化用户空间。</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\77afb33aacc7dea0170721f52cf45bd5.png\"/></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\5898f39b8db9d428f38d2b438fa4f576.png\"/></p>\n<p> </p>\n<p></p>\n<pre><code>Server：相当于云服务器\nHost OS：为操作系统\nDocker Engine：可以认为我们在这个操作系统上安装了一个docker的软件\nApp A：在Docker组件中运行App A\nApp B：在Docker组件中运行App B\n# 所以docker完全没有操作系统的概念，用的还是宿主机的操作系统，但是它做出了隔离。也实现了虚拟化。</code></pre>\n<p><em>虚拟机与Docker容器对比</em></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\a3ab28d561ed9c59a8035d905ea0fef3.png\"/></p>\n<h2><strong>三:Docker容器是如何工作的？</strong></h2>\n<h3><strong>1.Docker的三大组成要素：</strong></h3>\n<ul><li><a href=\"https://link.zhihu.com/?target=https%3A//info.support.huawei.com/info-finder/encyclopedia/zh/%25E9%2595%259C%25E5%2583%258F.html\" title=\"镜像\">镜像</a>：Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像可以用来创建Docker容器，用户可以使用设备上已有的镜像来安装多个相同的Docker容器。</li><li>容器：镜像创建的运行实例，Docker利用容器来运行应用。每个容器都是相互隔离的、保证安全的平台。我们可以把容器看做是一个轻量级的Linux运行环境。</li><li>镜像仓库：集中存放镜像文件的地方。用户创建完镜像后，可以将其上传到公共仓库或者私有仓库，需要在另一台主机上使用该镜像时，只需要从仓库上下载即可。</li></ul>\n<p>Docker容器的运行逻辑如下图所示，Docker使用客户端/服务器 (C/S) 架构模式，Docker守护进程（Docker daemon）作为Server端接收Docker客户端的请求，并负责创建、运行和分发Docker容器。Docker守护进程一般在Docker主机后台运行，用户使用Docker客户端直接跟Docker守护进程进行信息交互。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\21105a944d8fcacc7f55d580a745cd0c.png\"/></p>\n<h3><strong>2.<em>Docker运行流程</em></strong></h3>\n<p>其中：</p>\n<ul><li>Docker客户端：用于和Docker守护进程（Docker Daemon）建立通信的客户端。Docker客户端只需要向Docker服务器或者守护进程发出请求（Docker构建、Docker拉取和Docker启动等指令），服务器或者守护进程将完成所有工作并返回结果。 \n  <ul><li>如橙色流程所示，执行Docker构建指令会根据Docker文件构建一个镜像存放于本地Docker主机。</li><li>如蓝色流程所示，执行Docker拉取指令会从云端镜像仓库拉取镜像至本地Docker主机或将本地镜像推送至远端镜像仓库。</li><li>如黑色流程所示，执行Docker启动指令会将镜像安装至容器并启动容器。</li></ul></li></ul>\n<p></p>\n<ul><li>Docker主机：一个物理或者虚拟的机器用于执行 Docker守护进程和容器。</li><li>Docker守护进程：接收并处理Docker客户端发送的请求，监测Docker API的请求和管理Docker对象，比如镜像、容器、网络和数据卷。</li></ul>\n<h3><strong>4.Docker服务器与客户端</strong></h3>\n<pre><code>Docker是一个客户端-服务端(C/S)架构程序，Docker客户端只需要向Docker服务器或者守护进程发送请求即可，服务器或者守护进程将完成所有工作并返回结果，Docker提供了一个命令行工具以及一正太Restful Api，我们可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地Docker客户端连接运行在另外一台宿主机的Docker的守护进程。</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\08214e8a4e01bee6f2ab0e3be301ebae.png\"/></p>\n<pre><code># 使用了RESTful API的目的就是为了统一规范，无需自己在生成一套体系。现在几乎所有的软件都是通过RESTful API来传输数据。</code></pre>\n<h3><strong>5.docker非常重要的概念：镜像（image）与容器（container）</strong></h3>\n<pre><code>1.有了镜像---》镜像运行起来是容器（真正的执行单位）\n镜像\t\t: 面向对象的类    \n容器\t\t: 对象\n    \n2. 镜像是从哪里来的？    \n-镜像就是一堆文件\n-从远程仓库获取（拉取）</code></pre>\n<h2><strong>四:docker架构图</strong></h2>\n<pre><code>Docker是一个客户端-服务器（C/S）架构程序（mysql，redis都是cs架构），整套RESTful API</code></pre>\n<ul><li>Docker客户端(Docker Client)</li></ul>\n<blockquote>\n •Docker客户端(Docker Client)是用户与Docker进行交互的最主要方式。当在终端输入docker命令时，对应的就会在服务端产生对应的作用，并把结果返回给客户端。Docker Client除了连接本地服务端，通过更改或指定DOCKER_HOST连接远程服务端。\n</blockquote>\n<ul><li>Docker服务端(Docker Server)</li></ul>\n<blockquote>\n •Docker Daemon其实就是Docker 的服务端。它负责监听Docker API请求(如Docker Client)并管理Docker对象(Docker Objects)，如镜像、容器、网络、数据卷等\n</blockquote>\n<ul><li>Docker Registries</li></ul>\n<blockquote>\n •俗称Docker仓库，专门用于存储镜像的云服务环境.\n <br/> •Docker Hub就是一个公有的存放镜像的地方，类似Github存储代码文件。同样的也可以类似Github那样搭建私有的仓库。\n</blockquote>\n<ul><li>Docker 对象(Docker Objects)</li></ul>\n<blockquote>\n •镜像：一个Docker的可执行文件，其中包括运行应用程序所需的所有代码内容、依赖库、环境变量和配置文件等。\n <br/> •容器：镜像被运行起来后的实例。\n <br/> •网络：外部或者容器间如何互相访问的网络方式，如host模式、bridge模式。\n <br/> •数据卷：容器与宿主机之间、容器与容器之间共享存储方式，类似虚拟机与主机之间的共享文件目录。\n</blockquote>\n<pre><code>docker pull :  拉取镜像(从远程仓库中获取放到Images)\ndocker run  :  运行镜像(运行镜像后就会放到容器里)\ndocker container :  查看运行了那些镜像(容器)\ndocker image :  查看有那些镜像 \ndocker network :  查看网络\ndocker valume :  查看数据表等\n    - 数据表等建议放到宿主机上，因为如果一旦容器删除了，在容器上的数据表就没有了。</code></pre>\n<h3><strong>docker 三大要素：镜像(image)、容器(container)、仓库(repository)</strong></h3>\n<pre><code>1.镜像：就是一个只读的模板，镜像可以用来创建docker容器，一个镜像可以创建很多容器\n\n2.容器：用镜像创建的实例，可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、网络空间等）和运行在其中的应用程序。容器与镜像的关系类似于面向对象编程中的类和对象，镜像好比是类，那么容器则是对象\n\n3.仓库是集中存放镜像文件的场所。仓库（repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库又分为公开仓库（public）和私有仓库（private）两种形式。最大的仓库是DockerHub (https://hub.docker.com)，存放了数量庞大的镜像供用户下载。国内的公有仓库包括阿里云、网易云等。\n\n \ndocker本身就是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎image镜像文件。只有通过镜像文件才能生成docker容器。image文件可以看做是容器的模板。docker根据image文件生成容器实例。同一个image文件，可以生成多个可以同时运行的容器实例。\n\nimage文件 生成的容器实例，本身也是一个文件，称为镜像文件\n一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器。\n仓库就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以</code></pre>\n<h2><strong>五:docker安装</strong></h2>\n<h3><strong>1 windows安装</strong></h3>\n<pre><code>1 windows安装（不建议你装）http://get.daocloud.io/</code></pre>\n<h3><strong>2.乌班图安装：</strong></h3>\n<ul><li>系统要求：Ubuntu 14.04及其以上版本</li><li>查看<a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/install/linux/docker-ce/ubuntu/\" title=\"官方源安装教程\">官方源安装教程</a></li></ul>\n<pre><code># 0 卸载\nsudo apt-get remove docker docker-engine docker.io containerd runc\n# 1 安装必要工具\nsudo apt-get update\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n# 2 安装GPG证书\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n#换成阿里云\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n# 2 写入软件源信息\n#官方\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n#换成阿里云\nsudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\n\n# 3 更新并安装docker-ce\nsudo apt-get -y install docker-ce\n# 4 开启docker服务\nsystemctl status docker\n\n# 安装成功后，使用 docker version查看\n\n如果出现权限禁止，需要切换到root用户执行\n\n    su\n    输入密码\n    docker version</code></pre>\n<h3><strong>3.cent os安装:(条件7.0以上版本)</strong></h3>\n<pre><code>0 卸载（如果没有安装过无需卸载）\nyum remove docker docker-common  docker-selinux docker-engine\nrm -rf /var/lib/docker\n\n1 更新yum\nyum update\n\n2 安装需要的软件包：yum-util (会生成该命令yum-config-manager)\n命令：yum install -y yum-utils device-mapper-persistent-data lvm2\n\n3 执行（向你的yum源，增加一条记录）\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \n4 安装 \nyum install docker-ce\n\n5 验证安装（查看版本）\ndocker -v  \n~]# docker -v  （19年03月12日发布）\n# 自从分了docker-ce和docker-ee以后，以年份命名版本\nDocker version 19.03.12, build 48a66213fe</code></pre>\n<p>注意：自从区分docker-ce和docker-ee之后，docker最初始的版本是17.03，也就是17年发布的，所有17是老版本和新版本的分水岭</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\bef96af831da8bd34e96daade9c5e834.png\"/></p>\n<h3><strong>系统支持情况</strong></h3>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\ec464d0da9eef7af2aad808f8795b071.png\"/></p>\n<pre><code>6 启动docker服务\nsystemctl start docker\n\n7 停止docker服务，重启docker服务\nsystemctl stop docker\nsystemctl restart docker\n\n8 开机启动\t\nsystemctl enable docker\n\n9 查看概要信息\ndocker info（你可能写了一个管理docker的运维平台）</code></pre>\n<h2><strong>六:容器镜像的基本操作</strong></h2>\n<h3><strong>1.镜像操作</strong></h3>\n<h3><strong><code>下载镜像：</code></strong></h3>\n<pre><code># 远程仓库地址：https://hub.docker.com/\n\t- 注册 登录\n    \n# 你可以上传镜像（类似于github），你把你制作的镜像传上去，别人可以下载使用\n# 搜索镜像：\n    方式一：https://hub.docker.com/    点点点搜索\n\t方式二：docker search 镜像名字\n    \n# 后面有OK代表官方    </code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\044675ce5d45ac06f3ece1c22c6bac3d.png\"/></p>\n<pre><code># search作用：\n\t搜索Docker Hub(镜像仓库)上的镜像\n# 命令格式：\n\tdocker search [OPTIONS] TERM\n# 命令参数(OPTIONS)：\n\t-f,  --filter filter   \t根据提供的格式筛选结果\n\t     --format string   \t利用Go语言的format格式化输出结果\n\t     --limit int       \t展示最大的结果数，默认25个\n\t     --no-trunc        \t内容全部显示\n        \n #  命令演示\ndocker search -f is-offical=true ubuntu\ndocker search ubuntu</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\0c3aea41e1514262613915e15b61d4c2.png\"/></p>\n<pre><code># 拉取下载镜像\ndocker pull hello-world  # 最新版本latest\ndocker pull hello-world:nanoserver  # 指定版本</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\1c2376435461e5c22a95261544be94ef.png\"/></p>\n<pre><code>docker pull hello-world:版本号(默认最新，可以指定版本号)</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\835ba3f44c95e7fea34ff8c41ee9c3a7.png\"/></p>\n<h3><strong><code>查看镜像</code></strong></h3>\n<pre><code># 查看机器上有哪些镜像\n# 命令：docker images\n# 解释：\n\nREPOSITORY  TAG   IMAGE ID   CREATED   SIZE\n镜像名字    版本     id号     创建时间   大小</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\9c381846f72c8f16452e0e579196d87c.png\"/></p>\n<h3><strong><code>运行镜像</code></strong></h3>\n<pre><code># 命令：\ndocker run 镜像名字\n\ndocker run hello-world\n\n# 例：\n第一个hello-world（没有任何意义）\n\tdocker run hello-world\n\t1 客户端连到服务端，服务下载了hello-world镜像\n    2 通过镜像跑起容器来\n    3 容器输出一些东西，通过服务端发送给客户端，客户端展示在窗口里了</code></pre>\n<h3><strong><code>删除镜像</code></strong></h3>\n<pre><code># 命令：\ndocker rmi 镜像名字/Id号\n\n# 注意：\n1.如果还有基于这个镜像的容器，是不允许删除镜像的\n2.可以先删除容器，在删除镜像\n\t# 查询容器依赖\t\n\tdocker ps -a\n    # 在删除要不允许的镜像\n    docker rm 容器/id</code></pre>\n<h3><strong>2.拉取python3.6镜像，redis最新镜像，mysql5.7镜像，nginx镜像</strong></h3>\n<pre><code># 拉取python3.6镜像，redis最新镜像，mysql5.7镜像\n    docker pull python:3.8\n    docker pull redis\n    docker pull mysql:5.7\n    docker pull nginx\n    docker pull centos:centos7\n     \n# 查询当前镜像\n\tdocker images</code></pre>\n<h3><strong>镜像容器是可以看作：</strong></h3>\n<pre><code>镜像容器是可以看作：\n\t-镜像就是一堆文件，这堆文件通过docker跑起来，就是容器，你现在就把他当成，一个操作系统内跑了这个软件（比如就是：centos+redis）\n    -假设centos7的镜像跑起来，此时容器你就当成在你宿主机上跑了一个centos7的操作系统（虚拟机）</code></pre>\n<h2><strong>七:容器操作</strong></h2>\n<pre><code>1 删除容器\n docker rm 容器名字/容器id\n    \n2 启动并运行容器\n\t# 通过centos:centos7镜像，创建一个容器名字叫mycentos，并且把它运行起来\n    docker run -di --name=mycentos centos:centos7\n    # 结果：会打印出容器的id号\n\n    \n3 查看机器上正在运行的容器\n\tdocker ps\n    \n4 查看宿主机上所有的容器（包括停止的）\n\tdocker ps -a\n    \n5 停止容器\n\tdocker stop 容器名字/id号\n    \n6 启动容器\n\tdocker start 容器id/名字   # id号只要能够区分即可无需写全部</code></pre>\n<h2><strong>八:补充：配置镜像(提升加速)</strong></h2>\n<pre><code># 配置加速（之前去https://hub.docker.com/），阿里云，清华，做了一个备份，配置好以后，再拉镜像会去国内地址拉取\n第一步：vi /etc/docker/daemon.json  \n第二步：\n# 指定清华源，提升拉取加速\n{\n\"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]\n}</code></pre>\n<h2><strong>九:容器的创建和启动</strong></h2>\n<h3><strong>虚拟机的生命周期</strong></h3>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\44726276e50e864184d3a650f0d53835.png\"/></p>\n<h3><strong>容器的生命周期</strong></h3>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\1514242b7f5714c0d9cef6f4098c9a1a.png\"/></p>\n<h3><strong>1.容器创建 – docker create</strong></h3>\n<pre><code># 作用：\n\t利用镜像创建出一个Created 状态的待启动容器\n    \n# 命令格式：\n\tdocker create [OPTIONS] IMAGE [COMMAND] [ARG...]\n    \n# 命令参数(OPTIONS)：查看更多\n  -t, --tty           \t\t分配一个伪TTY，也就是分配虚拟终端\n  -i, --interactive    \t即使没有连接，也要保持STDIN打开\n  --name          \t\t为容器起名，如果没有指定将会随机产生一个名称\n    \n# 命令参数（COMMAND\\ARG）:\n\tCOMMAND 表示容器启动后，需要在容器中执行的命令，如ps、ls 等命令\n\tARG 表示执行 COMMAND 时需要提供的一些参数，如ps 命令的 aux、ls命令的-a等等\n    \n# 创建容器命令演示：\ndocker create --name test-container centos:centos7 ps -A\n# 我们创建了一个容器，并指定在启动容器的时候执行：docker ps -a\ndocker create -ti --name test-container2 centos /bin/bash</code></pre>\n<h3><strong>2.容器启动 – docker start</strong></h3>\n<pre><code># 作用：\n\t将一个或多个处于创建状态或关闭状态的容器启动起来\n# 命令格式：\n\tdocker start [OPTIONS] CONTAINER [CONTAINER...]\n# 命令参数(OPTIONS)：\n\t-a, --attach\t\t将当前shell的 STDOUT/STDERR 连接到容器上\n\t-i, --interactive\t\t将当前shell的 STDIN连接到容器上\t\n# 命令演示：\ndocker ps -a\ndocker start -a 65ebc\ndocker start test-container</code></pre>\n<h3><strong>3.重点（容器一直运行的原因）</strong></h3>\n<pre><code># 容器一直运行的原因COMMAND\n1.它有一条前台进程,一直在运行\n2.以后如果自己制作的镜像，运行起容器，必须有个可以夯住的命令COMMAND\n3.如果COMMAND该命令结束，该容器也就结束了</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\dbfd235e020644f40df6b81e7d3095d3.png\"/></p>\n<pre><code># 当我们在后台启动的时候\n1.比如：docker run -di --name=mycentos centos:centos7\n2.这时他会自动启动一个 /bin/bash窗口\n3.因为我们并没有关闭这个/bin/bash窗口，所以他会一直在后台运行  \n4.我们在使用start或者直接run进入这个镜像的时候，就相当于运行的这个命令:/bin/bash，就进入了这个bash窗口，相当于进入了容器(其实不是进入了容器，可以把他看作是xshell一个远程连接，连接到这个容器。)这里我们看作是进入到了这个容器，当我们使用exit退出的时候，就相当于关闭了/bin/bash这个窗口。所以容器一直会在后台运行的原因就是这个/bin/bash窗口一直在启动这,没有关闭它</code></pre>\n<h3><strong>4.容器创建并启动 – docker run</strong></h3>\n<pre><code># 创建并启动（run）\n# 参数：\n    -i：表示运行容器\n    -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。\n    -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。\n    --name :为创建的容器命名。如果不写，会自动分配一个名字（英文人名）\n    -v：表示目录映射关系（前者是宿主机目录，后者是容器目录，映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。（下述单独演示）\n    -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （下述单独演示）\n    \n# 例子：run\n    docker run -it --name=myredis redis  # 这时就会启动redis容器并进去redis容器  \n    docker run -id --name=oursql mysql  # 这时就不会进入mysql容器，再后台运行\n    \n    \n# 注意，docker run  镜像 \n使用该命令：如果本地没有，会先pull，再run</code></pre>\n<h3><strong>5.进入容器内部和退出容器</strong></h3>\n<h3><strong>5.1进入容器</strong></h3>\n<pre><code># 方式1:\n\t1.查询机器上运行的容器\n\tdocker ps\n    2.进入容器\n\tdocker exec -it 容器id/bin/bash\n    docker exec -it 427 /bin/bash\n    \n# 第二种：ssh连接（容器内部装ssh服务端）（不常用）    </code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\df3d27fd0cdb2e9c3c6d5d8dd1dfb16c.png\"/></p>\n<pre><code>#  exec真正的作用是在容器内执行命令，而不是真正的进入到容器内部\n1.因为 /bin/bash这个命令，就相当于与这个容器建立了连接，所以我们可以和容器做交互，当我们关闭这个连接的时候，就会自动结束掉这个容器。\n\n2.执行exec命令:\n\tdocker exec -it 容器id ls  # 查询根路径所有文件</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\e33305a0375fd73d3c86b0c37807af3e.png\"/></p>\n<pre><code># top 命令(容器内部执行查询进程)</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\2381833c046f1ba3cc7be25d4e4c8366.png\"/></p>\n<pre><code># 容器内部是纯净的空间，安装:vim </code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\029442e8e8501fe83d74f92ed4fb3c53.png\"/></p>\n<h3><strong>5.2退出容器</strong></h3>\n<pre><code># 命令：exit\n\t1.如果是一个夯在哪里得命令，则使用exit退出容器\n    2.如果不是则会自动退出容器</code></pre>\n<h3><strong>6.(-it 进入容器退出) 与 (-id 进入容器退出)区别</strong></h3>\n<pre><code># -it 进入容器退出(前台容器自动结束【后台停止运行】)\n1.在我们使用 -it 参数直接进入该容器的时候，使用exit退出的时候这个容器就会自动结束。\n\t- 此时后台就没有该运行中的容器。\n\n# -id 进入容器退出(前台容器自动结束【后台正常运行】)    \n2.如果使用 -id 后台运行容器的时候，使用 docker exec进入该容器，此时使用exit退出该容器的话，只是退出该容器，并没有从后台结束该容器，该容器还会在后台运行这。</code></pre>\n<h2><strong>十:文件拷贝(宿主机和容器互相拷贝文件)</strong></h2>\n<pre><code># 1.从宿主机拷贝到容器内部\n\tdocker cp 宿主机文件 容器id:容器路径\n        \n    docker cp /home/a.txt 427:/home      \n# 2.从容器中拷贝到宿主机\n\tdocker cp 容器id:容器路径 宿主机路径(起别名)\n        \n    docker cp 427:home/a.txt a.txt</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\81e197bdd8c10f62228fb985ddaf8681.png\"/></p>\n<h2><strong>十一:目录挂载(映射作用)</strong></h2>\n<pre><code># 目录挂载格式:\ndocker run -di --name=mycentos99 -v /宿主机要挂载目录:/容器要挂载路径 指定镜像\n\ndocker run -di --name=mycentos99 -v /home:/home centos:centos7\n\n# -v \t: 映射\n\n# 挂载作用:\n1.一旦挂载，以后宿主机目录内修改，同样影响容器内部\n2.容器内修改同样影响宿主机</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f6ee61993f64908ef656090e780e493f.png\"/></p>\n<h2><strong>十二:端口映射</strong></h2>\n<h3><strong>图解：</strong></h3>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\b67aab6a773cbcdade69d855a1dbbe55.png\"/></p>\n<pre><code># 命令：\t\n\t- 使用参数 -p 宿主机端口:容器端口\n    - 例：docker run -it -p 6377:6379 redis   # 将宿主机得6377端口映射到容器redis6379端口上\n# 演示：\n# 创建容器\n\t- docker run -di -p 6377:6379 redis\n# 进入容器\n\t- docker exec -it 27d /bin/bash\n  \t- 此时启动的是redis服务端  \n# 连接客户端\n\t- redis-cli\n# 在容器中操作redis\n\t- set name born</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\c91085b32a31e0fb0ecb19c78d103b77.png\"/></p>\n<pre><code># 此时我们使用远程连接我们得宿主机云服务器的6377端口。</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\662994d57ccdecf176d05d4803041b79.png\"/></p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\53ccddfd0b4769d29379aab57c934829.png\"/></p>\n<h3><strong>为什么会后台启动redis服务?</strong></h3>\n<pre><code># 为什么会后台启动redis服务?\n\t1.我们在启动redis容器的时候，他会自动运行一个脚本文件:docker-entrypoint.sh\n    2.就像启动cent os自动启动一个/bin/bash窗口\n    3.而redis启动/bin/bash与之建立连接之后，会自动执行这个脚本文件</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\0217a649a4309599aad449c951124eae.png\"/></p>\n<pre><code># docker-entrypoint.sh 这个脚本的路径：\n\t/usr/local/bin/docker-entrypoint.sh</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f75bf9af1a4153b153c87a069c9c37ef.png\"/></p>\n<h2><strong>十三:查看容器ip地址</strong></h2>\n<pre><code># 命令：\n# 查看容器详细信息\n\t- docker inspect 容器id\n# 只查看容器ip地址\n\t- docker inspect --format='{<!-- -->{.NetworkSettings.IPAddress}}' 容器名称/容器ID</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\43b67e76977930893b17727082bb62e9.png\"/></p>\n<pre><code># 其实宿主机与容器之间是通过网关进行通信的\n\t- 查看网关\n    \t# 容器内下载该命令:\n    \t- 下载查看ip信息的命令：yum install net-tools\n        - ifconfig：查看网络相关信息</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\9961791c3ce0bcfde28a3716a41f7ef4.png\"/></p>\n<p></p>\n<pre><code># 所以此时我们在连接redis的时候就有两种方式\n\t- 第一种：\n    \t- 因为我们做了端口映射，所以我们可以通过：云服务器地址:6377连接\n     - 第二种：\n    \t- 此时我们已经知道了容器的ip地址，所以就可以通过： 容器的ip地址:6379 （此时端口号就是它本身的6379因为是直接通过它本身的ip建立的连接）\n# 每个容器都有ip地址，每一个ip地址标志着一台唯一服务器，所以就实现了宿主与容器之间的隔离性，每一个容器就相当于一个虚拟机</code></pre>\n<h2><strong>十四:应用部署</strong></h2>\n<pre><code># 在容器内部署mysql\n\n# 容器内查询env，环境变量密码\ndocker run -di --name=mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n        \n# -e\t\t: 表示环境变量指定密码   \n\n# 进入容器\ndocker exec -it 749 /bin/bash\n\nmysql\n\nmysql -uroot -p 123456\n\nshow databases;\n\ndrop database lqz;\n\n# 官方提供的\ndocker run --name some-mysql -v /my/own/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n        \n# 宿主部署容器内redis\ndocker run -di -p 6377:6379 redis:latest\n        \n# 宿主部署容器内nginx\ndocker run -di --name=mynginx -p 8080:80 nginx\n    \n    \n# 我们都使用了 -p 参数做了端口映射，所以我们在访问云服务器指定映射端口后，就访问到部署好的容器，所以有了docker完全就需要在本地下载这些应用，直接使用docker pull拉下来使用即可</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\f72ba8671bf502faad473194f31dc600.png\"/></p>\n<blockquote>\n 小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏+评论转发+关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【999】即可免费获取\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\7a1157bc92b7190adf9b143911215499.png\"/></p>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-06-01 17:13:03", "summary": "一为什么需要容器？引入麻烦的环境部署在软件开发中，最麻烦的事情之一就是环境配置。在正常情况下，如果要保证程序能运行，我们需要设置好操作系统，以及各种库和组件的安装。举例来说，要运行一个程序，计算机必须"}