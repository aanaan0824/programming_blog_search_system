{"blogid": "125932955", "writerAge": "码龄1年", "writerBlogNum": "12", "writerCollect": "57", "writerComment": "9", "writerFan": "6", "writerGrade": "2级", "writerIntegral": "136", "writerName": "河海CV小菜鸡", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125932955.jpg", "writerRankTotal": "79246", "writerRankWeekly": "716843", "writerThumb": "7", "writerVisitNum": "10065", "blog_read_count": "1393", "blog_time": "已于 2022-07-22 15:46:21 修改", "blog_title": "Bubbliiiing版本yolov7 c++opencv dnn部署", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>使用B导的yolov7代码部署，代码地址：<a href=\"https://github.com/bubbliiiing/yolov7-pytorch\" title=\"https://github.com/bubbliiiing/yolov7-pytorch\">https://github.com/bubbliiiing/yolov7-pytorch</a></p>\n<p>模型的的训练看B导即可，up主地址：<a href=\"https://blog.csdn.net/weixin_44791964\" title=\"Bubbliiiing的博客_CSDN博客-神经网络学习小记录,睿智的目标检测,有趣的数据结构算法领域博主\">Bubbliiiing的博客_CSDN博客-神经网络学习小记录,睿智的目标检测,有趣的数据结构算法领域博主</a></p>\n<p>模型训练完成之后，在predict.py中设置mode = \"export_onnx\"即可生成。</p>\n<p>注意，<strong>此处有个坑，B导的yolov7代码输出的onnx只有1*class.size*20*20这一层，需要在nets/yolo.py文件中修改一下。</strong></p>\n<p>修改之前：（在yolo.py的最下面）</p>\n<pre><code> #---------------------------------------------------#\n #   第三个特征层\n #   y3=(batch_size, 36, 80, 80)\n #---------------------------------------------------#\n out2 = self.yolo_head_P3(P3)\n #---------------------------------------------------#\n #   第二个特征层\n #   y2=(batch_size, 36, 40, 40)\n #---------------------------------------------------#\n out1 = self.yolo_head_P4(P4)\n #---------------------------------------------------#\n #   第一个特征层\n #   y1=(batch_size, 36, 20, 20)\n #---------------------------------------------------#\n out0 = self.yolo_head_P5(P5)\n return [out0, out1, out2]</code></pre>\n<p>修改之后：</p>\n<pre><code>#---------------------------------------------------#\n#   第三个特征层\n#   y3=(batch_size, 36, 80, 80)\n#---------------------------------------------------#\nout2 = self.yolo_head_P3(P3)\nbs, _, ny, nx = out2.shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\nout2 = out2.view(bs, 3, 12, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\nout2 = out2.view(bs * 3 * ny * nx, 12).contiguous()\n#---------------------------------------------------#\n#   第二个特征层\n#   y2=(batch_size, 36, 40, 40)\n#---------------------------------------------------#\nout1 = self.yolo_head_P4(P4)\nbs, _, ny, nx = out1.shape\nout1 = out1.view(bs, 3, 12, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\nout1 = out1.view(bs * 3 * ny * nx, 12).contiguous()\n#---------------------------------------------------#\n#   第一个特征层\n#   y1=(batch_size, 36, 20, 20)\n#---------------------------------------------------#\nout0 = self.yolo_head_P5(P5)\nbs, _, ny, nx = out0.shape\nout0 = out0.view(bs, 3, 12, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\nout0 = out0.view(bs * 3 * ny * nx, 12).contiguous()\n\n#return [out0, out1, out2]\nreturn torch.cat((out2,out1,out0))</code></pre>\n<p>这样我们可以看到输出的shape已经变成了25200*12了！<img alt=\"\" height=\"1080\" src=\"..\\..\\static\\image\\116e9ec556b6415983f9d09457231b32.jpeg\" width=\"1200\"/></p>\n<p>解释下这个数据：网络原本的输出是1*36*80*80，1*36*40*40，1*36*20*20，36是因为我的模型的类别数为7，36=（5+7）*3，5为四个位置信息加置信度，3为anchor数，经过上述代码的操作就把所有的输出拼接起来了，结果为25200*12，一共有25200个预测结果与每个结果对应12个信息。</p>\n<p>之后我们就可以利用生成的onnx在vs studio中进行部署啦。</p>\n<p>main.cpp：</p>\n<pre><code>#include \"yolo.h\"\n#include &lt;iostream&gt;\n#include&lt;opencv2//opencv.hpp&gt;\n#include&lt;math.h&gt;\n\nusing namespace std;\nusing namespace cv;\nusing namespace dnn;\n\nint main()\n{\n\tstring img_path = \"3.jpg\";\n\tstring model_path = \"models.onnx\";\n\n\tYolo test;\n\tNet net;\n    //加载onnx模型\n\tif (test.readModel(net, model_path, true)) {\n\t\tcout &lt;&lt; \"read net ok!\" &lt;&lt; endl;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\t//生成随机颜色\n\tvector&lt;Scalar&gt; color;\n\tsrand(time(0));\n\tfor (int i = 0; i &lt; 80; i++) {\n\t\tint b = rand() % 256;\n\t\tint g = rand() % 256;\n\t\tint r = rand() % 256;\n\t\tcolor.push_back(Scalar(b, g, r));\n\t}\n\tvector&lt;Output&gt; result;\n\tMat img = imread(img_path);\n\tif (test.Detect(img, net, result)) {\n\t\ttest.drawPred(img, result, color);\n\n\t}\n\telse {\n\t\tcout &lt;&lt; \"Detect Failed!\" &lt;&lt; endl;\n\t}\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<p>yolo.h：</p>\n<pre><code>#pragma once\n#include&lt;iostream&gt;\n#include&lt;math.h&gt;\n#include&lt;opencv2/opencv.hpp&gt;\nstruct Output {\n\tint id;//结果类别id\n\tfloat confidence;//结果置信度\n\tcv::Rect box;//矩形框\n};\n\nclass Yolo\n{\npublic:\n\tYolo() {}\n\t~Yolo(){}\n\tbool readModel(cv::dnn::Net&amp; net, std::string&amp; netPath, bool isCuda);\n\tbool Detect(cv::Mat&amp; SrcImg, cv::dnn::Net&amp; net, std::vector&lt;Output&gt;&amp; output);\n\tvoid drawPred(cv::Mat&amp; img, std::vector&lt;Output&gt; result, std::vector&lt;cv::Scalar&gt; color);\n\nprivate:\n\t//计算归一化函数\n\tfloat Sigmoid(float x) {\n\t\treturn static_cast&lt;float&gt;(1.f / (1.f + exp(-x)));\n\t}\n\t//anchors\n\tconst float netAnchors[3][6] = { { 12.0, 16.0,  19.0, 36.0,  40.0, 28.0 },{ 36.0, 75.0,  76.0, 55.0,  72.0, 146.0 },{ 142.0, 110.0,  192.0, 243.0,  459.0, 401.0 } };\n\t//stride\n\tconst float netStride[3] = { 8.0, 16.0, 32.0 };\n\tconst int netWidth = 640; //网络模型输入大小\n\tconst int netHeight = 640;\n\tfloat nmsThreshold = 0.45;\n\tfloat boxThreshold = 0.35;\n\tfloat classThreshold = 0.35;\n\t//我的数据集类名\n\tstd::vector&lt;std::string&gt; className = { \"scratch\",\"Exposed components\",\"Reverse printing\",\"Missing print\",\"6.8CA\",\"D7\",\"TB20K\"};\n\n};\n\n</code></pre>\n<p> yolo.cpp:</p>\n<pre><code>#include \"Yolo.h\"\nusing namespace std;\nusing namespace cv;\nusing namespace dnn;\n\nbool Yolo::readModel(Net&amp; net, string&amp; netPath, bool isCuda = false) {\n\ttry {\n\t\tnet = readNetFromONNX(netPath);\n\t}\n\tcatch (const std::exception&amp;) {\n\t\treturn false;\n\t}\n\t//cuda\n\tif (isCuda) {\n\t\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\n\t\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA);\n\t}\n\t//cpu\n\telse {\n\t\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_DEFAULT);\n\t\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n\t}\n\treturn true;\n}\n\n\nbool Yolo::Detect(Mat&amp; SrcImg, Net&amp; net, vector&lt;Output&gt;&amp; output) {\n\tMat blob;\n\tint col = SrcImg.cols;\n\tint row = SrcImg.rows;\n\tint maxLen = MAX(col, row);\n\tMat netInputImg = SrcImg.clone();\n\tif (maxLen &gt; 1.2 * col || maxLen &gt; 1.2 * row) {\n\t\tMat resizeImg = Mat::zeros(maxLen, maxLen, CV_8UC3);\n\t\tSrcImg.copyTo(resizeImg(Rect(0, 0, col, row)));\n\t\tnetInputImg = resizeImg;\n\t}\n\tblobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(104, 117, 123), true, false);\n\t//blob = blobFromImage(netInputImg, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(0, 0,0), true, false);//如果训练集未对图片进行减去均值操作，则需要设置为这句\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(114, 114,114), true, false);\n\tnet.setInput(blob);\n\tstd::vector&lt;cv::Mat&gt; netOutputImg;\n\t//vector&lt;string&gt; outputLayerName{\"345\",\"403\", \"461\",\"output\" };\n\t//net.forward(netOutputImg, outputLayerName[3]); //获取output的输出\n\tnet.forward(netOutputImg, net.getUnconnectedOutLayersNames());\n\tstd::vector&lt;int&gt; classIds;//结果id数组\n\tstd::vector&lt;float&gt; confidences;//结果每个id对应置信度数组\n\tstd::vector&lt;cv::Rect&gt; boxes;//每个id矩形框\n\tfloat ratio_h = (float)netInputImg.rows / netHeight;\n\tfloat ratio_w = (float)netInputImg.cols / netWidth;\n\tint net_width = className.size() + 5;  //输出的网络宽度是类别数+5\n\tfloat* pdata = (float*)netOutputImg[0].data;\n\n\tfor (int stride = 0; stride &lt; 3; stride++) {    //stride\n\t\tint grid_x = (int)(netWidth / netStride[stride]);\n\t\tint grid_y = (int)(netHeight / netStride[stride]);\n\t\tfor (int anchor = 0; anchor &lt; 3; anchor++) { //anchors\n\t\t\tconst float anchor_w = netAnchors[stride][anchor * 2];\n\t\t\tconst float anchor_h = netAnchors[stride][anchor * 2 + 1];\n\t\t\tfor (int i = 0; i &lt; grid_x; i++) {\n\t\t\t\tfor (int j = 0; j &lt; grid_y; j++) {\n\t\t\t\t\tfloat box_score = Sigmoid(pdata[4]);//获取每一行的box框中含有某个物体的概率\n\t\t\t\t\tif (box_score &gt; boxThreshold) {\n\t\t\t\t\t\t//为了使用minMaxLoc(),将85长度数组变成Mat对象\n\t\t\t\t\t\tcv::Mat scores(1, className.size(), CV_32FC1, pdata + 5);\n\t\t\t\t\t\tPoint classIdPoint;\n\t\t\t\t\t\tdouble max_class_socre;\n\t\t\t\t\t\t//cout &lt;&lt; scores &lt;&lt; endl;\n\t\t\t\t\t\tminMaxLoc(scores, 0, &amp;max_class_socre, 0, &amp;classIdPoint);\n\t\t\t\t\t\tmax_class_socre = Sigmoid((float)max_class_socre);\n\t\t\t\t\t\tif (max_class_socre &gt; classThreshold) {\n\t\t\t\t\t\t\t//rect [x,y,w,h]\n\t\t\t\t\t\t\tfloat x = (Sigmoid(pdata[0]) * 2.f - 0.5f + j) * netStride[stride];  //x\n\t\t\t\t\t\t\tfloat y = (Sigmoid(pdata[1]) * 2.f - 0.5f + i) * netStride[stride];   //y\n\t\t\t\t\t\t\tfloat w = powf(Sigmoid(pdata[2]) * 2.f, 2.f) * anchor_w;   //w\n\t\t\t\t\t\t\tfloat h = powf(Sigmoid(pdata[3]) * 2.f, 2.f) * anchor_h;  //h\n\t\t\t\t\t\t\tint left = (x - 0.5 * w) * ratio_w;\n\t\t\t\t\t\t\tint top = (y - 0.5 * h) * ratio_h;\n\t\t\t\t\t\t\tclassIds.push_back(classIdPoint.x);\n\t\t\t\t\t\t\tconfidences.push_back(max_class_socre * box_score);\n\t\t\t\t\t\t\tboxes.push_back(Rect(left, top, int(w * ratio_w), int(h * ratio_h)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpdata += net_width;//指针移到下一行\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector&lt;int&gt; nms_result;\n\tdnn::NMSBoxes(boxes, confidences, classThreshold, nmsThreshold, nms_result);\n\tfor (int i = 0; i &lt; nms_result.size(); i++) {\n\t\tint idx = nms_result[i];\n\t\tOutput result;\n\t\tresult.id = classIds[idx];\n\t\tresult.confidence = confidences[idx];\n\t\tresult.box = boxes[idx];\n\t\toutput.push_back(result);\n\t}\n\n\tif (output.size())\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nvoid Yolo::drawPred(Mat&amp; img, vector&lt;Output&gt; result, vector&lt;Scalar&gt; color) {\n\tfor (int i = 0; i &lt; result.size(); i++) {\n\t\tint left, top;\n\t\tleft = result[i].box.x;\n\t\ttop = result[i].box.y;\n\t\tint color_num = i;\n\t\trectangle(img, result[i].box, color[result[i].id], 2, 8);\n\n\t\tstring label = className[result[i].id] + \":\" + to_string(result[i].confidence);\n\n\t\tint baseLine;\n\t\tSize labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &amp;baseLine);\n\t\ttop = max(top, labelSize.height);\n\t\t//rectangle(frame, Point(left, top - int(1.5 * labelSize.height)), Point(left + int(1.5 * labelSize.width), top + baseLine), Scalar(0, 255, 0), FILLED);\n\t\tputText(img, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 1, color[result[i].id], 2);\n\t}\n\timshow(\"res\", img);\n\twaitKey();\n}\n</code></pre>\n<p>预测结果：</p>\n<p><img alt=\"\" height=\"1024\" src=\"..\\..\\static\\image\\ede11b49c9cd456886927606a30837b6.png\" width=\"1200\"/></p>\n<p> 大功告成啦，不得不说yolov7的效果相当的好，也感谢B导大大啦</p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-22 15:46:21", "summary": "使用导的代码部署，代码地址：模型的的训练看导即可，主地址：的博客博客神经网络学习小记录睿智的目标检测有趣的数据结构算法领域博主的博客博客神经网络学习小记录睿智的目标检测有趣的数据结构算法领域博主模型训"}