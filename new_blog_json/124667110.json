{"blogid": "124667110", "writerAge": "码龄2年", "writerBlogNum": "156", "writerCollect": "9129", "writerComment": "2471", "writerFan": "22570", "writerGrade": "7级", "writerIntegral": "13215", "writerName": "柠檬叶子C", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124667110.jpg", "writerRankTotal": "785", "writerRankWeekly": "635", "writerThumb": "6773", "writerVisitNum": "500513", "blog_read_count": "1740", "blog_time": "已于 2022-07-08 21:11:25 修改", "blog_title": "【C++要笑着学】vector 核心框架接口的模拟实现 | 基于STL3.0版本的简化vector | 浅谈迭代器失效问题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p> <img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\451dfef5a53e4c94a3ecbfb02d167973.png\" width=\"286\"/>  ​​​​​​ 🤣 爆笑教程 👉 <strong> <a href=\"https://blog.csdn.net/weixin_50502862/category_11602059.html\" title=\"《C++要笑着学》\">《C++要笑着学》</a></strong><strong> </strong>👈 火速订阅<strong>  </strong>🔥</p>\n<p></p>\n<p><img alt=\"\" height=\"123\" src=\"..\\..\\static\\image\\32974baa747043f9907e5bbd13639957.png\" width=\"679\"/></p>\n<p><strong>💭 写在前面</strong></p>\n<p>STL 的源代码整体考虑的东西比较多，还要考虑和其他地方的结合，因此整体的设计是比较复杂的。基于这一系列原因，我们会以简单的形式去实现其核心框架接口，方便去学习 vector。</p>\n<p>还是那句话，我们去模拟实现它们，不是为了造更好的轮子，而是为了去学习它，理解它的本质！自己造一次，心里会更清楚，更利于加深对它们的理解。</p>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\c52b4035e4864f4ba6cbbd9070bc53cd.png\" width=\"324\"/>  <strong> 本篇博客全站热榜排名：<span style=\"color:#fbd4d0;\">32</span></strong></p>\n<p></p>\n<hr/>\n<h2 id=\"%E2%85%A0.%20vector%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0\">Ⅰ. 实现基本框架</h2>\n<h3 id=\"0x00%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89\">0x00 结构的定义</h3>\n<p><img alt=\"\" height=\"123\" src=\"..\\..\\static\\image\\60b11889d405440d97fc73328e33afbe.png\" width=\"106\"/> 我们参考《STL源码剖析》，用 <em>STL3.0</em> 版本去实现一个阉割版的 <span style=\"color:#4da8ee;\">vector</span>。</p>\n<p></p>\n<p>💬 成员变量的定义：</p>\n<div>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\nnamespace chaos\n{\n\ttemplate&lt;class T&gt;\n\tclass vector {\n    public:\n\ttypedef T* iterator;\n\n\tprivate:\n\t\titerator _start;        // 开始位置\n\t\titerator _finish;\t\t// 结束位置\n\t\titerator _eos;\t\t\t// end of storage\n\t};\n}</code></pre>\n</div>\n<p>❓ 我们发现 —— 怎么成员函数和我们之前模拟实现<span style=\"color:#4da8ee;\"> string</span> 的写法不一样了？<img alt=\"\" height=\"79\" src=\"..\\..\\static\\image\\6959256f94334a3bbb76c044763c3018.png\" width=\"94\"/></p>\n<p>不要慌，我们参考的是 STL3.0 的写法，它给的就是 <span style=\"color:#0d0016;\">start</span> 、<span style=\"color:#0d0016;\">finish </span>和<span style=\"color:#0d0016;\"> end_of_storage</span>。</p>\n<p><span style=\"color:#a5a5a5;\">（这里我们把 end_of_storge 简写成 eos ）</span></p>\n<p>虽然表面上看起来不一样，但是实际上表达的效果是大同小异的，看图：</p>\n<p><img alt=\"\" height=\"369\" src=\"..\\..\\static\\image\\15f3b8c6e67b47daa11b1e23169dc25b.png\" width=\"601\"/></p>\n<p>我们用指针记录 <span style=\"color:#0d0016;\"><em>_start</em></span> 、<em><span style=\"color:#0d0016;\">_finish</span></em> 和 <span style=\"color:#0d0016;\"><em>_eos</em></span> 的位置，只需要 \"指针减指针\" 就可以得到大小或容量。</p>\n<p><img alt=\"\" height=\"183\" src=\"..\\..\\static\\image\\25027ee0100f4c05ab886182efde3348.png\" width=\"179\"/> 这非常的自由！我们想求 <span style=\"color:#0d0016;\">size</span>，只需要<em> <span style=\"color:#be191c;\">_finish - _start</span></em><span style=\"color:#be191c;\"> </span>即可，</p>\n<p>同样的，求<span style=\"color:#0d0016;\"> capacity </span>我们可以<em><span style=\"color:#be191c;\"> _eos - _start </span></em>。甚至可以求可用空间，<span style=\"color:#be191c;\"><em>_eos - _finish</em> </span>就行。</p>\n<p>真的是太自由了！我们之前实现 <span style=\"color:#4da8ee;\">string </span>时记录 <span style=\"color:#0d0016;\"><em>_capacity</em> </span>和 <em><span style=\"color:#0d0016;\">_size</span></em> 的形式，是不是瞬间不香了？</p>\n<p><img alt=\"\" height=\"150\" src=\"..\\..\\static\\image\\f2e054a51e344c7d8b4caabb69f023f0.png\" width=\"116\"/>  这种写法真的是非常的高雅，没错就是这么的🐂🍺！</p>\n<p></p>\n<p>再说回代码的实现，为了和库中的<span style=\"color:#4da8ee;\"> vector </span>进行区分，我们这里依然用命名空间包含起来。</p>\n<p>我们这里造一个<span style=\"color:#4da8ee;\"> vector </span>的类模板去适应各种类型，我们用 <span style=\"color:#956fe7;\">typedef </span>将 <span style=\"color:#ad720d;\">T*</span> 重命名为<span style=\"color:#ad720d;\"> iterator</span>。</p>\n<p></p>\n<p></p>\n<h3 id=\"0x01%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">0x01 构造函数的实现</h3>\n<p> <img alt=\"\" height=\"53\" src=\"..\\..\\static\\image\\bea89a62a5794d96a623cd102a0a8392.png\" width=\"129\"/> 这里要完成的是初始化工作，我们利用初始化列表将它们值成空指针即可。</p>\n<p>💬 vector：</p>\n<div>\n<pre><code class=\"language-cpp\">vector()\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _eos(nullptr) {}\n</code></pre>\n</div>\n<p></p>\n<h3 id=\"0x02%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">0x02 析构函数的实现</h3>\n<p><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\62ae7b0f785f4fada2d04b5af94df83d.png\" width=\"55\"/> 析构函数也没什么说的，要做的就是释放空间，并将定义的指针置空。</p>\n<p>💬 ~vector：</p>\n<div>\n<pre><code class=\"language-cpp\">/* 析构函数 */\n~vector() {\n\tif (_start) {\n\t\tdelete[] _start;\n\t\t_start = _finish = _eos = nullptr;\n\t}\n}</code></pre>\n</div>\n<p></p>\n<h3 id=\"0x03%C2%A0%E5%AE%9E%E7%8E%B0%20size()%20%E5%92%8C%20capacity()%C2%A0\">0x03 实现 size() 和 capacity() </h3>\n<p><img alt=\"\" height=\"60\" src=\"..\\..\\static\\image\\fe1eda8d04724766927260be2d8a69cd.png\" width=\"60\"/> 通过刚才的讲解，我们已经知道 <span style=\"color:#0d0016;\"><em> _start </em></span>、<span style=\"color:#0d0016;\"><em>_finish</em></span> 与<span style=\"color:#0d0016;\"><em> _eos </em></span>的用法了，</p>\n<p> 通过指针减指针，我们就可以轻松实现 <span style=\"color:#e6b223;\">size</span>() 和 <span style=\"color:#e6b223;\">capacity</span>() 了，实现方式如下：</p>\n<p></p>\n<p>💬 size：</p>\n<div>\n<pre><code class=\"language-cpp\">size_t size() const {\n\treturn _finish - _start;   // 返回数据个数\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"219\" src=\"..\\..\\static\\image\\dd24f95c7fa34d07a11a62a3a02cb232.png\" width=\"493\"/></p>\n<p></p>\n<p>💬 capacity：</p>\n<div>\n<pre><code class=\"language-cpp\">size_t capacity() const {\n\treturn _eos - _start;      // 返回容量\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"233\" src=\"..\\..\\static\\image\\1a2abfe593c04537ac539ace5c3c4875.png\" width=\"565\"/></p>\n<p></p>\n<h3 id=\"0x04%C2%A0%E5%AE%9E%E7%8E%B0%20push_back%20%E5%B0%BE%E6%8F%92\">0x04 实现 push_back 尾插</h3>\n<p><img alt=\"\" height=\"103\" src=\"https://img-blog.csdnimg.cn/82a395480aa54198b9b6dbb566cd6d82.gif\" width=\"103\"/> 我们这里先实现一个简单的 <span style=\"color:#e6b223;\">push_back</span>，以便于我们能先把<span style=\"color:#4da8ee;\"> vector </span>跑起来。</p>\n<p>因为是阉割版，我们的 <span style=\"color:#e6b223;\">push_back </span>也自然没有空间配置器，我们就用 <span style=\"color:#4da8ee;\">new </span>去替代它。</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"21\" src=\"..\\..\\static\\image\\a494197b64ef41b5a061f62a75ca846a.png\" width=\"278\"/></p>\n<p>​</p>\n</div>\n<p><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\fa8112e6f8d248f6b8f509ea9b1d26e9.png\" width=\"70\"/> 首先思考，尾插需要做哪些事？</p>\n<p><strong>Step1：检查是否需要增容</strong></p>\n<p>需要增容，就先增容后再插入数据；不需要增容，就直接插入数据。</p>\n<p>我们先去思考，如何判断是否需要增容 ——</p>\n<p>我们之前的判断方式是 <span style=\"color:#e6b223;\">size</span><span style=\"color:#0d0016;\"> ==</span><span style=\"color:#e6b223;\"> capacity</span> 的时候需要增容<span style=\"color:#a5a5a5;\">（数据结构专栏、string 的模拟实现）</span></p>\n<p>问题是，这次我们没有定义<span style=\"color:#0d0016;\"><em> _size</em></span> 和 <span style=\"color:#0d0016;\"><em>_capacity</em></span>，取而代之的是<span style=\"color:#0d0016;\"><em> _start</em></span> 、<span style=\"color:#0d0016;\"><em> _finish </em></span>和<span style=\"color:#0d0016;\"><em> _eos</em></span> 的形式。</p>\n<p><span style=\"color:#0d0016;\"><img alt=\"\" height=\"310\" src=\"..\\..\\static\\image\\a1698ac250f449da94d0ada39258315d.png\" width=\"572\"/></span></p>\n<p> 当 <em><span style=\"color:#0d0016;\">_finish</span> </em>触及到<span style=\"color:#0d0016;\"><em> _eos</em></span> <span style=\"color:#a5a5a5;\">（end of storage）</span> 时，不就说明容量不够了吗？如下所示：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"22\" src=\"..\\..\\static\\image\\d7e8211c2d464166801abb153877e23b.png\" width=\"190\"/></p>\n</div>\n<p><strong>Step2：如果需要增容</strong></p>\n<p><img alt=\"\" height=\"65\" src=\"..\\..\\static\\image\\9fe2f1dc3b7749a8a206ee68198a4a15.png\" width=\"77\"/> 我们再来思考一下增容部分的实现，我们在 <span style=\"color:#4da8ee;\">vector </span>常用接口介绍章节里说过：</p>\n<p><span style=\"color:#a5a5a5;\"><em>\" vector 使用动态分配数组来存储它的元素。当新元素插入时，为了增加存储空间，这个数组就需要被重新分配大小。具体做法是分配一个新的数组，然后将全部元素转移到这个新的数组。\"</em></span></p>\n<p>因此，我们的增容操作可以大致可分为4个步骤：</p>\n<blockquote>\n<p>① 开一块带有新容量的空间存到 <span style=\"color:#0d0016;\">tmp</span> 中。</p>\n<p>② 再把原空间的数据拷贝到新空间。</p>\n<p>③ 并释放原有的旧空间（我们先 \"故意\" 使用<span style=\"color:#e6b223;\"> memset</span>，至于 <span style=\"color:#e6b223;\">memset </span>的问题我们最后探讨）</p>\n<p>④ 最后将 <span style=\"color:#0d0016;\"><em>_start</em></span>、<em><span style=\"color:#0d0016;\">_finish</span></em> 和 <span style=\"color:#0d0016;\"><em>_eos</em></span> 指向新的空间。</p>\n</blockquote>\n<p>📌 注意事项：</p>\n<p>值得注意的是，最后一步如果先将<span style=\"color:#0d0016;\"><em> _start</em></span> 指向 <span style=\"color:#0d0016;\">tmp</span> 后，再计算<span style=\"color:#0d0016;\"> _finish</span> 时，</p>\n<p>此时不能现场算<span style=\"color:#e6b223;\"> size</span>() ，现场算会出问题，因为<span style=\"color:#0d0016;\"> <em>_start</em> </span>已经被更新成<span style=\"color:#0d0016;\"> tmp </span>了，</p>\n<p>如果不想改变顺序，还是想按 <span style=\"color:#0d0016;\"><em>_start</em></span>、<span style=\"color:#0d0016;\"><em>_finish</em></span> 和 <span style=\"color:#0d0016;\"><em>_eos </em></span>的顺序赋值，</p>\n<p>我们可以提前把 <span style=\"color:#e6b223;\">size</span>() 算好，存到一个变量中。</p>\n<p></p>\n<p><img alt=\"\" height=\"52\" src=\"..\\..\\static\\image\\4748fc1e596b44f79c3e9483fa5f260f.png\" width=\"52\"/> 此外，真 <span style=\"color:#4da8ee;\">vector </span>这里扩容是要调空间配置器的，开空间和初始化是分开的。</p>\n<p>我们这里的实现也没有空间配置器，所以这里就直接一把梭了。</p>\n<p>对于空间配置器的知识我们放到后面再说，我们目前的重点不是空间配置器，重点是 <span style=\"color:#4da8ee;\">vector</span>。</p>\n<p></p>\n<p>至于新容量给多少，我们还是按照自己的习惯，首次给4默认扩2倍的方式去增容。</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"23\" src=\"..\\..\\static\\image\\5a589e4e5b364613a67be4c5291804a8.png\" width=\"564\"/></p>\n<p>​</p>\n</div>\n<p><strong>Step3：插入数据</strong></p>\n<p><img alt=\"\" height=\"52\" src=\"..\\..\\static\\image\\1e7268a822834094ba533d74b0ec5c0c.png\" width=\"62\"/> 检查增容和增容都已经分析完了，最后就只剩一个插入了，插入是最简单的：</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"23\" src=\"..\\..\\static\\image\\d160095e6c8c4b8fb7cad99da56976b0.png\" width=\"270\"/></p>\n<p>​</p>\n</div>\n<p>💬 分析结束，开始写代码：</p>\n<div>\n<pre><code class=\"language-cpp\">/* 尾插：push_back */\nvoid push_back(const T&amp; x) {\n\t// 检查是否需要增容\n\tif (_finish == _eos) {\n\t\tsize_t new_capacity = capacity() == 0 ? 4 : capacity() * 2;\n\t\tsize_t sz = size();   // 提前把size算好\n\n\t\tT* tmp = new T[new_capacity];   // 开一块带有新容量new_capacity的空间存到tmp中\n\t\tif (_start) {\n\t\t\tmemcpy(tmp, _start, sizeof(T) * size());  // 再把原空间的数据拷贝到新空间，并释放原有的旧空间。\n\t\t\tdelete[] _start;                          // 并释放原有的旧空间\n\t\t}\n\n\t\t_start = tmp;                    // 指向新空间\n\t\t_finish = tmp + sz;\t\t\t   // 现场算size() 会有问题，因为start已经被更新成tmp了\n\t\t_eos = _start + new_capacity;\n\t}\n\n\t// 插入数据\n\t*_finish = x; _finish++;\n}</code></pre>\n</div>\n<p>为了方便测试尾插的效果，我们先来实现一下 <span style=\"color:#956fe7;\">operator</span>[] ，利用 \"下标+方括号\" 的方式遍历。</p>\n<p></p>\n<h3 id=\"0x05%C2%A0%E5%AE%9E%E7%8E%B0%20operator%5B%5D\">0x05 实现 operator[]</h3>\n<p><img alt=\"\" height=\"92\" src=\"..\\..\\static\\image\\37bb5f5c60334d4ba899c67cdf5bb1ee.png\" width=\"384\"/></p>\n<p><strong>T：</strong>由于我们不知道返回值类型，所以给 T。</p>\n<p><strong>T&amp;：</strong>引用返回减少拷贝。</p>\n<p><strong>const：</strong>这里<span style=\"color:#ad720d;\"> cosnt</span> 修饰 T 和<span style=\"color:#956fe7;\"> this</span>，是为了限制写。</p>\n<div>\n<pre><code class=\"language-cpp\">const T&amp; operator[](size_t idx) const {\n\tassert(idx &lt; size());\n\treturn _start[idx];\n}</code></pre>\n</div>\n<p>接收下标，断言判断一下下标是否合法，合直接返回。</p>\n<p></p>\n<p>💬 测试 push_back：</p>\n<div>\n<pre><code class=\"language-cpp\">    void test_vector1() {\n\t\tvector&lt;int&gt; v;\n\t\tv.push_back(1);\n\t\tv.push_back(2);\n\t\tv.push_back(3);\n\t\tv.push_back(4);\n\t\tv.push_back(5);\n\t\tv.push_back(6);\n\n\t\tfor (size_t i = 0; i &lt; v.size(); i++) {\n\t\t\tcout &lt;&lt; v[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}</code></pre>\n</div>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"122\" src=\"..\\..\\static\\image\\a4fdf9c897f34a709c25edd29d959d0a.png\" width=\"476\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A1.%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0\">Ⅱ. 迭代器的实现</h2>\n<h3 id=\"0x00%20%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%20begin%20%E5%92%8C%20end\">0x00 实现迭代器的 begin 和 end</h3>\n<p><img alt=\"\" height=\"55\" src=\"..\\..\\static\\image\\4be11bf06c974dc0952f277b111c10dc.png\" width=\"66\"/> <span style=\"color:#4da8ee;\">vector</span> 的迭代器是一个原生指针：</p>\n<div>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nclass vector {\npublic:\n\ttypedef T* iterator;\n\ttypedef const T* const_iterator;\n</code></pre>\n</div>\n<p>我先实现一下 <span style=\"color:#e6b223;\">begin</span>() 和 <span style=\"color:#e6b223;\">end</span>() ，直接分别返回 <span style=\"color:#0d0016;\"><em>_start </em></span>和 <em><span style=\"color:#0d0016;\">_finish </span></em>即可：</p>\n<p><img alt=\"\" height=\"204\" src=\"..\\..\\static\\image\\6083f913f67d467db193be8167395e11.png\" width=\"571\"/></p>\n<p> 💬 <span style=\"color:#e6b223;\">begin</span></p>\n<div>\n<pre><code class=\"language-cpp\">iterator begin() {\n\treturn _start;\n}</code></pre>\n</div>\n<p>💬 <span style=\"color:#e6b223;\">end</span></p>\n<div>\n<pre><code class=\"language-cpp\">iterator end() {\n\treturn _finish;\n}</code></pre>\n</div>\n<p></p>\n<h3 id=\"0x01%20%E5%AE%9E%E7%8E%B0%20const%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%20begin%20%E5%92%8C%20end\">0x01 实现 const 迭代器的 begin 和 end</h3>\n<p><img alt=\"\" height=\"111\" src=\"https://img-blog.csdnimg.cn/271a9335ba2047cdbf35f4cba5e1df92.gif\" width=\"109\"/><span style=\"color:#ad720d;\">const </span>类型的迭代器，即可读不可写。在实现的时候用<span style=\"color:#ad720d;\"> const </span>修饰即可：</p>\n<p>💬 begin</p>\n<div>\n<pre><code class=\"language-cpp\">const_iterator begin() const {\n\treturn _start;\n}</code></pre>\n</div>\n<p>💬 end</p>\n<div>\n<pre><code class=\"language-cpp\">const_iterator end() const {\n\treturn _finish;\n}</code></pre>\n</div>\n<p></p>\n<h3 id=\"0x02%20%E6%B5%8B%E8%AF%95%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C\">0x02 测试实现效果</h3>\n<p>💬 测试迭代器的效果：</p>\n<div>\n<pre><code class=\"language-cpp\">\tvoid test_vector1() {\n\t\tvector&lt;int&gt; v;\n\t\tv.push_back(1);\n\t\tv.push_back(2);\n\t\tv.push_back(3);\n\t\tv.push_back(4);\n\t\tv.push_back(5);\n\t\tv.push_back(6);\n\n\t\tfor (size_t i = 0; i &lt; v.size(); i++) {\n\t\t\tcout &lt;&lt; v[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\n\t\t// 迭代器\n\t\tvector&lt;int&gt;::iterator it = v.begin();\n\t\twhile (it != v.end()) {\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\tit++;\n\t\t}\n\t\tcout &lt;&lt; endl;\n    }</code></pre>\n</div>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"121\" src=\"..\\..\\static\\image\\0559614402074052ab57a51f4a19c26a.png\" width=\"485\"/></p>\n<p></p>\n<p>💬 我们知道，老老实实地实现迭代器，范围for也就能用了，我们来试试：</p>\n<div>\n<pre><code class=\"language-cpp\">\tvoid test_vector1() {\n\t\tvector&lt;int&gt; v;\n\t\tv.push_back(1);\n\t\tv.push_back(2);\n\t\tv.push_back(3);\n\t\tv.push_back(4);\n\t\tv.push_back(5);\n\t\tv.push_back(6);\n\n\t\t// 下标 + []\n\t\tfor (size_t i = 0; i &lt; v.size(); i++) {\n\t\t\tcout &lt;&lt; v[i] &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\n\t\t// 迭代器\n\t\tvector&lt;int&gt;::iterator it = v.begin();\n\t\twhile (it != v.end()) {\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\tit++;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t\t\n\t\t// 范围for\n\t\tfor (auto e : v) {\n\t\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}</code></pre>\n</div>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"163\" src=\"..\\..\\static\\image\\2781e167480a4ba2b5309ce6deb0fd58.png\" width=\"525\"/></p>\n<p><img alt=\"\" height=\"162\" src=\"..\\..\\static\\image\\dc81bd27dfe04544b2dab46ffe1f130b.png\" width=\"146\"/> 至此，我们已经还原好了上一章介绍的<span style=\"color:#4da8ee;\"> vector </span>的三种遍历方式。</p>\n<p></p>\n<p>💬 测试迭代器的 \"写\" ：</p>\n<div>\n<pre><code class=\"language-cpp\">\tvoid test_vector2() {\n\t\tvector&lt;int&gt; v;\n\t\tv.push_back(1);\n\t\tv.push_back(2);\n\t\tv.push_back(3);\n\t\tv.push_back(4);\n\t\tfor (auto e : v) cout &lt;&lt; e &lt;&lt; \" \";\n\t\tcout &lt;&lt; endl;\n\n\t\t// 迭代器\n\t\tvector&lt;int&gt;::iterator it = v.begin();\n\t\twhile (it != v.end()) {\n\t\t\t*it *= 2;\n\t\t\tit++;\n\t\t}\n\t\tfor (auto e : v) cout &lt;&lt; e &lt;&lt; \" \";\n\t}</code></pre>\n</div>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\4f09c63bab3d4acaa130df8be3d08e39.png\" width=\"454\"/></p>\n<p></p>\n<p>💬 测试一下 <span style=\"color:#ad720d;\">const </span>迭代器：</p>\n<div>\n<pre><code class=\"language-cpp\">\tvoid test_vector3() {\n\t\tvector&lt;int&gt; v;\n\t\tv.push_back(1);\n\t\tv.push_back(2);\n\t\tv.push_back(3);\n\t\tv.push_back(4);\n\n\t\t// const 迭代器\n\t\tvector&lt;int&gt;::const_iterator it = v.begin();\n\t\twhile (it != v.end()) {\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\tit++;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}</code></pre>\n</div>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"132\" src=\"..\\..\\static\\image\\d1e646af73eb4cff8490d75b1ae4fa22.png\" width=\"457\"/></p>\n<p></p>\n<p>❌ 如果对 <span style=\"color:#e6b223;\">const</span> 迭代器进行 \"写\" 操作：</p>\n<p><img alt=\"\" height=\"84\" src=\"..\\..\\static\\image\\76b8112a7226431d8180304589988501.png\" width=\"220\"/>  <span style=\"color:#be191c;\"><span style=\"background-color:#fbd4d0;\">error C3892: “it”: 不能给常量赋值</span></span></p>\n<p><img alt=\"\" height=\"135\" src=\"..\\..\\static\\image\\5fb62b28aa364cf0b984a95f2c86761a.png\" width=\"137\"/> …… 测试成功，果然不行，不行就对了。</p>\n<p></p>\n<h3 id=\"0x00%C2%A0%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8C%BA%E9%97%B4\">0x03 实现迭代器区间</h3>\n<p><img alt=\"\" height=\"144\" src=\"..\\..\\static\\image\\615e91a9d1f0424ebf23f164a01b31d7.png\" width=\"388\"/>​</p>\n<p><img alt=\"\" height=\"91\" src=\"..\\..\\static\\image\\ae5da8075ca749898b115e859ef7f773.png\" width=\"92\"/>我们在构造时需要注意，使用迭代器区间必须是左闭右开 —— <img alt=\"(\\, first, \\, last\\, ]\" src=\"https://latex.codecogs.com/gif.latex?%28%5C%2C%20first%2C%20%5C%2C%20last%5C%2C%20%5D\"/>​  .</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"43\" src=\"..\\..\\static\\image\\9c16b72b9018452cbbe73f1f9951f233.png\" width=\"437\"/></p>\n</div>\n<p><span style=\"color:#a5a5a5;\">（一个类模板的成员函数，又可以是一个函数模板）</span></p>\n<p>💬 迭代器区间：</p>\n<div>\n<pre><code class=\"language-cpp\">/* 迭代器区间 */\ntemplate &lt;class InputIterator&gt;  // 类模板的成员函数又可以是一个函数模板\nvector(InputIterator first, InputIterator last)\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _eos(nullptr) \n{\n\twhile (first != last) {   // 遵循左闭右开\n\t\t// 逐个插入\n\t\tpush_back(*first);\n\t\tfirst++;\n\t}\n}</code></pre>\n</div>\n<p>现在我们就可以用迭代器区间去初始化 <span style=\"color:#4da8ee;\">vector</span> 了。</p>\n<p></p>\n<p>❓ 为什么这里要叫<span style=\"color:#4da8ee;\"> </span><span style=\"color:#be191c;\">InputIterator</span>？不用它行不行？</p>\n<p>想要知道这个问题，我们先讲解一下迭代器的分类。</p>\n<p></p>\n<h3 id=\"%C2%A00x01%C2%A0%E6%B5%85%E8%B0%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB\"> 0x04 浅谈迭代器的分类</h3>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\"><tbody><tr><td><strong>迭代器</strong></td><td><strong>对应类型</strong></td></tr><tr><td> <p><strong>A 👴 输入 / 输出迭代器：</strong>input_iterator  /  output_iterator</p> <p>* 特点：单步向前迭代，不可写 / 单步向前迭代，可写</p> </td><td> <p>无对应类型</p> </td></tr><tr><td> <p><strong>B 🧓 单向迭代器：</strong>forward_iterator</p> <p>* 特点：满足以上所有功能，并且能 ++ </p> <p>（不能 - -没有 rbegin / rend）</p> </td><td> <p><a class=\"link-info\" href=\"https://www.cplusplus.com/reference/forward_list/\" title=\"&lt;forward_list&gt;\">&lt;forward_list&gt;</a>         （C++11）</p> <p><a href=\"https://www.cplusplus.com/reference/unordered_map/\" title=\"&lt;unordered_map&gt;\">&lt;unordered_map&gt;</a>  （C++11）</p> <p><a href=\"https://www.cplusplus.com/reference/unordered_set/\" title=\"&lt;unordered_set&gt;\">&lt;unordered_set&gt;</a>    （C++11）</p> </td></tr><tr><td> <p><strong>C 👨 双向迭代器：</strong>bidirectional_iterator</p> <p>* 特点：满足以上功能，并且能 ++，还能 - -</p> </td><td> <p><a href=\"https://www.cplusplus.com/reference/list/?kw=%3Clist%3E\" title=\"&lt;list&gt;\">&lt;list&gt;</a></p> <p><a href=\"https://www.cplusplus.com/reference/map/\" title=\"&lt;map&gt;\">&lt;map&gt;</a></p> <p><a href=\"https://www.cplusplus.com/reference/set/\" title=\"&lt;set&gt;\">&lt;set&gt;</a></p> </td></tr><tr><td> <p><strong>D 👶 随机迭代器：</strong>randomaccess_iterator</p> <p>* 特点：满足以上所有功能，能 ++ 能 - -，还能 + 和 -  </p> </td><td> <p><a href=\"https://www.cplusplus.com/reference/vector/\" title=\"&lt;vector&gt;\">&lt;vector&gt;</a></p> <p><a href=\"https://www.cplusplus.com/reference/deque/\" title=\"&lt;deque&gt;\">&lt;deque&gt;</a></p> </td></tr></tbody></table>\n<p></p>\n<blockquote>\n<p style=\"text-align:center;\">就功能上来说：<img alt=\"D&gt;C&gt;B&gt;A\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?D%3EC%3EB%3EA\"/>  （一代更比一代强）</p>\n</blockquote>\n<p><img alt=\"\" height=\"129\" src=\"https://img-blog.csdnimg.cn/072906e8385d4a3cae467cab1a8c62bf.gif\" width=\"153\"/> 它们本质上是一个继承关系：下面是子类，上面是父类。</p>\n<p>子类都是一个父类，因为它满足父类的所有特征。</p>\n<p></p>\n<p>也就是说，虽然在语法上它是个模板，允许你传任意类型的迭代器，</p>\n<p>但是在更深层次上存在着更进一步的限制 ——</p>\n<p><img alt=\"\" height=\"85\" src=\"..\\..\\static\\image\\6d1502c19d4148c3bf1689835a7b8d59.png\" width=\"663\"/></p>\n<p>① 它要求你传随机迭代器，你就不能用双向迭代器。因为只有随机迭代器才能满足随机迭代器的所有操作。换言之，<span style=\"background-color:#f9eda6;\">你不能用功能比它指定的迭代器少的迭代器。</span><span style=\"color:#a5a5a5;\">（可以理解为权限的放大）</span></p>\n<p></p>\n<p><img alt=\"\" height=\"132\" src=\"..\\..\\static\\image\\eaf4d3970c76452194b82a17d766e766.png\" width=\"897\"/></p>\n<p>② 它要求你用双向迭代器，你就不能用单向迭代器，因为单项迭代器不能满足所有双向迭代器的操作。<span style=\"background-color:#f9eda6;\">但是你可以用比它功能多的迭代器</span>，比如随机迭代器，因为随机迭代器也能满足双向迭代器的操作。因为随机迭代器是双向迭代器的子类，它满足父类（双向迭代器）的所有功能。<span style=\"color:#a5a5a5;\">（可以理解为权限的缩小）</span></p>\n<blockquote>\n<p>限制你用 \"儿子\" ，你就不能用 \"爸爸\" </p>\n<p>但是，限制你用 \"爸爸\"，你可以用 \"儿子\" </p>\n</blockquote>\n<p><img alt=\"\" height=\"101\" src=\"..\\..\\static\\image\\1a422a178db642f9989bd4e83d3a6a86.png\" width=\"110\"/> 我们弄明白了这些，我们再回到刚才提的问题 ——</p>\n<p>❓ 为什么这里要叫<span style=\"color:#4da8ee;\"> InputIterator</span>？不用它行不行？</p>\n<p>首先，InputIterator 是输入迭代器，这么写是为了满足命名规范。</p>\n<p>可以不用，我们可以传单向迭代器、双向迭代器，也可以传随机迭代器。</p>\n<p>因为这些迭代器都满足输入迭代器的所有功能。</p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A2.%20%E5%AE%9E%E7%8E%B0%20vector%20%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9\">Ⅲ. vector 的扩容</h2>\n<h3 id=\"0x00%20%E5%BC%95%E5%85%A5%EF%BC%9A%E5%85%88%E6%8A%8A%20reserve%20%E5%86%99%E5%92%AF\">0x00 引入：先把 reserve 写咯</h3>\n<p>我们要实现<span style=\"color:#4da8ee;\"> vector</span> 的<span style=\"color:#e6b223;\"> insert</span>，肯定需要用到增容，我们这里当然不会傻傻地重写一遍。</p>\n<p>我们可以把刚才写<span style=\"color:#e6b223;\"> push_back</span> 实现的增容部分拎出来，实现一个 <span style=\"color:#956fe7;\">CheckCapacity </span>函数。</p>\n<p>但是我们这里可以直接实现出 <span style=\"color:#e6b223;\">reserve</span>，到时候实现 <span style=\"color:#e6b223;\">resize</span> 也可以复用得上，岂不美哉？</p>\n<p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\31c836a67003174535a37a7ab18016e8.png\"/></p>\n<p>所以，我们先实现 <span style=\"color:#e6b223;\">reserve</span>，顺便把 <span style=\"color:#e6b223;\">resize</span> 再实现一下，再去实现 <span style=\"color:#e6b223;\">insert </span>。</p>\n<p></p>\n<h3 id=\"0x01%20%E5%AE%9E%E7%8E%B0%20reserve\">0x01 实现 reserve</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"95\" src=\"https://img-blog.csdnimg.cn/img_convert/a3b0cb4eae73522e4d027ae5c90282d4.gif\" width=\"96\"/></p>\n<p>直接复制粘贴刚才实现的 <span style=\"color:#e6b223;\">push_back</span> 中 \"检查否需要增容\" 的部分，然后稍作修改即可。</p>\n<p><img alt=\"\" height=\"288\" src=\"..\\..\\static\\image\\dfaf23c9fff9491e81cfdeb1041bf915.png\" width=\"574\"/></p>\n<p>首先还是检查是否真的需要扩容，如果传入的<span style=\"color:#0d0016;\"> new_capacity</span> 确实比现有 <span style=\"color:#e6b223;\">capacity </span>要大，</p>\n<p>并且 <span style=\"color:#be191c;\"><em>_finish == _eos</em></span> 时，我们就进行扩容，这相当于是一个检测，</p>\n<p>防止根本就不需要扩容，还给它扩容的情况。还是分为四个步骤：</p>\n<p><strong>① 开新空间：</strong><span style=\"color:#956fe7;\">new </span>空间的地方，我们直接给上传入的 <span style=\"color:#0d0016;\">new_capacity</span> 即可，要求开多少就开多少。</p>\n<p><strong>② 拷贝数据：</strong>暂时先用 <span style=\"color:#e6b223;\">memset</span><span style=\"color:#a5a5a5;\">（如果你知道 memcpy 的问题，先别急，我们最后再专门探讨）</span></p>\n<p><strong>③ 释放旧空间：</strong>释放 <span style=\"color:#0d0016;\"><em>_start</em></span>，<span style=\"color:#956fe7;\">new</span>[] 对应 <span style=\"color:#956fe7;\">delete</span>[] 去释放。</p>\n<p><strong>④ 指向新空间：</strong>把 <span style=\"color:#e6b223;\">size</span>() 提前算好，然后让<strong> </strong><span style=\"color:#0d0016;\"><em>_start</em></span>、<span style=\"color:#0d0016;\"><em>_finish</em></span> 和 <span style=\"color:#0d0016;\"><em>_eos </em>指向新空间。</span></p>\n<p>💬 <span style=\"color:#e6b223;\">reserve</span></p>\n<div>\n<pre><code class=\"language-cpp\">/* reserve */\nvoid reserve(size_t new_capacity) {\n\tif (new_capacity &gt; capacity()) {  \t\t\t// 检查是否真的需要扩容\n\t\tif (_finish == _eos) {\n\t\t\tsize_t sz = size();   // 提前把size算好\n\n\t\t\tT* tmp = new T[new_capacity];\n\t\t\tif (_start) {\n\t\t\t\tmemcpy(tmp, _start, sizeof(T) * size());  // 再把原空间的数据拷贝到新空间，并释放原有的旧空间。\n\t\t\t\tdelete[] _start;                          // 并释放原有的旧空间\n\t\t\t}\n\n\t\t\t_start = tmp;                    // 指向新空间\n\t\t\t_finish = tmp + sz;\t\t\t     // 现场算size() 会有问题，因为start已经被更新成tmp了\n\t\t\t_eos = _start + new_capacity;\n\t\t}\n\t}\n}</code></pre>\n</div>\n<p></p>\n<h3 id=\"0x02%20%E8%AE%A9%20push_back%20%E5%A4%8D%E7%94%A8%20reserve\">0x02 让 push_back 复用 reserve</h3>\n<p><img alt=\"\" height=\"48\" src=\"https://img-blog.csdnimg.cn/b39fc3544c9549bb804d8186f61f69af.gif\" width=\"48\"/> 实现完<span style=\"color:#e6b223;\"> reserve </span>之后，我们可以把刚才的 <span style=\"color:#e6b223;\">push_back </span>简化一下：</p>\n<p>有了 <span style=\"color:#e6b223;\">reserve</span>，我们的<span style=\"color:#e6b223;\"> push_back </span>直接去调它就可以了，还是按首次给4，默认扩2倍的形式走。</p>\n<p>三目运算符得到的结果传入 <span style=\"color:#e6b223;\">reserve</span>，结果变成 <span style=\"color:#e6b223;\">reserve </span>中的<span style=\"color:#0d0016;\"> new_capacity </span>参数，</p>\n<p>然后 <span style=\"color:#e6b223;\">reserve </span>执行<span style=\"color:#956fe7;\"> new </span>的时候，会按照传入的<span style=\"color:#0d0016;\"> new_capactiy</span> 的大小去开空间。</p>\n<p><img alt=\"\" height=\"97\" src=\"..\\..\\static\\image\\5ebd68ecf5c143a29c2ee02493d1de94.png\" width=\"106\"/>​ 最后再插入数据即可。所以，本质上其实是一样的。</p>\n<p>⚡ push_back：</p>\n<div>\n<pre><code class=\"language-cpp\">/* 尾插：push_back */\nvoid push_back(const T&amp; x) {\n\t// 检查是否需要增容\n\tif (_finish == _eos) {\n\t\t// 扩容\n\t\treserve(capacity() == 0 ? 4 : capacity() * 2);\n\t}\n\n\t// 插入数据\n\t*_finish = x; \n\t_finish++;\n}</code></pre>\n</div>\n<p></p>\n<h3 id=\"0x03%C2%A0%E4%BD%BF%E7%94%A8%20memcpy%20%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98\">0x03 使用 memcpy 拷贝问题</h3>\n<p><img alt=\"\" height=\"70\" src=\"..\\..\\static\\image\\1d3dfd7a92de4b0ab77a9d1dd493a8da.png\" width=\"85\"/> 我们一开始实现的<span style=\"color:#e6b223;\"> push_back</span> 就用了<span style=\"color:#e6b223;\"> memcpy</span> 进行拷贝的，</p>\n<p>然后我们刚才实现了 <span style=\"color:#e6b223;\">reserve</span>，因而又让 <span style=\"color:#e6b223;\">push_back </span>复用了<span style=\"color:#e6b223;\"> reserve</span>， </p>\n<p><span style=\"color:#e6b223;\">reserve</span><span style=\"color:#ad720d;\"> </span>搬元素的时候也是 <span style=\"color:#e6b223;\">memcpy </span>去进行拷贝的，其实这里存在一个非常严重的问题！</p>\n<p></p>\n<p>💬 我们现在给出一个测试用例：</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector10() {\n\t\tvector&lt;string&gt; v;      // 在vector里放string\n\t\tv.push_back(\"233333333333333333\");\n\t\tv.push_back(\"233333333333333333\");\n\t\tv.push_back(\"233333333333333333\");\n\t\tv.push_back(\"233333333333333333\");\n\t\tv.push_back(\"233333333333333333\");\n\t\tv.push_back(\"233333333333333333\");\n\t\tv.push_back(\"233333333333333333\");\n\n\t\tfor (auto&amp; e : v) {\n\t\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"362\" src=\"..\\..\\static\\image\\10133e141b5c4fb7a9ec91446eb703d5.png\" width=\"528\"/></p>\n<p>为什么会这样？原因在于我们在扩容和深拷贝时，用了一个 <span style=\"color:#e6b223;\">memcpy</span>！</p>\n<p><span style=\"color:#e6b223;\">push_back</span> 调用<span style=\"color:#e6b223;\"> reserve</span> 扩容时就会出问题，根本原因是<span style=\"color:#e6b223;\"> memcpy </span>是浅拷贝。</p>\n<p><img alt=\"\" height=\"540\" src=\"..\\..\\static\\image\\87f4578900304e6ea7e2afa6716f86f6.png\" width=\"462\"/></p>\n<p><img alt=\"\" height=\"817\" src=\"..\\..\\static\\image\\77aa6f374cd747dfa98996e3230f6d00.png\" width=\"601\"/></p>\n<p><strong>问题分析：</strong></p>\n<p><span style=\"color:#e6b223;\">memcpy </span>是内存的二进制格式拷贝，</p>\n<p>将一段内存空间中内容原封不动的拷贝到另外一段内存空间中。</p>\n<p>如果拷贝的是自定义类型的元素，<span style=\"color:#e6b223;\">memcpy </span>既高效又不会出错，</p>\n<p>但如果拷贝的是自定义类型元素，并且自定义类型元素中涉及到资源管理时，</p>\n<p>就会出错，因为memcpy的拷贝实际是浅拷贝。</p>\n<p></p>\n<p><strong>结论：</strong></p>\n<p>如果对象中涉及到资源管理时，千万不能使用<span style=\"color:#e6b223;\"> memcpy </span>进行对象之间的拷贝，</p>\n<p> <img alt=\"\" height=\"111\" src=\"..\\..\\static\\image\\a8fabb951f5f4c7a8641628e928de4de.png\" width=\"103\"/> 因为 <span style=\"color:#e6b223;\">memcpy</span> 是浅拷贝，否则可能会引起内存泄漏甚至程序崩溃！</p>\n<p></p>\n<p><strong>解决方案：</strong></p>\n<p>不要使用 <span style=\"color:#e6b223;\">memcpy</span>，我们手动去拷！</p>\n<p>⚡ 我们修改一下 reserve：</p>\n<pre><code class=\"language-cpp\">/* reserve */\nvoid reserve(size_t new_capacity) {\n\tif (new_capacity &gt; capacity()) {  \t\t\t// 检查是否真的需要扩容\n\t\tif (_finish == _eos) {\n\t\t\tsize_t sz = size();   // 提前把size算好\n\n\t\t\tT* tmp = new T[new_capacity];\n\t\t\tif (_start) {\n\t\t\t\t// memcpy(tmp, _start, sizeof(T) * size());   有问题！\n\n\t\t\t\t\t//自己把原空间的数据拷贝到新空间\n\t\t\t\tfor (size_t i = 0; i &lt; sz; i++) { \n\t\t\t\t\t// 如果T是int，一个一个拷贝没问题\n\t\t\t\t\t// 如果T是string等自定义问题，一个一个拷贝调用的是T的深拷贝，也不会出问题。\n\t\t\t\t\ttmp[i] = _start[i];  \n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdelete[] _start;                          // 并释放原有的旧空间\n\t\t\t}\n\n\t\t\t_start = tmp;                    // 指向新空间\n\t\t\t_finish = tmp + sz;\t\t\t     // 现场算size() 会有问题，因为start已经被更新成tmp了\n\t\t\t_eos = _start + new_capacity;\n\t\t}\n\t}\n}</code></pre>\n<p>如果 <span style=\"color:#0d0016;\">T</span> 是<span style=\"color:#ad720d;\"> int</span>，一个一个拷贝没问题，<br/> 如果 <span style=\"color:#0d0016;\">T</span> 是<span style=\"color:#ad720d;\"> string</span> 等自定义问题，一个一个拷贝调用的是 <span style=\"color:#0d0016;\">T </span>的深拷贝，也不会出问题。</p>\n<p></p>\n<p>我们拿刚才的测试用例测试一下，看看效果如何：</p>\n<p><img alt=\"\" height=\"190\" src=\"..\\..\\static\\image\\3fe99535f22a4dfeb3a359f3c3f6f73c.png\" width=\"639\"/></p>\n<p></p>\n<h3 id=\"0x03%C2%A0%E5%AE%9E%E7%8E%B0%20resize\">0x03 实现 resize</h3>\n<p>💬 resize：</p>\n<div>\n<pre><code class=\"language-cpp\">/* resize */\nvoid resize(size_t new_capacity, const T&amp; val = T()) {\n\t// 如果容量足够\n\tif (new_capacity &lt; size()) {       \n\t\t_finish = _start + new_capacity;   // 直接修改 _finish\n\t}\n\telse {  // 容量不够\n\t\tif (new_capacity &gt; capacity()) {   // 检查是否需要扩容\n\t\t\treserve(new_capacity); \n\t\t}\n\t\twhile (_finish != _start + new_capacity) {   // 初始化\n\t\t\t*_finish = val;  // 按val初始化，默认缺省为 T()\n\t\t\t_finish++;\n\t\t}\n\t}\n}</code></pre>\n</div>\n<p><span style=\"color:#4da8ee;\">vector</span> 的 <span style=\"color:#e6b223;\">resize</span> 如果不给第二个参数，默认给的是其对应类型的缺省值作为 \"填充值\"。</p>\n<p>由于这里我们不知道具体类型是什么，这里缺省值我们使用匿名对象<span style=\"color:#0d0016;\"> T</span>() ，</p>\n<p>此外因为匿名对象的生命周期仅在当前一行，这里必须要用 <span style=\"color:#ad720d;\">const</span> 引用匿名对象，</p>\n<p><img alt=\"\" height=\"151\" src=\"..\\..\\static\\image\\1dbe2adeffd245c8afc9526466f8886a.png\" width=\"206\"/> 可以理解为延长其生命周期。</p>\n<p></p>\n<h3 id=\"0x04%C2%A0%E5%AE%9E%E7%8E%B0%20pop_back\">0x04 实现 pop_back</h3>\n<p><img alt=\"\" height=\"96\" src=\"..\\..\\static\\image\\bf270ee81bf84ff58d38bdecce0a9f75.png\" width=\"97\"/><span style=\"color:#e6b223;\"> pop_back</span> 很简单，只需要 <em><span style=\"color:#be191c;\">_finish--</span></em> 就可以了。</p>\n<p> 但是需要考虑删完的情况，我们这里采用暴力的处理方式 —— 断言。</p>\n<p></p>\n<p>💬 push_back</p>\n<pre><code class=\"language-cpp\">/* 尾删：pop_back */\nvoid pop_back() {\n\tassert(_finish &gt; _start);\n\t_finish--;\n}</code></pre>\n<p>测试一下：</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector6() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\n\t\tv1.pop_back();\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n 🚩 运行结果如下：\n</blockquote>\n<p><img alt=\"\" height=\"134\" src=\"..\\..\\static\\image\\83f64818e6284ab0b8a2136e04a11054.png\" width=\"462\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"50\" src=\"..\\..\\static\\image\\4c185267f2a848f99ff58c7fb9088ef0.png\" width=\"51\"/> 测试一下断言效果：</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector6() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\n\t\tv1.pop_back();\n\t\tv1.pop_back();\n\t\tv1.pop_back();\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p> <img alt=\"\" height=\"254\" src=\"..\\..\\static\\image\\2516763858ab479386b5b205c08a8c3c.png\" width=\"448\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A3.%20%E6%B5%85%E8%B0%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98\">Ⅳ. 浅谈迭代器失效问题</h2>\n<h3 id=\"0x00%20%E5%BC%95%E5%85%A5%EF%BC%9A%E9%80%9A%E8%BF%87%20insert%20%2F%20erase%20%E4%BA%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98\">0x00 引入：通过 insert / erase 了解迭代器失效问题</h3>\n<p><img alt=\"\" height=\"126\" src=\"..\\..\\static\\image\\7553b02bfa9f49f49e3e29b3179af184.png\" width=\"116\"/>我们通过实现<span style=\"color:#4da8ee;\"> vector</span> 的<span style=\"color:#e6b223;\"> insert</span> 和 <span style=\"color:#e6b223;\">erase</span>，去顺带讲解迭代器失效的问题。</p>\n<p>❓ 什么是迭代器失效？</p>\n<blockquote>\n<p>\" 迭代器失效是一种现象，由特定操作引发，这些特定操作对容器进行操作，使得迭代器不指向容器内的任何元素，或者使得迭代器指向的容器元素发生了改变。\"</p>\n</blockquote>\n<p>迭代器的主要作用就是让算法能够不用关心底层数据结构，其底层实际就是一个指针，</p>\n<p>或者是对指针进行了封装，比如：<span style=\"color:#4da8ee;\">vector </span>的迭代器就是原生态指针 <span style=\"color:#ad720d;\">T* </span>。</p>\n<p>因此迭代器失效，实际就是迭代器底层对应指针所指向的空间被销毁了，</p>\n<p>而使用一块已经被释放的空间，造成的后果是程序崩溃，</p>\n<p>即，如果继续使用已经失效的迭代器，程序可能会出现崩溃。</p>\n<p></p>\n<h3 id=\"0x01%C2%A0%E5%AE%9E%E7%8E%B0%20insert\">0x01 实现 insert</h3>\n<p>插入可分为四个步骤：① 检查 pos 是否越界   ② 检查是否需要扩容  ③ 移动数据   ④ 插入数据</p>\n<p></p>\n<p>💬 insert</p>\n<pre><code class=\"language-cpp\">/* 插入 */\nvoid insert(iterator pos, const T&amp; x) {\n\tassert(pos &gt;= _start);\n\tassert(pos &lt;= _finish);\n\n\t// 检查是否需要增容\n\tif (_finish == _eos) {\n\t\t// 扩容\n\t\treserve(capacity() == 0 ? 4 : capacity() * 2);\n\t}\n\n\t// 移动数据\n\titerator end = _finish - 1;\n\twhile (end &gt;= pos) {\n\t\t*(end + 1) = *end;\n\t\tend--;\n\t}\n\t\t\t\n\t// 插入数据\n\t*pos = x;\n\t_finish++;\n}</code></pre>\n<p></p>\n<p>💬 测试：在2的位置前插入一个20</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector7() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tv1.push_back(3);\n\t\tvector&lt;int&gt;::iterator pos = find(v1.begin(), v1.end(), 2);\n\t\tif (pos != v1.end()) { \n\t\t\tv1.insert(pos, 20);\n\t\t}\n\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"134\" src=\"..\\..\\static\\image\\09ca880ad96a4b5fa2972447b478b9b8.png\" width=\"408\"/></p>\n<p></p>\n<p>我们的 <span style=\"color:#e6b223;\">insert</span> 似乎没什么问题？我们再 <span style=\"color:#e6b223;\">push_back </span>一个数据看看，让它出现扩容的情况：</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector7() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tv1.push_back(3);\n\t\tv1.push_back(4);\n\t\tvector&lt;int&gt;::iterator pos = find(v1.begin(), v1.end(), 2);\n\t\tif (pos != v1.end()) {\n\t\t\tv1.insert(pos, 20);\n\t\t}\n\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"159\" src=\"..\\..\\static\\image\\68c65cc5975b4ad1a4c8fbc81241fd59.png\" width=\"613\"/></p>\n<p>迭代器失效问题。扩容导致的<span style=\"color:#0d0016;\"> pos</span> 失效，我们的<span style=\"color:#e6b223;\"> insert </span>没有去处理这个问题。</p>\n<p>如果发生扩容，我们的 <span style=\"color:#0d0016;\">pos</span> 是不是应该去更新一下？</p>\n<p>💬 insert：</p>\n<pre><code class=\"language-cpp\">/* 插入 */\nvoid insert(iterator pos, const T&amp; x) {\n\tassert(pos &gt;= _start);\n\tassert(pos &lt;= _finish);\n\n\t// 检查是否需要增容\n\tif (_finish == _eos) {\n\t\t// 扩容会导致迭代器失效，扩容需要更新一下 pos\n\t\tsize_t len = pos - _start;\n\t\treserve(capacity() == 0 ? 4 : capacity() * 2);\n\n\t\tpos = _start + len;\n\t}\n\n\t// 移动数据\n\titerator end = _finish - 1;\n\twhile (end &gt;= pos) {\n\t\t*(end + 1) = *end;\n\t\tend--;\n\t}\n\t\t\t\n\t// 插入数据\n\t*pos = x;\n\t_finish++;\n}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"154\" src=\"..\\..\\static\\image\\04821f11a5ea4c2f8f751de46c0895fb.png\" width=\"611\"/></p>\n<p></p>\n<p>但是外面的<span style=\"color:#0d0016;\"> pos</span>（实参） 还是失效的，这里是传值，<span style=\"color:#a5a5a5;\">pos</span>（形参） 是<span style=\"color:#0d0016;\"> pos</span>（实参） 的临时拷贝。 </p>\n<p class=\"img-center\"><img alt=\"\" height=\"23\" src=\"..\\..\\static\\image\\db8c2b6d9bf04f229c33e600b31ded07.png\" width=\"215\"/></p>\n<p>如果 <span style=\"color:#e6b223;\">insert </span>中发生了扩容，那么会导致<span style=\"color:#0d0016;\"> pos</span>（实参）指向空间被释放。</p>\n<p><span style=\"color:#0d0016;\">pos</span>（实参） 本身就是一个野指针，这种问题我们称之为 —— 迭代器失效<strong> </strong></p>\n<p></p>\n<p>❓ 如何解决这里的迭代器失效问题？传引用？</p>\n<p>传引用当然时不好的，有的 vector 还会缩容呢，传引用不能彻底解决所有问题。</p>\n<p></p>\n<p>🔍 我们来看看大佬是如何解决这一问题的：</p>\n<p><img alt=\"\" height=\"119\" src=\"..\\..\\static\\image\\3cd9c762ba284a05bd578d55f205b01e.png\" width=\"544\"/></p>\n<p>然而它们是通过返回值去拿的，返回新插入的迭代器。</p>\n<p>如果迭代器失效了，你想拿另一个迭代器去代替，就可以通过返回值去拿一下。</p>\n<p>⚡ insert：</p>\n<pre><code class=\"language-cpp\">/* 插入 */\niterator insert(iterator pos, const T&amp; x) {\n\tassert(pos &gt;= _start);\n\tassert(pos &lt;= _finish);\n\n\t// 检查是否需要增容\n\tif (_finish == _eos) {\n\t\t// 扩容会导致迭代器失效，扩容需要更新一下 pos\n\t\tsize_t len = pos - _start;\n\t\treserve(capacity() == 0 ? 4 : capacity() * 2);\n\n\t\tpos = _start + len;\n\t}\n\n\t// 移动数据\n\titerator end = _finish - 1;\n\twhile (end &gt;= pos) {\n\t\t*(end + 1) = *end;\n\t\tend--;\n\t}\n\t\t\t\n\t// 插入数据\n\t*pos = x;\n\t_finish++;\n\n\treturn pos;\n}</code></pre>\n<p></p>\n<h3 id=\"0x02%C2%A0%E5%AE%9E%E7%8E%B0%C2%A0erase\">0x02 实现 erase</h3>\n<p>💬 erase</p>\n<pre><code class=\"language-cpp\">void erase(iterator pos) {\n\tassert(pos &gt;= _start);\n\tassert(pos &lt;= _finish);\n\n\titerator begin = pos + 1;\n\twhile (begin &lt; _finish) {\n\t\t*(begin - 1)* begin;\n\t\tbegin++;\n\t}\n\n\t_finish--;\n}</code></pre>\n<p></p>\n<p>💬 测试：删除2</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector8() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tv1.push_back(3);\n\t\tv1.push_back(4);\n\t\tvector&lt;int&gt;::iterator pos = find(v1.begin(), v1.end(), 2);\n\t\tif (pos != v1.end()) {    \n\t\t\tv1.erase(pos);\n\t\t}\n\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"128\" src=\"..\\..\\static\\image\\1054a25231c54129bbd351836a30839c.png\" width=\"471\"/></p>\n<p><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\9eb0367eb5584e37a8c72e5a169f21e6.png\" width=\"70\"/>思考：<span style=\"color:#e6b223;\">erase </span>有没有迭代器失效的问题？</p>\n<p>当然了，<span style=\"color:#e6b223;\">erase </span>也会有失效的情况！</p>\n<p></p>\n<p>💬 比如我们要求删除 <span style=\"color:#0d0016;\">v1 </span>所有的偶数：</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector8() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tv1.push_back(3);\n\t\tv1.push_back(4);\n        v1.push_back(5);\n\n\t\t// 要求删除v1所有的偶数\n\t\tvector&lt;int&gt;::iterator pos = find(v1.begin(), v1.end(), 2);\n\t\twhile (pos != v1.end()) {\n\t\t\tif (*pos % 2 == 0) {\n\t\t\t\tv1.erase(pos);\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<p>❓ 删除会导致 <span style=\"color:#0d0016;\">pos </span>失效吗？</p>\n<p>我们用三种场景去测试：</p>\n<pre><code class=\"language-cpp\">1 2 3 4 5\n1 2 4 5\n1 2 3 4</code></pre>\n<p>测试结果如下，如果数据是：</p>\n<p>①  1 2 3 4 5  👉 正常（其实是个巧合）</p>\n<p><img alt=\"\" height=\"108\" src=\"..\\..\\static\\image\\8dd08d41cfbe45e5b9ef543e800fb20b.png\" width=\"398\"/></p>\n<p>②  1 2 3 4    👉 崩溃</p>\n<p><img alt=\"\" height=\"259\" src=\"..\\..\\static\\image\\d821032829eb4884bbde2051843045c3.png\" width=\"458\"/></p>\n<p>③  1 2 4 5    👉 结果不对（没删除完）</p>\n<p><img alt=\"\" height=\"130\" src=\"..\\..\\static\\image\\46d4dc8e82a94870b3825ffc36610a8f.png\" width=\"447\"/></p>\n<p><span style=\"color:#e6b223;\">erase</span>(<span style=\"color:#0d0016;\">pos</span>) 以后，<span style=\"color:#0d0016;\">pos</span> 指向的意义已经变了，直接 <span style=\"color:#0d0016;\">pos</span><span style=\"color:#be191c;\">++</span> 可能会导致一些意料之外的结果。</p>\n<p><strong>对于情况 ③：</strong>比如连续的偶数，导致后一个偶数没有判断，导致没有删掉。</p>\n<p>再其次，<span style=\"color:#e6b223;\">erase</span> 的删除有些<span style=\"color:#4da8ee;\"> vector</span> 版本的实现，不排除它会缩容。</p>\n<p>如果是这样，<span style=\"color:#e6b223;\">erase</span>(<span style=\"color:#0d0016;\">pos</span>) 以后，<span style=\"color:#0d0016;\">pos </span>也可能会是野指针，跟 <span style=\"color:#e6b223;\">insert </span>类似。</p>\n<p><span style=\"color:#a5a5a5;\">（SGI 和 PJ 版本 vector 都不会缩容）</span></p>\n<p><strong>对于情况 ②：</strong>如果最后一个数据是偶数，会导致<span style=\"color:#e6b223;\"> erase</span> 以后，<span style=\"color:#0d0016;\">pos </span>意义变了。</p>\n<p>再 <span style=\"color:#be191c;\">++</span> 一下，导致<span style=\"color:#be191c;\"> </span><span style=\"color:#0d0016;\">pos</span><span style=\"color:#be191c;\"> </span>和<span style=\"color:#0d0016;\"> end </span>错过结束判断，出现越界问题。</p>\n<p><strong>而情况 ①：</strong> 之所以没有翻车，是因为被删除的偶数后面恰巧跟的是奇数，运气好逃过了一劫。</p>\n<p></p>\n<p>导致上述三种问题的本质：<span style=\"color:#e6b223;\">erase</span>(<span style=\"color:#0d0016;\">pos</span>) 以后，<span style=\"color:#0d0016;\">pos </span>的意义变了，再去 <span style=\"color:#0d0016;\">pos</span><span style=\"color:#be191c;\">++</span> 是不对的。</p>\n<p>为了解决这个问题，<span style=\"color:#e6b223;\">erase</span> 是这么说明的：</p>\n<p><img alt=\"\" height=\"243\" src=\"..\\..\\static\\image\\de3de9263d154806ae5eb7df9549a01a.png\" width=\"1200\"/></p>\n<p>最近<span style=\"color:#e6b223;\"> erase </span>的元素的后方位置。</p>\n<p>⚡ 改进<span style=\"color:#e6b223;\"> erase</span>：</p>\n<pre><code class=\"language-cpp\">/* 删除 */\niterator erase(iterator pos) {\n\tassert(pos &gt;= _start);\n\tassert(pos &lt;= _finish);\n\n\titerator begin = pos + 1;\n\twhile (begin &lt; _finish) {\n\t\t*(begin - 1) = *begin;\n\t\tbegin++;\n\t}\n\n\t_finish--;\n\n\treturn pos;\n}\n\n\tvoid test_vector9() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tv1.push_back(3);\n\t\tv1.push_back(4);\n\n\t\t// 要求删除v1所有的偶数\n\t\tvector&lt;int&gt;::iterator pos = find(v1.begin(), v1.end(), 2);\n\t\twhile (pos != v1.end()) {\n\t\t\tif (*pos % 2 == 0) {\n\t\t\t\tpos = v1.erase(pos);  // erase以后pos失效，会返回下一个位置的迭代器\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"117\" src=\"..\\..\\static\\image\\cfdf1b1a705940509b33a3fca3a83f25.png\" width=\"492\"/></p>\n<p></p>\n<h3 id=\"0x03%20%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E6%93%8D%E4%BD%9C\">0x03 可能导致迭代器失效的操作</h3>\n<p><img alt=\"\" height=\"89\" src=\"..\\..\\static\\image\\d6dc3dfb6dd344dea20b3cf03cdfbf3c.png\" width=\"97\"/> 对于 <span style=\"color:#4da8ee;\">vector</span> 可能会导致其迭代器失效的操作有：</p>\n<p>① 会引起其底层空间改变的操作，都有可能存在迭代器失效。</p>\n<p>比如：<span style=\"color:#e6b223;\">resize</span>、<span style=\"color:#e6b223;\">reverse</span>、<span style=\"color:#e6b223;\">insert</span>、<span style=\"color:#e6b223;\">assign</span>、<span style=\"color:#e6b223;\">push_back</span> 等。</p>\n<p></p>\n<p>② 指定位置元素的删除操作：<span style=\"color:#e6b223;\">erase</span></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;vector&gt;\nint main()\n{\n\tint a[] = { 1, 2, 3, 4 };\n\tvector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));\n\t// 使用find查找3所在位置的iterator\n\tvector&lt;int&gt;::iterator pos = find(v.begin(), v.end(), 3);\n\t// 删除pos位置的数据，导致pos迭代器失效。\n\tv.erase(pos);\n\tcout &lt;&lt; *pos &lt;&lt; endl; // 此处会导致非法访问\n\treturn 0;\n}\n\n\n</code></pre>\n<p><span style=\"color:#e6b223;\">erase </span>删除 <span style=\"color:#0d0016;\">pos </span>位置元素后，<span style=\"color:#0d0016;\">pos</span> 位置之后的元素就会往前搬移，</p>\n<p>没有导致底层空间的改变，理论上讲迭代器不应该会失效。</p>\n<p>但是 <span style=\"color:#0d0016;\">pos </span>刚好是最后一个元素，删完之后 <span style=\"color:#0d0016;\">pos</span> 刚好在<span style=\"color:#0d0016;\"> end</span> 的位置，</p>\n<p>而 <span style=\"color:#0d0016;\">end</span> 位置是没有元素的，那么 <span style=\"color:#0d0016;\">pos</span> 就失效了。</p>\n<p>因此删除 <span style=\"color:#4da8ee;\">vector</span> 中任意位置元素时，<strong>VS</strong> 就认为该位置迭代器失效了。</p>\n<p></p>\n<p>还有就是我们刚才讲解的奇偶数，删除 <span style=\"color:#0d0016;\">pos</span> 位置的数据，导致<span style=\"color:#0d0016;\"> pos </span>迭代器失效。</p>\n<p>当然，<span style=\"color:#4da8ee;\">vector</span> 迭代器的失效主要发生在<span style=\"color:#4da8ee;\"> insert </span>和 <span style=\"color:#4da8ee;\">erase</span>。<span style=\"color:#4da8ee;\">vector </span>的其他接口基本不碰迭代器，自然也就不涉及这些问题。</p>\n<p><span style=\"background-color:#f9eda6;\">迭代器失效解决方法：在使用前，对迭代器重新赋值即可。</span></p>\n<p></p>\n<p>❓<span style=\"color:#4da8ee;\"> string</span> 的<span style=\"color:#e6b223;\"> insert </span>和<span style=\"color:#e6b223;\"> erase </span>迭代器是否会失效？<span style=\"color:#4da8ee;\">string</span><span style=\"color:#e6b223;\"> </span>有没有迭代器失效？</p>\n<p>💡 当然会，<span style=\"background-color:#f9eda6;\">只要使用迭代器的容器，都可能会涉及迭代器失效。</span></p>\n<p>只是<span style=\"color:#4da8ee;\"> string</span><span style=\"color:#e6b223;\"> </span>一般很少涉及迭代器失效，因为它<span style=\"color:#e6b223;\"> insert </span>和 <span style=\"color:#e6b223;\">erase</span> 时主要用下标。</p>\n<p></p>\n<p></p>\n<h2 id=\"%E2%85%A5.%20vector%20%E6%B7%B1%E6%8B%B7%E8%B4%9D\">Ⅴ. vector 深拷贝</h2>\n<h3 id=\"0x00%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0\">0x00 拷贝构造</h3>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"30\" src=\"..\\..\\static\\image\\8bf1d4a1ee4c4e63a434d5f3496b12d4.png\" width=\"270\"/></p>\n<p><img alt=\"\" height=\"56\" src=\"..\\..\\static\\image\\2e3a25dfec624216b815f0ccb825ffb1.png\" width=\"136\"/>​ 可以使用传统写法，也可以使用现代写法。</p>\n</div>\n<p>💬 传统写法：全都自己干，</p>\n<div>\n<pre><code class=\"language-cpp\">/* v2(v1) */\nvector(const vector&lt;T&gt;&amp; v) {\n\t//_start = new T[v.capacity()];\n\t//_finish = _start + v.size();\n\t//_eos = _start + v.capacity();\n \n\treserve(v.capacity());    // 我们可以直接调用写好的reserve去开空间\n\t// memcpy(_start, v._start, v.size() * sizeof(T));  // 会翻车\n\tfor (const auto&amp; e : v) {\n\t\tpush_back(e);\n\t}\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"121\" src=\"..\\..\\static\\image\\0f624a59b15d464cbf6ea649e4856dd8.png\" width=\"129\"/>老老实实开空间，老老实实拷数据。</p>\n<p>因为我们已经实现好了 <span style=\"color:#e6b223;\">reserve</span>，所以我们这里可以直接调用 <span style=\"color:#e6b223;\">reserve</span> 去开空间。</p>\n<p>注意这里不能使用<span style=\"color:#e6b223;\"> memcpy</span>，这个我们前面已经强调过了。</p>\n<p></p>\n<p>💬 现代写法：找工具人帮忙干活：</p>\n<p><img alt=\"\" height=\"81\" src=\"..\\..\\static\\image\\1e59620ef0af4956918ee1db87fcc871.png\" width=\"86\"/>​ 刚来，谁是工具人？   —— 让迭代器区间当工具人：</p>\n<div>\n<pre><code class=\"language-cpp\">/* 现代写法：v2(v1) */\nvector(const vector&lt;T&gt;&amp; v)\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _eos(nullptr)\n{\n\tvector&lt;T&gt; tmp(v.begin(), v.end());\n\tswap(_start, tmp._start);\n\tswap(_finish, tmp._finish);\n\tswap(_eos, tmp._eos);\n}</code></pre>\n</div>\n<p></p>\n<p>💬 测试一下：</p>\n<pre><code class=\"language-cpp\">\tvoid test_vector4() {\n\t\tvector&lt;int&gt; v1;\n\t\tv1.push_back(1);\n\t\tv1.push_back(2);\n\t\tv1.push_back(3);\n\t\tv1.push_back(4);\n\n\t\tvector&lt;int&gt; v2(v1);\n\t\tfor (auto e : v2) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\t}</code></pre>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"122\" src=\"..\\..\\static\\image\\20e72d2d92424cd68ee6986cd6c709f6.png\" width=\"487\"/>​</p>\n<p><span style=\"color:#0d0016;\">tmp</span> 完成交换工作后，出了作用域要调用析构函数，</p>\n<p>如果我们不对<em><span style=\"color:#0d0016;\"> _start</span></em>、<span style=\"color:#0d0016;\"><em>_finish </em></span>和 <em><span style=\"color:#0d0016;\">_eos</span></em> 进行初始化，那么<span style=\"color:#0d0016;\"> tmp</span> 将会是随机值。</p>\n<p>所以我们用初始化列表给它们先初始化成 <span style=\"color:#a5a5a5;\">nullptr</span>，这样交换后<span style=\"color:#0d0016;\"> tmp </span>就都是<span style=\"color:#a5a5a5;\"> nullptr </span>了。</p>\n<p></p>\n<p><img alt=\"\" height=\"144\" src=\"..\\..\\static\\image\\06a9c97f6e864f24b05ce1270ba10af9.png\" width=\"88\"/> 根据经验，我们下面肯定还会用到 <span style=\"color:#e6b223;\">swap</span> 的，我们不如把它封装成一个 <span style=\"color:#4da8ee;\">Swap</span> 函数。</p>\n<p>💬 Swap：</p>\n<div>\n<pre><code class=\"language-cpp\">void Swap(vector&lt;T&gt;&amp; tmp) {\n\tswap(_start, tmp._start);\n\tswap(_finish, tmp._finish);\n\tswap(_eos, tmp._eos);\n}</code></pre>\n</div>\n<p>⚡ 更新拷贝构造：</p>\n<div>\n<pre><code class=\"language-cpp\">/* v2(v1) */\nvector(const vector&lt;T&gt;&amp; v)\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _eos(nullptr)\n{\n\tvector&lt;T&gt; tmp(v.begin(), v.end());\n\tSwap(tmp);\n}</code></pre>\n</div>\n<p><img alt=\"\" height=\"141\" src=\"..\\..\\static\\image\\200f6d59ed294d238ec245e80dc02210.png\" width=\"138\"/> 当然，不加模板参数的写法也是可以的：</p>\n<pre><code class=\"language-cpp\">vector(const vector&amp; v)\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _eos(nullptr)\n{\n\tvector&lt;T&gt; tmp(v.begin(), v.end());\n\tSwap(tmp);\n}</code></pre>\n<p><span style=\"color:#a5a5a5;\">（这样语法上是支持的，但是还是推荐用加模板参数的写法，因为写类型会比较清楚）</span></p>\n<p></p>\n<h3 id=\"0x01%20%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%20operator%3D\">0x01 赋值构造 operator=</h3>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"22\" src=\"..\\..\\static\\image\\15a98d30177146d08729a2fe9e63c4f1.png\" width=\"435\"/></p>\n<p>​传统写法就是把 <span style=\"color:#0d0016;\">v2</span> 赋值给 <span style=\"color:#0d0016;\">v1</span>，自己把 <span style=\"color:#0d0016;\">v1</span> 释放了，再去深拷贝出<span style=\"color:#0d0016;\"> </span><span style=\"color:#0d0016;\">v2 </span>一样大的空间……</p>\n</div>\n<p><img alt=\"\" height=\"96\" src=\"..\\..\\static\\image\\1d87152e817d40a9ba2ad4b8466a1d80.png\" width=\"96\"/> 太麻烦了，直接用现代写法，只要有了拷贝构造，赋值都可以用现代写法。</p>\n<p>并且，这里还可以利用 \"传参调用拷贝构造\" 这一特性，做到真正的 \"压榨\" 工具人。</p>\n<p>所以我们去掉<span style=\"color:#e6b223;\"> const </span>和引用传参，为的是让形参去充当临时变量<span style=\"color:#0d0016;\"> tmp</span> ——</p>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"27\" src=\"..\\..\\static\\image\\16d000e215f1488d85837afc241155ac.png\" width=\"358\"/></p>\n<p>​</p>\n</div>\n<p>💬 现代写法：<span style=\"color:#0d0016;\">v1</span> = <span style=\"color:#0d0016;\">v3</span></p>\n<div>\n<pre><code class=\"language-cpp\">/* v1 = v3 */\nvector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v) {\n\tSwap(v);   // 让形参v充当tmp工具人\n\treturn *this;\n}</code></pre>\n</div>\n<p>这里也一样，不写模板参数也是可以的：</p>\n<pre><code class=\"language-cpp\">/* v1 = v3 */\nvector&amp; operator=(vector v) {\n\tSwap(v);   // 让形参v充当tmp工具人\n\treturn *this;\n}</code></pre>\n<p></p>\n<p>想要 <span style=\"color:#0d0016;\">v1</span> 跟 <span style=\"color:#0d0016;\">v3</span> 有一样大的空间一样大的值，我们让传参的时候就顺便把这件事给办了。</p>\n<p>现在<span style=\"color:#0d0016;\"> v </span>手上就有 <span style=\"color:#0d0016;\">v3</span> 了，然后再用<span style=\"color:#e6b223;\"> Swap</span> 函数夺取<span style=\"color:#0d0016;\"> v </span>的劳动成果，最后返回 <span style=\"color:#956fe7;\">*this </span>就大功告成了。</p>\n<p>这里<span style=\"color:#0d0016;\"> v1 </span>不仅把 <span style=\"color:#0d0016;\">v</span> 从<span style=\"color:#0d0016;\"> v3 </span>得到的东西，还让<span style=\"color:#0d0016;\"> v</span> 帮忙把垃圾丢了（释放空间） ——</p>\n<p> <img alt=\"\" height=\"1123\" src=\"..\\..\\static\\image\\57a723edfe9f40ab8f94d1aa7586ca68.png\" width=\"547\"/>​ （画技烂轻喷）</p>\n<p> \"传参调用拷贝构造\" 压榨工具人的方式，是我们第二次讲了。</p>\n<p>第一次是在<span style=\"color:#0d0016;\"> string</span> 模拟实现的时候讲的，当时我们称之为 —— 更简洁的写法：</p>\n<p><img alt=\"\" height=\"276\" src=\"..\\..\\static\\image\\4a5b473a44f54875863b48591586b831.png\" width=\"607\"/>​</p>\n<p>正所谓一回生二回熟，相信到这里你应该理解，我们为什么可以这么做了。</p>\n<p>❓ <strong>现在请思考：</strong>既然有这种好事，为什么不在拷贝构造的时候用？</p>\n<p><img alt=\"\" height=\"418\" src=\"..\\..\\static\\image\\86ab7c1bd83b4fc9b741c7f841a1d6ff.png\" width=\"1152\"/>​</p>\n<p>🔍 如果你答错了，建议复习一下：</p>\n<p><a href=\"https://blog.csdn.net/weixin_50502862/article/details/123359614\" title=\"【C++要笑着学】类的默认成员函数详解 | 构造函数 | 析构函数 | 构造拷贝函数\">【C++要笑着学】类的默认成员函数详解 | 构造函数 | 析构函数 | 构造拷贝函数</a></p>\n<p><img alt=\"\" height=\"511\" src=\"..\\..\\static\\image\\e3af211fb08a4a3ca58e831ac0bbcd3c.png\" width=\"635\"/>​</p>\n<p></p>\n<p>💬 测试一下：</p>\n<div>\n<pre><code class=\"language-cpp\">void test_vector5() {\n\tvector&lt;int&gt; v1;\n\tv1.push_back(1);\n\tv1.push_back(2);\n\tv1.push_back(3);\n\tv1.push_back(4);\n\tcout &lt;&lt; \"赋值前：\";\n\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n\n\tvector&lt;int&gt; v3;\n\tv3.push_back(10);\n\tv3.push_back(20);\n\tv3.push_back(30);\n\n\tcout &lt;&lt; \"赋值后：\";\n\tv1 = v3;\n\tfor (auto e : v1) cout &lt;&lt; e &lt;&lt; \" \"; cout &lt;&lt; endl;\n}</code></pre>\n</div>\n<blockquote>\n<p>🚩 运行结果如下：</p>\n</blockquote>\n<p><img alt=\"\" height=\"137\" src=\"..\\..\\static\\image\\ada169aff2af40edaf0d9383ac17a8cd.png\" width=\"472\"/>​  <span style=\"color:#a5a5a5;\">（不崩溃了）</span></p>\n<p></p>\n<p></p>\n<hr/>\n<p style=\"text-align:right;\"><strong>📜 参考资料</strong></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">. C++reference[EB/OL]. []. http://www.cplusplus.com/reference/.</span></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p>\n<p style=\"text-align:right;\"><span style=\"color:#a5a5a5;\">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p>\n<pre><code class=\"language-cpp\">📌 [ 笔者 ]   王亦优\n📃 [ 更新 ]   2022.5.11\n❌ [ 勘误 ]   /* 暂无 */\n📜 [ 声明 ]   由于作者水平有限，本文有错误和不准确之处在所难免，\n              本人也很想知道这些错误，恳望读者批评指正！</code></pre>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-07-08 21:11:25", "summary": "爆笑教程《要笑着学》《要笑着学》火速订阅写在前面的源代码整体考虑的东西比较多，还要考虑和其他地方的结合，因此整体的设计是比较复杂的。基于这一系列原因，我们会以简单的形式去实现其核心框架接口，方便去学习"}