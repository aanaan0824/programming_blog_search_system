{"blogid": "122023220", "writerAge": "码龄9年", "writerBlogNum": "3", "writerCollect": "14", "writerComment": "0", "writerFan": "9", "writerGrade": "1级", "writerIntegral": "32", "writerName": "程序员小晨", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122023220.jpg", "writerRankTotal": "266950", "writerRankWeekly": "514915", "writerThumb": "1", "writerVisitNum": "4148", "blog_read_count": "909", "blog_time": "于 2021-12-19 13:48:56 发布", "blog_title": "PHP 常见设计模式——工厂模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>最近参加了几次面试，对于应用常见的几种设计模式问题，深有感触。为加强自身理解，同时也希望能给一些初级开发者一定的参考学习，决定开始就PHP常见的设计模式写下几篇博文，工作原因，会不定期更新，感谢您的耐心阅读！</p>\n<p>今天这篇文章主要是描述一下PHP常见设计模式之工厂模式。工厂模式其实可以划分为：<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong>等。</p>\n<p><strong>1.简单工厂模式</strong></p>\n<p><strong>简介</strong>：简单工厂模式又被称为静态工厂方法模式，属于设计模式中的类创建模式。官方解释为：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类。一般用在具体产品很少扩展的情况下，不用经常修改，且不修改代码的话是不能实现扩展的。</p>\n<p><strong>优缺点</strong>：优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责；缺点在于工厂类不够灵活，增加新的产品时需要修改工厂类的代码，一旦产品较多时，工厂类将会变得异常复杂。</p>\n<p><strong>具体代码实例</strong>：</p>\n<pre><code class=\"language-php\">&lt;?php\n\nclass A\n{\n    function __construct()\n    {\n        echo \"我是A类\";\n    }\n}\n\nclass B\n{\n    function __construct()\n    {\n        echo \"我是B类\";\n    }\n}\n\nclass Factory\n{\n    public static function create($name)\n    {\n        if ($name == 'A') {\n            return new A();\n        } elseif ($name == 'B') {\n            return new B();\n        }\n    }\n}\n\n$a = Factory::create('A');\n$b = Factory::create('B');</code></pre>\n<p><strong>2.工厂方法模式</strong></p>\n<p><strong>简介</strong>：工厂方法模式通过定义了一个抽象出来的核心工厂类，并同时定义创建产品对象的接口，而创建具体实例的工作延迟到工厂子类中去完成。这种设计方式好处是核心类只需要关注工厂类的接口定义，具体的实例交由具体的工厂子类去创建。当需要新增一个产品时，无需修改现有的代码，只需要添加一个新的产品类和对应的工厂子类即可，促使整体的扩展性更好。</p>\n<p><strong>优缺点</strong>：基于其简介我们可以了解到，工厂方法模式是在简单工厂模式的基础上进一步的抽象，保留了简单工厂模式的优点，且解决了它的缺点。在工厂方法模式中，核心类仅仅负责给出具体工厂必须实现的接口，而无需再负责具体的产品类实例化，使得系统可以在不修改整体代码的情况下方便的引进新的产品。</p>\n<p><strong>具体代码实例</strong>：</p>\n<pre><code class=\"language-php\">&lt;?php\n\ninterface Basic\n{\n    public function actionOne();\n\n    public function actionTwo();\n}\n\nclass A implements Basic\n{\n    public function actionOne()\n    {\n        echo \"我是A类—方法1\";\n    }\n\n    public function actionTwo()\n    {\n        echo \"我是A类—方法2\";\n    }\n}\n\nclass B implements Basic\n{\n    public function actionOne()\n    {\n        echo \"我是B类—方法1\";\n    }\n\n    public function actionTwo()\n    {\n        echo \"我是B类—方法2\";\n    }\n}\n\nabstract class Factory\n{\n    abstract static function createBasic();\n}\n\nclass A_Factory extends Factory\n{\n    public static function createBasic()\n    {\n        return new A();\n    }\n}\n\nclass B_Factory extends Factory\n{\n    public static function createBasic()\n    {\n        return new B();\n    }\n}\n\n$a = A_Factory::createBasic();\n$a-&gt;actionOne();\n$a-&gt;actionTwo();\n\n$b = B_Factory::createBasic();\n$b-&gt;actionOne();\n$b-&gt;actionTwo();</code></pre>\n<p><strong>3.抽象工厂模式</strong></p>\n<p><strong>简介</strong>：抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。此模式是在工厂方法模式上的进一步扩展。在工厂方法模式中，一个具体工厂负责一类具体产品的处理（一对一关系），但当我们需要一个工厂负责生成多种类型产品时，就要抽象整个工厂类了。</p>\n<p><strong>举一个具体生活实例</strong>：</p>\n<ul><li>产品结构：假设一个抽象类是手机，其子类有小米手机、华为手机、荣耀手机，那么抽象的手机和具体品牌的手机之间则构成了一个产品结构，抽象手机是父类，具体品牌手机是其子类。</li><li>产品组：产品组是指由同一工厂生产，位于不同产品结构中的一组产品。如华为厂家生产的华为手机、华为手环，华为手机属于手机产品结构中，华为手环则属于手环产品结构中中。</li></ul>\n<p><strong>具体代码实例</strong>：</p>\n<pre><code>&lt;?php\n\ninterface Phone\n{\n    public function open();\n\n    public function operate();\n}\n\nclass HuaweiPhone implements Phone\n{\n    public function open()\n    {\n        echo \"打开华为手机\";\n    }\n\n    public function operate()\n    {\n        echo \"操作华为手机\";\n    }\n}\n\ninterface Bracelet\n{\n    public function look();\n\n    public function click();\n}\n\nclass XiaomiBracelet implements Bracelet\n{\n    public function look()\n    {\n        echo \"查看小米手环\";\n    }\n\n    public function click()\n    {\n        echo \"点击小米手环\";\n    }\n}\n\nabstract class Factory\n{\n    abstract public static function createPhone();\n\n    abstract public static function createBracelet();\n}\n\nclass ProductFactory extends Factory{\n    public static function createPhone()\n    {\n        return new HuaweiPhone();\n    }\n\n    public static function createBracelet()\n    {\n        return new XiaomiBracelet();\n    }\n}\n\n$newPhone = ProductFactory::createPhone();\n$newPhone-&gt;open();\n$newPhone-&gt;operate();\n\n$newBracelet = ProductFactory::createBracelet();\n$newBracelet-&gt;look();\n$newBracelet-&gt;click();</code></pre>\n<p> 以上就是我对工厂模式的一些学习见解，希望对部分同行人在理解上有一定的帮助，感谢你们的关注！</p>\n</div>\n</div>", "first_tag": "PHP", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 1, "time": "2021-12-19 13:48:56", "summary": "最近参加了几次面试，对于应用常见的几种设计模式问题，深有感触。为加强自身理解，同时也希望能给一些初级开发者一定的参考学习，决定开始就常见的设计模式写下几篇博文，工作原因，会不定期更新，感谢您的耐心阅读"}