{"blogid": "125651833", "writerAge": "码龄3年", "writerBlogNum": "6", "writerCollect": "21", "writerComment": "11", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "75", "writerName": "PeakXYH", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125651833.jpg", "writerRankTotal": "118843", "writerRankWeekly": "596353", "writerThumb": "10", "writerVisitNum": "5006", "blog_read_count": "2148", "blog_time": "已于 2022-07-15 15:28:08 修改", "blog_title": "MYSQL数据库事务的隔离级别（详解）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、概述</h2>\n<blockquote>\n<p>数据库事务的隔离级别分为四种：（后面为解决的问题，结合下文案例深入理解）</p>\n<p>1.读未提交（Read Uncommited）事务1修改的数据被事务2给回滚了</p>\n<p>2.读已提交（Read Commited）事务1读到其他事务修改但是没有提交的信息</p>\n<p>3.可重复度（Repeatable Read）在事务1进行多次的查询操作的时候，查询的结果不一致的</p>\n<p>4.可串行化（Serializable）在同一事务中查询的时候发现多了很多条记录</p>\n</blockquote>\n<h2>二、隔离级别出现的原因</h2>\n<blockquote>\n<p>为了解决事务在<span style=\"background-color:#fefcd8;\">并发执行</span>的时候不会相互影响，所以就引入了事务的隔离级别（也就是在多个事务同时对一个数据进行读取、更新等操作的时候，如何保证数据的正确性和一致性）</p>\n</blockquote>\n<h2>三、四种事务隔离级别各自解决的问题</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px;\"><tbody><tr><td></td><td style=\"text-align:center;width:107px;\">脏写</td><td style=\"text-align:center;width:107px;\">脏读</td><td style=\"text-align:center;width:115px;\">不可重复读</td><td style=\"text-align:center;width:120px;\">幻读</td></tr><tr><td>读未提交</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:107px;\">×</td><td style=\"text-align:center;width:115px;\">×</td><td style=\"text-align:center;width:120px;\">×</td></tr><tr><td>读已提交</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:115px;\">×</td><td style=\"text-align:center;width:120px;\">×</td></tr><tr><td>可重复度</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:115px;\">√</td><td style=\"text-align:center;width:120px;\">×</td></tr><tr><td>可串行化</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:107px;\">√</td><td style=\"text-align:center;width:115px;\">√</td><td style=\"text-align:center;width:120px;\">√</td></tr></tbody></table>\n<h2>四、不同的隔离级别解决的问题</h2>\n<ul><li>脏写（事务1修改的数据被事务2给回滚了）</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:680px;\"><tbody><tr><td></td><td style=\"text-align:center;\">事务1</td><td style=\"text-align:center;\">事务2</td></tr><tr><td>T1</td><td style=\"text-align:center;\">begin</td><td style=\"text-align:center;\"></td></tr><tr><td>T2</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">begin</td></tr><tr><td>T3</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">update xxx set password= 200 where id = 1</td></tr><tr><td>T4</td><td style=\"text-align:center;\">update xxx set password= 1000 where id = 1</td><td style=\"text-align:center;\"></td></tr><tr><td>T5</td><td style=\"text-align:center;\">commit</td><td style=\"text-align:center;\"></td></tr><tr><td>T6</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">Rollback</td></tr></tbody></table>\n<blockquote>\n<p>        这里可以看到事务1在修改完id为1的password并进行事务的提交之后，事务2在T6时刻进行了事务的回滚，这就导致了<span style=\"background-color:#fbd4d0;\">事务1对数据的修改丢失</span>了，这是一个非常严重的错误，即自己修改的数据被被人给回滚了，<span style=\"background-color:#fefcd8;\">在任何隔离级别的情况下都是解决了脏写问题</span>。</p>\n</blockquote>\n<ul><li>脏读（事务1读到其他事务修改但是没有提交的信息、临时信息）</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:680px;\"><tbody><tr><td></td><td style=\"text-align:center;\">事务1</td><td style=\"text-align:center;\">事务2</td></tr><tr><td>T1</td><td style=\"text-align:center;\">begin</td><td style=\"text-align:center;\"></td></tr><tr><td>T2</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">begin</td></tr><tr><td>T3</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">update xxx set password= 99 where id = 1</td></tr><tr><td>T4</td><td style=\"text-align:center;\">select password from xxx where id = 1</td><td style=\"text-align:center;\"></td></tr><tr><td>T5</td><td style=\"text-align:center;\">commit</td><td style=\"text-align:center;\"></td></tr><tr><td>T6</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">RollBack</td></tr></tbody></table>\n<blockquote>\n<p>        这里事务1在T4读取到了事务2针对id=1的用户的password修改，但是实际上事务2在最后进行了事务的回滚，这就导致了实际上事务1读到的是一个不存在的数据，<span style=\"background-color:#fbd4d0;\">也就是事务1读到了其他事务修改但是没有提提交的记录信息</span>。<span style=\"background-color:#fefcd8;\">在读已提交的隔离级别下就解决了脏读问题</span>。</p>\n</blockquote>\n<ul><li>不可重复度（在同一事务进行多次的查询操作的时候，查询的结果是不一致的）</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:680px;\"><tbody><tr><td></td><td style=\"text-align:center;\">事务1</td><td style=\"text-align:center;\">事务2</td></tr><tr><td>T1</td><td style=\"text-align:center;\">begin</td><td style=\"text-align:center;\"></td></tr><tr><td>T2</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">begin</td></tr><tr><td>T3</td><td style=\"text-align:center;\">select password from xxx where id = 1</td><td style=\"text-align:center;\"></td></tr><tr><td>T4</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">update xxx set password = 99 where id = 1</td></tr><tr><td>T5</td><td style=\"text-align:center;\">select password from xxx where id = 1</td><td style=\"text-align:center;\"></td></tr><tr><td>T6</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">update xxx set password= 88 where id = 1</td></tr><tr><td>T7</td><td style=\"text-align:center;\">select password from xxx where id = 1</td><td style=\"text-align:center;\"></td></tr><tr><td>T8</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">update xxx set password= 88 where id = 1</td></tr><tr><td>T9</td><td style=\"text-align:center;\">commit</td><td style=\"text-align:center;\"></td></tr><tr><td>T10</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">commit</td></tr></tbody></table>\n<blockquote>\n<p>        在T3、T5、T7时刻事务1对id=1的账号进行password，发现该数据一致是变化的，这就是不可重复度的问题，<span style=\"background-color:#fbd4d0;\">在同一事务中</span>每次进行查询的时候数据都是在变化的，<span style=\"background-color:#fefcd8;\">在可重复度的隔离级别下解决了不可重复的的问题</span>。</p>\n</blockquote>\n<ul><li>幻读（在同一事务中查询的时候发现多了很多条记录，称为幻影记录） </li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:680px;\"><tbody><tr><td></td><td style=\"text-align:center;\">事务1</td><td style=\"text-align:center;\">事务2</td></tr><tr><td>T1</td><td style=\"text-align:center;\">begin</td><td style=\"text-align:center;\"></td></tr><tr><td>T2</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">begin</td></tr><tr><td>T3</td><td style=\"text-align:center;\">select * from xxx where id &gt; 100</td><td style=\"text-align:center;\"></td></tr><tr><td>T4</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">insert into xxx(id,password) values (199,11)</td></tr><tr><td>T5</td><td style=\"text-align:center;\">select * from xxx where id &gt; 100</td><td style=\"text-align:center;\"></td></tr><tr><td>T6</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">insert into xxx(id,password) values (200,11)</td></tr><tr><td>T7</td><td style=\"text-align:center;\">select * from xxx where id &gt; 100</td><td style=\"text-align:center;\"></td></tr><tr><td>T8</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">insert into xxx(id,password) values (201,11)</td></tr><tr><td>T9</td><td style=\"text-align:center;\">commit</td><td style=\"text-align:center;\"></td></tr><tr><td>T10</td><td style=\"text-align:center;\"></td><td style=\"text-align:center;\">commit</td></tr></tbody></table>\n<blockquote>\n<p>        在T3、T5、T7时刻事务1对id大于100的信息进行查询的时候，<span style=\"background-color:#fbd4d0;\">发现在同一事务中每次查询的时候都会有新的数据的出现，这就是幻读问题</span>，<span style=\"background-color:#fefcd8;\">在可串行化（序列化）的隔离级别下解决了幻读的问题</span></p>\n</blockquote>\n<h2> 五、混淆点&amp;知识点</h2>\n<ul><li>多次查询的的时候发现数据变少了，是幻读还是不可重复度</li></ul>\n<blockquote>\n<p>答：不可重复度。幻读一定是数据增多了（可以从字面意思上理解，幻读即出现幻影记录，那么就是两次读发现多了数据），如果是数据减少了，那么就是不可重复度</p>\n</blockquote>\n<ul><li> 脏写和脏读的回滚问题</li></ul>\n<blockquote>\n<p>两者都是由于事务1在进行操作的时候其他事务回滚导致的问题，脏写是其他事务回滚导致自己写入的数据无效了，脏读则表示的是其他事务回滚导致读到的是无效的数据，由于脏写是所有事务隔离级别都解决的，所以做了解即可（一般通过加锁就可以解决）</p>\n</blockquote>\n<ul><li>四种隔离级别的问题严重性</li></ul>\n<blockquote>\n<p>问题严重性：脏写&gt;脏读&gt;不可重复读&gt;幻读</p>\n</blockquote>\n<ul><li>在MYSQL中的事务隔离级别</li></ul>\n<blockquote>\n<p>在MySQL中innodb存储引擎下的隔离级别是可重复读，但是得益于innodb的MVCC版本控制，MYSQL在可重复度的隔离级别下同时解决了幻读的问题</p>\n</blockquote>\n<h2>六、四种隔离级别的比较总结</h2>\n<ul><li>并发性</li></ul>\n<blockquote>\n<p>从字面意思上即可理解：</p>\n<p>1.可串行化并发能力最低，所有的事务等待执行，解决所有问题，安全性高，但是效率低下</p>\n<p>2.之后并发能力一次递增：串行化&lt;可重复度&lt;读已提交&lt;读未提交</p>\n<p>3.在实际的开发中根据业务的具体需求，权衡并发性和数据安全性选择对应的隔离级别</p>\n</blockquote>\n</div>\n</div>", "first_tag": "SQL", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 1, "php": 0, "time": "2022-07-15 15:28:08", "summary": "一、概述数据库事务的隔离级别分为四种：后面为解决的问题，结合下文案例深入理解读未提交事务修改的数据被事务给回滚了读已提交事务读到其他事务修改但是没有提交的信息可重复度在事务进行多次的查询操作的时候，查"}