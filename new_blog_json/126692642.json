{"blogid": "126692642", "writerAge": "码龄4年", "writerBlogNum": "112", "writerCollect": "146", "writerComment": "13", "writerFan": "130", "writerGrade": "4级", "writerIntegral": "1304", "writerName": "肖爱Kun", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126692642.jpg", "writerRankTotal": "14815", "writerRankWeekly": "2484", "writerThumb": "173", "writerVisitNum": "50404", "blog_read_count": "142", "blog_time": "于 2022-09-05 22:39:26 发布", "blog_title": "OpenCV 图像处理学习二十二，基于距离变换和分水岭的图像分割", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3> 一.图像分割</h3>\n<p><strong>图像分割是根据灰度、颜色、纹理和形状等特征，把图像分成若干个特定的、具有独特性质的区域，这些特征在同一区域内呈现出相似性，而在不同区域间呈现出明显的差异性，并提出感兴趣目标的技术和过程。 它是由图像处理到图像分析的关键步骤。从数学角度来看，图像分割是将数字图像划分成互不相交的区域的过程。图像分割的过程也是一个标记过程，即把属于同一区域的像索赋予相同的编号。</strong><br/>  </p>\n<p><strong>其目的是将图像中像素根据一定的规则分为若干(N)个聚(cluster)集合，每个集合包含一类像素。将对象在背景提取出来。</strong></p>\n<h3><br/> 二.基于距离变换和分水岭的图像分割</h3>\n<p><strong>分水岭法（Meyer）是一种基于拓扑理论的数学形态学的分割方法，其基本思想是把图像看作是测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。该算法的实现可以模拟成洪水淹没的过程，图像的最低点首先被淹没，然后水逐渐淹没整个山谷。当水位到达一定高度的时候将会溢出，这时在水溢出的地方修建堤坝，重复这个过程直到整个图像上的点全部被淹没，这时所建立的一系列堤坝就成为分开各个盆地的分水岭。分水岭算法对微弱的边缘有着良好的响应，但图像中的噪声会使分水岭算法产生过分割的现象。</strong><br/><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></p>\n<p><strong>距离变换API函数接口</strong></p>\n<p><strong>距离变换用于计算图像中每一个非零点像素与其周围最近的零点像素之间的距离，返回的值保存了每一个非零点与最近零点的距离信息；在图像上的体现为图像上越亮的点，代表了离零点的距离越远。</strong></p>\n<pre><code>void distanceTransform( \nInputArray src,  \nOutputArray dst,\nOutputArray labels,\nint distanceType,\nint maskSize,\nint labelType=DIST_LABEL_CCOMP\n);\n</code></pre>\n<p><strong>参数说明</strong></p>\n<p><strong>（1）src是单通道的8bit的二值图像（只有0或1）<br/> （2）dst表示的是计算距离的输出图像，可以使单通道32bit浮点数据<br/> （3）distanceType表示的是选取距离的类型，可以设置为                                          CV_DIST_L1,CV_DIST_L2,CV_DIST_C等，具体如下：</strong></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:650px;\"><tbody><tr><td style=\"width:236px;\">DIST_USER</td><td style=\"width:413px;\">User defined distance</td></tr><tr><td style=\"width:236px;\">DIST_L1=1</td><td style=\"width:413px;\">distance = |x1-x2| + |y1-y2</td></tr><tr><td style=\"width:236px;\">DIST_L2</td><td style=\"width:413px;\">the simple euclidean distance</td></tr><tr><td style=\"width:236px;\">DIST_C</td><td style=\"width:413px;\">distance = max(|x1-x2|,|y1-y2|)</td></tr><tr><td style=\"width:236px;\">DIST_L12</td><td style=\"width:413px;\">L1-L2 metric: distance =2(sqrt(1+x*x/2) - 1))</td></tr><tr><td style=\"width:236px;\">DIST_FAIR</td><td style=\"width:413px;\">distance = c^2(|x|/c-log(1+|x|/c)),c = 1.3998</td></tr><tr><td style=\"width:236px;\">DIST_WELSCH</td><td style=\"width:413px;\">distance = c2/2(1-exp(-(x/c)2)), c= 2.9846</td></tr><tr><td style=\"width:236px;\">DIST_HUBER</td><td style=\"width:413px;\">distance = |x|&lt;c ? x^2/2 :c(|x|-c/2), c=1.345</td></tr></tbody></table>\n<p><strong>（4）maskSize表示的是距离变换的掩膜模板，可以设置为<code>3</code>，<code>5</code>或<code>CV_DIST_MASK_PRECISE</code>，对 <code>CV_DIST_L1</code> 或<code>CV_DIST_C</code> 的情况，参数值被强制设定为 3, 因为<code>3×3 mask</code> 给出<code>5×5 mask</code> 一样的结果，而且速度还更快。</strong></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"width:248px;\">DIST_MASK_3</td><td style=\"width:251px;\">mask=3</td></tr><tr><td style=\"width:248px;\">DIST_MASK_5</td><td style=\"width:251px;\">mask=5</td></tr><tr><td style=\"width:248px;\">DIST_MASK-PRECISE</td><td style=\"width:251px;\"></td></tr></tbody></table>\n<p><strong>（5）labels表示可选输出2维数组；<br/> （6）labelType表示的是输出二维数组的类型,8位或者32位浮点数，图像是单一通道，并且大小与输入图像一致</strong></p>\n<p><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></p>\n<h2><strong>watershed 分水岭函数API接口</strong></h2>\n<pre><code>void watershed( InputArray image, InputOutputArray markers );</code></pre>\n<p><strong>参数说明</strong></p>\n<p><strong>（1）参数 image，必须是一个8bit3通道彩色图像矩阵序列。<br/> （2） 输入或输出32位单通道的标记，和图像一样大小。（输入高峰轮廓标记）；在执行分水岭函数<code>watershed</code>之前，必须对第二个参数<code>markers</code>进行处理，它应该包含不同区域的轮廓，每个轮廓有一个自己唯一的编号，轮廓的定位可以通过<code>Opencv</code>中<code>findContours</code>方法实现，这个是执行分水岭之前的要求。</strong></p>\n<p><strong>算法会根据<code>markers</code>传入的轮廓作为种子（也就是所谓的注水点），对图像上其他的像素点根据分水岭算法规则进行判断，并对每个像素点的区域归属进行划定，直到处理完图像上所有像素点。而区域与区域之间的分界处的值被置为“-1”，以做区分。</strong></p>\n<p><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></p>\n<h3>代码实现</h3>\n<p>1、将白色背景改为黑色，为后面的变换做准备；<br/> 2、使用filter2D与Laplace算子实现图像对比度的提高；sharpen锐化<br/> 3、通过threshold()转换为二值图像；<br/> 4、距离变换；<br/> 5、对距离变换的结果归一化到0-1之间；<br/> 6、使用阈值，再次二值化，得到标记；<br/> 7、腐蚀（erode）得到每个Peak；（peak : 山峰，山顶 ）<br/> 8、发现轮廓<strong><code>findContours</code></strong>；<br/> 9、绘制轮廓；<br/> 10、分水岭变换；<br/> 11、对每个分割区域着色输出结果；</p>\n<p><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></p>\n<pre><code>#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char** argv) {\n\tchar input_win[] = \"input image\";\n\tchar watershed_win[] = \"watershed segmentation demo\";\n\tMat src = imread(\"D:/vcprojects/images/cards.png\");\n\t// Mat src = imread(\"D:/kuaidi.jpg\");\n\tif (src.empty()) {\n\t\tprintf(\"could not load image...\\n\");\n\t\treturn -1;\n\t}\n\tnamedWindow(input_win, CV_WINDOW_AUTOSIZE);\n\timshow(input_win, src);\n\t// 1. change background\n\tfor (int row = 0; row &lt; src.rows; row++) {\n\t\tfor (int col = 0; col &lt; src.cols; col++) {\n\t\t\tif (src.at&lt;Vec3b&gt;(row, col) == Vec3b(255, 255, 255)) {\n\t\t\t\tsrc.at&lt;Vec3b&gt;(row, col)[0] = 0;\n\t\t\t\tsrc.at&lt;Vec3b&gt;(row, col)[1] = 0;\n\t\t\t\tsrc.at&lt;Vec3b&gt;(row, col)[2] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tnamedWindow(\"black background\", CV_WINDOW_AUTOSIZE);\n\timshow(\"black background\", src);\n\n\t// sharpen\n\tMat kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; 1, 1, 1, 1, -8, 1, 1, 1, 1);\n\tMat imgLaplance;\n\tMat sharpenImg = src;\n\tfilter2D(src, imgLaplance, CV_32F, kernel, Point(-1, -1), 0, BORDER_DEFAULT);\n\tsrc.convertTo(sharpenImg, CV_32F);\n\tMat resultImg = sharpenImg - imgLaplance;\n\n\tresultImg.convertTo(resultImg, CV_8UC3);\n\timgLaplance.convertTo(imgLaplance, CV_8UC3);\n\timshow(\"sharpen image\", resultImg);\n\t// src = resultImg; // copy back\n\n\t// convert to binary\n\tMat binaryImg;\n\tcvtColor(src, resultImg, CV_BGR2GRAY);\n\tthreshold(resultImg, binaryImg, 40, 255, THRESH_BINARY | THRESH_OTSU);\n\timshow(\"binary image\", binaryImg);\n\n\tMat distImg;\n\tdistanceTransform(binaryImg, distImg, DIST_L1, 3, 5);\n\tnormalize(distImg, distImg, 0, 1, NORM_MINMAX);\n\timshow(\"distance result\", distImg);\n\t\n\t// binary again\n\tthreshold(distImg, distImg, .4, 1, THRESH_BINARY);\n\tMat k1 = Mat::ones(13, 13, CV_8UC1);\n\terode(distImg, distImg, k1, Point(-1, -1));\n\timshow(\"distance binary image\", distImg);\n\n\t// markers \n\tMat dist_8u;\n\tdistImg.convertTo(dist_8u, CV_8U);\n\tvector&lt;vector&lt;Point&gt;&gt; contours;\n\tfindContours(dist_8u, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0));\n\n\t// create makers\n\tMat markers = Mat::zeros(src.size(), CV_32SC1);\n\tfor (size_t i = 0; i &lt; contours.size(); i++) {\n\t\tdrawContours(markers, contours, static_cast&lt;int&gt;(i), Scalar::all(static_cast&lt;int&gt;(i) + 1), -1);\n\t}\n\tcircle(markers, Point(5, 5), 3, Scalar(255, 255, 255), -1);\n\timshow(\"my markers\", markers*1000);\n\n\t// perform watershed\n\twatershed(src, markers);\n\tMat mark = Mat::zeros(markers.size(), CV_8UC1);\n\tmarkers.convertTo(mark, CV_8UC1);\n\tbitwise_not(mark, mark, Mat());\n\timshow(\"watershed image\", mark);\n\n\t// generate random color\n\tvector&lt;Vec3b&gt; colors;\n\tfor (size_t i = 0; i &lt; contours.size(); i++) {\n\t\tint r = theRNG().uniform(0, 255);\n\t\tint g = theRNG().uniform(0, 255);\n\t\tint b = theRNG().uniform(0, 255);\n\t\tcolors.push_back(Vec3b((uchar)b, (uchar)g, (uchar)r));\n\t}\n\n\t// fill with color and display final result\n\tMat dst = Mat::zeros(markers.size(), CV_8UC3);\n\tfor (int row = 0; row &lt; markers.rows; row++) {\n\t\tfor (int col = 0; col &lt; markers.cols; col++) {\n\t\t\tint index = markers.at&lt;int&gt;(row, col);\n\t\t\tif (index &gt; 0 &amp;&amp; index &lt;= static_cast&lt;int&gt;(contours.size())) {\n\t\t\t\tdst.at&lt;Vec3b&gt;(row, col) = colors[index - 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdst.at&lt;Vec3b&gt;(row, col) = Vec3b(0, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\timshow(\"Final Result\", dst);\n\n\twaitKey(0);\n\treturn 0;\n}</code></pre>\n<p><strong>---------------------------------------------------------------------------------------------------------------------------------</strong></p>\n<p><strong>图像处理效果</strong></p>\n<p>输入原图像和锐化图像 </p>\n<p><img alt=\"\" height=\"714\" src=\"..\\..\\static\\image\\48752ba371554c49a7828c525418adfd.png\" width=\"1200\"/></p>\n<p>原图和黑背景图（背景应为黑色） </p>\n<p><img alt=\"\" height=\"714\" src=\"..\\..\\static\\image\\2a912de697ad4d05b308f72929926370.png\" width=\"1200\"/></p>\n<p>threshold转化的二值化图片和距离变换结果图</p>\n<p><img alt=\"\" height=\"713\" src=\"..\\..\\static\\image\\fbae5e5e9cf748239d271eedee4807c6.png\" width=\"1200\"/></p>\n<p> 距离变换结果图和二值化图像</p>\n<p><img alt=\"\" height=\"693\" src=\"..\\..\\static\\image\\c66c37b528214ee49fa560dce9738cdd.png\" width=\"1200\"/></p>\n<p> </p>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-05 22:39:26", "summary": "一图像分割图像分割是根据灰度、颜色、纹理和形状等特征，把图像分成若干个特定的、具有独特性质的区域，这些特征在同一区域内呈现出相似性，而在不同区域间呈现出明显的差异性，并提出感兴趣目标的技术和过程。它是"}