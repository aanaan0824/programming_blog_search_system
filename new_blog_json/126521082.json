{"blogid": "126521082", "writerAge": "码龄1年", "writerBlogNum": "89", "writerCollect": "1106", "writerComment": "1780", "writerFan": "4058", "writerGrade": "5级", "writerIntegral": "4238", "writerName": "小白又菜", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126521082.jpg", "writerRankTotal": "4022", "writerRankWeekly": "310", "writerThumb": "1868", "writerVisitNum": "66783", "blog_read_count": "299", "blog_time": "于 2022-08-25 15:59:30 发布", "blog_title": "[ C++ ] string类常见接口及其模拟实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>上一篇博文内容：string类的构造，拷贝，赋值拷贝，及其模拟实现<a href=\"https://blog.csdn.net/qq_58325487/article/details/126089927?spm=1001.2014.3001.5501\" title=\"[ C++ ] string类之构造，拷贝，赋值 及其模拟实现\">[ C++ ] string类之构造，拷贝，赋值 及其模拟实现</a></p>\n<p></p>\n<p>本篇内容：string类的常见接口及其模拟实现，我将会从<span style=\"color:#fe2c24;\"><strong>遍历</strong></span>，<strong><span style=\"color:#fe2c24;\">增</span></strong>，<span style=\"color:#fe2c24;\"><strong>删</strong></span>，<span style=\"color:#fe2c24;\"><strong>查</strong></span>，<span style=\"color:#fe2c24;\"><strong>改</strong></span>5个方面对常见，常用的接口进行模拟实现string类。</p>\n</blockquote>\n<p>该思维导图是本篇博文主要内容</p>\n<p><img alt=\"\" height=\"392\" src=\"..\\..\\static\\image\\40854e4f31b24c6d9fb69830bd15cf34.png\" width=\"1027\"/></p>\n<p> </p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81%E9%81%8D%E5%8E%86\">1、遍历</a></p>\n<p id=\"1.1%20%E4%B8%8B%E6%A0%87%2Boperator%20%5B%20%5D-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%20%E4%B8%8B%E6%A0%87%2Boperator%20%5B%20%5D\">1.1 下标+operator [ ]</a></p>\n<p id=\"1.2%C2%A0c_str-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%C2%A0c_str\">1.2 c_str</a></p>\n<p id=\"1.3%C2%A0%E8%BF%AD%E4%BB%A3%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%C2%A0%E8%BF%AD%E4%BB%A3%E5%99%A8\">1.3 迭代器</a></p>\n<p id=\"1.4%20%E8%8C%83%E5%9B%B4for-toc\" style=\"margin-left:40px;\"><a href=\"#1.4%20%E8%8C%83%E5%9B%B4for\">1.4 范围for</a></p>\n<p id=\"2%E3%80%81%E5%A2%9E-toc\" style=\"margin-left:0px;\"><a href=\"#2%E3%80%81%E5%A2%9E\">2、增</a></p>\n<p id=\"2.1.push_back-toc\" style=\"margin-left:40px;\"><a href=\"#2.1.push_back\">2.1.push_back</a></p>\n<p id=\"2.2.%20%E9%87%8D%E8%BD%BD%20%2B%3D%20%EF%BC%88char%20ch%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#2.2.%20%E9%87%8D%E8%BD%BD%20%2B%3D%20%EF%BC%88char%20ch%EF%BC%89\">2.2. 重载 += （char ch）</a></p>\n<p id=\"%C2%A02.3.%20append-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.3.%20append\"> 2.3. append</a></p>\n<p id=\"2.4.%E9%87%8D%E8%BD%BD%20%2B%3D%20%EF%BC%88char*%C2%A0%20str%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#2.4.%E9%87%8D%E8%BD%BD%20%2B%3D%20%EF%BC%88char*%C2%A0%20str%EF%BC%89\">2.4.重载 += （char*  str）</a></p>\n<p id=\"2.5.%20insert%20(%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5)-toc\" style=\"margin-left:40px;\"><a href=\"#2.5.%20insert%20%28%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%29\">2.5. insert (任意位置插入)</a></p>\n<p id=\"2.5.1%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#2.5.1%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6\">2.5.1 任意位置插入一个字符</a></p>\n<p id=\"2.5.2%C2%A0%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:80px;\"><a href=\"#2.5.2%C2%A0%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2\">2.5.2 任意位置插入一个字符串</a></p>\n<p id=\"3.%E5%88%A0-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E5%88%A0\">3.删</a></p>\n<p id=\"3.1%20earse-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20earse\">3.1 earse</a></p>\n<p id=\"4.%E6%9F%A5-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E6%9F%A5\">4.查</a></p>\n<p id=\"4.1%20%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%20%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6\">4.1 查找一个字符</a></p>\n<p id=\"4.2%C2%A0%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%C2%A0%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2\">4.2 查找一个字符串</a></p>\n<p id=\"4.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:40px;\"><a href=\"#4.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\">4.3 字符串比较</a></p>\n<p id=\"5.%E6%94%B9-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E6%94%B9\">5.改</a></p>\n<p id=\"5.1%20reserve-toc\" style=\"margin-left:40px;\"><a href=\"#5.1%20reserve\">5.1 reserve</a></p>\n<p id=\"5.2%20resize%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#5.2%20resize%C2%A0\">5.2 resize </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%E3%80%81%E9%81%8D%E5%8E%86\">1、遍历</h1>\n<h2 id=\"1.1%20%E4%B8%8B%E6%A0%87%2Boperator%20%5B%20%5D\">1.1 下标+operator [ ]</h2>\n<p>这种方法是最好理解的，我们使用下标将字符串的内容逐字符输出。</p>\n<pre><code class=\"language-cpp\">char&amp; operator[](size_t pos)\n{\n\tassert(pos &lt; strlen(_str));\n\treturn _str[pos];\n}\n\nconst char&amp; operator[](size_t pos) const \n{\n\tassert(pos &lt; strlen(_str));\n\treturn _str[pos];\n}\n\nint main()\n{\n\tstring s1(\"hello world\");\n\tfor (int i = 0; i &lt; s1.size(); ++i)\n\t{\n\n\t\tcout &lt;&lt; s1[i];\n\t}\n\treturn 0;\n}</code></pre>\n<p> <img alt=\"\" height=\"207\" src=\"..\\..\\static\\image\\df4a464b11724e27895bbe523fa0b955.png\" width=\"632\"/></p>\n<p> </p>\n<h2 id=\"1.2%C2%A0c_str\">1.2 c_str</h2>\n<p><img alt=\"\" height=\"444\" src=\"..\\..\\static\\image\\77059403294741ccb01d4e65ba2b8950.png\" width=\"1067\"/></p>\n<p>我们发现c_str返回的就是该字符串以及末尾的'\\0'，我们可以使用c_str()来进行字符串的打印，遇到'\\0'就停止。</p>\n<p>实现代码：</p>\n<pre><code class=\"language-cpp\">\t\tconst char* c_str() const\n\t\t{\n\t\t\treturn _str;\n\t\t}</code></pre>\n<p> <img alt=\"\" height=\"158\" src=\"..\\..\\static\\image\\592df589e251441d85e39845d83bc587.png\" width=\"449\"/></p>\n<h2 id=\"1.3%C2%A0%E8%BF%AD%E4%BB%A3%E5%99%A8\">1.3 迭代器</h2>\n<p>迭代器：字符串的迭代器底层是一个char* 的原生指针，因此我们使用string的迭代器时就像指针一样使用即可，但是其他的容器底层实现并不一定都是原生指针。</p>\n<pre><code class=\"language-cpp\">\ttypedef char* iterator;\n\ttypedef const char* const_iterator;\n\titerator begin()\n\t{\n\t\treturn _str;\n\t}\n\n\titerator begin() const\n\t{\n\t\treturn _str;\n\t}\n\titerator end()\n\t{\n\t\treturn _str + _size;\n\t}\n\n\titerator end() const\n\t{\n\t\treturn _str + _size;\n\t}</code></pre>\n<p>我们使用迭代器来遍历一下字符串：</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tstring::iterator it = s1.begin();\n\twhile (it != s1.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\n\t}\n\treturn 0;\n}</code></pre>\n<p> <img alt=\"\" height=\"351\" src=\"..\\..\\static\\image\\88992b90931843bd979c5abbaab82d60.png\" width=\"620\"/></p>\n<p> </p>\n<h2 id=\"1.4%20%E8%8C%83%E5%9B%B4for\">1.4 范围for</h2>\n<p>范围for的使用</p>\n<pre><code class=\"language-cpp\">\tfor (auto e : s1)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}</code></pre>\n<p> <img alt=\"\" height=\"409\" src=\"..\\..\\static\\image\\5da99a25b83a47d3b915e1e49ff44c43.png\" width=\"812\"/></p>\n<p></p>\n<p>范围for的底层原理：范围for的底层原理其实就是迭代器。我们如何来验证呢，我们可以将自己实现的迭代器屏蔽起来，再使用范围for进行遍历发现就会出现报错。  </p>\n<p><img alt=\"\" height=\"488\" src=\"..\\..\\static\\image\\579d47dd00614565875ddfd7072947ae.png\" width=\"782\"/></p>\n<p></p>\n<h1 id=\"2%E3%80%81%E5%A2%9E\">2、增</h1>\n<h2 id=\"2.1.push_back\">2.1.push_back</h2>\n<p><img alt=\"\" height=\"275\" src=\"..\\..\\static\\image\\23e70694248f4c3c9f501f560df75a9b.png\" width=\"1061\"/></p>\n<p>通过查询文档，我们知道了push_back的作用是将一个字符添加到目标字符串后。</p>\n<p>方法：</p>\n<p>1、首先我们肯定要判断是否需要扩容。如果<em><span style=\"color:#fe2c24;\">_size == _capacity</span> </em>，说明满了，需要扩容。</p>\n<p>扩容的方法：开辟一个2倍的新空间，将字符串拷贝到新空间，现有的空间释放掉即可。</p>\n<p>2、扩容完毕后我们在下标为_size的位置加入新增字符。</p>\n<p>3、最后我们将_size++，并处理'\\0'即可。</p>\n<p>实现代码：</p>\n<pre><code class=\"language-cpp\">\t\tvoid push_back(char ch)\n\t\t{\n\t\t\tif (_size == _capacity)\n\t\t\t{\n\t\t\t\tchar* tmp = new char[_capacity * 2 + 1];\n\t\t\t\tstrcpy(tmp, _str);\n\t\t\t\tdelete[] _str;\n\t\t\t\t_str = tmp;\n\t\t\t\t_capacity *= 2;\n\n\t\t\t\t//reserve(_capacity == 0?4:_capacity*2);\n\t\t\t}\n\n\t\t\t_str[_size] = ch;\n\t\t\t++_size;\n\t\t\t_str[_size] = '\\0';\n\n\t\t\t//insert(_size, ch);\n\n\t\t}</code></pre>\n<h2 id=\"2.2.%20%E9%87%8D%E8%BD%BD%20%2B%3D%20%EF%BC%88char%20ch%EF%BC%89\">2.2. 重载 += （char ch）</h2>\n<p>我们在日常写代码时很少会使用push_back，我们经常会使用 <span style=\"color:#fe2c24;\"><strong>+=</strong></span> ，因此我们也有必要实现一下 +=，+= 的实现可以复用 push_back。</p>\n<p>代码实现：</p>\n<pre><code class=\"language-cpp\">\t\tstring&amp; operator+=( char ch)\n\t\t{\n\t\t\tpush_back(ch);\n\t\t\treturn *this;\n\t\t}</code></pre>\n<h2 id=\"%C2%A02.3.%20append\"> 2.3. append</h2>\n<p><img alt=\"\" height=\"413\" src=\"..\\..\\static\\image\\2a862fdd964e40788341ec684dc07939.png\" width=\"1082\"/></p>\n<p>前两个接口针对新增一个字符，<span style=\"color:#fe2c24;\"><strong>append接口是将一个字符串新增到源字符串后。</strong></span></p>\n<p>方法：</p>\n<p>1、首先，我们依然要考虑源字符串是否需要扩容，这次的扩容和push_back的扩容仍有区别，push_back由于只新增一个字符，因此在源字符串大小的基础上扩容2倍是足够的；append如果也是在源字符串的大小上扩容2倍的话并不能保证空间足够，<span style=\"color:#ff9900;\"><strong>因为并不知道新字符串的大小。</strong></span><span style=\"color:#0d0016;\">那么确保新空间的大小一定足够呢？因此我们只需要计算源字符串的_size + 新字符串的_size的和，这个和就是新空间的大小。这也一定能确保新空间足够。</span>因此我们可以使用<span style=\"color:#be191c;\"><strong>reserve接口</strong></span>（该接口实现在 5.1）</p>\n<p><span style=\"color:#0d0016;\">2、只需要修改_size.</span></p>\n<p>代码实现：</p>\n<pre><code class=\"language-cpp\">\t\tvoid append(const char* str)\n\t\t{\n\t\t\tsize_t len = _size + strlen(str);\n\t\t\tif (len &gt; _capacity)\n\t\t\t{\n\t\t\t\treserve(len);\n\t\t\t}\n\t\t\tstrcpy(_str + len, str);\n\t\t\t_size = len;\n\t\t\t//insert(_size, str);\n\t\t}</code></pre>\n<h1 id=\"2.4.%E9%87%8D%E8%BD%BD%20%2B%3D%20%EF%BC%88char*%C2%A0%20str%EF%BC%89\">2.4.重载 += （char*  str）</h1>\n<p>+=字符串实现原理也是直接复用append</p>\n<p>代码实现：</p>\n<pre><code class=\"language-cpp\">\tstring&amp; operator+=(const char* str)\n\t{\n\t\tappend(str);\n\t\treturn *this;\n\t}</code></pre>\n<h2 id=\"2.5.%20insert%20(%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5)\">2.5. insert (任意位置插入)</h2>\n<p><img alt=\"\" height=\"431\" src=\"..\\..\\static\\image\\86a507cf70b44866a84557d010c28154.png\" width=\"1036\"/></p>\n<p><img alt=\"\" height=\"186\" src=\"..\\..\\static\\image\\db95fe72e1364b5cbbdc8967584fa50d.png\" width=\"784\"/></p>\n<h3 id=\"2.5.1%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6\">2.5.1 任意位置插入一个字符</h3>\n<p>方法：</p>\n<p>1、首先：判断pos位置的合法性。</p>\n<p>2、其次：判断是否需要扩容，如果满了则需要扩容（2倍扩即可）</p>\n<p>3、再者：从_size+1位置开始从后往前分别将每个字符向后移动一位，当end等于pos位置时，移动结束</p>\n<p>4、最后：在pos位置插入新字符，修改_size</p>\n<p><img alt=\"\" height=\"458\" src=\"..\\..\\static\\image\\a3933278765240c997f0120acc69245f.png\" width=\"831\"/></p>\n<p> </p>\n<p>代码实现如下：</p>\n<pre><code class=\"language-cpp\">string&amp; insert(size_t pos, char ch)\n{\n\tassert(pos &lt;= _size);\n\t//判断size\n\tif (_size == _capacity)\n\t{\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t}\n\n\tsize_t end = _size+1;\n\twhile (end &gt; pos)\n\t{\n\t\t_str[end] = _str[end-1];\n\t\t--end;\n\t}\n\t_str[pos] = ch;\n\t++_size;\n\treturn *this;\n}</code></pre>\n<p>注：当pos == size时，相当于push_back，因此push_back可以复用insert。 </p>\n<h3 id=\"2.5.2%C2%A0%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2\">2.5.2 任意位置插入一个字符串</h3>\n<p>任意位置插入一个字符串时原理基本和插入一个字符相同，需要注意临界条件即可。</p>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\914aed709363420994ea5a862b904390.png\" width=\"1081\"/></p>\n<p>方法：</p>\n<p>1、首先：判断pos位置的合法性。</p>\n<p>2、其次：判断是否需要扩容，如果满了则需要扩容，这里的扩容和append的扩容原理相同，使用reserve扩。</p>\n<p>3、再者：挪动数据。 依然是从后往前挪。此时end = size + len（len = strlen(str)）,依次将end - len位置的字符挪动到end位置，每挪一个字符，end--，当 end == pos+len - 1时候说明挪动结束。</p>\n<p>4、最后，插入字符串，修改_size即可。</p>\n<pre><code class=\"language-cpp\">\t\tstring&amp; insert(size_t pos, const char* str)\n\t\t{\n\t\t\tassert(pos &lt;= _size);\n\t\t\tsize_t len = strlen(str);\n\t\t\tif (len == 0)\n\t\t\t{\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tif (_size + len &gt; _capacity)\n\t\t\t{\n\t\t\t\treserve(_size + len);\n\t\t\t}\n\t\t\t//挪动数据\n\t\t\tsize_t end = _size + len;\n\t\t\t//while(end &gt;= end+len)\n\t\t\twhile (end &gt; pos+len-1)\n\t\t\t{\n\t\t\t\t_str[end] = _str[end-len];\n\t\t\t\t--end;\n\t\t\t}\n\t\t\t//插入数据  \n\t\t\tsize_t i = 0;\n\t\t\twhile (i &lt; len)\n\t\t\t{\n\t\t\t\t_str[pos+i] = str[i];\n\t\t\t\t++i;\n\t\t\t}\n\t\t\t_size += len;\n\t\t\treturn *this;\n\t\t}</code></pre>\n<h1 id=\"3.%E5%88%A0\">3.删</h1>\n<h2 id=\"3.1%20earse\">3.1 earse</h2>\n<p><img alt=\"\" height=\"916\" src=\"..\\..\\static\\image\\4a514fa1f85e430482f7c73c389ab0a9.png\" width=\"1140\"/></p>\n<p>库中提到了一个npos，我们可以看一下npos到底是什么？</p>\n<p><img alt=\"\" height=\"366\" src=\"..\\..\\static\\image\\8f21ca09103641c3850fd63f1d9be29d.png\" width=\"1095\"/></p>\n<p>npos的大小肯定是大于给定len的大小，因此就是有多少删多少。</p>\n<p>通过库里面的定义，<span style=\"color:#fe2c24;\"><strong>erase的作用是在pos位置往后删除len个字符</strong></span></p>\n<p>其中erase删除可分为这几种情况：</p>\n<p><span style=\"color:#0d0016;\"><strong>情况1</strong></span>：如果len == npos，或者pos + len &gt;= _size，说明要删完，后面删完的话只需要在pos位置赋成 '\\0' 即可。</p>\n<p><img alt=\"\" height=\"525\" src=\"..\\..\\static\\image\\4c1f646d22cd4aaba6f25da6f73ff3d0.png\" width=\"796\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>情况2</strong></span>：没有删完，删除一部分，我们可以定义一个begin = pos + len，让begin 位置的字符赋值给begin - len 位置的字符，当begin == _size时，就自动将 ' \\0 ' 赋值过去了，因此结束的条件是begin &gt; _size。 最后再处理一下 _size -= len </p>\n<p><img alt=\"\" height=\"764\" src=\"..\\..\\static\\image\\f536ea5d46c44c909d2054b14063991c.png\" width=\"790\"/></p>\n<p>代码实现：</p>\n<pre><code class=\"language-cpp\">\t\tstring&amp; earse(size_t pos, size_t len = npos)\n\t\t{\n\t\t\tassert(pos &lt; _size);\n\t\t\tif (len == npos || pos + len &gt;= _size)\n\t\t\t{\n\t\t\t\t_str[pos] = '\\0';\n\t\t\t\t_size = pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize_t begin = pos + len;\n\t\t\t\twhile (begin &lt;= _size)\n\t\t\t\t{\n\t\t\t\t\t_str[begin-len] = _str[begin];\n\t\t\t\t\t++begin;\n\t\t\t\t}\n\t\t\t\t_size -= len;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}</code></pre>\n<h1 id=\"4.%E6%9F%A5\">4.查</h1>\n<h2 id=\"4.1%20%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6\">4.1 查找一个字符</h2>\n<p><img alt=\"\" height=\"450\" src=\"..\\..\\static\\image\\d39d9d5871684f5ea98811b381117ed8.png\" width=\"1107\"/></p>\n<p> </p>\n<p>find查字符串返回第一次出现该字符的下标，这个实现也比较简单。 </p>\n<pre><code class=\"language-cpp\">\t\tsize_t find(char ch,size_t pos = 0)\n\t\t{\n\t\t\tfor (; pos &lt; _size; ++pos)\n\t\t\t{\n\t\t\t\tif (_str[pos] == ch)\n\t\t\t\t{\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn npos;\n\t\t}</code></pre>\n<h2 id=\"4.2%C2%A0%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2\">4.2 查找一个字符串</h2>\n<p>查找子串可以使用C语言中的strstr</p>\n<pre><code class=\"language-cpp\">\t\tsize_t find(const char* str, size_t pos = 0)\n\t\t{\n\t\t\tconst char* p = strstr(_str + pos, str);\n\t\t\t//kmp算法 -- 效率不好 不实用\n\t\t\t//bm算法\n\t\t\tif (p == nullptr)\n\t\t\t{\n\t\t\t\treturn npos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn p - _str;\n\t\t\t}\n\t\t}</code></pre>\n<h2 id=\"4.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\">4.3 字符串比较</h2>\n<p>这里我们比较的是字符的ASCII码值的大小,可以使用strcmp</p>\n<pre><code class=\"language-cpp\">    bool operator&lt;(const string&amp; s1, const string&amp; s2)\n\t{\n\t\treturn strcmp(s1.c_str(), s2.c_str()) &lt; 0;\n\t}\n\tbool operator==(const string&amp; s1, const string&amp; s2)\n\t{\n\t\treturn strcmp(s1.c_str(), s2.c_str()) == 0;\n\t}\n\tbool operator&lt;=(const string&amp; s1, const string&amp; s2)\n\t{\n\t\treturn s1 &lt; s2 || s1 == s2;\n\t}\n\tbool operator&gt;(const string&amp; s1, const string&amp; s2)\n\t{\n\t\treturn !(s1 &lt;= s2);\n\t}\n\tbool operator&gt;=(const string&amp; s1, const string&amp; s2)\n\t{\n\t\treturn !(s1 &lt; s2);\n\t}\n\tbool operator!=(const string&amp; s1, const string&amp; s2)\n\t{\n\t\treturn !(s1 == s2);\n\t}</code></pre>\n<h1 id=\"5.%E6%94%B9\">5.改</h1>\n<h2 id=\"5.1%20reserve\">5.1 reserve</h2>\n<p><img alt=\"\" height=\"361\" src=\"..\\..\\static\\image\\59119e037cc547e58f8cce9a5e84c782.png\" width=\"1046\"/></p>\n<p> reserve作用就是将string的容量扩充到n个。</p>\n<p>方法：首先需要判断n是否大于_capacity，如果n小于等于_capacity则不进行容量修改，如果n大于_capacity，则需要进行扩充到n。</p>\n<p>代码实现：</p>\n<pre><code class=\"language-cpp\">void reserve(size_t n)\n{\n\tif (n &gt; _capacity)\n\t{\n\t\tchar* tmp = new char[n + 1];\n\t\tstrcpy(tmp, _str);\n\t\tdelete[] _str;\n\t\t_str = tmp;\n\n\t\t_capacity = n;\n\t}\n}</code></pre>\n<h2 id=\"5.2%20resize%C2%A0\">5.2 resize </h2>\n<p><img alt=\"\" height=\"385\" src=\"..\\..\\static\\image\\e5697ac0ee374c2b88cdcb2036314d7a.png\" width=\"1042\"/></p>\n<p> </p>\n<p>resize的作用是将字符串的大小调整为n个字符。resize修改的是size。</p>\n<p><span style=\"color:#956fe7;\"><strong>resize和reserve的区别：reserve只对空间进行处理，不影响值；resize不仅会改变空间，还会改变size,会改变字符的值。</strong></span></p>\n<p><span style=\"color:#1a439c;\"><strong>情况1: resize的n大于当前字符串的长度。</strong></span></p>\n<p>用如图举例，s1中存放 hello world，大小只有15个空间，现在要resize(20,'x')，此时空间不够，需要扩容，开辟新空间后将源字符串内容拷贝下来并在后面加满 'x'</p>\n<p><img alt=\"\" height=\"315\" src=\"..\\..\\static\\image\\8ce39e8d7e5e42b7a492e8349efa9ca3.png\" width=\"891\"/><img alt=\"\" height=\"347\" src=\"..\\..\\static\\image\\5efec39310604f73b405695e4e0e805d.png\" width=\"649\"/> </p>\n<p><span style=\"color:#1a439c;\"><strong>情况2: resize的n小于当前字符串_capacity的长度。但是大于字符串_size的长度</strong></span></p>\n<p>如下图所示，在这种情况下，s1的_capacity不会变，而是将_size增加到n,并在字符串后弥补目标字符。</p>\n<p><img alt=\"\" height=\"265\" src=\"..\\..\\static\\image\\9f1446a995ae48e3a821548adefd02a0.png\" width=\"841\"/></p>\n<p><img alt=\"\" height=\"276\" src=\"..\\..\\static\\image\\f600d4c616014b86bd0d260f27122ade.png\" width=\"755\"/> </p>\n<p><span style=\"color:#1a439c;\"><strong>情况3: resize的n小于当前字符串_resize</strong></span></p>\n<p>如下图所示，在这种情况下，s1的_size修改为目标大小n，并改变值，只会保留前n个字符的内容</p>\n<p><img alt=\"\" height=\"483\" src=\"..\\..\\static\\image\\f174cf4d7da6499592521a94d32b4aaf.png\" width=\"783\"/></p>\n<p>在了解resize的作用后，我们也进行了不同情况的分类，模拟实现代码如下：</p>\n<pre><code class=\"language-cpp\">\t\t//扩空间+初始化\n\t    //删除部分数据，保留前n个\n\t\tvoid resize(size_t n,char ch = '\\0')\n\t\t{\n\t\t\tif (n &lt; _size)\n\t\t\t{\n\t\t\t\t_size = n;\n\t\t\t\t_str[_size] = '\\0';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (n &gt; _capacity)\n\t\t\t\t{\n\t\t\t\t\treserve(n);\n\t\t\t\t}\n\t\t\t\tfor (size_t i = _size; i &lt; n; ++i)\n\t\t\t\t{\n\t\t\t\t\t_str[i] = ch;\n\t\t\t\t}\n\t\t\t\t_size = n;\n\t\t\t\t_str[_size] = '\\0';\n\t\t\t}\n\t\t\t\n\t\t}</code></pre>\n<p> （本篇完）</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-25 15:59:30", "summary": "上一篇博文内容：类的构造，拷贝，赋值拷贝，及其模拟实现类之构造，拷贝，赋值及其模拟实现类之构造，拷贝，赋值及其模拟实现本篇内容：类的常见接口及其模拟实现，我将会从遍历，增，删，查，改个方面对常见，常用"}